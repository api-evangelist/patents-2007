---

title: Enterprise performance management software system having dynamic code generation
abstract: An enterprise software system provides dynamic code generation techniques that facilitate quick and efficient resolution of multi-dimensional data demands. The system includes an object store that stores a first object that references multi-dimensional data and an object model that receives a request for multi-dimensional data referenced by the first object. The object model causes the first object to dynamically generate a portion of the executable software instructions for a second object in response to the request and instantiate the second object within the object store. The dynamically generated portion of the instructions enables the second object to calculate a memory address into the multi-dimensional data referenced by the first object. The second object utilizes the dynamically generated portion of the instructions to satisfy the request. Because the second object maintains direct access to the multi-dimensional data, it need not make costly and time consuming function calls to the first object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918755&OS=08918755&RS=08918755
owner: International Business Machines Corporation
number: 08918755
owner_city: Armonk
owner_country: US
publication_date: 20070130
---
This application claims the benefit of U.S. Provisional Application Ser. No. 60 852 146 filed Oct. 17 2006 the entire content of which is incorporated herein by reference.

The invention relates to enterprise computing environments and more particularly to enterprise performance management systems.

Enterprise software systems are typically sophisticated large scale systems that support many e.g. hundreds or thousands of concurrent users. Examples of enterprise software systems include financial planning systems budget planning systems order management systems inventory management systems sales force management systems business intelligence tools enterprise reporting tools project and resource management systems and other enterprise software systems.

Many enterprise performance management and business planning applications require a large population of users to enter data that the software then accumulates into higher level areas of responsibility in the organization. The system may perform mathematical calculations on the data combining data submitted by one user with data submitted by another. Using the results of these calculations the system may generate reports for review by higher management.

A computing device for a user typically connects to the enterprise software system via a computing network. The user computing device may provide an operating environment for concurrent execution of multiple planning applications that access multidimensional data stored to a cache on the computing device. Typically the user computing device includes a cache to store datasets requested by the user. In many cases the cache stores complex multi dimensional datasets i.e. data cubes which may be downloaded from the enterprise software system via the network connection.

Frequently the planning applications perform operations that access and manipulate the multidimensional datasets. To perform these operations software executing on the computing device may create and maintain additional multi dimensional datasets within the cache to temporarily hold the subset of the data being manipulated. The software also creates software reference objects also referred to as data provider objects that enable access to the multi dimensional data. Commonly other software objects frequently interact with the reference objects via numerous function calls to traverse the multidimensional data and to retrieve the underlying multidimensional data.

In general enterprise planning and performance management techniques are described that utilize dynamic code generation to reduce the extensive calls between software objects when traversing and accessing multi dimensional data.

According to the techniques an object model maintains one or more reference objects within an object store where each of these reference objects correspond to multi dimensional data. The reference objects are aware of the dimensionality of the data and operate as data providers by servicing requests from other objects to retrieve the multidimensional data.

Dynamic code generation techniques are described that enable the object model to cause a first software object that references multi dimensional data to dynamically generate a portion of the executable software instructions for a second object. The dynamically generated portion of the executable software instructions enables the second object to directly calculate offsets into the multidimensional data space maintained by the first object. Through the use of this technique the object model may more quickly and efficiently satisfy multi dimensional data requests. For example the second object need not make resource and time consuming function calls to the first object in order to traverse the dimensions of the multi dimensional data.

In response to a multi dimensional data request the object model selects the appropriate reference object associated with the requested multi dimensional data and invokes that object to return the requested data. The object model typically returns the requested data by creation of a new object. At this time the object model causes the first object to dynamically generate executable software instructions for inclusion within the new object. Moreover the first object e.g. the data provider object generates the executable software instructions based on the particular dimensionality and arrangement of the multidimensional data that it references. The dynamically generated executable software instructions enables the second object to directly calculate indices into the multidimensional data space referenced by the first object.

After dynamically generating the portion of the executable software instructions the first object instantiates the second object whereupon the second object facilitates the retrieval of the requested data by utilizing the dynamically generated portion of its executable software instructions to directly compute indices into the multi dimensional data referenced by the first object. In one embodiment this technique is dynamic in that the first object e.g. the data provider generates the executable software instructions during run time in response to a data access request instead of compile time. It is also dynamic in that the code is generated based on the current run time state of the multi dimensional data being retrieved e.g. the dimensionality of the data. These dynamic code generation techniques may more quickly and efficiently traverse multidimensional data because they avoid function calls typically required to move the data provider through the multidimensional space such as a MoveNext call that is often necessary between data retrieval. Instead the second object is instantiated so that its dynamically generated executable software instructions which were generated based on the dimensionality and arrangement of the data directly calculate indices within the requested multi dimensional data. Thus the second object need only call the data provider to retrieve the data using the calculated indices and need not repeatedly call the data provider to traverse the underlying multidimensional data using MoveNext calls or other functions.

In one embodiment a computer implemented method comprises receiving a request for multi dimensional data referenced by a first object and dynamically generating a portion of the executable software instructions for a second object with the first object that references the multi dimensional data in response to the request wherein the portion of the executable software instructions enables the second object to calculate a memory address into the multi dimensional data referenced by the first object. The method further comprises instantiating the second object within an object store of an enterprise planning system wherein the second object includes the dynamically generated portion of the executable software instructions and utilizes the dynamically generated portion of the executable software instructions to satisfy the request.

In another embodiment a computing system comprises an object store that stores a first object that references multi dimensional data and an object model that receives a request for multi dimensional data referenced by the first object and causes the first object to dynamically generate a portion of the executable software instructions for a second object in response to the request and instantiate the second object within the object store wherein the portion of the executable software instructions enables the second object to calculate a memory address into the multi dimensional data referenced by the first object and further wherein the second object includes the dynamically generated portion of the executable software instructions and utilizes the dynamically generated portion of the executable software instructions to satisfy the request.

In another embodiment the invention is directed to a computer readable medium containing instructions. The instructions cause a programmable processor to receive a request for multi dimensional data referenced by a first object and dynamically generate a portion of the executable software instructions for a second object with the first object that references the multi dimensional data in response to the request wherein the portion of the executable software instructions enables the second object to calculate a memory address into the multi dimensional data referenced by the first object. The instructions further cause the processor to instantiate the second object within an object store of an enterprise planning system wherein the second object includes the dynamically generated portion of the executable software instructions and utilizes the dynamically generated portion of the executable software instructions to satisfy the request.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

For exemplary purposes the invention is described in reference to an enterprise planning and performance management system such as an enterprise financial or budget planning system. The techniques described herein may be readily applied to other software systems including other large scale enterprise software systems. Examples of enterprise software systems include order management systems inventory management systems sales force management systems business intelligence tools enterprise reporting tools project and resource management systems and other enterprise software systems.

In general enterprise planning and performance management system enables and automates the reconciliation of top down targets with detailed bottom up forecasts for an enterprise. Enterprise planning and performance management system implements and manages an enterprise planning process which can be divided into three functions 1 modeling 2 contribution and 3 reconciliation.

Initially high level enterprise managers or executives referred to as analysts define organizational targets and build planning models for the enterprise. The analysts may include for example financial analysts such as the chief financial officer senior financial analysts or product and sales analysts. More specifically the analysts develop a model having a number of hierarchically arranged nodes representing various cost centers within the organization such as business units or departments. The analysts specify corporate target data for each node of the organizational hierarchy. Corporate target data may include financial data revenue data order data inventory data and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Next the analysts assign one or more enterprise users to each node such as managers supervisors sales representatives lab managers or the like that are responsible for enterprise planning for the cost center corresponding to the node. Each enterprise user may be designated as a contributor that provides planning data to enterprise planning and performance management system a reviewer that accepts or rejects contributions from the contributors or both. The contributors and reviewers may be authorized users within the enterprise or within other entities coupled to network such as suppliers or customers.

Typically enterprise users that are designated as contributors interact with enterprise planning and performance management system to input detailed forecasts in the form of contribution data. As described above enterprise users may provide detailed financial forecasts revenue forecasts order forecasts inventory forecasts estimated resource requirements and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Enterprise planning and performance management system automates the reconciliation of the forecast data with the corporate target data provided by the analysts. In particular enterprise planning and performance management system operates in accordance with a defined model i.e. the enterprise planning model created by the analysts to provide a hierarchical planning process having multiple reconciliation levels. As each of the contributors provides his or her contribution data enterprise planning and performance management system automatically aggregates the contribution data across the enterprise in real time and provides access to the aggregated data to enterprise users designated as reviewers associated with higher levels of the enterprise. In particular upon receiving contribution data from the contributors enterprise planning and performance management system identifies all higher levels of the organizational model affected by the newly received contribution data and calculates new aggregate totals at each level in real time.

Consequently the reviewers view aggregated data across the enterprise in real time during the enterprise planning session. At each level enterprise planning and performance management system ensures that the reviewers as defined by the nodes of the enterprise model reconcile the target data with the forecast data. Each of the reviewers may for example reject or accept the contribution data in view of corporate targets provided by the analysts. This process continues until the contribution data is ultimately approved by the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets provided by the analysts.

In this manner enterprise planning and performance management system may provide more accurate enterprise planning than with conventional techniques. For example enterprise planning and performance management system may improve the accuracy and predictability of enterprise planning by enabling organizations to reconcile corporate models and organizational targets with detailed forecasts. The techniques may provide a platform that delivers collaborative real time planning capabilities without requiring offline consolidation and aggregation of forecasts. Because enterprise planning and performance management system can aggregate contribution data in real time all users can be presented with an accurate up to date view of the numbers. Further the architecture of enterprise planning and performance management system can readily scale to thousands of users and may be designed around best planning practices. In addition the techniques enabling high participation by enterprise users i.e. the contributors and reviewers allowing accurate planning cycles to be reduced

Enterprise users may utilize a variety of computing devices to interact with enterprise planning and performance management system via network . For example an enterprise user may interact with enterprise planning and performance management system using a laptop computer desktop computer or the like running a web browser such as Internet Explorer from Microsoft Corporation of Redmond Wash. Alternatively an enterprise user may use a personal digital assistant PDA such as a Palm organizer from Palm Inc. of Santa Clara Calif. a web enabled cellular phone or similar device.

Network represents any communication network such as a packet based digital network like the Internet. In this manner system can readily scale to suit large enterprises. Enterprise users may directly access enterprise planning and performance management system via a local area network or may remotely access enterprise planning and performance management system via a virtual private network remote dial up or similar remote access communication mechanism.

Enterprise planning and performance management system may utilize a cut down process by which the multi dimensional data store is sliced for each user in accordance with the defined enterprise model. During this process enterprise planning and performance management system identifies areas of the defined model to which users are assigned either as contributors or reviewers and slices the data store based on the assignments. When a given user logs in and proceeds with an enterprise planning activity enterprise planning and performance management system communicates the respective data slice to the respective computing device for display to the user via the extended spreadsheet application. In this fashion enterprise planning and performance management system need not communicate the entire model to each of users thereby reducing communication time as well as resource requirements. Instead each user receives only relevant information. Users interact with computing devices to capture contribution data and to reconcile the contribution data with organizational targets.

As described herein each of computing devices utilize dynamic code generation to reduce the extensive calls between software objects when traversing and accessing multi dimensional data. Typically within computing devices planning applications interact with an application programming interface API to issue requests to an object model all of which are described in more detail below in reference to . The object model maintains one or more objects within an object store where each of these objects reference multi dimensional data. In response to a data access request the object model selects an appropriate object that references the requested multi dimensional data and causes that object to return the requested multidimensional data. In returning the requested data the object model causes the reference object to dynamically generate a portion of the executable software instructions for a second object. The dynamically generated portion of the executable software instructions enables the second object to directly calculate offsets into the multidimensional data space maintained by the first object. Through the use of this technique the object model may more quickly and efficiently satisfy multi dimensional data requests. For example the second object need not make resource and time consuming function calls to the first object in order to traverse the dimensions of the multi dimensional data.

In one embodiment these dynamic code generation techniques are dynamic in that the first object generates the executable software instructions during run time in response to a data access request instead of at compile time. It is also dynamic in that it generates the executable software instructions based on the current run time state of the multi dimensional data being retrieved. These dynamic code generation techniques may more quickly and efficiently traverse multidimensional data because they avoid function calls typically required to move the data provider through the multidimensional space such as a MoveNext call that is often necessary between data retrieval. Instead the second object is instantiated so that it s dynamically generated executable software instructions which were generated based on the dimensionality and arrangement of the data directly calculate indices within the requested multi dimensional data. Thus the second object need only call the data provide to retrieve the data using the calculated indices and need not repeatedly call the data provider to traverse the underlying multidimensional data using MoveNext calls or other functions. Because computing devices typically access and manipulate large amounts of multi dimensional data eliminating or reducing the number of inter object calls associated with traversing the multidimensional data and updating reference information within the reference object may significantly increase the speed and efficiency of retrieving multidimensional data.

Planning applications represent planning applications executing on computing device A. For example planning applications may include reporting tools modeling tools spreadsheet applications data collection templates business intelligence tools or other types of enterprise planning applications.

Object model interface comprises an application programming interface API that exposes object model . For example object model may be a metadata model for datasets that represent multidimensional data from one or more data cubes. Object store may comprise memory such as a cache that stores specific instantiations of object model .

In general object model represents any hierarchy of data objects and may comprise a series of collections and objects within the collections. In other words object model may comprise a hierarchy of objects each of which contains a collection which in turn provides access to one or more objects. Object model may be wrapped to protect the objects within the collections. In this way user A and planning applications cannot directly alter the data within object model . Instead planning applications interact with object model via object model interface and more particularly API to specify operations object model may perform. In particular object model interface receives operation calls from planning applications via API and may return the result of the operations to planning applications . Typically these operation calls constitute requests for multi dimensional data referenced by one or more of the below described objects stored in object store .

In the example of enterprise planning user A may interact with web browser to enter and manipulate enterprise planning data such as budget or forecast data. Datasets contain multidimensional planning data which may include top down targets and bottom up contribution data and allows all calculations for an enterprise planning session to be performed locally by computing device A. Therefore in this example a contributor can modify his or her respective contribution data and perform calculations necessary for the enterprise planning process without necessarily accessing enterprise planning system . User A may save the planning data locally and submit the planning data to enterprise planning system for aggregation with the planning data from other users .

Enterprise planning system automatically aggregates the contribution data across enterprise in real time and provides access to the aggregated data to reviewers associated with higher levels of the enterprise. This process continues until the contribution data is ultimately approved by the reviewers associated with the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets.

In one embodiment calculation engine and datasets are loaded for use during the enterprise planning session. Calculation engine may for example comprise a forward calculation engine wrapped in an Active X object built in an array based language. In other embodiments calculation engine may be implemented by creating layered function datasets within object store .

As illustrated in object store includes a variety of software objects. In this example object store includes datasets virtual datasets and indexer objects . Datasets each represent objects for storing data in a multi dimensional format e.g. in a format having multiple dimensions where each dimension may have a hierarchy of levels and members. Datasets may be loaded onto computing device A from enterprise planning system or may result from operations performed on other datasets or virtual datasets .

Virtual datasets each store information relating to the result of an operation applied to one or more datasets possibly in combination with other virtual datasets . Moreover virtual datasets may be manipulated by planning applications as if actual datasets. For example planning applications may perform selection operations time series operations discreet mathematical operation e.g. addition or subtraction appending or dataset combination operations and many other operations so as to manipulate multidimensional data. Planning applications may layer function operations utilizing the virtual datasets so as to perform complex mathematical operations involving numerous discreet mathematical operations.

However unlike datasets virtual datasets are represented in as dashed boxes and termed virtual because they do not actually store multidimensional data that resulted from the operation. To the contrary a virtual dataset only stores information necessary to resolve and retrieve the resultant multidimensional data from the underlying multidimensional datasets that were originally used as inputs to the operation that produced the respective virtual dataset. Because virtual datasets do not store the resultant multidimensional data but only refer to it virtual datasets may occupy less space in a cache not shown in of computing device A. Further as described below computing device A need not resolve the result i.e. access the underlying hierarchy of data objects referred to by virtual datasets until planning applications subsequently attempt to retrieve the underlying data. Moreover because virtual datasets only store a reference to the data objects object store need not repeatedly synchronize virtual datasets upon altering editing and or updating data objects referenced by virtual datasets and stored within datasets . Exemplary virtual datasets are described in detail within U.S. patent applicant Ser. No. 11 564 011 filed Nov. 28 2006 entitled VIRTUAL MULTIDIMENSIONAL DATASETS FOR ENTERPRISE SOFTWARE SYSTEMS the content of which is incorporated herein by reference.

Planning applications specify operations that object model performs upon datasets and virtual datasets through interactions with object model interface . As one example API of object model interface provides the following syntax by which planning applications may specify a selection operation 

Planning applications specify the and fields of the .Select method or selection operation. The and fields may accept any of datasets and virtual datasets . As described below the selection operation may accept multiple datasets via the field thereby allowing planning applications to specify dataset projections through the use of the selection operation as described in more detail below. The field may be referred to as the argument list of the selection operation in these and other instances. The field requires that planning applications specify a unique name or handle for an object by which planning applications may later access the result of the selection operation.

In this example the object identified by the field comprises a virtual dataset however in some embodiments the object identified by the field may comprise a dataset as well. In these embodiments object model may require that object model interface indicate whether to resolve the virtual dataset indicated in the field. If object model interface indicates that the resulting virtual dataset should be resolved object model will build a dataset containing the items referred to by the resulting virtual dataset. Planning applications issue this select command to object model interface via API which in turn causes object model to perform the select and instantiate a new virtual dataset in object store containing the reference to one or more of datasets .

Object model also instantiates indexer objects that provide object interfaces for maintaining references e.g. indices into datasets and virtual datasets where one or more of indexer objects may reference the same dataset or virtual dataset. For example datasets may each be instantiations of classes implementing IDataset interfaces. The IDataset interface provides a getIndexer method to instantiate one of indexer objects and associate the newly instantiated one of indexer objects to the calling one of datasets . In some embodiments the getIndexer method may return an instantiation of a previously defined custom indexer class that was dynamically generated with the appropriate references to dataset . That is the getIndexer method may dynamically generate a custom indexer class at runtime and then instantiate an instance of the custom indexer class. Subsequent invocations of the first function to instantiate the indexer object may not need to regenerate the custom indexer class. The IDataset interface also provides a getElement method that accepts an Indexer object as a parameter. Upon invoking the getElement method by passing an indexer object the getElement method returns value of the data element referenced by the indices of the passed indexer object .

Indexer objects may each be instantiations of classes implementing the IIndexer interface where the IIndexer interface provides a moveNext method for traversing the multidimensional data of a dataset or virtual dataset. When the moveNext method is invoked the called indexer object moves or updates its reference to an associated one of datasets such that the reference references the next data element within datasets . The moveNext method may not necessarily move the reference to the sequential next data element of the associated dataset but may instead move the reference according to some pre defined pattern specified by the indexer. In other embodiments a custom view of a dataset may be defined. In some cases an indexer may sequentially follow a pattern described by the custom view yet traverse the underlying dataset in a non sequential pattern. Moreover the indexer may not necessarily traverse all of the elements of the dataset and may access some of the elements multiple times depending on the defined view.

Object model next invokes the getElement method of the appropriate one of datasets passing the associated indexer object as a parameter for the getElement method. Upon invoking the getElement method the appropriate dataset safely returns the value of the requested data element referenced by the associated indexer object . Safely above refers to safely returning a type specific object instead of a generic object which would not ensure type safety. Thus safely refers to type safety. This double dispatch data retrieval technique enables compilers to determine type safety of the underlying classes at compile time unlike conventional data retrieval techniques that do not support type safety determination during compile time. By enabling type safety checks at compile time object model may safely invoke a generic indexer object without fear of violating type safety concerns during run time unlike conventional data retrieval techniques that may encounter debilitating type safety issues during run time with little recourse.

Exemplary indexer objects are described in detail within U.S. patent applicant Ser. No. 11 563 485 filed Nov. 27 2006 entitled ENTERPRISE PLANNING AND PERFORMANCE MANAGEMENT SYSTEM PROVIDING DOUBLE DISPATCH RETRIEVAL OF MULTIDIMENSIONAL DATA the content of which is incorporated herein by reference.

As described herein a dataset or virtual dataset may create a custom indexer class by dynamically generating code defining the indexer class. The dynamically generated executable software instructions defining the indexer class may include multiple shortcuts that save time and or computing resources in maintaining reference information with respect to the underlying dataset or virtual dataset such as in response to invocation of a moveNext call.

The dynamically defined indexer class is produced to include executable software instructions that enable one or more indexer objects to be instantiated with the coded shortcuts. In some circumstances these shortcuts for example enable indexer objects to update indices into the multidimensional data space of datasets or virtual datasets without having to make function calls to the underlying dataset that physically stores the multi dimensional data.

For example as generic objects indexer objects can be invoked to traverse any type of dataset or virtual dataset . When a planning application invokes a moveNext function of an indexer object to update the objects indices with respect to a particular dataset or virtual dataset the indexer object typically invokes the dataset or virtual dataset to re compute the indices based on the particular dimensionality and structure of the underlying multidimensional data. However in accordance with the techniques described herein the invoked indexer object first determines whether the particular dataset or virtual dataset being traversed is the same dataset or virtual dataset that created the class on which the indexer object is based. If so the indexer object avoids the inter object call to the dataset or virtual dataset to re compute the indexer s indices. Instead the indexer object invokes the executable instructions that were dynamically generated when the indexer s class was generated. The executable instructions of the indexer class were generated based on the dimensionality and structure of the dataset that created the class and therefore are able to directly update the indices of the instantiated indexer object . This code may allow for example the instantiated indexer object to quickly perform its defined moveNext function by adding an offset or some multiple thereof to a stored base address given the codes awareness of the dimensions levels and members of the referenced data thereby avoiding function calls to the underlying dataset that stores the referenced multi dimensional data.

Examples of virtual dataset supported by API of object model interface include virtual function datasets and virtual selection datasets. For example API provides the following syntax by which planning applications may specify a function operation to build virtual function dataset objects 

Planning applications specify dataset the and fields of the above function operation. The and fields may each accept any dataset and or a virtual dataset object such as virtual selection datasets virtual function datasets objects and or aggregation datasets objects. Planning applications may specify any sort of discreet mathematical operation in the field such as addition subtraction multiplication division etc. The field requires that planning applications specify a unique name by which planning applications may later access the result of the function operation. Planning applications may layer function operations to perform complex mathematical operations involving numerous discreet mathematical operations.

The function operation returns a virtual function dataset object having a placeholder for storing reference information should object model receive a demand for multi dimensional data referenced by the newly created virtual function dataset object. Upon receiving a demand for multi dimensional data referenced by the newly created virtual function dataset object model resolves i.e. determines the references to the multi dimensional data for the appropriate one of the virtual function dataset objects. Typically during resolution of the newly created virtual function dataset object this object passes in turn a code object to each virtual dataset and or dataset defined in the and fields above where each of these datasets dynamically generate the executable software instructions for virtual function dataset object.

For example the virtual function dataset object may pass a code object to one of the virtual selection dataset objects specified in the field whereupon this virtual selection dataset object or more generally a first object dynamically generates a portion of the executable software instructions for the virtual function dataset object or more generally a second object. Next the virtual function dataset object may pass the same code object to another virtual selection dataset object or more generally a third object whereupon it dynamically generates another portion of the code for the virtual function dataset object or again the second object. In both instances the first and third objects may generate a portion of the code for a data provider element of the virtual function dataset object that enables the data provider element to calculate memory addresses directly into the memory space referenced by both the first and third virtual dataset objects without having to make function calls to both of these objects in order to access their referenced multi dimensional data. The first and third objects return this code to the virtual function dataset object via the code object originally passed to them or in some instances the code object may be passed by reference thereby allowing edits to the code object without having to pass the code object back to the virtual function dataset object.

Upon dynamically generating the executable software instructions for the data provider element the virtual function dataset object may quickly and efficiently access the multi dimensional data for both datasets defined in the and via the data provider element that incorporates the dynamically generated portions of code. The virtual function dataset object may satisfy the demand by utilizing the data provider element to quickly and directly access the underlying multi dimensional data referenced by both the first and third objects applying the function defined in the field and returning the result of applying the function to the multi dimensional data to the object model. Although not described explicitly herein virtual function dataset objects may be utilized in this manner to quickly perform complex mathematical operations through the use of layered function operations.

Planning applications may also specify aggregation dataset objects via API in a manner similar to specifying virtual selection and function dataset objects. Unlike virtual dataset objects aggregation dataset objects store the underlying multi dimensional data instead of a reference to the multi dimensional data. Upon specifying the aggregation dataset objects via API object model creates an aggregation dataset object but does not include a placeholder for reference information as aggregation dataset objects require no reference information. Instead object model creates a placeholder for storing the actual multi dimensional data which it will populate upon receiving a demand for multi dimensional data stored to the aggregation dataset object.

Upon receiving such a demand object model may invoke a populate function of the appropriate aggregation dataset object where the populate function may pass a code object to those virtual datasets and or datasets to be aggregated into the aggregation dataset object. Similar to the dynamic code generation technique described above in reference to virtual function dataset objects each source dataset object of the aggregate operation or more generally a first object dynamically generates the executable software instructions for the aggregation dataset object or more generally a second object. Once all of the source dataset objects have dynamically generated their portion of the code the aggregation dataset object may utilize the code to build a data provider element that quickly and efficiently employs the coded shortcuts to directly calculate memory addresses into the memory space of the multi dimensional data referenced and or stored by the respective virtual datasets and or datasets defined in the fields of the aggregate operation. Using the data provider aggregation dataset objects may populate their placeholder with the requested data and return this data to object model to satisfy the demand.

In this manner computing device A may utilize these dynamic code generation techniques to quickly access multi dimensional data and efficiently satisfy demands for various forms of multi dimensional data. In the instance of virtual selection dataset objects dynamically generated custom indexer class code may instantiate indexer objects that provide quick and efficient access to multi dimensional data defined by a selection operation. In the instance of virtual function dataset objects dynamically generated code portions may define portions of a data provider for quickly and efficiently accessing multi dimensional data upon which it applies a defined function. Similarly in the instance of aggregation dataset objects the dynamically generated code portions may define portions of a data provider for quickly and efficiently accessing multi dimensional data used to populate its placeholder. In each instance the dynamically generated executable software instructions enables quick and efficient access by enabling direct access to the multi dimensional data without having to make costly and time consuming function calls.

While the technique described above includes passing a code object to dynamically generate code for virtual selection dataset objects and aggregation dataset objects in other embodiments both virtual selection dataset objects and aggregation dataset objects may infer the dimensionality and references to the underlying data thereby generating the code themselves. That is virtual selection dataset objects may for example already have access to this information via the datasets defined in the and fields. Using these references to the and fields virtual selection dataset objects may access their respective dimensionality and references to the underlying data and dynamically generate the code based on this information. Similarly aggregation dataset objects may also dynamically generate the above code through access to the datasets defined in its field. Thus the invention should not be limited strictly to passing a code object but may include other methods by which the code is dynamically generated.

Initially object model receives an operation such as one of the above described selection function or aggregate operations via API from one of planning applications . Upon receiving the operation object model creates and stores the virtual dataset object such as respective virtual selection or function datasets objects or a dataset object such as an aggregation dataset object in object store . After storing these objects object model returns a reference to the newly created object in the form of a handle as described above .

Next object model waits to receive a request pertaining to the newly created one of objects which is commonly referred to as a demand. If no demand is received object model may receive other operations and perform the above described actions to create and store other virtual datasets and or datasets NO . However upon receiving a request for multi dimensional data either referenced or stored by the newly created one of objects or first object i.e. receive a demand for this multi dimensional data YES object model invokes the relevant function to cause the first object to satisfy the demand. In all instances the first object dynamically generates a portion of the executable software instructions for a second object such as indexer object in the instance the demand requests multi dimensional data referenced by one of virtual selection datasets objects .

After dynamically generating the portion of the executable software instructions for the second object the first object instantiates the second object within object store such that the second object includes the dynamically generated portion of the code . The second object which as described herein may include an indexer object a virtual function dataset object or an aggregate object utilizes the dynamically generated portion of the code to satisfy the demand . Typically the second object utilizes the dynamically generated portion of the code to calculate memory addresses directly into the memory space that stores the requested i.e. demanded multi dimensional data without having to make any function calls to the object that stores the multi dimensional data as described above. Thus the dynamically code generation techniques facilitate quick and efficient demand resolution by enabling such resolution without making possibly thousands if not more function calls to the objects that reference and or store the multi dimensional data.

Next object model waits to receive a demand for multi dimensional data referenced by the newly created virtual selection dataset object. If no demand is received object model may continue to create and store virtual selection dataset objects or any other object described herein NO . However assuming object model receives a demand for multi dimensional data referenced by the newly created virtual selection dataset object YES object model resolves i.e. determines the references to the multi dimensional data for the newly created virtual selection dataset objects. Typically during resolution of the newly created virtual selection dataset object this first object instantiates a new indexer object or a second object via its interface s getIndexer function.

This new indexer object creates a custom indexer class by dynamically generating code defining the indexer class and may do so either as a part of its instantiation not shown in or after object model receives the demand of . The dynamically generated code defining the indexer class may include multiple shortcuts that save time should one of planning applications demand the multi dimensional data referenced by the newly created virtual selection dataset object.

The getIndexer function of the interface provided by a virtual selection dataset object constitutes a first function for instantiating a new indexer object . The getIndexer function compiles the dynamically generated code defining the custom indexer class instantiates an indexer object and passes the newly instantiated indexer object out to the newly created virtual selection dataset object in the form of a handle . The virtual selection dataset utilizes the newly instantiated indexer object to satisfy the demand which in turn causes the indexer object to utilize its dynamically generated portion of its code .

Typically the dynamically generated executable software instructions define an indexer class that enables the instantiated indexer object to perform the coded shortcuts where most of the shortcuts typically enable indexer objects to calculate a memory address into the memory space that stores the multi dimensional data referenced by the first object or virtual selection dataset object without having to make function calls to the underlying dataset that physically stores the multi dimensional data. Moreover this code may result in an instantiated indexer object capable of quickly performing its defined moveNext function by adding a set value or some multiple thereof to a stored base address thereby again avoiding function calls to the underlying dataset that stores the referenced multi dimensional data.

As shown in object store also stores virtual function dataset object . Although shown as storing a single object object store may store multiple virtual function dataset objects similar to virtual function dataset object and the invention should not be limited as such. Virtual function dataset object includes a data provider element that implements the dynamically generated portion of the code described above. Typically in response to a function operation an object model such as object model creates and stores virtual function dataset to object store . Upon being stored to object store virtual function dataset object may not initially include data provider element as no demand has yet been received for multi dimensional data referenced by virtual function dataset object . Thus illustrates a virtual function dataset object after object model received a demand for multi dimensional data referenced by virtual function dataset object .

Assuming for purposes of illustration that a demand has been received object model invokes a function via the handle associated with virtual function dataset object to satisfy the demand. In response to this invocation virtual function dataset object passes a code object to those virtual datasets and datasets specified in the fields of the function operation where each of these virtual datasets and or datasets dynamically generate the code for data provider element . Although described in reference to two source datasets for purpose of example virtual function datasets do not require two source datasets and may utilize a single source dataset e.g. a square root function or more than two source datasets.

For example virtual function dataset object passes a code object to virtual dataset objects A specified in the field whereupon this virtual dataset object A or more generally a first object dynamically generates a portion of the code for virtual function dataset object or more generally a second object. In addition virtual function dataset object may pass the same code object to dataset object N or more generally a third object whereupon it dynamically generates another portion of the code for virtual function dataset object or more generally the second object. In both instances the first and third objects may generate a portion of the code for data provider element of virtual function dataset object that enables data provider element to calculate memory addresses directly into the memory space referenced by both first and third objects A N respectively without having to make function calls to both of these objects A N in order to access their respective referenced and stored multi dimensional data. The first and third objects return this code to the virtual function dataset object via the code object originally passed to them or in some instances the code object may be passed by reference thereby allowing edits to the code object without having to pass the code object back to virtual function dataset object .

Upon dynamically generating the code for data provider element virtual function dataset object may quickly and efficiently access the multi dimensional data for both datasets defined in the and via data provider element that incorporates the dynamically generated portions of code. Virtual function dataset object may satisfy the demand by utilizing data provider element to quickly and directly access the underlying multi dimensional data referenced by both the first and third objects applying the function defined in the field and returning the result of applying the function to the multi dimensional data to object model . Although illustrated in as referencing one of each of virtual dataset objects and dataset objects by the use of arrowed lines virtual function dataset object may reference two of virtual dataset objects or two of dataset objects and the invention should not be limited strictly to the illustrated embodiment.

Next object model waits to receive a demand for multi dimensional data referenced by the newly created virtual function dataset object . If no demand is received object model may continue to create and store virtual function dataset objects or any other objects described herein NO . However assuming object model receives a demand for multi dimensional data referenced by the newly created virtual function dataset object YES object model resolves i.e. determines the references to the multi dimensional data for virtual function dataset object . Typically during resolution of the newly created virtual function dataset object object passes a code object to each virtual dataset and or dataset defined in the and fields above where each of these datasets dynamically generate the code for data provider element of virtual function dataset object .

For example virtual function dataset object may pass a code object to one of virtual dataset objects specified in the field whereupon virtual dataset object A for example or more generally a first object dynamically generates a portion of the code for virtual function dataset object or more generally a second object . Next the virtual function dataset object may pass the same code object to dataset object N for example or more generally a third object whereupon it dynamically generates another portion of the code for virtual function dataset object or more generally the second object . In both instances the first and third objects may generate a portion of the code for a data provider element of virtual function dataset object that enables the data provider element to calculate memory addresses directly into the memory space referenced by both the first and third dataset objects A N without having to make function calls to both of these objects in order to access their referenced multi dimensional data. The first and third objects return this code to the virtual function dataset object via the code object originally passed to them or in some instances the code object may be passed by reference thereby allowing edits to the code object without having to pass the code object back to virtual function dataset object .

Upon dynamically generating the code for the data provider element virtual function dataset object may quickly and efficiently access the multi dimensional data for both datasets defined in the and via data provider element that incorporates the dynamically generated portions of code. Virtual function dataset object may satisfy the demand by utilizing data provider element to quickly and directly access the underlying multi dimensional data referenced by both the first and third objects applying the function defined in the field and returning the result of applying the function to the multi dimensional data to the object model thereby satisfying the demand .

In the example of object store stores aggregation dataset object . Although shown as storing a single object object store may store multiple aggregation dataset objects similar to aggregation dataset object and the invention should not be limited as such. Aggregation dataset object includes a data provider element that implements the dynamically generated portion of the code described above. Typically in response to an aggregation operation an object model such as object model creates and stores virtual function dataset to object store . Upon being stored to object store aggregation dataset object may not initially include data provider element as no demand has yet been received for multi dimensional data referenced by aggregation dataset object . Thus illustrates an aggregation dataset object after object model received a demand for multi dimensional data referenced by aggregation dataset object .

Assuming for purposes of illustration that a demand has been received object model invokes a populate function via the handle associated with aggregation dataset object to satisfy the demand. In response to this invocation aggregation dataset object passes a code object to one or more of virtual dataset objects and or dataset objects to be aggregated into aggregation dataset object . Similar to the dynamic code generation technique described above in reference to virtual function dataset objects of each source dataset object of the aggregate operation or more generally a first object dynamically generates the code for aggregation dataset object or more generally a second object. An aggregation operation typically has only a single source e.g. aggregation of sales over all products . However aggregation may be performed using two or more source dataset objects.

Once all of the source dataset objects have dynamically generated their portion of the code aggregation dataset object may utilize the code to build data provider element that quickly and efficiently employs the coded shortcuts to directly calculate memory addresses into the memory space of the multi dimensional data referenced and or stored by the respective virtual dataset objects and or dataset objects defined in the fields of the aggregate operation. Using data provider element aggregation dataset object may populate the placeholder with the requested data and return this data to object model to satisfy the demand.

For example aggregation dataset object may pass a code object to one of virtual dataset objects specified in the field whereupon virtual dataset object A for example or more generally a first object dynamically generates a portion of the code for aggregation dataset object or more generally a second object. In some cases aggregation dataset object may pass the same code object to another dataset object e.g. dataset object N for example or more generally a third object whereupon it dynamically generates another portion of the code for aggregation dataset object or more generally the second object.

In such instances the source object s may generate a portion of the code for data provider element of aggregation dataset object that enables data provider element to calculate memory addresses directly into the memory space referenced by both the source dataset objects e.g. dataset objects A N in this example without having to make function calls to both of these objects in order to access their referenced and stored multi dimensional data. The source dataset object s return this code to aggregation dataset object via the code object originally passed to them or in some instances the code object may be passed by reference thereby allowing edits to the code object without having to pass the code object back to aggregation dataset object .

Upon dynamically generating the code for data provider element aggregation dataset object may quickly and efficiently access the multi dimensional data for the dataset s defined in the and optionally the via data provider element that incorporates the dynamically generated portions of code. Aggregation dataset object may satisfy the demand by utilizing data provider element to quickly and directly access the underlying multi dimensional data referenced by the source dataset object s and returning the multi dimensional data to object model thereby satisfying the demand.

Next object model waits to receive a demand for multi dimensional data referenced by the newly created aggregation dataset object . If no demand is received object model may continue to create and store other aggregation dataset objects similar to aggregation dataset object or any other objects described herein NO . However assuming object model receives a demand for multi dimensional data referenced by the newly created aggregation dataset object YES object model resolves i.e. determines the references to the multi dimensional data for aggregation dataset object . Typically during resolution of the newly created aggregation dataset object object passes a code object to each virtual dataset and or dataset defined in the and fields above where each of these datasets dynamically generate the code for data provider element of aggregation dataset object . Although not explicitly described this dynamic code generation process may apply to two or more virtual dataset objects and or dataset objects and the invention should not be limited as such. In instances where more than two objects and or are specified in the aggregate operation aggregation dataset object continues to pass the code object to these subsequent objects and or where these objects and or dynamically generate additional portions of the code for data provider element .

For example in instances where two sources are specified aggregation dataset object may pass a code object to one of virtual dataset objects specified in the field whereupon virtual dataset object A for example or more generally a first object dynamically generates a portion of the code for aggregation dataset object or more generally a second object . Next aggregation dataset object may pass the same code object to dataset object N for example or more generally a third object whereupon it dynamically generates another portion of the code for aggregation dataset object or more generally the second object . In both instances the first and third objects may generate a portion of the code for data provider element of aggregation dataset object that enables data provider element to calculate memory addresses directly into the memory space referenced by both the first and third dataset objects A N without having to make function calls to both of these objects in order to access their referenced and stored multi dimensional data. The first and third objects return this code to aggregation dataset object via the code object originally passed to them or in some instances the code object may be passed by reference thereby allowing edits to the code object without having to pass the code object back to aggregation dataset object .

Upon dynamically generating the code for data provider element aggregation dataset object may quickly and efficiently access the multi dimensional data for both datasets defined in the and via data provider element that incorporates the dynamically generated portions of code. Aggregation dataset object may satisfy the demand by utilizing data provider element to quickly and directly access the underlying multi dimensional data referenced by both the first and third objects and returning the multi dimensional data to object model thereby satisfying the demand .

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

