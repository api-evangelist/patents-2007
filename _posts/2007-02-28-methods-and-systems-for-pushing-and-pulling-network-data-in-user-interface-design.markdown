---

title: Methods and systems for pushing and pulling network data in user interface design
abstract: A network management system is provided for allowing a user to interface with network management data provided by a network agent via a network. Application level logic obtains and formats the network management data to thereby create a display presented to the user. A library of software processing structures for sharing data with the network agent is provided, and an abstraction layer distinct from the library is configured in communication with the application level logic. The abstraction layer includes a pusher feature configured to facilitate the writing of data from the application level logic to the network agent and a puller feature configured to facilitate the reading of data from the network agent to the application level logic. The abstraction layer uses the library to communicate with the network agent via the network while isolating the application level logic from the library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08027362&OS=08027362&RS=08027362
owner: Symbol Technologies, Inc.
number: 08027362
owner_city: Holtsville
owner_country: US
publication_date: 20070228
---
This application claims priority to U.S. Provisional Pat. Ser. No. 60 778 503 for METHOD AND APPARATUS FOR PUSHING AND PULLING NETWORK DATA IN USER INTERFACE DESIGN which was filed Mar. 1 2006 and is incorporated herein by reference.

The present invention generally relates to networked software and more particularly to pushing and pulling network data between a database and a user application or applet.

Due the size of modern wireless networks it has become difficult to plan monitor manage and troubleshoot the system as a whole. There has been a dramatic increase in demand for mobile connectivity solutions utilizing various wireless components and wireless local area networks WLANs . Such WLANs generally include multiple wireless access points that communicate with mobile devices using one or more RF channels e.g. in accordance with one or more of the IEEE 802.11 standards . The number of mobile units and associated access ports as well as the number of RFID readers and associated antennae can be very large in an enterprise. As the number of components increases the management and configuration of those components becomes complicated and time consuming.

Management software typically includes one or more user interfaces that incorporate management information base MIB entries and user interface applets. Currently known systems however are limited with respect to their ability to create user interfaces e.g. Java interfaces based on these MIBs.

Accordingly it is desirable to provide improved methods of generating user interface structures. In particular it is desirable to provide improved techniques and systems for pushing and pulling data between a database e.g. an SNMP MIB and a user application. Other desirable features and characteristics of the present invention will become apparent from the subsequent detailed description and the appended claims taken in conjunction with the accompanying drawings and the foregoing technical field and background.

The following detailed description is merely exemplary in nature and is not intended to limit the range of possible embodiments and applications. Furthermore there is no intention to be bound by any theory presented in the preceding background or the following detailed description.

According to various embodiments so called pushers and pullers are provided that allow user interface pages to automate the writing and reading respectively of data residing over a network such as simple network management protocol SNMP data contained within a management information base MIB . Pushers and pullers are objects or other software helpers that may be designed to be invoked directly by an application or applet and or to be automatically invoked by a page management framework as described more fully below.

Pullers and pushers encapsulate much of the network I O activities of the user interface page. A page or dialog can have as many or as few as needed e.g. different pullers and pushers support different situations and although they can be called individually in various embodiments they are invoked at the appropriate times automatically by the page management framework. In various embodiments their behaviors can be augmented in special cases using listeners and special overridden methods. In more unusual cases lower level read write methods can also be used. Data can typically be modified in any chosen thread but components are generally updated in Event Dispatch threads and many pullers automatically take care of this. Pullers can also be invoked in a separate thread so slow data loading does not block the user interface during operation.

For simplicity and clarity of illustration the drawing figures depict the general structure and or manner of construction of the various embodiments. Descriptions and details of well known features and techniques may be omitted to avoid unnecessarily obscuring other features. Elements in the drawings figures are not necessarily drawn to scale the dimensions of some features may be exaggerated relative to other elements to assist improve understanding of the example embodiments.

Terms of enumeration such as first second third and the like may be used for distinguishing between similar elements and not necessarily for describing a particular spatial or chronological order. These terms so used are interchangeable under appropriate circumstances. The embodiments of the invention described herein are for example capable of use in sequences other than those illustrated or otherwise described herein. Unless expressly stated otherwise connected means that one element node feature is directly joined to or directly communicates with another element node feature and not necessarily mechanically. Likewise unless expressly stated otherwise coupled means that one element node feature is directly or indirectly joined to or directly or indirectly communicates with another element node feature and not necessarily mechanically.

The terms comprise include have and any variations thereof are used synonymously to denote non exclusive inclusion. The terms left right in out front back up down and other such directional terms are used to describe relative positions not necessarily absolute positions in space. The term exemplary is used in the sense of example rather than ideal. For the purposes of conciseness conventional techniques and systems related to data communication network systems wireless local area networks WLANs communication standards e.g. the IEEE 802.11 family of specifications and applet operation are not described in detail herein.

Although the present invention may be used in a variety of contexts e.g. any system where applets or other applications are created and sent from one device to another device for execution depicts a wireless local area network WLAN . In this embodiment one or more switching devices alternatively referred to as wireless switches WS or simply switches are coupled to a network e.g. an Ethernet network coupled to one or more other networks or devices indicated by network cloud . One or more wireless access points alternatively referred to as access ports or APs are configured to wirelessly connect to one or more mobile units alternatively referred to as MUs . The access points are suitably connected to corresponding wireless switches via communication lines e.g. conventional Ethernet lines . Any number of additional and or intervening switches routers servers and other network components may also be present in the system. Additional servers and client systems not shown may communicate indirectly or directly with the various illustrated components e.g. via a network connection .

A particular access point may have a number of associated mobile units . For example in the illustrated topology mobile units and are associated with access point while mobile unit is associated with access point . Furthermore one or more access points may be connected to a single wireless switch . Thus as illustrated access point and access point are connected to wireless switch and access point is connected to wireless switch .

Each wireless switch determines the destination of data packets it receives over network and routes that data packet to the appropriate access point if the destination is a mobile unit with which the access point is associated. Each wireless switch therefore maintains a routing list of mobile units and their associated access points . These lists are generated using a suitable packet handling process known in the art. Thus each access point acts primarily as a conduit sending receiving RF transmissions via mobile units and sending receiving data packets via a network protocol with wireless switch .

The access points are typically capable of communicating with one or more mobile units through multiple RF channels. This distribution of channels varies greatly by device as well as country of operation. For example in one embodiment in accordance with 802.11 b there are fourteen overlapping staggered channels each centered 5 MHz apart in the RF band although only eleven channels may currently be used legally in the U.S.

Referring to an exemplary method of creating an applet will now be described. Initially any number of management information base MIB objects elements or files are provided within a database . Each of these MIB objects are associated with one or more components within the WLAN e.g. the WLAN illustrated in and in one embodiment objects are stored as static final Java objects. In other embodiments objects may be .NET constructs or any other objects structures or modules as appropriate.

As is known in the art a management information base MIB is based on the OSI ISO network model and is a type of database used to manage devices in the network. It includes a set of objects MIB objects corresponding to the various switches routers and other components within the system. These objects are typically defined using a subset of Abstract Syntax Network Notion One ASN.1 entitled Structure of Management Information Version 2 SMIv2 RFC 2578. MIBs may be periodically updated to add new functionality remove ambiguities and to fix defects. These changes may be made in accordance with Section 10 of RFC 2578 for example. Various tools exist to manipulate MIBs including for example MIB2GUI and other MIB related software tools offered by MG Soft Inc. and others.

In accordance with various embodiments two or more MIB XML files are created and stored within a database or within database . Each MIB XML file is associated with a corresponding MIB object . The nature of XML eXtensible Markup Language is well known in the art and need not be described herein. A translator e.g. MG Soft MIB2GUI can be used to convert MIB objects to a form that supports a user interface UI puller pusher infrastructure and or that permits UI validation based on the MIB.

In one embodiment when MIBs are created or updated an XML export file is created using suitable software e.g. MG SOFT s MIB Explorer Export to XML feature . These XML export files are checked into a subversion repository within database . In one embodiment this process is made part of the build so that system always has current XML files.

Any number of software interfaces are then created each of which is associated with a corresponding one of the MIB XML files . These interfaces may be stored prior to creation of the applet or created at the same time that the applet assembled. In one embodiment software interfaces are Java interfaces that include one or more constant classes corresponding to the corresponding SNMP objects. These constant classes might include for example an object ID OID of the SNMP object the type of the SNMP object and access information regarding the SNMP object. As is known in the art SNMP Simple Network Management Protocol is a widely used protocol employed to manage elements in large networks and is based on a manager agent model. The manager provides the interface between the human network manager and the management system and the agent provides the interface between the manager and the physical devices being managed. SNMP is powerful notwithstanding its relatively small command set. Further information regarding SNMP may be found for example within the IETF SNMPv1 and SNMPv2 standard documents.

Finally an applet is created using a subset of the plurality of software interfaces. As described above for every MIB element available to applet there can be a static final Java object that defines that MIB element including its OID. These objects may be pre created according to any scheme e.g. one for each discrete MIB element one for each table column and one for each overall table. These objects are used to identify a MIB element that the user wishes to manipulate.

The term applet is used to refer to any small software code library structure or other module and is not limited to Java applets. In various equivalent embodiments .NET constructs or the like could be used. In one embodiment a WLAN management applet is created i.e. an applet that is used in connection with the wireless switch or other component and which allows one or more components of the WLAN to be managed. Other embodiments could be used to manage other network components e.g. routers switches bridges and or the like or for any other purposes.

Creation of applet may be performed on a conventional user computer system operated by a network manager or other individual and may include various software and hardware components conventionally used in such systems. In one embodiment applet includes an applet used in connection with a web browser to provide a user interface to one or more of the WLAN components.

When the management applet is built the MIB XML files are converted into a set of matching Java interfaces using a MIB2GUI tool. Each interface contains one or more constant classes where each class corresponds to an SNMP object. These classes contain for example the object s OID type optional range access info and or any other object attributes as appropriate.

OIDs may be stored as an array of short integers for example to reduce memory usage. Given the large number of constants that may be generated in any particular environment storing the OID as an SNMP OID class such as the ones provided in an SNMP4J or AdventNet library consumes on the order of one additional megabyte of memory. In one embodiment The DataType class is a type safe enum class containing UT types mapped from SNMP types during the conversion process. Range contains a low and high limit for integer or string values. For strings the low limit is the minimum length and the high limit is the maximum length. The Boolean readOnly flag is TRUE if the field is read only and FALSE if the object is read write or write only.

The system generally includes an SNMPTableElement Class or the like. In one embodiment the export tool e.g. MIG2GUI generates an SNMPTableElement class for each SNMP table. This class contains all the fields in SNMPElement as well as an array of columns. Each column value in the SNMPTableElement is a previously defined SNMPListElement constant. In turn individual values within a row or non tabular scalar values are expressed with an SNMPElement constant. Constants files may be updated by the translator when their corresponding source XML files are modified. In addition the translator can be built when its source files are changed or when SNMPElement and related classes are modified. Both targets are suitably implemented in a make file or the like that is associated with the applet.

With reference now to additional detail about the applet creation environment will now be discussed with particular reference to the page management infrastructure and data pushers pullers for transferring data between the applet and the network agent having access to a MIB or other database as appropriate. In various embodiments applet suitably includes application level logic that creates a user interface display as desired by the user in conjunction with data obtained through a data abstraction layer and a page management infrastructure .

Application level logic suitably includes any collection of pages dialogs and or other interface features developed to provide the actual functionality of applet such as the various device management features. These features may include various pages or dialogs that may be accessed via a conventional web browser or the like shown as display in . Application level logic is suitably configured to obtain and format the network management data to thereby create the display presented to the user. Various features implemented in application level logic have been described above with reference to .

Generally speaking page management infrastructure is a run time environment that handles the general housekeeping features of a user created page or dialog implemented in logic . Such features may include for example managing certain pusher and puller features for input and or output of data automating dirty flags for detecting changes in data from user interaction as well as refreshing pages tabs and other user interface features with current data. Page management infrastructure is generally provided by a service provider and need not be modified by the end user. Other features provided may include enforcement of a read only mode for certain data types binding of pages to navigation features e.g. sashes and the like to aid in navigation and or other features as appropriate.

Abstraction layer is any code or other abstraction capable of providing an interface between application level logic and any network communications library as appropriate. In various embodiments abstraction layer contains pushers pullers for transmitting receiving data respectively using library . In such embodiments the abstraction layer uses the library to communicate with the remote network agent via the network while isolating the application level logic from library . Generally speaking abstraction layer isolates the application level logic from library by translating instructions from the application level logic to library instructions. Abstraction layer further isolates the application level logic from library by translating data received from library to a pre determined interface format that is compatible with the application level logic. An example of this format is shown in .

Further abstraction may be obtained by providing a high level application programming interface API separate from any library specific code . In various embodiments library may be an SMNP library such as the open source SNMP4J library or the like. By isolating any library specific code to a single abstraction layer the particular library used in future software releases may be changed without significant rebuilding of code outside of the abstraction layer . That is only the internals of layer typically need to be changed in the event that library is changed.

Layer contains various pusher and or puller features that may be used by page management infrastructure and or application level logic to facilitate the reading and writing of data between applet and data agent . Additional detail about pushers and pullers contained within layer can be found below.

Application programming interface provides a set of resources for implementing the pushers and pullers via library . In various embodiments interface is implemented using the Java Cfg class or the like. In such embodiments a set of static methods are provided by which most operations using library can be accomplished. Generally speaking features of interface may be available to page management infrastructure and or application level logic for use when a pusher or puller is not available for a particularly desired feature. Typically however the features of the interface are primarily provided for use by the pusher puller features of layer .

Using the features of library as abstracted in various pullers pushers applet is able to read and write data to and from network agent . Network agent is any database server application or other process capable of providing data requested by applet . In various embodiments agent is a conventional SNMP agent operating on a network which may correspond to networks and or the like in 

Application level logic communicates with page management infrastructure and abstraction layer using conventional programming constructs e.g. message passing interrupts etc. that may be implemented within the JAVA .NET or other appropriate environment. Application logic suitably communicates with page management infrastructure for example to track dirty flags and other changes message and to bind sashes and other interface elements to displayed pages message . Similarly application logic communicates with abstraction layer message for reading and writing of data through pushers and pullers . Data pushers and pullers may also facilitate auto populating and refreshing of data on various pages through page management infrastructure via e.g. message . These standard behaviors can be overridden by for example adding new listener features within abstraction layer and or page management infrastructure to intercept data values and special conditions in subsequent implementations. Alternatively custom post processing in special methods could be used.

The pusher puller arrangement described above allows for code re use on various libraries and provides a convenient and stable interface for user applets . In various situations however the user may wish to bypass the use of pushers and pullers and instead access either API level or less preferably library specific code . Examples of instances when this bypass process may be useful include without limitation the following situations 1 when SNMP delivers enumerated values but it is desirable to display human readable strings 2 when it is desirable to load miscellaneous values that do not come from an SNMP table into a displayed table 3 when a special MIB element has an unusual or non supported format for its data to be written and or 4 when an SNMP data value is not directly loaded into a screen component but instead affects several components in an unusual or complex way. Other situations may arise in various equivalent embodiments. Conversely other embodiments may find ways to implement pushers pullers even in these and other exceptional circumstances.

With reference now to an exemplary applet suitably includes various component objects as described above as well as calls to various pullers or pushers . These calls may be formatted in any manner such as the standard interfaces described in as appropriate. When a puller is called within applet or the page management infrastructure associated with the applet the corresponding logic in layer suitably formats and or posits a query to the appropriate network agent which returns a response using conventional SMTP or other standard formats. The response is appropriately received by the data puller logic which formats the response into a pre determined interface format that can be returned to applet for display or other processing. Pushers similarly forward data received in a pre determined format defined by the interface to network agent as message . Various types of pullers and pushers include mechanisms that could be used for simple data e.g. text fields checkboxes labels etc tables headless data e.g. data stored in memory and or used to implement a MAP interface and or the like. In various further embodiments the various pushers and pullers in layer may additionally validate data and or execute other tasks as appropriate. Values being read written can be checked for example and either vetoed e.g. discarded or modified if verification fails.

In still other embodiments the various pusher puller constructs in layer may be used to implement a listener feature that allows for monitoring of changes in network data and or user entered data. Such information runs similar to a daemon or other process in that it listens for data changes that can be automatically or otherwise reported to the network agent and or to the applet as appropriate. That is data can be pushed to the network agent pulled to the applet . Moreover data can be validated as it is being transferred via the layer constructs. Such data can then be vetoed and or revised if it fails validation. Other features could be implemented across a wide array of equivalent embodiments as appropriate.

As noted above the various pushers and pullers in layer are generally implemented with well defined interfaces to allow ready insertion into user applets . show examples of interfaces for exemplary pullers and pushers respectively. As noted in the interface for a puller can be used to pull read data from the SNMP or other data agent for use in user applet . The interface for a pusher can be similarly used to push write data in the appropriate format out to data agent . Pusher as shown also includes syntax for clearing dirty flags that is for removing any indications that data changes have been made. This syntax may be useful for example following a data push to the MIB agent or the like.

While at least one example embodiment has been presented in the foregoing detailed description it should be appreciated that a vast number of variations and equivalents exist. It should also be appreciated that the example embodiment or embodiments described herein are not intended to limit the scope applicability or configuration of the invention in any way. Rather the foregoing detailed description will provide those skilled in the art with a convenient road map for implementing the described embodiment or embodiments. It should be understood that various changes can be made in the function and arrangement of elements without departing from the scope of the invention and the legal equivalents thereof.

