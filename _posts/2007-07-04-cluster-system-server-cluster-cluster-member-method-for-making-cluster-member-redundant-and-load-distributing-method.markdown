---

title: Cluster system, server cluster, cluster member, method for making cluster member redundant and load distributing method
abstract: A protocol process to a reception traffic is executed by cluster members of a current use system and a backup system. The backup system discards the reception traffic subjected to the protocol process and only the current use system transfers the reception traffic to an AP. The AP makes an application process redundant in an independent method. The cluster member in charge of the protocol process to the reception traffic is determined by using a data in a lower layer and the cluster member in charge of the application process is determined by using a data in a higher layer after the protocol process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08555295&OS=08555295&RS=08555295
owner: NEC Corporation
number: 08555295
owner_city: Tokyo
owner_country: JP
publication_date: 20070704
---
This application is the National Phase of PCT JP2007 063346 filed Jul. 4 2007 which claims priority to Japanese Application No. 2006 0186503 filed Jul. 6 2008 and Japanese Application No. 2006 331798 filed Dec. 8 2006.

The present invention relates to a cluster system functioning as network equipment and particularly a cluster system functioning as network equipment in which an application program is executed inside.

In general a cluster system includes a plurality of apparatuses i.e. cluster members capable of realizing a predetermined function even if each of them is used as a single apparatus and an additional mechanism to make each of the cluster members to cooperate.

Although various methods are known to constitute a cluster system a configuration in which a load balancer is placed in the boundary with another system has been used in a relatively wide. shows a configuration of a cluster system using a load balancer. The cluster system is provided with a plurality of cluster members to and a load balancer . IP packets i.e. communication data transmitted from nodes to via a network are distributed to the cluster members to by the load balancer .

The cluster system shown in has an advantage in that events such as an apparatus configuration in a rear stage and a failover can be concealed to other systems by using the load balancer and control of a load balance can be easily carried out. On the other hand the system has a possibility that the load balancer becomes a bottleneck. If the load balancer is made redundant to prevent the load balancer from becoming a single point failure the configuration becomes complicated.

In order to solve the above drawbacks a cluster system is proposed in which the load balancer is not provided i.e. broadcast dispatch system e.g. to be referred to Japanese Patent Application Publication JP P2003 517221A .

IP packets transmitted from other nodes to to the cluster system are broadcasted to the cluster members to via the data link . Each of the cluster members to calculates a hash value of the IP packet broadcasted by the distributing filters to e.g. hash value to a transmission source address included in a header section and executes a receiving process to the received IP packet only if the calculated hash value is equal to a corresponding hash value allocated to its own cluster member. The IP packets transmitted from the other nodes to are broadcasted to all the cluster members to in the cluster system of the broadcast dispatch system. Each of the cluster members to processes only an IP packet corresponding to a hash value allocated to its own cluster member. Thus load balance is realized.

Furthermore if an identical hash value is allocated to two or more cluster members in the cluster system of the broadcast dispatch system the identical IP packet is processed by the cluster members redundantly. Accordingly a communication redundancy process can be carried out without explicitly making a copy of a state. Thus it is made possible to enhance scalability and availability.

Meanwhile the cluster system of the broadcast dispatch system has been developed for apparatuses such as a router to relay a packet. These apparatuses are characterized in that a process to the packet remains in a relatively low protocol layer and many of the apparatuses can relay the packet at high speed in a relatively simple process since a process in an application layer to the packet is not executed.

Referring to the cluster member is provided with a reception interface and a transmission interface which are connected to the data link for communication with an adjacent node protocol processing section . . . and for processing and transferring a packet two packet filters of a reception side distributing filter and a transmission side distributing filter and a filter control section for setting the filters and .

Each of the filters and calculates an integer value from a packet header by using a hash function and allows the packet to pass therethrough only when an integer value allocated to the filter or by the filter control section is equal to the integer value obtained from the calculation result. In the examples shown in four cluster members are provided to use four kinds of hash values 1 to 4 for simplification.

If an identical hash value is set to the reception side distributing filters of different cluster members by using this mechanism an identical packet is processed redundantly in these cluster members. Traffic corresponding to the hash value is therefore processed redundantly. The hash value is set to the transmission side distributing filter in only one of the above cluster members in order to prevent an identical packet from being transmitted to the outside of the system. For example in the example of it would be understood that traffic corresponding to a hash value 2 is processed redundantly by the cluster member on the left end and the cluster member on the right side to duplicate a flow state.

Moreover if sets of values in a value range of a hash function are allocated to the reception side distributing filters such that the cluster members deal with them without any gap and duplication a load balance of the traffic can be realized. For example the configurations of are same and cluster members are switched depending on a hash value calculated from a process target packet to realize the load balance. These cluster members are used in combination to realize a broadcast router cluster.

Other related techniques are exemplified as following. Japanese Patent Application Publication JP P2000 83045A discloses a route control technique that provides a technique to constitute a router with high extension ability corresponding to the needs of increase in lines of a router due to enlargement of a network in size. Japanese Patent Application Publication JP A Heisei 3 36853 discloses a call control method in an ISDN terminal apparatus and an ISDN terminal in which a software configuration in an application section is simplified and a call control for call origination and call arrival are made possible in high performance. Japanese Patent Application Publication JP A Heisei 7 87536 discloses a virtual line concentration system in a switch. In this system a control function for a subscriber line concentrator which is disposed within the same switch or outside of the switch is concealed in a common function so as for a call control application not to be conscious of presence or absence of a line concentration function.

By the way in apparatuses such as a server which terminates communication as a host node packets are processed which are usually transmitted and received by an application program. More specifically in a host node H as shown in a packet transmitted and received via a reception interface a transmission interface a protocol processing sections . . . and a read API Application Programming Interface section and a write API section is processed by an application program . When an apparatus having the above application program running thereon is clustered a system is conventionally employed in which a load balance is performed by a load balancer in accordance with policy of the application program and a state is made redundant by the application program independently. However use of the load balancer causes a state that the load balancer may become a bottleneck as described above.

Therefore it could be considered that the apparatus with the application program running thereon is clustered by a broadcast dispatch system. However in this case the following problems would arise 

 1 there is a case that the load balancing and policies for redundancy are different between an application process and a protocol process and

 2 it is necessary to make complicated states of the application process redundant while sustaining consistency thereof.

That is in the broadcast dispatch system since a hash operation is applied to a header section of an IP packet immediately after receiving the IP packet there is a case that a data in an upper layer cannot be used for traffic distribution. This is because the data is encrypted by TLS RFC 2246 The TLS Protocol Version 1.0. January 1999 by T. Dierks and C. Allen and IPsec ESP RFC 4303 IP Encapsulating Security Payload ESP December 2005 by S. Kent or the data in the upper layer is divided by IP fragmentation. Is such a case it is sometimes difficult to realize traffic distribution according to the data in the upper layer.

For example when a web server i.e. HTTP is constituted by a cluster system of the broadcast dispatch system it requires many resources for the all of cluster members to hold all of the contents. As a countermeasure taken against the above problem it could be considered to distribute the contents to the cluster members in accordance of identification data of the contents. However since the identification data of each content is written in a HTTP request as URL it is impossible to distribute traffic by using the identification data of the content. Accordingly entire contents need to be held by each of the cluster members.

Moreover in the protocol process transmission confirmation and re transmission are carried out in consideration of a data loss on a transmission path. Accordingly even if a broadcasted packet is processed by different cluster members independently large inconsistency does not cause in a protocol state of each of the cluster members in many cases. As described above the broadcast dispatch system has good affinity to the protocol process.

In contrast the application process has a complicated state and a displacement of a process timing is easily generated due to process scheduling or the like in the execution environment of multiple processes such as UNIX . Therefore even if the same data is supplied a state inconsistency easily occurs. Moreover the application process is generally more complicated in implementation than the protocol process and a possibility is high that a defect is triggered by specific reception data. In such a case since reliability is not improved even if the broadcasted data is processed by a redundancy system the broadcast dispatch system is inappropriate.

Therefore a cluster system of the broadcast dispatch system is demanded is which can effectively support both of the application process and the protocol process.

By the way the protocol processing sections . . . and and the reception side distributing filter shown in are generally realized by a kernel of an OS operating system and the application program also requests the OS to transmit and receive an IP packet by a system call. Accordingly in order to satisfy the above request for example a new function needs to be incorporated into the OS to realize the above request. However the incorporation of the new function requires a large change in the OS.

Therefore an object of the present invention is to provide a cluster system of a broadcast dispatch system which can effectively support both of an application process and a protocol process without adding a large change to an OS.

A cluster system or a server cluster according to an example of the present invention includes a plurality of cluster members and each of the plurality of cluster members includes a protocol processing section configured to execute a protocol process a communication API section configured to read data from the protocol processing section and write data in the protocol processing section depending on a kind of call and a trapping section configured to trap a call to the communication API section from an application program operating on a self cluster member to call the communication API section instead of the application program to execute a process determined depending on the kind of the call to the data read from the protocol processing section by the communication API section based on the call or the data written into the protocol processing section by the communication API section based on the call and to execute a process determined based on a kind of a data transmitted from another cluster member to the transmitted data.

A cluster system or a server cluster according to another example of the present invention includes a plurality of cluster members and each of the plurality of cluster members operating as a current use system includes a current use system protocol processing section configured to execute a protocol process a current use system communication API section configured to read a data from the current use system protocol processing section in response to a read call and to write a data in the current use system protocol processing section in response to a write call a current use system call trapping section configured to trap the read call or the write call from an application program operating on the self cluster member to carry out the read call to the current use system communication API section instead of the application program when the read call is trapped to transfer the data read from the current use system protocol processing section by the current use system communication API section in response to the read call to the application program and to carry out the write call to the current use system communication API section instead of the application program when the write call is trapped and a current use system transferring section configured to transfer a replica data of a write data to one cluster member of a backup system to the self cluster member when the current use system call trapping section traps the write call. The cluster member operating as a backup system of the plurality includes a backup system protocol processing section configured to execute the protocol process a backup system communication API section configured to read a data from the backup system protocol processing section in response to a read call and to write a data in the backup system protocol processing section in response to a write call a backup system writing section configured to carry out the write call to the backup system communication API section when the replica data is transferred from the current use system transferring section such that the replica data is written in the backup system protocol processing section and a discarding section configured to discard a reception data and a transmission data subjected to a protocol process by the backup system protocol processing section.

A cluster system or a server cluster according to still another example includes a plurality of cluster members and each of the plurality of cluster members includes a protocol processing section configured to execute a protocol process a reception side distributing filter configured to transfer the reception packet to the protocol processing section when determining that the reception packet is the reception packet to be processed in the self cluster member based on a predetermined protocol processing distribution rule a communication API section configured to read a data from the protocol processing section in response to a read call and to write a write data in the protocol processing section in response to a write call a call trapping section configured to trap the read call or the write call from an application program operating on a self cluster member to carry out the read call to the communication API section instead of the application program when trapping the read call to transfer a reception data to the application program when a data read from the protocol processing section by the communication API section in response to the read call is the reception data from another cluster member to transfer a transmission data to the protocol processing section when being the transmission data from another cluster member to transfer the data to an application process distributing section in a case other than the above cases and to transfer the transmission data instructed by the trapped write call to a protocol process distributing section when trapping the write call the application process distributing section configured to determine the cluster member in charge of an application process to the data transferred from the call trapping section based on a predetermined application process distribution rule to transfer the data to the application program operating on the self cluster member when the determined cluster member is the self cluster member and to transfer the data to a transferring section when the determined cluster member is another cluster member the protocol process distributing section configured to determine the cluster member in charge of a protocol process to the data transferred from the call trapping section based on a predetermined protocol process distribution rule to transfer the data to the protocol processing section on the self cluster member when the determined cluster member is the self cluster member and to transfer the data to the transferring section when the determined cluster member is another cluster member and the transferring section configured to transmit the data transferred from the application process distributing section and the protocol process distributing section to the other cluster member.

A cluster system or a server cluster according to a yet still another example of the present invention includes a plurality of cluster members and a traffic is distributed by picking up a portion in charge by a self cluster member from traffic broadcasted to all of the plurality of cluster members and discarding a remaining portion. The cluster system or the server cluster includes a a reception side distributing filter configured to hold a calculation rule used to calculate an integer value from a predetermined section of a packet and an integer value allocated to the self cluster member provided between a reception interface and a protocol processing section of each cluster member. The reception side distributing filter calculates the integer value for every packet by using the calculation rule and transfers the packet to a receiving process of the protocol processing section only when the calculation result is equal to the allocated integer value an identical value is allocated to the reception side distributing filters of a current use system and a backup system and distribution of the traffic and a redundant process of a protocol process are made possible by allocating a set of integer values as the calculation results obtained based on the calculation rule to the plurality of cluster members with no space. The cluster system further includes b a distributing and redundancy processing section configured to hold a calculation rule used to calculate an integer value from an application data contained in the reception packet and a distribution rule as a list of integer values allocated to the plurality of cluster members is provided between the application program and the protocol processing section of each cluster member. The distributing and redundancy processing section transfers a data to the cluster member allocated with the integer value which is calculated from the reception data based on the distribution rule such that a reading process of the data is executed when the application program of the destination cluster member executes the reading process. In the cluster system or the server cluster the distributing and redundancy processing section holds the calculation rule used to calculate an integer value by using the same rule as the reception side distributing filter from header information used for a transmitting process of the data written by the application program and the list of the integer values allocated for all of the plurality of cluster members calculates the integer value based on the calculation rule used for the data written by the application program to transfer a write data to a plurality of cluster members allocated with the integer value and to make allocation of the cluster members to the application process and a redundant protocol process controllable independently. The cluster system or the server cluster further includes c a transmission side packet filter configured to discard a packet processed as a backup system cluster member is provided between a transmission side interface and the protocol processing section of each of the plurality of cluster members.

A cluster system or a server cluster according to another example of the present invention includes a plurality of cluster members and a traffic is distributed by picking up a portion in charge by a self cluster member from the traffic broadcasted to all of the plurality of cluster members and discarding a remaining portion. The cluster system or the server cluster includes a transmission side distributing filter and a reception side distributing filter provided between a transmission interface and a reception interface and a protocol processing section of each cluster member and configured to hold a calculation rule used to calculate an integer value from a predetermined section of a packet and an integer value allocated to the self cluster member. The reception side distributing filter calculates the integer value for every packet by using the calculation rule and transfers the packet to a receiving process of the protocol processing section only when the calculation result is equal to the allocated integer value and the transmission side distributing filter calculates the integer value for every packet transferred from the protocol processing section by using the calculation rule and transfers the packet to the transmission interface only when the calculation result is equal to the allocated integer value. Further an identical value is allocated to the reception side distributing filters of a current use system and a backup system and a redundant process is made possible by distributing the value to the transmission side distributing filter of the current use system and distribution of the traffic and the redundant process of a protocol process are made possible by allocating a set of integer values as the calculation results obtained based on the calculation rule to the plurality of cluster members with no space.

A cluster member is provided with a trapping section for trapping a call issued to a communication API section by an application program operating on its own cluster member. Upon trapping the call the trapping section calls the communication API section in place of the application program. The trapping section carries out a process corresponding to a type of the call to a data read from a protocol processing section by the communication API section in response to the call and a data written into the protocol processing section by the communication API section in response to the call. The trapping section further executes a process corresponding to a type of data to the data transmitted from another cluster member. The trapping section can be provided outside of an OS which constitutes the protocol processing section. It is therefore made possible to provide a cluster system of the broadcast dispatch type which can effectively support both an application process and a protocol process without adding a change to the OS in a large scale.

When a cluster member is made redundant for example a current use system call trapping section and a current use system transferring section are provided on one cluster member of a current use system as a trapping section which carries out the above processes. The current use system call trapping section traps a read call and a write call issued by an application program operating on its own cluster member. When the read call is trapped the current use system call trapping section carries out the read call to an current use system communication API section in place of the application program and the current use system communication API section transfers a data read from the current use system protocol processing section to the application program in response to the read call. When the write call is trapped the current use system call trapping section carries out the write call to the current use system communication API section in place of the application program. When the write call is trapped the current use system call trapping section further transfers a data copied from a write data to a cluster member in a backup system corresponding to its own cluster member in the current use system by using the current use system transferring section.

In contrast a backup system writing section and a discarding section are provided as a trapping section on the cluster member in the backup system. When a replica data is transferred from the current use system transferring section the backup system writing section carries out the write call to the backup communication API section in order to write the replica data in a backup protocol processing section. The discarding section discards a reception data and a transmission data subjected to the protocol process by the backup protocol processing section.

By employing such a configuration an identical transmission traffic and reception traffic are processed by the protocol processing section in the current use system and backup systems as shown in while data transmission and the transfer of reception data to the application program are carried out only by the current use system cluster member. The current use system protocol processing section and the backup system protocol processing section process the identical reception traffic and transmission traffic and the states are same.

It should be noted that a complicated state of the application program can be made redundant by a unique method of the application program. Redundancy can be realized by for example the following method 

1. the current use system application program receives some data from a counter communication apparatus 

2. the current use system application program determines an updated content of a control data from the received data and notifies the updated content to the backup application program by using an inter process communication and a shared memory 

3. the backup application program updates its own control data in accordance with a notice from the current use system and responds to the current use system application program to inform whether or not the data has been successfully updated 

4. the current use system application program updates its own control data upon successful data update in the backup application program and

5. a response is returned to the counter communication apparatus when the above processes are properly completed.

In contrast in case of realizing a load balance a call trapping section an application process distributing section a protocol process distributing section and a transferring section are provided on a cluster member as a trapping section.

The call trapping section traps a read call and the write call issued by an application program operating on its own cluster member.

When the read call is trapped the call trapping section carries out the read call to the communication API section in place of the application program. If a data read from the protocol processing section by the communication API section in response to the read call is a reception data transmitted from another cluster member the call trapping section transfers the read data to the application program. If the data read by the communication API section is a transmission data transmitted from the other cluster member the call trapping section transfers the read data to the protocol processing section. In other cases the call trapping section transfers the above data to the application process distributing section.

Moreover when the write call is trapped the transmission data which is instructed to be written by the trapped write call is transferred to the protocol process distributing section.

The application process distributing section determines a cluster member in charge of an application process to the data transferred from the call trapping section in accordance with an application process distribution rule set in advance. Then if the determined cluster member is the cluster member itself the data is transferred to the application program on its own cluster member whereas the data is transferred to the transferring section if being determined to be another cluster member.

The protocol process distributing section also determines a cluster member in charge of a protocol process to the data transferred from the call trapping section in accordance with a protocol process distribution rule set in advance. Then if the protocol process distributing section determines its own cluster member the data is transferred to the protocol processing section on its own cluster member. If another cluster member is determined the data is transferred to the transferring section.

The transferring section transfers the data transferred from the application process distributing section and the protocol process distributing section to a corresponding cluster member.

By employing such a configuration different cluster members can be used to carry out the protocol process and the application process to a traffic as shown in .

According to the present invention a cluster system of a broadcast dispatch type can be provided while effectively supporting both an application process and a protocol process without adding a large change to the OS. The reasons are as follows. The trapping section provided in a cluster member traps a call to the communication API section from the application program operating on its own cluster member and calls the communication API section in place of the application program. The trapping section carries out a process corresponding to a type of the call to a data read by the communication API section from the protocol processing section in response to the call or a data written into the protocol processing section by the communication API section in accordance with the call. The trapping section further carries out a process corresponding to a type of the data to a data transmitted from another cluster member. The trapping section can be provided outside of an OS which constitutes the protocol processing section and therefore the cluster system of the broadcast dispatch type can effectively support both the application process and the protocol process without adding a large change to the OS.

According to the present invention a server apparatus for a trunk operation in which high reliability is required and an application level gateway apparatus having concentrated traffic on a network can be made redundant. It is also possible to construct a server with a large processing capability in an extremely large scale by for example arbitrarily increasing the number of server apparatuses each of which can also be operated as a single apparatus to make a call control of a telephone in a communication carrier and using the server apparatuses as a cluster apparatus for performing a load balance.

Hereinafter best modes for carrying out the present invention will be described in detail with reference to the attached diagrams.

In a cluster system of a broadcast dispatch system according to a first exemplary embodiment of the present invention a cluster member onto which an application program is mounted is made redundant. The present exemplary embodiment is realized by using cluster members as shown in in place of the cluster members to in the cluster system of the broadcast dispatch system as shown in . The cluster system of the present exemplary embodiment functions as for example a server i.e. a server cluster .

Referring to the cluster member according to the present exemplary embodiment is provided with an application program protocol processing sections . . . a reception side distributing filter a transmission reception filter a filter control section a reception interface a transmission interface a read API section serving as a communication API section a write API section serving as a communication API section a read API call trapping section a write API call trapping section a copying and collating section a copying and writing section a control section and a transferring section .

The cluster member can be realized by a computer as will be exemplified below. A disk a semiconductor memory or a recording medium in which a program for make a computer to function as the cluster member is recorded is prepared. The above program is read in the computer. The computer controls an operation of itself in accordance with the read program so as to realize on its own computer the protocol processing sections . . . and the reception side distributing filter the transmission side distributing filter the filter control section the reception interface the transmission interface the read API section the write API section the read API call trapping section the write API call trapping section the copying and collating section the copying and writing section the control section and the transferring section .

The cluster member can function as both a current use cluster member and a backup cluster member. shows a configuration of the cluster members which are made to function as a current use cluster member and a backup cluster member and a flow of transmission reception data therein. shows only primary elements of the present invention. The protocol processing sections . . . and the reception side distributing filter the transmission side distributing filter the filter control section the reception interface and the transmission interface are omitted from .

Referring to the current use cluster member is provided with the copying section the copying and collating section of functions as the copying section of when the cluster member is made to function as an current use cluster member the copying section the copying and writing section of functions as the copying section when the cluster member is made to function as an current use cluster member the control section the transferring section the read API call trapping section and the write API call trapping section between the read API section or the write API section and the application program .

When the application program calls a reading process by a system call or the like the read API call trapping section is used to trap the call and dispose a clustering process before and after the reading process. This operation is also applied to the write API call trapping section .

The copying sections and carry out a process to copy transmission reception data to be read and written to transfer to the transferring section .

The transferring section receives the data from the copying sections and to transfer the data to a backup cluster member. The transferring section also receives processing result of the data by the backup cluster member to transfer them to the copying sections and .

Each of the read API section and the write API section provides an API for performing actual communication. These API sections are also provided in the host node H shown in . The protocol processing sections . . . and the reception side distributing filter the transmission side distributing filter the filter control section the reception interface and the transmission interface which are provided in the read API section and the write API section are omitted from .

The application program calls the read API section and the write API section and executes a communication process.

The control section is in charge of clustering a communication control process such as a session control.

The backup cluster member is provided with the collating section the copying and collating section of functions as the collating section of when functioning as the backup cluster member the writing section the copying and writing section of functions as the writing section of when functioning as the backup cluster member the read API call trapping section the write API call trapping section the control section and the transferring section between the application program the read API section and the write API section . The control section is internally provided with a switching notifying section a switching control section and a current use monitoring section .

The read API call trapping section the write API call trapping section and the transferring section function as described in the current use cluster member.

The copying and writing section is used to transfer a write data transferred from the current use cluster member to a transmission process in the backup cluster member via the write API section in the backup cluster member.

The collating section receives a reception data read in the current use cluster member executes a reading process via the read API section in the backup cluster member itself to execute a collating process of whether identical contents have been read.

The control section is in charge of clustering a communication control process such as a session control process and system switching to from the current use system.

The switching notifying section is used to receive information on a fault detection in the current use cluster member from a program not shown monitoring a dead alive state of the current use cluster member and to transfer the information to the application program and the switching control section as needed.

The switching control section has a function to switch operations of the collating section and the write API section when the current use cluster member is failed so that the backup cluster member performs failover and to allow the application program in the backup system to carry out transmission and reception.

The current use monitoring section has a function to monitor the dead alive state of the current use system i.e. current use cluster member in accordance with a procedure set separately. It should be noted that this function may be independently provided onto the application program or the like and in such a case the current use monitoring section may be omitted.

If the cluster member is realized by an operating system for multi process here it is generally realized based on the following manipulation. The read API section and the write API section are typically realized as a system call API. The protocol processing sections . . . and and other elements disposed therebelow are realized as a part of a kernel in an OS. The application program is realized as a user process.

In such a configuration elements held in a region from the read API call trapping section and the write API call trapping section to the read API section and the write API section can be realized as a library. This configuration allows changes in a conventionally existing kernel portion in the OS and implementation of an application program to be made small when a cluster function according to the present invention is added. This is because many systems usually manage the kernel portion of the OS and the application program separately as independent files and the library can be dynamically linked on execution of the application program.

Although a case has been described in which only one application program operates in a cluster member for simplification a plurality of application programs may operate therein. In this case the components described above are prepared for each of the application programs.

A correspondence relation of a certain application program in the current use system and a certain application program in the backup system is set in advance in the transferring section so that the transferring sections in the current use system and the backup system communicate from each other for redundancy. More specifically port numbers for a redundancy communication session or the like are set and known in advance.

In order to describe one feature of the present exemplary embodiment a receiving and reading process of the host node H refer to which is not provided with the read API call trapping section and the write API call trapping section and is not clustered will be described with reference to flowcharts of .

Referring to a reading process includes two sequences of processes. One sequence of processes is started in response to packet reception as shown in i.e. protocol process . The other sequence of processes is started in response to the reading process of the application program as shown in i.e. application process .

The former and the latter processes deal with same reception data but they are separated as described above because the flows of processes are ended.

When an IP packet addressed to the host node H arrives from the data link the reception interface receives the packet step S . A reception data is transferred while being processed successively from the protocol processing section in a lower layer to the protocol processing section in a high layer steps S and S . For example the TCP IP network has layers which are typically provided in combination of Ethernet IP TCP or the like.

The protocol processing section in the uppermost layer notifies a read enable state to the read API section when a protocol process has been completed in its own layer step S . This notice is carried out by preparing a state variable which is shared by the protocol processing section and the read API section and changing a value of the state variable to a value indicating data enable state.

When the application program requests the read API section to read the reception data step S the read API section reads the reception data to transfer to the application program steps S and S when the read enable state is notified from the protocol processing section YES in step S . In contrast when the read enable state is not notified NO in step S the reading process is blocked until the read enable state is notified step S .

Next a process of the present invention will be described. are flowcharts showing an operation on the current use system side in the receiving and reading process according to the present exemplary embodiment.

The receiving and reading process is separated into the protocol process steps S to S as shown in and the application process steps S to S as shown in in a same manner as the host node H explained for comparison. In these processes the protocol process steps S to S includes a process at the step S which is slightly different from the process at the step S of while processes in the steps S to S are the same as the processes in the steps S to S of . The step S differs from the step S in that only a packet is received whose hash value is equal to a hash value calculated by the reception side distributing filter .

Next the application process will be described. In the present exemplary embodiment the read API call trapping section traps a call to the read API section by the application program steps S and S . When the above call is trapped the read API call trapping section calls the read API section in place of the application program step S . Therefore the read API section reads the reception data if it is prepared in the protocol processing section or blocks the reading process until the reception data is prepared in case of no reception data steps S to S .

Next the reception data read by the read API section is copied by the copying section and transferred to the transferring section and the transferring sections sends the transferred data to the backup cluster member step S . This transfer of a replica data is carried out by a communication mechanism exclusively used among the cluster members a shared memory or the read write API section which is use for communication by the application program.

Furthermore since the result of collating data are transmitted from the backup cluster member the reading process is executed by the read API section so as to wait for data reception step S . Upon reception of the collation result the transferring section reads the data from the read API section to transfer to the copying section step S . If the collation result indicates collation success YES in step S the copying section transfers the data read at the step to the application program via the read API call trapping section step S . If the collation result indicates collation failure NO in step S the data read at the step S is discarded to return an error to the application program step S .

Next an operation of the backup system will be described. are flowcharts showing the operation on the backup system side in the receiving and reading process according to the present exemplary embodiment.

Referring to the reading process in the backup system also includes two sequences of processes in a same manner as the current use system.

Since the reception data is broadcast to all the cluster members in the present exemplary embodiment a same packet is delivered to the current use cluster members and the backup cluster members. It should be noted that a corresponding hash value of the backup cluster member is set to be the same as that of the current use cluster member.

Meanwhile the reading process is not driven by the application program but driven by the clustering process itself in the backup system.

In the backup cluster member the collating section reads the reception data or replica data transmitted from the current use system via the transferring section . The transferring section waits for arrival of replica data from the current use system and transfers the replica data to the collating section upon the arrival steps S and S . In response to this the collating section reads the reception data via the read API section steps S to S . At this time if it is possible to specify the length of reception data to be read the data is read only for the same length as that of the replica of the reception data received from the current use system.

Thereafter the collating section collates the reception data read at the step S and the replica data of the reception data received from the current use system and transmits the collation result indicating collation success to the current use system when both of these data are coincident with each other or transmits the collation result indicating collation failure to the current use system when both of these data are not coincident with each other step S . Then the collating section discards the reception data step S . It should be noted that if an amount of data read by the backup system itself at the step S is smaller than an amount of replica data of the reception data received from the current use system the data is continuously read until the same amount of data is provided. However when the same amount of data is provided even if the data is continuously read for a period of time specified in advance the data read may be canceled so as to determine the collation failure. The reception data by the backup system itself is discarded after ending the above process.

It should be noted that transmission of the collation result is carried out by using a communication mechanism exclusively used among the cluster members a shared memory and a read write API used for communication by the application program like the transmission of replica data. However if the application program uses the read write API for communication communication with the current use system cannot be carried out since an IP packet is discarded immediately before being transmitted from the backup system as a result of a writing process which will be described later. Therefore an exceptional process is executed to a packet addressed to the current use system so as to be actually transmitted without being discarded.

In addition the process to read data by the application program is not ended until it is completed to read data in both the current use system and the backup system. This makes it possible to prevent a process synchronization gap in which a process to read data is advanced in either the current use system or the backup system.

Referring to the application program in the unclustered host node H calls the write API section to write transmission data in a buffer of the write API section step S . When the transmission data is written in the internal buffer the write API section checks whether or not the above transmission data can be transferred to the protocol processing section in the uppermost layer step S . Then when it is possible to transfer the transmission data YES at step S the transmission data is transferred to the protocol processing section in the uppermost layer step S . When it is impossible to transfer the transmission data to the protocol processing section because the buffer in the protocol processing section is full or due to other reasons NO at step S the writing process is blocked until it becomes possible to transfer the transmission data step S .

The transmission data outputted from the write API section is transferred while being processed successively from the protocol processing section in a high layer to the protocol processing section in a low layer steps S and S . Then the data is finally transmitted from the transmission interface to the data link Step S . The writing and transmitting process of the host node H is as described above.

Next the writing and transmitting process according to the present exemplary embodiment will be described. are flowcharts showing an operation on the current use system side in the writing and transmitting process according to the present exemplary embodiment.

Referring to the writing and transmitting process is initiated by the application program calling the write API section like the host node H as a comparison example step S .

According to the configuration of the present exemplary embodiment the call to the write API section is trapped by the write API call trapping section step S and the following process is executed as the writing and transmitting process.

First the copying section copies the transmission data to produce a replica data and transfers the replica data to the transferring section . The transferring section sends the transferred replica data to the backup cluster member step S . This transmission of the replica data is realized by using a communication mechanism exclusively used among cluster members a shared memory or a read write API used for communication by the application program . Furthermore since a data writing result is supposed to be transmitted from the backup cluster member the current use system waits for receiving the result steps S and S . The data writing result is transmitted by using the communication mechanism exclusively used among the cluster members the shared memory or the read write API not shown used for communication by the application program .

Upon reception of the data writing result the transferring section transfers it to the copying section . When the data writing result indicates write failure NO at step S the copying section discards the transmission data and notifies the write failure to the application program step S . In contrast when the data was successfully written YES at step S the copying section transfers the transmission data to the protocol processing section immediately when the data can be written in the buffer of the protocol processing section or after waiting for a state in which the data can be written therein when the data can not be written steps S to S . Thereafter the same processes as those of the steps S and S are executed in the protocol processing sections . . . and steps S and S and the transmission data is finally transmitted from the transmission interface to the data link step S .

Next an operation of the backup system will be described. is a flowchart showing an operation on the backup system side in the writing and transmitting process according to the present exemplary embodiment. The writing and transmitting process in the backup system is not initiated by the application program but initiated by the clustering process itself like the reading process.

The transferring section waits for arrival of the transmission data or replica data from the current use system and transfers the transmission data to the writing section upon its arrival step S .

The write API section therefore checks whether or not the data can be written in the buffer of the protocol processing section and transfers the transmission data to the protocol processing section immediately when the data can be written or after waiting for a state in which the data can be written when the data cannot be written steps S to S .

Accordingly the protocol processing sections . . . and execute the writing process of the transmission data i.e. protocol process step S . Thereafter the writing section generates the data writing result indicating whether or not the transmission data was successfully written on the basis of responses such as a return from a function call and a call of a callback routine from the protocol processing sections . . . and and transmits it to the current use cluster member step S . This transmission of the data writing result is realized by using a communication mechanism exclusively used among the cluster members a shared memory or a read write API used for communication by the application program .

It should be noted that when the above read write API is used to notify the writing result to the current use system a destination of the writing result is set to an IP MAC address of the current use system in order to prevent the writing result from being discarded in the transmission interface . That is the transmission side distributing filter in the backup system is configured to send a packet which is addressed to the current use system to the data link via the transmission interface and to discard packets addressed to other destinations. If only a part of replica data of the transmission data received from the current use system is written at the step S the writing process is continued until the entire data is written. However the writing process may be canceled to determine as a failure if the writing process is not ended even if the writing process is continuously executing for a period of time specified in advance.

Also the reason why the writing process in the backup system is executed prior to the writing process in the current use system is in the features of the redundancy process in the present exemplary embodiment and a protocol operation such as TCP.

In the redundancy system according to the present invention the transmission data for the transmitting process in the current use system is actually transmitted but the transmission data for the transmitting process in the backup system is discarded immediately before the transmission. Thus it is made possible to prevent the transmission data from being transmitted in duplex.

Meanwhile a transmission confirmation response to the data transmission is transmitted from a counter node in a protocol such as TCP and SCTP to assure data transmission. Since the arrival of transmission data can be confirmed through the reception of this response the data held in a transmission buffer can be deleted in the protocol. In contrast if the response is not received it is necessary to continue to re transmit the transmission data.

When the transmitting process is executed in the backup system according to the present exemplary embodiment a packet is not actually transmitted although being for the protocol process in the backup system and the confirmation response is never received from the counter node.

In contrast since the transmission data is actually transmitted to the counter node when the transmitting process is executed in the current use system causes the response is returned.

Here a response message here is transmitted to the cluster system which means the message is received by both the current use system and the backup system.

If the transmitting process is first executed in the current use system there is a possibility that the response arrives in the backup system before the transmitting process is executed in the backup system. Since a response to the data which has not been transmitted is discarded the backup system discards the response in this case.

Even if the backup system executes the transmitting process thereafter the transmission data is not actually transmitted and the response to the transmission data does not arrive. Therefore the transmission confirmation cannot be carried out forever. As described above the writing process is executed in the backup system prior to the current use system in order to increase an opportunity to execute the transmitting process in the backup system prior to the current use system.

Communication control APIs to generate an endpoint and to establish a session are prepared for the group of communication APIs in addition to the read API and the write API.

Here a redundancy method of the above control API in a Barkley socket API as one of primary communication APIs will be described. Primary system calls used for generation of the endpoint and establishment of the session among the socket APIs are shown below 

Among these system calls bind listen and accept are used by a server which waits for a session are whereas connect is used by a client side which independently establishes a session. A method of generating a communication program by using these APIs is described in detail in UNIX Network Programming Network API Socket and XTI Pearson Education 2000 written by W. Richard Stevens and translated by Yoichi Shinoda .

A procedure to establish a session on the client side and the server side will be described below with reference to a sequence diagram while paying attention to the purposes of these calls.

With APIs other than APIs to be described below success of the API call is notified to the application program only when the API on the current use system side is called a call content is copied the same API on the backup side is also called and consequently the API call is successful in both of the current use and backup systems.

 3 wait for session establishment with a client in a system call of accept . When the session is established with the client a socket descriptor is newly generated for each session and returned to the calling side.

Her the application program typically issues a system call for each of the above three steps. According to the system of the present invention an additional process for redundancy is carried out by trapping each of the system calls in the same manner as the case of the reading and writing processes without any change in the calling procedure.

Next with the system call of accept when the application program in the current use system makes a call the control section traps the call and first the current use system issues the system call. Then soon after a session is established in the current use system a socket descriptor for communication is generated separately from the socket descriptor for waiting and returned to a calling source i.e. control section in this case .

Only when the above process is successfully completed the control section requests the backup system to carry out the process. The system call is also issued in the backup system and similarly receives a socket descriptor for communication to transmit the result to the current use system. As described above the socket for communication with a client can be generated in both of the current use and backup systems. Lastly the socket descriptor for communication on the current use system side is notified to the application program as the result of the system call and the process to establish the session is ended.

Here the reason why only the system call of accept is first issued in the current use system is in that the backup system records correspondence between the socket descriptor for communication in the current use system and the socket descriptor for communication in the backup system itself.

The session establishment by the protocol can be carried out prior to issuing the system call of accept . If the session has been established between the system call of accept is called information on the session is held in a waiting queue generated by the system call of listen . In this case the socket descriptor for communication can be obtained immediately after issuing the system call of accept . If the session is not established yet at the point of time at which the system call of accept is issued the system call of accept is blocked until the session is established.

Through the above process a redundancy process can be carried out without confusion by transferring a socket API to be processed at the time of communication between the current use system and the backup system even if the application program uses a plurality of socket descriptors. Furthermore even if the call of the accept is delayed in the backup system the session can be established in both the current use and backup systems.

In addition with the above procedure a reading process is started immediately after carrying out the above step 1 in case of establishing a session by a connection oriented protocol such as TCP refer to Transmission Control Protocol RFC 793 September 1981 by J. Postel and SCTP refer to Stream Control Transmission Protocol RFC 2960 October 2000 by R. Stewart Q. Xie K. Morneault C. Sharp H. Schwarzbauer T. Taylor I. Rytina M. Kalla L. Zhang and V. Paxson and in case of a connectionless protocol such as UDP User Datagram Protocol RFC 768 August 1980 by J. Postel . In this case only the bind process is made redundant by the above procedure.

The session establishment is typically carried out on the client side by issuing the system call of connect . When the system call is issued the protocol is requested to establish the session with a counter endpoint by fixing an endpoint on its own node side and the call is returned by the result of the session establishment.

A session establishment on the client side is made redundant by processing the system call of connect redundantly.

Here the endpoint on its own node side is first fixed. The endpoint on its own node side is not specified in the usual system call of connect and the protocol side selects a port number of the endpoint appropriately. However in case of the redundancy configuration according to the present exemplary embodiment an identical port number is allocated to the end points in the current use system and the backup system to generate the corresponding endpoints.

The system call of bind is used for fixation of the endpoint on its own node side as explained on the server side. Therefore a process similar to a process of making the system call of bind redundant is first carried out to set the endpoints on their own nodes in the current use system and the backup system to a same state.

When the above process is successfully completed a session with the counter endpoint is established. The backup system first issues the system call of connect in an asynchronization mode. A process of the system call of connection is ended once in the asynchronization mode even if establishment of a connection is not ended. Thus the protocol in the backup system is set to a state in which the session is being established and if the protocol is TCP a process of transmitting a segment in which an SYN flag is set is carried out though a packet is discarded before the transmission . The asynchronization mode is selected because since a packet is not actually transmitted in the backup system so that the session establishing process does not progress and the system call of connect is not ended.

Next the system call of connect is issued in the current use system side to actually execute the session establishing process. When the session establishing process is executed in the current use system the packet is actually transmitted to establish the session. At this time the backup system is waiting for a response from the counter endpoint and the session establishing process will progress in the backup system upon reception of the response from the counter endpoint. As described above the session is redundantly established in both of the current use and backup systems.

Next a failover process in which the system is switched to the backup system when the current use system is failed will be described below.

The dead alive state of the current use system is monitored in accordance with a procedure defined separately. For example a following method can be considered as a specific example of the monitoring procedure. It should be noted that the following method is one example to realize monitoring procedure and any other methods to monitor an operation of the current use system may be employed.

First a current use monitoring section is internally provided in the current use system as to monitor whether each section properly operates in the current use system. Next the monitoring section transmits operation information to the current use monitoring section in the backup cluster member in constant intervals.

The current use monitoring section determines a fault of the current use system when the operation information indicates abnormality detection or when subsequent operation information is not delivered after passing a predetermined period of time from reception of the last operation information.

Next if the current use monitoring section detects the fault the switching notifying section notifies occurrence of the fault occurred to the application program and the switching control section in the backup system. The application program in the backup system in a waiting state starts the operation in place of the application program in the current use system.

Also the switching control section changes the operations of the writing section and the collating section. The writing section operates to transmit a write API call issued by the application program to the write API via the write API call trapping section without any change. The collating section also carries out a similar process to reading process. Through the above process the backup system operates in a same manner as a host node of a stand alone type.

The functions of the current use monitoring section may be independently implemented by the application program. In this case the current use monitoring section is omitted and the application program is operated to notify a fault of the current use system to the switching notifying section.

According to the present exemplary embodiment the cluster member of the broadcast dispatch type with the application program operating thereon can be made redundant without any significant change to the OS so that the reliability can be improved. It is because the configuration is employed which includes the read API call trapping section the write API call trapping section the copying and collating section the copying and writing section the control section and the transferring section between the application program and the read and write API sections and . That is each of the above sections can be arranged outside of the OS so that the cluster member with the application program operating thereon can be made redundant without changing the OS.

In a second exemplary embodiment of the present invention a load balance to the protocol process and a load balance to the application process are carried out under different policies in the cluster system of the broadcast dispatch type including a plurality of cluster members each of which includes an application program operating thereon.

The distributing section carries out an operation to recalculate the cluster members to process traffics in a transmission direction and a reception direction by using two hash functions for the protocol process and the application process and retransmit the traffics to other cluster members as needed. Thus it is made possible for the protocol process and the application program to process traffics distributed by different distribution methods.

On the reception side the same process as those of the conventional cluster system of the broadcast dispatch type is executed up to the protocol process. Prior to transfer of reception data to the application program the distributing section determines one cluster member in charge of an application process. This is carried out by applying a hash function for the application process which differs from a hash function for the protocol process to application data included in the packet generally included as a payload to calculate a hash value and determining the cluster member to which the hash value is allocated.

In the example of the cluster member for receiving the packet differs from the cluster member for the application process and the distributing section transfers the reception data to the application program. Thus the application program is possible to receive the packet without being conscious of the cluster member which executes the protocol process.

On the transmission side the data transmitted from the application program is processed to pass through the proper cluster member in charge of a proper protocol process. The distributing section calculates and determines the cluster member in the charge of the protocol process by using the same hash function as that of a reception side filter used immediately after receiving the packet. In an example of the distributing section transfers the reception data before the application program writes transmission data and it is transferred to the protocol process. Therefore the protocol processing section can execute the transmitting process without being conscious of communication with the application programs of the other cluster members.

Here an identical representative MAC address is allocated to all the cluster members connected to the same data link. The reception interface of each of the cluster members is set so that when an adjacent node transmits a packet to this MAC address the packet reaches all the cluster members. Meanwhile a unique MAC address is also allocated to each of the cluster members for communication among the cluster members. This address is used to carry out one to one communication by specifying one cluster member of the cluster system

The protocol process distributing section executes a process to determine the cluster member to process transmission data on the basis of contents of protocol data. The protocol process distributing section is internally provided with a section not shown to calculate a hash value of the transmission data in accordance with the same distribution rule as that of the reception side distributing filter. It is additionally provided with an allocation table not shown of hash values to the respective cluster members. That is it is possible to determine not only the hash value allocated to the cluster member itself but also the hash values allocated to the other cluster members.

The application process distributing section executes a process to determine the cluster member to process the reception data on the basis of contents of application data which is data processed by the protocol processing section in the uppermost layer and transferred to the application program . The application process distributing section is also internally provided with a section to determine the cluster member to process the reception data on the basis of the same application distribution rule as the protocol process distributing section .

The cluster member having such functions can be realized by a computer and in such a case the computer is set as follows for example. There is prepared a disc a semiconductor memory or another recording medium in which a program is recorded for causing a computer to function as the cluster member and the program is read and loaded on the computer. The computer controls an operation of itself in accordance with the read program thereby realizing on the computer itself the protocol processing sections . . . and the reception side distributing filter the transmission side distributing filter the filter control section the reception interface the transmission interface the read API section the write API section the read API call trapping section the write API call trapping section the control section the transferring section the application process distributing section and the protocol process distributing section .

First a packet receiving process in the protocol and a reception data reading process by the application program will be described with reference to . A cluster reading process will be described later.

In the present exemplary embodiment the reception data is broadcasted to all the cluster members to and thereby the packet to be processed in the cluster system reaches all the cluster members to regardless of whether or not it is a data to be processed.

Referring to when receiving the packet via the reception interface the reception side distributing filter first distributes the packet by checking whether or not the packet is addressed to the representative MAC address of the cluster system steps S and S . Here the packet which may be possibly received is classified into the following three kinds 

The packet which is received directly from a communication node and addressed to the representative MAC address of the cluster system

The packet which is transmitted from another cluster member addressed to a MAC address of the its own cluster member and includes the reception data and

The packet which is transmitted from another cluster member addressed to the MAC address of the cluster member itself and includes the transmission data.

The packet which is not addressed to the representative MAC address of the cluster system does not require a clustering process and is therefore transferred to the protocol process by skipping a distributing process at steps S and S steps S to S .

With a packet addressed to the representative MAC address of the cluster system a hash value is calculated by applying a predetermined hash function to a header of the packet in the reception side distributing filter step S .

The hash function is typically a process in which a transmission source address and a destination address of the IP header are regarded as integer values of four bytes a sum of the values is calculated and further a remainder of a predetermined positive number is calculated. However any hash functions may be employed as long as using a calculation method by which traffic can be entirely distributed to each of the cluster members without any gap.

Next the reception side distributing filter determines whether a hash value calculated as described above is equal to an integer value allocated to the cluster member in advance step S . This allocation of the integer value is made in a same manner as the conventional broadcast rooter cluster. The packet having the calculation result which differ from an allocated hash value is discarded step S whereas only the packet whose calculation result is coincident with the allocated hash value is passed through the reception side distributing filter step S .

The packet passing through the reception side distributing filter is transferred while being processed from the protocol processing section in a low layer to the protocol processing section in a high layer steps S and S .

When ending the protocol process the protocol processing section in the uppermost layer notifies that data can be read to the read API section so that the application program receives the reception data via the read API section step S .

Meanwhile the application program calls the read API section to read the reception data via the read API section as shown in . In the present exemplary embodiment this call is trapped by the read API call trapping section steps S and S so as to execute the reading redirecting process step S .

Here the reading redirecting process executed at the step S will be described in detail with reference to the flowcharts of . First the read API call trapping section reads the reception data transmitted from the read API section . However if there is no reception data the reading process is blocked until the reception data is prepared in the same manner as the conventional method steps S and S .

When the reception data is read it is transferred to the application process distributing section . The application process distributing section determines whether the data is a data redirected from another cluster member based on a transmission source or the like of the data step S .

If the data is not the redirected data it is determined to be the reception data directly received from a communication node of the application program . This data is uploaded through the read API section after being manipulated in the protocol process without any change and the application process distributing section recalculates the hash value of the reception data by using a hash function supplied from the application program to apply a distribution method for an application program which differs from the distribution method for the protocol process step S .

If the calculation result is equal to the hash value allocated to its own cluster member YES at step S it is assumed that the process target application program operates in its own cluster member so that the packet is transferred to the application program via the read API call trapping section step S .

If the calculation result differs from the allocated hash value NO at step S it is assumed that the target application program operates in another cluster member. Which of the cluster members a hash value is allocated to is given in advance and the allocation is referred to retransmit the reception data to the cluster member in charge step S .

Therefore the reception data is transferred to the transferring section the transferring section encapsulates the reception data into a UDP datagram or the like addressed to one cluster member on which the target application program operates and further information is added to indicate that the data is reception data so that the writing process is executed steps S to S . Then a packet including the reception data is finally transmitted to the data link from the transmission interface step S . The reception data directly received from the communication node of the application program can be processed as described above.

If the reception data is redirected from another cluster member the data is further grouped into data which was originally reception data and data which was originally transmission data. Whether or not the data is the reception data can be determined based on the information which is attached at the time of redirecting the data and indicates that the data is reception data.

If the data is the reception data YES at step S the cluster member is determined to be in charge of the application process when the other cluster member calculates a hash value to the data. Therefore the received reception data is transferred to the application program via the read API call trapping section step S .

If the data is the transmission data NO at step S the afore mentioned process at the steps S to S is executed. It should be noted that whether or not the data is the transmission data can be determined on the basis of the information which is attached at the time of redirecting the data and indicates that the data is the transmission data.

Next the writing and transmitting process will be described with reference to the flowcharts of . When the application program calls the write API section this call is trapped by the write API call trapping section to transfer the transmission data from the application program to the protocol process distributing section steps S and S .

The protocol process distributing section therefore applies a hash function for the protocol process to the transmission data which is transferred from the write API call trapping section in order to calculate a hash value step S .

If the calculation result is equal to the hash value allocated to its own cluster member YES at step S the cluster member in charge of applying the protocol process to the transmission data is determined to be its own cluster member and the transmission data is transferred to the protocol processing section via the write API section steps S to S . It should be noted that the transmission data is transferred after waiting for a state in which data can be written if the protocol processing section is not ready to write data. Thereafter the protocol process is executed successively from the protocol processing section in the uppermost layer and a packet is finally transmitted to the data link via the transmission interface steps S to S .

In contrast if the calculation result differs from the allocated hash value No at step S it is determined that a cluster member in charge of the protocol transmission process is not the cluster member itself. Since which cluster member the hash value is allocated to is given in advance in the same manner as the case of the reception data the allocation is referred to transmit the transmission data to the cluster member in charge.

The protocol process distributing section therefore transfers the transmission data to the transferring section where the transferring section encapsulates the transmission data into a UDP datagram or the like addressed to the cluster member in charge and further attaches information indicating that the data is the transmission data. Then the transferring section executes the writing process steps S to S . Thereafter a packet is finally transmitted to the data link via the transmission interface step S .

Next in the same manner as the first exemplary embodiment an operation of the APIs other than the reading writing processes will be described. Here a cluster method according to the present exemplary embodiment applied to the above control API using a Barkley socket API which is one of primary communication APIS will be described. Like the first exemplary embodiment a typical method of using the Barkley socket API on the server side and the client side will be described with reference to a sequence diagram for the session establishing process.

Three system calls including bind listen and accept are mainly used to establish the session on the server side. A clustering process in each of these system calls will be described sequentially.

Reception data actually arrives when the communicable state is set and the reading process is executed to distribute arrived traffics to the application programs in the cluster members.

However the application program may not call accept yet at this point of time in some of the cluster members. It is because the application programs operate on different machines from each other so that the process progress is not matched. Since the application program which does not yet call accept is not ready to wait for session establishment it cannot execute the reading process even if the data receiving process is allocated to the cluster member having the application program.

In order to avoid the above problem an entry of a cluster member with an application program operating thereon is added to a hash value allocation table for the cluster members when accept call is carried out by the application program.

When the application program of another cluster member calls second or later accept the call is notified to other cluster members for simply adding the entry thereof to the hash value allocation table corresponding to the case where accept is called by a cluster member and a cluster member N in . As described above when the session is established the cluster member in charge of process is selected based on the application programs in a waiting state and traffic is transmitted to the cluster member in charge.

Also the above procedure is applied to the case of establishing a session in a connection oriented protocol whereas only the bind process is made redundant in the above procedure in case of a connectionless protocol. In the application program using a connectionless protocol since the application program can receive data immediately after completion of the bind process an entry of a cluster member with the application program operating thereon is added to the hash value allocation table.

On the client side a session is typically established by issuing the system call of connect . When the system call is issued an endpoint on its own node side is fixed to request a protocol to establish the session with a counter endpoint and a call is returned in response to the session establishment.

Here a process to fix an endpoint on its own node side is first executed. In a normal connect call a port number at an appropriate endpoint is selected by the protocol side. In the present exemplary embodiment there is a possibility that arguments of a hash function required to calculate the cluster member in charge of the protocol process are lack if the endpoint is not specified.

The hash function for distributing the protocol process typically uses an address and a port number included in a protocol header or the like. The counter endpoint is given from the application program as an argument of the connect call. However if the endpoint is not fixed it is impossible to obtain the above information and therefore the control section first determines the endpoint on its own node side.

Next the cluster member in charge of the protocol process is determined and a session establishing request is transmitted to the cluster member in charge. In the example of the application program of the cluster member calls connect and the cluster member is determined to be the cluster member in charge of the protocol process. The cluster member in charge of the protocol process fixes an endpoint on its own node side by the system call of bind and subsequently issues the system call of connect to actually establish a session. The result of the above process is notified to the cluster member which is a calling source of connect and thus the process to establish the session is ended.

According to the present exemplary embodiment in the cluster system of the broadcast dispatch type with the application program operating thereon it is possible to use different cluster members to execute the application process and the protocol process with respect to an identical traffic in load balancing. This is because the configuration is employed which includes the read API call trapping section the write API call trapping section the control section the transferring section the application process distributing section and the protocol process distributing section between the application program and the read write API sections and .

The present exemplary embodiment has one feature in that performance in the entire system is improved by distributing a traffic process load to a plurality of cluster members and reliability is further enhanced by processing the traffic redundantly.

Referring to the cluster member is provided with a packet filter and a distributing redundancy processing section like the second exemplary embodiment. However the distributing redundancy processing section also carries out execution of a redundancy process in addition to simple determination of the cluster member in charge of the application process by using a hash value.

Two hash values are allocated to each of the cluster members in order to determine the cluster member in charge of the protocol process. One of the hash values is used for a current use process and the other one is used for a backup process. A hash value is allocated to one cluster member in charge of the current use process and one cluster member in charge of the backup process.

The broadcasted traffic is received by all the cluster members and is processed by two cluster members in the current use system and the backup system in accordance with hash values calculated from a header or the like. After the protocol process is redundantly executed data collation is carried out prior to transfer of the reception data to the application program. Thereafter the cluster member in charge of the application process is determined in accordance with a hash function defined by the application program and if necessary the reception data is redirected to the cluster member in charge. Accordingly the application program can receive data without being conscious of which of the cluster members carries out the protocol process and whether or not the protocol process is made redundant.

The present exemplary embodiment is realized by using cluster members having a configuration shown in in place of the cluster members to each having the configuration shown in in the cluster system shown in .

The difference between the cluster member used in the present exemplary embodiment and the cluster member as shown in is in that the application process distributing copying and collating section is provided in place of the application process distributing section and the protocol process distributing copying and writing section is provided in place of the protocol process distributing section .

The application process distributing copying and collating section executes a process corresponding to the redundancy process on the reception side in the first exemplary embodiment and the distributing process on the reception side in the second exemplary embodiment.

The protocol process distributing copying and writing section also executes a process corresponding to the redundancy process on the transmission side in the first exemplary embodiment and the distributing process on the transmission side in the second exemplary embodiment.

 1 All the cluster members operate to be current use in the application process and each of the cluster members is in charge of backup for any one of the other cluster members. If any one of the cluster members is failed the cluster member in charge of the backup for the failed cluster member takes over the application process thereof and

 2 The cluster member in charge of the backup is prepared separately from the current use cluster member. This cluster member performs as the backup cluster member for all the application processes. This cluster member usually does not execute processes except for saving a state required in the backup process or the like.

The functions of components other than the above component are similar to those of the first and second exemplary embodiments and the description thereof will be omitted.

It should be noted that the cluster member can be realized by a computer. In such a case a disk a semiconductor memory or another recording medium in which a program is recorded to cause the computer to function as the cluster member is prepared and the program is loaded in the computer. The computer controls the operation of itself in accordance with the loaded program to realize on the computer itself the protocol processing sections . . . and the reception side distributing filter the transmission side distributing filter the filter control section the reception interface the transmission interface the read API section the write API section the read API call trapping section the write API call trapping section the application process distributing copying and collating section the protocol process distributing copying and writing section the control section and the transferring section .

First a process steps S to S in will be described. In the process of the steps S to S in the same process as a process of the steps S to S in the second exemplary embodiment as shown in is executed while in the process of the steps S to S the same process as a process of the steps S to S as shown in is executed. The difference from is in that the process of the step S is executed when a received packet is addressed to the representative MAC address of the cluster system and a hash value obtained by the reception side distributing filter is equal to a corresponding hash value of its own cluster member YES at steps S and S . Since one hash value is allocated to the cluster member in chare of the current use process and the cluster member in charge of the backup process a process is executed at the step S where which of the above two cluster members the received packet corresponds to is determined by using the hash value allocating table and the information indicating the allocation is attached to the packet.

Meanwhile the application program calls the read API section in order to read the reception data via the read API section as shown in . In the present exemplary embodiment this call is trapped by the read API call trapping section steps S and S so as to execute the reading and redirecting process step S .

When the reception data is read it is first determined which of processes the read data corresponds to step S . In the present exemplary embodiment the reception data corresponds to one of following seven kinds 

2.1 Collation data transmitted from the current use cluster member in charge to the backup cluster member in charge and

2.2 Collation result transmitted from the backup cluster member in charge to the current use cluster member in charge 

3.1 Reception data transmitted from the cluster member in charge of the protocol process to the cluster member in charge of the application process 

3.2 Transmission data transmitted from the cluster member in charge of the application process to the cluster member in charge of the protocol process and

3.3 Write notice transmitted from the cluster member in charge of the protocol process to the cluster member in charge of the application process.

If a packet is encapsulated by UDP or the like and a flag is attached to the packet to indicate the collation data or the redirect data these data can be determined. Other data are data which is directly received from the communication node and information is attached to indicate that the data is for the backup process. As described above the above seven kinds of data can be determined.

Of data received directly from the communication node if the data is for the current use process a process is executed to collate the reception data with the cluster member in charge of the backup process. More specifically the reception data is first copied step S and a replica data is transmitted as collation data to the cluster member in charge of the backup process via the transferring section step S . Here the reception data is held by the cluster member in charge of the current use process until a collation result is received.

Of data received directly from the communication node if the data is for the backup process the reception data is collated with the collation data transmitted from the current use cluster member. More specifically if the reception data is first received NO at step S arrival of collation data is waited for while holding the reception data step S . Since the reception data and the collation data can be associated with each other by using information on the connection endpoint such as a transmission source address destination address and port number to which the data is transmitted the information is also held along with the data. When the data is prepared the content of the data is collated step S so as to transmit the collation result back to the current use system by using the transferring section step S .

If the collation data of data used for the collating process is received it is assumed that a corresponding data for the backup process is received. The process at the steps S and S is executed if these data has been already received YES at step S or the process is executed after waiting for receiving these data if not yet received.

If the collation result of data used for the collating process is received it is confirmed whether or not the collation has been successfully made. In case of collation failure the reception data is discarded to end the process not shown but carried out prior to the step S . In case of the collation success a hash function supplied from the application program is used to recalculate the hash value of the reception data and to determine the cluster member on which the application program operates to process the stored reception data step S .

If the calculation result is equal to the value allocated to the cluster member YES at step S the application program to process the reception data is assumed to be operating on this cluster member and therefore a packet is transferred to the application program via the read API call trapping section step S .

If the calculation result is different from the allocated value NO at step S the application program to process the reception data is assumed to be operating on another cluster member. Since it is informed in advance which cluster member a hash value is allocated to the reception data is retransmitted to the cluster member to process the reception data by referring to the allocating table step S . Therefore the reception data is transferred to the transferring section and the transferring section encapsulates the reception data into a UDP datagram or the like addressed to the cluster member on which the application program to process the data is operating attaches information indicating that the data is the reception data and further executes the writing process.

If the data redirected from another cluster members is the reception data this indicates that the other cluster member a hash value to the data and determines that this cluster member is in charge of the application process. Therefore the reception data is transferred to the application program via the read API call trapping section step S .

The processes in the case of the transmission data and the write notice will be described together with the writing process.

According to the configuration of the present invention the call of the write API section is trapped by the write API call trapping section so as to execute the following process as the writing process step S .

First the hash value of the reception data is recalculated by applying a hash function for the protocol process to the transmission data which has been written by the application program . The cluster member in charge of the hash value is determined by searching the hash value allocating table for the hash value step S .

Since one hash value is allocated to two current use and backup cluster members in the protocol process the packet is first copied to transfer the packet to these cluster members step S .

Next in order to make the protocol process redundant the transmitting process is executed by each of the current use cluster member and the backup cluster member. The cluster member in charge of the backup process first executes the transmitting process like the first exemplary embodiment. If the cluster member itself is in charge of the backup process YES at step S the transmission data is written directly via the write API section step S . Details of the writing and transmitting process will be described later with reference to . When the data is successfully written the copied transmission data is transmitted to the cluster member in charge of the current use process which is always allocated to a cluster member other than its own cluster member steps S and S .

If its own cluster member is not in charge of the backup process YES at step S the replica data is redirected to the cluster member in charge of the backup process in order to cause the cluster member to execute the transmitting process step S .

When the replica data is redirected to another cluster member the other cluster member which received the replica data executes the transmitting process in the extension of the redirected data receiving process in case that the redirected transmission data is received as shown in . In this case since it has been already determined that the cluster member executes the protocol process for transmission data the transmission data is simply written via the write API section step S . When the writing process is ended the result is transmitted back to a redirect source i.e. a cluster member whose application program calling the write API section as a write notice step S .

Next a process responding to reception of the write notice will be described. First if the write notice indicates a result of failure NO at step S of an error is returned to the writing process of the application program due to determination of the failure in data write step S .

Next if the data is successfully written YES at step S necessity of the current use process is determined step S . If the redirect source is not the cluster member in charge of the backup process the transmitting process on the current use system side is further required after executing the backup process. Accordingly whether or not the transmitting process on the current use system side has been already executed is determined and the process is executed if it is not yet executed YES at step S . If the transmitting process is already executed on the current use system side NO at step S the transmission data is discarded to notify an error to the application program step S .

If its own cluster member is in charge of the current use process YES at step S the data is written directly by calling the write API step S . If the data is successfully written a process of the write API section called by the application program is properly ended.

If another cluster member is in charge of the current use process NO at step S the transmission data is redirected to the cluster member step S . Furthermore when the write notice is received it is confirmed whether or not the data is successfully written and the data writing result is notified to the application program to end the writing process.

The protocol transmission process is executed by the procedure of . A process similar to the writing process described in the first exemplary embodiment e.g. steps S to S in is executed at steps S to S. In step S it is determined whether or not the packet is for the backup process. Then the packet is discarded if it is determined to be for the backup process YES at step S or the packet is transmitted via the transmission interface if it is not NO at step S .

Here the process at the steps S to S can be realized as follows. Additional information indicating that a copied packet is for the backup process is attached to the transmission data at the step S of and the transmission side distributing filter discards the packet only when the packet is for the backup process.

Alternatively the following process may also be employed. The transmission side distributing filter holds the hash value corresponding to its own cluster member in charge of the current use protocol process and the hash value corresponding to its own cluster member in charge of the backup process. With the packet transferred from the protocol processing section to the transmission side distributing filter whether or not a transmission source address is identical to the representative address is determined. The packet not having the representative address of the cluster system as the transmission source address is not a packet for the redundancy process such as communication among cluster members and the packet is transmitted without making any changes. With the packet having a representative address of the cluster as the transmission source address the hash value is calculated from a header of the packet or the like in the same manner as the process in the reception side distributing filter i.e. steps S to S and a flag for the current use or backup process is attached to the packet. If the flag for the backup process is attached to the packet the packet is discarded.

Other processes are roughly divided into a session control and dead alive state monitor. The session establishment basically involves only two of current use backup cluster members which execute accept and connect in the sequence of the second exemplary embodiment and therefore the detailed description will be omitted.

The dead alive state monitor will be carried out as follows. The cluster members share the hash value allocating table for the protocol process and the application process. One cluster member in charge is allocated for every hash value in the allocating table. The dead alive state of each of the cluster members is controlled by operation confirmation communication and the operation state is reflected on the allocating table. Thus the dead alive state can be reflected in the cluster process.

First an example of an operation confirming procedure will be described. Each of the cluster members broadcasts an operation notice message on the data link in a predetermined interval set as t . Each of the cluster members manages the operation notice from each of the other cluster members by using the cluster member of the transmission source as a key and determines that the cluster member from which a new operation notice cannot be received for a predetermined period of time set as t and t t is in a failure state.

Next a method of updating the hash value allocating table will be described. The hash value allocating table includes one of the hash values as a key and an operating cluster member for each hash value. If the cluster member is determined to be in the failure state the cluster member is deleted from the allocating table.

Through the above procedure the allocating table is updated as follows. Since two of current use and backup cluster members are allocated to one hash value of the hash value allocating table for the protocol process no cluster member in charge lacks on the table if only one of the cluster members is in the failure state. In contrast only the current use cluster member is usually registered on the allocating table for the application process. Therefore if the cluster member is in the failure state the backup cluster member allocated in advance is registered to the entry of the applicable hash value.

The reading process according to the present exemplary embodiment may also be executed in the following procedure. According to the description in the present exemplary embodiment when the cluster member in charge of the backup protocol process receives data the data is discarded at the time of completion of the collation. However if the cluster member is in charge of the application process efficiency is high when the data is not discarded but is directly transferred to the application program. Therefore the cluster member in charge of the backup process may calculate a hash value by using the hash function supplied form the application program without discarding the reception data when the reception data is successfully collated and transfers the reception data to the application program without any changes if its own cluster member is in charge of the application process. In this case the current use cluster member calculates the hash value and discards the reception data without redirecting if the cluster member in charge of the application process is equal to the backup cluster member in charge of the protocol process. Thus the process is ended.

The following procedure may also be employed. The above procedure is efficient in terms of no meaningless data transfer but wasted in terms of calculating a hash value twice to all the data in successful collation. Therefore when the current use cluster member calculates the hash value and the cluster member in charge of the application process is equal to the backup cluster member in charge of the protocol process this may be notified to the backup cluster member. The backup cluster member in charge of the protocol process simply holds successfully collated reception data without calculating the hash value and transfers the data to the application program in response to a notice from the current use cluster member if its own cluster member is in charge of the application process and discard the data if the cluster member in charge is different. Accordingly the hash value is calculated only once without wasted transfer of the reception data.

According to the present exemplary embodiment performance in the entire system can be increased by distributing a process load of a traffic into the plurality of cluster members and the reliability is improved by processing traffic redundantly. This is because the configuration is employed which includes the read API call trapping section the write API call trapping section the control section the transferring section the application process distributing copying and collating section and the protocol process distributing copying and writing section between the application program and the read write API sections and .

Next a fourth exemplary embodiment of the present invention will be described in detail. The present exemplary embodiment has one feature in that an identical protocol process can be executed by both of the cluster members in the current use system and the backup system even if a large delay is caused in the transmitting process in one of the cluster members of the current use system and the backup system and even if a packet transmitted from a counter apparatus cannot be received by one of the cluster members of the current use system and the backup system.

According to the afore mentioned first exemplary embodiment the protocol process is made redundant by using two of the cluster members in the current use system and the backup system so as to realize the reliability enhancement. At this time the identical protocol process needs to be executed by the cluster members in the current use system and the backup system. However the state in which the identical protocol process is not executed is continued due to the following phenomena in practice resulting in the loss of redundancy in a protocol state.

That is when the protocol process such as TCP to confirm transmission is made redundant the protocol process cannot be maintained in one of the systems in following cases 

 1 a packet arrives only in one of the current use system and the backup system while the same packet does not arrive in the remaining system or the packet is dropped due to a defect in one of the systems and

 2 a significant delay is caused in one of the current use system and the backup system to carry out a transmission confirmation packet before transmission of the packet.

 1 a If the packet arrives only in the current use system the protocol processing section in the current use system receives the packet and transmits the confirmation response packet. The backup system generates but does not externally transmit the confirmation response packet indicating that the reception packet is dropped. Therefore only the confirmation response packet issued from the current use system arrives in the counter apparatus and the counter apparatus transmits a subsequent packet. If this process is repeated the backup system cannot receive the dropped packet and cannot recover a same state as the current use system forever.

 1 b If the packet arrives only in the backup system the protocol processing section in the backup system receives the packet and generates the confirmation response packet. However this confirmation response packet is not externally transmitted. Since the current use system transmits a confirmation response indicating that the reception packet is dropped the counter apparatus determines that the transmission packet is lost and retransmits the packet. The retransmitted packet is received only in the current use system while the retransmitted packet is simply discarded in the backup system even if it arrives therein. Accordingly a packet loss is not problem in case of 1 b .

Next 2 is divided into following two cases 2 a a transmitting process is delayed in the current use system and

 2 a No defect will occur when the transmitting process is delayed in the current use system. Even if the backup system first executes a transmitting process the packet is not externally transmitted in practice which means that no confirmation response packet transmitted from the counter apparatus will arrive in a non transmitted packet of the current use system.

 2 b If the transmitting process is delayed in the backup system the current use system is supposed to execute the transmitting process prior to starting the transmitting process in the backup system. Furthermore when a packet transmitted from the current use system arrives in the counter apparatus the counter apparatus immediately transmits the confirmation response packet. When the confirmation response packet is actually delivered from the counter apparatus it reaches not only the current use system but also the backup system. The confirmation response packet arrives to a non transmitted packet in the backup system but such a confirmation response packet is usually discarded. Even if the backup system executes the transmitting process of the packet thereafter the packet is not externally transmitted. Therefore there is no chance to receive the confirmation response packet from the counter apparatus and the backup system is forced to continuously retransmit the above packet after which a retransmission timer reaches a timeout to cut off the connection.

In the present exemplary embodiment a redundancy function including an additional function to solve a defect caused by a dropped packet in the backup system and a deviation in the transmission time will be described.

The present exemplary embodiment is realized by using cluster members shown in in place of the cluster members to in the cluster system of the broadcast dispatch type as shown in . The cluster system according to the present exemplary embodiment will function as a server i.e. server cluster .

The difference between the cluster member according to the present exemplary embodiment as shown in and the cluster member according to the first exemplary embodiment as shown in is in that a reception side distributing filter and a transmission side distributing filter are provided in place of the reception side distributing filter and the transmission side distributing filter . The reception side distributing filter and the transmission side distributing filter have different configurations in case of the cluster member operating in the current use system and in case of the cluster member operating in the backup system. It should be noted that the cluster member according to the present exemplary embodiment can also be realized by a computer in the same manner as the cluster member according to the first exemplary embodiment.

When the cluster member operates in the backup system the reception side distributing filter and the transmission side distributing filter have same configurations as a reception side distributing filter and a transmission side distributing filter as shown in respectively.

Referring to the reception side distributing filter is provided with a distributing section a reception notice transmitting section and a filter processing section .

The distributing section has a function to distribute a packet received via the reception interface to the reception notice transmitting section if the packet is addressed to the representative address of the cluster system or if the packet is broadcasted or to distribute the packet to the protocol processing section if the packet is not addressed thereto.

The reception notice transmitting section has a function to generate an identifier to identify the packet whenever the packet is transferred from the distributing section and further to transmit a reception notice packet including the generated identifier to the cluster member in the current use system.

The transmission side distributing filter is provided with a distributing processing section a transmission notice transmitting section and a filter processing section .

The distributing section has a function to distribute the packet transferred from the protocol processing section to the transmission notice transmitting section if the packet is to be made redundant and to distribute the packet to the transmission interface in other cases.

The transmission notice transmitting section has a function to acquire a sequence number of transmission data included in the packet whenever the packet is transferred from the distributing section and to transmit a transmission notice packet including the sequence number to the cluster member in the current use system.

When the cluster member operates in the current use system the transmission side distributing filter has the same configuration as the transmission side distributing filter used in the first exemplary embodiment while the reception side distributing filter has the same configuration as a reception side distributing filter shown in .

Referring to the reception side distributing filter used by the cluster member in the current use system is provided with a distributing section a reception packet control section a reception packet buffer a backup system reception history storage section a reception notice receiving section a confirmation response buffer a backup system transmission history storage section and a transmission notice receiving section .

The distributing section has a function to distribute a packet transmitted from the counter apparatus and received via the reception interface as well as a reception notice packet and a transmission notice packet transmitted from the backup system to the reception control section the reception notice receiving section and the transmission notice receiving section .

The reception notice receiving section has a function to store an identifier included in a reception notice packet transmitted from the backup system in the backup system reception history storage section .

The transmission notice receiving section has a function to store a sequence number included in a transmission notice packet transmitted from the backup system in the backup system transmission history storage section .

The reception packet control section has a function to store a normal packet including data in the reception packet buffer a function to store a confirmation response packet including confirmation response data in the confirmation response buffer a function to transfer a received packet to the protocol processing section a function to transmit a packet stored in the reception packet buffer to the cluster member in the backup system and a function to transmit the confirmation response packet stored in the confirmation response buffer to the cluster member in the backup system.

Next the operation according to the present exemplary embodiment will be described dividing into the operation in the current use system and the operation in the backup system. It should be noted that redundancy operation itself is the same as that of the first exemplary embodiment and the description of the redundancy process will be omitted here.

The operation in the backup system will be described first. shows a flow of the operation of the backup system.

First an operation at the time of receiving a packet in the backup system will be described. When the packet is received from the counter apparatus via the reception interface the distributing section determines whether or not the packet is addressed to the representative address or whether or not the packet is broadcasted to both of the current use system and the backup system on the basis of the destination MAC address of the packet steps S and S .

If it is determined that the packet is not addressed to the representative address NO at step S the distributing section transfers the received packet to the protocol processing section . A protocol reception process is therefore executed.

In contrast if it is determined that the packet is addressed to the representative address YES at step S the received packet is transferred to the reception notice transmitting section .

The reception notice transmitting section therefore generates an identifier to identify the received packet step SA . The identifier is information by which the packet can be identified from other packets and a checksum of the packet is used. However it does not need to be a checksum and any values may be used as an identifier as long as the packet can be identified by the information. For example the hash value which is calculated by applying the hash function to the packet may also be used as the identifier.

Thereafter the reception notice transmitting section generates a reception notice packet including the above identifier to transmit to an address of the cluster member in the current use system step SB . This process normally includes the protocol transmission process and is therefore taken over by the protocol transmission process step S in . After executing the above process the received packet is subjected to the filtering process by the filter processing section step SC and then is transferred to the protocol processing section for the receiving process step SD .

Next the transmitting process in the backup system will be described. When the transmission packet is transferred from the protocol processing section the distributing section in the transmission side distributing filter determines whether or not the packet is to be made redundant steps S and S . This determination is based on the content of a header of the packet and a transmission source address. It should be noted that a packet originated from a write API call made by the write API section step S a reception notice packet and a transmission notice packet are transferred form the protocol processing section to the distributing section .

Then if the transmission packet is not to be made redundant NO at step S the distributing section transmits the transmission packet via the transmission interface step S .

In contrast if a transmission packet is to be made redundant YES at step S the distributing section transfers the transmission packet to the transmission notice transmitting section .

Accordingly the transmission notice transmitting section first obtains a sequence number i.e. transmission sequence number from a header portion of the transmission packet step S . Next a transmission notice packet including the above sequence number is generated and transmitted to an address of the cluster member in the current use system step S . This process is also taken over by the protocol transmission process step S like the case of a reception notice packet.

After executing the above process the filter processing section executes a filtering process which is defined in the transmission side distributing filter step S . The above filtering process in the backup system includes at least a process to discard the transmission packet to be made redundant.

As described above a notice is transmitted to a cluster member in the current use system every time to execute a process to transmit receive a transmission reception packet to be made redundant.

Next an operation of the current use system will be described. B and C show a flow of the operation in the current use system.

When the packet is received via the reception interface the distributing section in the reception side distributing filter as shown in determines whether or not the packet is addressed to a representative address on the basis of a destination MAC address step S .

If the packet is addressed to the representative address YES at step S the distributing section transfers the reception packet to the reception packet control section . The reception packet control section therefore executes the filtering process which is defined in the reception side distributing filter as needed step S .

Thereafter the reception packet control section determines whether or not the reception packet is the confirmation response packet including confirmation response data transmitted from the counter apparatus step S .

Then if it is determined to be the confirmation response packet transmitted from the counter apparatus YES at step S a confirmation response number in a header portion of the packet or a sequence number of a normally received packet is extracted and this confirmation response number is used as a key to search the backup system transmission history storage section in order to examine whether or not the backup system has been already transmitted a packet corresponding to the above confirmation response packet step S . That is it is determined that the packet has been already transmitted if a sequence number which is identical to the confirmation response number is stored in the backup system transmission history storage section or it is determined that the packet is not transmitted yet if it is not stored therein.

Then if the packet is determined to be the confirmation response packet to the packet which is not transmitted yet from the backup system YES at step S the above confirmation response packet is stored in the confirmation response buffer to hold a reception process thereafter step S .

In contrast if the packet is determined to be the confirmation response packet to the packet which has been already transmitted from the backup system NO at step S the confirmation response packet is transferred to the protocol processing section step SA .

Moreover if the packet transferred from the distributing section is determined to be a normal packet including data transmitted from the counter apparatus at the afore mentioned step S i.e. NO in the determination result the reception packet control section searches the backup system reception history storage section to determine whether or not the same packet has been already received in the backup system step S . That is it is determined that the same packet has been already received in the backup system if the identifier identical to that of the received packet is stored in the backup system transmission history storage section whereas it is determined that the same packet is not received yet if the identifier is not stored therein.

Then if it is determined that the same packet has been already received in the backup system YES at step S the reception packet control section transfers the received packet to the protocol processing section and further deletes the identifier of the above packet from the backup system reception history storage section step SA .

In contrast if it is determined that the same packet is not received yet in the backup system NO at step S it may be necessary to transmit the above packet to the backup system. The above packet is copied and stored in the reception packet buffer and the above packet is further transferred to the protocol processing section steps S and SA .

The process to receive the packet which is to be made redundant i.e. a packet addressed to a representative address is as described above.

Next a case of receiving the packet which is not addressed to the representative address will be described.

If the packet received via the reception interface is not addressed to a representative address NO at step S the distributing section examines whether or not the packet is a transmission notice packet transmitted from the backup system step SC .

If the packet is the transmission notice packet YES at step SC the above packet is transferred to the transmission notice receiving section . The transmission notice receiving section therefore extracts a sequence number from the above transmission notice packet to store in the backup system transmission history storage section step SD . Sequence numbers are generally consecutive so that only the sequence number of the packet transmitted at last may be held in the backup system transmission history storage section .

When the sequence number is stored in the backup system transmission history storage section the reception packet control section searches the confirmation response buffer to find out a confirmation response packet having the sequence number identical to the above newly stored sequence number step SE . That is since the packet belonging to the above sequence number is not transmitted yet from the backup system a confirmation response packet stored or held in the confirmation response buffer at the step S is searched.

If such a confirmation response packet cannot be searched the reception packet control section ends the process. In contrast if the confirmation response packet can be searched the searched confirmation response packet is transferred to the protocol processing section to execute the receiving process in the current use system while transmitting the above confirmation response packet to the cluster member in the backup system via the protocol processing sections . . . and the read API section the copying and collating section and the transferring section steps SF SA and SB . The reason why the confirmation response packet is transmitted to the cluster member in the backup system is in that even if this confirmation response packet is received in the backup system it is highly possible that the confirmation response packet which has been issued for a non transmitted packet is discarded.

In this way the confirmation response packet issued for the packet which is not transmitted yet in the backup system is always retained in the confirmation response buffer in the current use system without being transferred to the protocol processing section . Furthermore when a transmission notice packet arrives from the backup system the confirmation response packet retained in the confirmation response buffer is transmitted to the protocol processing section . Through the above processes it is possible to solve the program 2 b caused by failing to receive the confirmation response packet issued for the non transmitted packet in the backup system.

The operation when the transmission notice packet is received from the backup system is as described above.

Next an operation when the reception notice packet is received from the backup system will be described.

When the packet received via the reception interface is determined to be the reception notice packet from the backup system YES at step SG the distributing section transfers the packet to the reception notice receiving section and the reception packet control section .

The reception packet control section therefore refers to the backup system reception history storage section and the reception packet buffer steps SH and SI to examine whether the state corresponds to any one of the following x 1 x 2 y 1 y 2 and z 

 x 1 a state that an identifier included in the reception notice packet is stored in the backup system reception history storage section and a packet corresponding to the above identifier is stored in the reception packet buffer 

 x 2 a state that an identifier included in the reception notice packet is stored in the backup system reception history storage section and a packet corresponding to the above identifier is not stored in the reception packet buffer 

 y 1 a state that an identifier included in the reception notice packet is not stored in the backup system reception history storage section a packet corresponding to the above identifier referred to as a packet P and packets received prior to the packet P are stored in the reception packet buffer and the packets received prior to the packet P include a packet which is not store an identifier corresponding to the backup system reception history storage section referred to as a packet P 

 y 2 a state that an identifier included in the reception notice packet is not stored in the backup system reception history storage section the packet P corresponding to the above identifier and packets received prior to the packet P are stored in the reception packet buffer and the packets received prior to the packet P store all identifiers corresponding to the backup system reception history storage section and

 z a state that an identifier included in the reception notice packet is not stored in the backup system reception history storage section and a packet corresponding to the above identifier referred to as a packet P is not stored in the reception packet buffer .

Thereafter the reception packet control section executes a process at the steps SJ to SL in accordance with a current state of the backup system reception history storage section and the reception packet buffer .

In case of the state x 1 it is determined as unnecessary to retransmit a packet because the packet is received in the backup system NO at step SJ . The same packet is also received in the current use system in this state and the entry of the packet is deleted from the reception packet buffer and the backup system reception history storage section step SL .

In case of the state x 2 it is determined as unnecessary to retransmit a packet because the packet is received in the backup system NO at step SJ . Moreover the content of the backup system reception history storage section is maintained without any changes because the packet may not be received yet in the current use system or may have been dropped. It should be noted that a flag is attached to the identifier so that the identifier is deleted to prevent memory leakage if the packet does not arrive after passing a predetermined period of time.

In case of the state y 1 it is highly possible that the packet P which is received in the current use system is dropped in the backup system. This is because the packet is received from the same data link in the current use system and the backup system which suggests that the order of receiving a packet is rarely switched. Therefore in this case it is determined as necessary to retransmit a packet YES at step SJ and the packet P stored in the reception packet buffer is transmitted to the backup system steps SK and SB . Moreover in this case the reception notice receiving section is instructed to store the identifier at the step SL. Accordingly the reception notice receiving section stores the identifier included in the reception notice packet which has been transferred form the distributing section at the afore mentioned step SG in the backup system reception history storage section .

In case of the state y 2 the current use system and the backup system have same packet reception histories so that it is determined as unnecessary to retransmit the packet NO at step SJ which is further followed by deleting entire entries from the backup system reception history storage section and the reception packet buffer step SL .

In case of the state z a packet is received in the backup system and it is determined as unnecessary to retransmit the packet No at step SJ . Moreover since the packet which is received in the backup system may not be possibly received in the current use system the reception notice receiving section is instructed to store an identifier at the step SL. The reception notice receiving section therefore stores the identifier included in the reception notice packet which has been transferred from the distributing section at the afore mentioned step SG in the backup system reception history storage section . It should be noted that a flag is attached to the identifier so that the identifier is deleted to prevent memory leakage if the identifier does not arrive after passing a predetermined period of time.

Through the above processes the packet which arrives in the current use system but does not arrive in the backup system is retransmitted from the current use system by confirming the backup system reception history storage section . Accordingly it is possible to solve the problem 1 a which is caused by dropping the reception packet only in the backup system.

As described above according to the present exemplary embodiment it is possible to avoid continuation of a deviated protocol state caused due to dropping of the packet and transmission delay. This is because the cluster member in the backup system is provided with the transmission notice transmitting section for transmitting a transmission notice packet indicating information on a transmission packet manipulated by the protocol process in the protocol processing sections . . . and while the cluster member in the current use system is provided with the reception packet control section . The reception packet control section stores a confirmation response packet in the confirmation response buffer under the condition that the transmission notice packet indicating information on the above transmission packet has not been transmitted from the cluster member in the backup system when the confirmation response packet to the above transmission packet is transmitted from the confirmation response buffer and the counter apparatus which is a destination of the transmission packet. The reception packet control section also transmits the confirmation response packet to the cluster member in the backup system under the condition that the confirmation response packet to the transmission packet which is indicated by the transmission notice packet is stored in the confirmation response buffer when the transmission confirmation packet is transmitted from the cluster member in the backup system.

The first and fourth exemplary embodiments are provided on the premises that identical transmission data is generated at least in the current use system and the backup system and a process to transmit a packet including the identical data is executed.

The identical packet is generated in a protocol which stores a message boundary such as SCTP if the identical data is written by an application program whereas different packets are generated due to deviated message partitions if transmission timings are different even if the identical data is written in a protocol which does not store a message boundary such as TCP.

For example it is assumed that data of 3000 bytes is written by the application program when the length of a data included in a packet is 1460 bytes S . At this time two packets each of which includes the data of 1460 bytes and one packet including the data of 80 bytes are to be transmitted if there is no following data S to S . The transmission data is held in the protocol transmission buffer until a confirmation response packet arrives from the counter apparatus.

Here if the writing process of the subsequent transmission data is executed in a state that a confirmation response is not issued for the last data of 80 bytes in its own system whereas a confirmation response packet issued for the last packet arrives prior to executing the writing process in another system the protocol transmission buffer in its own system has two write data mixed whereas the protocol transmission buffer in another system holds second write data only S .

If the transmitting process of a subsequent packet is executed in this state its own system outputs connection data including the old data of 80 bytes and the new data of 1380 bytes whereas another system outputs only the new data of 1460 bytes S . Deviation may be thus generated in the boundary of transmission data included in the packet.

Even in such a case defects are not usually observed because the protocol transmission buffer is empty when the confirmation response is issued for entire transmission data placed in the protocol transmission buffer which allows identical data to be placed again in the protocol transmission buffer when the data is written at the next time and a break of transmission data in each packet is aligned.

However if a period to receive the confirmation response is controlled by causing the sequence number of the transmission packet to correspond to a confirmation response number as described in the fourth exemplary embodiment deviation in the boundary of the transmission data makes it difficult to realize correspondence between the confirmation response and transmission data. In order to solve such a problem the present exemplary embodiment prevents the data of a transmission buffer from being mixed by different writing operations.

The transmission buffer monitoring section has a function to check whether or not a protocol transmission buffer belonging to each of the protocol processing sections . . . and is empty.

The all response notice receiving section has a function to receive a whole response notice issued by the transmission side distributing filter .

The write amount notifying section has a function to notify an amount of data to be written as the transmission data to the transmission side distributing filter .

The transmission side distributing filter has one feature in that the write amount notice receiving section the transmission amount measuring section and the all response notifying section are included therein. It should be noted that shows only a filter processing section as one of other configuration components which are provided in the transmission side distributing filters and and omitted to be shown herein.

The reception side distributing filter also has one feature in that a response trapping section is included. shows only the filter processing section as one of other configuration components which are provided in the reception side distributing filters and and omitted to be shown herein.

The write amount notice receiving section has a function to receive a write amount notice issued by the write amount notifying section at the time of writing data.

The transmission amount measuring section has a function to measure an amount of data included in the packet transmitted from its own filter .

The all response notifying section has a function to notify the all response notice receiving section on the API side that the whole amount of write data has been transmitted and responded.

The response trapping section has a function to trap a confirmation response packet having a predetermined sequence number.

When the application program calls the write API section the write API call trapping section executes a redundancy process prior to actually calling the write API section step S . The redundancy process is followed by a further process which is executed prior to the writing process.

First the write API call trapping section checks whether or not remaining data is present in the protocol transmission buffer or whether or not the protocol transmission buffer is empty by using the transmission buffer monitoring section step S . If there is the remaining data NO at step S the transmission is ended to wait for the remaining data to disappear step S .

An inspection of the remaining data is generally carried out by polling the protocol transmission buffer in a predetermined interval but if the predetermined interval is shortened for quality improvement frequent inspections are required and computing resources are wasted. It may take a long time to make the protocol transmission buffer empty so that such monitoring is inefficient. Therefore inspection of the remaining data is not carried out until all the response notices are received in the present exemplary embodiment.

When the all response notice receiving section receives all the response notices step S the write API call trapping section instructs the transmission buffer monitoring section to start the inspection. Thus the transmission buffer monitoring section inspects the protocol transmission buffer until the remaining data disappears steps S and S .

If no remaining data is detected by the transmission buffer monitoring section YES at step S the write API call trapping section transmits an amount of data to be written i.e. write amount to the transmission side distributing filter via the write amount notifying section step S . Thereafter the write API section is called to execute the writing process steps S and SB .

When the write amount notice receiving section receives a write amount step S the transmission amount measuring section in the transmission side distributing filter starts measuring an amount of transmission data from this point of time step SA .

Whenever the packet to be made redundant is transferred from the protocol processing section in a bottom layer the transmission amount measuring section integrates an amount of data included therein to a transmission amount steps SC and SD .

Thereafter the transmission amount measuring section checks whether or not an integrated transmission amount is coincident with a write amount received by the write amount notice receiving section in order to determine whether or not the transmission packet transferred from the protocol processing section this time is the last transmission packet to transmit the write data step SE .

If the transmission packet is not the last transmission packet to transmit the write data NO at step SE the transmission amount measuring section transfers the above transmission packet to the filter processing section . Therefore the filter processing section executes the filtering process to the above transmission packet as needed and then transmits the packet via the transmission interface steps SH and SI .

In contrast if the transmission packet is the last transmission packet to transmit the write data YES at step SE the transmission amount measuring section outputs to the response trapping section a confirmation response monitor instruction which instructs to trap a confirmation response packet transmitted from the counter apparatus to the above last transmission packet step SF . It should be noted that the confirmation response monitor instruction includes the sequence number of the above last packet. Thereafter the transmission amount measuring section ends a process to measure the transmission amount to transfer the above last packet to the filter processing section step SG . The filter processing section therefore executes the filtering process as needed and then transmits the last transmission packet via the transmission interface steps SH and SI .

Meanwhile when a confirmation response monitor instruction is supplied from the transmission amount measuring section the response trapping section checks whether or not the received confirmation response packet is issued for the last transmission packet whenever the confirmation response packet in connection with measurement of a transmission amount is received steps SJ and SK . More specifically it is checked whether or not a confirmation response number included in the received confirmation response packet is coincident with the sequence number included in the confirmation response monitor instruction in order to determine whether or not the confirmation response packet is issued for the last transmission packet.

If the confirmation response packet is not issued for the last transmission packet NO at step SK the response trapping section waits for receiving the next confirmation response packet to execute a process similar to the afore mentioned process step SJ .

In contrast if the confirmation response packet is issued for the last transmission packet YES at step SK entire data to be transmitted which is stored in the protocol transmission buffer is assumed to be confirmed and responded by the counter apparatus which means that the protocol transmission buffer is empty so that the response trapping section notifies this state to the all response notifying section . The all response notifying section therefore issues all the response notices to the whole response notice receiving section step SL .

When the all response notice receiving section receives all the response notices step S the write API call trapping section waits for the protocol transmission buffer to become empty steps S and S and executes the afore mentioned process at the step S and the processes thereafter when the protocol transmission buffer becomes empty.

As described above the data is always written when the protocol transmission buffer is empty in the present exemplary embodiment whereby a plurality of transmission data to be written cannot be included in a single packet and transmitted creating no deviation in the boundary of transmission data when it is packetized in the current use system and the backup system.

