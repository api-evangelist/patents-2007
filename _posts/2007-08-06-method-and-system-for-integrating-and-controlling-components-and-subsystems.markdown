---

title: Method and system for integrating and controlling components and subsystems
abstract: A method and system for integrating and controlling a hardware device having one or more embedded systems including one or more hardware components configurable for use with the hardware device and one or more operating systems for use with the one or more hardware components. A control module configurable for use with the one or more hardware components and one or more operating systems accesses and controls the one or more hardware components with the hardware device. The control module generates and displays access and control commands on the hardware device to allow user to operate and manage the embedded system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07681201&OS=07681201&RS=07681201
owner: Lectronix
number: 07681201
owner_city: Lansing
owner_country: US
publication_date: 20070806
---
This application claims the benefit of U.S. provisional application Ser. No. 60 835 558 filed Aug. 4 2006.

The present invention relates to a method and system for integrating developing and controlling components and subsystems for use in an embedded system.

Manufacturers and suppliers such as automobile and consumer electronics manufacturers and suppliers face challenges when attempting to integrate discrete components and subsystems as embedded systems. As the demand for feature content of the hardware and related software components and subsystems increases manufacturers and suppliers face challenges to integrate these discrete components as embedded systems in a manner that maximizes productivity in integration and increases the reliability of these efforts. In many cases these bag of parts are a diverse and sometimes incompatible mix of software and hardware components. Further there may be issues relating to validation reliability and performance of the system once the diverse software and hardware components are integrated. It would be advantageous to provide a method and system for integrating and controlling multiple components and subsystems for use as embedded systems that allows for reuse across many diverse products and platforms by multiple vendors.

A method and system for integrating and controlling components and subsystems for use in an embedded system includes a computer implemented method for development of a module for controlling an embedded system is disclosed. The method includes providing an abstraction layer for the one or more operating systems of the embedded system. One or more device drivers compatible for use with the one or more hardware components and operating systems of the embedded system are provided and may be used by the abstraction layer to function under the one or more operating systems of the embedded systems to create a control module.

A client server architecture may be created for the control module to use the abstraction layer to function under the one or more operating systems of the embedded system to interface between the one or more device drivers to control the functions of the one or more hardware components. The system and method may also include a tangible machine readable medium having instructions for generating a control module for one or more embedded systems that when executed cause the machine to create the module as described herein.

Referring now to the Figures a method and system for integrating and controlling components and subsystems for use in an embedded system is disclosed. Referring to the architecture of the method and system for creating a control module for use with an embedded system developed with the present invention is illustrated. It is understood that the control module used with the system may be of various configurations and may contain greater or fewer number of components to accomplish similar objectives. An embedded system for exemplary purposes may be considered a set of hardware and software dedicated to a particular purpose or use.

An embedded system may be embedded in a higher level system to perform the particular function or any electronic system that uses a processor. Such systems generally use microprocessors or they may use custom designed chips or both. It is understood that the system and method described herein may also be used in a computing environment such as a distributed computing environment.

The method for developing a control module for use in controlling an embedded system includes the use of an architecture that allows for portability modularity is easily distributable and accommodates replaceable user interfaces. Portability addresses the need to be able to move the system functionality rapidly to new hardware platforms and operating systems. At least two of the elements used to achieve this are the operating system abstraction OSAPI shared library which may provide a generic portable abstraction of operating system specific calls and the use of layered device drivers which can be rapidly ported across different hardware and operating system platforms.

Modularity deals with the ability to easily create control module builds that include or exclude sets of features. One element of modularity is packaging functionality into separate processes since this helps prevent functions from becoming entwined with one another. In distributed systems processes that may be geographically diverse intercommunicate over a networked communication path to produce a single cohesive system out of independent processing modules. Like many distributed systems the current method and system uses a client server architecture between processes.

The system and method of the present invention may be configured for use with derivative products requiring the user interface process be maintained as a discrete module that can be modified or replaced on a per product basis. This allows the functionality of the platform to be repackaged with entirely unique look and feel. While the architecture as a whole has been constructed to achieve these goals it is still important to consider underlying rationales while implementing specific software components to avoid practices that defeat the intended flexibility. For example a user interface that talks extensively to device drivers and other local services may still be portable and modular but loses the ability to be distributed across the network whereas this distribution is possible if the application limits its access to client server calls to the servers.

The exemplary control module for use in an embedded system created with the method according to the present invention is illustrated in . Control module includes a client server architecture interfacing with one or more device drivers and a shared operating system abstraction library OSAPI . These components cooperate with a user interface application shown in block to present various information to an operator. User interface may cooperate with one or more clients configured work in connection with a discrete hardware component as shown in or may be configured to work with a variety of third party devices to display relevant information or controls to the user. It is contemplated that the user interface and high level applications act as clients to the servers.

In one exemplary embodiment a computer implemented method for development of a module for controlling an embedded system may comprise at least the following steps of providing an abstraction layer for the one or more operating systems of the embedded system. The method identifies the one or more client hardware components and one or more operating systems of the embedded system. One or more device drivers compatible for use with the one or more hardware components of the embedded system using the abstraction layer to function under the one or more operating systems of the embedded system are obtained.

A client server architecture using the abstraction layer to function under the one or more operating systems of the embedded system to interface between the one or more device drivers to control the functions of the one or more hardware components is created for the control module. It is understood that the system and method may also include a tangible machine readable medium having instructions for generating a control module for one or more embedded systems that when executed cause the machine to create the module as described herein.

Referring now to software components of the control module may include one or more client server processes device drivers and shared runtime libraries all of which may utilize OSAPI for use in the embedded system for example in a vehicle . OSAPI provides a layer that converts abstracted calls into operating specific calls as will be described in greater detail below. A client server process may be an independent executable module containing one or more execution threads that runs within its own protected memory space. In the system platform illustrated in user interface client process communicates to and controls a set of middleware logic or server processes that each provide a specific service. These processes communicate using a client server model shown by reference numeral . It is understood that middleware may function but is not required to function as a server element.

Functionality may be implemented in servers in the client server model to monitor and control the integrated technology connected to the system. Servers maintain portability by using the OSAPI abstraction layer for its operating system and hardware access requirements. The functionality incorporated as part of the client server architecture includes creating logic in communication with the abstraction layer for management and control of the one or more hardware components and creating a user interface in communication with the servers to display commands for use by an operator of the embedded system to control the one or more hardware components. The abstraction layer provides operating system and hardware component access requirements to the client server architecture to allow control of the embedded system. Client server architecture may also include a single user interface for one or more servers to display commands for use by the user to operate the embedded system that may be graphically displayed on a video display screen incorporated in the embedded system.

One or more device drivers individually represented by reference numeral may include elements to provide connection access and or control to the hardware devices within the system. In some cases common services may be required for use by multiple processes or device drivers. Device drivers may be program routines that link the operating system to a component or device. The drivers typically contain the machine language necessary to perform the functions requested by the application.

Rather than build such common software into each process or driver a single instance of such code can be placed into a shared common library . The mechanism to support this may vary by operating system used in connection with the components or subsystem such as Windows CE and QNX. In the system platform the library may be used for services such as the OSAPI abstraction layer and configuration file access.

Referring now to a description of the device driver configuration for use in connection with the present invention is described in greater detail. System platform device drivers may comprise layered drivers having two or more layers associated therewith. In one exemplary embodiment layered device driver includes a first layer or command layer and a second layer or access layer. The layered drivers may be configured to work with the client server architecture to provide instructions and or commands to the components to access operate and or control one or more components and features of the components.

The various layers of the control module for use with the system of the present invention are further called out in . In addition to the device driver layer described above the application layer includes the user interface and servers . The user interface box represents the graphics rendering and other operating system specific input output portions of the application. In one exemplary embodiment the user interface communicates with the servers through TCP IP InterProcess Communication IPC .

The system architecture considers the graphics rendering of the user interface to be operating system dependent. However the user interface may also run on multiple operating systems with a component designed to handle operating system specific matters. Servers provide the core application functions including radio jukebox audio media player trip computer and overall system control among other modules. The servers maintain portability by using the OSAPI abstraction layer for its operating system and hardware access requirements.

The system includes an OSAPI adaptation layer that converts abstracted calls into operating system specific calls. An abstraction layer typically implies that there are two or more implementations of the target program so that one set of program calls or application programming interfaces API works on different platforms or environments. An API may include a language and message format used by an application program to communicate with the operating system or some other control program such as a communications protocol. APIs may be implemented by writing function calls in the program which provide the linkage to the required subroutine for execution.

The OSAPI adaptation layer cooperates with an operating specific API layer for various operating systems such as Windows NT Windows CE and QNX among others. The OSAPI adaptation layer does not preclude the use of existing off the shelf applications in the system. While the applications may be operating system specific they may also include internal operating system abstractions of their own that make them portable for use in various systems and configurations.

Referring now to and an embedded system having an application or control module created using the method of the present invention is illustrated. The client server portion of the application may be configured for use in connection with one or more embedded systems in a vehicle. As explained above it is understood that the method and system of the present invention may be configured for use in various industries for a variety of applications such as in the consumer electronics industry with cell phones and personal digital assistants PDA or in connection with point of sale terminals sold to retailers.

In one aspect of the present invention a client server architecture utilizes high level InterProcess Communications IPC abstracted components consisting of a client portion and a server portion. The software interface to the IPC may be built to use a variety of communication methods and or communications protocols such as the TCP IP BSD socket layer. The interface may be incorporated within OSAPI or programming language client objects that expose method calls for all middle ware services.

The Transmission Control Protocol TCP stream socket type may be used to provide guaranteed and in order delivery of packets. Additionally the keep alive property is used to ensure the sockets stay connected even when data flows are sparse. Further the client side will attempt to reconnect to the server if a broken link is detected. Thus clients will gravitate to a new server if a server was shut down and restarted for any reason.

For each client server connection two socket connections may be established. Each of these connections carries a full duplex packet stream between client and server. One of two connections used to carry asynchronous messages commands from the client to the server. When the server receives messages on this connection the protocol layer automatically responds with an acknowledgment over that same connection back to the client. The second connection is used in a similar manner but in the reverse direction for messages that originate from the server such as responses or status updates and are acknowledged by the client.

A client object exposes method functions for control to the client application. These method functions transmit appropriate commands over the TCP IP socket to the server where a function is invoked to process the command. Once the client interface transmits the command to the server it enters into a blocking wait for an acknowledgment from the server. In the event of a timeout the request is retransmitted. Otherwise until the acknowledgment is received execution of the calling client thread is stalled.

When the server process receives the message the protocol layer automatically sends the acknowledgment back to the client. This acknowledgment is sent prior to processing the command and is an indication only that the packet was received not that its contents are valid. Sending the acknowledgment prior to processing the message ensures that the stalled client thread is freed to continue execution as quickly as possible.

In this example the server process generates a status message back to the client in response to the command. For example the server process may send back to the client information regarding the frequency to which the radio server is tuned. This message travels across the second socket connection. A dedicated thread in the client process receives the incoming status message returns an immediate acknowledgment to the server and then invokes the application s function to process the incoming message or status update. The application s function is registered by the application layer when it initiates the client interface object.

In another example the basic execution thread may include the main user interface UI event thread blocks waiting for user inputs such as button presses. Based on user input the UI server process calls the appropriate client object methods to control the servers. Next the main server thread blocks waiting for commands over the client server connection. When executing received commands the server generates response messages such as status updates back to the client. Next client interface threads for which there may be one for each client in the user interface process block waiting for status updates from the server or servers.

Threads on either the client or server side that send messages always wind up stalled until the other side responds with an acknowledgment. In both the client and server protocol implementations this acknowledgment generation is protected with a mutex that only permits processing of one command at a time. This protection introduces some synchronization between the client and servers. Assuming an initial idle state when client or server initially sends a message the opposite side will take the mutex send an immediate acknowledgment and then begin processing the message. If an additional message is sent while the first message is still being processed the sending process will wind up blocked waiting for its acknowledgment until the first message completes and the mutex is released.

This generally single threads the command processing and response generation between the processes. It is not possible for the user interface for example to generate a flood of queued messages to a single server since the calling thread will start to stall after the initial immediately acknowledged message until the server catches up.

In general the responses and status events from the servers are handled as asynchronous events. The typical execution flow is the client side sends a command and then is later notified by an asynchronous message from the server of any status changes. In a few cases an additional layer to block the calling client until a response is received by way of a synchronous response has been implemented most notably for query calls to the SQL database server.

Referring back to exemplary embedded systems incorporating one or more control modules in accordance with system and method of the present invention in the client server architecture are described and illustrated. It is understood that the system platform may be configured to control a plurality of systems and components for vehicles including vehicle control systems vehicle condition monitoring systems communications telematics climate control and navigation and entertainment components such as portable media devices mobile telephones media players tuners and storage devices. Exemplary components are described for reference purposes.

Block represents a radio component. The AM FM radio server handles all tuning aspects of the AM FM tuner module in the system platform. It provides basic tune seek and scan support. Radio servers are implemented with and without built in preset support. Preset information may be maintained by the user interface application using the database server rather than built in to the radio server. As illustrated in the AM FM radio server component typically includes a connection to one or more device drivers that cooperate with the component to allow the client server platform to control the device.

Block represents a satellite radio component. The satellite radio server may communicate to the satellite receiver module via a communications link such as a serial communications link. It is understood that one or more of the exemplary components described herein may be included or removed from the system based on customer preference. Further additional components not described herein may be incorporated and controlled in the system. Device drivers are typically provided in connection with these components to allow integration and control of the device.

Block represents a video server and video media player. Hardware component of the system illustrated in supports display of video in a window on its main LCD display. This server component manages the video overlay region size and position and provides an interface to control what video source is displayed in the overlay window.

Block represents a local database service. A local database is used by various server components to hold information about internal and removable content such as audio content. The user interface layer code utilizes the information in the database both for display purposes during playback and to assist in the creation of song lists. The interface to the database engine is raw SQL commands. A single threaded interface to the local database service is desirable in most every instance of its use.

Block represent an audio media player AMP server. Several different types of audio media players conform to this class including but not limited to File Server Players ATAPI players and Smart Device Players. Each Audio Media Player has a Song Selector Play List Selector and an associated Media Device. The Media Device may be responsible for detecting the presence and status such as the insertion and ejection of media. The Media Device may also be responsible for interrogating the media for file types and processing them.

The Audio Media Player establishes a client to the Audio Zone Manager AZM . The AZM broadcasts what audio source is in each zone. Each Audio Media Player can use this to determine when to request or relinquish use of the particular shared Sound Device Driver the Audio Media Player may be associated with at the time.

Block represents a system player. The system player server component allows user interface code access to retrieve current real time clock data and to power down the system. Additionally the component handles the controls for the audio amplifiers with respect to sleep and mute though there is no direct client control.

Block represents a display server. The display server component handles manipulations of display parameters according to user requests and vehicle controls. One such example is the LCD display backlight intensity. The user may wish to modify the intensity to different values when the headlamps are on and when they are off. Additionally the backlight intensity may change according to the dash illumination dimmer control. The display server makes a connection to the Trip Player to obtain the parameter for use in setting the display backlight intensity.

Block represents an update manager component. The update manager server component handles the specifics of updating various system software and data file components from removable media. The update manager can accomplish updates of the boot image and application image in Flash license files and other content such as navigation and entertainment databases. The update manager detects the presence of update media as indicated by the presence of one or more update files and or license files. The update manager works with the license manager to accomplish updates.

Block represents an Audio Zone Manager AZM . The system may be designed to manage either a single zone or multiple zone configurations. The AZM is the point of control for what audio source is playing in which zone. Audio characteristics e.g. volume tone equalization balance etc. are controllable on a per zone basis. The AZM also provides a method whereby a priority audio message can be played over any audio source in a zone. This feature is useful for handling high priority messages for applications such as voice assisted navigation prompts.

Block represents a system monitor or trip player component. The trip player server component provides an IPC interface to vehicle information. It aggregates information provided by any number of device drivers that implemented the Vehicle Information interface. Limits on each parameter are driven from configuration files. As well as raw information the trip player provides trip computer functions including calculating values such as gallons of fuel to go to complete trip etc. The trip player maintains a central repository for checklists e.g. departure arrival etc. . The number of checklists and their contents is driven by configuration files.

The trip player maintains a central repository for maintenance items e.g. tire rotation oil change etc. The service rate for maintenance items is specified in terms of miles. The maintenance items are driven by configuration files. The checklists are configurable text that does not change dynamically so clients can request it as required. Vehicle parameters do change dynamically. Clients can register to receive periodic updates of any number of parameters. The update rate is a configuration parameter for the trip player as a whole.

Block represents a license manage server which accesses licensing information for use by the system. Block represents a navigation system having a variety of functions for monitoring and displaying driver assistance information including route guidance map rendering and vehicle location. It is contemplated that the system may manage and control a variety of other components.

While embodiments of the invention have been illustrated and described it is not intended that these embodiments illustrate and describe all possible forms of the invention. Rather the words used in the specification are words of description rather than limitation and it is understood that various changes may be made without departing from the spirit and scope of the invention.

