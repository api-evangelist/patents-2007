---

title: Computer system and method of adapting a computer system to support a register window architecture
abstract: A target computing system  is adapted to support a register window architecture, particularly for use when converting non-native subject code  instead into target code  executed by a target processor . A subject register stack data structure (an “SR stack”)  in memory has a plurality of frames  each containing a set of entries  corresponding to a subset of subject registers  of one register window  in a subject processor . The SR stack  is accessed by the target code  executing on the target processor . The SR stack  stores a large plurality of such frames  and thereby avoids overhead such as modelling automatic spill and fill operations from the windowed register file of the subject architecture. In one embodiment, a target computing system  having sixteen general purpose working registers is adapted to support a register window architecture reliant upon a register file containing tens or hundreds of subject registers 
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08001535&OS=08001535&RS=08001535
owner: International Business Machines Corporation
number: 08001535
owner_city: Armonk
owner_country: US
publication_date: 20070927
---
This application claims benefit of GB Patent Application No. 0619380.9 filed Oct. 2 2006 and U.S. Provisional Patent Application Ser. No. 60 853 924 filed Oct. 24 2006.

The present invention relates generally to the field of computers and computer systems. More particularly the present invention relates to a computer system which is adapted to support a register window architecture and to a method of adapting a computer system to support a register window architecture.

The central processing unit CPU or processor lies at the heart of all modern computing systems. The processor executes instructions of a computer program and thus enables the computer to perform useful work. CPUs are prevalent in all forms of digital devices in modern life and not just dedicated computing machines such as personal computers laptops and PDAs. Modern microprocessors appear in everything from automobiles to washing machines to children s toys.

A problem arises in that program code which is executable by one type of processor often cannot be executed in any other type of processor. Firstly each type of processor has its own unique Instruction Set Architecture ISA . Secondly processors often have unique hardware features which are not present on other types of processor. Hence the field of program code conversion has evolved to automatically convert program code written for one type of processor into code which is executable instead by another type of processor or to optimise an old inefficient piece of code into a newer faster version for the same type of processor. That is in both embedded and non embedded CPUs there are predominant ISAs for which large bodies of software already exist that could be accelerated for performance or translated to other processors that present better cost performance benefits. One also finds dominant CPU architectures that are locked in time to their ISA and cannot evolve in performance or market reach. This problem applies at all levels of the electronics industry from stand alone pocket sized devices right through to massive networks having tens or hundreds of powerful computers.

As background information in this field of program code conversion PCT publications WO2000 22521 entitled Program Code Conversion WO2004 095264 entitled Method and Apparatus for Performing Interpreter Optimizations during Program Code Conversion WO2004 097631 entitled Improved Architecture for Generating Intermediate Representations for Program Code Conversion WO2005 006106 entitled Method and Apparatus for Performing Adjustable Precision Exception Handling and WO2006 103395 entitled Method and Apparatus for Precise Handling of Exceptions During Program Code Conversion which are all incorporated herein by reference disclose methods and apparatus to facilitate program code conversion capabilities as may be employed in the example embodiments discussed herein.

Most modern processors include a set of registers as a type of fast access memory. The processor uses the registers to hold temporary values while executing a sequence of instructions in a computer program. The processor hardware contains a limited number of these registers and in use execution of the program can readily fill all of the available registers with temporary data values. This leads to competition for the available registers as the processor moves from one section of code to another because each section of code will generate temporary values and will need to make use of the registers in the processor to store those temporary data values.

In response to this difficulty processors have been developed with a register window architecture. For example register window architectures based on the Berkeley RISC design of the early 1990s provide a large set of hardware registers the register file and allow only a small subset of these registers the register window to be accessed by the current section of code. The other registers in the register file lying outside the current position of the register window are not accessible by the current section of the computer program. For example only eight registers are visible at any one time from a register file of sixty four registers in total. When the processor moves from one section of code to another such as when a procedure call is performed then the register window shifts position in the register file and exposes a different subset of the registers for the new section of code. These movements are generally classified as either causing a SAVE type movement where the register window moves to a previously unused position to present a clean set of hardware registers to the executing subject code or else a RESTORE type movement which shifts the register window back toward a previously exposed position and thus reveals a set of previously used registers to the executing code to thereby restore access to the data values held in those registers. Eventually however the finite number of hardware registers in the register file will be exhausted depending upon the number of procedure call levels invoked by executing the program. Here a SPILL operation is performed whereby the data values in the registers are moved to a safe location such as in second tier memory outside the processor. Later a FILL operation moves those data values back into the hardware registers so that processor can continue execution of the relevant section of code.

This register window architecture is intended to allow the computing system to execute faster especially where the processor frequently moves from one section of code to another and then returns back to the first section i.e. performs procedure calls by avoiding the costly and time consuming register spill and fill operations for large parts of the computer program.

This register window architecture has been adopted by processors such as the SPARC the AMD29000 and the Intel i960 on a large commercial scale. Hence a large body of code has already been written to execute only on these architectures and cannot be run by any other type of processor.

Of these commercial processors the SPARC is particularly prevalent. Further background information about the SPARC register window architecture is found for example in SPARC Architecture Manual Version 8 Section 4.1 Registers and SPARC Architecture Manual Version 9 Section 5.1 Registers published by SPARC International Inc of San Jose Calif. the disclosure of which is incorporated herein by reference.

As an example illustrates the use of register windows in a v9 SPARC architecture of the related art. The v9 SPARC architecture provides a plurality of control status registers and a large number of general purpose r registers. The general purpose registers include eight permanently visible global registers and a further eight global alternates and a moveable 24 register window divided into eight in registers eight local registers and eight out registers. The current window into the total register file is given by a Current Window Pointer CWP held in one of the control status registers. The CWP is incremented each time a restore instruction is executed and is decremented for a save instruction or when a trap occurs. In this example the 24 register window partially overlaps with adjacent windows positions such that the eight out registers of one window position overlap with the eight in registers of an adjacent window position whilst the local registers are unique to each window position. That is the out registers of window position CWP 1 are also addressable as the in registers of the current window CWP. Also the out registers of the current window CWP are equivalent to the in registers of the next window CWP 1. The v9 SPARC architecture supports from a minimum of three to a maximum of thirty two window positions depending on the specific hardware implementation. Hence together with the permanently visible global registers the v9 SPARC architecture requires 64 to 528 general purpose hardware registers 8 global registers 8 alternate globals and 16 registers for each window position .

In this example the original program code here called subject code relies on a particular type of subject hardware having a register window architecture. However in the field of program code conversion of the present invention the subject code is instead converted into target code and executed by a target computing system. That is it is desired to replace an older subject computer system based on the register window architecture instead with a newer target computer system but still have the target computer system support the register window architecture of the subject computing system.

An aim of the present invention is to provide a computing system which is adapted to support a register window architecture. Exemplary embodiments aim to adapt a computer system to support a foreign non native register window architecture.

According to the present invention there is provided a computing system a method of adapting a computer system and a computer readable storage medium as set forth in the appended claims. Other features of the invention will be apparent from the dependent claims and the description which follows.

In one exemplary aspect of the present invention there is provided a computing system comprising at least a decoder unit an encoder unit a memory and a target processor. The decoder unit is arranged to decode subject code executable by a subject processor of a register window based subject computing architecture where a current register window is positioned to reveal a selected subset of subject registers from a windowed register file The subject code includes window based instructions which affect the position of the register window in relation to the register file and register based instructions which contain references to the registers in the register window. The decoder unit is further arranged to identify the window based instructions in the subject code intended to cause movement of the register window and to derive register window movement information from the window based instructions. Further still decoder unit is arranged to identify the register based instructions in the subject code and to derive one or more windowed subject register references from the register based instructions. The memory comprises a stack data structure arranged to store a plurality of entries. The encoder unit is arranged to generate target code from the subject code decoded by the decoder unit. The target processor is arranged to execute the target code generated by the encoder unit. Execution of the target code on the target processor sets a stack pointer relevant to a head of the stack data structure adjusts the stack pointer with reference to the register window movement information derived by the decoder unit and accesses the entries in the stack data structure with reference to the stack pointer combined with a displacement determined from each of the windowed subject register references derived by the decoder unit.

In another exemplary aspect of the present invention there is provided a method of adapting a computing system to support a register window architecture. The method includes decoding subject code executable by a subject processor of a register window based subject computing architecture wherein a register window is positioned to reveal a selected subset of subject registers from a windowed register file including identifying a windowed subject register reference from an instruction in the subject code where said windowed subject register reference comprises a reference to one of said subject registers in the register window and deriving a register window movement information from an instruction in the subject code for causing a movement of the register window providing a stack data structure in a memory of the computing system where the stack data structure is arranged to store a plurality of entries and setting a stack pointer indicating a head of the stack data structure in the memory converting the subject code into target code and executing the target code on a target processor of the computing system adjusting the stack pointer with reference to the identified register window movement information and accessing at least one of the entries in the stack data structure with reference to the stack pointer in combination with a displacement determined from the windowed subject register reference.

In still another exemplary aspect of the present invention there is provided a computer readable storage medium having recorded thereon computer implementable instructions which when executed adapt a computing system to support a register window architecture wherein the computer readable storage medium comprises a code unit arranged to decode subject code executable by a subject processor of a register window based subject computing architecture wherein a current register window is positioned to reveal a selected subset of subject registers from a windowed register file including identifying a windowed subject register reference from an instruction in the subject code where said windowed subject register reference comprises a reference to one of said subject registers in the register window and deriving a register window movement information from an instruction in the subject code for causing a movement of the register window a code unit arranged to provide a stack data structure in a memory of the computing system arranged to store a plurality of entries and to set a stack pointer indicating a head of the stack data structure in the memory and a code unit arranged to convert the subject code into target code and to cause execution of the target code on a processor of the computing system to adjust the stack pointer with reference to the identified register window movement information and to access at least one of the entries in the stack data structure with reference to the adjusted stack pointer in combination with a displacement determined from the windowed subject register reference.

The exemplary embodiments of the present invention concern a mechanism which adapts a computing system to support a register window architecture which is particularly applicable when converting from subject code for a subject processor of a subject computing system into target code executed instead by a target processor on a target computing system. The mechanism provides a stack data structure the SR stack in the memory of the target computing system. The SR stack has a plurality of frames. Each frame on the SR stack stores a set of entries corresponding to the windowed subset of subject registers of the register window as addressed by the subject code. The SR stack is then accessed by the target code executing on the target computing architecture. The SR stack is able to store a large plurality of such frames and avoids expensive overhead such as modelling automatic spill and fill operations from the windowed register file of the subject architecture.

In one exemplary embodiment a computing system having only sixteen working registers is adapted to support a register window architecture representing a windowed register file reliant upon tens or even hundreds of hardware registers. Further the exemplary embodiments allow efficient operation of the target computing system particularly in terms of processing speed even when the system is adapted to support the register window architecture.

The following description is provided to enable a person skilled in the art to make and use the invention and sets forth the best modes contemplated by the inventors of carrying out their invention. Various modifications however will remain readily apparent to those skilled in the art since the general principles of the present invention have been defined herein specifically to provide an improved program code conversion method and apparatus.

Referring to a subject program is intended to execute on a subject computing platform having a subject processor . Here the subject computing platform can by any form of electronic device which relies upon computing operations in the subject processor to operate the device. However a target computing platform is instead used to execute the subject program through a translator unit which performs program code conversion. Here the translator unit converts the subject code into target code such that the target code is then capable of being executed by the target computing platform .

As will be familiar to those skilled in the art the subject processor has a set of subject registers . A subject memory holds inter alia the subject code and a subject operating system . Similarly the example target computing platform in comprises a target processor having a plurality of target registers and a memory to store a plurality of operational components including a target operating system the subject code the translator code and the translated target code . The target computing platform is typically a microprocessor based computer or other suitable computer.

In one embodiment the translator code is an emulator to translate subject code of a subject instruction set architecture ISA into translated target code of another ISA with or without optimisations often known as a this to that translator . In another embodiment the translator functions to translate subject code into target code each of the same ISA by performing program code optimisations known as a this to this translator or an accelerator .

The translator code is suitably a compiled version of source code implementing the translator and runs in conjunction with the operating system on the target processor . It will be appreciated that the structure illustrated in is exemplary only and that for example software methods and processes according to embodiments of the invention may be implemented in code residing within or beneath an operating system . The subject code translator code operating system and storage mechanisms of the memory may be any of a wide variety of types as known to those skilled in the art.

In the apparatus according to program code conversion is performed dynamically at run time to execute on the target architecture while the target code is running. That is the translator runs inline with the translated target code . Running the subject program through the translator involves two different types of code that execute in an interleaved manner the translator code and the target code . Hence the target code is generated by the translator code throughout run time based on the stored subject code of the program being translated.

In one embodiment the translator unit emulates relevant portions of the subject architecture such as the subject processor and particularly the subject registers whilst actually executing the subject program as target code on the target processor . In the preferred embodiment at least one global register store is provided also referred to as the subject register bank or abstract register bank . In a multiprocessor environment optionally more than one abstract register bank is provided according to the architecture of the subject processor under consideration. A representation of a subject state is provided by components of the translator and the target code . That is the translator stores the subject state in a variety of explicit programming language devices such as variables and or objects. The translated target code by comparison provides subject processor state implicitly in the target registers and in memory locations which are manipulated by the target instructions of the target code . For example a low level representation of the global register store is simply a region of allocated memory. In the source code of the translator however the global register store is a data array or an object which can be accessed and manipulated at a higher level. Execution of the target code performs the work expected of the subject code and also updates the emulated model of the subject processor such that the translator is able to determine an emulated execution context the subject state and in response correctly control the flow of execution to dynamically select translate and execute appropriate blocks of the subject program as target code.

The term basic block will be familiar to those skilled in the art. A basic block is a section of code with exactly one entry point and exactly one exit point which limits the block code to a single control path. For this reason basic blocks are a useful fundamental unit of control flow. Suitably the translator divides the subject code into a plurality of basic blocks where each basic block is a sequential set of instructions between a first instruction at a single entry point and a last instruction at a single exit point such as a jump call or branch instruction . The translator may select just one of these basic blocks block mode or select a group of the basic blocks group block mode . A group block suitably comprises two or more basic blocks which are to be treated together as a single unit. Further the translator may form iso blocks representing the same basic block of subject code but under different entry conditions.

In the preferred embodiments trees of Intermediate Representation IR are generated based on a subject instruction sequence as part of the process of generating the target code from the original subject program . IR trees are abstract representations of the expressions calculated and operations performed by the subject program. Later the target code is generated planted based on the IR trees. Collections of IR nodes are actually directed acyclic graphs DAGs but are referred to colloquially as trees .

As those skilled in the art may appreciate in one embodiment the translator is implemented using an object oriented programming language such as C . For example an IR node is implemented as a C object and references to other nodes are implemented as C references to the C objects corresponding to those other nodes. An IR tree is therefore implemented as a collection of IR node objects containing various references to each other.

Further in the embodiment under discussion IR generation uses a set of register definitions which correspond to specific features of the subject architecture upon which the subject program is intended to run. For example there is a unique register definition for each physical register on the subject architecture i.e. the subject registers of . As such register definitions in the translator may be implemented as a C object which contains a reference to an IR node object i.e. an IR tree . The aggregate of all IR trees referred to by the set of register definitions is referred to as the working IR forest forest because it contains multiple abstract register roots each of which refers to an IR tree . These IR trees and other processes suitably form part of the translator .

In the subject code is suitably an application program which is converted by the translator to run on the target system. As general examples the application program is a complex program such as a web server a digital content server e.g. a streaming audio or streaming video server a word processor a spreadsheet editor a graphics image editing tool or a database application amongst many others. However in other examples the subject code is any sort of program which enables the computing system to perform useful work and control operations of an electronic device. The target computing platform is often required to run many such programs simultaneously in addition to other tasks such as those associated with the operating system and the translator .

In the example embodiments the subject code takes the form of a binary executable which has been created e.g. compiled specific to the subject architecture . There is no opportunity for human intervention or review of the subject code . Instead the target computing platform through the translator automatically converts the subject code into the target code as a binary executed on the target computing platform . Thus in the exemplary embodiment the translator is a binary translator that converts the subject code as a binary executable of the subject ISA into the target code as a binary executable of the target ISA. Further translator is a dynamic binary translator that interleaves the translation with execution of blocks of the target code .

Although the general construction and operation of the subject processor will be familiar to the skilled person a brief review is provided here in order to illustrate and discuss those components of the subject processor that are emulated by the target system. In the example embodiments discussed herein the subject processor employs a register window arrangement according to the example v9 SPARC architecture which has been discussed above generally with reference to . In this case the register window positions are overlapped and have a rotating configuration. However it will be appreciated that embodiments of the invention may also be implemented for a register window architecture having other specific configurations such as non overlapping and or non rotating configurations. Some related art descriptions of this register window architecture refer to a plurality of register windows only one of which is the current window i.e. there are many windows each having a fixed position and only one of which is open at any one time . For consistency the following description considers a single current window which is moved to different register window positions but the skilled person will readily understand that the invention is equally applicable to architectures defined in terms of multiple fixed windows.

Although a large number of registers are provided in the subject hardware the subject code is only able to address thirty two visible general purpose registers at any one time namely the eight global subject registers g g and the twenty four register window into the windowed subject registers i i l l o o . Hence the subject code is written with reference to this visible set of thirty two register names.

Turning now to consider the target computing platform the subject code is provided such as by loading the subject code into an available area in the memory of the target system and block by block the subject code is converted and executed as target code . As discussed above when the translator first encounters a block of subject code the decoder unit decodes the subject instructions. This decoding process includes identifying references within the subject code instructions to the general purpose subject registers of the subject architecture including in particular references to the windowed subject registers and the global subject registers . Secondly subject code instructions are identified which cause SAVE and RESTORE type movements of the current register window to a new position. Here the instruction set architecture for the example v9 SPARC hardware includes at least save and restore instructions which on the subject platform would cause the current register window to move to another one of the positions . The register references and the register window movement information obtained by the decoder are passed to the core and are used in the encoder to generate the target code .

At an initialisation stage the translator provides various memory structures which later will be used to emulate the subject processor. In particular the translator provides the abstract register bank as discussed above namely a data structure used to store values which would have been held in the registers of the subject processor including the global subject registers and the windowed subject registers . Here a memory region is defined in the target memory having a set of eight static locations to form a static part of the abstract register bank relating to the eight global subject registers . Where references to the global subject registers are identified in the subject code instructions decoded by the decoder unit the equivalent target code instructions are generated with appropriate references to these static locations in the memory region . That is the data values representing the contents of these subject global registers are used by the target code most commonly by loading data from the static locations into the working registers of the target processor and then storing results back to these memory locations as appropriate during execution of the target code. In this way the target code emulates the behaviour of those instructions of the subject code which rely on the global subject registers .

The windowed subject registers behave in a dynamic windowed configuration as discussed above and hence a separate mechanism is now provided in the target platform to emulate these subject registers. As shown in to implement this register window mechanism the translator provides a stack data structure within the memory of the target platform which will referred to below as the SR stack . As will be familiar to persons skilled in the art a stack is a LIFO last in first out type of memory structure that is created and managed efficiently in most commonly available computing architectures. Typically a stack is located in memory at a given base address start address and grows downwards or upwards in memory as data is added to or removed from the stack. The current position of the top head of the stack is determined by reference to a stack pointer and the stack pointer is regularly updated to account for the memory locations which are consumed as data is pushed onto the stack and conversely which are released as data is popped from the stack. Commonly data on the stack is manipulable by addressing memory relative to the stack pointer. In the following examples the SR stack grows downwardly i.e. using progressively decreasing memory addresses from a given base address SR BASE in the target memory and a stack pointer SR SP is used to determine the current head of the SR stack.

The SR stack is used to store data values each representing the content of one of the windowed subject registers as referenced by the subject code . That is decoding the subject code reveals the windowed subject registers which are accessed by the subject code during execution and the data values used by the subject code are now instead stored as entries in the SR stack . The target code is generated to store these data values on the SR stack in the target memory load the data values into the working registers of the target processor as needed by the target code and store the results back to the SR stack as appropriate during execution of the target code. The SR stack thus forms part of the abstract register bank to emulate the windowed subject registers and enables the target code to emulate execution of the subject code instructions which rely on the windowed subject registers .

In the example embodiment as illustrated in the SR stack is divided into a plurality of frames where each frame contains a set of the data entries . In this example the addressable set of twenty four windowed subject registers are referred to as i i l l o o or equivalently as r to r by the subject code . Hence register definitions and register references in the subject code which are collectively referred to herein as register references are from the viewpoint of the subject code expressed in terms of this addressable set of register names. In the emulation mechanism discussed herein those data values required by the subject code to lie in the subject registers are instead stored in one frame of twenty four entries on the SR stack .

Secondly where in the subject processor the subject code would cause the current register window to move to a new position then in the present emulation mechanism a new frame of entries is provided on the SR stack . Due to the overlapping nature of the windowed subject registers this example embodiment provides sixteen new entries on the SR stack for each new frame whilst eight older entries corresponding to o o of the previous frame now give the data values for the i i register references of the current frame.

As shown in the decoder unit of the translator decodes the instructions in the first and second subject code blocks . Conveniently this first example embodiment divides the subject code into the first and second blocks according to the position of the save and restore subject instructions. In practical embodiments each block of subject code will typically contain around ten instructions but sometimes will contain up to around one hundred instructions.

The decoder identifies the subject code references to the windowed subject registers and derives the register window movement information . In this example pseudo code the first subject block includes two mov instructions and one add which contain the references to the windowed subject register l l and o i.e. local local and output . Concerning the register window movement information the save instruction here is identified as causing a SAVE type movement. Similarly the second code section is decoded to identify another reference to l local and a restore to induce a RESTORE type register window movement . The return in this example pseudo code returns to some other caller section of subject code not shown in the diagram.

The target code generated by the translator in this case is illustrated by the target code blocks and . Here the translator generates the target code instructions to address relevant entries on the SR stack based at least in part on the identified subject register references.

In this first embodiment the relevant SR stack entries are addressed by considering the identified windowed subject register references and with respect to the stack pointer SR SP. Conveniently the stack pointer SR SP is updated at the end of each target block in response to the identified register window movement information found at the end of each subject block. That is the target code is generated to update the SR stack pointer SR SP to track the current position of the head of the SR stack in response to the SAVE and RESTORE register window movement information obtained by the decoder .

Here the generated target code contains target instructions which cause the SR stack pointer SR SP to be updated to move forward down the SR stack by sixteen 64 bit entries for each identified SAVE type movement or roll back by sixteen entries for each identified RESTORE type movement. Here the stack pointer is updated by sixteen entries rather than a full frame of twenty four entries due to the overlapping of the entries representing i s inputs and o s outputs within each frame . As illustrated by the example in SR SP is set to a first value SR SP for the first target code block relevant to a first frame and is updated to a second value SR SP such that the second target code block refers instead to the entries in a second frame

As also shown in in this first embodiment the required SR stack entries are found in the current frame of twenty four entries located at the head of the SR stack as referenced by the current value of the stack pointer SR SP. Here each register reference determines a predetermined displacement relevant to the current value of the stack pointer SR SP. As a simplified example by taking the entry for o as having displacement of 0 i.e. the stack pointer SR SP refers to o as the first entry on the stack then the entries for o and o have displacements of 1 and 2 64 bit words respectively and so on up to the entry for i at 23 64 bit words. Here the target code calculates the address of the required entry on the stack by combining the current value of the stack pointer with the required displacement.

Conveniently one of the target registers is chosen to hold the stack pointer SR SP and is loaded with the current value of the stack pointer when passing context to the target code. On the example 64 bit x86 target architecture the stack pointer is conveniently loaded into one of the temporary registers such as rbp. That is as one option the stack pointer SR SP is loaded into the target register rbp in a run loop of the translator prior to calling the illustrated first section of target code . Alternatively rbp is conveniently loaded as part of the header code shown in . Thus the stack pointer SR SP is then available for use in the sections of target code from the register rbp. An example instruction to perform this operation is shown below where fs SR SP is a reference to a memory location which stores the stack pointer during context switches as part of the subject state held by the translator 

The following example shows the calculation of the displacement on the SR stack where in the subject code one of the subject global subject registers g is loaded into the local windowed subject register l local . Here the l entry is located at a displacement of 13 i.e. thirteen 64 bit words which is conveniently expressed as 13 8 104 8 bit bytes in some architectures having addressing in 8 bit bytes . In the target code we can assume that the value for g has already been loaded from the memory region into an available target register rax 

In response to the identified SAVE movement the current stack pointer value SR SP now held in rbx is advanced by sixteen 64 bit entries on the SR stack . This will either add sixteen new entries to the SR stack or will move the current frame forward to a previously occupied position and thus now reveal the data values stored in these memory locations. Secondly it is useful at this point to also update the version of SR SP held in memory at fs SR SP although this can be done separately.

The stack pointer SR SP is advanced downwardly in memory in this example by sixteen 64 bit words in response to each SAVE type movement information such as with the target instructions 

Conversely the stack pointer SR SP is retarded upwardly in memory in response to each RESTORE type movement information to then allow the specified displacements to refer to a previously encountered frame of entries on the SR stack such as with the target instructions 

As shown in the first target code block begins with header code which in this example includes instructions not shown that load the stack pointer SR SP into the temporary target register rbp. At this point we can assume that rbp holds the value SP SR and so refers to frame of . Next the target registers rax and rbx are loaded with the constants 10 and 3 and then these values are also stored into the referenced entries on the SR stack with respect to the displacements derived from the register references . Thus the relevant entries on the SR stack now hold the data values expected by the subject code in the referenced registers l and l . These target registers rax and rbx are then used perform work equivalent to the example add subject instruction and the result stored to the entry relevant to the o reference. The save subject instruction in this embodiment terminates the first subject block . Also in response to the register window movement information derived from this save the target code is generated to amend the stack pointer SR SP held in rbp to advance by sixteen entries on the SR stack so that SR SP now has the value SR SP and refers to frame in . The footer code in this first target block now determines a next action such as passing control back to the translator to select a next block of subject code to execute as translated target code or to pass control directly to a next block of already generated target code. In this example the footer code passes execution control directly to the second target code block without returning to the translator .

The header code in the second target code block suitably prepares context for this block. In most cases this includes including loading SP SP into rbp from the memory at fs SR SP although in this example a target code optimisation would allow the value already in rbp simply to be carried forward from block . Then the target code performs the work of the subject add instruction from subject block . Note that due to the updated value of SR SP in rbp the register reference to l local does not resolve to the same entry in the SR stack as in the first subject code block . That is in subject block the reference to l resolved to an entry in frame whereas the reference to l in subject block now instead resolves to an entry in frame . In this way the SR stack emulates the expected behaviour of the register window in the subject processor. Finally in response to the register window movement information from the final restore in subject block the target code has been generated to update the value of SR SP in rbp to retard the stack pointer by sixteen entries whereby the stack pointer is now again referring to frame of . Also the subject restore instruction acts to select the termination point of this second subject block . In most cases the restore causes the translator to terminate the subject block . However in this example the subject block is actually terminated at the return immediately following the restore . At this point it is appropriate to save the updated stack pointer SR SP back from rbp to fs SR SP and the footer code now determines a next action such as in this case returning execution control to the translator which may in turn then return control to the subject code not shown that called the first subject block as func to continue execution of the subject program.

The decoder unit of the translator identifies the windowed subject register references and the register window movement information as discussed above. Further the identified register window movements are used to derive a frame offset which is expressed in the target code as a frame offset from the SR SP stack pointer. Then each of the register references provide the displacement from this frame offset to address a relevant entry in the SR stack . Hence the stack pointer SR SP may now remain constant throughout the target code block even though two or more frames of entries are under consideration during the block. The second embodiment shown in in particular allows the translator to inline leaf functions within a single block of target code where a leaf function is a function which does not itself call another function. The function is inlined by treating both the caller and the callee subject code instructions as a single block subject code and creating therefrom a corresponding single block of target code . In this simplified example of there is no leaf function but the operations discussed below are equally applicable for this purpose.

In a further example embodiment where the decoder detects that a section of subject code contains more than a predetermined number of SAVEs or RESTOREs then decoding of the block is stopped broken at that point and a new block created with the frame offset returning to the default value f . That is where a section of subject code contains greater than the permitted number of SAVE or RESTOREs this section of subject code is subdivided into two or more smaller sections by creating additional subject code blocks. This limitation is convenient to allow a break in an otherwise relatively lengthy block.

As shown in the identified register window movements adjust a frame offset up or down in SAVE and RESTORE directions from an assumed starting position. Conveniently the frame offset is set to 0 at the start of each decoded block and is adjusted by one count to 1 2 etc. for each consecutive SAVE movement. Conversely the frame offset is increased by one count for each identified RESTORE type movement. Thus the frame offset provides a current cumulative offset from the default starting position based on the identified register window movement information encountered during that block. For example from the default of 0 a SAVE adjusts the frame offset to 1 . A second SAVE then adjusts the offset to 2 . However a RESTORE now adjusts the offset back to 1 a second RESTORE adjusts the offset back to 0 and a further RESTORE adjusts the offset now to 1 and so on. The table in shows the identified register references and the identified register window movements . Also the table shows the displacements and the frame offsets derived therefrom. Further the table shows example target code which combines together the frame offset and the displacements to address individual entries lying in various different frames on the SR stack . That is the current offset and the displacements are used by the core and the encoder unit when generating and planting the target code. The encoder is thus able to plant target code which simplifies addressing in the SR stack by allowing base plus offset type addressing.

As shown in the target code block begins with header code which as in the previous example suitably loads the stack pointer SR SP into a target register rbp. In this example it is assumed that the value in rbp refers to frame of . Next the target code performs work equivalent to the example mov and add subject instructions as discussed above. In response to the register window movement information derived from the save the frame offset is decreased by one count and the target code is generated to temporarily amend the stack pointer SR SP held in rbp to advance by sixteen entries on the SR stack so that SR SP now refers to the subsequent frame in . Note that the save subject instruction here does not terminate the subject block. That is the overhead of header and footer code is not required. The target code in now immediately performs the work of the second subject add instruction using rax. In response to the register window movement information derived from the restore the target code has been generated to update the value of SR SP in rbp according to the new offset to retard the stack pointer by sixteen entries whereby the stack pointer is now again referring to frame of . Also the final subject restore instruction acts to select the termination point of this subject block . The footer thus now saves the updated stack pointer SR SP back from rbp to fs SR SP. As for above the return at the end of the subject block may return execution control to the translator which may in turn then return to the subject code not shown that called the subject block as func .

The addressing mechanism discussed above in allows the translator to provide a single block of target code which includes target instructions that emulate the effects of multiple save and or restore instructions of the subject code within a single block of target code. It will be appreciated that this mechanism also allows the translator to inline subject functions and particularly leaf functions into the target code. That is the subject call and return instructions that are used to perform a procedure call involve the same SAVE and RESTORE type movements of the register window and can now be achieved without requiring a function call in the target code.

At step the target code is generated with reference to the SR stack and the stack pointer SR SP. That is each block of target code is generated with target code instructions which store and retrieve data values as entries on the SR stack . Here at step the target code derived from the identified register window movement information adjusts the stack pointer SR SP either by immediately updating the stack pointer SR SP to refer to the new head of the stack or by adjusting the temporary frame offset . At step the target code derived from the identified register references accesses the desired entries within the frames of the SR stack using the associated displacements from the adjusted stack pointer SR SP.

Advantageously the SR stack mechanism is not limited as to the number of frames which it can store simultaneously. Referring again to it will be noted that this example hardware implementation of the subject processor provides only eight register window position and by definition the SPARC hardware is only able to provide a maximum of 32 register window position. Once each of the register window positions contains valid data any additional SAVE forces a spill operation to empty the windowed register file to free new temporary working space. By contrast the present emulated register window mechanism avoids the considerable overhead associated with detecting and performing the automatic spill and fill operations of the subject architecture. That is the present register window mechanism is not bounded by such finite hardware limitations and the SR stack instead expands as required to contain the necessary additional entries for each SAVE. If the subject computing architecture comprises a maximum finite number n register window positions and then the SR stack may have as execution progress a plurality m frames where m and n are both positive integers and m is greater n. The SR stack is relatively large and is not of a predetermined finite size. In most target computing platforms the memory is sufficiently large that the SR stack appears to the translator as an infinite resource. Ultimately the SR stack is limited in size but in practice the theoretical maximum size of the stack far exceeds the needed size for any realistic implementation e.g. 1 Kb per sixteen 64 bit entries such that the SR stack may be treated as an infinite resource i.e. many hundreds of frames are easily stored by the SR stack .

The subject stack is of particular interest since in the subject architecture register spill operations transfer register values from the windowed hardware subject registers onto the subject stack as provided in the memory of the subject system. Conversely fill operations in the subject architecture transfer register values from the subject stack to the windowed hardware subject registers . In the example V9 SPARC architecture each SAVE type register movement causes space to be reserved on the execution stack which when a spill operation is performed will be filled with register values from registers in a respective register window position . That is as illustrated in the subject code now translated into target code may reasonably assume that required data values will in certain circumstances appear in the allocated space in the emulated version of the subject stack . However unless such data values are in fact copied from the SR stack to the emulated subject stack the data values will not appear as expected.

There are certain subject code instructions which specifically affect the transfer of data from the subject registers to the subject stack. In the v9 SPARC example discussed herein a flushw instruction flushes all of the registers from the windowed hardware subject registers into the subject execution stack except the current window position by performing repetitive spill traps. The flushw instruction is implemented by causing a spill trap if any register window position other than the current register window position has valid contents. On the subject architecture the number of window positions with valid contents is computed with reference to the CANSAVE control status register.

Also the programming language C may include native code libraries which are compiled specific to a particular subject computing platform. The C programming language includes instructions such as setjmp and longjmp which although now widely considered to be archaic and notoriously difficult to implement can appear in many real world subject programs especially legacy programs. The setjmp and longjmp instructions are typically used in the C programming language for non local exits or for software exception handling. The setjmp function identifies return points by saving information about the execution environment at the point where the call to the setjmp function appears in the subject code. Execution of the subject program continues normally after the call to setjmp until at some later point calling longjmp causes an exit to this return point such that execution control is transferred back to the point where setjmp was called. The setjmp routine typically includes copying register values from the subject registers to the subject stack and the longjmp function typically restores those values from the stack to the subject registers.

As another example the programming language C may include processor family specific implementations in assembly of functions to create save and restore a context for use in signal handling or for user multi threading. Some C libraries provide such routines under the names getcontext setcontext and makecontext . The context functions are provided as if part of a native C library but with specific implementations for specific hardware such as ARM PowerPC SPARC and x86.

As a further example the higher level programming language C provides instructions specifically to handle software exceptions. Although these C exception handling instructions are primarily intended for handling exceptional situations encountered during execution of a subject program they are also a convenient programming construct in themselves and are often used to simplify a program s algorithm in contrast to more typical if type instructions. Specifically C exception instructions include try catch and throw instructions. Implementing these instructions in binary subject code executable by the subject processor thus involves the transfer of data between the subject registers and the subject stack.

There are many other situations which require such transfer of data including for example stack unwinding whereby the subject program walks back up the execution stack and hence requires valid subject register values to be present on the execution stack.

At step the subject code is decoded to inter alia identify SAVE and RESTORE type register window movements as discussed above. At step a CR counter is updated for each identified register window movement . Suitably each SAVE adds 1 to the CR counter and each RESTORE decrements 1 from the CR counter. Thus as the subject program progresses the CR counter counts the number of frames of entries on the SR stack . Also at step subject instructions are identified which in the subject architecture require data values held in the windowed subject registers to be saved to the subject execution stack which here are termed SPILL type instructions. As a particular example for the SPARC subject architecture the flushw subject instruction is identified. At step and as shown in target code is provided to flush a determined number of frames of entries from the SR stack to the corresponding space allocated on the emulated subject stack . In this illustrated example of the SR stack contained entries for nine frames labelled F to F. Here the CR counter shows that eight earlier frames F to F i.e. not including the current frame of entries F need to be copied from the SR stack to the subject stack CR 8 . At step following this repetitive spill operation the CR counter is updated reset to zero to show that all of the required frames have been copied from the SR stack to the subject stack .

As noted above in the subject architecture the flushw instruction invalidates all register window positions except the current position and thus the subject execution stack now holds the canonical version of the subject register values for all previous register window positions. Some subject programs such as the C context functions setjmp longjump functions and C exceptions will alter the data values stored in the subject stack. Hence in this emulated environment illustrated in it is important to refer to the values now held in the emulated subject execution stack rather than the now potentially invalid data in the entries on the SR stack . Accordingly at step the target code is now generated to access the desired data values on the emulated subject stack where appropriate.

Step comprises identifying subject code instructions which in the subject architecture cause register values to be loaded into the windowed register file from the subject execution stack which here are termed here FILL type instructions. In the example SPARC subject architecture this is suitably a restore instruction. In the emulated mechanism provided herein the CR counter is tested at step . If the CR counter is non zero CR 0 to indicate that one or more valid frames exist in the SR stack then at step the CR is updated in this case decremented CR CR 1 in response to the RESTORE instruction and no data is copied from the subject stack . The subject restore here causes an adjustment of the stack pointer SR SP to select a different frame on the SR stack as discussed above. However where the CR counter is zero CR 0 to indicate that no valid earlier frames exist on the SR stack then at step a fill operation is performed to copy a frame of data values from the subject stack back to the SR stack for use as the new current frame following the RESTORE. The frame of data values from the subject stack may have been modified by the subject program and hence the canonical versions of these data values are now again available in the entries of the SR stack for subsequent use in the subject program. In particular the SPARC architecture by convention stores the stack pointer for the subject stack in subject register o also known by the alias sp . Due to the overlap of the register window positions the stack pointer for a caller procedure is also available in the subject register i. This previous stack pointer is termed the frame pointer and can be accessed using the alias fp . Modifications to the stored register values typically involve changing the register values for the frame pointer i fp and or the stack pointer o sp . Thus it is important that these data values are accurately maintained by the emulation mechanism discussed herein.

Other specific embodiments of this transfer mechanism are also contemplated. In particular following the spill operation flushw any suitable point on the SR stack may then be used as the new current frame since flushw invalidates all register windows except the current window. For example the SR stack can be cleared and the stack space reclaimed completely after each flushw or a default position on the SR stack may be set as the new current frame such as half way along an allocated space for the stack.

At least some embodiments of the invention may be constructed solely using dedicated hardware and terms such as module or unit used herein may include but are not limited to a hardware device such as a Field Programmable Gate Array FPGA or Application Specific Integrated Circuit ASIC which performs certain tasks. Alternatively elements of the invention may be configured to reside on an addressable storage medium and be configured to execute on one or more processors. Thus functional elements of the invention may in some embodiments include by way of example components such as software components object oriented software components class components and task components processes functions attributes procedures subroutines segments of program code drivers firmware microcode circuitry data databases data structures tables arrays and variables. Further although the preferred embodiments have been described with reference to the components modules and units discussed herein such functional elements may be combined into fewer elements or separated into additional elements.

Although a few example embodiments have been shown and described it will be appreciated by those skilled in the art that various changes and modifications might be made without departing from the scope of the invention as defined in the appended claims.

Attention is directed to all papers and documents which are filed concurrently with or previous to this specification in connection with this application and which are open to public inspection with this specification and the contents of all such papers and documents are incorporated herein by reference.

All of the features disclosed in this specification including any accompanying claims abstract and drawings and or all of the steps of any method or process so disclosed may be combined in any combination except combinations where at least some of such features and or steps are mutually exclusive.

Each feature disclosed in this specification including any accompanying claims abstract and drawings may be replaced by alternative features serving the same equivalent or similar purpose unless expressly stated otherwise. Thus unless expressly stated otherwise each feature disclosed is one example only of a generic series of equivalent or similar features.

The invention is not restricted to the details of the foregoing embodiment s . The invention extends to any novel one or any novel combination of the features disclosed in this specification including any accompanying claims abstract and drawings or to any novel one or any novel combination of the steps of any method or process so disclosed.

