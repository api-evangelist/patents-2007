---

title: Method and system for customizing profiling sessions
abstract: A system and method are provided to customize profiling sessions. In one embodiment, a profiling session at a first virtual machine is initiated, the profiling session including tracking a profiling event occurring at threads, each thread having associated semantical information corresponding to a plurality of profiling entities. A request from a second virtual machine is received specifying extracting profiling information when a profiling entity executes a thread where the profiling event occurs. The profiling information relating to the profiling entity is extracted as requested by the second virtual machine. The profiling information is communicated to the second virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667471&OS=08667471&RS=08667471
owner: SAP AG
number: 08667471
owner_city: Walldorf
owner_country: DE
publication_date: 20070330
---
Embodiments of the invention relate generally to the field of data processing systems. More particularly the embodiments of the invention relate to customizing profiling sessions.

A memory on any computing system is a limited resource. No matter how fast computing systems become they always depend upon a finite amount of memory in which to run their software applications. As a result software developers should consider this resource when writing and developing software applications.

The JAVA programming language differs from many traditional programming languages e.g. C C by the way in which memory is allocated and deallocated. In languages like C and C memory is explicitly allocated and deallocated by the application programmer developer. This can greatly increase the time spent by programmers in tracking down coding defects in regards to deallocating memory. The JAVA programming language presents several features that appeal to developers of large scale distributed systems such as write once run anywhere portability portable support for multithreaded programming support for distributed programming including remote method invocation garbage collection and an appealing object model have encouraged JAVA use for systems with a size and complexity far beyond small applets. However the developers of these applications often encounter problems such as memory leaks performance and scalability problems synchronization problems and programming errors.

JAVA runtime environments e.g. JAVA virtual machine provide a built in mechanism for allocating and deallocating memory. In JAVA memory is allocated to objects. The JAVA virtual machine VM or JVM automatically handles the amount and allocation of memory upon an object s creation. The JAVA runtime environment employs a garbage collector GC to reclaim the memory allocated to an object that is no longer needed. Once the GC determines that the object is no longer accessible e.g. when there is no longer any references to it stored in any variables the fields of objects or the elements of any arrays etc. it reclaims the allocated memory. When objects in a JAVA application are no longer referenced the heap space the object occupied is to be recycled so that the space becomes available for subsequently created objects.

Although having garbage collection improves productivity it is not entirely immune from a class of bugs called memory leaks. A memory leak can occur when a program or in the case of JAVA the VM allocates memory to an object but never or only partially deallocates the memory when the object is no longer needed. As a result a continually increasing block of memory may be allocated to the object eventually resulting in an Out Of Memory Error OOME . In other words a memory leak occurs when memory is allocated but it is never or only partially reclaimed. Memory leaks can also occur when a data structure e.g. hashtable is used to associated one object with another and even when neither object is required any longer the association with the data structure remains preventing the objects from being reclaims until the data structure is reclaimed. Stated differently when a lifetime of the data structure is longer than that of the objects associated with it memory leaks are caused.

Memory leaks are of particular concern on JAVA based systems e.g. JAVA 2 Platform Enterprise Edition J2EE platforms which are to run twenty four hours a day seven days a week. In this case memory leaks even seemingly insignificant ones can become a major problem. Even the smallest memory leak in code that runs 24 7 may eventually cause an OOME which can bring down the VM and its applications or even all VMs running on a particular application server instance. This can cause critical performance problems.

It is generally preferred to profile memory use and debug memory leaks in an application code in the early stages of development to provide an early detection of memory problems long before the production stage. Although garbage collection makes code much safer because having the developer to explicitly delete objects from memory is prone to human error garbage collection is not a panacea. For example if the developer does not manage the references to the JAVA carefully it can result in a memory leak problem such as a reference to an object is stored within an instance or class field this reference may exist throughout the life of the application and unless desired is regarded a memory leak.

Within a distributed application server environment having thousand of concurrent users performance and scalability problems are typical. The causes of problems are various such as synchronization problems extensive access to shared resources e.g. database systems bad configuration settings etc. To provide consistency within such a system locks with various validity scopes e.g. VM local application server wide and system wide are used however deadlock situations and synchronization problems exist.

Several performance monitoring profiling and debugging tools are used to examine software applications to determine resource consumption within the JAVA runtime environment JRE . For example a profiling tool may identify the most frequently executed methods and objects created in an application. However such tools are very limited in detecting and exposing system inefficiencies and problems e.g. memory leaks while consuming great amounts of system resources by requiring overhead tasks such as starting and restarting of VMs in special modes. Further such tools are also limited in providing necessary information about system problems and the limited information that these tools may provide is not useful for applications comprising several thousand objects. This leaves developers with often insurmountable amounts of code to manually evaluate to track down the problem objects variables such as the specific class method calls etc. For example conventional profiling tools like Optimizelt and JProbe when used require restarting of VMs and servers which results in loss of production and system resources particularly when restarting a productive system. Moreover the starting of a server and its VMs further adds to the system overhead by increasing memory consumption which also harms the normal work of the server and server software. The restarting of the server adds overhead in regards to the Central Processing Unit CPU as the server would have to start up from scratch.

Regarding profiling allocations all conventional commercial and non commercial profiling techniques affect all users and applications running in a particular JAVA VM if for example when a specific CPU intensive profiling trace is started the complete VM slows down and all users running in that VM get a negative impact on response times. This is particularly unacceptable when dealing with a large scale mission critical applications server environment. Moreover no additional knowledge or information is provided about any of the users or sessions or software components that are associated with the actual allocation that has taken place and thus all of the users and applications running in a VM are negatively impacted.

A system and method are provided to customize profiling sessions. In one embodiment a profiling session at a first virtual machine is initiated the profiling session including tracking a profiling event occurring at threads each thread having associated semantical information corresponding to a plurality of profiling entities. A request from a second virtual machine is received specifying extracting profiling information when a profiling entity executes a thread where the profiling event occurs. The profiling information relating to the profiling entity is extracted as requested by the second virtual machine. The profiling information is communicated to the second virtual machine.

The above attributes may be implemented using a computer program a method a system or apparatus or any combination of computer programs methods or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.

As used herein references to one or more embodiments are understood as describing a particular feature structure or characteristic included in at least one implementation of the invention. Thus phrases such as in one embodiment or in an alternate embodiment appearing herein describe various embodiments and implementations of the invention and do not necessarily all refer to the same embodiment. However they are also not necessarily mutually exclusive. Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein.

JAVA applications can vary in both size and complexity. In addition certain large JAVA application e.g. 10 000 classes and 1 000 000 methods with 100 000 000 method calls may run 24 7 long living applications . Within a long living application major problems e.g. memory leaks are expected to occur in terms of both stability and performance. For example a single long living object that increases in size by 1 byte between each GC cycle will eventually cause the application and VM to crash due to an OOME. Although such a crash may take a long time e.g. 1 bytes per GC cycle millions of free bytes of memory it will inevitably occur. Furthermore when dealing with such long applications and productive systems mere use of commercial and non commercial conventional profiling tools and debugging tools having JVMPI and JVMTI profiling interfaces and JVMDI debugging interface respectively are not suitable and cannot provide the necessary profiling debugging and monitoring information. Even when dealing with suitable systems such conventional tools cause high memory footprints and are not effective without having to restart the VM and are known to disturb user sessions inherent to the VM.

In one embodiment a vendor specific proprietary interface and implementation are provided as described throughout this document e.g. see . This implementation can be made an integral part of a VM e.g. JVM SAP JVM and allow for on demand examining of system problems including in productive systems without restarting the underlying VM. These system problems can range anywhere from memory leaks to performance scalability and synchronization problems. In one embodiment on demand refers to examining e.g. profiling tracing debugging and or monitoring system problems in runtime such as without the need for restarting the underlying VM.

In one embodiment profiling is performed using profiling infrastructure that resides at backend VM that is being profiled. Profiling infrastructure includes a number of components as described in to perform trace profiling. In one embodiment using profiling infrastructure no default profiling agent or default implementations and instances e.g. JVMPI JVMTI are needed or employed. Without having the default agent employed a direct communication is established between backend VM and frontend VM via server JAVA API and client JAVA API and profiling protocol . Any number of VMs may be used as backend or frontend VMs. Furthermore when performing profiling trace in an offline profiling mode an external profiling file is used to store profiling trace data. Starting and stopping of profiling trace may be performed in a number of ways such as using a Graphical User Interface GUI based monitoring tool . The profiling data is written using various components of profiling infrastructure and displayed to the user using any number of display devices. These display devices may include GUI based display devices. In one embodiment using profiling infrastructure on demand profiling is performed which refers to performing the profiling without restarting the underlying VM . Stated differently the profiling is performed in runtime without any interruptions or restarting of the underlying VM .

It is to be noted that the VMs may not be VMs and instead be any program or application e.g. a native application or program that is compatible with the components of and related to the profiling infrastructure . For example the frontend VM is illustrated here merely as an example for brevity and clarity. It is however contemplated that a frontend VM or any VM for that matter is not necessary for embodiments of the present invention. For example in one embodiment instead of employing a VM any program or application that is compatible with the mechanisms and components described herein is acceptable and functional and can be employed and implemented. Stated differently for example any program that can read and speak the described components e.g. components of profiling infrastructure protocols e.g. socket communication protocol APIs e.g. server and client side APIs parameters profiling files etc. is compatible and can be used instead of a VM such as the frontend VM . This is applicable throughout this document wherever there is mention of a VM .

Profiling infrastructure can be used for starting profiling traces for certain users or applications such as using profiling annotations. Profiling annotations refer to a concept of tagging threads with certain semantic information from an application server environment. Here JAVA API is provided which allows for annotating a JAVA thread with one or more of the following information user name application name request identifier and session identifier. If profiling traces are started a thread filter for such information is provided and thus a profiling trace can be started only a certain user or application. A JAVA API is also provided on the client side such as client JAVA API that communication with server JAVA API via a profiling protocol . Client includes frontend VM which includes any arbitrary VM that represents a native application that speaks e.g. in case of online profiling the profiling protocol and or knows e.g. in case of offline profiling the profiling file format of profiling file . Backend VM is the one that is being profiled.

The illustrated mechanism provides both an online mechanism for interactive profiling and an offline mechanism for non interactive profiling. When starting profiling the backend VM any profiling parameters including the desired mode e.g. an online or offline mode are specified. If started in the online mode the profiling backend VM opens a port and waits for a connection. The profiling frontend VM attach to this connection via the profiling protocol and JAVA APIs . The starting running and stopping of profiling and tracing is then performed. In one embodiment online profiling is performed via internal components such as JAVA APIs or external components such as a monitoring tool e.g. JAVA VM monitor . Online profiling may also be performed using a command line such as java agentlib jdwp transport dt socket address 8000 suspend n or bin java monjdwp transport dt socket address 8000 server y. For the offline mode profiling files are used to store profiling data and a special interface is provided to couple the backend VM with the frontend VM via client JAVA API to allow for starting and stopping of traces. In some cases server JAVA API can also be used to perform offline profiling. Offline profiling may also be performed using monitoring tool and or using a command line such as java XX Profiling XX ProfilingAlloationTrace.

When the profiling mechanism is started in the offline or non interactive mode the profiling information is stored in an external medium e.g. file system and can be analyzed after the profiling run. This way the profiling information may then be used for port mortem analysis however traces can still be started and stopped in an interactive manner. In contrast the online or interactive mode allows for analyzing the profiling information online. For example if a class statistic trace has been enabled and a garbage collection happens the profiling information can be directly accessible through a stream based interface.

Furthermore to have no performance degradation in case of running in a non profiling mode e.g. when no profiling is being performed VM may maintain a global flag indicating whether profiling is enabled or not. The flag may be requested each time any profiling data is written. For example a profiling trace for garbage collection events may be implemented in the following way when a garbage collection is performed the global profiling flag is checked. If profiling is enabled the flag is checked to indicate whether garbage collection events are to be profiled. This can also be done via some VM global flags. If the garbage collection trace is enabled the backend VM may be called to collect the desired data.

In one embodiment profiling controller framework is used for starting and stopping profiling runs and traces. Controller framework allows the user to specify profiling options or settings that the user would want to enable. These profiling settings to be applied are divided into distinct areas such as functional profiling settings and filter settings. The functional profiling settings determine the area to be profiled e.g. allocation trace reference trace etc. while the filter settings define the validity scope e.g. user session thread VM etc. of the functional profiling settings. For example an allocation trace can be started for a specified user. JAVA API and graphical user interface GUI are provided in communication with profiling controller framework . GUI is used to enable the user to directly specify the desired profiling settings without any system guidance. Additionally a wizard similar interface is provided. GUI also allows for an expert mode and for a wizard guided mode. Controller framework may include a profiling evaluation module for analyzing a performed profiling run. For example the JAVA API can be used for getting the complete low level profiling information gathered within a corresponding profiling run as well as for getting condensed problem oriented profiling information. The condensed profiling information may be used to directly pinpoint various problematic areas. For example if the user has performed performance analysis using a time based sampling approach the JAVA API may enable a client to directly receive information about the time consuming methods. The user may view this information via GUI at a display device at the client.

Controller framework is used for starting and stopping profiling runs and traces which includes starting and stopping various profiling options further described later . For each profiling run the user is free to determine the set of traces to be started. For example the user may start an allocation trace using the allocation trace module together with a class statistic trace. A user defined name may be assigned to each non interactive profiling run and used later on to evaluate the gathered profiling information. Considering interactive profiling runs the user is able to evaluate the profiling information online and therefore the profiling information may be available through a stream based interface.

Furthermore controller framework may be independent of the surrounding application server environment. Stated differently controller framework refers to the underlying VM currently executing a profiling request e.g. starting an allocation trace . The corresponding application server infrastructure may be responsible for starting and stopping the desired trace on other VMs. For example if an allocation trace is started for a certain user session at VM the application server infrastructure accounts for starting the allocation trace in the VMs executing requests for the user session. Controller framework enables the application server infrastructure to specify thread filters . A thread filter may contain the following information client user session identifier request identifier application name and component name. On the one hand controller framework may provide a facility to tag these pieces of information to a thread. On the other hand if a certain profiling run is to be started a thread filter is provided. Hence for example a trace may be stared only for a certain user. Accordingly the application server is responsible for setting the current thread state e.g. client user session identifier etc. . In one embodiment an application server includes a J2EE server.

In one embodiment the profiling options include functions cases such as memory debugging e.g. memory leak detection performance analysis synchronization monitoring and application debugging e.g. detecting called methods . These profiling functions further include a number of sub functions such as heap dump coupling of debugging and profiling infrastructure time based sampling memory based sampling method statistic allocation trace silent allocation trace allocation statistic trace loitering trace garbage collection trace garbage collection statistic class statistic trace permanent generation statistic trace local garbage collection trace shared garbage collection statistic other traces such as reference trace object death trace object movement trace shared closure trace global reference trace method trace time method trace input output I O trace monitor trace shared lock trace method count trace execution line trace scheduler trace and exception trace.

Solving a memory leak problem may include a couple of processes such as identifying the JAVA classes or objects caused the memory leak and determining where in the infrastructure or application code the leak occurred. Many of the sub functions can be used to solve memory leak problems. Class statistic trace functionality is provided to help identify the JAVA classes that cause memory leaks. Class statistic trace includes getting an overview of all living classes within particular VM including class name class loader description the number of object instances and the accumulated net and gross size of all object instances. The information may be traced after each full local garbage collection. Reference trace includes detecting the objects holding references to leaking objects. It also provides the complete reference chain to a specific object instance. This information may also be available after one full local garbage collection.

If the class statistic trace reveals that specific objects are created over and over again using the allocation trace module the allocation trace may be enabled to check for the exact allocation place. Using the allocation trace module the allocation trace enables the user to specify a class filter . Silent allocation trace is a derivate of allocation trace. When an allocation trace is started each object which is allocated and adheres to a user defined class filter is assigned to an object identifier. Although the allocation trace enables the user to get informed about object allocations the user may not get the information when the corresponding object dies. In that case object death trace allows the user to check for those objects are garbage collected and no longer alive. Object movement trace makes allows the checking of why certain objects are kept alive while the allocation trace allows for getting information when certain objects are created.

Shared closure trace provides for getting object information each time shared closures are created deleted copied or mapped. Global references may be used across multiple invocations of a JAVA Native Interface JNI method and also across multiple threads. A global reference remains valid until it is freed by the programmer and ensures that the referenced object is not garbage collected. For relatively complex scenarios a dump of the current JAVA heap is performed. The heap dump functional lows for getting a dump of the current overall object state.

In some cases memory leaks occur due to the fact that a failed clean up operation. For example considering a cache based on shared closures at regular intervals the cache might be cleared. If the clean up operation were interrupted at the end of the operation e.g. due to a VM abort exception most cache entries would probably be deleted however some entries might still exist. Thus a memory leak may be resulted if the cache were not able to remove any of the existing entries. The detection of this kind of memory leak could be difficult since most object instances of the corresponding class are removed and merely a few exist. Thus class statistic trace may not be the right choice to detect such a memory leak. One characteristic of this problem is that the memory leak is caused by objects which may not be used any longer. The loitering trace performed via loitering trace module facilitates the detection of objects which are not used for a long time.

Various performance problems may be caused by any number of reasons such as choosing the wrong algorithm for a problem repeatedly recalculating the same result excessive allocating of temporary objects too many I O operations or transferring too much memory etc. Profiling helps improving the performance by determining what is it that is to be optimized. Profiling identifies parts of the overall system for which optimization can have an impact on the overall performance. Optimizing a function which only amounts to a miniscule fraction of the overall runtime may not have noticeable benefits. Profiling also determines how the optimization is to be done. Checking for optimization options of those parts that are identified during the first process. Time based sampling is used to get an overview of methods which consume the most CPU resources of the application. Time based sampling works by dumping a stack trace of the currently active thread at regular intervals. Memory based sampling works analogously to the time base sampling however instead of dumping a stack trace in time intervals At stack trace is sampled after an amount of memory M is allocated on the JAVA heap. This way those methods that allocate the largest number of bytes on the JAVA heap are identified.

When time based sampling shows that a method uses a large amount of time the reason for this resource consumption might be that a call of the method is expensive or the method is called very often. To find out how many times a particular method was called method statistic trace may be used. Together with time based sampling method statistic trace may also allow for calculating the average runtime of a specific method e.g. the cumulative time divided by the method count . Method trace is used to get more detailed information than method statistic. Time method trace can be used to provide very detailed trace information. Time method trace provides for detecting method calls that for any number of reasons take a particularly long time. To see if garbage collection is properly configured or if a particular problem related to garbage collection exists local GC statistic is used which includes dumping a statistical entry for each local garbage collection partial and full for each garbage collection run. Shared GC statistic is emitted when a local GC detects that a shared GC has happened and has not been dumped yet. The shared GC statistic contains the number and size of the collected shared classes shared interned strings and shared classes.

Another source of performance problems is related to I O. These I O related problems include a network connection being operated at its bandwidth maximum the latency being too high an external system being overloaded etc. To check for an I O problem I O trace allows for tracing the timing of each I O operation. I O trace can be used in analysis to check for operations where huge amounts of data were transmitted the I O operation took an extraordinary amount of time or a huge amount of small I O operations was performed.

JAVA has an explicit support for multithreading and concurrency at the language level. Although these welcome features the typical problems with multithreading and concurrency are deadlocks race conditions thread starvation and scalability problems. Synchronization monitoring is provided to detect such problems. For example synchronization monitoring includes monitor trace that identifies deadlock or scalability problems and gathers information about locks used inside a VM. To find synchronization problems a thread trying to acquire a lock is identified and once it is identified the lock is freed by the thread. Shared lock trace is used to identify deadlocks between VMs and scalability problems of a server instance. Shared lock trace provides information about different kinds of shared lock activities like entering and leaving. Further for such problems above scheduler trace is used to know why a thread was scheduled and why it gave up control of the CPU and for how long the entire VM was waiting on external I O or just sleeping.

In one embodiment application debugging is used to provide those the debugging functionalities that are not supported by conventional debugging instances and protocols such as JVMDI JAVA Debug Wire Protocol JDWP etc. For example application debugging covers functionalities such as call coverage and line coverage. Regarding call coverage method count trace may deliver a number of calls to a method. Regarding line coverage execution line trace may deliver information about code lines that were executed. Method call trace is used to find all methods that are called. When the method call trace is enabled the VM counts method calls and when the method call trace is disabled the VM dumps the collected information such as name and signature of a method and the number of times it was called. Execution line trace may be used to find out the lines of code that are not executed. When the execution line trace is triggered it enables the VM to write out information about the method and code line each time a byte code is interpreted and or the line number changes. Such information can help the developer find out the lines of code that are not covered particular test cases.

Method trace may be employed to trace or profile the debugging process of an application. For example the method trace is used to find out what has happened before the program reaches a certain point. Such information may be used to trace back the program flow and find out in which way the program reached that point of code. Exception trace is another functionality that may be employed to trace or profile the debugging process of an application. This information can be used to trace back the reasons for exceptions that followed up and for different execution branches.

In one embodiment a dedicated JAVA API and a GUI is provided to allow for starting and stopping of various functionalities and uses e.g. allocation trace loitering trace GC trace and other traces and for getting the corresponding profiling and tracing results. To determine and analyze the profiling and tracing results an expert mode and or a guided mode are provided. For example a guided mode may directly pinpoint any problem areas.

Profiling infrastructure is compatible with multiple clients. For example depending on the surrounding application server infrastructure and whether any clients are handled in a special way the profiling infrastructure may perform in compliance with several clients simultaneously and remain multiple client compliant. Profiling infrastructure also allows for restricting profiling runs to certain clients while the surrounding application server environment may assure that the current client information is assigned to the respective thread. Furthermore profiling infrastructure may be started on demand which includes performing profiling infrastructure functionalities e.g. profiling tracing etc. without restarting the entire application server or even the underlying VM . If no profiling option is enabled by a certain user there is no impact on the response time caused by the profiling infrastructure . However if profiling is enabled it may depend on the started profiling options and filter settings about how the overall system performance is influenced. For example if a method trace is started on an application server without any filter settings e.g. user classes etc. the performance may decrease to an extent. Therefore the profiling infrastructure as well as the application server infrastructure must provide options to restrict profiling runs. This way profiling may be enabled for a particular user or session while users and sessions remain unaffected. In addition profiling infrastructure provides reasonable and necessary filter settings for various profiling traces.

Class filters are implemented to allow for limiting profiling trace out puts by limiting the process of profiling to for example specific traces. For example if a developer seeks to profile only JAVA object allocations which refer to java.lang.HashMap instances then using class filters a profiling allocation trace with a class filter applying exclusively to java.lang.HashMap instances is started. Thread filters relate to profiling annotations e.g. specifying annotations such as when an allocation trace exists. Thread filters may also be used by the user to specify when and or where a trace is to be triggered and or used. Buffer framework is used to compress and decompress any type of data or information that is being communicated stored etc. Communication framework is used to facilitate communication of any data or information between and within various components elements modules systems servers VM etc. Communication framework is also used to determine and facilitate the storing of data or information such as storing the data using files or socket connections.

ID service is employed to specify variables such a class a name of the class etc. to assign identification to them. Once class class names etc. are assigned an ID e.g. a number they are then mapped with each other and with various components and variables via a mapping packet instead of mapping by names. Using ID service the same can be done with threads and methods. For example by assigning IDs instead of names to threads and methods when dumping is performed the IDs of threads and methods are dumped rather than their names. This technique of using IDs e.g. numbers instead of using the names is efficient fast and saves memory.

For example an allocation event is considered. ID numbers are mapped to various packet names such as java.Hashtable is mapped to 2000 the thread named main is assigned 3 and the user named Ralf is assigned 7 . Stack trace is then commenced using command lines such as com.sap.test line com.sap.submethod line etc. The even information may then be provided as etc. It is known that ID number was mapped to the underlying hashtable while ID number was mapped to the thread. Using these ID s names e.g. main Ralf etc. are not needed and instead IDs are used which provides an easier technique for packet name mapping. Similarly object ID service is used to assign IDs e.g. numbers to objects so the IDs can be used to for example identify and compare the objects instead of using object names.

In one embodiment profiling information and any other relevant data is displayed at a display device via GUI at a client so that a user can access and evaluate the displayed information. The information may also be stored at a database and or file system for subsequent retrieval and analysis. Although JAVA components such as J2EE server JAVA VM JAVA heap and JAVA memory errors etc. are discussed here for simplicity and brevity it should be noted however that the underlying principles and embodiments of the present invention may be implemented within any type of object oriented and runtime environments. Moreover it should be noted that requirements and examples used in this document do not necessarily reflect the real values that a system or program would actually produce. For example garbage collection may be invoked multiple times while checking the VM heap memory size so that there are different VM implementations and according to a relevant VM specification a given VM implementation might not clean up the memory immediately after it has been requested to do so. Thus to be sure that a memory cleanup is provoked the memory size may be checked and the garbage collection may be invoked again as necessary.

Garbage collection as described here includes a process designed to identify and reclaim blocks of memory that are dispensed by a memory allocator but are no longer alive or live e.g. no longer being used as determined for example by not being reachable from any currently referenced objects or entities . Garbage collection can sometimes be handled as a background task by runtime systems rather than as an explicit task by user programs. Garbage collection can also be handled as an inlined task. Garbage collection can be used to reclaim memory in runtime systems and there are some well known garbage collection algorithms e.g. reference counting mark sweep mark compact and copying algorithms .

A VM e.g. VM is an example of a runtime system. A VM refers to an abstract machine that includes an instruction set a set of registers a stack a heap and a method area such as a machine or processor. A VM essentially acts as an interface between program code and the actual processor or hardware platform on which the program code is to be executed. The program code includes instructions from the VM instruction set that manipulates the resources of the VM. The VM executes instructions on the processor or hardware platform on which the VM is running and manipulates the resources of that processor or hardware platform so as to effect the instructions of the program code. For example a JAVA source program can be compiled into program code such as bytecode. Bytecode can be executed on a VM such as JVM running on any processor or platform. The JVM can either interpret the bytecode one instruction at a time or the bytecode can be further compiled for the real processor or platform using a just in time JIT compiler.

The illustrated VM includes a JVM e.g. SAP JVM which is used as an example however other examples of VMs which can be used in various embodiments include Advanced Business Application Programming ABAP language VMs Common Language Runtime CLR VMs and the like. ABAP is a programming language for developing applications for SAP systems such as SAP R 3 system which is a widely installed business application system developed by SAP AG of Walldorf Germany. The CLR is a managed code execution environment developed by Microsoft Corp. of Redmond Wash. For simplicity and brevity the discussion in this document focuses on virtual machines and in particular JAVA virtual machine but it is to be understood that the techniques described herein can also be used with other types of runtime systems.

A runtime system includes a code execution environment that executes instructions or code in user requests and that provides runtime services for that code. Code runtime services may include functionality such as process thread and memory management e.g. laying out objects in the server memory sharing objects managing references to objects and garbage collecting objects . Enhanced runtime services may include functionality such as error handling and establishing security and connectivity.

The illustrated server includes a J2EE server engine node which supports Enterprise JAVA Bean EJB components and EJB containers at the business layer and Servlets and JAVA Server Pages JSP at the presentation layer . It is understood that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments JAVA based environments such as a J2EE environment or environments defined by other releases of the JAVA standard other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation and the like.

Online profiling is started via JAVA APIs e.g. server and client JAVA APIs using monitoring tools e.g. JAVA VM monitor and or using command lines. If the profiling is to be performed offline the offline profiling mode is triggered for for example non interactive profiling. Offline profiling can also be started using monitoring tools using command lines and or via JAVA APIs as described above. At processing block any profiling data obtained from offline profiling is stored at an external source such as a profiling file. The data at the profiling file may be stored in zipped format. At decision block whether the process of profiling be continued is determined. If yes the profiling continues with decision block . If not the profiling status is switched to the non profiling mode at processing block . This non profiling mode is maintained at processing block .

In one embodiment semantical information may be provided at and by server environment via semantical information module residing at server . Backend VM profiling infrastructure which includes thread filter that is in communication with the semantical information module to allow the filtering of those entities that are specified for profiling allocations. For example a particular user at a particular thread e.g. Michael at thread B may be specified such that the profiling data for a profiling trace is only collected or not collected when the particular user Michael executes at the particular thread . Using this technique of mechanism any negative impact of profiling sessions is limited to a particular area or entity. This is accomplished using semantical information e.g. user name Michael associated with a particular thread which is generated at server environment and extracted and provided by semantical information module and filtered using thread filter at profiling infrastructure at backend VM in communication with frontend VM . Since the process of profiling is used and controlled by client the user name e.g. Michael or any other entity such as a session an application a request etc. associated with a particular thread may be selected and identified by the user e.g. developer administrator etc. via client via frontend VM . It is contemplated that the illustrated JAVA based components such as the server the J2EE engine the VMs etc. are provided as examples and that the mechanism and other embodiments of the present invention can also be used with other non JAVA based environments and components. Furthermore a backend VM may reside at the same J2EE engine as the semantical information module or at another J2EE engine. Sever environment and client may include servers and clients similar to server and client respectively of .

In one embodiment mechanism is used to associate profiling data with semantical information about various entities such as users sessions requests applications and software components provided by server . Since none of the conventional mechanisms make use of semantical information in one embodiment using mechanism having semantical information is used for profiling applications e.g. JAVA applications by assigning semantical information to profiling data resulting reduced negative impact of profiling runs particularly of the started profiling runs. For example when a bunch of temporary JAVA objects are created during request processing garbage collector is triggered frequently and a negative impact on request throughput is observed. Now if a profiling trace is started for checking the allocation of the JAVA objects the allocation events and the corresponding stack traces are obtained. This information allows the user to know where the actual allocations took place. In one embodiment mechanism allows for extracting semantical information from server via semantical information module to be used by profiling infrastructure at backend VM in communication with frontend VM at client . The extracted semantical information is obtained at server and contains information about the components and entities such as the users software component sessions etc. involved with the actual allocations. This semantical information provides semantical knowledge of profiling allocations that is used to reduce any negative impact of profiling runs relating to threads .

When profiling traces are started the annotated thread information is related to the collected profiling data. For example if a profiling trace for JAVA object allocations is started the annotations associated with each thread are written to a profiling output stream at start up and upon each change. The object allocations are related to the thread where the allocation actually occurs. This is information is used to associate or assign the object allocations to various entities such as users sessions applications etc. as they relate to each thread . Furthermore if a certain profiling is to be started thread filter is used to specify that the profiling data is to be collected if for example a particular user executes in a particular thread e.g. Arno at thread A where the profiling event occurs. Using this technique any negative impact of a started profiling session is limited to a particular entity such as the particular user executing in the particular thread .

Once the semantical information is identified e.g. once the entity is identified such as user name Ralf this semantical information is communicated to profiling infrastructure at backend VM that is being profiled via server JAVA API for example prior to starting a profiling session. Once the semantical information is received at profiling infrastructure the thread filter at profiling infrastructure is used to filter other entities and information out such that the profiling data can be collected for this particular entity e.g. user name Ralf that was specified when this particular entity executes in the thread where the profiling event occurs . This is so that a profiling trace e.g. allocation trace may start but any impacts of the profiling session can be limited to a certain area e.g. the specified entity . Here allocation trace is merely used as an example and that this technique can be used with any number of profiling trace processes.

At profiling infrastructure the allocation trace starts using an allocation trace module along with the thread filter. Allocations are performed at the backend VM via the profiling infrastructure . Allocations are reported to the profiling infrastructure . At profiling infrastructure a determination is made as to whether the specified entity in this case user name Ralf is being executed at the current thread . In other words whether the user name associated with the current thread matches the user name specified Ralf . If the specified entity is not found e.g. the user name is different from the specified user name the process ends and no allocation information is reported . If however the entity being executed at the current thread matches with the entity specified and then filtered by the thread filter e.g. the user name is Ralf the allocations having detected and collected allocations or allocation information are reported to frontend to be displayed for the user via a display device at the client. The reported allocation information relates to the semantical information e.g. the identified entity which provides a narrow set of information resulting in limiting any negative impact of the profiling session to a particular area as identified by the semantical information.

At decision block a determination is made as to whether the specified entity is being executed at the current thread. If the entity does not match the profiling session continues or ends but the profiling results are not reported to the frontend VM at processing block . At processing block if the entity matches the specified entity the profiling session continues and the results of the profiling session are reported to the frontend VM so they can be displayed to the user via a display device at the client.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which can cause a machine such as a virtual machine a general purpose processor disposed on a semiconductor chip a special purpose processor disposed on a semiconductor chip etc. to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

One or more modules components or elements described throughout this document such as the ones shown within or associated with the on demand profiling infrastructure of profiling mechanism of may include hardware software and or a combination thereof. In a case where a module includes software the software data instructions and or configuration may be provided via an article of manufacture by a machine electronic device hardware. An article of manufacture may include a machine accessible readable medium having content to provide instructions data etc. The content may result in an electronic device for example a filer a disk or a disk controller as described herein performing various operations or executions described. A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information content in a form accessible by a machine e.g. computing device electronic device electronic system subsystem etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. as well as electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc. The machine accessible medium may further include an electronic device having code loaded on a storage that may be executed when the electronic device is in operation. Thus delivering an electronic device with such code may be understood as providing the article of manufacture with such content described above. Furthermore storing code on a database or other memory location and offering the code for download over a communication medium via a propagated signal may be understood as providing the article of manufacture with such content described above. The code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Client systems may execute multiple application or application interfaces. Each instance or application or application interface may constitute a user session. Each user session may generate one or more requests to be processed by server . The requests may include instructions or code to be executed on a runtime system such as VM on server such as the requests made via the on demand profiling infrastructure and its components and modules as described throughout this document.

In addition to what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

