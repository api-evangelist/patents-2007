---

title: Method and system for module initialization
abstract: A method for initializing a module that includes identifying a module for initialization and performing a plurality of processing phases on the module and all modules in a dependency graph of the module. Performing the processing phases includes, for each module, executing a processing phase of the plurality of processing phases on the module, determining whether the processing phase has been executed on all modules in a dependency graph of the module, and when the processing phase has been executed for all modules in the dependency graph of the module, executing a subsequent processing phase of the plurality of processing phases on the module, wherein at least one processing phase of the plurality of processing phases includes executing custom initialization code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099735&OS=08099735&RS=08099735
owner: Oracle America, Inc.
number: 08099735
owner_city: Redwood City
owner_country: US
publication_date: 20071221
---
This application is related to U.S. application Method and System for Module Initialization With An Arbitrary Number of Phases with U.S. Pat. No. 7 934 084 which is incorporated by reference in its entirety.

Software development and support costs are driven by many factors including increasing software complexity and the need to support multiple hardware platforms and operating systems. To help reduce these costs there is an increasing emphasis on creating modular software solutions to allow reuse of software components i.e. modules . Many different frameworks to support dynamic use of software components have been developed to meet these needs. Examples of such frameworks include the Java Module System JAM the OSGi Service Platform the Microsoft .NET Framework the Apache Software Foundation Maven and the Sun Microsystems NetBeans . Java and NetBeans are trademarks of Sun Microsystems Inc. OSGi is a trademark of The OSGi Alliance.

While specific implementation details and programming languages supported may vary module frameworks share a number of common features. Functionality included in a module framework may include a runtime engine module life cycle management one or more module repositories and module version management. This functionality allows off the shelf software modules to be reused and integrated into applications coherently and to be dynamically added updated and removed from the framework. In addition modules may dynamically discover and cooperate with each other.

In module frameworks a given module may be defined to depend on multiple other modules which may in turn depend on yet other modules. More specifically a module may export one or more interfaces that may be imported by other modules. As a result when a module is instantiated by the framework some initialization may need to be performed to ensure among other things that any modules on which that module depends are present i.e. that the imported interfaces are available and can also be instantiated and that there are no conflicts among these modules e.g. two modules export a class having the same name . This initialization process typically varies depending on the framework and the composition of the modules.

In general in one aspect the invention relates to a method for initializing a module. The method includes identifying a module for initialization and performing a plurality of processing phases on the module and all modules in a dependency graph of the module. Performing the processing phases includes for each module executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module wherein at least one processing phase of the plurality of processing phases includes executing custom initialization code.

In general in one aspect the invention relates to a module system that includes module storage configured to store a plurality of module definitions and a module initialization engine configured to initialize a module created from a module definition of the plurality of module definitions by performing a plurality of processing phases on the module and all modules in a dependency graph of the module. Performing the processing phases includes executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module wherein at least one processing phase of the plurality of processing phases includes executing custom initialization code.

In general in one aspect the invention relates to a computer readable medium. The computer readable medium includes executable instructions to initialize a module by identifying a module for initialization and performing a plurality of processing phases on the module and all modules in a dependency graph of the module. Performing the processing phases includes for each module executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module wherein at least one processing phase of the plurality of processing phases includes executing custom initialization code.

Other aspects of the invention will be apparent from the following description and the appended claims.

Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.

In the following detailed description of embodiments of the invention numerous specific details are set forth in order to provide a more thorough understanding of the invention. However it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail to avoid unnecessarily complicating the description.

In general embodiments of the invention provide a method and system for initializing a module in a module system. More specifically in one or more embodiments of the invention when a module is selected for execution the selected module and all modules on which the selected module directly or indirectly depends i.e. dependent modules are initialized by executing a sequence of processing phases on each of these modules i.e. the selected module and the dependent modules . Each processing phase performs an operation on a module e.g. identifying modules on which the module depends verifying constraints etc. . Further in one or more embodiments of the invention custom initialization code i.e. executable code that is not part of and not under the direct control of the module system may be executed in one or more of the processing phases. Execution of the custom initialization code may cause the initialization of one or more additional modules.

Further each processing phase on each module is followed by a graph walking phase. The graph walking phase walks a graph of the transitive closure of the dependent modules of the module to verify that each of the dependent modules have completed the immediately preceding processing phase. The initialization of the module is not allowed to progress to the next processing phase until all of the dependent modules of that module have completed at least the same processing phase as the module. The originally selected module is successfully initialized when a graph walking phase executed on the selected module indicates that all modules in the dependency graph of the selected module have successfully progressed through all of the processing phases.

As shown in the system includes a module system a runtime environment and an operating system . The operating system provides hardware interfaces and system functionality to software such as the runtime environment and the module system executing on a specific hardware platform not shown . The operating system may be any suitable operating system including for example Solaris UNIX Linux and the operating systems available from Microsoft and IBM. Solaris is trademark of Sun Microsystems Inc. UNIX is a registered trademark of The Open Group. Linux is a registered trademark of Linus Torvalds.

The runtime environment provides a software interface for executing applications such as the module system and the modules included in the module system . In one or more embodiments of the invention the runtime environment may be a software library for a specific programming language that provides functionality for interfacing with the underlying operating system e.g. operation system when an application e.g. the module system is executed. In such embodiments the module system is implemented in the programming language and the runtime environment may be linked as a part with the compiled code of the module system . In one or more embodiments of the invention the runtime environment may be a virtual machine that abstracts the underlying operating system and hardware platform. Further in one or more embodiments of the invention the module system may be implemented in Java and the runtime environment may be a Java Virtual Machine.

The module system is a framework for the development and deployment of module based applications and libraries. The module system provides for example a distribution format i.e. a module definition for packaging collections of functions or classes and any related resources along with information i.e. metadata describing the module to the framework a versioning scheme for the modules and runtime support for discovering loading integrity checking and initializing modules. The module system includes an application programming interface API a module manager module storage a module initialization engine a module cache and a module initialization queue . Each of these components of the module system is described in more detail below. Further in one or more embodiments of the invention the module system may be the Java Module System as described in the Java Specification Request JSR JSR 277 available from the Java Community Process website.

The API provides an interface for requesting various services from the module system . The module initialization queue holds those modules that are currently being initialized by the module system . The module queue may be implemented as any suitable data structure including for example a linked list an array and a circular buffer. The module cache stores fully initialized and instantiated modules and modules that are in the process of being initialized. In one or more embodiments of the invention the module cache may be implemented in any form suitable for storing modules including for example one or more data structures in the memory of a computer system one or more databases and one or more files in a file system.

Module storage stores module definitions for the modules configured for use with the module system. In one or more embodiments of the invention the module definitions stored in module storage may include module definitions provided by a vendor of the module system module definitions developed by one or more users of the module system and or module definitions from third party vendors. A module definition is used to instantiate i.e. create an instance of the module it describes. In one or more embodiments of the invention a module definition for example specifies what classes and resources are provided by a module what functionality the module imports and exports and the version of the module. In one or more embodiments of the invention a module definition may also specify custom initialization code to be executed when a module is instantiated from the module definition and initialized by the module system. A module definition is described in more detail below in reference to . In one or more embodiments of the invention module storage may be for example one or more databases file systems file or database servers any other suitable storage medium and combinations thereof.

In one or more embodiments of the invention module storage may include one or more module repositories. A module repository is a mechanism for storing discovering and retrieving module definitions in the module system . Module repositories may include a bootstrap repository that exposes core platform module definitions a global repository that exposes module definitions that may be shared by multiple processes an application repository that exposes module definitions specific to an application a URL repository that exposes module definitions stored on a server and or other user defined repositories. A more detailed description of one example of module repositories may be found in JSR 277.

The module manager includes functionality to receive requests from the API interact with other parts of the module system to fulfill the requests and provide any results of fulfilling the requests to the API . The module manager further includes functionality to manage the initialization of modules whose module definitions are stored in module storage . For example in one or more embodiments of the invention a request is made to the module system through the API to locate a specific module definition in module storage using for example the module name or other information that identifies the module. A second request is then made to the module system through the API to request a module corresponding to the module definition from the module manager . The module manager first checks the module cache to see if the requested module has already been initialized or is in the process of being initialized. If the requested module is not in the module cache the module manager causes a module object to be created from the module definition and added to the module cache and to the module initialization queue .

The module initialization engine includes functionality to initialize the modules in the module initialization queue . More specifically the module initialization engine performs a multi phase initialization process on each module in the module initialization queue . As is explained in more detail below in reference to the multi phase initialization process includes both processing phases and graph walking phases. In one or more embodiments of the invention in the initialization process each processing phase on a module is followed by a graph walking phase on the module. In addition once a specific processing phase is performed on a module the next processing phase in the initialization process is not executed on the module until all dependent modules of the module have successfully completed at least the specific processing phase. Further in some embodiments of the invention the processing phases in the initialization process are required to be executed in a specific order.

While the number of processing phases is not necessarily limited in one or more embodiments of the invention the number of processing phases may be predetermined. For example some embodiments of the invention may include only two processing phases while other embodiments of the invention may include three processing phases four processing phases etc. In some embodiments of the invention the number of processing phases performed may be application or module dependent. For example the multi phase initialization process may include some number of required processing phases and allow for one or more optional processing phases. In such embodiments an optional processing phase may be performed upon request by an application that requests a module from the module system and or if indicated in a module definition. Thus the number of processing phases performed on a module and its dependent modules may be dynamically determined at run time.

A processing phase is a phase in which some initialization operation is performed on a module. An initialization operation may be for example identifying those modules on which a module depends and adding those dependent modules to the initialization queue if the dependent modules have not been initialized. An initialization operation may also be for example checking for namespace conflicts between dependent modules. Further in one or more embodiments of the invention an initialization operation may include the execution of custom initialization code. As is explained in more detail below in reference to in some embodiments of the invention custom initialization code may be included in the module definition of the module. In addition in some embodiments of the invention custom initialization code may be provided by an application that requests a module from the module system. In one or more embodiments of the invention there are two possible outcomes to a processing phase the module progresses to the graph walking phase or the module is marked to indicate that the processing phase did not complete successfully e.g. the module is marked as being in an error state .

In some embodiments of the invention a particular processing phase may be designated as a processing phase in which custom initialization code is to be executed on a module if such custom initialization code is provided. For example if the multi phase initialization process includes three processing phases the third processing phase may be designated as the processing phase for performing custom initialization code such as for example custom initialization code included in the module definition of the module. Further in some embodiments of the invention a processing phase for executing some types of custom initialization code such as for example custom initialization code provided by an application when requesting a module may be dynamically added to the multi phase initialization process as needed.

The graph walking phase that follows each processing phase is used to determine whether the next processing phase can be performed on the module i.e. that all dependent modules of a module have successfully completed at least the same processing phase as the module. In one or more embodiments of the invention a graph walking phase walks the graph of the transitive closure of a module s dependent modules to verify that each of the dependent modules has successfully completed at least the same processing phase as the module.

In one or more embodiments of the invention there are four possible outcomes of a graph walking phase 1 if any processing phase was not successfully completed on a dependent module the module is marked to indicate that the module cannot be successfully initialized e.g. the module is marked as being in an error state and initialization of the module is aborted 2 if all dependent modules have completed at least the same processing phase as the module the next processing phase is performed on the module 3 if all dependent modules have completed at least the same processing phase as the module and all processing phases have been completed on the module the module is marked to indicate successful initialization and is removed from the module initialization queue and 4 if all dependent modules have not completed at least the same processing phase the module is marked to indicate that the processing phase has been completed on the module the module initialization engine selects the next module in the module initialization queue to process and the graph walking phase is repeated the next time the module initialization engine selects the module from the module initialization queue for processing.

Module metadata includes information about the module that may be needed for initialization and instantiation of the module and or for other modules to be able to use the module. In one or more embodiments of the invention module metadata may include a name of the module the imports and class exports of the module and the members of the module. The name may be a text string or any other suitable identifier for the module. The imports specify the modules that are imported by the module. More specifically the imports identify those modules on which a module instantiated from the module definition directly depends. In one or more embodiments of the invention the imports are used by the module initialization engine of to identify the direct dependent modules of a module during a processing phase.

The class exports specify which of the classes in the module classes are visible to other modules i.e. may be called by other modules. In one or more embodiments of the invention the class exports may also identify classes that are re exported by the module i.e. classes that are imported from another module and then exported by the module. In one or more embodiments of the invention the class exports are used by the module initialization engine of to check for naming conflicts between modules during a processing phase. The members identify the classes that are part of the module.

In one or more embodiments of the invention the module metadata may also include one or more of a version a main class attributes resource exports a module initializer and an import policy class . The version specifies the version of the module represented by the module definition . The main class identifies a class of the module classes that is an entry point for the module i.e. the initial class to be called to start execution of the module. The resource exports identify those resources of the module resources that are exported i.e. made visible by the module. In one or more embodiments of the invention a resource may be identified by a path name of the file storing the resource. In one or more embodiments of the invention the resource exports may also identify resources that are re exported by the module i.e. resources that are imported from another module and then exported by the module.

The attributes are used to specify extensions to the module metadata . In more or more embodiments of the invention an attribute may be a name value pair of text strings that uniquely identify the attribute and provide a value for the attribute. The attributes may be defined and used by other modules in the module system of . Further the presence of a particular attribute defined by another module in the module metadata indicates that the module provides a feature of interest to the other module. For example a service loader module may define a service provider attribute that is to be included in modules that contain service providers. At run time when a service is requested by the service loader the module system of can then discover the available service providers by looking in the module storage of for those modules that include the service provider attribute in their module metadata.

The module initializer and the import policy class each specify custom initialization code to be executed in processing phases of the multi phase initialization process described herein. In one or more embodiments of the invention the module initializer specifies a class or function to be called to perform initialization operations specific to the module. Such initialization operations may include for example reading of configuration files establishing a connection with a database registering with system services setting up a network service to allow other applications to interact with the module etc. In one or more embodiments of the invention the custom initialization code specified by the module initializer is executed in a specifically designated processing phase of the multi phase initialization process. For example the multi phase initialization process may include three processing phases in which the first processing phases identifies dependent modules the second processing phase checks type conflicts between dependent modules and the third processing phase executes the custom initialization code of a module if any specified in the module initializer .

In one or more embodiments of the invention the import policy class specifies a class or function that provides a custom policy for importing dependent modules. The custom import policy allows a module to specify custom requirements for importing modules. Examples of custom import requirements include but are not limited to specifying that the version of an imported module must be a specific version or within a range of versions specifying that a specific version s of a module should not be imported specifying that a module to be imported must include certain attributes and or specifying the specific processing platform an imported module must execute on. In one or more embodiments of the invention the import policy class if provided is invoked in a processing phase specifically designated for identifying the direct dependent modules of a module.

As previously mentioned module initialization is a multi phase initialization process that is performed on a module and all modules in a dependency graph of the module i.e. all modules on which the module may directly or indirectly depend. Further the multi phase initialization process includes processing phases and graph walking phases that are performed on each of these modules.

In one or more embodiments of the invention each module may include or have associated with it a status indicator that indicates the initialization status of the module. More specifically the status indicator may indicate which phase of the initialization process has most recently been completed on the module. In one or more embodiments of the invention each phase is identified by an integer e.g. 0 1 2 3 4 . . . with the processing phases assigned odd integers the graph walking phases assigned even integers and a phase number of 0 indicating that no processing phase has been performed. Accordingly the status indicator of a module may store the number of the phase most recently completed. For simplicity of explanation the flow diagram of may be described below assuming that the phases are so identified. However other approaches for indicating the initialization status of a module may be used without departing from the scope of the invention and the focus on one particular approach should not be interpreted as limiting the invention in any way.

In one or more embodiments of the invention the module initialization process does not permit a dependency cycle between a module and other modules initialized as the result of executing custom initialization code described in more detail below during the initialization of the module. Accordingly the module initialization process may include steps to detect such dependency cycles. For example in one or more embodiments of the invention the module initialization process monitors the module initialization queue to determine if progress is being made in initializing the modules in the queue. More specifically when initially started the module initialization process may set a progress indicator e.g. a Boolean variable to indicate that no progress has been made in initializing any module in the queue. Then as is explained in more detail below after any module successfully completes a processing phase or a graph walking phase and is allowed to progress to the next phase or if a module is moved to an error state the progress indicator is set to indicate that initialization progress has been made.

Each time the module initialization process reaches the end of the module initialization queue the module initialization process checks the progress indicator. If the progress indicator indicates that progress has been made the module initialization process then sets the progress indicator to indicate no progress selects the first module in the queue and continues the initialization process. If no progress has been made all modules remaining in the module initialization queue are marked to indicate that they were not successfully initialized i.e. are moved to an error state and the module initialization process terminates. The module initialization process is designed such that at least one module should make progress in each pass through the module initialization queue unless there is a dependency cycle between a module and any module that is initialized as part of executing custom initialization code for that module.

In one or more embodiments of the invention a module that is to be initialized is added to a module initialization queue e.g. the module initialization queue of . More specifically in one or more embodiments of the invention a module definition e.g. module definition of may be retrieved from a module repository in module storage e.g. module storage of a module object i.e. a module instance may be created using the module definition and the module instance i.e. the module may be added to the module initialization queue to be initialized. Further an initialization status may be associated with the module. More specifically a status indicator for the module may be set to 0 to indicate that no processing phase has been performed on the module.

Referring now to the initialization process for a module begins when the module is selected from the module initialization queue Step . When a module is selected from the module initialization queue a check is made to determine whether the initial processing phase has been performed on the module Step . In one or more embodiments of the invention if the status indicator of the retrieved module is 0 the initial processing phase has not been performed.

If the first processing phase has not been performed on the module that first processing phase is performed Step . In one or more embodiments of the invention in the initial processing phase any modules on which the module directly depends are identified. In one or more embodiments of the invention the dependent modules are the modules imported by the module. In some embodiments of the invention the dependent modules are specified in the metadata of the module definition e.g. imports in . Each dependent module that has not been previously initialized or that is not currently undergoing initialization is added to the module initialization queue with a status indicator of 0. Any of the dependent modules that have already been initialized or are currently being initialized may be stored in a module cache e.g. the module cache of with status indicators indicating the initialization phase last completed on those modules.

In one or more embodiments of the invention custom initialization code may be executed as part of the initial processing phase Step . If custom initialization code is not executed Step in one or more embodiments of the invention the status indicator of the module is set to indicate that the first phase has been completed on the module and the next step Step is performed. Further in one or more embodiments of the invention a progress indicator is set to indicate that progress has been made.

In some embodiments of the invention the custom initialization code is code that specifies custom requirements for determining the modules to be imported e.g. the import policy class of . In some embodiments of the invention the custom initialization code i.e. custom import code may be executed to augment the explicit designation of imported i.e. dependent modules. For example the module metadata may include both an explicit designation of imported modules and custom import code and both will be used during the initial processing phase. In other embodiments of the invention either imported modules are explicitly designated or custom import code is provided. In yet other embodiments of the invention the custom import code may override any explicit designation of imported modules.

As is shown in if custom initialization code is to be executed the current module i.e. the module for which the custom initialization code is being executed is removed from the module initialization queue Step . Then the custom initialization code is executed Step . As part of executing this custom initialization code one or more new modules may need to be initialized for example because the custom initialization code uses an API e.g. API of to request a module from a module system e.g. module system of Step . If one or more new modules do not need to be initialized the current module is returned to the module initialization queue Step after the custom initialization code is executed and the process continues with the next step Step in . In one or more embodiments of the invention the status indicator of the current module is set to indicate that the processing phase has been completed on the module. Further in one or more embodiments of the invention a progress indicator is set to indicate that progress has been made.

In one or more embodiments of the invention if one or more new modules are to be initialized the module initialization process detects a recursive invocation for each module to be initialized. The new module is added to the module initialization queue Step and the process waits until the return from the recursive invocation i.e. until the new module is initialized Step . More specifically adding the new module to the module initialization queue causes the new module to be initialized using the module initialization process described in . In one or more embodiments of the invention the new module is added to the module initialization queue a status indicator for the new module is set to 0 to indicate that no processing phase has been performed on the new module and the module initialization process is recursively invoked.

The recursively invoked module initialization process continues processing each module in the module initialization queue as described herein. The recursive invocation is terminated when the new module is either successfully initialized or a determination is made that the new module cannot be initialized. For example after any module is successfully initialized the module initialization process may check to determine if that module is the module that caused the recursive invocation. If the successfully initialized module is the one that caused the recursive invocation the recursive invocation is terminated.

The initialization of modules in the custom initialization code continues until all are initialized Step Step . Once the new modules are initialized the custom initialization code completes execution and the current module is returned to the module initialization queue Step . In one or more embodiments of the invention the status indicator of the current module is set to indicate that the processing phase has been completed on the module. Further in one or more embodiments of the invention a progress indicator is set to indicate that progress has been made. The process continues with the next step Step in .

Returning to upon successful completion of the first processing phase a graph walking phase is performed Step . Further when a module is retrieved from the module initialization queue that has already had the first processing phase performed on it Step a graph walking phase is performed Step . The graph walking phase walks the transitive closure of the dependency graph of the module to determine if the dependent modules of the module have progressed sufficiently to allow the next processing phase if any to be performed on the module. More specifically the graph walking phase walks the dependency graph to determine whether the dependent modules have successfully completed at least the last processing phase that was successfully completed on the module. For example if processing phase has been successfully completed on the module then the graph walking phase checks the dependent modules to determine if at least processing phase has been successfully completed on those modules. In one or more embodiments of the invention more processing phases may have been completed on a dependent module than on the module that depends on it.

If all of the dependent modules have completed at least the processing phase previously completed on the module Step then the initialization process for that module may advance to the next processing phase if any. If all of the processing phases have been successfully completed on the module step the status indicator of the module may be set to indicate that the module is completely initialized and the module may be removed from the module initialization queue Step . In one or more embodiments of the invention the status indicator is set to the integer representing the final graph walking phase of the initialization process to indicate successful initialization. Further in one or more embodiments of the invention a progress indicator is set to indicate that progress has been made.

If the module initialization queue is empty step the module initialization process terminates. In one or more embodiments of the invention termination may include notifying an application that request initialization of a module that the initialization is complete.

If the module initialization queue is not empty Step a check is made to determine if the end of the module initialization queue has been reached Step . If the end of the module initialization queue has not been reached the next module is selected from the module initialization queue for processing Step . If the end of the module initialization queue has been reached a check is made to determine if progress has been made in initializing any module in the module initialization queue Step .

In one or more embodiments of the invention a progress indicator is checked. As explained above the progress indicator is set to indicate no progress before processing the first module in the module initialization queue and is set to indicate progress if any module successfully completes a processing step or successfully completes the entire initialization process during a pass through the module initialization queue. If no progress is indicated the module initialization process is terminated. In one or more embodiments of the invention each module remaining in the module initialization queue is marked as not being successfully initialized before the initialization process is terminated. If progress has been made the progress indicator is set to indicate no progress and the next module in the module initialization queue i.e. the first module is selected from the module initialization queue for processing Step .

Referring back to Step if all processing phases have not been completed on the module the next processing phase is performed on the module Step . In one or more embodiments of the invention the processing phase may include the execution of custom initialization code Step . If custom initialization code is to be executed the processing continues as described above in reference to . The custom initialization code may be for example a module initializer class specified in the module definition of the module or initialization code specified by an application when requesting a module.

If custom initialization code is not to be executed Step the status indicator of the module is set to indicate completion of the processing phase. In one or more embodiments of the invention the status indicator is set to the integer representing the processing phase completed. For example if processing phase is performed the status indicator is set to 3. Further in one or more embodiments of the invention a progress indicator is set to indicate that initialization progress has been made. Another graph walking phase is then performed on the module Step . The cycle of performing a graph walking phase and a processing phase on the module Steps continues until either there are no more processing phases to be performed Step or the processing phase performed on the module prior to the graph walking phase has not been completed on the dependent modules Step .

If all of the dependent modules have not completed at least the processing phase previously completed on the module Step then processing continues at Step as described above. In one or more embodiments of the invention the status indicator of the module is set to indicate that a graph walking phase should be performed on the module the next time the module is selected from the module initialization queue.

In one or more embodiments of the invention a module is successfully initialized when all phases of the multi phase initialization process have been successfully performed on the module and any modules on which the module directly or indirectly depends. Further in one or more embodiments of the invention the number of processing phases in an initialization process is arbitrary. More specifically the above described methods and systems for initialization do not limit the number of processing phases that may be included in embodiments of the invention. However in some embodiments of the invention the number of processing phases may be predetermined.

The example in illustrates the application of the multi phase initialization process in initializing module A . shows the dependencies of module A . Module A imports module B and module C so module A directly depends on module B and module C . Module B does not import another module so module D has no direct dependencies. Module C imports module D so module C directly depends on module D and module A indirectly depends on module D . Module D does not import another module so module D has no direct dependencies. In addition only Module B specifies a module initializer class.

As is shown in when initialization of module A is requested the status indicator labeled as Phase in of module A is set to 0 to indicated that no phase of the initialization process has been performed module A . In addition module A is added to the module initialization queue . A progress indicator Boolean flag not shown is also set to False to indicate that no initialization progress has been made. At this point in the initialization process the dependent modules of module A have not been identified so the dependency graph of module A includes only module A .

Subsequently the initialization process selects module A from the module initialization queue and phase a processing phase is successfully performed on module A followed by the first graph walking phase phase . The progress indicator flag is also set to True to indicate that initialization progress has been made. As is shown in after phases and are performed the direct dependent modules of module A i.e. module B and module C have been identified and placed in the module initialization queue to be initialized. Further the status indicators of both module B and module C have been set to 0 to indicate that no phase of the initialization process has been performed on these modules. In addition the status indicator of module A has been set to 1 to indicate that phase was successfully completed on module A .

After the execution of phase the dependency graph of module A now includes module B and module C . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module A the outcome indicates that phase has not yet been performed on either module B or module C . Therefore module A is not permitted to advance to the next processing phase in the initialization process. Accordingly the initialization process moves to the next module in the module initialization queue .

The initialization process thus selects module B from the module initialization queue . Phase is successfully performed on module B followed by the first graph walking phase phase . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module B the outcome is clearly that phase has been performed on all dependent modules of module B as module B has no dependent modules. Therefore module B is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module B in which any direct dependent modules of module B are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module B . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module B . Therefore module B is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module B in which a module initializer class if one is specified is to be executed. Module B includes a module initializer class so module B is removed from the module initialization queue and the module initializer class is executed. During the execution of the module initializer class a new module module K requires initialization. As shown in module B is now gone from the module initialization queue and module K is added. Further the status indicator of module B is set to 4 to indicate that phase was successfully completed on module B . The initialization process is recursively invoked to initialize module K and moves to the next module in the module initialization queue .

The initialization process then selects the next module module C from the module initialization queue . Phase is successfully performed on module C followed by the first graph walking phase phase . As is shown in after phases and are performed the direct dependent module of module C i.e. module D is identified and added to the module initialization queue for initialization. The status indicator for module D has also been set to 0 to indicate that no phase of the initialization process has been performed on module D . Further the status indicator of module C has been set to 1 to indicate that phase was successfully completed on module C .

After the execution of phase the dependency graph now includes module D . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module C the outcome is that phase has not been performed on module D . Therefore module C is not permitted to advance to the next processing phase in the initialization process. Accordingly the initialization process moves to the next module in the module initialization queue .

The initialization process then selects module K from the module initialization queue . Phase is successfully performed on module K followed by the first graph walking phase phase . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module K the outcome is clearly that phase has been performed on all dependent modules of module K as module K has no dependent modules. Therefore module K is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module K in which any direct dependent modules of module K are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module K . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module K . Therefore module K is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module K in which a module initializer class if one is specified is to be executed. Module K does not includes a module initializer class so none is executed. Upon successful completion of phase the third graph walking phase phase is performed on the transitive closure of the dependency graph of module K . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module K . Therefore module K has successfully completed all of the initialization phases. As shown in module K is removed from the module initialization queue . Further the status indicator of module K is set to 6 to indicate all phases of the initialization process have been successfully completed on module K . Since module K is initialized the recursive invocation of the initialization process is ended. Module B is then returned to the module initialization queue . For purposes of this example Module B is placed in the module initialization queue in the location from which Module K was removed i.e. before module D .

The module initializer class for module B completes execution thus successfully completing the execution of phase on module B . Upon successful completion of phase the third graph walking phase phase is performed on the transitive closure of the dependency graph of module B . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module B . Therefore module B has successfully completed all of the initialization phases. Module B is removed from the module initialization queue . Further the status indicator of module B is set to 6 to indicate all phases of the initialization process have been successfully completed on module B .

The initialization process then selects the next module module D from the module initialization queue . Phase is successfully performed on module D followed by the first graph walking phase phase . As is shown in after phase is performed the dependency graph is unchanged as module D has no direct dependent modules. When the graph walking phase phase is performed on the transitive closure of the dependency graph of module D the outcome is clearly that phase has been performed on all dependent modules of module D as module D has no dependent modules. Therefore module D is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module D in which any direct dependent modules of module D are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module D . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module D . Therefore module D is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module D in which a module initializer class if one is specified is to be executed. Module D does not includes a module initializer class so none is executed. Upon successful completion of phase the third graph walking phase phase is performed on the transitive closure of the dependency graph of module D . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module D . Therefore module D has successfully completed all of the initialization phases. As shown in module D is removed from the module initialization queue . Further the status indicator of module D is set to 6 to indicate all phases of the initialization process have been successfully completed on module D .

The initialization process has now reached the end of the module initialization queue . The progress indicator flag is checked to see if progress was made in initializing any module in the module initialization queue . The process indicator flag is currently set to True so progress has been made. The progress indicator flag is set to False and the initialization process starts again with the first module in the module initialization queue .

The initialization process thus selects module A from the module initialization queue . The status indicator of module A indicates that the last processing phase performed on module A was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module A again to determine whether module A is permitted to progress to the next processing phase. The outcome of performing the graph walk is that the direct dependent modules of module A module B and module C and the indirect dependent module of module A module D have all completed phase . Therefore module A is permitted to advance to the next processing phase in the initialization process phase and the progress indicator flag is also set to True to indicate that initialization progress has been made.

Phase is performed on module A in which any direct dependent modules of module A are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module A . The outcome of the phase graph walk is that phase has not been performed on one of the dependent modules of module A i.e. module C . Therefore module A is not permitted to advance to the next processing phase in the initialization process. As shown in the status indicator of module A is set to 3 to indicate that phase was successfully completed on module A . The initialization process then moves to the next module in the module initialization queue .

The initialization process thus selects module C from the module initialization queue . The status indicator of module C indicates that the last processing phase performed on module C was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module C again to determine whether module C is permitted to progress to the next processing phase. The outcome of the graph walking phase is that the direct dependent module of module C module D has successfully completed the last processing phase performed on module C i.e. phase . Therefore module C is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module C in which any direct dependent modules of module C are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module C . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module C . Therefore module C is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module C in which a module initializer class if one is specified is to be executed. Module C does not includes a module initializer class so none is executed. Upon successful completion of phase the third graph walking phase phase is performed on the transitive closure of the dependency graph of module C . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module C . Therefore module C has successfully completed all of the initialization phases. As shown in module C is removed from the module initialization queue . Further the status indicator of module C is set to 6 to indicate all phases of the initialization process have been successfully completed on module C .

The initialization process has again reached the end of the module initialization queue . The progress indicator flag is checked to see if progress was made in initializing any module in the module initialization queue . The process indicator flag is currently set to True so progress has been made. The progress indicator flag is set to False and the initialization process starts again with the first module in the module initialization queue .

The initialization process thus selects module A from the module initialization queue . The status indicator of module A indicates that the last processing phase performed on module A was phase so the second graph walking phase phase is performed on the transitive closure of the dependency graph of module A again to determine whether module A is permitted to progress to the next processing phase. The outcome of the graph walking phase is that all of the direct and indirect dependent modules of module A have completed the last processing phase performed on module A i.e. phase . Therefore the progress indicator is set to True and module A is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module A in which a module initializer class if one is specified is to be executed. Module A does not include a module initializer class so none is executed. Upon successful completion of phase the third graph walking phase phase is performed on the transitive closure of the dependency graph of module A . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module A . Therefore module A has successfully completed all of the initialization phases. As shown in module A is removed from the module initialization queue . Further the status indicator of module A is set to 6 to indicate all phases of the initialization process have been successfully completed on module A .

Embodiments of the invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system may be connected to a network e.g. a local area network LAN a wide area network WAN such as the Internet or any other similar type of network via a network interface connection not shown . Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the aforementioned computer system may be located at a remote location and connected to the other elements over a network. Further embodiments of the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention e.g. module system module storage module cache etc. may be located on a different node within the distributed system. In one embodiment of the invention the node may be a computer system. Alternatively the node may be a processor with associated physical memory. The node may alternatively be a processor with shared memory and or resources. Further software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape a file or any other computer readable storage device.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly the scope of the invention should be limited only by the attached claims.

