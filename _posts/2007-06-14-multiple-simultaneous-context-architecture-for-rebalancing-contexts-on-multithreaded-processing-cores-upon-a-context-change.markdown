---

title: Multiple simultaneous context architecture for rebalancing contexts on multithreaded processing cores upon a context change
abstract: Graphics processing elements are capable of processing multiple contexts simultaneously, reducing the need to perform time consuming context switches compared with processing a single context at a time. Processing elements of a graphics processing pipeline may be configured to support all of the multiple contexts or only a portion of the multiple contexts. Each processing element may be allocated to process a particular context or a portion of the multiple contexts in order to simultaneously process more than one context. The allocation of processing elements to the multiple contexts may be determined dynamically in order to improve graphics processing throughput.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08095782&OS=08095782&RS=08095782
owner: NVIDIA Corporation
number: 08095782
owner_city: Santa Clara
owner_country: US
publication_date: 20070614
---
This application is a continuation in part of U.S. patent application titled Multiple Simultaneous Context Architecture filed Apr. 5 2007 and having and Ser. No. 11 696 928 now U.S. Pat. No. 7 979 683. The aforementioned related patent application is herein incorporated by reference.

The present invention generally relates to graphics data processing and more specifically to processing multiple graphics contexts simultaneously and allocating graphics processing units among the multiple graphics contexts.

Current graphics processing systems maintain state information for a single processing context. A processing context consists of a complete set of rendering state through the entire graphics pipeline. Many programs running on a CPU will need only one processing context for all their graphics although some programs might use multiple processing contexts. For example a program may use one context for each window or one context for graphics and another context to run computing applications on a graphics processor. As more application programs use the graphics processing system to perform graphics processing it is necessary to switch between the different contexts that correspond to each application program. As the capabilities of the graphics processing systems have increased the complexity and execution time for the graphics processing programs has also increased. Therefore the amount of active state information that is maintained within the graphics processing system has also increased.

In order to complete a context switch the active state information is saved in memory and new state for a different context is loaded into the graphics processing system and processing is resumed using the new state. The time needed to unload and load the active state information reduces the processing throughput since the graphics processing system is unavailable during the unloading and loading operations. In some cases the unloading and loading operation may take as long as 500 microseconds. When each context requires a small amount of graphics processing the context switching time may exceed the time spent processing data. Alternatively the graphics processing pipeline may be drained to idle the pipeline so that the size of the active state information is minimized. However some graphic pipelines may be very deep i.e. have a high latency and require too long to drain necessitating a costly active context switch to change to a different context without draining the pipeline.

Accordingly what is needed in the art is a system and method for improving processing throughput when multiple graphics contexts are processed.

Graphics processing elements within a graphics processing system are capable of processing multiple contexts simultaneously reducing the need to perform time consuming context switches compared to processing multiple contexts serially. Processing elements of a graphics processing pipeline may be configured to support all of the multiple contexts or only a portion of the multiple contexts. Each processing element may be allocated to process a particular context or a portion of the multiple contexts in order to simultaneously process more than one context. The allocation of processing elements to the multiple contexts may be determined dynamically in order to improve graphics processing throughput.

There are two types of processing engines cores and processing units. The processing units maintain state for all of the active contexts so those units can run any of the active contexts. The cores are allocated to a single context at a time and save and restore context state in order to perform a context switch. When a new context is launched any available processing units begin processing the next context and the cores begin processing the new context as they are available. The workload from older contexts may be migrated to fewer cores in order to free up cores to process the new context. Therefore the processing engines may begin processing a new high priority context quickly.

Various embodiments of a method of the invention for switching contexts in a multiple context processing system include receiving a context change from a first context to a second context responsive to a context changing event and determining if the first context is being executed by one or more multithreaded processing cores. When the first context is being executed by one or more of the multithreaded processing cores the first context is rebalanced to be executed by a first portion of the multithreaded processing cores to make available a second portion of the multithreaded processing cores to execute the second context. The method accepts methods for the second context and the second context is processed using a processing unit that is configured to maintain context state for multiple contexts.

Various embodiments of the invention for simultaneously processing multiple contexts include a parallel processing unit configured to simultaneously process the multiple contexts. The parallel processing unit includes a plurality of context engines a work distribution unit multithreaded processing cores and one or more processing engines. The plurality of context engines are configured to receive methods for the multiple contexts and produce instructions and data for processing the multiple contexts and rebalance processing of the multiple contexts when a context change is received. The work distribution unit is coupled to the plurality of context engines and configured to receive the instructions and data for the multiple contexts and distribute the instructions and data. The multithreaded processing cores are coupled to the work distribution unit and configured to process instructions and data for the multiple contexts and maintain context state for a portion of the multiple contexts. The one or more processing engines are coupled to the work distribution unit and configured to process instructions and data for the multiple contexts and maintain context state for the multiple contexts.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

Memory bridge which may be e.g. a Northbridge chip is connected via a bus or other communication path e.g. a HyperTransport link to an I O input output bridge . I O bridge which may be e.g. a Southbridge chip receives user input from one or more user input devices e.g. keyboard mouse and forwards the input to CPU via path and memory bridge . A parallel processing subsystem is coupled to memory bridge via a bus or other communication path e.g. a PCI Express Accelerated Graphics Port or HyperTransport link in one embodiment parallel processing subsystem is a graphics subsystem that delivers pixels to a display device e.g. a conventional CRT or LCD based monitor . A system disk is also connected to I O bridge . A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including USB or other port connections CD drives DVD drives film recording devices and the like may also be connected to I O bridge . Communication paths interconnecting the various components in may be implemented using any suitable protocols such as PCI Peripheral Component Interconnect PCI Express PCI E AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

An embodiment of parallel processing subsystem is shown in . Parallel processing subsystem includes one or more parallel processing units PPUs each of which is coupled to a local parallel processing PP memory . An instruction stream buffer that specifies the location of data and program instructions for execution by each PPU may be stored in each PP memory . In general a parallel processing subsystem includes a number U of PPUs where U 1. Herein multiple instances of like objects are denoted with reference numbers identifying the object and parenthetical numbers identifying the instance where needed. PPUs and PP memories may be implemented e.g. using one or more integrated circuit devices such as programmable processors application specific integrated circuits ASICs and memory devices.

As shown in detail for PPU each PPU includes a host interface that communicates with the rest of system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. Host interface generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path and directs them to appropriate components of PPU . For example commands related to processing tasks may be directed to a front end unit while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a memory interface . Host interface front end unit and memory interface may be of generally conventional design and a detailed description is omitted as not being critical to the present invention.

Each PPU advantageously implements a highly parallel processor. As shown in detail for PPU a PPU includes a number C of cores where C 1. Each processing core is capable of executing a large number e.g. tens or hundreds of threads concurrently where each thread is an instance of a program one embodiment of a multithreaded processing core is described below. As previously described a processing context encompasses a complete set of state through PPU while a thread may encompass only the state required to shade a single pixel. Threads run inside processing contexts one processing context might contain thousands of running threads. Cores receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from a front end unit . Work distribution unit can implement a variety of algorithms for distributing work. For instance in one embodiment work distribution unit receives a ready signal from each core indicating whether that core has sufficient resources to accept a new processing task. When a new processing task arrives work distribution unit assigns the task to a core that is asserting the ready signal if no core is asserting the ready signal work distribution unit holds the new processing task until a ready signal is asserted by a core .

In a conventional system processing tasks for a single context are executed in parallel and a context switch must occur before processing tasks for another context are received. In contrast when multiple contexts are used as permitted by the present invention each processing task may correspond to a different one of the multiple contexts and cores may be configured to process tasks for one or more of the multiple contexts. In some embodiments of the present invention device driver allocates one or more core s for each one of the multiple contexts and work distribution unit distributes the processing tasks according to that allocation.

Cores communicate with memory interface to read from or write to various external memory devices. In one embodiment memory interface includes an interface adapted to communicate with local PP memory as well as a connection to host interface thereby enabling the cores to communicate with system memory or other memory that is not local to PPU . Memory interface can be of generally conventional design and a detailed description is omitted.

Cores can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local PP memories into internal on chip memory process the data and write result data back to system memory and or local PP memories where such data can be accessed by other system components including e.g. CPU or another parallel processing subsystem .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by instruction stream buffer via memory bridge and bus interacting with local PP memory which can be used as graphics memory including e.g. a conventional frame buffer instruction stream buffer texture maps and the like to store and update pixel data delivering pixel data to display device and the like. In some embodiments PP subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated PP memory device s or no dedicated PP memory device s .

In operation CPU is the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in that is specified by instruction stream buffer or and which may be located in system memory PP memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and executes commands asynchronously with operation of CPU .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of PPU to the rest of system may also be varied. In some embodiments PP system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

A PPU may be provided with any amount of local PP memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment in such embodiments little or no dedicated graphics PP memory is provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory e.g. via a bridge chip.

As noted above any number of PPUs can be included in a parallel processing subsystem. For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of the PPUs could be integrated into a bridge chip. The PPUs in a multi PPU system may be identical to or different from each other for instance different PPUs might have different numbers of cores different amounts of local PP memory and so on. Where multiple PPUs are present they may be operated in parallel to process data at higher throughput than is possible with a single PPU .

Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and so on.

In one embodiment each core includes an array of P e.g. 8 16 etc. parallel processing engines configured to receive SIMD instructions from a single instruction unit . Each processing engine advantageously includes an identical set of functional units e.g. arithmetic logic units etc. . The functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

Each processing engine uses space in a local register file LRF for storing its local input data intermediate results and the like. In one embodiment local register file is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each processing engine and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. In some embodiments each processing engine can only access LRF entries in the lane assigned to it. The total number of entries in local register file is advantageously large enough to support multiple concurrent threads per processing engine .

Each processing engine also has access to an on chip shared memory that is shared among all of the processing engines in core . Shared memory may be as large as desired and in some embodiments any processing engine can read to or write from any location in shared memory with equally low latency e.g. comparable to accessing local register file . In some embodiments shared memory is implemented as a shared register file in other embodiments shared memory can be implemented using shared cache memory.

In addition to shared memory some embodiments also provide additional on chip parameter memory and or cache s which may be implemented e.g. as a conventional RAM or cache. Parameter memory cache can be used e.g. to hold state parameters and or other data e.g. various constants that may be needed by multiple threads. Processing engines also have access via memory interface to off chip global memory which can include e.g. PP memory and or system memory with system memory being accessible by memory interface via host interface as described above. It is to be understood that any memory external to PPU may be used as global memory . Processing engines can be coupled to memory interface via an interconnect not explicitly shown that allows any processing engine to access global memory .

When core is configured to process multiple contexts each processing engine may be allocated to process one or more of the multiple contexts. State information for each context that a processing engine is allocated to process may be stored in local register file shared memory and or global memory to allow the processing engine to switch between contexts as needed to respond to an allocation change or a context whose processing is blocked. For example multiple contexts may be processed during multiple cycles with a single context selected for processing each cycle. In some embodiments of the invention each processing engine is configured to process a single context at a time. In those embodiments core processes multiple contexts simultaneously since each processing engine may be configured to process a different context. In other embodiments of the present invention processing engine is configured to process multiple contexts by maintaining active context state for more than one context.

In one embodiment each processing engine is multithreaded and can execute up to some number G e.g. 24 of threads concurrently e.g. by maintaining current state information associated with each thread in a different portion of its assigned lane in local register file . Processing engines are advantageously designed to switch rapidly from one thread to another so that instructions from different threads can be issued in any sequence without loss of efficiency. Since each thread may correspond to a different context multiple contexts may be processed over multiple cycles as different threads are issued for each cycle.

Instruction unit is configured such that for any given processing cycle an instruction INSTR is issued to each P processing engines . Each processing engine may receive a different instruction for any given processing cycle when multiple contexts are being processed simultaneously. When all P processing engines process a single context core implements a P way SIMD microarchitecture. Since each processing engine is also multithreaded supporting up to G threads concurrently core in this embodiment can have up to P G threads executing concurrently. For instance if P 16 and G 24 then core supports up to 384 concurrent threads for a single context or N 24 concurrent threads for each context where N is the number of processing engines allocated to the context.

Operation of core is advantageously controlled via a core interface . In some embodiments core interface receives data to be processed e.g. primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed from work distribution unit . Core interface can load data to be processed into shared memory and parameters into parameter memory . Core interface also initializes each new context in instruction unit then signals instruction unit to begin executing the context. When execution of a context is completed core advantageously notifies core interface . Core interface can then initiate other processes e.g. to retrieve output data from shared memory and or to prepare core for execution of additional contexts.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing engines may be included. In some embodiments each processing engine has its own local register file and the allocation of local register file entries per thread can be fixed or configurable as desired. In particular entries of local register file may be allocated for processing each context. Further while only one core is shown a PPU may include any number of cores which are advantageously of identical design to each other so that execution behavior does not depend on which core receives a particular processing task. Each core advantageously operates independently of other cores and has its own processing engines shared memory and so on.

In some embodiments multithreaded processing core of can execute general purpose computations using thread arrays. As used herein a thread array is a group consisting of a number n of threads that concurrently execute the same program on an input data set to produce an output data set for a context. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

In some embodiments the thread arrays are cooperative thread arrays or CTAs. As with other types of thread arrays a CTA is a group of multiple threads that concurrently execute the same program referred to herein as a CTA program on an input data set to produce an output data set for a context. In a CTA the threads can cooperate by sharing data with each other in a manner that depends on thread ID. For instance in a CTA data can be produced by one thread and consumed by another. In some embodiments synchronization instructions can be inserted into the CTA program code at points where data is to be shared to ensure that the data has actually been produced by the producing thread before the consuming thread attempts to access it. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program.

In some embodiments threads in a CTA share input data and or intermediate results with other threads in the same CTA using shared memory of . For example a CTA program might include an instruction to compute an address in shared memory to which particular data is to be written with the address being a function of thread ID. Each thread computes the function using its own thread ID and writes to the corresponding location. The address function is advantageously defined such that different threads write to different locations as long as the function is deterministic the location written to by any thread is predictable. The CTA program can also include an instruction to compute an address in shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA.

CTAs or other types of thread arrays are advantageously employed to perform computations that lend themselves to data parallel decomposition. As used herein a data parallel decomposition includes any situation in which a computational problem is solved by executing the same algorithm multiple times in parallel on input data to generate output data for instance one common instance of data parallel decomposition involves applying the same processing algorithm to different portions of an input data set in order to generate different portions an output data set. Examples of problems amenable to data parallel decomposition include matrix algebra linear and or nonlinear transforms in any number of dimensions e.g. Fast Fourier Transforms and various filtering algorithms including convolution filters in any number of dimensions separable filters in multiple dimensions and so on. The processing algorithm to be applied to each portion of the input data set is specified in the CTA program and each thread in a CTA executes the same CTA program on one portion of the input data set. A CTA program can implement algorithms using a wide range of mathematical and logical operations and the program can include conditional or branching execution paths and direct and or indirect memory access.

For example as is known in the art an array of data values e.g. pixels can be filtered using a 2 D kernel based filter algorithm in which the filtered value of each pixel is determined based on the pixel and its neighbors. In some instances the filter is separable and can be implemented by computing a first pass along the rows of the array to produce an intermediate array then computing a second pass along the columns of the intermediate array. In one CTA implementation of a separable 2 D filter the threads of the CTA load the input data set or a portion thereof into shared memory then synchronize. Each thread performs the row filter for one point of the data set and writes the intermediate result to shared memory . After all threads have written their row filter results to shared memory and have synchronized at that point each thread performs the column filter for one point of the data set. In the course of performing the column filter each thread reads the appropriate row filter results from shared memory and a thread may read row filter results that were written by any thread of the CTA. The threads write their column filter results to shared memory . The resulting data array can be stored to global memory or retained in shared memory for further processing. Where shared memory can be accessed with lower latency and or greater bandwidth than global memory storing intermediate results in shared memory advantageously improves processor throughput.

In one embodiment a driver program executing on CPU of writes commands defining the CTA to a pushbuffer not explicitly shown in memory e.g. system memory from which the commands are read by a PPU . The commands advantageously are associated with state parameters such as the number of threads in the CTA the location in global memory of an input data set to be processed using the CTA the location in global memory of the CTA program to be executed and the location in global memory where output data is to be written. The state parameters may be written to the pushbuffer together with the commands. In response to the commands core interface loads the state parameters into core e.g. into parameter memory then begins launching threads until the number of threads specified in the CTA parameters have been launched. In one embodiment core interface assigns thread IDs sequentially to threads as they are launched. More generally since all threads in a CTA execute the same program in the same core any thread can be assigned any thread ID as long as each valid thread ID is assigned to only one thread. Any unique identifier including but not limited to numeric identifiers can be used as a thread ID. In one embodiment if a CTA includes some number n of threads thread IDs are simply sequential one dimensional index values from 0 to n 1. In other embodiments multidimensional indexing schemes can be used. It should be noted that as long as data sharing is controlled by reference to thread IDs the particular assignment of threads to processing engines will not affect the result of the CTA execution. Thus a CTA program can be independent of the particular hardware on which it is to be executed.

Data assembler is a fixed function unit that collects vertex data for high order surfaces primitives and the like and outputs the vertex data to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in PP memory through memory interface for use in processing the vertex data.

Primitive assembler receives processed vertex data from vertex processing unit and constructs graphics primitives e.g. points lines triangles or the like for processing by geometry processing unit . Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. Geometry processing unit outputs the parameters and new graphics primitives to rasterizer . Geometry processing unit may read data that is stored in PP memory through memory interface for use in processing the geometry data.

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read data that is stored in PP memory through memory interface for use in processing the fragment data. Memory interface produces read requests for data stored in graphics memory decompresses any compressed data and performs texture filtering operations e.g. bilinear trilinear anisotropic and the like. Raster operations unit is a fixed function unit that optionally performs near and far plane clipping and raster operations such as stencil z test and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory for display on display device .

In a conventional system in order to switch contexts each processing unit a graphics processing pipeline is idled and a new context is loaded. Alternatively if the current context would take too long to execute and reach an idle point an active context switch may be performed by unloading the active context and loading the new context. Since the active context state is larger than the idle context state time needed to switch contexts is longer but it isn t necessary to reach an idle point. In either case the number of clock cycles needed to perform the context switch negatively impacts the interactivity of an application program that uses the graphics processing capability.

In contrast core is capable to processing more than a single context simultaneously. Specifically for each graphics processing unit e.g. data assembler vertex processing unit primitive assembler geometry processing unit rasterizer fragment processing unit and raster operations unit core may be configured to process more than a single context by maintaining an active context for more than one context. However since the active context can be quite large each processing unit may process a disparate number of contexts simultaneously.

Context routing is used to route program instructions and input data for a particular context to the context processing element that is allocated to process the particular context. When multiple context processing units are configured in a pipeline that includes stages of multiple context processing unit with equal number of context processing elements each context processing element may output program instructions and data directly to another context processing element and context routing may be omitted.

In contrast context processing elements maintain one or more active contexts within each context processing element . Therefore context processing elements require more storage circuitry at each pipeline state and are therefore larger in terms of die area compared with context processing elements . The advantage of context processing elements is that context switches can be performed quickly even in a single clock cycle.

Context processing element performs a context switch by unloading the active context state to context storage and loading the new context state from context storage . Each context processing element has a dedicated context storage and the number of clock cycles needed to unload and load context state to from a context processing element depends on the amount of active state that is maintained within the context processing element and the interface bandwidth between context processing element and context storage .

Context routing is used to route program instructions and input data for a particular context to the context processing element that is allocated to process the particular context. When multiple context processing units are configured in a pipeline each context processing element may output program instructions and data directly to another context processing element and context routing may be omitted.

In some embodiments of the present invention each context processing element or is constrained to access particular memory devices of graphics memory. This constraint is advantageous in terms of minimizing access latency and wiring for the available memory bandwidth but reduces the flexibility for allocating context processing elements or to process any of the multiple contexts. For example when a context processing element or configured to perform the functions of raster operations unit each context processing element or is coupled to a particular portion of the memory interface to facilitate high bandwidth read and write transfers to from graphics memory. However each context may need to access any portion of the graphics memory. Therefore each context processing element or needs to store all N multiple contexts.

In other embodiments of the present invention other special resources can impose similar constraints on the allocation of context processing elements or to process any of the multiple contexts. In either case each context processing elements or can each be configured to process all N multiple contexts in order to provide processing throughput for contexts that are mapped to a particular portion of graphics memory. Alternatively a particular portion of memory needed by a context may be moved in graphics memory to correspond to the context processing element or that is allocated to the context.

When an embodiment of the present invention allows for the portions of memory to be changed it is possible to limit the number of contexts that each context processing element or is configured to process and process the multiple contexts simultaneously. For example when each context processing element or is configured to process up to two contexts a first context is mapped to 8 context processing elements or a second context is mapped to 4 of the 8 context processing elements or a third context is mapped to 2 of the remaining 4 of the 8 context processing elements or and a fourth context is mapped to the remaining 2 of the 8 context processing elements or . Therefore five contexts are processed in parallel when each one of context processing elements or is configured to only support up to two contexts.

In step multiple context processing unit determines if the new context is an active context meaning that multiple context processing unit is already configured to process data for the new context without needing to unload and load a context. Since each context processing element may be configured to process a different context the new context may be an active context in at least one context processing element .

If in step multiple context processing unit determines that the new context is an active context then multiple context processing unit proceeds directly to step and continue processing received data using the active context. If in step multiple context processing unit determines that the new context is not an active context then in step multiple context processing unit unloads the active context state from one or more processing elements depending on which multiple context processing unit is allocated to process the new context. The active context state is stored in context storage . In some embodiments of the present invention particularly those embodiments in which context processing element is not a deep pipeline context processing element is drained or partially drained to minimize the amount of active context state that is unloaded.

In step multiple context processing unit loads the new context state from context storage into the one or more context processing elements that are allocated to process the new context. In step multiple context processing unit continues processing data using the new active state.

In some embodiments of the present invention multiple context processing units and are configured to switch contexts when the active context is blocked i.e. cannot proceed with processing data. The active context may be blocked due to a resource contention or while waiting for completion of a memory read request such as a texture map read. In some cases during graphics processing it is possible to saturate the processing throughput of one processing engine such as a core or host interface configured to perform the functions of data assembler vertex processing unit primitive assembler geometry processing unit rasterizer fragment processing unit raster operations unit of and have another processing engine operate below capacity. For example depending on the graphics primitives being rendered for a context a setup engine primitive assembler generates plane equations which saturate the capacity of a downstream fragment processing unit . At a later point in time during processing of the same context the setup engine may be saturated while the downstream fragment processing unit is underutilized.

Conventionally a context executes until a program is completed avoiding any need to perform a context switch. In order to optimize processing throughput multiple context processing unit or may use a virtual channel technique to context switch to a new context when the active context is blocked and unable to execute thereby increasing processing throughput. The concept of virtual channel is known to those skilled in the art of ATM asynchronous transfer mode networking and is used to improve processing throughput for a device that accepts requests from multiple sources. If a request becomes blocked so that the device cannot immediately complete the associated transaction the device waits idle and the other sources wait idle even though they might be able to be processed. In networking virtual channels allows one of the other sources to be bypass the blocked source and be processed.

When the virtual channel technique is used in the present invention an underutilized setup engine can context switch to a different context preferably a context that is setup performance limited rather than fragment processing limited while the fragment processing engine is saturated. Switching between two different contexts using the virtual channel technique improves overall processing throughput. Virtual channels can be used without or without allocations of processing elements to contexts.

The ability to simultaneously process multiple contexts increases processing throughput by distributing processing between different contexts. For example when a graphics processor such as parallel processing subsystem of configured for processing graphics data runs most efficiently with 30 000 parallel threads during a single clock cycle multiple contexts can be processed in parallel to achieve greater processing throughput compared with running a single context. Specifically if a first context requires only 15 000 threads the full processing throughput of parallel processing subsystem is achieved by also processing a second context that uses the remaining 15 000 threads each clock cycle. The processing throughput for each context is doubled since 30 000 threads are executed each clock cycle for each context instead of 15 000 threads each clock cycle when the contexts are processed serially.

Furthermore supporting simultaneously processing of multiple contexts is needed when a context requires a long time to execute. In particular if the context requires a long time to execute an operating system may conclude that parallel processing subsystem is idle and initiate a sleep or power saving mode and disable the power supply to parallel processing subsystem . In some cases the operating system may determine that an unrecoverable error has occurred when a context requires too long to execute on parallel processing subsystem . Allocating a small portion of the processing throughput to process a second context can eliminate problems caused by a single context running for too long. For some applications the allocation of processing throughput to contexts is static having been determined by the application developer. In some embodiments of the invention particularly console systems device driver is omitted and the static allocation is used. Other applications benefit from dynamic load balancing relying on device driver to monitor and change the allocations for each context to improve processing throughput. In some embodiments of the present invention the monitoring of processing throughput and allocation adjustment is performed within parallel processing subsystem .

In step the contexts are executed for a number of clock cycles over which time performance data is measured to determine the number of clock cycles that each context is blocked from execution including the clock cycles when another context was executing using a shared processing slice. In step device driver or parallel processing subsystem determines if the processing slice allocation needs to be rebalanced based on the performance data. For example when one context is blocked by a specified amount more than a context with the least number of blocked clock cycles the slice allocation needs to be rebalanced. Other methods for determining when rebalancing is needed may also be employed.

If in step the method determines that rebalancing is not needed then the method returns to step and the contexts are executed with the current slice allocation. Otherwise in step the context with the greatest number of blocked clock cycles is allocated an additional processing slice and the context with the least number of blocked clock cycles is allocated one less processing slice. The method then returns to step and the contexts are executed with the rebalanced slice allocation. Steps and are repeated to dynamically allocate the processing slices in order to improve the processing throughput of parallel processing subsystem .

Multiple context processing units and within a parallel processing subsystem are capable of processing multiple contexts simultaneously reducing the need to perform time consuming context switches compared with processing a single context at a time. Context processing elements and may be configured to perform the functions of graphics processing pipeline and support all of the multiple contexts or only a portion of the multiple contexts. Each context processing element and may be allocated to process a particular context or a portion of the multiple contexts in order to simultaneously process more than one context. The allocation of processing elements to the multiple contexts may be determined dynamically in order to improve graphics processing throughput.

In addition to cores parallel processing unit includes context state management units that are each configured to maintain state for all of the active contexts. Therefore context state management unit is similar to previously described context processing element see . Cores are configured to maintain state for less than all of the active contexts and to save and restore state as needed to switch contexts. Therefore cores are similar to previously described context processing element and see . A memory interface performs the functions of memory interface interfacing between PP memory and cores and context state management units .

Context storage is configured to store context information active and non active for host interface and front end method decoder . For example context storage unit may contain shadowed application level state which is maintained for downstream units since front end method decoder may expand input methods depending on the state of the current context or alternatively front end method decoder may excise input methods which set state redundantly. Front end method decoder may be configured to switch from processing a current context to a new context when a page fault event occurs that prevents the current context from processing. Front end method decoder is also configured to generate sync tokens as needed to switch contexts when screen space memory mapping is used as described in conjunction with . Other events may cause front end method decoder to switch from processing one context to another. For example a time slice allocated for one context may have expired a higher priority context may be started or the like.

Front end method decoder responds to a context switch caused by any event by providing the new context to available context state management units via work distribution unit . The core process resources are redistributed to migrate the old context to fewer cores freeing the remaining cores to process the new context. The available context state management units are able to start processing the new context without storing the old context and restoring the new context since context state management unit are configured to maintain state for multiple contexts.

If in step front end method decoder determines that the old context is being processed on one or more cores then in step front end method decoder rebalances the contexts by migrating work for the old context to fewer cores freeing one or more cores to process the new context. Each core that switches from processing the old context to the new context will store the old context and restore the new context before accepting instructions for the new context. Because context state management units maintain all of the active contexts those units may begin processing the new context without delay.

Cores may switch contexts by storing the old context state for each pipeline state. The pipeline state can be scanned out using a scan chain that also is used to test the core . A core may complete queued processing of the old context and begin processing the new context after the core is drained. In other embodiments of the present invention cores store the old context state in a context storage or as described in conjunction with .

In step front end method decoder accepts method for the new context. In step front end method decoder outputs the new context work to available cores and returns to step . As other cores become available front end method decoder outputs new context work to those cores until all cores are processing the new context or unit a context change event occurs.

Advantages of transitioning cores to switch contexts are that a new context can run on a portion of cores while the old context continues processing any queued program instructions and data. When a first core has a page fault and processing of a first context is delayed other cores can be switched to processing of a second context as they complete processing of the first context without necessitating a storing of the first context state of the first core . The first core can resume processing when the page fault is resolved. Another advantage is that a high priority context can be processing by context state management units without storing and restoring context state while cores become available for processing the high priority context. Furthermore a long running context will not completely starve all of the contexts since the long running context can be allocated a portion of the context state management units and cores . Other active contexts can be allocated a remainder of the context state management units and cores . Therefore the long running context does not need to be killed after a pre defined time limit to allow the processing of other contexts.

Graphics primitives and pixels are mapped to cores and context state management units to encourage texture locality and so that cores and context state management units only need to process data using a fixed subset of the screen coordinates. The mapping of cores and context state management units to screen space coordinates is the screen space mapping. The screen space mapping may be changed without requiring any surfaces storing pixel data to be relocated in PP memory since the screen space coordinate to physical memory address mapping memory mapping is a separate translation.

Data stored in graphics memory may be interleaved across different memory banks to improve memory access efficiency. A physical address space is defined to address memory locations in DRAMs that are used to store graphics surfaces. The address space is divided into sets of sequential addresses that are each mapped to a single DRAM device or a pair of DRAM devices producing an address space interleaved across multiple DRAMs which each correspond to different sets of sequential addresses. The interleaving specified by the screen space mapping between a screen space addressing e.g. x y and z coordinates that is used by cores and context state management units and the screen space mapping may vary for each context.

In some embodiments of the present invention each context state management unit is memory mapped meaning that it is constrained to access particular memory devices e.g. DRAMs of graphics memory. This constraint is advantageous in terms of minimizing access latency and wiring for the available memory bandwidth but reduces the flexibility for allocating context state management units to process any of the multiple contexts. In particular when a context state management unit configured to perform the functions of raster operations unit or reading texture data each context state management unit is coupled to a particular portion of the memory interface to facilitate high bandwidth read and write transfers to from graphics memory. Therefore each context state management unit is configured to perform screen space to physical memory address translation and that translation may vary for each context.

The memory mapping translation uses on the base address of the surface the memory interleave specified for the surface or context the pixel size and the x y pixel coordinates. It is advantageous to avoid reallocating context state management units that are configured to performing memory mapping translations since surface data stored in memory locations accessible by one context state management unit may need to be relocated to be accessible by another context state management unit when a reallocation occurs. In embodiments of the present invention that allow for memory mapped processing engines to be reallocated requiring a change in memory mapping translations a subset of the contexts may be supported and the surfaces that are affected by the change in memory mapping are relocated in PP memory .

Compressed zcull data for a portion of the screen is stored in a buffer within each context state management unit that is configured to perform zcull processing culling pixels or primitive based on a z depth test . Before the screen space mapping is changed to switch contexts the compressed zcull data stored in the buffer is saved to memory.

A synchronization token is used to cause all of the threads executing within a core to execute the instruction preceding the synchronization token and wait until all of the other threads have also reached the synchronization token. When all of the threads are synchronized the context state may be stored. Note that synchronizing the threads is not the same as draining core since the thread state is present in the pipeline registers of core . The sync token includes the mapping information that is needed to configure cores and context state management units for processing the new context. The details of how the sync token is processed by core are described in conjunction with .

In step front end method decoder outputs screen space mapping information for the new context to configure any cores that will process the new context. The screen space mapping information specifies how screen space coordinates are mapped to cores and context state management units . Steps and are completed as previously described in conjunction with .

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

