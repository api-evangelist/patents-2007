---

title: Single stream processing with multi-version support of application operating environments
abstract: A method is provided for developing a software module including support for multiple versions of an operating environment. The method includes determining a first set of references associated with a first version of an application operating environment. A second set of references associate with a second version of the computing environment is determined. A first class loader is associated with the first version of the computing environment. A second class loader is associated with the second version of the computing environment. The method also includes encapsulating the first set of references, the second set of references, the first class loader, and the second class loader in a software module, wherein the second set of references are obscured from the first class loader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037467&OS=08037467&RS=08037467
owner: International Business Machines Corporation
number: 08037467
owner_city: Armonk
owner_country: US
publication_date: 20071026
---
The present invention generally relates to the field of application operating environments and more particularly relates to providing single stream processing of an application tool with multi version support of application operating environments.

Java technology is both a high level object oriented programming language and a platform. As with most technologies newer versions of the Java platform are periodically released. Ideally software vendors try to develop applications or tools that require the lowest level of Java as possible to ensure that a broad range of customers can use their products. However one problem experienced by software vendors who develop applications is that applications developed for an earlier version of Java are not generally compatible with new versions of Java. The following is an example of this problem discussed with respect to a Java Database Connectivity JDBC driver.

A certain minimum level of Java Runtime Environment JRE is always required for a specific version of Java Database Connectivity JDBC specification. For example the prerequisite level for JDBC 2 is JRE 1.2 for JDBC 3 is JRE 1.4 and for the latest JDBC 4 is JRE 6.0. In order to support a specific version of JDBC specification a seemingly straightforward solution is to always require a database driver to run with the prerequisite level of Java system. For example Microsoft s SQL Server 2005 JDBC Driver is JDBC 3 compliant and runs on the JRE 1.4 and later versions. In addition to standard JDBC functionalities a number of database drivers also include vendor specific features most of which do not depend on the underlying level of Java system. Moreover from the customers perspective many of them do not like to move to a new level of Java system too fast for stability reason. Furthermore vendors who develop applications based on database drivers also prefer a low prerequisite level of Java system for easy adoptability of their products. However the previous solution forces the minimum level of Java system for the database driver to be the same as that for the highest supported JDBC specification.

Many database driver vendors thus adopt an alternative solution which spins off a new stream for support of each JDBC specification with a different prerequisite level of Java system. For example Sybase provides a stream conn2.jar for JDBC 2 support on JRE 1.2 and a stream conn3.jar for JDBC 3 support on JRE 1.4. Oracle provides a stream classes12.zip for JDBC 2 support on JRE 1.2 and a stream ojdbc14.jar for JDBC 3 support on JRE 1.4. However one of the major drawbacks for this solution is that code is duplicated all over the place among separate streams. Besides each additional stream means additional development service and testing effort. This is why some database driver vendors use a third solution which splits new classes for new JDBC support to avoid dual stream process.

The classes are compiled under different prerequisite levels of Java systems and then bundled together at the end. For example Cloudscape has a set of major classes for JDBC 3 and another set of major classes for JDBC 4. JDBC 3 specific classes are compiled using JRE 1.4 and JDBC 4 specific classes are compiled using JRE 6.0. At the end all of these classes are bundled in one Java Archive JAR file. However the JAR file with byte code compiled under different Java systems is still inadequate and insufficient under certain circumstances. This mixed byte code solution is not compatible under an IDE such as Eclipse because of the multiple Java system build requirement. In addition it may work for support of one connectivity type with a single inheritance hierarchy but it does not fit well for support of multiple connectivity types which most major database vendors have due to the fact that Java system does not support multiple inheritance hierarchy.

Briefly in accordance with the present invention disclosed is a method for developing a software module comprising support for multiple versions of an operating environment. The method includes determining a first set of references associated with a first version of an application operating environment. A second set of references associate with a second version of the computing environment is determined. A first class loader is associated with the first version of the computing environment. A second class loader is associated with the second version of the computing environment. Encapsulating the first set of references the second set of references the first class loader and the second class loader in a software module wherein the second set of references are obscured from the first class loader.

In another embodiment a method of providing multi version operating environment support for a software module is disclosed. The method includes determining a current version of an application operating environment. The method also includes determining that a software module to be executed within the application operating environment is executable under at least a first and second versions of the application operating environment. A set of references is selected from a plurality of references associated with the at least first and second versions of the application operating environment. The set of references are associated with the current version of the application operating environment. Executing the software module in the current version of the operating environment through a single code path associated with the at least first and second versions of the application operating environment in response to the selecting.

In yet another embodiment an information processing system for providing multi version operating environment support for a software module is disclosed. The information processing system includes a memory and a processor that is communicatively coupled to the memory. The information processing system also includes an application operating environment for executing an application. The application operating environment includes at least a version coordination manager. The version coordination manager is adapted to determining a current version of an application operating environment. The method also includes determining that a software module to be executed within the application operating environment is executable under at least a first and second versions of the application operating environment. A set of references is selected from a plurality of references associated with the at least first and second versions of the application operating environment. The set of references are associated with the current version of the application operating environment. Executing the software module in the current version of the operating environment through a single code path associated with the at least first and second versions of the application operating environment in response to the selecting.

One advantage of the present invention is a software module such as a Java Archive JAR file can include references to an up level application operating environment such as JRE. These references are provided within the software module so that they are hidden to a down level class loader. The techniques of one embodiment of the present invention make possible a single stream process for a tool such as a database driver or an application to support non standard features at a down level application operating environment while supporting standard functionalities at the prerequisite level version of the application operating environment.

Another advantage is that one embodiment of the present invention does not require the minimum level of the application operating environment for the tool or application to be the same as that for the highest supported application operating environment specification. This can facilitate adoption of the tool or application for customers and other application vendors. In addition one embodiment of the present invention not only avoids dual stream process with duplicate code and duplicate effort but also avoids mixed byte code software files which is still inadequate and insufficient under certain circumstances .

In the illustrated embodiment the computing environment is a distributed system in a symmetric multiprocessing SMP computing environment. The computing environment includes processing nodes coupled to one another via network adapters and . Each processing node is an independent computer with its own operating system image channel controller memory and processor s on a system memory bus . A system input output bus couples I O adapters and network adapter . Although only one processor is shown in each processing node each processing node is capable of having more than one processor. Each network adapter is linked together via a network switch . In some embodiments the various processing nodes are part of a processing cluster.

It should be noted that throughout the following discussion the Java system and the Java Runtime Environment JRE are used as one example of an Application Operating Environment AOE applicable to the present invention. Any cross platform AOE that is system operating system independent is applicable to the present invention.

Java technology is both a high level object oriented programming language and a platform. Java technology is based on the concept of a single Java Virtual Machine JVM which is a translator between the language and the underlying software and hardware. All implementations of the programming language must emulate the JVM enabling Java programs to run on any system that has a version of the JVM. The Java programming language is unusual because Java programs are both compiled translated into an intermediate language called Java bytecode and interpreted bytecode parsed and run by the JVM . Compilation occurs once and interpretation happens each time the program runs. Compiled bytecode is a form of optimized machine code for the JVM the interpreter is an implementation of the JVM.

The Java platform is a software only platform that runs on top of various hardware based platforms. The Java platform comprises of the JVM and the Java Application Programming Interface API a large collection of ready made software components classes that ease the development and deployment of applets and applications including robust secure and interoperable enterprise applications. It spans everything from basic objects to networking and security and XML generation and Web services. The Java API is grouped into libraries of related classes and interfaces the libraries are known as packages.

As discussed above in one embodiment of the present invention the code base of a software module includes references such as but not limited to classes and methods associated with an up level AOE in a way in which the code base remains compilable and runnable under a down level AOE. For example a software module can be a Java Archive JAR file comprising a Java Database Connectivity JDBC driver. To support the JDBC 4 specification the database driver needs to include references to JDBC 4 classes of JRE 6.0 an up level AOE . In one embodiment of the present invention the database driver remains compilable under JRE 5.0 a down level AOE and most importantly runnable under JRE 5.0. As a result the database driver can run under JRE 5.0 for non JDBC 4 features. At the mean time the database driver runs under JRE 6.0 for standard JDBC 4 functionalities and obviously non JDBC 4 features .

In one embodiment a version switch module class split module instantiation delegation module and upcast return module can be used alone and or in combination with one another to provide a single code path that the software module can execute through across multiple versions of the AOE. These modules in one embodiment are included within a software development environment tool for enabling the software module to include references to an up level AOE in a way in which the code base remains compilable and runnable under a down level AOE. In another embodiment these modules can be self sustaining modules that reside within the software module for dynamically adjusting the execution of the software module for compatibility across multiple versions of the AOE.

Using JRE 5.0 as an example of a down level AOE and JRE 6.0 as an example of an up level AOE a database driver can be developed to be compiled under JRE 5.0 as long as new classes in JRE 6.0 are included in the compilation class path and the necessary abstract methods are implemented in subclasses. However making the database driver runnable under JRE 5.0 while access to JDBC 4 classes of JRE 6.0 is included in the database driver can be a difficult task. The first challenge is that direct references to JDBC 4 classes are not allowed in any code path invoked under JRE 5.0. For example the following code does not work because the invocation of setObject under JRE 5.0 comes across java.sql.SQLXML.

Therefore the version switch module of the present invention can be implemented to divert the code path to access the appropriate class based on the running version of JRE. In the current example the version switch module when utilized can generate the following code.

As can be seen in the above example the above code first checks the running JRE version. If JRE 6.0 is not running a direct reference to JRE 6.0 classes i.e. java.sql.SQLXML is not made. Also if JRE 6.0 is not running the code checks if the parameter passed in Object x is an instance of a proprietary class ProprietaryXML. IF this is true the corresponding method is invoked. Otherwise if JRE 6.0 is running the code checks if the parameter passed in Object x is an instance of the new JDBC 4 class java.sql.SQLXML and invokes the corresponding method.

However for the same reason that direct references to JDBC 4 classes are not allowed a proprietary class which is an extension to one or more standard APIs provide by vendors to access vendor specific features that is previously supported and now standardized in JDBC 4 cannot directly inherit from JDBC 4 classes. For example a proprietary ProprietaryXml class is still required to be returned under JRE 5.0 and thus cannot directly implement the standard java.sql.SQLXML class. Therefore the following code does not work 

In this situation where a proprietary class that is previously supported and now standardized in the upper level AOR the version switch module is not suitable. Therefore class split module can be implemented. The class split module returns the proprietary class which does not inherit from a JDBC 4 class under JRE 5.0 but a JDBC 4 class under JRE 6.0. The class split module returns the proprietary non JDBC 4 class only under JRE 5.0. A new class JDBC4Xml which is a subclass of both the standard java.sql.SQLXML and the proprietary ProprietaryXml is then returned under JRE 6.0. For example the following code shows the class hierarchy for the new JDBC 4 class JDBC4X which inherits from the proprietary class ProprietaryXml and implements the new standard JDBC 4 class java.sql.SQLXML.

In the current example there instantiation of JDBC 4 classes are not allowed in any existing classes loaded under JRE 5.0. For example the following code will not work if loaded under JRE 5.0 because the JDBC 4 subclass JDBC4Xml is instantiated inside Connection.

Therefore the instantiation delegation module can be implemented. The instantiation delegation module delegates the instantiation to another factory class away from existing classes. For example the following code shows that instead of creating a new instance of the JDBC 4 subclass JDBC4XML directly in Connection the instantiation is redirected to another class JDBC4Factory.

The code in the above example has one more compatibility issue. In any existing classes loaded under JRE 5.0 it is not allowed to return data from methods that return JDBC 4 classes. Therefore the above code still does not work if invoked by Connection under JRE 5.0 because JDBC4Factory.createXml returns the JDBC 4 subclass JDBC4Xml. To resolve this issue the upcast return module can be implemented. The upcast return module upcasts the return type in a new version class to the most generic type in the declaration and then downcasts the return type to the specific method during invocation. This is shown in the following code segment 

As shown in the above code segment the return type of createXml in JDBC4Factory is first upcast to the most generic type Object in the declaration and then downcast to the specific java.sql.SQLXML type during invocation.

In addition JDBC 4 exceptions are not allowed to be thrown in any existing classes loaded under JRE 5.0. For example the following code does not work if loaded under JRE 5.0 because setClientInfo throws a JDBC 4 SQLClientInfoException in Connection.

Therefore in one embodiment of the present invention a combination of two or more of the version switch module class split module instantiation delegation module and upcast module can be used to resolve this issue. In the current example a combination of the version switch class split and instantiation delegation modules are used to overcome the problem of setClientInfo throwing a JDBC 4 SQLClientInfoException in Connection as follows 

The above code segment shows that JDBC4Connection is split from Connection to contain method setClientInfo which throws a JDBC 4 SQLClientInfoException. Then instantiation of JDBC4Connection is delegated to JDBC4Factory away from Connection when loaded under JRE 5.0. Finally an appropriate class is created from createConnection in Connection based on the running version of JRE.

As can be seen from the above discussion the version switch module class split module instantiation delegation module and upcast return module enable a software module such as a database driver implemented with new versions classes methods such as JDBC 4 support to be compiled under an older version of an AOE such as JRE 5.0 and to be run under both the older version AOE such as JRE 5.0 and the newer version AOE such as JRE 6.0. Therefore one embodiment of the present invention avoids dual stream processing with duplicate development service and testing effort. Another advantage of the present invention is that mixed byte code software modules e.g. JAR files which are inadequate and insufficient for supporting multiple connectivity types are avoided.

The information processing system includes a computer . The computer has a processor that is connected to a main memory mass storage interface terminal interface and network adapter hardware . A system bus interconnects these system components. The mass storage interface is used to connect mass storage devices such as data storage device to the information processing system . One specific type of data storage device is a computer readable medium such as a floppy disk drive which may be used to store data to and read data from a CD 318 or a floppy diskette not shown . Another type of data storage device is a data storage device configured to support for example NTFS type file system operations.

The main memory in one embodiment comprises the software development environment tool and or an AOE . The software development environment enables a user or automated program to develop software modules for operation within the AOE In one embodiment the software modules are developed using one or more of the version switch module class split module instantiation delegation module and upcast return module so that they can execute and perform across multiple versions of the AOE . The function of each of the version switch module class split module instantiation delegation module and upcast return module has been discussed in greater detail above.

Although illustrated as concurrently resident in the main memory it is clear that respective components of the main memory are not required to be completely resident in the main memory at all times or even at the same time. In one embodiment the information processing system utilizes conventional virtual addressing mechanisms to allow programs to behave as if they have access to a large single storage entity referred to herein as a computer system memory instead of access to multiple smaller storage entities such as the main memory and data storage device . Note that the term computer system memory is used herein to generically refer to the entire virtual memory of the information processing system .

Although only one CPU is illustrated for computer computer systems with multiple CPUs can be used equally effectively. Various embodiments of the present invention further incorporate interfaces that each includes separate fully programmed microprocessors that are used to off load processing from the CPU . Terminal interface is used to directly connect one or more terminals to computer to provide a user interface to the computer . These terminals which are able to be non intelligent or fully programmable workstations are used to allow system administrators and users to communicate with the information processing system . The terminal is also able to consist of user interface and peripheral devices that are connected to computer and controlled by terminal interface hardware included in the terminal I F that includes video adapters and interfaces for keyboards pointing devices and other devices interfaces.

An operating system not shown included in the main memory is a suitable multitasking operating system such as the Linux UNIX Windows XP and Windows Server 2001 operating system. Various embodiments of the present invention are able to use any other suitable operating system. Some embodiments of the present invention utilize architectures such as an object oriented framework mechanism that allows instructions of the components of operating system not shown to be executed on any processor located within the information processing system . The network adapter hardware is used to provide an interface to a network . Various embodiments of the present invention are able to be adapted to work with any data communications connections including present day analog and or digital techniques or via a future networking mechanism.

Although the example embodiments of the present invention are described in the context of a fully functional computer system those of ordinary skill in the art will appreciate that various embodiments are capable of being distributed as a program product via CD or DVD e.g. CD 318 CD ROM or other form of recordable media or via any type of electronic transmission mechanism.

Example Process for Providing a Software Module with a Single Stream Process Comprising Multi Version Support of an Application Operating Environment

The version coordination manager at step determines if a code path is invoking system classes and or methods for a newer version of JRE. If the result of this determination is positive the version coordination manager at step implements the version switch module . The version switch module at step diverts the code path so that it accesses the appropriate class based on the running version of the JRE. The control flows to step . If the result of the determination is negative the version coordination manager at step determines if a previously supported proprietary class that is now standardized in the newer version of the JRE needs to be implemented. If the result of this determination is positive the version coordination manager at step implements the class split module . The class split module at step returns the proprietary class under the older version of JRE and returns a new class that is a subclass of both the standardized class and the proprietary class under the newer versions of the JRE.

The control flows to step . The version coordination manager at step determines if classes form the newer version JRE need to be instantiated. If the result of this determination is positive the version coordination manager at step implements the instantiation delegation module . The instantiation delegation module at step creates a new factory class for instantiating the classes from the newer version JRE. The control flows to step . If the result of this determination is negative the version coordination manager at step determines if any data needs to be returned from methods that return classes from the newer version of the JRE. If the result of this determination is positive the version coordination manager at step implements the upcast return module .

The upcast return module at step upcasts the return type in the new version class to the most generic type in the declaration. The upcast return module then downcasts the return type to the specific method during invocation. The control flows to step . If the result of this determination is negative the version coordination manager at step determines if a potential new version JRE exception can occur in any existing classes loaded in the older version of the JRE. If the result of this determination is negative the control flow exits at step . If the result of this determination is positive the version coordination manager at step implements two or more of the version switch module class split module instantiation delegation module and upcast return module . The control flow then exits at step .

The present invention can be realized in hardware software or a combination of hardware and software. A system according to one embodiment of the present invention can be realized in a centralized fashion in one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that when being loaded and executed controls the computer system such that it carries out the methods described herein.

In general the routines executed to implement the embodiments of the present invention whether implemented as part of an operating system or a specific application component program module object or sequence of instructions may be referred to herein as a program. The computer program typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described herein may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

Although specific embodiments of the invention have been disclosed those having ordinary skill in the art will understand that changes can be made to the specific embodiments without departing from the spirit and scope of the invention. The scope of the invention is not to be restricted therefore to the specific embodiments and it is intended that the appended claims cover any and all such applications modifications and embodiments within the scope of the present invention.

