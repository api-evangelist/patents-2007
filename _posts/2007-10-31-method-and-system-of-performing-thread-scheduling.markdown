---

title: Method and system of performing thread scheduling
abstract: A method and system of performing thread scheduling. At least some of the illustrative embodiments are computer-readable mediums storing a program that, when executed by a processor of a host system, causes the processor to instantiate a CPU object that represents a processor abstraction, create a CPU context object that represents a thread abstraction (wherein the CPU context object is associated to a method, and wherein the CPU context object is mapped onto the CPU object), and execute the method within the CPU object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08336031&OS=08336031&RS=08336031
owner: Texas Instruments Incorporated
number: 08336031
owner_city: Dallas
owner_country: US
publication_date: 20071031
---
The present application claims priority to EP Application No. 07291167.0 filed on Sep. 28 2007 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation based on a plurality of bytecodes that define specific actions. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly. Many times a processor that directly executes Java bytecodes is paired with a general purpose processor to accelerate Java program execution.

Moreover threads may be used to concurrently perform different tasks within the same processor. A thread may be generically defined as an independent flow of control or stream of execution within an executing application. A thread may comprise a context e.g. a program counter and a register set and an instruction sequence that can be executed independently of other instruction sequences. The Java programming language specification provides a thread API java.lang.thread that may be used to implement multiple threads of execution within a Java program and imposes a minimum priority based thread scheduling policy on implementations of the Java Virtual Machine JVM . In many JVM implementations Java threads are implemented on the native threading model of a non Java operating system and the scheduler of the operating system controls the scheduling of the Java threads.

A method and system of performing thread scheduling. At least some of the illustrative embodiments are a computer readable medium storing a program that when executed by a processor of a host system causes the processor to instantiate a CPU object that represents a processor abstraction create a CPU context object that represents a thread abstraction wherein the CPU context object is associated to a method and wherein the CPU context object is mapped onto the CPU object and execute the method within the CPU object.

Other illustrative embodiments are computer systems comprising a processor that executes bytecodes and a memory coupled to the processor. The processor instantiates a CPU object that represents a processor abstraction. The processor creates CPU context object that represents a thread abstraction wherein the CPU context object is associated to a method and wherein the CPU context object is mapped onto the CPU object . The processor executes the method within the CPU object.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

Optional processor may be referred to as a Micro Processor Unit MPU . System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise an Application Programming Interface API implementation and a Java Virtual Processor JVP discussed more below . The API is compliant with the JVM specification and with the Java language specification. The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

The MPU also may execute non Java instructions. For example the MPU may host an operating system O S which performs various functions such as system memory management system task management and most or all other native tasks running on the system and management of the display . Java code executed on the JVP may be used to perform any one of a variety of applications such as multimedia games or web based applications in the system while non Java code which may comprise the O S and other native applications may run on the MPU .

As discussed above the JVP provides a layer of abstraction. In particular the JVP is a virtual hardware platform that is compatible with any Java API any real hardware software platform that may comprise a JSM processor or any JVM implementation. In some exemplary embodiments the JVP comprises a JEK core that has an execution engine a memory management component and a compiler. The execution engine may comprise a Bytecode engine a class loader a notification manager and an external method interface. The memory management component may comprise a memory allocator an object mapper for physically constrained objects a garbage collector a memory defragmentor and a swapper. The compiler may comprise a dynamic compiler and provide code buffer management. The JEK core may also comprise firmware to facilitate the execution of Java Bytecodes on the JSM processor.

The JVP also provides the API with methods to create software class loaders. A class loader loads classes used by an application at runtime. Other hardware components of the hardware platform or software components are virtualized within the JEK as Java Virtual Devices JVD that communicate with the JEK core. Each JVD comprises some combination of fields methods and notifications. The fields may comprise standard Java fields or may be mapped to a predefined or constrained physical memory space wherein the constraint may be due to hardware or software. The fields may also comprise a map to indirect memories. The methods may comprise bytecodes JSM native code hardware instructions or may use any kind of native interface such as a Java Native Interface JNI or a KVM Native Interface KNI . The notifications may be initiated by an event for example a hardware interrupt or from software. Additionally the JEK core manages native interface links and the notification mechanism provides a way to implement flexible monitoring.

Threads may be used to give the appearance of concurrently performing different tasks within the same processor such as the JVP or within a plurality of abstracted processors discussed below . A thread may be defined as an independent flow of control or stream of execution within an executing application. A thread comprises a context e.g. a program counter and a register set and an instruction sequence that is executed independently of other instruction sequences. Java threads may be abstracted on a single processor and context switching may be accomplished via APIs. However in some embodiments Java threads may be abstracted for execution within a plurality of abstracted processors and the context switching may be accomplished by a non native Java Scheduler i.e. written entirely in Java by way of an object field as opposed to relying on the APIs discussed further below .

The Java API may comprise a Java scheduler API an execution flow scheduler API a thread API and an execution flow API. The execution flow API is presented by an ExecutionFlow class that abstracts the execution flow context of an underlying low level runtime of the system . An example implementation of an ExecutionFlow class is shown in . One of ordinary skill will appreciate that this code sequence is presented by way of example only and other implementations are possible and fall within the scope of this disclosure. Functionality comprised in an ExecutionFlow class is explained below with reference to this example implementation.

The ExecutionFlow class of is designed to be extended i.e. subclassed. As such the execution flow API comprises a method invoked by the JVP to execute the instructions of an execution flow i.e. an ExecutionFlow execution method lines . Note that the ExecutionFlow execution method is entitled run in the example and is referred to as a run method herein. This run method is overridden by any class extending the ExecutionFlow class to provide an implementation that comprises the instructions.

The ExecutionFlow class may also comprise a constructor that creates a native execution flow context when an object of subclass of the ExecutionFlow class is instantiated lines . The constructor calls a native method to create the native execution flow context i.e. an ExecutionFlowCreate method . In other embodiments the native execution flow context may be created after the object is instantiated by an invocation of a native method that creates the execution flow context e.g. line .

In some embodiments when an object instantiated in the memory of the system is no longer needed the memory allocated to that object is freed for reuse i.e. destroyed by the garbage collector in the JVP . Therefore an object of a subclass of the ExecutionFlow class that is no longer needed is eventually destroyed by the garbage collector. However in some embodiments of the system the low level runtime may provide a predetermined static number of execution flow contexts. In such embodiments the ExecutionFlow class may comprise a native method that may be invoked to indicate to the low level runtime that an object of a subclass of the ExecutionFlow class is no longer using an execution flow context i.e. an ExecutionFlowDestroy method line . This allows the execution flow context to be re used even if the garbage collector has not yet destroyed the object.

As is explained in more detail below threads of the Java applications and the Java operating system are implemented as subclasses of the ExecutionFlow class. In some embodiments multiple threads may run simultaneously. The possibility exists that two threads may attempt to access the same data simultaneously or one thread may attempt to retrieve data that has not yet been provided by another thread.

The JVP implements thread synchronization as specified in the Java language specification and the Java virtual machine specification. Each Java object is allocated a monitor when the object is created. If a method of an object or a code segment of a method is implemented using the Java keyword synchronized the JVP uses the monitor to control access to the synchronized method or code segment. When the synchronized method or code segment is executed by a thread the thread acquires the monitor while executing the method or code segment. After the method or code segment is executed the thread releases the monitor. A thread that attempts to execute a synchronized method or code segment of an object whose monitor is taken by another thread waits until that thread releases the monitor.

The illustrative ExecutionFlow class comprises a method that may be invoked by the JVP to notify a Java thread scheduler discussed more below that a currently executing thread has attempted to execute a synchronized method or code segment of an object whose monitor is taken i.e. a monitorEnter method line . Upon receiving such notification the Java thread scheduler may halt the execution of the current thread and place it in a queue to wait for the monitor to be released. The ExecutionFlow class also comprises a method that may be invoked by the JVP to notify the Java operating system that a monitor has been released. Upon receiving such notification the Java operating system reschedules any threads that can be run in particular threads that are waiting for the monitor to be released.

The execution flow scheduler API is presented by a Java ExecutionFlowScheduler class. The ExecutionFlowScheduler class comprises a Java native method that is invoked to cause the low level runtime to perform a context switch i.e. an execution flow activation method . The context switch halts execution of the currently executing execution flow and saves its context. The context switch then restores and activates an execution flow context specified by the execution flow activation method. The Java system software of the system comprises a single execution flow scheduler object created using this class. In some embodiments as discussed below the context switch may be accomplished by a non native Java Scheduler by way of an object field.

The thread API is presented by a Thread class. An example implementation of the Thread class is shown in . One of ordinary skill will appreciate that this code sequence is presented by way of example only and other implementations are possible and fall within the scope of this disclosure. Functionality comprised in the Thread class is explained below with reference to this example implementation.

The Thread class extends an ExecutionFlow class and is designed to be extended i.e. subclassed by a Java application to create custom thread classes representing threads of the application. The thread API comprises a method to be invoked by the JVP to execute the instructions of a thread i.e. a run method lines . In some embodiments the run method is overridden by a custom Thread class extending the Thread class to provide an implementation that comprises the instructions of the thread. In other embodiments the run method of the Thread class comprises an instruction sequence that causes a thread instruction sequence of a custom Thread class to be executed.

In some embodiments the Thread class comprises a scheduling method that may be called by the Java operating system to cause a thread to be activated lines . This scheduling method comprises instructions to invoke the execution flow activation method of an execution flow scheduler API to activate an execution flow context of a thread defined by a custom Thread class.

In various embodiments the thread API may comprise additional methods and instance variables that are used by a Java thread scheduler to manage threads. For example the Thread class may comprise methods to suspend the execution of a thread to set the priority of a thread and to resume a thread.

A Java scheduler API is presented by a Java thread scheduler. Embodiments of the Java thread scheduler implement a high level thread scheduling policy e.g. round robin priority based and or negotiated multimedia . In some embodiments additional methods and instance variables included in the thread API are determined at least in part by the thread scheduling policy of the Java thread scheduler.

The thread abstraction as described above relates in part to abstracting Java threads for execution within a single processor such as the JVP . In addition context switching is described as being accomplished by the APIs. In some embodiments Java threads may be abstracted and executed within a plurality of processors wherein the plurality of processors is abstracted. Furthermore context switching may be accomplished by a non native Java Scheduler i.e. written entirely in Java by way of an object field rather than relying solely on APIs to make the context switch.

The plurality of processors may be abstracted for example by creating a JVP object by instantiating a JVP class. Java methods e.g. comprised within a Java Thread class may then be run on the instantiated JVP objects. illustrates a system comprising a plurality of abstracted processors which are represented by CPU Objects and . For the purposes of this disclosure the CPU Objects may be equivalently referred to as JVP Objects. As shown each CPU Object comprises a Volatile Field e.g. Volatile Fields belonging to CPU Objects and respectively . In some exemplary embodiments each of the Volatile Fields is named CurrentSwContext and serves to identify a particular CPU Context Object such as CPU Context Objects or which are managed by the non native Java Scheduler running within the JVM . For the purposes of this disclosure the CPU Context Objects which can be viewed as thread abstractions may be equivalently referred to as JVPContext Objects. In some embodiments the CPU Context Objects may be instantiated by the Java Scheduler or other Java software such as application software. In effect a CPU Context Object is mapped onto a CPU Object by way of the Volatile Field as determined by the Scheduler and methods Method 1 or Method 2 discussed below for execution within the CPU Object. In some embodiments the system may use the CPU Context Objects and the CurrentSwContext Volatile Fields to switch the currently running Java method within a CPU Object. In other embodiments the system may switch from running a Java method on one CPU Object to another CPU Object e.g. system may switch from CPU Object to CPU Object .

The CPU Context Objects each represent a single execution flow within the system and may be created by passing a reference to a static method to a constructor e.g. a JVPContext constructor . Each CPU Context Object is independent from each other and each CPU Context Object can be viewed as a Java thread abstraction. In addition each CPU Context represents a particular CPU or equivalently JVP state. When the CPU Context Object is created it is associated to both one CPU Object and one Java method. The Java method associated to the CPU Context Object then becomes the entry point for execution of instructions within the CPU Context Object. Furthermore each Java bytecode starts and ends within the same CPU context.

In existing Java platforms a Java scheduler is written in native code and executes one thread at one time on one CPU. In embodiments of the present invention the Java Scheduler is written entirely in Java and is not limited to scheduling and executing threads on a physical CPU such as the JSM . Instead the Java Scheduler sees the abstracted CPUs CPU Objects as the entirety of CPUs available for thread execution. Thus the Java Scheduler can execute in parallel any number of threads represented by the CPU Context Objects on any number of abstracted CPUs and the Java Scheduler determines which CPU context objects execute on which CPU objects. Regardless of the number of abstracted CPUs or the number of abstracted threads the JEK performs the physical realization of the thread execution upon the JVP .

Method 1 functions to remove the current CPU Context Object i.e. the current thread represented by JvpContext in Method 1 and Method 2 from the CPU Object upon which it was executing and replacing it with a new CPU Context object i.e. a new thread represented by ctx in Method 1 and Method 2 . The context switch as implemented according to Method 1 or Method 2 is accomplished by rewriting the CurrentSwContext Volatile Field of the CPU Object upon which a thread i.e. a CPU Context Object is executing.

Method 2 provides functionality similar to Method 1 and also provides a monitor standby mechanism wherein the current i.e. original CPU Context Object is assumed to own a monitor represented by mon in Method 2 . Method 2 removes the current CPU Context Object from the CPU Object upon which it was executing while temporarily freeing the monitor for a new CPU Context Object to be executed on the CPU Object. The original CPU Context Object may reacquire the monitor once the new CPU Context Object has released the monitor and the original CPU Context Object may once again execute. For both Method 1 and Method 2 null may be used as a valid argument for JvpContext wherein null indicates to the CPU Object that there is nothing to execute at the moment. Thus considering the rewriting of the CurrentSwContext Volatile Field based on Method 1 or Method 2 the context switch is performed by using the Java Scheduler written entirely in Java and modifying an object field of the CPU Object rather than relying on APIs to accomplish the context switch. This results in more efficient context switching.

System may be implemented as a mobile cell phone such as that shown in . As shown the mobile communication device has an outer enclosure and includes an integrated keypad and display . The JSM processor and MPU processor and other components may be included in electronics package connected to the keypad display and radio frequency RF circuitry . The RF circuitry may be connected to an antenna .

From the description provided herein those skilled in the art are readily able to combine software created as described with appropriate general purpose or a special purpose computer hardware to create a computer system and or computer subcomponents embodying aspects of the invention to create a computer system and or computer subcomponents for carrying out the method embodiments of the invention and or to create a computer readable medium storing a software program to implement method aspects of the various embodiments. Moreover the embodiments of the illustrative methods could be implemented together in a single program with various subroutines or split up into two or more programs executed on the processor.

While various embodiments of the invention have been shown and described modifications thereof can be made by one skilled in the art without departing from the spirit and teachings of the invention. The embodiments described herein are illustrative only and are not intended to be limiting. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

