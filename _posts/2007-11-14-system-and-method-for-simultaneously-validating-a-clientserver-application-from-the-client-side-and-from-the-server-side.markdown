---

title: System and method for simultaneously validating a client/server application from the client side and from the server side
abstract: A system and method for simultaneously validating a client-server software application from a client side and a server side, the client-server software application having a client application and a server application. The method and system include: defining a test case to exercise or emulate the client application; specifying validations to be made against server-side state in the defined test case; controlling a monitoring program to monitor the server application and collect information about the server-side state; executing the defined test case to exercise the server application through the client or a client emulator; processing the collected information; simultaneously performing validation tests against the collected information about the server-side state and against the client application or outputs from the server; and reporting results of the validation tests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510716&OS=08510716&RS=08510716
owner: Parasoft Corporation
number: 08510716
owner_city: Monrovia
owner_country: US
publication_date: 20071114
---
This Patent Application claims the benefit of the filing date of U.S. Provisional Patent Application Ser. No. 60 865 768 filed on Nov. 14 2006 and entitled System And Method For Creating Test Cases For Simultaneously Validating A Client Server Application From The Client Side And From The Server Side the entire content of which is hereby expressly incorporated by reference.

The present invention relates generally to testing computer software and more particularly to a system and method for simultaneously validating a client server application.

Traditionally client server applications have been tested in one of the following ways. First a test tool exercises a client and validates that the client responds properly to user inputs. The behavior of the server is indirectly tested by validating the correct behavior of the client since the server output affects what the client displays to the user. In this scenario both the behavior of the client application and the server application are being tested. An example is a test tool that is used to automate testing of a Java client or of a web browser.

Second instead of testing a client application directly a test tool can emulate a client by directly interacting with the server and acting like a client. However in these cases a client application is not being tested. Instead the behavior of the server is tested by the test tool sending different requests or sequences of requests to the server and then validating the contents of the responses returned by the server.

Another way that client server applications are tested is by using unit tests that run against the server side code. In this case the tests are not run in the server s runtime environment rather they are simply unit tests that run against the application code. They typically require that many method calls be stubbed out since the test cases are not run against a running web application but only against the source code of the application.

An adaptation of this method is to use unit tests that run in container. In container tests require that the server application be running as the tests are run. Typically they involve executing the test case to make special requests to the server and adding in or turning on an additional server framework that intercepts the special server requests. The special requests may include parameters that are only intended to be used by the additional server framework. However since the tests are performed using the additional framework and not using typical client requests the behavior of the server is not tested in the actual production environment in which it needs to be run. Additionally the framework requires the setup work of installing and configuring it.

The first two methods of testing are performed from the client side of the application without directly validating the server as it runs. The server is tested by observing its output either within a client or within the output itself. The third method along with its adaptation is performed from inside the server without doing any validation on the output it produces for the client. Using the first three methods if a user desires to test both client side and server side behavior he needs to run different tests at different times in order to accomplish this.

The separation of client and server based tests is undesirable in many cases. Server applications are meant to be accessed through a remote client. Therefore it is understandably difficult to create tests that run against the server in the server s runtime environment without using a client to send requests to the server. It can be difficult or even impossible to replicate the server state thus making validation just as difficult. On the other hand simply validating server output from the client perspective is not a sufficient method of testing either as there may be problems in the server application that do not make themselves visible in the output.

Therefore there is a need for a new system and method to define a test case that exercises the server from the client perspective without modifying the server s environment and at the same time is able to validate server side state to validate whether the server is operating properly.

In some embodiments the present invention is a system and method for simultaneously validating a client server software application from a client side and a server side the client server software application having a client application and a server application. The method and system include defining a test case to exercise or emulate the client application specifying validations to be made against server side state in the defined test case controlling a monitoring program to monitor the server application and collect information about the server side state executing the defined test case to exercise the server application through the client or a client emulator processing the collected information simultaneously performing validation tests against the collected information about the server side state and against the client application or outputs from the server and reporting results of the validation tests.

Defining the test case may include generating corresponding code for example JAVA code from an Application Programming Interface API for example a HttpUnit API that mimics a set of user actions in the client application or by a client emulator.

In some embodiments the present invention is a system and method for simultaneously validating an application from the client side and the server side. The invention allows the user to define a test in a client server application using for example a test tool. The test tool controls a client or emulates a client to test both or one of the client and server applications.

The test case also specifies validations to be made against the client application and or validations to be made against the output s from the server application . For example validations against the client application may include validating that the client shows appropriate information to the user for example that a search field that allows a user to enter search criteria shows up on a search page. In another example validations against the outputs from a server application may include validating that HTML returned by the server application contains an input element that allows a user to enter search criteria on a search page in a client that interprets the HTML. A primary difference between validating a client application and validating the outputs from a server application is as follows. When validating a client application direct validation is made that the client shows the appropriate information for example a search box based on the output s received from the server for example an HTML file containing an input element . In this situation the server output is only indirectly tested for example the client application will not create a search box if the input element is not in the HTML . However validating server output s involves directly testing the output s from the server for example that an input element is present in the HTML for a search page.

Lastly the test case specifies validations to make against information collected from server monitoring . For example the test case can retrieve information about the state of a server side object of type com.google.search.SearchResultsList that is present within the server application as the test case executes. The test case can validate that the state of that object meets certain requirements for this particular test case for example whether the object contains 10 instances of the class com.google.search.SearchResultEntry and whether the states of each of those instances are correct and contain proper information within their title description and url fields.

The collected information may include data uniquely identifying a thread in the execution path in which a method is invoked instance object on which the method was invoked method argument values place of the method invocation amongst other method invocations and return value of the methods. The collected information may also include information about the objects and processes a method would interact with and objects calling sequence which may be implied from temporal recording of sequence of calls from the execution of application program while exercised by the client application or the client emulator .

The invention then retrieves the collected information about server side state that was stored by the monitoring program and uses it to recreate instances of the server side objects in the testing environment that have the same properties as the actual objects had in the server application as seen in block . It recreates the objects by using an API exposed by the invention that allows it to instantiate the objects set object properties and stub portions of the object that reference information that was not collected by the monitoring engine. Validation tests are then run against the server side state in block . For example if the server contains a particular object with certain values the test validates that the object did in fact exist and had the correct values as the client accessed the application.

Optionally and in addition to validating the server side state the test case may also perforin validations against the behavior of the client or the output from the server as shown in block .

For example data can be acquired for processes run on Java VM using Debugger Interface DI Profiler Interface PI or Tool Interface TI for Sun Microsystem s Java Development Kit JDK . Alternatively the source or the binary code can be instrumented. Also the combination of the above mentioned data acquisition means can be employed. Such profiling interfaces provide data about method invocation sequence and argument values. For Java applications these interfaces are known as Java Virtual Machine Profiler Interface JVMPI Java Virtual Machine Debugger Interface JVMDI and Java Virtual Machine Tools Interface JVMTI .

The driver program then initializes a recorder module . Control events and are sent to the recorder. These events may be sent by the driver the monitored server application or both. Example of control events include Start Recording and Stop Recording . Events also control the granularity of recorded data. For example Record method calls Record method calls and objects etc. Execution data is then sent to the recorder .

Recorder may send control events to the monitored server application or the driver . These events may be for example data granularity control events like turning on off object recording execution control events like suspend execution or kill . Execution data is then processed by the recorder and stored in an Execution Record Database . The tested program is prepared for recording by appending arguments for the launch to enable the required program type interfaces. The prepared program is then launched in and terminated in .

A monitoring program is described in more detail in a co pending and co owned U.S. patent application Ser. No. 11 559 356 and entitled System And Method For Automatically Creating Test Cases Through a Remote Client now U.S. Pat. No. 7 908 590 the entire contents of which is herein incorporated fully by reference.

In some embodiments the present invention defines the test case within a unit test written with a programming language. For example an API is defined to allow connection to the server side monitor retrieval of the monitored data and re creation of server side objects within the test case so that assertions can be defined against those objects. A user defines a series of user actions that are to be performed in an application being tested. These user actions represent the real steps a user would take within a client application when interacting with the remote application. Each user action may cause a series of requests to be made to the server application. Each request may be an HTTP request where the HTTP headers the URL being requested and the post data being sent along with the request may also be able to be modified by the user within the unit test.

The test case may also perform validations against the client or against the output from the server. The test case may also retrieve recreated server side objects from the server side monitor and define assertions against properties of those objects. These recreated server side objects are replicas of object instances that were detected by the monitor while the test case was executing the user actions. The monitor observes the objects in the server application records the data needed to recreate them and then when asked by the test case recreates the same objects with the same properties in the test environment.

Defining the test case within source code typically provides more flexibility to the user than defining the test case within a test tool. Source code generally allows the test case to be created with much more complicated logic than could be done in a GUI. Server side objects are abstractions of real world data that are defined within source code therefore it is a natural extension to use a source code based unit test to validate them. Typically only developers understand the architecture of the server sufficiently to know what objects to expect and what their values should be. Since the developers already understand and like working with source code it is advantageous for the tests to be written in source code.

In block the test case again accesses the monitoring engine this time asking it for a recreated instance of every object of type com.google.search.SearchResultList that was created by the server application during the time the user actions were being executed by the test case. In this example SearchResultList is a Java class used by the server application when it constructs search results in HTML to send to the client application. The monitoring engine program recreates instances of the objects based on the information it collected while monitoring the state of those objects on the server and returns those recreated instances to the test case.

In block the test case validates that only one instance of the SearchResultList object was created by the server application while the user actions were executed and furthermore validates that that one object contains 10 instances of the SearchResultEntry object since a search results page is expected to have 10 results. The test case may then define assertions against properties of each of the SearchResultEntry objects for example verifying that each one contains a non empty description title and URL.

In some embodiments the present invention automatically creates the test case by iterating through a set of user actions previously recorded in a browser one by one i.e. clicking a link submitting a form sending a custom request etc. and then generates corresponding code for instance Java code from the HttpUnit Application Programming Interface API that mimics each action. The Java source code fragments for each action are combined into a test case that executes the actions in the same order as they were made while recording in the browser.

For example a set of user actions performed within a browser accessing a remote server application such as a web application are converted into a test for example a JUnit test that uses the HttpUnit API to define the same set of user actions. These user actions may have been recorded within the context of a test tool that also allows a user to set up validations against the client application and or the server outputs within the test tool GUI. These validations that were set up within the tool GUI may also be automatically transferred to the generated JUnit test. To do this the invention iterates through each validation one by one and then generates corresponding Java code from the HttpUnit and JUnit APIs that will mimic the same validation.

Optionally instead of or in addition to the user defining the server side object assertions a test tool with a GUI may generate them automatically. For example this could happen by the test tool observing the server side objects that were created by a server application while recording user actions in a browser. Once done recording in addition to generating the code within the test case that executes the recorded user actions the test tool could also generate assertions within the test case for recreated versions of the server side objects it observed while recording.

Generation of a unit test written with a programming language is described in more detail in a co pending and co owned U.S. patent application Ser. No. 11 558 241 and entitled System And Method For Generating Source Code based Test Cases the entire contents of which is herein incorporated fully by reference.

Then as the invention accesses the server application indirectly by interacting with the client application or client emulator in block it collects the server side information using the monitor in block and processes the collected information in block . It then presents it to the user within a GUI in block . The user is then able to sift through the presented data filter it and observe the recorded state of server side data. If the user knows that there is a certain problem within an application the user can record the scenario that reproduces the problem using the present invention. Then the tool that records the scenario would retrieve and show the server side object state observed while running the recorded scenario specified by the user. The user can then peruse the information to identify what objects may have had incorrect values and caused the problem. This is easier than modifying server side code to log data which may involve stopping and restarting the server with each change and then replaying the scenario. The invention allows the above mentioned steps to be performed within the context of the test tool making the task much easier for the developer.

It will be recognized by those skilled in the art that various modifications may be made to the illustrated and other embodiments of the invention described above without departing from the broad inventive scope thereof. It will be understood therefore that the invention is not limited to the particular embodiments or arrangements disclosed but is rather intended to cover any changes adaptations or modifications which are within the scope and spirit of the invention as defined by the appended claims.

