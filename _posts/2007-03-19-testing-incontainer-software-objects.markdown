---

title: Testing in-container software objects
abstract: Various techniques for testing in-container software objects are disclosed. For example, one method involves invoking a proxy method of a proxy object within a testing process. In response to the proxy method of the proxy object being invoked, a request is sent to a container, which is separate from the testing process. The request includes a request to invoke a method of an object within the container. The proxy object represents the object within the container. The proxy object can be used to test the corresponding object, which is represented by the proxy object, within the container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510712&OS=08510712&RS=08510712
owner: Interactive TKO, Inc.
number: 08510712
owner_city: Dallas
owner_country: US
publication_date: 20070319
---
This invention relates to testing and more particularly to systems for testing in container software objects.

As software becomes more sophisticated it becomes more difficult to quickly and easily perform thorough software testing. For example software containers are independent environments in which applications can execute. Examples of containers include Java 2 Platform Enterprise Edition J2EE or JavaEE containers such as those provided in product families such as WebLogic WebSphere and JBoss as well as widget toolkits such as Swing applications using the Java Swing toolkit that provide a framework for creating user interfaces.

Testing code within a container is often difficult. In general a container is an independent process in which container dependent code is deployed. Applications designed to be executed within a container depend upon the container and cannot be tested independently of the container. At the same time external tests i.e. tests that execute outside of the container are not part of the container s process and thus do not have visibility into the container. In other words an external test will execute in a different process than the container and thus the external test cannot interact with individual objects within the container. Accordingly external tests cannot adequately test objects that are executing within the container such objects are referred to herein as in container objects since those objects are effectively invisible to the external tests.

Because of the above characteristics of software that executes in containers existing techniques for testing in container objects have required container specific test code that is deployed within the container. If the test code needs to be modified the modified test code must be redeployed and the container restarted. Because of these restrictions existing techniques for performing in container testing can be laborious error prone and or inefficient. Accordingly new techniques for testing in container objects are desired.

While the invention is susceptible to various modifications and alternative forms specific embodiments of the invention are provided as examples in the drawings and detailed description. It should be understood that the drawings and detailed description are not intended to limit the invention to the particular form disclosed. Instead the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

In container test manager is generic to the type of container used to implement container e.g. if container is a J2EE container in container test manager can be designed for use within J2EE containers . In container test manager is configured to detect classes that are implemented within container and to provide information identifying those classes to test manager . In container test manager can identify Enterprise JavaBeans as well as other Java classes deployed within container . In container test manager can also instantiate manipulate and delete objects within container in response to requests from testing process as well as provide information indicating the results of instantiating manipulating or deleting in container objects to testing process . Thus in container test manager provides test manager with visibility into container as well as the ability to manipulate and monitor the behavior of objects within container .

Testing process is implemented independently of container . Thus testing process can be modified without having to stop and restart container and without having to redeploy any code into container . A user can thus modify testing process or dynamically change the flow of testing being performed by testing process without needing to redeploy any test code or to restart container . At the same time because testing process can communicate with in container test manager testing process has the ability to interact with in container objects individually.

As noted above testing process gains visibility into container by communicating with in container test manager . In one embodiment test manager is configured to communicate with in container test manager . For example when testing process is initiated test manager can send a request for a list of in container classes to in container test manager . In response in container test manager returns a list of available classes to test manager .

Test manager can display the available classes which were identified by in container test manager to a user. If a user selects to test one of the available classes test manager instantiates a proxy object corresponding to that class within the testing process environment and instructs in container test manager to instantiate an object of the selected class within container . Both the in container object and the proxy object can be instantiated and deleted on the fly in response to test code execution and or user input.

In this example object and proxy object have been instantiated within container and testing process respectively. Proxy object corresponds to object which is an in container object within container . As shown proxy object implements a proxy method which corresponds to method of object .

Proxy object and object can be instantiated in response to a user request or test case execution that selects one of the in container classes for test. When such a selection is made test manager instantiates a proxy object corresponding to that class and also requests that in container test manager instantiate corresponding object of the selected class within container . It is noted that the order in which object and proxy object are instantiated can vary e.g. in some situations proxy object can be instantiated prior to instantiation of object or vice versa .

The proxy methods to implement within a given proxy object are identified by in container test manager which can provide a list of methods implemented by each class that is available within container . In container test manager can provide this list as either part of the information that identifies all available classes within the container or as a class specific list e.g. such a class specific list can be provided to testing process in response to instantiating an object from that class . For each method implemented by the in container object testing process will implement a proxy method within the corresponding proxy object.

Because proxy object is implemented within the testing process environment testing process can manipulate and monitor proxy object directly. In contrast object cannot be manipulated or monitored directly by testing process since object is implemented within container .

Proxy object is implemented using reflection such that a method call to one of the proxy object s proxy methods will be reflected to the corresponding in container object. Thus while testing process can manipulate a proxy object in the same manner as any other object within the testing process such activity will effectively cause the in container object to be manipulated.

In one embodiment proxy objects like proxy object are instantiated from the Java class java.lang.reflect.Proxy. Objects of this class behave in a manner that dynamically presents an interface to a remote object. Invoking a proxy method of a proxy object causes the method call to be sent to the remote object via the interface provided by the proxy object. Thus when a user selects to invoke proxy method as part of a test that method invocation will be reflected to object and cause corresponding method to be invoked as indicated by the arrow leading from proxy method to method .

If proxy method is invoked using the identifier ID of proxy object and the name of proxy method e.g. proxyObject.myMethod where proxyObject is the proxy object that method invocation will be translated to the ID of the corresponding in container object and the same method e.g. object.myMethod . In some embodiments this translation can be performed automatically e.g. due to proxy object being implemented as a proxy object . Alternatively the translation can be performed by test manager . Once the translation has been performed the translated ID and method name are sent to container causing in container test manager to retrieve the identified object and invoke the named method. As noted below the ID of in container object can be assigned to object by in container test manager .

When a method of an in container test object is invoked due to reflection from a proxy object in container test manager can monitor the results and return those results to test manager . For example if a method that returns a result is invoked in container test manager can return that result to test manager . If the result returned by invoking the in container method is an object that object can be represented by a proxy object in test manager .

In addition to monitoring results in container test manager can also monitor other conditions within container during the test process and return information identifying those conditions to test manager . For example in container test manager can obtain session keys from existing session objects within container monitor memory usage within the container and the like.

In one embodiment testing process is implemented using LISA Live Interaction Service Architecture available from iTKO Inc. of Dallas Tex. In this embodiment testing process provides a user interface that allows a user to dynamically test software by manipulating objects under test. Here testing process can provide a user with a list of available classes. If a user selects to test a particular class testing process dynamically instantiates an object of that class and displays the instantiated object as well as each method implemented by the object to the user. The user can then select to invoke methods within the instantiated object and view the results of invoking those methods. It is noted that a user can instantiate and test multiple objects simultaneously in order to observe the interactions between multiple objects. In this embodiment the user can dynamically alter the flow of testing.

In other embodiments testing process is a testing process that includes prespecified test cases that instantiate and manipulate one or more objects. In these embodiments the flow of testing is predetermined.

In container test manager can in one embodiment be implemented as an Enterprise JavaBean EJB that is configured to be deployed within a J2EE container. In one embodiment different types of in container test managers are provided for use with different types of containers. For example the developer of the testing software can supply different in container test managers for use with Swing applications or other widget applications as well as for use with Web containers applet containers EJB containers and the like. Similarly different in container test managers can be provided for use with different container platforms e.g. J2EE WebLogic WebSphere Enhydra and JBoss and the like .

It is noted that illustrates a specific example. In other embodiments different components can be used to implement the testing functionality described above. For example while specific software components have been described as implementing specific functionality this functionality can be implemented by different components than those depicted herein. For example the functionality of test manager can be subdivided into multiple other test management components or integrated into another component within testing process . Furthermore the specific components depicted in can be combined or subdivided into fewer or additional components.

Additionally other components can be used instead of and or in addition to those shown in . Such other components can provide different or additional functionality instead of and or in addition to the functionality described herein.

Furthermore some of the functionality described herein can be eliminated in some embodiments. For example in an alternative embodiment in container test manager can simply support manipulation of objects within container and return the results of those manipulations to testing process without providing information regarding the availability of classes within container . In such an embodiment a list of the classes available within the container and the methods available within each class is manually generated and supplied to testing process as opposed to being collected by in container test manager . Testing process can then use this information to request instantiation of objects of these classes and to instantiate corresponding proxy objects. This embodiment simplifies the implementation of in container test manager however for testing process to have the most up to date information it may also be desirable for a user to manually update the list of available classes within the container each time that classes are added to or removed from the container.

ID uniquely identifies the instantiated object within the container. This identifier can be assigned by the in container test manager. The in container test manager and the remote test manager within the testing process use ID to identify the in container object.

Pointer points to the location in memory at which the instantiated object is located. This pointer allows the in container test manager to retrieve the instantiated object in order to manipulate the object e.g. by invoking a method within the object or deleting the object .

Whenever the in container test manager receives a request e.g. a request that has been generated by translating a request to manipulate a proxy object as described above from the testing process that identifies a particular in container object the in container test manager accesses information in order to obtain the pointer associated with the object s ID . The in container test manager can then use pointer to access the identified object and perform the manipulations requested by the testing process.

It is noted that the in container test manager can maintain multiple sets of information one for each instantiated object under test within the container. As new objects are instantiated new sets of information can be created. As existing objects are deleted existing sets of information can be removed. This information can be stored in a table hash table linked list tree or other appropriate data structure. The in container test manager can search this data structure based upon object ID.

In general once deployed within the container the in container test manager begins listening for requests from the testing process e.g. by monitoring a particular software port designated for communication with the testing process . Thus each method of begins with the in container test manager waiting for a request from the testing process.

The in container test manager parses the metadata and extracts information identifying each class available within the container. The in container test manager then returns the information identifying the identified classes to the testing process as shown at . It is noted that in some embodiments this list can also include other information. For example the list can identify each method implemented by each identified class.

If such a request is received the in container test manager instantiates an object of the specified class as shown at . The in container test manager also assigns a unique identifier to the instantiated object. The in container test manager can store the assigned identifier as well as a pointer to the instantiated object s location within a table or other data structure in memory as described above with respect to .

Once the object has been instantiated the in container test manager returns the object s identifier to the testing process as shown at . The in container test manager can also return a list of metadata associated with the object e.g. such as a list of methods implemented within the object to the testing process.

If the in container test manager receives a request to manipulate an existing object the in container test manager will look up the identifier contained in the request and use the associated pointer to access the in container object. The in container test manager will then perform the requested manipulation. For example the in container test manager can invoke a method on the identified object as shown at .

If a result is generated during the process of manipulating the in container object the in container test manager can capture this result and return information identifying the result to the testing process. For example if the method invoked at generates a value as determined at the resulting values can be returned to the testing process as shown at .

The method begins at when the testing process obtains any credentials necessary to access the container. For example the testing process can prompt a user to enter the network address and port number associated with the container. If additional credentials are required e.g. if the container is implemented within a corporate intranet that is not publicly available the testing process can also prompt the user for a username and or password or other security information usable to gain access to the container. Alternatively instead of being received dynamically from a user such credentials can be obtained via configuration information that is encoded within a test case executing as part of the testing process.

At the testing process obtains a list of classes that are available within the container. The testing process can obtain this information by sending a request to an in container test manager within the container using the credentials obtained at .

Once the list of available classes has been obtained the testing process can display these classes to a user. If a user selects to instantiate an object within the container e.g. by selecting one of the available classes as displayed by the testing process as determined at the testing process will generate a request to create the selected object and provide this request to an in container test manager. The in container test manager can then instantiate the selected object as shown in the method of .

After requesting the creation of a selected object is requested the testing process will receive an object identifier ID of the selected object as well as metadata associated with the selected object as shown at . The associated metadata can identify various characteristics of the selected object such as the methods implemented by the selected object it is noted that this metadata can alternatively be obtained as part of the information obtained in operation instead of or in addition to being received as part of operation . The testing process will subsequently use this ID to refer to the object when communicating with the in container test manager.

The testing process then creates a proxy object corresponding to the in container object as shown at . For each method implemented within the in container object the proxy object will contain a corresponding proxy method. The proxy object is implemented in such a manner that any attempt to invoke a proxy method of the proxy object will result in the invocation of the corresponding method of the in container object. The proxy object is instantiated within the testing process allowing the testing process to manipulate the proxy object directly.

If the user selects to manipulate the proxy object e.g. by invoking a proxy method of the proxy object as determined at the manipulations will be reflected to the container . Reflecting the manipulations involves translating the proxy object identifier to the identifier of the in container object. If a proxy method is being invoked the proxy method s name is translated to the name of the corresponding method of the in container object. If there are any parameters being provided as part of a method call these parameters will also be provided to the in container object.

The results of the manipulation of the in container object are monitored by an in container test manager and returned to the testing process. The testing process can then display information indicating these results to the user as shown at . It is noted that such results can be provided as inputs to other test components recorded e.g. in a log file or otherwise consumed instead of or in addition to being displayed to a user.

It is noted that in some embodiments operations and are optional. For example in an alternative embodiment the list of available classes and access credentials can be manually provided to the testing process or coded into the testing process making it unnecessary to request such credentials or available classes from a user or in container test manager. Additionally in some embodiments the flow of testing is prespecified as opposed to being dynamically determined based upon user interaction within the testing process and thus objects will be instantiated and or manipulated as needed to satisfy the prespecified test flow instead of being instantiated on the fly in response to user input.

Thus some embodiments may not implement all of the operations shown in . Furthermore other operations can be implemented instead of and or in addition to those methods shown in .

Computing device includes one or more processors e.g. microprocessors PLDs Programmable Logic Devices or ASICs Application Specific Integrated Circuits configured to execute program instructions stored in memory . Similarly computing device includes one or more processors configured to execute program instructions stored in memory . Memories and can each include various types of RAM Random Access Memory ROM Read Only Memory Flash memory MEMS Micro Electro Mechanical Systems memory and the like.

Computing device also includes one or more interfaces and computing device includes one or more interfaces . In each computing device the respective processor s memory or memories and interface s are coupled to send and receive data and control signals by a bus or other interconnect.

Interfaces and can each include an interface to a storage device on which instructions and or data included are stored. Interfaces and can also each include an interface to a network such as network for use in communicating other devices. Interfaces and can also include interfaces to various peripheral Input Output I O devices such as a monitor on which a graphical interface e.g. allowing a user to interact with a test case or view test results can be displayed.

In this example program instructions and data implementing a testing process which includes a proxy object are stored in memory of computing device . As noted above testing process is a testing tool that is configured to test software such software is referred to as software under test . In some such embodiments testing process is an off the shelf testing tool e.g. a software application available from a third party vendor as opposed to a testing tool that was completely designed in house by the creators of the software under test . For example in one embodiment testing process is LISA Live Interaction Service Architecture available from iTKO Inc. of Dallas Tex. Testing process can be a functional test tool e.g. a test tool that is designed to verify whether the system under test is functioning as intended a performance test tool e.g. to measure how the system under test performs under certain conditions or a test tool that gathers significant metrics describing the operation of the system under test.

Program instructions and data implementing a container are stored in memory of computing device . An object and in container test manager have been deployed within container .

It is noted that the program instructions and data implementing testing process and or in container test manager can be stored on various computer readable media such as memory and or . In some embodiments testing process and or in container test manager can be stored on a computer readable storage medium such as a CD Compact Disc DVD Digital Versatile. Disc hard disk optical disk tape device floppy disk and the like. In order to be executed by processor and or the instructions and data implementing testing process and or in container test manager are loaded into memory from the other computer readable storage medium. The instructions and or data implementing testing process and or in container test manager can also be transferred to a computing device for storage in memory via a network such as the Internet or upon a carrier medium.

While shows the testing process and container as being implemented on different computing devices that are coupled by a network it is noted that testing process and container can also be implemented on the same computing device. Thus the testing process and container can be coupled in a variety of different ways.

Although the present invention has been described in connection with several embodiments the invention is not intended to be limited to the specific forms set forth herein. On the contrary the present invention is intended to cover such alternatives modifications and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims.

