---

title: Systems and/or methods for providing feature-rich proprietary and standards-based triggers via a trigger subsystem
abstract: The example embodiments disclosed herein relate to application integration techniques and, more particularly, to application integration techniques built around the publish-and-subscribe model (or one of its variants). In certain example embodiments, triggers are provided for establishing subscriptions to publishable document types and for specifying the services that will process documents received by the subscription. A standards-based messaging protocol (e.g., JMS messaging) may be fully embedded as a peer to a proprietary messaging protocol provided to an integration server's trigger subsystem so that all or substantially all of the feature-rich capabilities available via the proprietary protocol may also become available via the standards-based messaging protocol. The triggers may be JMS triggers in certain example embodiments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08136122&OS=08136122&RS=08136122
owner: Software AG
number: 08136122
owner_city: Darmstadt
owner_country: DE
publication_date: 20070830
---
The example embodiments disclosed herein relate to application integration techniques and more particularly to application integration techniques built around the publish and subscribe model or one of its variants . In certain example embodiments a standards based messaging protocol e.g. the JMS messaging protocol may be fully embedded as a peer to a proprietary messaging protocol in an integration server trigger subsystem such that all or substantially all of the feature rich capabilities available via the proprietary protocol may be accessed via the standards based messaging protocol. The triggers accessing the trigger subsystem may be JMS triggers in certain example embodiments.

Companies today are tasked with implementing solutions for many types of integration challenges within their respective enterprises. Many of these challenges involve issues of application integration e.g. integration among and or between software applications and or other systems and fall into common patterns.

For example a first area relates to propagation of similar business objects from one system to multiple other systems such as for example in an order status change or a product price change. A second area relates to synchronization of similar business objects between two or more systems to obtain a single view such as for example a real time synchronization of customer product registration product order and product SKU information among several applications. This is the most common issue requiring an integration solution. In a one way synchronization there generally is one system e.g. resource that acts as a data source and one or more resources that are targets of the synchronization. In a two way synchronization every resource often is both a potential source and target of a synchronization. There generally is not a single resource that acts as the primary data resource. Thus a change to any resource should be reflected in all other resources. A third area involves information joined from multiple sources into a common destination system such as for example communicating pharmacy customer records and prescription transactions and website data into a central application and database.

Various tools have been provided that enable a user to design and deploy solutions that address these challenges using for example the publish and subscribe model or one of its variants. The publish and subscribe model is a specific type of message based solution in which messages are exchanged anonymously through a message broker. Applications that produce information that needs to be shared make this information available in specific types of recognizable documents that they publish to the message broker. Applications that require information subscribe to the document types they need.

At run time the message broker receives documents from publishers and then distributes the documents to subscribers. The subscribing application processes or performs work using the document and may or may not send a response to the publishing application.

In a typical system an integration server or applications running on an integration server publish documents to a broker. The broker then routes the documents to subscribers located on other integration servers. The integration server and the broker share a fast efficient process for exchanging documents across the entire system.

Although such techniques have been successful in providing solutions to the above described challenge areas further enhancements are still possible. For example the integration server IS Trigger Subsystem provides a rich infrastructure for message processing e.g. asynchronous message processing . However this functionality is only available for messaging over a proprietary e.g. broker messaging protocol. Thus users currently have to make a difficult design decision choosing between either a feature rich proprietary protocol or a standards based interoperable messaging protocol e.g. JMS .

One approach to solving this problem has involved the use of a JMS adapter provided to an integration server. Thus both a proprietary trigger subsystem provided by the integration server for proprietary messaging and a separate JMS adapter were provided to the integration server.

Unfortunately this approach is somewhat incomplete. In particular despite the availability of a JMS adapter for standards based interoperable messaging the trigger subsystem capabilities could not be fully used in connection with JMS. That is users who want the extended capabilities of the trigger subsystem while using the JMS adapter would have to custom implement those capabilities in their applications for every new application. This often imposes significant configuration and programming requirements and has led to a plethora of non standardized implementations of the same and or similar functionality. This problem is further exacerbated as JMS is still in the process of being standardized for use in the in web services context. In essence this means that if capabilities comparable to those of the proprietary broker were required they would have to be implemented in the application services layer time and time again. Even where such approaches have been implemented they have not been standardized e.g. because enterprises are different in terms of their organizations processes requirements infrastructure etc.

Thus a problem remains in that there is not a single means to couple the current trigger subsystem and all of its capabilities with standards based messaging e.g. via JMS . Accordingly there remains a tradeoff between a feature rich proprietary protocol on the one hand and a standards based interoperable messaging protocol e.g. JMS on the other.

Thus it will be appreciated that there is a need in the art for improved techniques for providing application integration solutions in one or more of the above noted and or other areas.

One aspect of certain example embodiments of this invention relates to a messaging layer that provides a rich feature set for addressing application integration challenges that is accessible through both proprietary and open messaging constructs existing outside of the application layer. In certain example embodiments such messaging constructs may be in the form of triggers and such triggers may enable a publish and subscribe type solution to such application integration challenges in certain example embodiments. The triggers of certain example embodiments may be JMS triggers.

Another aspect of certain example embodiments relates to parallel subsystems being accessible through a common trigger subsystem provided as value added layer above the respective trigger subsystems.

Still another aspect of certain example embodiments relates to substantially fully embedding JMS as a peer to the proprietary messaging protocol in the integration server trigger subsystem so that all or substantially all existing capabilities would be JMS enabled.

A further aspect of certain example embodiments relates to the use of a messaging layer that enables JMS messaging without the use of a special adapter provided to an integration server. Furthermore in certain example embodiments such a messaging layer may make it possible to avoid making any changes to the JMS trigger itself and or may reduce the need for custom programming and or implementation at the application service level in certain example cases.

In certain example embodiments a trigger subsystem for use with an application integration system is provided. At least one proprietary trigger subsystem is embedded in the trigger subsystem. At least one standards based trigger subsystem is substantially fully embedded in the trigger subsystem. Common trigger facilities are provided for the at least one proprietary trigger subsystem and the at least one standards based trigger subsystem. The at least one proprietary trigger subsystem and the at least one standards based trigger subsystem are provided as parallel subsystems. Each said proprietary trigger subsystem and each said standards based trigger subsystem is configured to access a corresponding trigger layer. Each said trigger layer is configured to provide triggers in a format associated with the respective trigger layer. The triggers include instructions for causing a process to be executed in or by the application integration system or a component thereof.

In certain other example embodiments there is provided a messaging layer for use across an integration server or an integration server instance provided as a component in an application integration system. A trigger subsystem includes at least one proprietary trigger subsystem embedded therein at least one standards based trigger subsystem substantially fully embedded therein and common trigger facilities for the at least one proprietary trigger subsystem and the at least one standards based trigger subsystem. The at least one proprietary trigger subsystem and the at least one standards based trigger subsystem are provided as parallel subsystems in the trigger subsystem. A plurality of parallel trigger layers is respectively provided for each said proprietary trigger subsystem and each said standards based trigger subsystem. A plurality of messaging API layers is respectively provided for each said proprietary trigger subsystem and each said standards based trigger subsystem. Each said trigger layer is configured to provide triggers in a format associated with the respective trigger layer. The triggers include instructions for causing a process to be executed in or by the application integration system or a component thereof.

According to certain example embodiments a method of configuring an application integration system is provided. There is provided a messaging layer for use across an integration server or an integration server instance provided as a component in the application integration system. In the messaging layer a trigger subsystem is included. At least one proprietary trigger subsystem is embedded in the trigger subsystem. At least one standards based trigger subsystem is substantially fully embedded in the trigger subsystem. The trigger subsystem is configured to provide common trigger facilities for the at least one proprietary trigger subsystem and the at least one standards based trigger subsystem. A plurality of trigger layers is respectively provided for each said proprietary trigger subsystem and each said standards based trigger subsystem. A plurality of messaging API layers is respectively provided for each said proprietary trigger subsystem and each said standards based trigger subsystem. The at least one proprietary trigger subsystem and the at least one standards based trigger subsystem are provided as parallel subsystems in the trigger subsystem. Each said trigger layer is configured to provide triggers in a format associated with the respective trigger layer. The triggers include instructions for causing a process to be executed in or by the application integration system or a component thereof.

According to certain other example embodiments there is provided a method of operating an application integration system based on a publish and subscribe model or a variant of the publish and subscribe model. There is provided a messaging layer for use across an integration server or an integration server instance provided as a component in the application integration system. The messaging layer includes a trigger subsystem included therein with the trigger subsystem comprising at least one proprietary trigger subsystem embedded therein and at least one standards based trigger subsystem substantially fully embedded therein and with the trigger subsystem being configured to provide common trigger facilities for the at least one proprietary trigger subsystem and the at least one standards based trigger subsystem. Also included in the messaging layer is a plurality of trigger layers respectively provided for each said proprietary trigger subsystem and each said standards based trigger subsystem with each said trigger layer being configured to provide triggers in a format associated with the respective trigger layer. In the triggers instructions are included for establishing subscriptions to publishable document types and for specifying one or more services to process documents received by the subscriptions. One or more documents are published to one or more subscribers in dependence on the instructions included in the corresponding trigger s . Each said document is processed in dependence on the instructions included in the corresponding trigger s . The at least one proprietary trigger subsystem and the at least one standards based trigger subsystem are provided as parallel subsystems in the trigger subsystem.

These aspects and example embodiments may be used separately and or applied in various combinations to achieve yet further embodiments of this invention.

A description of an illustrative application integration system and its example methods of operation will now be provided. It will be appreciated that the following description is provided by way of example and without limitation. Indeed the implementations set forth below reflect the general techniques associated with one publish and subscribe approach to providing application integration solutions developed by the assignee of the instant application which may be used in connection with the messaging layer triggers and trigger subsystems of certain example embodiments.

Referring now more particularly to the drawings is a schematic view of an illustrative application integration system . A plurality of integration servers are shown each being in communication with a broker . A first integration server is shown as is a second integration server which includes a plurality of adapters . An integration server cluster also is shown and it includes a plurality of adapters provided thereto.

In general the integration server is the system s central run time component. It serves as the entry point for the systems and applications to be integrated and it is the system s primary engine for the execution of integration logic. It also provides the underlying handlers and facilities that manage the orderly processing of information from resources or clustered resources inside and or outside the enterprise. The integration server publishes documents to and receives documents from the broker.

The broker forms the potentially globally scalable messaging backbone of the example components described herein. It provides the infrastructure for implementing asynchronous message based solutions that are built on the publish and subscribe model or one of its variants such as for example request reply publish and wait and the like.

The broker routes documents between information producers e.g. publishers and information consumers e.g. subscribers . Thus the broker receives queues and delivers documents. The broker maintains a registry of document types that it recognizes. It also maintains a list of subscribers that are interested in receiving those types of documents. When the broker receives a published document it queues it for the subscribers of that document type. Subscribers retrieve documents from their queues. This action usually triggers an activity on the subscriber s system that processes the document.

Multiple brokers optionally may be provided to a system . Multiple brokers can operate in groups called territories which allow several brokers to share document type and subscription information.

The following is a description of the basic building blocks of an integration solution that uses the publish and subscribe model. These building block include for example documents publishable document types triggers services adapter notifications and canonical documents.

In an integration solution built on the publish and subscribe model applications publish and subscribe to documents. Documents are objects that the above noted components may use to encapsulate and exchange data. A document represents the body of data that a resource passes to the components. Often it represents a business event such as for example placing an order e.g. via a purchase order document shipping goods e.g. via a shipping notice adding a new employee e.g. via a new employee record etc.

Each published document includes an envelope. The envelope is much like a header in an email message. The envelope records information such as for example the sender s address the time the document was sent sequence numbers and or other useful information for routing and control. It includes information about the document and its transit through the system.

Every published document is associated with a publishable document type. A publishable document type is a named schema like definition that describes the structure of a particular kind of document that can be published and subscribed to. An instance of a publishable document type can be published locally within an integration server or can be published to a broker. In a publication environment that includes a broker each publishable document type may be bound to a broker document type. Clients on the broker subscribe to publishable document types. The broker uses publishable document types to determine which clients to distribute documents to.

Within the publish and subscribe model of certain example embodiments described herein triggers establish subscriptions to publishable document types. Triggers also specify the services that will process documents received by the subscription. Within a trigger a condition associates one or more publishable document types with a service.

Services are method like units of work. They contain program logic that the integration server executes. Services may be built to carry out work such as for example extracting data from documents interacting with back end resources publishing documents to the broker etc. When a trigger is built a user may specify the service to be used to process the subscribed to documents.

Adapter notifications notify the system whenever a specific event occurs on an adapter s resource. The adapter notification publishes a document when the specified event occurs on the resource. Each adapter notification has an associated publishable document type. Triggers may be used to subscribe to the publishable document types associated with adapter notifications. The service associated with the publishable document type in the trigger condition may for example perform some additional processing updating and or synchronization e.g. based on the contents of the adapter notification.

A canonical document is a standardized representation that a document may assume while it is passing through the system. A canonical document acts as the intermediary data format between resources. For example in an implementation that accepts purchase orders from companies one of the steps in the process may convert the purchase order document to a company s standard purchase order format. This format is called the canonical form of the purchase order document. The canonical document is published delivered and passed to services that process purchase orders.

By converting a document to a neutral intermediate format subscribers e.g. adapter services only need to know how to convert the canonical document to the required application format. If canonical documents were not used every subscriber would have to be able to decode the native document format of every publisher.

A canonical document is a publishable document type. The canonical document may be used when building publishing services and subscribed to when building triggers. In flow services documents may be mapped from the native format of an application to the canonical format.

An overview of illustrative publish and subscribe paths is now provided with reference to . As noted above integration servers exchange documents via publication and subscription. One integration server publishes a document and one or more integration servers subscribe to and process that document. The integration server generally interacts with the broker to publish and subscribe to documents. For example an integration server may publish documents to the broker an integration server may retrieve documents from the broker and or an integration server may publish and subscribe to documents locally.

When the integration server is configured to connect to a broker the integration server can publish documents to the broker. The broker then routes the documents to all of the subscribers. Three example publishing path scenarios are explained below a document is published to the broker a document is published to the broker when the broker is not available and a document is published to the broker and a reply is waited for e.g. as in a request reply scenario . If a broker is not configured for the integration server all publishes may become local publishes and delivering documents to a specific recipient is not available. This possibility is described in greater detail below.

A publishing service provided to the integration server sends a document to the dispatcher or an adapter notification publishes a document when an event occurs on the resource the adapter monitors S . Before the integration server sends the document to the dispatcher it validates the document against its publishable document type. If the document is not valid the service returns an exception specifying the validation error. The dispatcher obtains a connection from the connection pool S . The connection pool is a reserved set of connections that the integration server uses to publish documents to the broker . To publish a document to the broker the integration server uses a connection for the default client. The dispatcher sends the document to the broker S .

The broker examines the storage type for the document to determine how to store the document S . For example if the document is volatile the broker may store the document in a memory location . If the document is guaranteed the broker may instead store the document in memory and or on disk .

The broker routes the document to subscribers S . If the document was published e.g. broadcast the broker identifies subscribers and places a copy of the document in the client queue for each subscriber e.g. both first and second client queues . If the document was delivered the broker places the document in the queue for the client specified in the delivery request e.g. either first and second client queues . If there are no subscribers for the document the broker returns an acknowledgement to the publisher and then discards the document. If however a deadletter subscription exists for the document the broker deposits the document in the queue containing the deadletter subscription e.g. either or both of first and second client queues . A document remains in the queue e.g. either or both of first and second client queues on the broker until it is picked up by the subscribing client. If the time to live for the document elapses the broker discards the document. The time to live period may be predetermined e.g. by the user. If the document is guaranteed the broker returns an acknowledgement to the dispatcher to indicate successful receipt and storage of the document S . The dispatcher returns the connection to the connection pool . The integration server returns control to the publishing service which executes the next step S .

It is possible to configure publishable document types and the integration server so that integration server does not validate documents when they are published. Also if a transient error occurs while the integration server publishes a document the audit subsystem may log the document and assign it a status of FAILED. A transient error is an error that arises from a condition that might be resolved quickly such as for example the unavailability of a resource related to network issues or failure to connect to a database. A monitor may be used to find and resubmit documents with a status of FAILED. 

A publishing service provided to the integration server sends a document to the dispatcher or an adapter notification publishes a document when an event occurs on the resource the adapter monitors S . Before the integration server sends the document to the dispatcher it validates the document against its publishable document type. If the document is not valid the service returns an exception specifying the validation error. The dispatcher detects that the broker is not available. Accordingly the document may be stored. For example if the document is guaranteed the dispatcher routes the document to the outbound document store e.g. on disk . If the document is volatile the dispatcher discards the document and the publishing service throws an exception. The integration server executes the next step in the publishing service.

When the integration server re establishes a connection to the broker the integration server obtains a single connection from the connection pool S . The integration server automatically sends the documents from the outbound document store to the broker S . To empty the outbound document store more rapidly the integration server may send the documents in batches instead of one at a time. It will be appreciated that the integration server may use a single connection to empty the outbound document store for example to preserve publication order.

The broker examines the storage type for the document determines that it is guaranteed and stores the document in memory and on disk S . The broker routes the document to subscribers S . If the document was published e.g. broadcast the broker identifies subscribers and places a copy of the document in the client queue for each subscriber e.g. both first and second client queues . If the document was delivered the broker places the document in the queue for the client specified in the delivery request e.g. either first and second client queues . If there are no subscribers for the document the broker returns an acknowledgement to the publisher and then discards the document. If however a deadletter subscription exists for the document the broker deposits the document in the queue containing the deadletter subscription e.g. either or both of first and second client queues . A document remains in the queue e.g. either or both of first and second client queues on the broker until it is picked up by the subscribing client. If the time to live for the document elapses the broker discards the document. The time to live period may be predetermined e.g. by the user. If the document is guaranteed the broker returns an acknowledgement to the dispatcher to indicate successful receipt and storage of the document S . The dispatcher returns the connection to the connection pool . The broker returns an acknowledgement to the integration server to indicate successful receipt and storage of the guaranteed document S . The integration server removes the document from the outbound document store .

If it is desirable to keep published documents from being placed in the outbound document store when the broker is unavailable the integration server can be configured to throw an exception instead. After the connection to the broker is re established the integration server may send all newly published documents e.g. guaranteed and volatile to the outbound document store until the outbound store has been emptied. This allows the integration server to maintain publication order. After the integration server empties the outbound document store the integration server may resume publishing documents directly to the broker .

If the integration server makes a predetermined number of attempts e.g. 3 4 5 etc. to transmit a document from the outbound document store to the broker and all attempts fail an audit subsystem may log the document and assign it a status of TOO MANY TRIES. If a transient error occurs while the integration server publishes a document the audit subsystem may log the document and assign it a status of FAILED. It is possible to configure publishable document types and the integration server so that the integration server does not validate documents when they are published. A monitor may be used to find and resubmit documents with a status of TOO MANY TRIES or FAILED. 

A publishing service sends a document e.g. the request to the dispatcher S . The integration server populates a tag field in the document envelope with a unique identifier that will be used to match up the reply document with this request. The publishing service enters into a waiting state. The service will not resume execution until it receives a reply from a subscriber or the wait time elapses. The integration server may begin tracking the wait time as soon as it publishes the document. Before the integration server sends the document to the dispatcher it may validate the document against its publishable document type. If the document is not valid the service may return an exception specifying the validation error. The service may then unblock but with an exception.

The dispatcher obtains a connection from the connection pool S . The connection pool is a reserved set of connections that the integration server uses to publish documents to the broker . To publish a request document to the broker the integration server uses a connection for the request reply client. If the broker is not available the dispatcher may route the document to the outbound document store e.g. as described above. The dispatcher sends the document to the broker S .

The broker examines the storage type for the document to determine how to store the document S . For example if the document is volatile the broker stores the document in memory . If the document is guaranteed the broker stores the document in memory and on disk . The broker routes the document to subscribers S . If the document was published e.g. broadcast the broker identifies subscribers and places a copy of the document in the client queue for each subscriber e.g. both first and second client queues . If the document was delivered the broker places the document in the queue for the client specified in the delivery request e.g. either first and second client queues . If there are no subscribers for the document the broker returns an acknowledgement to the publisher and then discards the document. If however a deadletter subscription exists for the document the broker deposits the document in the queue containing the deadletter subscription e.g. either or both of first and second client queues . A document remains in the queue e.g. either or both of first and second client queues on the broker until it is picked up by the subscribing client. If the time to live for the document elapses the broker discards the document. The time to live period may be predetermined e.g. by the user. If the document is guaranteed the broker returns an acknowledgement to the dispatcher to indicate successful receipt and storage of the document S . The dispatcher returns the connection to the connection pool .

Subscribers retrieve and process the document S . A subscriber uses a service not shown to compose and publish a reply document. This service automatically populates the tag field of the reply document envelope with the same value used in the tag field of the request document envelope. This service also automatically specifies the requesting client as the recipient of the reply document. One or more subscribers send reply documents to the broker S . The broker stores the reply documents e.g. in memory . The broker places the reply documents in the request reply client queue for the integration server that initiated the request.

The integration server that initiated the request obtains a request reply client from the connection pool and retrieves the reply documents from the broker S . The integration server uses the tag value of the reply document to match up the reply with the original request S . The integration server places the reply document in the pipeline of the waiting service S . The waiting service resumes execution.

If the requesting service specified a publishable document type for the reply document the reply document may be required to conform to the specified type. Otherwise the reply document may be an instance of any publishable document type. It will be appreciated that a single request may receive many replies. The integration server that initiated the request may use only the first reply document it retrieves from the broker . The integration server may also discard all other replies. First may be arbitrarily defined. There may be no guarantee provided for the order in which the broker processes incoming replies.

All reply documents may be treated as volatile documents. Volatile documents may be stored in memory and may be lost if the resource on which the reply document is located shuts down or if a connection is lost while the reply document is in transit.

If the wait time elapses before the service receives a reply the integration server may end the request and the service may return a null document that indicates that the request timed out. The integration server may execute the next step in the flow service. If a reply document arrives after the flow service resumes execution the integration server may reject the document and create a journal log message stating that the document was rejected because there is no thread waiting for the document. The publishable document types and the integration server may be configured so that the integration server does not validate documents when they are published.

When an integration server is connected to a broker the path a document follows on the subscriber side includes for example retrieving the document from the broker storing the document on the integration server and processing the document. The subscription path for a document may depend on whether the document was published to all subscribers e.g. broadcast or delivered to an integration server directly.

The dispatcher on the integration server uses a server thread to request documents from a trigger s client queue on the broker S . It will be appreciated that each trigger on the integration server may have a corresponding client queue on the broker . The thread retrieves a batch of documents for the trigger S . The dispatcher places the documents in the trigger s queue in the trigger document store S . The trigger document store may be saved in memory for example. The dispatcher then releases the server thread used to retrieve the documents.

The dispatcher obtains a thread from the server thread pool not shown pulls a document from the trigger queue and evaluates the document against the conditions in the trigger S . If exactly once processing is configured for the trigger the integration server may first determine whether the document is a duplicate of one that has already been processed by the trigger. In such a case the integration server may continue processing the document only if the document is new.

If the document matches a trigger condition the dispatcher executes the trigger service S associated with that condition S . If the document does not match a trigger condition the integration server may discard the document return an acknowledgement to the broker and return the server thread to the server thread pool. The integration server also may generate a journal log message stating that the document did not match a condition.

The trigger service executes to completion e.g. to success or error S . If the trigger service executed successfully the integration server returns an acknowledgement to the broker e.g. if this is a guaranteed document . The integration server then removes the copy of the document from the trigger queue and returns the server thread to the thread pool. If a service exception occurs the trigger service ends in error and the integration server rejects the document. If the document is guaranteed the integration server returns an acknowledgement to the broker . The integration server removes the copy of the document from the trigger queue returns the server thread to the thread pool and sends an error document to indicate that an error has occurred. If a transient error occurs during trigger service execution and the service catches the error wraps it and re throws it as an exception then the integration server waits for the length of the retry interval which may be predetermined and or user specified and re executes the service using the original document as input. If the integration server reaches the maximum number of retries which also may be predetermined and or user specified and the trigger service still fails because of a transient error the integration server treats the last failure as a service error.

After receiving an acknowledgement the broker may remove its copy of the document from guaranteed storage . The integration server may return an acknowledgement for guaranteed documents only. If the integration server shuts down or reconnects to the broker before acknowledging a guaranteed document the integration server may recover the document from the broker when the server restarts or the connection is re established. Thus the documents may be redelivered. If a trigger service generates audit data on an error and includes a copy of the input pipeline in the audit log a monitor may be used to re invoke the trigger service at a later time.

It is possible that a document could satisfy more than one condition in a trigger. However the integration server may execute only the service associated with the first satisfied condition. The processing mode for a trigger determines whether the integration server processes documents in a trigger queue serially or concurrently. In serial processing the integration server processes the documents one at a time in the order in which the documents were placed in the trigger queue. In concurrent processing the integration server processes as many documents as it can at one time but not necessarily in the same order in which the documents were placed in the queue. It will be appreciated that in concurrent processing the integration server may process a number of documents in dependence on the maximum availability of threads which may be configured by a user in certain example embodiments.

If a transient error occurs during document retrieval or storage the audit subsystem may log the document and assign it a status of FAILED. A transient error is an error that arises from a condition that might be resolved later such as for example the unavailability of a resource related to network issues or failure to connect to a database. A monitor may be used to find and resubmit documents with a status of FAILED. Also a trigger may be configured to suspend and retry at a later time if retry failure occurs. Retry failure occurs when the integration server makes the maximum number of retry attempts and the trigger service still fails because of an exception.

The dispatcher provided to the integration server requests documents from the default client s queue on the broker S . It will be appreciated that the default client may be the broker client created for the integration server . The broker places documents in the default client s broker queue only if the publisher delivered the document to the integration server s client ID. The thread retrieves documents delivered to the default client in batches S . The number of documents the thread retrieves at one time is determined by for example the capacity and refill level of the default document store and the number of documents available for the default client on the broker .

The dispatcher places a copy of the documents e.g. in memory in the default document store S . The dispatcher identifies subscribers to the document and routes a copy of the document to each subscriber s trigger queue S . In the case of delivered documents the integration server saves the documents to a trigger queue . The trigger queues are located within a trigger document store which may be saved on disk. The integration server removes the copy of the document from the default document store and if the document is guaranteed returns an acknowledgement to the broker S . The broker removes the document from the default client s queue .

The dispatcher obtains a thread from the server thread pool pulls the document from the trigger queue and evaluates the document against the conditions in the trigger S . If exactly once processing is configured for the trigger the integration server first determines whether the document is a duplicate of one already processed by the trigger. The integration server continues processing the document only if the document is new.

If the document matches a trigger condition the integration server executes the trigger services associated with that condition S . If the document does not match a trigger condition the integration server sends an acknowledgement to the trigger queue discards the document e.g. removes it from the trigger queue and returns the server thread to the server thread pool. The integration server also generates a journal log message stating that the document did not match a condition.

The trigger service executes e.g. to success or error S . If the trigger services executed successfully the integration server returns an acknowledgement to the trigger queue e.g. if this is a guaranteed document removes the document from the trigger queue and returns the server thread to the thread pool. If a service exception occurs the trigger service ends in error and the integration server rejects the document removes the document from the trigger queue returns the server thread to the thread pool and sends an error document to indicate that an error has occurred. If the document is guaranteed the integration server may return an acknowledgement to the trigger queue . The trigger queue removes its copy of the guaranteed document from storage. If a transient error occurs during trigger service execution and the service catches the error wraps it and re throws it as an exception then the integration server waits for the length of the retry interval and re executes the service using the original document as input. If the integration server reaches the maximum number of retries and the trigger service still fails because of a transient error the integration server treats the last failure as a service error.

The integration server may save delivered documents in a trigger document store which may be located on disk. The integration server may save published documents in a trigger document store located which may be in memory. If the integration server shuts down before processing a guaranteed document saved in a trigger document store on disk the integration server may recover the document from the trigger document store when it restarts. Volatile documents may be saved in memory and thus may not be recovered upon restart.

If a service generates audit data on error and includes a copy of the input pipeline in the audit log a monitor may be used to re invoke the trigger service at a later time. As above it is possible that a document could match more than one condition in a trigger. However the integration server executes only the service associated with the first matched condition.

The processing mode for a trigger may determine whether the integration server processes documents in a trigger queue serially or concurrently. In serial processing the integration server processes the documents one at a time in the order in which the documents were placed in the trigger queue. In concurrent processing the integration server processes as many documents as it can at one time but not necessarily in the same order in which the documents were placed in the queue.

If a transient error occurs during document retrieval or storage the audit subsystem logs the document and assigns it a status of FAILED. A monitor may be used to find and resubmit documents with a FAILED status. A trigger may be configured to suspend and retry at a later time if retry failure occurs. Retry failure occurs when the integration server makes the maximum number of retry attempts and the trigger service still fails because of an exception.

A publishing service provided to the integration server sends a document to the dispatcher S . Before the integration server sends the document to the dispatcher it validates the document against its publishable document type. If the document is not valid the service returns an exception specifying the validation error. The dispatcher either determines which triggers subscribe to the document and place a copy of the document in each subscriber s trigger queue saving locally published documents in a trigger document store e.g. located on disk or if there are no subscribers for the document discards the document S .

The dispatcher obtains a thread from the server thread pool pulls the document from the trigger queue and evaluates the document against the conditions in the trigger S . If exactly once processing is configured for the trigger the integration server first determines whether the document is a duplicate of one already processed by the trigger. The integration server continues processing the document only if the document is new. If the document matches a trigger condition the dispatcher executes the trigger service associated with that condition S . If the document does not match a trigger condition the integration server sends an acknowledgement to the trigger queue discards the document e.g. removes it from the trigger queue and returns the server thread to the server thread pool.

The trigger service executes to completion e.g. to success or error S . If the trigger service executed successfully the integration server sends an acknowledgement to the trigger queue e.g. if this is a guaranteed document removes the document from the trigger queue and returns the server thread to the thread pool. If a service exception occurs the trigger service ends in error and the integration server rejects the document removes the document from the trigger queue and returns the server thread to the thread pool. If the document is guaranteed the integration server sends an acknowledgement to the trigger queue . If a transient error occurs during trigger service execution and the service catches the error wraps it and re throws it as an exception then the integration server waits for the length of the retry interval and re executes the service using the original document as input. If the integration server reaches the maximum number of retries and the trigger service still fails because of a transient error the integration server treats the last failure as a service error.

It is possible to configure publishable document types and the integration server so that the integration server does not validate documents when they are published. The integration server may save locally published documents in a trigger document store which may be located on disk. If the integration server shuts down before processing a locally published guaranteed document the integration server may recover the document from the trigger document store when it restarts. The integration server may not recover volatile documents when it restarts. If a service generates audit data on error and includes a copy of the input pipeline in the audit log a monitor may be used to re invoke the trigger service at a later time.

It is possible that a document could match more than one condition in a trigger. However the integration server may execute only the service associated with the first matched condition. The processing mode for a trigger determines whether the integration server processes documents in a trigger queue serially or concurrently. In serial processing integration server processes the documents one at a time in the order in which the documents were placed in the trigger queue. In concurrent processing the integration server processes as many documents as it can at one time but not necessarily in the same order in which the documents were placed in the queue. It also is possible to configure a trigger to suspend and retry at a later time if retry failure occurs. Retry failure occurs when the integration server makes the maximum number of retry attempts and the trigger service still fails because of an exception.

An overview of the steps for building a publish and subscribe solution is now provided. In brief on the publishing side a user creates publishable document types for the documents that are to be published and services to process the incoming documents that are published by the publishing side. On the subscribing side the user creates services that publish the documents and triggers that associate the incoming documents with services that processes the documents.

In greater detail a first step to building an integration solution involves defining the problem and determining how to solve the problem using the publish and subscribe model. When designing the solution it may be helpful to determine the documents that will need to be published subscribed to. This information is helpful when creating the publishable document types. Similarly it also may be helpful to determine how the documents ought to be published. This information is helpful when creating the services that publish the documents. Finally it may be helpful to determine how to process the documents. This information is helpful when creating the services that process the documents.

In a second step the production configuration is determined. In some cases it may be desirable for the development environment to mirror the production environment. Issues to consider include whether all the document publishing and subscribing will be performed on a single integration server or whether multiple integration servers will be used if multiple integration servers are used whether a cluster will be configured and whether a broker will be used in the production environment. In a third step the publishable document type s is are created. That is after the documents that will be published is determined on the publishing side the publishable document types are created.

In a fourth step the publishable document types are made available. To create services that process documents and triggers that subscribe to documents the subscribing side generally needs the publishable document types that define the documents that will be published. When the development environment is a single integration server the publishing side and the subscribing side are developed on the single integration server. Thus in general no actions are needed to make the publishable document types available to other developers. After the publishable document type for the publishing side is created the publishable document type is immediately available for the subscribing side to use. However when the development environment includes multiple integration servers with a broker the publishing side and subscribing side each are developed on separate integration servers connected by a broker. Thus when the publishable document type is created a corresponding broker document type is automatically created on the broker. Publishable document types may be made available to other developers. This may be made possible by creating a publishable document type from the broker document type. It also may be made possible by using package replication to distribute publishable document types to developers working with other integration servers. In this case when other developers receive the package they may install the package and then synchronize the document types by pulling them from the broker.

In a fifth step on the publishing side the services that will publish the documents to the broker or locally on the same integration server are created. In a sixth step on the subscribing side the services that will process the incoming documents are created. When creating a service to process a document a document reference may be included in the input signature to the publishable document type for the published document. In this way it is possible to reference the data in the document using the fields defined in the publishable document type.

In a seventh step the triggers are defined. On the subscribing side triggers are created to associate one or more publishable document types with the service that processes the published documents. To associate a publishable document type with the service a condition in the trigger can be created that identifies the publishable document type being subscribing to and the service to invoke when a document of that type arrives. It is possible to further refine the condition by adding filters that specify criteria for the contents of a published document. When the trigger is saved the integration server uses the conditions in the trigger to define subscriptions to publishable document types. Further details on trigger design and configuration are provided below.

In an eighth step the publishable document types are synchronized. When a broker is included in the integration solution each publishable document type has a corresponding broker document type on the broker. shows the two sides of a publish and subscribe model integration solution with publishable document types being associated with the same broker document type. In a publish and subscribe integration solution both the publishing side and the subscribing side use the same publishable document type . The publishing side uses the publishable document type when publishing the document to the broker to identify the type of document being published. The subscribing side references the publishable document type in the trigger to indicate the type of document being subscribed to. For the integration solution to work correctly the publishable document type on the publishing side and the subscribing side should reference the same broker document type .

The following describes how to make a publishable document type correspond to the same broker document type based on the development environment. Where the development environment involves one integration server when the integration solution is moved into production the publishing side and subscribing side may be on different integration servers that are connected by a broker. Thus it may be necessary to synchronize to create the broker document types associated with the publishable document types. Accordingly on the publishing side during synchronization the publishable document types are pushed to the broker to create the broker document type on the broker. Package replication may be used to create and distribute packages containing the publishable document types. On the subscribing side the package containing publishable document types created by the publisher is installed. During synchronization document types are pulled from the broker to update the publishable document types.

Where the development environment involves multiple integration servers with a broker because the broker was used during development the publishable document types on both the publishing side and subscribing side may already correspond to the same broker document types. Nevertheless a simple synchronization of all document types may be used to ensure that the publishable document types are synchronized with broker document types.

Further details regarding triggers will now be provided. Triggers establish subscriptions to publishable document types and specify how to process instances of those publishable document types. When a trigger is built one or more conditions are created. A condition associates one or more publishable document types with a single service. The publishable document type acts as the subscription piece of the trigger. The service is the processing piece. When the trigger receives documents to which it subscribes the integration server processes the document by invoking the service specified in the condition.

Building a trigger is a process that involves the following basic stages. A new trigger on the integration server is created. During this stage the new trigger is created on the integration server where development and testing will be performed. One or more conditions for the trigger are created. During this stage publishable document types are associated with services filters to be applied to incoming documents are created and join types are selected. Trigger properties are set. During this stage parameters that configure the run time environment of this trigger are set such as for example trigger queue capacity document processing mode trigger service retry limit and exactly once processing. Testing and debugging may be performed on the trigger.

The service that processes a document received by a trigger is called a trigger service. A condition generally specifies a single trigger service. Before a trigger can be enabled the trigger service must already exist on the same integration server. Additionally the input signature for the trigger service needs to have a document reference to the publishable document type. The name for this document reference is the fully qualified name of the publishable document type. The fully qualified name of a publishable document type may conform to a set format such as for example folder.subfolder PublishableDocumentTypeName.

When a trigger is saved the integration server may evaluate the trigger and specifically the conditions in the trigger to make sure that the trigger is valid. If the integration server determines that the trigger or a condition in the trigger is not valid an error message may be displayed to the user and the trigger may be disabled. In certain implementations a trigger may be considered valid when each of the following is true the trigger contains at least one condition each condition in the trigger specifies a unique name each condition in the trigger specifies a service each condition in the trigger specifies one or more publishable document types if multiple conditions in the trigger specify the same publishable document type the filter applied to the publishable document type is the same in each condition the syntax of a filter applied to a publishable document type is correct and the trigger contains no more than one join condition.

In general a trigger can subscribe to publishable document types only. Multiple triggers and multiple conditions within a trigger can reference the same publishable document type. At run time for each trigger the integration server invokes the service specified for the first condition that matches the publishable document type criteria.

The trigger layer enables the above described broker trigger services which interact with the integration server broker trigger subsystem and facilities as described above. These layers enable access to the proprietary e.g. broker messaging API layer . The broker API may be distributed and or implemented via JAR files. Thus the right side of the messaging layer provides a rich set of features that may interact with an integration server or integration server instance through proprietary messaging layers to provide an application integration solution.

As noted above to provide interoperability and or communications over an open standards based messaging protocol appropriate messaging protocols e.g. JMS messaging may be enabled through the use of an adapter. Thus on the left side of the messaging layer a JMS adapter layer is provided to interface with the JMS API layer which may be enabled using the standard JMS interfaces provided by the JDK. Thus the left side of the messaging layer provides interoperable and or open messaging features that may interact with an integration server instance through the JMS related layers to provide an application integration solution.

As will be readily appreciated from the current messaging layer does not include a trigger subsystem for the left side of the messaging protocol. Thus applications built on the JMS adapter lack the extended capabilities of the broker trigger subsystem. As such with the current messaging layer users were forced to choose between interoperability and standards based messaging and processing on the one hand and more powerful proprietary messaging and processing on the other.

The solution to this problem implemented in certain example embodiments involves fully embedding JMS as a peer to the proprietary messaging protocol in the integration server trigger subsystem so that all or substantially all existing capabilities would be JMS enabled.

Accordingly is an illustrative block diagram representing a messaging layer in accordance with an example embodiment. As in the message layer of this messaging layer of certain example embodiments may sit on both the integration server or an instance of the integration server as shown in and the broker as separate implementations which is not the case shown in . It could be present on any provider such as for example one that supports JMS messaging. However through the use of the messaging layer of certain example embodiments JMS messaging may be enabled without the use of a special adapter provided to the integration server. Furthermore in certain example embodiments such a messaging layer may make it possible to avoid making any changes to the JMS trigger itself e.g. may enable standard JMS messages in a regular format to be used and or may reduce the need for custom programming and or implementation at the application service level in certain example cases.

As will be appreciated from the left side of the messaging layer essentially mirrors the right side thereof. In particular a JMS trigger layer is provided as a counterpart to the broker trigger layer and a JMS subsystem which helps take the place of the JMS adapter is a counterpart to the broker trigger subsystem . The same JMS messaging API layer and proprietary broker messaging API layer are still provided. However there is included in the messaging protocol a trigger subsystem which provides common trigger facilities. Trigger subsystem is provided as a value added layer above individual trigger subsystems thereby enabling the parallel subsystems to function.

Certain example embodiments enable the trigger subsystem by taking one or more of the following specific measures. First the integration server trigger namespace entity is extended and adapted to include properties and settings specific to JMS messaging. The trigger namespace is a named object that enables configuration regarding how long to wait for messages and how to process such messages when they are received. It may be organized for example as a named hierarchy of folders. For example the following construct represents an instruction as to how a business application should process order documents as they are received bussapp.processpo handlineincomingprocessingorder. The namespace may be organized as a tree and configuration may be performed at the node level.

Second the integration server trigger administration capabilities are extended and adapted to include options specific to JMS e.g. an alternate throttling scheme . Such administrative capabilities are useful in regulating the flow of messages into the system e.g. to reduce the chances of the system becoming overwhelmed . Administration may be performed globally and or on the trigger level. Example functionality includes regulating suspending trigger acceptance and or processing.

Third the integration server trigger clustering model is extended and adapted for JMS. It will be appreciated that clustering e.g. as provided behind a load balancer may provide for increased scalability and survivability. In certain example embodiments the same trigger may be used on one or more integration servers.

Fourth the integration server trigger join mechanism is extended and adapted for JMS. In a join operation a trigger waits for multiple documents if the process calls for the processing of all documents at once. Fifth the integration server trigger ordered service execution mechanism is extended and adapted for JMS. The ordered service execution guarantees in order processing if multiple documents are involved. Sixth implementation of integrated transaction handling is provided for the trigger subsystem for JMS messages. Transaction handling involves tying a processing sequence to a transaction. The processing sequence may then be committed as a whole transaction or changes may be rolled back if any operation in the transaction fails.

Also in certain example embodiments certain custom extensions are provided for cases where the broker is used as the JMS provider itself. For example a single step e.g. JNDI configuration multi server failover e.g. shared client mode and or streaming large message processing may be enabled. Indeed the configuration capabilities provided by certain example embodiments simplify the custom programming and implementation requirements of the current techniques. For example certain example embodiments provide a menu based configuration tool as compared to requiring actual programming.

The standard flow for message processing involves pre processing processing and post processing. Pre processing involves message retrieval and evaluation which may include for example cluster support duplicate detection transaction initiation and the like. Processing involves service dispatch which may include for example local filter processing concurrency of application join and ordered service execution evaluation and the like. Post processing involves message acknowledgement which may include for example error and retry handling transaction completion and the like.

These configuration techniques provide certain illustrative advantages. For example because message handling and processing is addressed through triggers the capabilities built into the integration sever can be leveraged. Because the trigger construct of certain example embodiments is unique so too is the JMS based delivery mechanism. Moreover even though the conventional broker provides the rich feature set through a proprietary protocol with reduced interoperability and JMS messaging provides interoperability with reduced features certain example embodiments provide both interoperability over standards based messaging protocol and a powerful feature set. Thus providing an extension to messaging layer reduces and sometimes eliminates the need for custom development of messaging layers adapters and or applications using such custom messaging layers and or adapters. As such it is possible to avoid repeated recoding which often is done in a non standard way with the same and further functionality instead being provided in a configuration based manner.

Thus the general advantages include richly enhanced fully interoperable standards based e.g. JMS based message processing the ability to use alternate e.g. JMS messaging providers in addition to or in place of the proprietary broker and the ability to connect to more than one messaging provider simultaneously e.g. one broker and or any number of JMS providers . Specific illustrative advantages provided by the trigger subsystem may include in certain example implementations declarative configuration of listeners for one or more JMS destinations e.g. queues or topics configured concurrency for server load control e.g. threads may be available per trigger and or globally global and per trigger runtime administration e.g. monitoring suspension and resumption capacity management etc. once and only once processing e.g. guaranteed processing duplicate detection error retry etc. automated transient error handling and recovery e.g. for temporarily unavailable backend applications cluster support for message processing e.g. providing scalability availability and failover features stream based messaging for large documents e.g. to reduce memory overload conditional message processing based on joins such as or and xor which are useful in business process model execution ordered service execution for sequences of ordered messages integrated local and XA transaction support client side queuing for messaging e.g. to support JMS provider unavailability local filters e.g. beyond limited JMS selector capability etc.

It will be appreciated that as used herein the terms system subsystem service programmed logic circuitry and the like may be implemented as any suitable combination of software hardware firmware and or the like.

While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment it is to be understood that the invention is not to be limited to the disclosed embodiment but on the contrary is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.

