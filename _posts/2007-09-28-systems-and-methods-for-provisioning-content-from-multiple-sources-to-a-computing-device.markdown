---

title: Systems and methods for provisioning content from multiple sources to a computing device
abstract: A system for provisioning content to at least one user is described. A content provisioning server is used. The content provisioning server includes a content provisioning application in communication with a user database. The content provisioning application is configured to access the user database to identify a user, determine rights of the user from the user database, and send a user interface to a client computing device that provides user interface items corresponding to the rights and associated links of the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08103673&OS=08103673&RS=08103673
owner: PresenceID, Inc.
number: 08103673
owner_city: Salt Lake City
owner_country: US
publication_date: 20070928
---
This application is related to and claims priority from U.S. Provisional Patent Application Ser. No. 60 827 841 filed Oct. 2 2006 for PRESENCEID CONTENT PROVISIONING with inventor David A. Doane which is incorporated herein by reference and

This application is also related to and claims priority from U.S. Provisional Patent Application Ser. No. 60 828 015 filed Oct. 3 2006 for PRESENCEID TREE MANAGER with inventor Douglas Walker which is incorporated herein by reference.

The present invention relates generally to computers and computer related technologies. More specifically the present invention relates to systems and methods for provisioning content from multiple sources to a computing device.

Computer and communication technologies continue to advance at a rapid pace. Indeed computer and communication technologies are involved in many aspects of business operations. For example a business may be located in numerous places with computers at each location. Computers may allow a business to maintain data relating to the business operations customers services etc. Employees of a business may enter the data into the computers by utilizing business applications that run on the computers. Applications may also allow the employee to manage the data after it has been entered into the computer.

Data stored in a computer or a computer system is typically organized into a file a database or another type of data repository. It is not uncommon for an enterprise e.g. corporation small business non profit institution government body etc. to have data stored in several different types of data repositories. There may be many reasons for this. For example an enterprise may have inherited some data repositories as a result of mergers acquisitions or the like with other enterprises. Alternatively different departments within the same enterprise may have different needs which are best satisfied by different types of computer systems having different types of data repositories. The different data repositories maintained by an enterprise may be located in a variety of different computer systems which may be dispersed around an office around a campus or even around the world.

Many businesses maintain many computer systems at various locations. A computer system at one location may differ from a computer system at another location. In particular application data and or databases on one computer system may differ from application data and or databases on other computers.

As shown many different kinds of data and computer systems may be used in today s workplace. Often employees need to use and or access many different kinds of systems and data on an almost daily basis. As such benefits may be realized by improved systems and methods for providing access for this content from multiple sources to one or more computing devices.

A system for provisioning content to at least one user is described. A content provisioning server is used. The content provisioning server includes a content provisioning application in communication with a user database. The content provisioning application is configured to access the user database to identify a user determine rights of the user from the user database and send a user interface to a client computing device that provides user interface items corresponding to the rights and associated links of the user.

The content provisioning application may be further configured to access a tree manager database to obtain the user interface and to send tree manager code that provides the user interface to the client computing device.

The user interface may include a tree user interface. The tree user interface may include a list of content that the user has rights and associated links to access. The tree user interface may be for a web browser.

The content may include files applications and systems. The content may further include services links web portals and mashup services.

A method for provisioning content to at least one user is also described. User information is received from a client computing device. A user database is accessed to identify a user using the user information. Rights of the user are determined from the user database. A user interface is sent to the client computing device that provides user interface items corresponding to the rights and associated links of the user.

A system for provisioning content to at least one user is described. A content provisioning server is used. The content provisioning server includes a content provisioning application in communication with a user database. The content provisioning application is configured to access the user database to identify a user determine rights of the user from the user database and send a user interface to a client computing device that provides user interface items corresponding to the rights and associated links of the user. The client computing device includes a web browser for displaying the user interface. The client computing device also includes a queue structure for storing changes to the user interface.

Various embodiments of the invention are now described with reference to the Figures where like reference numbers indicate identical or functionally similar elements. The embodiments of the present invention as generally described and illustrated in the Figures herein could be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of several exemplary embodiments of the present invention as represented in the Figures is not intended to limit the scope of the invention as claimed but is merely representative of the embodiments of the invention.

The word exemplary is used exclusively herein to mean serving as an example instance or illustration. Any embodiment described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments.

Many features of the embodiments disclosed herein may be implemented as computer software electronic hardware or combinations of both. To clearly illustrate this interchangeability of hardware and software various components will be described generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

Where the described functionality is implemented as computer software such software may include any type of computer instruction or computer executable code located within a memory device and or transmitted as electronic signals over a system bus or network. Software that implements the functionality associated with components described herein may comprise a single instruction or many instructions and may be distributed over several different code segments among different programs and across several memory devices.

As used herein the terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments certain embodiments one embodiment another embodiment and the like mean one or more but not necessarily all embodiments of the disclosed invention s unless expressly specified otherwise.

The term determining and grammatical variants thereof is used in an extremely broad sense. The term determining encompasses a wide variety of actions and therefore determining can include calculating computing processing deriving investigating looking up e.g. looking up in a table a database or another data structure ascertaining and the like. Also determining can include receiving e.g. receiving information accessing e.g. accessing data in a memory and the like. Also determining can include resolving selecting choosing establishing and the like.

The phrase based on does not mean based only on unless expressly specified otherwise. In other words the phrase based on describes both based only on and based at least on. 

A tree is a data structure that organizes data elements into a manageable structure. Tree data structures are typically arranged in a hierarchical data scheme. A tree structure may be used to handle different kinds of systems or data including but not limited to organizational structures in a business entity or file systems on a computer system. With the advent of graphical interfaces there are several different implementations to manage complex and unbalanced tree structures. As used herein the graphical interface to manage the tree structures may be referred to as a tree manager.

The menu shown may be dynamically altered to reflect the authorizations of the current user. Menus may be represented in a variety of fashions. The sidebar menu may be used in many enterprise applications. This technique may be used for provisioning content or content provisioning.

Graphical user interfaces representing a tree structure can be a programming challenge. Many implementations of a tree structure are client server applications and may have substantial interaction with data structures.

Typical client server tree structures implemented on the World Wide Web may operate in the following manner. The server may build a tree structure as HTML Hypertext Markup Language and send it to the web browser. For a tree of even moderate complexity this is an involved process that will typically take several seconds on some systems. The web browser may then render the tree structure. The HTML stream often contains scripting language commands which are often JavaScript. The scripts provide the capability to expand and contract the graphical representation of the tree. Rendering an edited tree can take several seconds for most web browsers. A common alternative to embedded JavaScript is that the browser returns to the server each time the graphical tree structure is edited. This process is slow from a user s perspective and resource expensive from the system s perspective. Rendering an edited tree can often take several seconds for many Web browser implementations. The user may then modify the tree structure displayed in the browser. The edit is sent to the server. The server may then modify the data structure of the tree and repeat this process for the next edit.

The present systems and methods may use a tree structure to solve several different problems. First an unbalanced tree structure is an excellent manner to catalog and organize the products and services that an enterprise wishes to organize manage and provision. These services may be application oriented web pages reports application services machine oriented servers peripherals network connections or content oriented data files graphical content . Since a tree structure groups services it facilitates the process of granting authorization to a group of services rather than requiring an administrator to enumerate each individual service as is common today. In the various configurations herein changing the tree structure of services may automatically adjust authorizations to applications machines and services.

A tree structure may be used to represent the organization of an enterprise entity. Content may be associated with different points and levels of the organization creating an authorization scheme that is easy to understand organize and maintain.

Most tree structures are read many thousands of times for every instance they are modified and edited. Most common tree structures in use today are not implemented to optimize read activity. The process of reading a tree data structure is a processor intensive activity for the underlying data store system usually a relational database management system RDBMS because it requires many individual read requests. This intensive database read activity often translates into poor end user client display performance especially for web applications with the extra burden of securely transmitting and rendering HTML screens that can be displayed by a browser. On the other hand update activity is relatively quick and does not require much in the way of resources to process.

A tree manager shown in may manage changes and edits to the tree structures in a manner that reduces resource and time requirements. One optional feature of the tree manager may be to quickly and inexpensively resolve which nodes of the tree belong to a higher level node of the same tree. Another optional feature of the tree manager may be to quickly resolve which higher level nodes of the tree own a particular node. These two activities may be relational queries rather than a resource expensive recursive query the technique most often employed in systems and application tree structures. This is accomplished by employing a sequential key in the tree manager database for all of the nodes of the tree structure. The sequential key assures that all of the children nodes for any particular parent node will be represented by a discrete range of keys. The key of the parent can be used to determine the lower bound of the range. The upper bound of the range is stored with the parent node. To maintain this structure the entire tree structure may be modified with each change or edit.

In one configuration the tree structure is modified with each change or edit. The tree manager may not require any dedicated client code or plug ins for the browser to manage edit or display its tree structure. Thus the client machine does not need to be altered.

Some code may be sent to the browser with the rendering of the tree structure. In one possible configuration JavaScript code is sent to the browser with the HTML rendering of the tree structure. The result is a responsive full featured tree manager that manages the complexities of the tree structure and creates a responsive and positive user experience.

The user examines and potentially modifies the tree structure in the browser . In one possible implementation the update events are not sent to the server at this point. The discrete transactions are stored in a queue structure on the browser or local to the browser . When the user decides to save the changes and edits to the tree structure the queue of update events may be sent to the server as a hidden field in the HTML form.

The server builds the original tree structure from the database and then executes the update transactions in the order they were executed on the browser . The result is a new tree structure that the operator can then save.

The server writes the new tree structures to the database . In the process all of the records of the original tree structure are replaced. This process assures that the nodes are arranged with sequential keys and that each parent nodes is stored with the upper bound of the children nodes. This process may be repeated as needed for each tree structure served up to a browser .

In operation the content provisioning application checks the rights and authorizations of a user in a user database and then the application provides a tree structure user interface to the tree manager that shows what content the user has access to. In some implementations the tree user interface does not show content that the user does not have authorization for. Referring back to the particular user would have rights to each of the items in the tree structure shown in the virtual directory .

Content provisioning offers the option of presenting the menu of options using the browser s inherent capabilities. Most browsers have the ability to create a tree like menu of favorites or bookmarks . Bookmarks and favorites are a list of URL s and or local machine file names that are organized and managed by the computer s operator.

Content provisioning installation may present a web page with the ability to download a menu to the browsers favorites or bookmarks to the user s local machine . During installation the content provisioning detects content provisioning generated menus that were previously downloaded and allows the user the option of replacing them. In one possible implementation content provisioning does not require a plug in to the browser or alter the local machine s configuration to which the browser is installed.

At installation content provisioning may detect the type of browser that the user is employing and transmit a web page containing the appropriate menu structure to be built and JavaScript code in one possible implementation that can be executed to deploy the menu. The content provisioning application running on the server may access a tree manager database to obtain the tree structure menu to transmit to the user . The user may execute the code to create the menu structure by simply pressing a button on the web page. The menu structure is then deployed to the favorites or bookmarks section of the browser . The code to create the menu structure may be JavaScript which employs commands native to the browser .

Content provisioning can aggregate and provide content that any given user is authorized to have access too. Content can be files applications systems services links portals individually or in combination. Combining content into a compound service can be accomplished in a number of technologies for example a batch file that executes a series of commands on a variety of applications sequentially. Code that is written to create a new application using other existing applications is often called a mashup. A mashup service may be provisioned the same as any other piece of content to users who are authorized to access it.

The contents within a mashup may include data and applications from any system regardless of architecture and physical location. Additionally a mashup service requires no changes to the constituent content data files applications or services. Using mashup services content provisioning is able to provision mainframe based data and applications as easily as a client server peer to peer P2P distributed software as a service SaaS with this mashup service capability with no changes to the data and applications.

The content provisioning application may provide rights based management of simple and compound content services in a service oriented architecture to a tree structure in a browser . The content provisioning application may access a database to obtain the rights and or authorizations of a particular user .

Many different kinds of databases may be used to store and manage information relating to a user and content . For example a database may store many user records that include data attributes for the user s rights and authorizations . These different kinds of databases may be used in combination with the content provisioning discussed herein. One possible implementation of a database management system that has the ability to integrate multiple databases and or systems will be set forth below with references to . Although the discussion in may be more general in its description the systems and methods therein may be used as an exemplary database system for managing users data content services etc.

Most business applications include two general types of data. The first may be transactional data. Examples of transactional data may include orders shipments invoices payments etc. Transactional data may utilize a high degree of control in order to maintain its integrity. This type of data may be managed by a single highly integrated application which may be highly dynamic or attended by a large volume of activity.

The second type of data may include reference data. Examples of reference data may include customers employees products services accounts locations etc. While an important level of control may be utilized in order for reference data to maintain its integrity it may be common for several business applications in an enterprise to maintain the same reference data. It may be beneficial if this type of data could be created edited changed deleted etc. by each individual business application in the manner that is was designed to function. Further it would be beneficial if each individual business application could share common data with the other business applications in the enterprise. For example it may be beneficial if all of the systems in a business that deal with a certain customer could identify that customer in the same way.

Transactional data may be controlled by tightly coupled data management techniques. For example a change to an order amount may occur in the same database transaction that affects the inventory levels of the product. However tightly coupled application systems are more expensive to develop and maintain than loosely coupled application systems.

Reference data generally doesn t require tightly coupled data management techniques. Instead this type of data can generally be handled with loosely coupled data management techniques. A change to an individual s address in one application should be shared with all of the other applications within the business enterprise but it may be acceptable if it takes several seconds or minutes to synchronize this changed data with the other applications.

The present systems and methods enable a business enterprise to loosely couple reference data with the multiple business systems applications and infrastructure. The present systems and methods may loosely couple reference data with asynchronous messages which may guarantee delivery of the message to each system and application within the business enterprise. For example the present systems and methods allow an application to complete a change to an attribute associated with reference data and continue the normal operations the application is designed to perform. The present systems and methods may operate in the background and send a message including information about the change to additional systems and applications within the business enterprise. When the additional applications are available they may accept the message and process the change.

A benefit of the present systems and methods is that if any systems are unavailable for any reason i.e. off line the integrity of the reference data will not be jeopardized. The remaining systems that are available will continue to be synchronized and continue with accurate updated data attributes.

Current systems and methods generally require data structures of the different applications to be identical or very similar. At the very least the reference data typically has been required to share a common data attribute that uniquely identifies reference data. Such requirements have not enabled current systems and methods to be sufficiently loosely coupled. Further it is expensive for dissimilar applications to share reference data.

System A and system B may include any type of computing device such as a personal computer laptop personal digital assistant PDA computer server etc. Systems A and B may include application A and application B respectively. Applications A and B may include software that employs the capabilities of systems A and B to execute a task. In one embodiment applications A and B may utilize different data structures. Different data structures may be suited to different types of applications such as applications A and B .

Systems A and B may also include application A database and application B database respectively. The databases may include a stored collection of data that may be accessed by applications A and B . In one embodiment systems A and B may also include spoke manager A and spoke manager B respectively. Spoke managers A and B may send receive data to from applications A and B respectively. In addition spoke managers A and B may send receive data to from application A database and application B database respectively. In one embodiment spoke manager A sends receives data to from application A in a first format . In another embodiment spoke manager B sends receives data to from application B in a second format . The first format may be different from the second format . Spoke manager A may also send receive data to from the system . In one embodiment spoke manager A sends receives data to from the system in a third format . In another embodiment spoke manager B also sends receives data to from the system in the third format .

Spoke managers A and B may communicate with the system over network A and network B respectively. While the illustrated embodiment only illustrates two networks it is to be understood that the system may communicate with any number of systems over any number of networks. In one embodiment the system includes a hub manager . The hub manager may act as a broker for all the data sent to or received from the various systems and applications. For example the hub manager may send receive messages to from the various systems and applications. In one embodiment the hub manager may include a repository . The repository may store data included within the various systems communicating with the system such as systems A and B . In one embodiment repository may include a plurality of reference objects such as reference object A and reference object B . Reference object A and B may be a record of data relating to the identity of an individual product etc. For example reference object A may be an employee record and reference object B may be a customer record. Each reference object includes common data attributes. Reference object A may include common data attributes A and reference object B may include common data attributes B . Common data attributes may include data that is shared between systems such as system A and system B . An example of a common data attribute may include the name of the entity being identified by the reference object. Further examples of common data attributes may include an address date of birth email address etc.

In one embodiment spoke managers may be deployed to each system and application within a business enterprise. Spoke managers may communicate directly with the hub manager and translate standard messages sent from the hub manager to the system or application. Data translations or data transformations may include data mapping and data formatting. In one embodiment data mapping identifies the location of specific required data in a table of one system and application and maps it to a location of data with the same attributes of another system and application. In one embodiment data formatting defines a physical format of the data.

Each spoke manager may be very specific to the particular business system or application on which it resides. Including spoke managers with every system and application may allow a business enterprise to scale more easily. For example the addition of another business application simply means adding a new spoke manager specific to that application. In one embodiment adding additional systems or applications does not require changes to the hub manager because the spoke manager provides the translation of data formats between the systems and applications and the hub manager . In one embodiment business systems and applications may be deployed on a variety of technology platforms data management tools and application development environments.

Spoke manager A and spoke manager B may implement a unique data attribute to uniquely identify each reference object. For example spoke manager A may implement unique data attribute A and spoke manager B may implement unique data attribute B to identify reference object A . Similarly spoke manager A may implement unique data attribute C and spoke manager B may implement unique data attribute D to uniquely identify reference object B . In one embodiment the repository is aware of each unique data attribute and the value of such attribute that each spoke manager implements to identify a particular reference object. The following scenario may further illustrate this concept.

A human resource system of a business may implement the unique data attribute of Employee id to uniquely identify the reference object of an employee record of the employee associated with the employee identification indicated by Employee id . An accounting system of the same business may use the unique data attribute of Employee tax id to uniquely identify the employee record of an employee. For purposes of illustration the Employee id may be 789 and the Employee tax id may be A52 . The employee record may include one or more common data attributes such as name address date of birth etc. In one embodiment the employee with the Employee id of 789 may change his her address through an application on the human resource system. The accounting system may not be able to be updated with the new address because the accounting system identifies employee records with a different data attribute i.e. Employee tax id .

In one embodiment the repository stores the employee s information such that the hub manager is aware that the employee identification is 789 and the employee tax identification is A52 . The repository may translate a message associated with Employee id 789 that is updating a common data attribute to a message that includes Employee tax id A52 before the message is sent to the accounting system.

In this embodiment the hub manager is aware of which unique data attribute and its value each spoke manager uses to uniquely identify a reference object. The hub manager is also aware of each of the plurality of reference objects that a particular enterprise may use i.e. employee records customer records product record etc. . Further the hub manager is aware of each common data attribute included with each reference object. The repository associates each reference object with the unique data attribute each spoke manager uses to uniquely identify the reference object.

Application A database and application B database may include one or more reference objects such as reference object A . Reference object A may identify a particular type of entity that is associated with one or more common data attributes. For example reference object A may identify customers employees business entities products services accounts locations etc. In one embodiment reference object A may include common data attributes relating to the entity identified by reference object A . In the depicted embodiment the reference object A identifies a customer and may include common data attributes further relating to the identity of the customer. It is to be understood that additional reference objects may include common data attributes that further relate to the identity of other entities in addition to customers. In one embodiment reference object A includes common data attributes such as name NetID account number and email address . While only four examples of common data attributes are listed it is to be understood that reference object A may include other common data attributes. For example common data attributes may include date of birth residential address business address social security number account numbers etc.

Spoke manager A and spoke manager B may each uniquely identify the reference object A with a different unique data attribute. For example spoke manager A may identify reference object A using unique data attribute A while spoke manager B identifies reference object A using unique data attribute B .

In addition application A and application B may use different common data attributes of reference object A . For example application A may use the common attributes of name NetID account number and email address . Application may use the common data attributes of data of birth address and telephone number .

In one embodiment application A database may have previously stored the name Jim Bowen . When application A communicates the name Ed Bowen to application A database the name Jim Bowen may change to the name Ed Bowen . This scenario may illustrate the situation where the first name entered Jim Bowen was incorrect and should have been Ed Bowen. In this embodiment the common data attribute of name is changed.

In one embodiment spoke manager A may send a message including the change in the common attribute of name to the hub manager . In an additional embodiment the message may include all the common data attributes included with the reference object . For example the reference object may include several common data attributes such as email NetID address etc. A change to any common data attribute such as the may cause a synchronization message to be sent which includes all of the common data attributes of the reference object . In other words the message may include common data attributes that have not been modified. In the illustrated example the hub manager detects from the synchronization message that a common data attribute of the reference object has changed.

Spoke manager A may gather all the common data attributes of the reference object and perform data translations if necessary. Spoke manager A may package the message in a first data format . In one embodiment spoke manager A includes translator A which facilitates the translation of the reference object if necessary. The message may be in the form of a simple record that includes unique data attribute A . Unique data attribute A may be used by spoke manager A to uniquely identify the reference object . Spoke manager A may send the message to the hub manager over network A . Changes to common data attributes associated with the reference object may be communicated to the hub manager . In a further embodiment application A updates reference information by writing a queue record in application A database . Spoke manager A may monitor the database and take action based on the queue records in the database . In another embodiment application A may not include an application programming interface API that spoke manager A may work with. In this instance spoke manager A may access data directly from application A database .

In the illustrated example the hub manager detects from the synchronization message that a common data attribute of the reference object has changed. In one embodiment the hub manager may define a packet of information for the reference object which includes all the common data attributes of the reference object . The packet of information included in the hub manager may be a superset of data from each system and application including the reference object . In one embodiment the hub manager maintains a repository with the reference object and each of the common data attributes of the reference object . In addition as previously explained the repository includes which unique data attribute each spoke manager of various system uses to unique identify the reference object .

In one embodiment the hub manager may receive the message which includes unique data attribute A . The hub manager is aware that spoke manager A uses unique data attribute A to identify the reference object . The hub manager may processes the message in order to update the common data attributes associated with the reference object stored in the repository . For example the common data attribute of name is changed from Jim Bowen to Ed Bowen .

Spoke manager A may send the message in the first data format to a data manager over network A . In one embodiment the data manager is included within a hub manager . In one embodiment spoke manager A may require additional information in order to build the message. Additional information may be retrieved from the hub manager in order to build a complete message. For example the additional information may be retrieved through synchronous web services messages. In one embodiment the data manager receives requests from spoke manager A for the web services.

The hub manager processes the message and determines which reference object is identified from the unique data attribute included in the message. In this example the message includes unique data attribute A which identifies the reference object . In one embodiment the common data attribute of name included in the reference object is changed from Jim Bowen to Ed Bowen . The reference object stored in the repository may be updated with the changed common data attribute included in the message.

A message generator may generate a synchronization message that includes updates to any of the common data attributes of the reference object . A collision detector may be used before the hub manager sends synchronization messages to other spoke systems to notify them of any updates to common data attributes. The collision detector detects the most recent synchronization message for a given reference object and only allows the most current messages generated by the message generator to be sent to additional spoke managers. Collision detection occurs when a particular spoke system is synchronized on a scheduled time interval as opposed to an on demand synchronization. In one embodiment the hub manager is aware which spoke managers are configured for a scheduled synchronization and when that is to occur. Synchronization messages may be placed in a cue between scheduled synchronization events and only the most recent messages are sent and the others are discarded at that time. The collision detector verifies that only the most accurate common data attributes are included on each reference object in every spoke system that needs that particular common data attribute.

The synchronization message may be sent to application B through spoke manager B . Because the hub manager is aware that spoke manager B uses unique data attribute B to identify reference object the message may include unique data attribute B . Spoke manager B may receive the message in the first data format with unique data attribute B . In one embodiment translator B translates the message to a suitable format that may be used by application B or application B database. In one embodiment the message may be a series of messages requests depending on the API of application B . Spoke manager B may communicate directly with application B database if application B does not allow a public API. Spoke manager B translates the message becomes aware that the message pertains to common data attributes of the reference object because of unique data attribute B . The message includes all the common data attributes associated with the reference object . Spoke manager B determines which common data attributes are applicable to the reference object used by application B . In other words spoke manager B may ignore some of the common data attributes in the message if they do not pertain to application B.

In some embodiments a unique data attribute may be changed. For example referring to the previous example the human resource system may change the employee tax identification for an employee from A52 to B46 . In this example the Employee tax id is used by the spoke manager B to uniquely identify the employee record. The hub manager may generate a key change message if the unique data attribute used by another spoke manger is altered.

In one embodiment application A may access application A database and store a queue record if changes to common data attributes have occurred. Application A and the system including application A such as system A may include native built in workflow capabilities. In one embodiment application A may include a workflow manager to manage these workflow capabilities. Spoke manager A may monitor application A database for a queue record. If a queue record is detected by spoke manager A spoke manager A may package a synchronization message that includes all of the common data attributes of the reference object and sends the message to a hub manager. In a further embodiment spoke manager A may gather all the common data attributes of the reference object by making requests of application A through an API or by accessing application A database directly if there is no API available.

In one embodiment a notification may be communicated to an authenticator when a queue record is stored in application A database . The authenticator may include a system administrator who may accept or reject the storage of the queue record. In another embodiment the authenticator may include computer software that automatically accepts or rejects the queue record according to certain parameters determined by the system administrator. For example the system administrator may program the software to accept changes relating to the common data attribute of name and reject changes the account number common data attribute . If the queue record is rejected spoke manager A does not build a message to send to a hub manager over network A .

The message may include all the common data attributes associated with the reference object. The message may also include the unique data attribute used by the receiving spoke manager to uniquely identify the reference object. In one embodiment the receiving spoke manager has sufficient contextual information to translate for differences in data structures keys application technologies and business rules. In a further embodiment the receiving spoke manager may translate any differences and synchronize the data with its internal data structures.

In one embodiment a message may be received in the second format. In one embodiment the message may be received from the hub manager . The message may be translated to a third format. In one embodiment the third format may be a format specific to a particular system and application. The message may be sent to the system and application that is specific to the third format.

The system may also include a network interface . The network interface facilitates communication between the system and other devices connected to a network which may be a pager network a cellular network a global communications network the Internet a computer network a telephone network etc. The network interface operates according to standard protocols for the applicable network.

The system may also include memory . The memory may include random access memory RAM for storing temporary data. Alternatively or in addition the memory may include read only memory ROM for storing more permanent data such as fixed code and configuration data. The memory may also be embodied as a magnetic storage device such as a hard disk drive. The memory may be any type of electronic device capable of storing electronic information.

The system may also include one or more communication ports which facilitate communication with other devices. The system may also include input output devices such as a keyboard a mouse a joystick a touchscreen a monitor speakers a printer etc.

Of course illustrates only one possible configuration of a system . Various other architectures and components may be utilized.

Information and signals may be represented using any of a variety of different technologies and techniques. For example data instructions commands information signals bits symbols and chips that may be referenced throughout the above description may be represented by voltages currents electromagnetic waves magnetic fields or particles optical fields or particles or any combination thereof.

The various illustrative logical blocks modules circuits and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

The various illustrative logical blocks modules and circuits described in connection with the embodiments disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array signal FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The steps of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an ASIC. The ASIC may reside in a user terminal. In the alternative the processor and the storage medium may reside as discrete components in a user terminal.

The methods disclosed herein comprise one or more steps or actions for achieving the described method. The method steps and or actions may be interchanged with one another without departing from the scope of the present invention. In other words unless a specific order of steps or actions is required for proper operation of the embodiment the order and or use of specific steps and or actions may be modified without departing from the scope of the present invention.

While specific embodiments and applications of the present invention have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and components disclosed herein. Various modifications changes and variations which will be apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems of the present invention disclosed herein without departing from the spirit and scope of the invention.

