---

title: Layout manager
abstract: Various technologies and techniques are disclosed for managing layout updates to user interface elements. A dirty state of user interface elements is tracked in a tree with multiple nodes of user interface elements. The dirty state allows dirty subtrees of the nodes to be identified. A root node is identified for each of the dirty subtrees. Affected portions of the tree are updated, starting with the root node that was identified for each of the dirty subtrees. As part of the update process, changes to ancestor nodes are detected and used to make a layout process more efficient. For example, any layout processes that are currently being performed on any descendant nodes of a changed ancestor are abandoned, and the layout process is resumed at the changed ancestor. After updating affected portions of the tree, the updated user interface elements are then rendered on an output device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08095865&OS=08095865&RS=08095865
owner: Microsoft Corporation
number: 08095865
owner_city: Redmond
owner_country: US
publication_date: 20071121
---
Modem computer operating systems have the ability to present and manage graphical user interface elements on an output device such as a monitor or printer. When a graphical user interface element is created within an application the item is sized and placed appropriately for rendering on the output device. Similarly when an existing graphical user interface element is modified or removed within an application or a new user interface element is added the output device must reflect this change appropriately. Existing computer operating systems make use of device drivers to communicate with particular output devices thus sparing a software developer from the messy details of rendering graphical output on specific output devices. Existing computer operating systems accomplish this by publishing Application Programming Interfaces APIs to prospective software developers.

Generally an API is a set of high level function calls made available to a software developer that are independent from the low level instructions necessary for any particular device. The platform or operating system with the aid of device drivers typically performs any needed translation of the high level API calls to the low level device specific calls.

Nevertheless although a software developer may not wish to concern himself with implementing how his application s graphical user interface elements are physically displayed or rendered on any particular output devices the developer may be interested in how those elements are logically laid out and managed. For example a software developer may wish to develop a graphical user interface that displays its menus or arranges icons in a particular manner. Or a developer may wish to develop an application that arranges and displays multiple graphical user interface elements in a single document in a particular fashion. Some tools have given software developers certain abilities to manage graphical layouts but such abilities are often complex or inefficient.

Various technologies and techniques are disclosed for managing layout updates to user interface elements. The dirty state of user interface elements is tracked in a tree of user interface elements. The tree contains multiple nodes of user interface elements and the dirty state allows dirty subtrees of the nodes to be identified. A root node is identified for each of the dirty subtrees. Affected portions of the tree are updated starting with the root node that was identified for each of the dirty subtrees. After updating affected portions of the tree the updated user interface elements are then rendered on an output device.

In one implementation changes to ancestor nodes are detected and used to make a layout process more efficient. A layout process is started on a specified node. A determination is made as to whether or not any ancestors of the specified node have changed. If at least one changed ancestor of the specified node is identified then any layout processes that are currently being performed on any descendant nodes of the changed ancestor are abandoned and the layout process is resumed at the changed ancestor.

In another implementation a layout status can be invalidated for a specified node. A determination is made as to whether or not a specified node is already dirty. If the specified node is not already dirty then the specified node is marked as dirty and a determination is made as to whether or not the specified node is an ancestor of at least one node that is currently being laid out measured or arranged . If the specified node is the ancestor of at least one node that is currently being laid out then all nodes on a direct path from the specified node to the node that is currently being laid out measured or arranged are marked as having a dirty ancestor but not including the specified node.

This Summary was provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

The technologies and techniques herein may be described in the general context as a layout manager application that coordinates the update of sizes and positions of user interface elements on an output device but the technologies and techniques also serve other purposes in addition to these. In one implementation one or more of the techniques described herein can be implemented as features within a platform such as MICROSOFT Silverlight an operating system such as MICROSOFT WINDOWS or from any other type of program or service that is responsible for coordinating updates to user interface elements on an output device.

In one implementation a layout manager is provided that coordinates the updating of the size and position of user interface elements so the updates can then be rendered on an output device. The term user interface element as used herein is meant to include any user interface object such as listboxes combo boxes tree structures radio buttons calendars windows forms panels and combinations thereof. New implementations of user interface objects are being constantly created and these examples disclosed also embrace user interface elements that have not specially been named. The user interface elements are organized into a tree of nodes so that their status can be tracked and updated. The term tree as used herein is meant to include multiple user interface elements that are represented in a hierarchy or other structure that allows relationships between the user interface elements to be identified. The term node as used herein is meant to include an individual user interface element within a tree of multiple user interface elements.

As parts of a given program run that impact user interface elements the layout manager uses the tree of nodes to track these changes to the user interface elements. For example one or more status indicators can be updated for a node in the tree to identify that one or more details of the user interface element have changed. As a non limiting example code may have executed that changes the font size for the text that is contained in a particular text box on the user interface. In one implementation a dirty indicator is marked on the changed node to flag the node as having one or more changed details that may need updating the next time the user interface is re rendered. These status indicators are tracked by the layout manager and are then used to determine what updates should be rendered for the user interface elements for the given program displayed on an output device.

For example the status indicators can be used by a layout process that is called by the layout manager before re rendering updates to the user interface. The term layout process as used herein is meant to include the process of sizing and positioning of user interface elements. The term laid out as used herein is meant to include the fact that a user interface element has been sized and positioned to reflect the changes that have impacted this user interface element thus far. A layout process can include a measure process and or an arrange process. A measure process is a process that deduces how big a particular user interface element wants to be. During a measure process a node determines the size it requires by determining the size required by all of its children or if the node has no children by the size the node itself requires. When measuring its children if any the node provides a size constraint which is typically the size the parent has left to allocate to the children the node has yet to measure the size limitation may also be unbounded in one or both dimensions. In one implementation regardless if a node has children or not other constraints such as height minimum height maximum height width maximum width and minimum width may also be used if they have been specified. An arrange process is a process where a parent element notifies a child node of the position and of the size which that child node has been allocated to display itself in. This may be less than greater than or equal to the size that the node indicated it required in the measure process. The node will position and size itself on the screen accordingly. Properties such as stretch mode horizontal alignment and vertical alignment may also be used to determine the node s position and or size if specified.

In some implementations described in further detail in the status of changes that have occurred on ancestor nodes are used to make a layout process e.g. measure and or arrange processes perform more efficiently. The term ancestor node as used herein is meant to include any predecessor node that is contained in an upward linear chain to a specified node. The term parent node as used herein is meant to include an immediate parent node e.g. the father of a specified node. When performing a layout process measure and or arrange process for a given node the layout manager determines if any ancestor nodes have changed. If any ancestor nodes have changed then any layouts measures and or arranges in process for descendant nodes e.g. child nodes beneath the changed ancestor are abandoned and the layout process measuring or arranging is resumed at the changed ancestor. If any ancestor nodes to the specified node have not changed then the layout process measuring and or arranging continues by going down a path of descendant nodes. In one implementation by recognizing that changes to ancestors have been made wasted work can be avoided by processing changes at an ancestor level as opposed to a descendant level. This work could otherwise have been spent on processing changes to descendant nodes that could then become outdated when updates were later processed for ancestor nodes. Some of these techniques will now be explored in further detail.

As shown in an exemplary computer system to use for implementing one or more parts of the system includes a computing device such as computing device . In its most basic configuration computing device typically includes at least one processing unit and memory . Depending on the exact configuration and type of computing device memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line .

Additionally device may also have additional features functionality. For example device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and need not be discussed at length here. In one implementation computing device includes layout manager application . Layout manager application will be described in further detail in .

Turning now to with continued reference to a layout manager application operating on computing device is illustrated. Layout manager application is one of the application programs that reside on computing device . However it will be understood that layout manager application can alternatively or additionally be embodied as computer executable instructions on one or more computers and or in different variations than shown on . Alternatively or additionally one or more parts of layout manager application can be part of system memory on other computers and or applications or other such variations as would occur to one in the computer software art.

Layout manager application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for coordinating the update of sizes and positions of user interface elements as described below with respect to logic for tracking the dirty state of user interface elements in a tree of elements as described below with respect to logic for updating affected portions of the tree of elements as described below with respect to logic for using special state on nodes in the tree to find roots of dirty subtrees to avoid wasted recalculations during updates as described below with respect to and other logic for operating the layout manager application .

Turning now to with continued reference to the stages for implementing one or more implementations of layout manager application are described in further detail. In some implementations the processes of are at least partially implemented in the operating logic of computing device . provide some high level examples of using ancestor changes to make a layout process more efficient. describe some more detailed techniques for applying these broader concepts to exemplary implementations.

Turning now to a process flow diagram is shown that illustrates one implementation of the stages involved in using a status of ancestor changes to make a layout process measure arrange etc. more efficient. A layout process is called for a given node stage . The layout manager application determines if any ancestor nodes to the given node have changed stage . If any ancestor s have changed decision point then the layouts in process for descendant nodes beneath the changed ancestor are abandoned stage and the layout process is resumed at the changed ancestor stage . If no ancestor s have changed decision point then the layout process continues by going down the path of descendants stage .

Turning now to a process flow diagram is shown that illustrates one implementation of the stages involved in marking a parent node as dirty when a node s size has changed to avoid wasted work. A layout process is started for a specified node stage . If the node s desired size has changed decision point then a dirty indicator is marked on the parent node of the specified node stage the current layout process is abandoned stage and the layout process is performed on the parent stage as described in further detail in other figures. If the node s desired size has not changed decision point then the layout process continues with the next sibling of this node stage .

If arrange is not dirty somewhere in the tree decision point then any queued size changed events are fired stage to allow the application to execute optional custom code in response to an element changing its size before the element has been displayed with its new size. If the tree is dirty decision point then the process loops back up to decision point . If the tree is not dirty decision point then the layout updated events are fired stage to allow the application to execute custom code in response to an update layout operation completing before any of the updated elements have been displayed with their new sizes and or positions. If the tree is dirty decision point then the process loops back up to decision point . If the tree is not dirty decision point then the process exits stage .

Turning now to a process flow diagram is shown that illustrates one implementation of some detailed stages involved in performing a layout process on a specified node. If the specified node itself is not dirty decision point then layout manager checks to see if the specified node has a dirty descendant decision point and follows the processing for the dirty descendant path as described momentarily. If the specified node itself is dirty decision point then the layout process is performed on the specified node stage . If an ancestor node has now been marked as dirty decision point then the layout process is abandoned for the specified node stage .

If an ancestor node has not been marked as dirty decision point after performing a layout on the specified node then layout manager determines whether the specified node has a dirty descendant decision point . Layout manager also determines whether the specified node has a dirty descendant if the specified node itself was not found dirty in decision point . In either case if the specified node does not have a dirty descendant decision point then the layout process exits stage . If the specified node does have a dirty descendant decision point then the next child is retrieved stage and laid out stage . After laying out the child layout manager determines whether an ancestor has been marked as dirty decision point . If so decision point then the layout process is abandoned stage . If an ancestor has not been marked as dirty decision point then layout manager determines whether the node itself is dirty decision point . If the node itself is dirty decision point then the layout process is performed for the node stage and the other stages following the layout processes performed as described previously. If the node itself is not dirty decision point then the next child is processed if there are more children stage . If there are not more children decision point then the process loops back up to processing the next sibling node of current parent in the dirty subtree stage .

In one implementation six different indicators are maintained on each node in order to make some of the decisions described above and to determine how to efficiently handle the updates. The six exemplary indicators are shown below.

In other implementations fewer or additional indicators can be used. These indicators will now be used in the following code sample for the sake of illustration. This sample walks through some exemplary code for performing the layout processes described in .

As is noted above in the UpdateLayout procedure the measure process is called if the display area size changed or the root has IsMeasureDirty or onPathToMeasureDirty flags set to true i.e. is either dirty itself or has a dirty descendant . Otherwise if the root has the IsArrangeDirty or IsOnPathToArrangeDirty flags set then the arrange process is called.

The measure and arrange processes shown in the exemplary code samples then recursively loop through the tree of nodes as appropriate to determine whether to measure or arrange upward with ancestors or downward with descendants depending on the evaluation of various criteria described therein and in .

Some exemplary source code is shown below to illustrate the process of in further detail. In the example shown an InvalidateMeasure process checks to see if the specified node is already on the stack i.e. already being measured and if so the InvalidateMeasure process exits. The specified node is marked as dirty and then the ancestor nodes are marked as being dirty.

These non limiting code examples were just provided for further illustration of some of these techniques. It will be appreciated by those in the computer software art that there are numerous other ways source code could be written to implement some or all of the techniques described herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. All equivalents changes and modifications that come within the spirit of the implementations as described herein and or by the following claims are desired to be protected.

For example a person of ordinary skill in the computer software art will recognize that the examples discussed herein could be organized differently on one or more computers to include fewer or additional options or features than as portrayed in the examples.

