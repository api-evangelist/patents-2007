---

title: Memory efficient data processing
abstract: Memory efficient data processing is provided in a computer environment. A data representation or description is utilized to reduce memory footprint. A data structure can be serialized iteratively utilizing the representation rather than first loading the entire data structure to memory. Portions of the data structure can be materialized to and removed from memory as function of operational need.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037096&OS=08037096&RS=08037096
owner: Microsoft Corporation
number: 08037096
owner_city: Redmond
owner_country: US
publication_date: 20070629
---
The pervasiveness of computers and other processor based devices has resulted in data proliferation such that vast amounts of digital data are created and stored daily. Although originally the sole domain of well funded companies and research institutions technology advancements and cost reductions over time have enabled computers and other electronic devices to become commonplace in the lives of most everyone. As a result both businesses and consumers create and interact with large amounts of digital data.

Traditionally a database management system DBMS is employed to manage interaction with database data. The DBMS efficiently manages requests or queries from users and programs so that these entities are free from having to know specifics pertaining to how and where data is physically stored. Furthermore in handling requests the DBMS ensures integrity and security with respect to the data. The most common DBMS is a relational database management system RDBM . In this system data is stored in a tabular format wherein data resides at the intersection of a row and a column.

With the advent and growing popularity of the Internet and other networking technologies various other structured data languages or formats have been developed to facilitate storing and sharing of information across different technology systems. One such language is XML eXtensible Markup Language which is a standard language that allows entities and or groups to share information in a convenient fashion. This language uses tags or symbols to markup or describe content. Another format that enables sharing of data is JSON JavaScript Object Notation . JSON is a lightweight data exchange format rather than a markup language that utilizes a collection of name value pairs and arrays of values to represent data. XML and JSON can capture various computer data structures e.g. objects lists trees for storage and or transmission.

A myriad of application programming interfaces APIs and or language implementations can be employed to process structured data. For example XML data can be formatted queried and or transformed by XSLT XQuery and or XPath. Furthermore similar mechanisms can be utilized for serializing or streaming such data. Conventionally such mechanisms load an entire data structure in memory and subsequently perform operations over the materialized data structure.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to memory efficient data processing. Rather than attempting to materialize an entire data structure in memory prior to performing any operation thereon materialization can be deferred. A data structure can be materialized at a later time as function of a particular operator to optimize system resources and or data processing.

In accordance with an aspect of the disclosure rather than materializing the structure itself a much smaller representation that describes the structure can be materialized. In one instance the representation can be executed iteratively to serialize data element by element. Here the entire structure need not be loaded in memory at the same time. Single elements or small groups of elements can be materialized in memory serialized and subsequently thrown away. In another instance portions of a described data structure can be materialized in memory to enable query operations. By deferring materialization and or lazily materializing data unnecessary work can be avoided including loading large amounts of data in memory. Not only is this more efficient than a conventional approach but it can enable data processing where it might not otherwise be possible given a large data structure and small memory for instance.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods are provided for processing data in a computer environment. A data representation can be utilized as a default means of processing data. For data serialization operations the data representation can be executed iteratively or sequentially to retrieve data for output or transmission to a computer readable medium. In other instances select portions of the data structure identified by the representation can be materialized to enable operation execution. The materialized portion can subsequently remain in memory or such space be reclaimed as function of an optimization analysis.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a data processing system is depicted in accordance with an aspect of the claimed subject matter. The system optimizes system resource utilization and or processing of data. Prior to processing conventional systems materialize or attempt to materialize an entire data structure into memory for processing. However if the data structure is sufficiently large in size and or the memory is rather small the process is unaffordable. Further even if the structure can fit in memory it may be wasteful to use an in memory representation if there is no immediate use for an in memory representation.

By way of example suppose it is desired that a given in memory object be traversed and an XML or HTML view extracted so that it can be stored in a file system or sent to a different application on the same or different computer. The XML view may potentially require so much memory that it would not be possible to materialize the view in memory or alternatively it would be wasteful to use an in memory representation in the application that generates the view because this application has no immediate use for an in memory representation. The system affords a solution to this issue.

The system includes a constructor component that provides a mechanism for loading or populating memory component e.g. cache RAM flash . . . with data. The constructor component need not perform such function at random. In fact the constructor component can load the memory component as a function of a data representation operator and or other input from execution component . Based on this information the construction component can load the memory component in a manner that preserves resources yet also enables efficient operation execution.

The data representation also referred to as data description and descriptive data representation identifies or describes data rather than being the data itself although broadly it can be considered a type of data . In other words the representation can identify computations of structures rather than the structures themselves. For instance consider a set of numbers from one to one hundred million. Each of the numbers from one to one hundred million can be considered data described by the following declaration Start from one and increment by one until one hundred million. Accordingly the data representation can correspond to a function method query or any other mechanism for identifying or describing data or portions thereof.

The operation is the particular type of data processing to be done. The operation can be received retrieved or otherwise acquired or obtained by the construction component . For instance the operation can be provided or retrieved externally or from the execution component . Alternatively the operation can be inferred as a function of contextual information such as the data representation previous runs and or execution component behavior. A number of operations are possible including saving or serializing querying and transforming data to name but a few.

The execution component executes an operation utilizing corresponding data loaded in the memory component by the construction component . The execution component can receive or retrieve the operation to execute externally. It can subsequently or concurrently provide the operation and or operation identity to the construction component . Additionally or alternatively the execution component can notify the construction component to load the memory component . Execution of an operation can produce output as a function of the operation including a serialized data structure or query result among other things.

Functionality provided by the constructor component and the execution component can vary based on a particular operation. Referring briefly to a representative constructor component and execution component are provided along with the below description to clarify some operational differences.

Turning first to the representative constructor component includes an operation analyzer component and a build component . The operation analyzer component analyzes an operation and instructs the build component concerning materialization of data to memory. As will be described in further detail below a data representation or description can be loaded to memory by default or upon identification of a save or serialization operation. Alternatively where a query or other operation is detected by the operation analyzer component the build component can build or materialize a data structure to memory. Moreover where operation analyzer component can determine that an operation is interested in solely a particular portion of data then the build component can materialize only that portion of data thereby preserving memory for other operations.

Referring to the representative execution component is shown. The execution component includes a serial component and a query component . The serial component provides a mechanism for computing or executing a data representation or description. Furthermore the execution can be iterative such that data elements can be retrieved one by one. The query component is a query processing mechanism to enable the execution component to satisfy queries of materialized data structures in memory.

In general the system of can operate in two distinct modes based on whether the operation corresponds to serialization or some other operation such as a query. Serialization is a unique case since it pertains to simply running though data and outputting each element. No relational element information needs to be maintained to respond to queries regarding element parents children or the like. In one instance a file can be opened data written thereto and subsequently closed. In this situation data can be generated in a serialization oriented fashion without use of a full in memory representation. A descriptive data representation need not be eagerly materialized to memory but rather deferred. More particularly the representation can simply be loaded to memory and executed iteratively to serialize elements one at a time. This conserves system resources and optimizes performance as a data structure does not first need to be materialized to memory including all relationships and other extraneous information.

Consider again the example of serialization of the numbers one to one hundred million. Rather than eagerly attempting a lengthy process of materializing numbers one through one hundred million in memory if even possible materialization can be deferred until a later time when such information is needed. Moreover only a data representation or description need be loaded not the entire set of numbers. The representation can indicate that the data is a collection of integers that starts at one and each subsequent number is incremented by one up to one hundred million. This representation here a function can then be executed serially or iteratively such that the numbers are produced or materialized one by one and subsequently or concurrently serialized to a computer readable medium communication stream or the like. Furthermore as the data structure is iterated over memory utilized by materialized elements can be thrown away or made available for reuse by subsequent materialized elements.

The other distinct mode can be to materialize data completely to memory. In this manner all data element relationships can be captured. The materialized structure can subsequently be utilized to respond to queries and optionally update the data structure among other things. However this mode suffers from previously described problems including increased time required to materialize the complete structure and memory occupation if enough space is available space to hold the structure .

In accordance with an aspect of the claimed subject matter a hybrid can exist that merges the two distinct modes. Similar to the serialization mode materialization of a data structure can be deferred. Stated differently materialization can be executed lazily such that it is put off until as late as possible because it might mean that work need not be performed. This can accommodate a serialization operation which is likely the most common scenario. Where a serialization operation is specified for instance in various reporting applications the data description can be loaded in memory and iterated through generating elements one at a time as previously described. Alternatively if a query or other operator is to be executed than at least a portion of data structure can be materialized to memory. In accordance with one aspect the materialization can be limited as function of an operation domain. For example if it can be determined or inferred that the operation is concerned with a particular portion of a data structure then only that portion should be materialized. In this manner the operation can be executed while minimizing resource use among other things.

Turning to exemplary graphical illustrations of data materialization are provided with respect to the distinct and hybrid modes to facilitate clarity and understanding. Here the data structures correspond to trees. However the claimed subject matter is not limited thereto.

The hybrid on in this continuum is depicted in . In this case a portion of data structure is materialized while another is not. In this case it may have been determined that an operation was only interested in sub tree A. Accordingly that portion of the tree is materialized while the remainder of the tree is captured by the data representation. In other words a portion of the tree can be inflated. This is simply one example. The tree can include various combinations of materialized and non materialized portions as a function of operations executed thereon.

Returning to it is to be appreciated that data processing system can be implemented or embodied in a number of ways. For instance the constructor component and execution component form part of an application programming interface API a program language implementation and or a compiler amongst other things. Furthermore the functionality can be performed in aggregate or separately. For example a single API can developed and employed that automatically materializes an entire structure performs deferred materialization or operates as a hybrid based on a variety of factors including operations to be performed. Alternatively there can be multiple APIs that can be utilized by programmers to control whether a data structure is eagerly materialized e.g. XElement deferred e.g. XDeferredElement or a hybrid of the two e.g. XHybridElement .

Further yet it is to be appreciated that low level unparsing APIs can be employed to materialize data structures in a serialization oriented fashion. However use of these low level APIs requires special programming skills and it is cumbersome as well as error prone. In accordance with an aspect of the claimed subject matter data can be materialized in a more compositional than imperative way. More specifically a declarative method is supported that can employ functional programming like idioms such as expression oriented data construction and compositional queries as well as lazy execution where necessary.

Referring to an optimized data processing system is illustrated in accordance with an aspect of the claimed subject matter. Similar to system of the system includes the constructor component execution component and memory component as previously described. In brief the constructor component can load the memory component with appropriate data for execution of an operation by execution component . The system also includes an optimization component to optimize data processing and or system resource utilization. As previously noted a spectrum or continuum can exist between eager and deferred materialization. The optimization component can identify and seek to obtain an optimal position on such a continuum with respect to processing and resource use.

For example consider a hybrid scenario in which a portion of a data structure is materialized to memory to facilitate execution of an operation. A decision can be made concerning whether or not the materialized structure should remain in memory or be released for reuse. While a default can exist a default s static nature can result in sub optimal performance. The optimization component can determine and effectuate an optimal solution utilizing context information. For example if memory is scarce or demand is high the optimization component can release the memory for garbage collection and reuse. Alternatively a decision can be made to keep a materialized data structure where it can be determined or inferred that it is likely that future operations will need the data structure. In general the optimization component make a decision based on cost of materialization and or maintenance in memory and value associated with alternate use.

For purposes of clarity and understanding what follows is an exemplary use case for serialization. This provides more concrete detail pertaining to how aspects of the disclosure can be employed and or embodied. It is to be noted that the following is merely exemplary and is not intended to limit the scope of the claimed subject matter.

Consider a scenario in which an HTML Hyper Text Markup Language representation of a given object graph is extracted such that fields of each object are listed and all sub objects are recursively turned into HTML. A web browser should be able to render the HTML in real time namely as the .html file is generated sequentially.

Using C and a designated type XDeferredElement for serialization oriented XML trees declarative code can be devised for the creation of the HTML view. A portion of the code is shown below. A more complete version of the code is provided in the attached Appendix.

The example is written in functional programming style such that the result e.g. the HTML view is constructed with the expression oriented idiom of functional construction XDeferredElement dl . . . recursion is used to descend into the object graph list processing idioms handle the list of fields cf from field in . . . select . . . .

One characteristic of the encoding is that the query for the recursive treatment of sub objects is stored as is by its parenting XDeferredElement instance. The query is executed only when the XDeferredElement instance is serialized later. The XML tree HTML tree is not materialized in memory.

Furthermore serialization semantics as opposed to an in memory semantics can be achieved without sacrificing idiomatic convenience of an in memory API. That is for comparison consider the following variation on the fragment above. It uses an in memory XML tree type XElement and the replacement of XDeferredElement by XElement is indeed the only required change.

Without loss of generality an API for in memory XML trees can leverage an object type XElement with the following capabilities 

As an illustration the following case discrimination on content of XDeferredElement instances handles monolithic attributes XAttribute in memory nodes XNode interim text string serialization oriented trees XDeferredElement and embedded queries IEnumerable . One can assume that the shown Serialize method is declared by an auxiliary serializer object that is created and directly invoked from the Save method above. Low level code for serializing nodes and attributes and strings is elided while the important insight is bolded. Embedded queries are executed such that each element of the resulting list is serialized immediately and individually without keeping any handle on an element once its serialization has completed.

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems and methods may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation optimization component can utilize such mechanism to optimize data processing and resource utilization.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a method of data processing is depicted in accordance with an aspect of the claimed subject matter. At reference numeral a data representation describing data is acquired. For example this can correspond to a method function and or query among other things. At numeral an operation to be performed is identified such as serialization query update etc. Memory is populated with the least amount of data necessary to perform the identified operation at . In this manner resources can be utilized more intelligently rather than simply attempting to load an entire data structure in memory where it is not necessary. At numeral the operation is executed utilizing the data provided in memory and any output provided.

Turning to a method of serializing data is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral a data representation is loaded in memory. This representation can describe data to be serialized declaratively and or imperatively. At numeral the data representation is evaluated iteratively or serially. In other words data can be materialized element by element as a list is iterated. The materialized data can subsequently be output at reference numeral . In sum rather than eagerly materializing a data structure to memory materialization is deferred until serialization. Further the entire structure is not kept in memory at the same time. Instead data elements are materialized and serialized iteratively and thrown away after they have been processed. This makes efficient use of memory.

The hybrid method of data processing provides for deferred data processing to facilitate efficient memory utilization among other things. Rather then always materializing an entire data structure to memory the method can load a description of the data which almost always will be significantly smaller that the materialized structure itself. In this way it is similar to the method for serializing data. This is a good starting point since serialization is more likely to be performed than any other operation. Upon analysis of an operation to be performed data structures can be materialized. However only a pertinent portion of the structure needs to be constructed. In some cases this can correspond to the entire data structure but in many other cases this will be a segment thereof enabling resources to be used more efficiently.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers . For example a client can acquire a data structure from a server over the communication framework for processing e.g. serialization query . . . . Additionally or alternatively data can be serialized over the communication framework to either a client and or a server for further processing or saving to a local store and respectively.

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

