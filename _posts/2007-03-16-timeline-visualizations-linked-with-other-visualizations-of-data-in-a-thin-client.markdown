---

title: Timeline visualizations linked with other visualizations of data in a thin client
abstract: An apparatus in one example has: a controller having a data connector for inputting temporal data, and an item collection for providing timelines and overlays, and for providing linked visualizations of the temporal data in a timeline to other visualizations of the temporal data; and a display for displaying the timeline and overlays, and the linked visualizations. The method may have the steps of: obtaining temporal data; displaying the temporal data in at least one timeline in a web browser and in at least one other visualization in the web browser; and linking the displayed data in the at least one timeline with the displayed data in the at least one other visualization.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08560946&OS=08560946&RS=08560946
owner: VisTracks, Inc.
number: 08560946
owner_city: Lisle
owner_country: US
publication_date: 20070316
---
This application is a continuation of U.S. Provisional Patent Application 60 784 700 filed Mar. 22 2006 which is now U.S. Non Provisional patent application Ser. No. 11 670 859 filed Feb. 2 2007. Also this application claims priority to U.S. Provisional Patent Application 60 784 700 filed Mar. 22 2006 which is now U.S. Non Provisional patent application Ser. No. 11 670 859 filed Feb. 2 2007 and U.S. Provisional Patent Application 60 865 786 filed Nov. 14 2006 each of which is incorporated herein by reference in its entirety.

 Web 1.0 is the term associated with the first generation of internet browser applications and programs along with the associated client side software entities and server side software entities used to support and access information using the Internet. Such Web 1.0 technologies like most first generation technologies are geared more to enabling a workable system and to the capabilities of the available software and hardware platforms rather than to creating a rich and efficient experience for the system s users. Thus conventional Web 1.0 technologies while efficient for machines are often highly inefficient and frustrating for their human users.

In particular Web 1.0 technologies operate on a click wait or a start stop philosophy. That is when a user wishes to view a web page the user must generate a request using the client side browser software and send that request to the server. The user must then wait for the server to respond to the request and forward the requested data. The user must further wait for all of the requested data to be received by the client side browser software and for the browser software to parse and display all of the requested information before the user is allowed to interact with the requested web page.

This is frustrating for most users on a number of levels. First for slow or bandwidth limited Internet connections obtaining all of the requested data can often take a relatively long time. Furthermore even when the user has high speed access to the Internet a web page that requires data to be re loaded or refreshed on a fairly regular basis such as mapping web pages sporting events scores or play by play web pages and the like can cause significant delays. This is typically due to Web 1.0 requirements that the entire web page be retransmitted even if no or only minimal changes have occurred to the displayed information.

Accordingly the next generation of technologies used to access and support the Internet are currently being developed and collected under the rubric Web 2.0 . A key feature in the Web 2.0 concept is to eliminate the above outlined click wait or start stop cycle by asynchronously supplying data associated with a particular web page to the user from the associated web server. The transfer occurs as a background process while a user is still viewing and possibly interacting with the web page which anticipates the fact that the user will wish to access that asynchronously supplied data. A number of important technologies within the Web 2.0 concept have already been developed. These include AJAX SVG and the like.

Asynchronous JavaScript and XML or AJAX is a web development technique used to create interactive web applications. AJAX is used to make web pages feel more responsive by exchanging small amounts of data between the client application and the server as a background process. Accordingly by using AJAX an entire web page does not have to be re loaded each time a portion of the page needs to be refreshed or the user makes a change to the web page at the client side. AJAX is used to increase the web page s interactivity speed and usability. AJAX itself makes use of a number of available techniques and technologies including XHTML extended hypertext markup language and CSS cascading style sheets which are used to define web pages and provide markup and styling information for the web pages. It also makes use of a client side scripting language such as JavaScript that allows the DOM document object model to be accessed and manipulated so that the information in the web page can be dynamically displayed and can be interacted with by the user.

Other important technologies include the XMLHttpRequest object which is used to exchange data asynchronously between the client side browser software and the server supporting the web page being displayed and XML RSS and other data exchange standards which are used as the format for transferring data from the server to the client side browser application. Finally SVG scalable vector graphics is used to define the graphical elements of the web page to be displayed using the client side browser application.

In addition to Web 1.0 and Web 2.0 technologies an entirely different set of software technologies are used to access other data available over local area networks wide area networks the internet and the like. These technologies are traditionally referred to as client server applications where a complex software application having a rich set of features is installed on a particular client computer. This software application executes on the client computer and is used to access display and interact with information stored on a server that is accessed via a local area network a wide area network the Internet or the like. While such client server applications allow for dynamic displays and make manipulating information easy such client server applications are difficult to deploy to all of the client machines and are difficult to update.

Timelines for displaying data are known. The SIMILE project has a thin client Timeline that is interactive. However it lacks many desirable features. For example there is no toolbar that is able to interact with the Timeline. Also the SIMILE timeline only supports a proprietary data format and does not ingest standard formats like RSS and GeoRSS. Once the data is read in it does not link to other visualizations or support selection or highlighting. The ability to zoom in or out and the ability to change scales are also not included in SIMILE s Timeline.

Thus there is a need in the art for an improved thin client environment that supports full featured timeline display of data.

One embodiment of the present method and apparatus encompasses an apparatus. This embodiment of the apparatus may comprise a controller having a data connector for inputting temporal data and an item collection for providing timelines and overlays and for providing linked visualizations of the temporal data in a timeline to other visualizations of the temporal data and a display for displaying the timeline and overlays and the linked visualizations.

Another embodiment of the present method and apparatus encompasses a method. This embodiment of the method may comprise obtaining temporal data displaying the temporal data in at least one timeline in a web browser and in at least one other visualization in the web browser and linking the displayed data in the at least one timeline with the displayed data in the at least one other visualization.

As indicated above traditional web applications work on a client server model. The client which is typically a web browser issues a request to a server for a new page when the user clicks on or otherwise activates a hyperlink. The web server which is usually Apache or IIS does some data processing on the received request retrieves information from various data source systems does some additional data processing and transmits a formatted page of hypertext back to the requesting client. In response the requesting client receives the transmitted formatted page of hypertext parses and renders it and displays it to the user.

While this approach is simple technologically it does not make much sense from the user s perspective. As indicated above the reason for this is the inherent latency in this system between the time when the user requests a page and the time when the page is finally loaded. This latency can typically be as high as ten seconds. Because of this latency it is not possible to use direct manipulation user interfaces as defined in Readings in Information Visualization Using Vision to Think S. Card et al. Morgan Kaufman 1999 incorporated herein by reference in its entirety. However as discussed in Designing the User Interface B. Shneiderman Addison Wesley 3rd Edition 1998 incorporated herein by reference in its entirety this class of user interfaces is greatly preferred by users.

As indicated above the set of technologies known as Web 2.0 enables a new model that eliminates the start stop start stop nature of traditional web applications. Rather using these technologies information is asynchronously requested and returned to the requesting browser using XML RSS and or any other data format that the browser is able to parse. JavaScript code in the browser parses and stores this information as it is received from the web server. This stored information can be displayed automatically or upon user request. Since the asynchronously provided information is cached locally the browser running such JavaScript code can provide instantaneous responses to user inputs and thereby support direct manipulation operations. Typically JavaScript code in the browser handles interactions such as panning zooming scaling and data validation. Such asynchronous requests for XML data are advantageous in that users can continue working with the web page displayed in the browser window without losing their focus and waiting while data is downloading.

Embodiments of the present method and apparatus provides a set of browser based visual components and systems and methods for using such browser based visual components to provide interactive collaborative information visualizations within a browser. In various exemplary embodiments the set of browser based visual components uses AJAX Asynchronous JavaScript and XML SVG scalable vector graphics and Web 2.0 programming techniques. In various exemplary embodiments the browser based visual components are information visualizations that act as if they are traditional client side application windows. However in various exemplary embodiments the browser based visual components are totally browser based and require no client installed software entities. For example in various exemplary embodiments the browser based visual components do not require any additional client side software entities to be installed for these browser based visual components to run within the browser. Accordingly in various exemplary embodiments the browser based visual components can be used across a variety of platforms are portable to mobile devices and enable real time collaboration among users to a particular web site implementing the browser based visual components.

Web interfaces are rapidly becoming the de facto standard for accessing information. As outlined above one advantage of web based interfaces is that they are simple to deploy relative to traditional desktop or client side software applications. However as also outlined above one disadvantage of such web based interfaces is that desktop or client side software applications have a richness and a responsiveness that is not heretofore been possible to provide using conventional web based interfaces. Recently several new web applications have appeared such as for example Google Maps Microsoft s Virtual Earth and Google Suggest which provide a rich user experience when accessing web based information that previously was only available in desktop of client side software applications.

These applications are examples of web development that combines Asynchronous JavaScript XML DHTML XSLT RSS and or other enabled data formats and represents a fundamental change in what is possible when accessing web based information. For example when accessing Microsoft s Virtual Earth web site a user uses the cursor to grab the map and scroll or pan it past the visualization window. As another example when using the Google Suggest web page and web service the system automatically generates suggestions for the desired search query based on the text that has previously been entered into the search query box. In both of these examples the system s responses occur almost instantaneously without waiting for pages to reload.

With respect to displaying map information and other geospatial information the current technical approach is to collect the geospatial information from a variety of sources such as satellite images map data and the like demographic information and the like and combine that information to form a JPEG or GIF image on the server supporting the particular mapping geospatial information website. The images are then sent to the client side browser that generated the particular request as a web services stream. For example Google Maps Earth Microsoft Virtual Earth and the like return a stream or series of tile images in response to requests generated by the browser to the requesting browser as the user zooms in and out pans the image past the view window and the like. However as outlined above this technique requires excessive bandwidth and when the image files are large is slow to transmit the image files to the requesting browser. Furthermore there is limited interaction if any with the information and there is no collaboration or social computing capabilities.

SVG is a World Wide Web Consortium W3C XML standard for two dimensional browser based graphics. Using Web 2.0 programming techniques and SVG a generic graphical user interface incorporates an interactive set of lightweight browser based visual components. Graphical user interfaces provide a rich desktop user experience and include many of the features found in Windows based client side applications. In various exemplary embodiments graphical user interfaces are implemented using a thin client platform that is portable to mobile devices. Thus using the interactive set of lightweight browser based visual components it is possible to develop interactive web based information visualizations that are browser based and able to run in a typical standard browser or on a later developed browser. As indicated above this interactive set of lightweight browser based visual components does not require installing any additional client side software such as dynamic link libraries DLLs or client side interpreters like the Java Virtual Machine JVM .

These components include views which in various exemplary embodiments are interactive and enable users to highlight and manipulate the data and the visualizations presented in those views. In various exemplary embodiments the views are movable and resizable as if they were windows. In various exemplary embodiments when multiple views present different visualizations of the same or overlapping data the views are linkable so that selections and interactions with the data made in one view propagate to other linked views if any. In various exemplary embodiments the interactive set of lightweight browser based visual components provide tool tips and other user interface controls that are common on desktop client side software applications but were not previously available in web based user interfaces. At the same time because the components are browser based in various exemplary embodiments the interactive set of lightweight browser based visual components are hyperlinkable and typically provide the benefits usually associated with web interfaces.

As indicated above the interactive set of lightweight browser based visual components typically load the data being visualized asynchronously without needing to interrupt any user activity. Likewise as outlined above the interactive set of lightweight browser based visual components are in various exemplary embodiments collaborative and provide support for real time collaboration. As a result edits revisions deletions additions and or the like made directly to the information displayed to the users and or made to annotations or other information supplied by one of the user to a particular information collection entered by one user interacting with one browser are automatically propagated to other users using other browsers to access that same information collection.

In various exemplary embodiments such collaboration is accomplished by enabling users to mark areas of a displayed information such as for example an image to edit such areas to set change reset or otherwise modify one or more properties of such areas to delete such areas and the like. It should be appreciated that in various exemplary embodiments markable areas of the displayed information can include a region of an image such as a region in a geographic image a rectangle polygon or other feature element that has been laid over an image a hot zone and or any other known or later developed image region or overlaid feature or graphical element or the like. In general in various exemplary embodiments such collaboration is accomplished by making it possible for a user to take any desired known or later developed action relative to and or against such areas that conveys information from that user to another user.

In particular the geospatial data view displays a satellite image and a plurality of data icons . In various exemplary embodiments the geospatial data view comprises two or more independent layers of information including for example an image layer and an SVG elements layer. In various exemplary embodiments the image layer includes one or more static images such as JPEG images GIF images bit map images and or the like. In the exemplary embodiment shown in the satellite image is displayed in the image layer and is typically a JPEG or GIF image supplied by some web based mapping service such as Microsoft s Virtual Earth or Google Maps . In various exemplary embodiments the various data icons are implemented in the SVG elements layer and are implemented as independent graphic objects overlaid on the satellite image . In particular each data icon can include one or more interactive features such as a color coded border an activation border and or the like. Additionally each of the various icons has an image or graphical appearance that corresponds to the type of data and or the information collection represented by that particular icon . A pop up tool tip window is also associated with each data icon .

In the particular example shown in the geospatial data view includes a plurality of different icons . In the exemplary embodiment shown in each of the icons includes a color coded border having a particular color. This particular color corresponds to the colors used in the Timeline Tool where the date of the data item represented by those icons is color coded according to the color and coding used in the timeline visualization shown in the Timeline Tool . Thus for example the color coded border around the data icon has a light yellow color indicating the date of that item is early 2004. The color coded borders around the data icons and have a light green yellow color indicating the date of those data items is late 2004 or early 2005. Finally the data icons and have dark blue green borders indicating the date of the corresponding data items is late 2005 or early 2006.

In the exemplary embodiment shown in the mouse cursor not shown is currently located over the data icon . As a result of mousing over that data icon an activation border which has a defined color is placed around the color coded border of the data icon and the pop up tool tip window associated with the data icon is displayed. In particular in various exemplary embodiments the pop up tool tip window is displayed by adding it to the geospatial data view as a transparent pop up. Accordingly when the mouse cursor is moved away from the data icon the pop up tool tip window will be removed from the geospatial data view . However if while the cursor is over the data icon the left mouse button for example is pressed the pop up tool tip window is replaced by a persistent pop up window . In the exemplary embodiment shown in this was done while the mouse cursor was over the data icon . As a result the information associated with the data icon is displayed in the displayed persistent pop up window which remains displayed after the cursor is moved away from the data icon . In particular the persistent pop up window will remain displayed until its close button is selected.

It should also be appreciated that in various exemplary embodiments the user can arbitrarily zoom in and out on the satellite image . In various exemplary embodiments the zoom function is linked to the scroll wheel of the mouse. Accordingly when the mouse if within the geospatial data view and the user rotates the mouse scroll wheel the user can zoom in or out. In various exemplary embodiments the zoom range is from world to meter level.

The Timeline Tool as indicated above includes the timeline visualization . Within the timeline visualization a plurality of tick marks are displayed. Each displayed tick mark corresponds to one or more of the data icons displayed over the satellite image in the geospatial data view . Additionally as shown in the Timeline Tool includes a scale selection widget and display mode selection widget . Each of these widgets includes two or more radio buttons that allow various data selections to be made. In particular the scale selection widget includes three radio buttons that define scale for the timeline data to be displayed. In particular in the exemplary embodiment shown in these three radio buttons are displayed for a one year scale the displayed five year scale and for a ten year scale. The display mode selection widget includes a pair of radio buttons including the publication date button and the topic start end date button. This allows the particular type of date information for the data items to be selected for displaying in the timeline visualization and when displaying the color coded borders .

It should also be appreciated that the satellite image shown in can be in various exemplary embodiments updated in near real time if it were being implemented with a real time geospatial server. Thus as updated satellite image became available the various image files used to form the satellite image that contain updated image data and only those image files would be received from the server and used to asynchronously replace the corresponding out of date image files without having to download the entire geospatial image .

The GeoLocation List Tool allows the user to select the various data item collections to be displayed within the geospatial data view . In the exemplary embodiment shown in there are three main information collections the JistPakistanYusharof.XML information collection the SiamPakistan.XML information collection and the PolicrashPakistan.XML information collection. Each of these information collections has a different icon appearance for the data icons associated with that information collection. Accordingly it is possible to readily determine that the data icons and correspond to the top information collection the data icon corresponds to the middle information collection and the data icons and correspond to the bottom information collection.

The Text Filter Tool and the Date Filter Tool allow various filters to be applied to the various information collections to allow the user to control which data items are displayed in the geospatial data view . In particular the Text Filter Tool allows data items containing a particular text string to be selected for display. As shown in in various exemplary embodiments the user can use the Text Filter Tool to select where the text string is to appear in the data item. Similarly the Date Filter Tool allows the user to select a date range over which the data items are selected for display. In the exemplary embodiment shown in this includes a start date and an end date and includes hyperlinks to calendars that allow the user to better determine the start and stop dates that the user desires.

As shown in the bar chart view includes a plurality of data item classes associated with the columns of the bar chart view and a value axis that indicates the data values associated with the various points along the columns . In the bar chart view each of the columns includes a plurality of data items that are color coded corresponding to the particular column in which they appear. Each of the data items is selectable.

The pie chart view includes a color coded legend that indicates the various data classes and the color codes used in the pie chart associated with each of those data classes . For example the organization class is associated with a portion of the pie chart and is colored using the color code associated with the organization class .

As shown in a particular data item in the location class has been selected. As a result a tool tip pop up window is displayed in the browser window and displays data associated with the selected data item . At the same time the corresponding data item in the bar chart view is also shown selected or highlighted.

The geospatial data information view displays various types of geospatial information including satellite images such as that shown in map data hybrid map satellite data or the like. A dashboard tool on the map can be used to interact with and adjust the maps settings as defined in the API of the specific map provider.

Finally as shown in the web page displayed using the browser window includes a Tool List widget and a View Settings widget . The Tool List widget allows the user to dynamically select the different data connectors collections and the corresponding views associated with that data. By selecting a specific view like the bar chart the user can use the View Settings widget to manipulate the different axes for that chart. The x axis could be changed from class to label so that the bar chart would represent count per label in each bar instead of count per class . When these tools are used to manipulate the views the page is not refreshed because the views are able to dynamically redraw themselves.

As shown in in various exemplary embodiments the system includes a client side browser based system and a server side system . In particular the client side or browser based system outputs various requests such as http get http post or similar messages asynchronously over a communication path to the server side system while the server side system sends various responses such as XML messages RSS feeds or the like over a communication path to the client side or browser based system . As shown in the client side or browser based system includes a data connector component a controller component and a view component containing one or more views . In various exemplary embodiments the data connector component is a browser based JavaScript component that asynchronously requests receives and parses XML data. While previous Web 1.0 approaches use a click wait style of programming the data connector component uses AJAX programming techniques and asynchronous data loading. In various exemplary embodiments the data connector component includes a Parser and an AjaxLoader . When loading data in various exemplary embodiments the AjaxLoader issues an XMLHttpRequest and immediately returns programming control to the user interface thread rather than pausing for the data to arrive as in the previous Web 1.0 approach.

When the XML data eventually arrives over the communication path from the server side system the data connector component inputs the XML data via the AjaxLoader and provides it to the Parser . The Parser parses the XML data and provides it to the controller component . As a result the data connector component allows this data loading to occur as a background asynchronous process. As indicated above this allows a better user experience because the user does not need to wait for the response to arrive over the communication path from the server side system . The response is also processed without a consciously issued request by the client side or browser based system in response to direct user control. Moreover the data connector component allows for more efficient use of network resources since this architecture enables lower performance networks to be run at higher utilization rates by returning only the specific data information that is needed rather than an entire html web page for every request.

Once the data connector component and particularly the Parser outputs the parsed data to the controller component the controller component stores the parsed data in one or more information collections . In various exemplary embodiments each information collection is a memory resident table like data structure that is associated with one set or type of data. Thus each different set or type of data will be stored using a separate information collection

As indicated above the view component comprises one or more views where each view includes one or more visual components that implement a particular information visualization. As outlined above with respect to the visual components each provide different visualizations of the data items that comprise the information collection that is associated with that particular view . Thus as outlined above with respect to selecting a particular data item displayed in one of the visual components causes that item in the other visual components of that view to be selected as well.

In various exemplary embodiments the visual components implemented in the various views of the view component are sets of standard charts such as bar charts pie charts line charts and the like maps such as street maps geospatial image data topographical maps and the like and other custom visualizations that display data. Many of the visual components are written using SVG. In particular each of the visual components displays data using its own visual metaphor. As indicated above visual components that point to the same information collection are linked. Thus interactive operations such as for example tool tips selections and highlighting are automatically propagated from one such linked visual components to the other linked visual components that are attached to the same information collection .

It should be appreciated that in various exemplary embodiments the client side or browser based system uses a model view controller design pattern so that new visual components may be easily instantiated and or deleted at run time. As further shown in the server side system comprises server controls that are connected to the data connector component via the communication paths and . The server controls are also connected to a plurality of data sources via a communication path . The server controls output data requests over the communication path to the various data sources . It should be appreciated that in various exemplary embodiments the data sources can include one or more of XML data RSS data CSV data and database data stored in SQL databases or other database formats. The various data sources return the requested data over the communication path to the server controls .

As shown in in various exemplary embodiments the server controls include administration configuration services collaboration services data connectors that connect various data stores such as a geospatial data store and or an image store to the data connector component a publisher an active content server a server side handler and an AJAX handler

In various exemplary embodiments the collaboration services handle coordination of all collaboration features. The collaboration services communicate with the administration configuration services to create a user authority user status and user activity. The collaboration services also control services like chat whiteboard drawing and or annotation or the like. For example if one active user in an active group annotates a particular visual component the collaboration services propagate the new information to all other active users within that active group such that that particular annotated visualization in the other active users browsers is updated to contain that annotation. The collaboration services are also used to signify which user has added which annotation to which visualization.

As shown in in various exemplary embodiments the collaboration services include a collaboration server and a collaboration data store . That is in various exemplary embodiments the collaboration services are implemented using a separate collaboration server and collaboration data store

The data connectors act as the source for access to external data via the communication paths and between the server controls and the external data sources . In particular in various exemplary embodiments the data connectors are designed to be data type independent. Thus the data connectors have the ability to interface with structured and or unstructured data. In various exemplary embodiments the data connectors are based on XML and interface with the internal geospatial data model stored in the geospatial data store . In various exemplary embodiments the data connectors are able to continue processing data if one of the data sources becomes inactive or unexpectedly terminates. The data connectors also have a full application programming interface designed to integrate with legacy or proprietary data sources . As indicated above the data connectors upon receiving data from the various data sources over the communication path store the received data in one or more various internal data stores such as the geospatial data store and or the image store .

The publisher inputs or receives data images and other information from the data connectors and deconflicts persists normalizes and or validates the data and other information prior to outputting the data and other information to the data connector component over the communication path . The publisher processes received data based on a set of rules that are fundamental to the publisher along with rules that can be defined for the particular web site and web pages being developed. These added rules can add delete modify change and or enhance data received by the publisher based on specific web site or web page dependant requirements.

The active content server is an entity that is used in conjunction with the publisher when the publisher needs to actively send out updated information. This is most important when the user is viewing data that needs to be updated frequently in a real time manner or when the user is collaborating with other users. The active content server will help the publisher to determine what data has been updated recently on a per user basis and thus should be sent to the user s browser so the data and visualization components can be updated.

The active content server is also used to keep the displayed web page in the geospatial data view updated as the client side AjaxLoader frequently polls the server controls for updates. In a conventional publishing server architecture when the user opens a web page the browser requests information from the publishing server. The publishing server is only responsible for transmitting the information to the requesting browser once. The end user will see the same data on the page until the end user clicks on the refresh button no matter how long that end user displays that web page.

In contrast when using systems or methods when the user opens a page the AjaxLoader requests information from the active content server . The AjaxLoader will poll the server controls every few seconds to simulate a server side push effect for the end user. The active content server will handle each request from the AjaxLoader and determine if there have been new updates to the information collection that is being viewed using the client side or browser based system . If there is new data the active content server will send only the new or changed data to the data connector component and the particular visual components of the view component that are linked to the information collections storing that data will be automatically updated. If there is no new data then the active content server will not send anything back to the data connector component and the visual components will remain as they are.

Accordingly it should be appreciated that the active content server has quite a bit more responsibility than a conventional publishing server. The active content server desirably needs to somehow know what new data is and specifically the particular new data that the active content server should send in response to the requests from a particular AjaxLoader that are received every few seconds. In various exemplary embodiments this can be accomplished by maintaining a timestamp on the data by applying some type of hash lookup to determine what is old data and what is new data or any other appropriate known or later developed technique. The active content server should also have a timeout period such that when a particular client side or browser based system has not done anything for some amount of time the active content server knows that it can stop sending data. This can avoid overloading the active content server with unneeded requests.

In an active publishing environment the client browser has to be configured differently and the publishing server needs to be configured differently to make it active . The physical hardware used to implement this can vary. In some exemplary embodiments two different servers are used to implement this architecture. In various other exemplary embodiments only one server which can be configured in different ways is used.

The server side handler processes visualizations analytics and other computationally intensive operations based on configuration options set using the administration configuration services . For example the server side handler would process a large visualization. The server side handler builds the visualization and parses the data for the data connector component . The server side handler would then output the large visualization data using the communication path which is part of the communication path to the data connector component .

The AJAX handler is the web services interface component of the server controls . The AJAX handler handles communication between the data connector component using an XML communication path an RSS communications path and or a SOAP communication path which are part of the communication paths . The AJAX handler can also interface with other web based services such as .NET ASP or Java based JSP services.

As shown in the object oriented like JavaScript library includes a Controller object class a DataConnector object class an AjaxLoader object class a Parser object class a ViewToBind object class a DataCollection object class a View object class an Item object class a Chart object class various specific chart object classes and a Map object class .

As shown in the Controller object class includes a plurality of properties and a plurality of methods. In particular in the exemplary embodiment shown in the Controller object class includes such properties as a DataCollectionCount property a DataCollections property a DataConnectors property and a ViewsToBind property . Similarly in various exemplary embodiments the Controller object class includes a GetDataCollectionByID method and a GetDataCollectionByName method .

In particular the DataCollectionCount property indicates the total number of different information collections that are associated with an instantiated Controller object . The DataCollections property holds an array of DataCollection objects where each DataCollection object is an instantiated object of the DataCollection class discussed herein. Thus the DataCollections property maintains the logical connections to various DataCollection object classes which in turn have various logical connections to various instantiations of the View object class and the Item object class .

The DataConnectors property holds an array of DataConnector objects instantiated from the DataConnector object class . The DataConnectors property maintains the logical connections to the instantiated DataConnector objects classes . Similarly the ViewsToBind property holds an array of ViewToBind objects that maintains the logical connections from the Controller object class to the instantiated ViewToBind object classes .

The GetDataCollectionByID method and the GetDataCollectionByName method are used by the Controller object class to initially load and regularly update the various DataCollection objects either by the values of their ID property and or by their Name properties .

The DataConnector object class includes a plurality of properties including an AjaxLoader property DataCollectionName property a Parser property and a URL property . When a DataConnector object class is instantiated the AjaxLoader property causes an AjaxLoader object class to be instantiated and connects it by a logical connection to the parent DataConnector object class . Likewise when that DataConnector object class is instantiated the parser property causes a Parser object class to be instantiated and connects it by a logical connection to the parent DataConnector object class . As outlined above the AjaxLoader object class accesses a particular web page defined by the URL property in its parent DataConnector object class . In particular when the AjaxLoader object class accesses the web page identified in the URL property it specifically loads the data in the information collection specified by the DataCollectionName property in its parent DataConnector object class . In particular each DataConnector object class points to a different web page and set of information collections found in the URL property and the DataCollectionName property . To access a different set of information collections on the same web page or to access other information collections on a different web page additional DataConnector objects class would be instantiated and logically linked back to the instantiated Controller object class by a separate logical connection .

The AjaxLoader object asynchronously requests and receives initial and updated information from the particular information collections on the server controls identified in the DataCollectionName property at the web page indicated in the URL property of the parental DataConnection object . In response the Parser object class parses the received XML SOAP or other data from the identified website and parses or interprets the XML data so it can be used by the rest of the object oriented like JavaScript library .

As shown in the ViewToBind object class includes a plurality of properties including a DataCollectionName property and an InitViewFunction property . As outlined above with respect to the Controller object class and the DataConnector object class the DataCollectionName property in each instantiated ViewToBind object class is a string pointing to a particular DataCollection object class . The InitViewFunction property points to a particular view object that is to be bound to the particular DataCollection object that is named in the DataCollectionName property . Thus each ViewToBind object class binds or links a particular View object to the named identified DataCollection object class .

The DataCollection object class includes a plurality of properties and a plurality of methods. It is linked by the logical connection to a parental Controller object class by its inclusion in the array of information collection objects within the DataCollections property of that Controller object . In various exemplary embodiments the DataCollection object class includes properties such as the ID property the Items property the Name property the ViewCount property and the Views property . The DataCollection object class also includes a plurality of methods such as an AddItem method an AddView method a GetItem method a GetView method a RefreshViews method a RemoveItem method and or a RemoveView method .

The ID property is a string defining a particular ID value for the particular instantiated DataCollection object class . The Items property is an array defining a plurality of logical connections to a plurality of instantiated Item object class . The Name property is a string containing the particular name for a particular instantiated DataCollection object class that is stored in the array of information collection objects held in the DataCollections property and it is linked by the DataCollectionName properties and to the particular DataConnector objects class and ViewToBind objects class respectively. The ViewCount property is a string or a numeric value indicating the number of different views that are linked to the particular instantiated DataCollection object class . The views property holds an array of View objects class and maintains their logical connection to the particular instantiated DataCollection object class .

The AddItem method is used to instantiated an additional Item object class while the AddView method is used to instantiated an additional View object class . The GetItem method is used to access the data associated with a particular Item object class while the GetView method is used to access the data and or functions of a particular View object class . The RefreshViews method is used to redraw and or redisplay the various views identified in the array held in the views property . This would be done for example after a view has been manipulated for example by selecting a particular item or the like. The RemoveItem method is used to remove or release a particular previously instantiated Item object class and to remove it from the various instantiated View objects class . The RemoveView method is used to remove a previously instantiated View object class .

As shown in the Item object class includes a plurality of properties including an ID property a PropertyName property and a PropertyValue property . In particular each ID property includes a string or numerical value. The array of items held in the Items property of a particular instantiated DataCollection object is linked to a particular instantiated Item object class using the value stored in the ID property of that Item object . The PropertyName property holds an array of data elements such as latitude longitude a text string a time and or date or any other data element of the particular data item associated with the Item object class . Each entry in the array of data elements held in the PropertyName property has a corresponding entry in an array held in the PropertyValue property that stores the particular value for the associated data element.

As shown in the View object class includes an ID property and a plurality of methods including a Clear method a Draw method an IsReadyToDraw method and a Refresh method . Additionally the View object class is a parent class to both the Chart object class and the Map object class

The particular methods and or properties included in the Chart object classes and and the Map object class are conventional and thus are omitted from this disclosure. It should be appreciated that non conventional properties and or methods can be included in any of the Chart object classes and and or the Map object class whether such properties and or methods are known or later developed. Like the Item object class each View object class is linked by the value of its ID property to various DataCollection objects and Item object class by its inclusion in the array held in the Views property . The Clear method removes everything from a view so that a clean representation of the data can be drawn. The Draw method causes the particular view to be drawn. The IsReadyToDraw method is used to query the view to determine if it is in a state that can be drawn. The Refresh method is activated by the RefreshViews method of the DataCollection object class that is linked to the particular View object class by the logical connection and causes that view to be redrawn to reflect any modifications or selections of the data and or to reflect any revised data contained in the linked Item object class .

Thus shows a class diagram that represents the various JavaScript classes that make up the client side components shown in . By organizing these client side components into an object oriented like library these client side components become very easy to reuse and extend. The expected object oriented properties such as inheritance polymorphism and encapsulation are implemented in the various JavaScript object oriented like classes using JavaScript closure techniques. As indicated above the model view control and design pattern cleanly separates the data objects from the views that are displayed in the various browser windows.

As outlined above a DataConnector object class is used to retrieve data from the server controls and can be executed either when the requested web page is initially loaded or programmatically by other ones of the client side components shown in . As shown in each instantiated DataConnector object class uses an associated instantiated AjaxLoader object class to retrieve the data from the server identified by the URL property and an instantiated Parser object class to interpret the XML data that is returned in response.

In various exemplary embodiments the AjaxLoader object class is a wrapper class around a browser specific XMLHttpRequest object to provide simple methods to execute the asynchronous data request. This AjaxLoader wrapper object class is included in the DataConnector object class . However in various other exemplary embodiments the AjaxLoader wrapper object class can also be used separately as needed. It should be appreciated that various different types of specific parser classes can be provided as child classes to the parent Parser object class . Various ones of these child parser object sub classes can be custom parsers that are written to interpret the received XML data. Various ones of these specific parser objects correspond to built in generic RSS tree or other parsers and are used to interpret the XML or other data that is returned from the server controls .

In operation when the developer of the web page is designing the client side components the developer will define one or more DataConnector objects class by identifying for each different DataConnector object class the particular URL which is to be accessed and from which data is to be retrieved. The web designer will also identify the particular DataCollection object class in the DataCollectionName property that is to be used to store the data once it has been received and parsed by the appropriate Parser object class . The web developer will also define one or more desired View objects class that generate views to be rendered. The web developer does this by identifying for each desired view the desired view and the name of the information collection that should be used to populate the view in a View object for each view. To link these components together the Controller object class maintains an array of the DataConnector objects class and a corresponding array of ViewToBind objects class .

When a user loads the particular web page the web developer has created a Controller object and any needed DataConnector objects and ViewToBind objects are instantiated. The Controller object class will be notified when each of the DataConnector objects are done parsing the particular data to be retrieved from the identified URL. In response as each DataConnector object finishes parsing its appropriate data the Controller object class instantiated the necessary DataCollection objects class . The Controller object class then instantiated the defined View objects class that are identified in the various ViewToBind objects class and provides the appropriate logical connections from the instantiated View objects class to the instantiated DataCollection objects class .

As indicated above the retrieved data is stored in the Item object class . In various exemplary embodiments the client side components include the various instantiated Item object classes . The Item object class is very flexible in that it contains an array of property names and corresponding array of property values that are used to store the parsed XML data variables or identifiers and the corresponding values. Each instantiated Item object class is associated by a logical connection to a particular one of the instantiated DataCollection objects class . The linked DataCollection object class is responsible for maintaining an array of the linked Item object class and to expose methods to access and manipulate the Item object class . As indicated above each instantiated DataCollection object class includes an array of the views that are associated by the logical connections to that DataCollection object class and thus to the associated Item object class .

The View object class and the underlying Chart and Map object classes and and the underlying specific Chart object classes are written in standard browser formats including SVG and DHTML and can be easily modified to support new technology such as for example XAML. When changes are made to the various Item object class that are associated with a particular DataCollection object class the particular View objects class that are associated with that DataCollection object class are updated automatically to reflect the change in the Item objects class . In addition when the user mousses over or selects a particular Item object class that is displayed in a particular View object class the other View objects that are linked that particular DataCollection object class and contain that particular Item object class are notified such that each such View object treats that item as being selected in that view as well. The end result is a more satisfying user experience where the user can originally analyze a specific data item using a variety of views such as a bar chart a pie chart a geospatial view and the like by simply mousing over a single entry in a particular view. Similarly patterns outlines and the like can also be made apparent by analyzing the data using different views simultaneously.

As indicated above the Chart object class inherits from the base View object class . Likewise as indicated above specialized chart object classes such as the BarChart object class the TreeChart object class and the TimelineChart object class inherit from the parent Chart object class . This design pattern provides all the advantages and polymorphic behavior of a true object oriented language but is done using closures and JavaScript. As other specialized Chart object classes are needed such new Chart object classes can be implemented as simply as inheriting from the base Chart object class overriding the Draw method in the View object class and defining any additional custom methods or properties that are desired.

The Map object class is a way to examine various data items contained in an Item object class using a geospatial view object . The Map object class is similar to the Chart object class in that the Map object class is also a dynamic interactive View object that receives updates and notifications from an underlying DataCollection object class . However like standard map objects the Map object class can also be zoomed in and out and panned as well as able to display overlays of lines and polygons as outlined above. It should be appreciated that in various exemplary embodiments any server response that returns XML data can be used to provide data to the DataConnector objects class . Such XML data can be retrieved from XML files ASP.NET pages and PHP pages. This data can also include any types of proxy page database connection that accesses server data and then responds with data in an XML format. Accordingly SOAP responses from web services would thus also be a valid source of data. By including most of the functionality in the client side or browser based system the server requirements to output data are very flexible and easy to implement regardless of the operating system or data source.

In the exemplary embodiment shown above with respect to to create the transparent SVG overlay layer data is imported which defines a polygon having longitude and latitude coordinates for its vertices 1 3. The latitude and longitude coordinates for these three points are 32.0 N 66.5 E 32.9 N 69.6 E and 30.1 N 66.6 E respectively. The geospatial data shown in the geospatial data view is then analyzed to determine the x and y pixel positions within the geospatial data view corresponding to the defined latitude and longitude coordinate values for the three vertices measuring from the upper left hand corner of the geospatial data view . In particular in the exemplary embodiment shown in the latitude and longitude coordinates for the first vertex corresponds to x y position of . The x y pixel locations for the second and third vertices 2 and 3 are respectively and . In various exemplary embodiments these x y position values are passed to a polygon drawing function such as the draw polygon function which creates an SVG graphic element in the transparent SVG overlay layer resulting in the image shown in .

It should be appreciated that as map events occur such as zooming in zooming out panning in any direction and the like the map is continually queried to determine the new x y pixel location values for the corresponding latitude and the longitude coordinates for the vertices 1 3. In response the updated x y pixel location values are passed to the polygon drawing function which creates a new SVG graphic element. This new SVG graphical element replaces the previous SVG graphical element which is removed from the transparent SVG overlay layer . Consequently the SVG graphical element appears to move and scale with the underlying geospatial image data displayed in the geospatial data view .

Accordingly it should be appreciated that to create the geospatial data view shown in a transparent SVG overlay layer is placed on top of the geospatial image data in the geospatial data view . Then data is imported that has been tagged with the appropriate latitude and longitude values. Based on those latitude and longitude values the geospatial data view is analyzed to determine the x and y pixel positions within the geospatial data view that correspond to those latitude and longitude values. Based on those x y pixel locations points and or shapes are drawn onto the transparent SVG overlay layer . As graphical user interface events that effect the geospatial data view are input by the user such as zooming panning or the like those graphical user interface events are caught and the geospatial data view is re analyzed to identify the new corresponding x y pixel locations. The various points shapes and other graphical elements in the transparent SVG overlay layer are then redrawn. It should also be appreciated that multiple transparent SVG overlay layers can be incorporated into a single geospatial data view and placed over the displayed image data. These various transparent SVG overlay layers can then be selectively displayed or hidden.

As shown in Analyst has opened a browser window and has opened a web page containing a geospatial data view . In this geospatial data view the Analyst has displayed a first set of image data . While accessing this image data the Analyst has added a pair of annotations to the various data items that are displayed in the image data presented in the geospatial view . The Analyst has also opened a message box that allows the analyst to add yet a further annotation. At the same time the geospatial view shows a pair of annotations that the Analyst has also added to the data items that appear in the image data shown in the geospatial view . At the same time the Analyst has opened a second browser window and accessed the same web site to display a second geospatial view that displays a second set of image data . In particular the image data overlaps the image data shown in the Analyst s browser window . Accordingly the Analyst sees the annotations added by the Analyst as well as the annotations that the Analyst has added himself.

As shown in a collaboration synchronization server communicates over a communication path with a collaboration state and history database . The collaboration state and history database allows the collaboration synchronization server to know which subsets of the information collections are currently being displayed or interacted with on each of the browser windows and as well as the particular annotations each of the users using the browser windows and have entered and have received. As each of the users enters in new annotations using their browser windows or the data connector component shown in pushes annotations to the collaboration synchronization server over the communication paths and or respectively using for example by using the AjaxLoader . The collaboration synchronization server then stores each annotation that has been pushed down to it to the collaboration state and history database .

Then each of the browser windows and or sends a request using the data connector component and the AjaxLoader in particular to the collaboration synchronization server to asynchronously obtained updated information over the communication paths and or respectively. In response the collaboration synchronization server queries the collaboration state and history database for each different browser window or the like to determine which annotations have already been supplied to that particular browser window or the like and to determine if there are any annotations which have not been sent to that browser window or the like. If any such annotations exist the collaboration synchronization server receives the appropriate data for such annotations over the communication path from the collaboration state and history database and pushed those annotations over the communication path to the particular browser window s and or the like that have not received it. At the browser window or each received annotation or the like is parsed using the parser and eventually displayed within the browser window or the like.

Accordingly the annotations from one user such as the Analyst are automatically propagated to any other browsers such as that being used by the Analyst accessing the same website and information collection. In particular no browser refreshes or other user activity are required to push these annotations down to the collaboration synchronization server or pull them back up to other ones of the appropriate browsers. It should be appreciated that besides annotations the types of information that can be pushed down onto the collaboration synchronization server include region selections label highlighting or other graphical elements that can be displayed in a transparent SVG layer.

It should be appreciated that the collaboration model discussed above is a logical collaboration around the information displayed in the particular view. In particular it is not an example of WYSIWIS standing for what you see is what I see . Thus in various exemplary embodiments the collaboration model does not propagate exact copies of a single screen among users in the collaboration as is done in other collaboration models such as for example Microsoft s Live Meeting collaboration software which was formally called PlaceWare .

As shown in regardless of which representation or of the web page is used a tool box is available to the web designer. As shown in this tool box includes a Navigation tab a Log in tab a Web Parts tab an HTML tab and a Views tab . Each of these tabs and provide generic code structures that can be dragged and dropped into the HTML code elements or the graphical elements of the web page and then customized for the particular website being developed. In particular the Navigation tab provides navigation controls the Log in tab provides log in controls and the Web Parts tab provides other web components that can be used in a web page. The HTML tab provides a plurality of HTML generic code structures for adding various types of HTML entities. The Views tab provides various generic code structures for various different types of view. For example in the exemplary embodiment shown in the web developer has selected the BarChart element of the Views tab . By dragging and dropping an instance of that BarChart element into the web page the web developer has placed a generic code structure into the web page that will generate a bar chart visualization when the web page is accessed. Similarly as shown in upon dragging and dropping the BarChart element the Bar Chart visualization has been added to the graphical elements of the web page being developed in the integrated development environment .

In non technical terminology the Timeline is a tool used to visualize and interact with data all of which is accomplished in a web browser without the need to install any software. To be more specific the Timeline visualization is a thin client AJAX enabled view of temporal data that is interactive and linked to other visualizations such as for example maps and business charts. A number of important features which may be utilized in embodiments according to the present method and apparatus are but are not limited to the following a thin client with no software install b interactive panning and interactive zooming c different time scales d synchronization to other Timelines detail and summary views e built in RSS support f linking to other visualizations g several data display modes h ability to select specific data items i ability to highlight specific data items j rich API to program against k built in Toolbar l visual scalability overplotting m best fit algorithms and n y axis plotting line chart capability .

The Timeline is a visualization included in the thinc Interface library. In general one embodiment according to the present method and apparatus may have the steps of linking to a thinc Interface library in a web page creating a new Timeline and pointing the Timeline to one of RSS data and custom data. Software routines implement different uses of the Timeline. In one embodiment for example the steps may be to create the Timeline and then create data Overlays that sit on top of the Timeline which hold the RSS data or other data that has been ingested. Several supporting classes Controller DataConnector ItemCollection Item make it easy to point to a valid data feed and then ingest that data into the visualization. Creating other visualizations like the Map BarChart or PieChart with the same data will automatically make the data linked between the visualizations.

The Controller DataConnector ItemCollection and Items provide an easy way of getting data into the Timeline and other visualizations. There are other ways to get data into a thin client application like including the data with the page or using the browser s raw XmlHttpRequest object to retrieve the data. Regardless of how the data arrives in the thin client application it may be used by the Timeline in a similar fashion. The Timeline itself may be instantiated by giving it a name and an element identification for where it should be placed on the page. Also it may be given a start date an end date and a time scale to be used as default values when the Timeline loads up. To get data to appear on the Timeline a new Timeline Overlay may be created and passed it the RSS or GeoRSS data. Then this TimelineOverlay may be overlayed on the Timeline.

This approach is unique and flexible because it allows multiple overlays of data to appear on the same Timeline which can be shown or hidden by calling certain API functions. Also the data used to populate the overlay may be automatically linked to other visualizations on the page that use the same data. Other attempts to solve this problem usually involve placing the temporal data directly in the Timeline and are usually done in a fat client application. However often times that approach does not provide the flexibility to be able to show and hide specific data or to link the data to other visualizations.

The Timeline may also include a toolbar which is unique to interact with the Timeline in a variety of ways. There may be buttons to change the time scale Year Month Day Hour Minute Second zoom in zoom out change the display mode of the data turn labels on or off turn date ranges on or off and turn custom images on or off. Panning the Timeline is very intuitive and involves in one example using the left mouse button to drag the Timeline to the right or left. The Timeline may automatically generate the background as you pan without the need to refresh the page.

Multiple Timelines on the same page may be synchronized so they pan at the same rate ex panning one Timeline at year scale will cause a synched Timeline at month scale to pan very fast because the Timelines are being panned by a fixed amount of time rather than pixels .

A more detailed description of the unique features of embodiments according to the present method and apparatus is as follows.

a Thin Client The visualization runs in a simple web browser with no installation which is a new trend in software loosely defined by principles like AJAX and Web 2.0.

b Interactive Panning and Zooming The old model in web pages was to click a button and have the entire page refresh to execute the pan or zoom event. The present Timeline is fully interactive and supports panning and zooming without refreshing the page. It generates new tiles for the Timeline background automatically.

c Different Time Scales The Timeline supports a variety of scales including Year Month Day Hour Minute Second.

d Synchronization To Other Timelines Multiple Timelines may be synchronized together on the same page so that they pan at the same rate. The lens may be drawn on one Timeline which represents the amount of time shown on the other Timeline. This technique provides a summary and detail view of the same data using two different Timelines at different scales.

e RSS Support The Timeline may plot any data Items with a time dimension but natively supports the RSS format. RSS is a common data format used in blogs and other web applications and is growing in popularity with the new GeoRSS extensions to RSS. RSS has a property called pubDate which in one embodiment is what the Timeline uses by default but can easily be configured to use some other property. The advantage of default RSS support is that the Timeline may be pointed at any valid blog or RSS feed and may instantly plot those blog posts on the visualization.

f Linked To Other Visualizations The data on a Timeline may be automatically linked to other visualizations Map BarChart PieChart etc that display the same data. If the underlying data is changed it will appear differently in all of the visualizations. This will be discussed more in the sections on selection and highlighting

g Data Display Modes The data items on the Timeline may be displayed as circles tick marks spheres or any custom icon. They may also display ranges if the event occurred from a start date to an end date.

h Selection The Timeline may support selection of data items by clicking on them or by doing a sweep rectangle select when the Timeline is in Select mode. This selects all the desired items and changes their display to indicate that they are selected. Every other visualization that is using the linked data will automatically change the display of those items as well. This makes the visualization unique because the end user is able to do when where analysis using the Timeline and Map all in a standard web browser.

i Highlighting The Timeline may support highlighting of data items. The idea is exactly the same as selection except that items get highlighted as the user mouses over the items rather then clicking on them.

j Rich API The Timeline may have in one example a very rich API that allows developers to set a variety of properties by using the Application Programmer s Interface that may be provide. It is easy to call functions or set variables that change the look and feel of the Timeline.

k Toolbar The Timeline may have a built in toolbar that allows the end user to use many of the features that have been described above. The toolbar may have tooltips and buttons that are interactive but it can also be toggled off if desired.

l Visual Scalability When a large amount of data needs to be shown at a given date the Timeline may have algorithms to show an over plotting indicator rather than stack all of the data on top of each other. This allows the end user to still see the patterns in the data and be able to zoom in further to see the data that wouldn t previously fit on the Timeline.

m Best Fit Algorithm The Timeline by default may use a best fit algorithm. This means that data items including their date range icon and text label will not overlap each other. If there is too much data to fit on the Timeline then an over plotting indicator will be displayed.

n Y Axis Plotting The Timeline may be switched from Best Fit to Y Axis Plotting of the data items. This means that the data items may be plotted by using time along the x axis and some other property along the Y axis. Essentially this turns the Timeline into an interactive Line Chart with all of the unique features of our Timeline.

The thin client has been described above but is shown in general terms in . In one embodiment a server may have a web server and a thin client may have a web browser . The Web browser may send a request for a resource at a given URL. The resource is then returned in a response to the web browser . The resource is then processed by the browser . Since this is a thin client no software need be installed in the thin client .

A further feature that may be implemented in the above described display of temporal data in a timeline and in other visualizations according to the present method and apparatus is event aging. In one embodiment this feature may be used with real time data. In this example each element of real time data may refer to an event. When a new event occurs it can be set to age off the Timeline after a given amount of time. As it ages it will become more and more transparent giving the impression that it is fading away.

A further feature that may be implemented in the above described display of temporal data in a timeline and in other visualizations according to the present method and apparatus is event replay. Using the event replay feature temporal data may be replayed on the timeline in the order they occurred. The standard features like pause fast forward rewind etc. may all be supported.

The features of event aging and event replay may be implemented in a manner similar to that of the other features of timelines in web pages of thin clients as described above.

A further feature that may be implemented in the above described display of temporal data in a timeline and in other visualizations according to the present method and apparatus is a toolbar button that effects panning of timeline data to the current time.

A further feature that may be implemented in the above described display of temporal data in a timeline and in other visualizations according to the present method and apparatus is an optimized view on the timeline of selected data points such as automatically setting scale zoom level etc to show an optimal view of a selected subset of data points.

The present apparatus in one example may comprise a plurality of components such as one or more of electronic components hardware components and computer software components. A number of such components may be combined or divided in the apparatus.

The present apparatus in one example may employ one or more computer readable signal bearing media. The computer readable signal bearing media may store software firmware and or assembly language for performing one or more portions of one or more embodiments. The computer readable signal bearing medium in one example may comprise one or more of a magnetic electrical optical biological and atomic data storage medium. For example the computer readable signal bearing medium may comprise floppy disks magnetic tapes CD ROMs DVD ROMs hard disk drives and electronic memory.

The steps or operations described herein are just exemplary. There may be many variations to these steps or operations without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified.

Although exemplary implementations of the invention have been depicted and described in detail herein it will be apparent to those skilled in the relevant art that various modifications additions substitutions and the like can be made without departing from the spirit of the invention and these are therefore considered to be within the scope of the invention as defined in the following claims.

