---

title: Application search tool for rapid prototyping and development of new applications
abstract: A code search tool greatly reduces time, cost, and other resource expenditures associated with implementing a new application. The tool is a search, navigation and visualization tool that accepts high-level processing concepts as inputs to identify, rank, and return the code of relevant existing applications. A software developer may use the relevant applications to rapidly build prototypes, identify requirements, and develop new applications. The tool provides an efficient way to improve the reuse of application logic to realize the high-level processing concepts, and more efficiently deliver proof of concept.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009649&OS=09009649&RS=09009649
owner: Accenture Global Services Limited
number: 09009649
owner_city: Dublin
owner_country: IE
publication_date: 20070516
---
This disclosure concerns finding existing program logic and reusing it to rapidly build prototypes and develop new applications. In particular this disclosure relates to a search navigation and visualization tool that accepts high level processing concepts as inputs that drive a multi layered search to identify applications and application programming interface API calls for reuse.

Software professionals widely recognize logic e.g. source code reuse as a technique that reduces the time money and other costs associated with creating a new application. Software professionals recognize API calls as forms of abstraction for high level processing concepts which drives the wide acceptance of API calls as reusable logic. For example implementing an existing API call that produces a pull down menu eliminates the need to write all the underlining logic necessary to deliver the functionality of a pull down menu. However current logic mining techniques and mining tools fail to retrieve highly relevant software components from application repositories that developers can use to prototype requirements in support of high level processing concepts. Modern search engines do not ensure that applications identified by the search engines can serve as highly relevant application prototypes HRAPs . Software professionals consider the mismatch between the high level processing concepts e.g. the intent reflected in the descriptions of applications and low level implementation details e.g. API calls and actual run time behaviour found in application logic a fundamental technical challenge to identifying highly relevant applications HRAs . Software professionals intend to author meaningful descriptions of applications in the course of depositing applications into software repositories. The mismatch between the description of an application and the actual behaviour of the application represents one example of the vocabulary problem which states that no single word or phrase best describes a programming concept.

In the spiral model of software development stakeholders describe high level processing concepts to development teams and together the stakeholders and development teams identify requirements in support of the high level processing concepts. In addition a development team builds a prototype based on the requirements and the development team demonstrates the prototype to the stakeholders to receive feedback. Prototypes attempt to approximate the desired high level processing concepts e.g. features and capabilities of the new application stakeholders desire development teams to build. The feedback from stakeholders often leads to changes to the prototype and the original requirements as stakeholders iteratively refine their vision. In the event the stakeholders make a substantial number of changes to the requirements the development team often discards the prototype and builds a new prototype and another iteration of refinements repeats. Building prototypes repeatedly without reusing existing application logic costs organizations a great deal in the form of wasted project resources and time.

Development teams find it cost effective to identify existing applications that approximate the high level processing concepts and requirements of new software projects as the basis for prototypes. In the context of prototyping software development professionals consider such existing applications as HRAs. Many application repositories e.g. open source repositories and source control management systems maintained by stakeholders internally contain hundreds of thousands of different existing applications e.g. potential HRAs . Unfortunately developers find it difficult to identify applications e.g. HRAs ideal for prototyping because of the time and expense involved in searching e.g. querying application repositories and source control management systems.

The amount of intellectual effort that a developer must expend to move a software system from one stage of development to another may be considered the cognitive distance. For example using current search tools developers expend significant intellectual effort to identify potentially relevant applications and confirm HRAs from potentially relevant applications. Many developers employ search engines that identify exact matches between keywords and the words found in application repositories. The application repositories may include descriptions application logic comments program variables names and variable types of existing applications. Such search engines actually increase the difficulty of identifying HRAs because of the poor quality of information contained in application repositories and the inability to reduce the cognitive distance required to identify HRAs as well as other factors. Additionally many application repositories include incomplete misleading and inaccurate descriptions of applications identified in the application repositories. Consequently even matching keywords with words in the application descriptions found in application repositories does not guarantee that the search engine will identify HRAs.

Effective software reuse techniques e.g. prototyping using existing applications reduce the cognitive distance between the initial concept of a system e.g. high level processing concepts that expressly and implicitly describe the features and capabilities of a new application establishing discrete requirements and the production implementation of the new system. Unfortunately current search engines lack the ability to reduce the cognitive distance related to identifying HRAs.

For example an application description may indicate that an application includes an encryption feature when in fact the application uses compression as a crude form of encryption. A developer entering encryption e.g. as a high level processing concept and specific requirement as a keyword may waste precious time to review a search engine result containing the incorrectly described application and ultimately discard the result because the application fails to meet the encryption requirement. The developer must download the application identified in the search result locate and examine fragments of the application logic that allegedly implements encryption before determining that the application fails to meet the requirement. The developer may spend scarce project development budget resources and significant amount of time to analyze the application before determining that an application is not relevant. The developer may even observe the runtime behavior of the application to ensure that the behavior matches the high level processing concepts desired by the stakeholders and meets the requirements in support of the high level processing concepts before establishing that the application qualifies as a HRA. Current search engines also lack the ability to assist developers to rapidly identify requirements in support of high level processing concepts described by stakeholders.

Some search tools return code snippets e.g. segments of application logic however code snippets do not give enough background or context to assist developers to create rapid prototypes and such search tools require developers to invest significant intellectual effort e.g. cognitive distance to understand how to use the code snippets in broader scopes. Other existing approaches and tools retrieve snippets of code based on the context of the application logic that developers work on but while these approaches and tools improve the productivity of developers they do not return relevant applications from high level processing concepts as inputs.

A need has long existed for a system and method that efficiently identifies HRAs usable to rapidly build prototypes and develop new applications.

The EXEcutable exaMPLes ARchive system Exemplar rapidly and efficiently identifies highly relevant applications HRAs from large application repositories. Using Exemplar a developer enters high level processing concepts e.g. toolbar download smart card as input e.g. initial query keywords and Exemplar uses information retrieval and program analysis techniques to retrieve HRAs that implement the high level processing concepts. Exemplar may also accept various types of inputs that describe high level processing concepts e.g. concept text identifiers concept visual identifiers concept audio identifiers and any other sensory identifier usable to identify high level processing concepts . Exemplar uses the help pages and help documentation of third party libraries software development kits and other middleware to produce a list of names of API calls that Exemplar in turn uses to expand an initial query query expansion to identify the application logic of HRAs and the API calls included in the HRAs. Exemplar determines the behavior of the application logic and API call logic and ranks the HRAs and API calls included in the HRAs.

Exemplar uses help documentation or other trusted sources that describe API calls to expand queries. An application provider typically provides the help pages and help documentation for their applications which developers consider reliable and a trusted source. In particular developers consider application providers trusted sources for help pages and help documentation of popular and widely used applications written by large development teams produced under rigorous testing and development best practices and used by other developers who provide feedback regarding documentation using different forums e.g. user groups . Developers trust help documentation over the descriptions of applications included in application repositories because application providers generally produce more verbose and accurate help documentation than the descriptions of applications included in application repositories. Developers also trust help documentation because many different people and review procedures are typically used to produce help documentation.

Exemplar query expansion increases the probability of identifying logic matches usable to build highly relevant application prototypes HRAPs and new applications and addresses the vocabulary problem mentioned above by expanding an initial query to include new keywords metadata and semantics information found in help pages and other help documentation determined to have similar meanings to the keywords originally used by a developer in the initial query. Exemplar expands an initial query to include the names of API calls with semantics that reflect in many cases unequivocally specific behaviour of the matched applications. Exemplar locates application logic containing the API calls that exhibit desired semantics by identifying API calls through help pages and help documentation. Exemplar provides a user interface that developers can use to navigate directly to the various locations to determine how an HRA implements high level processing concepts.

Exemplar may rank HRAs according to the number of high level processing concepts implemented by each API call found in the HRAs or based on other ranking metrics. In other words since API calls implement high level processing concepts the more high level processing concepts implemented by an HRA the more relevant the HRA and the higher the rank assigned to the HRA. Exemplar considers keywords included in queries to represent logically connected concepts. Often a question structured as a sentence forms the basis for a query from which a developer extracts keywords to form the query. For example consider the query send receive secure XML. Where a query presents a relation between multiple concepts e.g. send secure XML then a relation should exists between API calls that implement the concepts in the corresponding application logic e.g. API calls that encrypt process or handle XML formatted content and transmit content . Application logic often preserves the relations between concepts e.g. control flow and data flow links an instance of the software reflection model concept and known as connectivity heuristics. Exemplar calculates HRAs rankings based on analyzing the connectivity heuristics of API calls that implement the concepts included in the queries. Exemplar uses program analysis algorithms and computes control flow graphs CFG and data flow graphs DFG to analyze the connectivity heuristics of API calls.

Other systems methods and features of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the following claims.

The EXEcutable exaMPLes ARchive system Exemplar solves the technical problem of providing a tool that accepts high level processing concepts as queries to identify determine the behavior rank and return the application logic of HRAs. Exemplar solves an instance of the difficult vocabulary problem that exists when users and developers describe processing concept with different words. Exemplar is not limited to basic keyword matching used in queries against application descriptions and comments included with application logic. Accordingly when an application is highly relevant and where a query contains keywords different from the words used by the developer to describe application logic and API call logic Exemplar nevertheless returns the application as a highly relevant application.

Exemplar matches high level processing concepts e.g. expressed using keywords with the descriptions of various API calls found in help documents or other trusted descriptive sources. Because a typical application invokes API calls from several different libraries several different people who use different vocabularies often author help documents associated with API calls. The richness of different vocabularies increases the probability of finding matches and producing a long list of potentially relevant applications and API calls. Searching help documents or other trusted descriptive sources produces additional benefits. For example help documents including an API call often indicate where the application logic implements the API call. Consequently Exemplar may direct a developer to the location in application logic where an API call implements a high level processing concept. The developer may then determine the relevance of the application logic and API call logic. In other words the developer may determine whether the application logic and API call logic actually support the high level processing concept.

Although specific components of Exemplar will be described methods systems and articles of manufacture consistent with Exemplar may include additional or different components. For example a processor may be implemented as a microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other type of circuits or logic. Similarly memories may be DRAM SRAM Flash or any other type of memory. Logic that implements the processing and programs described below may be stored e.g. as computer executable instructions on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. An example of such a signal is a physical layer Ethernet signal bearing TCP IP packets that include program source code or executable programs. Flags data databases tables and other data structures may be separately stored and managed may be incorporated into a single memory or database may be distributed or may be logically and physically organized in many different ways. Programs may be parts of a single program separate programs or distributed across several memories and processors. Furthermore the programs or any portion of the programs may instead be implemented in hardware.

In one implementation the EPAD user interface expanded search engine heuristic relevance ranking engine and logic analyzer form an Exemplar system within the Exemplar environment . The Exemplar system may include additional or different components. The Exemplar system may communicate with the help content processor help content API calls dictionary and logic repository as well as other systems through the networks e.g. Internet as external systems.

The logic repository may include application logic and API call logic . The Exemplar system accepts high level processing concepts e.g. send secure XML as input and produces output identifying which application logic and API call logic developers may use to prototype and develop new applications implementing the high level processing concepts. In one implementation the Exemplar environment implements the help content and the logic repository with multiple storage devices e.g. multiple databases on different disk drives and interfaces to help content application logic and API call logic from various available source e.g. local or remote help databases websites knowledge exchanges document repositories or other sources .

In one implementation the help content processor may be implemented as a web crawler that traverses available application repositories and downloads help content e.g. application descriptions and logic repository content e.g. application logic and API logic . The help content processor may also perform full text indexing on the help content and the logic repository content. The help content processor may further produce an API calls dictionary that includes sets of tuples a form of ordered list that link selected words from the descriptions of the API calls to the names of the API calls.

The description above used the examples of application logic and API call logic . These types of logic may be program source code e.g. C or C code for example. However the Exemplar environment may search analyze and determine relevance for many other types of logic. As examples the logic repository may include programs or program components expressed in a visual programming language using graphical program elements and spatial arrangements of text and graphic symbols. The visual programming logic may include icon based logic form based logic diagram based logic or other types of visual expression. The visual expression may be consistent with dataflow languages flow based programming domain specific modelling or other programming paradigms.

The expanded search engine may combine the original query and the basis API call list to form an expanded query . The expanded search engine may execute an expanded search using the expanded query to search through the logic repository to obtain an expanded search result . In one implementation the logic repository may return the expanded search results to the heuristic relevance ranking engine . The expanded search result may contain a list of potentially relevant applications and potentially relevant API calls that the heuristic relevance ranking engine analyzes using the logic analyzer . In one implementation the heuristic relevance ranking engine may include the logic analyzer . The logic analyzer may include a parser generator such as ANTLR ANother Tool for Language Recognition available from www.antlr.org that provides support for generating data flow graphs and control flow graphs.

The logic analyzer may return connectivity rankings discussed in detail below to further determine an application heuristic relevance ranking and an API call heuristic relevance ranking . The heuristic relevance ranking engine may return the application heuristic relevance ranking and an API call heuristic relevance ranking to the EPAD user interface . The expanded search engine may also return a relevant applications list and a relevant API calls list to the EPAD user interface . The Exemplar system may assign an application heuristic relevance ranking to one or more relevant applications found in the relevant applications list to indicate how closely each relevant application supports the high level processing concept represented by the original query . Similarly Exemplar system may assign an API call heuristic relevance ranking to one or more relevant API calls found in the relevant API call list to indicate how closely each relevant API call supports the high level processing concept represented by the original query .

Table 1 shows an example of an original query in the form of a structured query language statement SQL that represents the high level processing concept compress uncompress ZIP file . Table 1 shows that the original query will search the help content e.g. Java Help Documents to identify a basis API calls list .

Table 2 shows one example of the help content represented by a fragment of Java Help Documentation released by Sun Microsystems Inc. that describes the functionality of classes exported from the Java.util package. The Java.util package defines a number of classes primarily collections classes that a developer may use when working with groups of objects. Referring to Table 2 the help content processor may identify partial matches for the class ZipEntry to the original query . The help content processor may search the help content and identify a fragment of the help documentation for the ZipEntry class shown in Table 3.

Table 3 shows the descriptions of two different methods e.g. getCompressedSize and setMethod for the ZipEntry class that include the terms compress and uncompress found in the high level processing concept compress uncompress ZIP file . The basis API call list may include the getCompressedSize and setMethod methods.

Table 4 shows an example of two equivalent forms of an expanded query that expand the original search from the help content e.g. Java Help Documents to the logic repository using the basis API call list from the original query . Table 4 statement A shows the getCompressedSize and setMethod that may be included in the basis API call list . Table 4 statement B shows the expanded query as a nested query where the original query and the basis API call list e.g. getCompressedSize and setMethod drive the outer query that searches the logic repository for potentially relevant applications to obtain the expanded query result including potentially relevant applications and potentially relevant API calls . The expanded query may improve upon the original query by targeting the search performed against the logic repository to obtain application logic with a high probability of including potentially relevant applications and potentially relevant API calls .

Table 5 shows another example of two equivalent forms of an expanded query that expand the original search from the help content e.g. Java Help Documents to the logic repository by combining the original query and the basis API call list to form the expanded query . Table 5 statement A shows the getCompressedSize and setMethod e.g. the basis API call list combined with the original query . Table 5 statement B shows the expanded query as a nested query where the original query and the basis API call list e.g. getCompressedSize and setMethod drive the outer query that searches the logic repository for potentially relevant applications to obtain the expanded query result including potentially relevant applications and potentially relevant API calls . The expanded query may improve upon the original query by targeting the search performed against the logic repository to obtain application logic with a high probability of including potentially relevant applications and potentially relevant API calls .

Table 6 shows an example of a fragment of logic extracted from the logic repository e.g. potentially relevant application that includes a potentially relevant API call e.g. getCompressedSize .

The relevant API list display area may include the relevant API call list returned by Exemplar system based on the original query . The relevant API call list may include a relevant API call identifier e.g. a function call name and a relevant API call identifier of the relevant API call logic e.g. source code for the function call and relevant API call logic respectively. The EPAD project area may present the relevant API call identifier and the relevant API call identifier as user selectable indicated by the arrow to display and highlight the relevant API call logic and the relevant API call logic in the logic display area . In one implementation the logic display area may highlight the relevant application logic and relevant API call logic and relevant API call logic so that the user can further determine the relevance of the logic to the high level processing concept represented in the original query .

The heuristic relevance ranking results display area shown in may include an application relevance threshold an API call relevance threshold data flow graph control flow graph and an API call graph . The heuristic relevance ranking results display area may display heuristic relevance ranking engine information to assist the user to determine the relevance of user selected logic. As will be described in more detail below the heuristic relevance ranking engine may determine the application heuristic relevance ranking for the relevant application logic based on the number of relevant API calls e.g. relevant API call logic and relevant API call logic found in the relevant application logic in comparison to other relevant application logic identified by Exemplar system . For example the high level processing concept example compress uncompress ZIP file may be entirely implemented in relevant application logic but only partially implemented in the other relevant application logic . As a result the heuristic relevance ranking engine may assign the relevant application logic a higher application heuristic relevance ranking than the other relevant application logic . In another implementation the heuristic relevance ranking engine may determine the API call heuristic relevance rankings of the relevant API call logic and the relevant API call logic based on analyzing semantics derived from the expanded query and the expanded search result which establish the behaviour of the relevant API call logic the relevant API call logic and the relevant applications logic .

The application relevance threshold and API call relevance threshold shown in may be user selectable and or pre configured with system default values. In another implementation Exemplar system may determine the application relevance threshold and the relevance threshold based a number of factors e.g. the complexity of the high level processing concept represented by the original query and the number of potentially relevant applications and potentially relevant API calls identified by the expanded search result . Exemplar system may use the application relevance threshold and the relevance threshold to further refine the relevant applications list and the relevant API calls list respectively. In one implementation the application relevance threshold and the relevance threshold may determine an application heuristic relevance ranking value that the potentially relevant applications must meet to be included on the relevant applications list . The API call relevance threshold may also determine the API call heuristic relevance ranking value that the potentially relevant API calls must meet to be included on the relevant API calls list . For example an application relevance threshold of 1 may indicate a low relevance requirement e.g. requiring loosely relevant applications and low application heuristic relevance rankings and allow a large number of potentially relevant applications to qualify as relevant applications e.g. relevant application logic . In another example an application relevance threshold of 10 may indicate a high relevance requirement e.g. requiring highly relevant applications and high application heuristic relevance rankings and allow only a fewer number of potentially relevant applications to qualify as relevant applications. The heuristic relevance ranking engine may also use the data flow graph and control flow graph to determine the application heuristic relevance ranking and API call heuristic relevance ranking and visually describe the relationships between the relevant application logic the relevant API call logic and the relevant API call logic discussed in further detail below.

The relevant API call logic and the relevant API call logic may be user selectable indicated by the arrow and provide the user the ability to generate a new application with the selected logic. To that end the EPAD project area may implement point and click drag and drop functionality for a user to select relevant API call logic and relevant API call logic to generate the new application . The EPAD project area may also build the new application by combining user selectable other relevant application logic relevant API call logic and relevant API call logic . The application creation display area may also identify requirements for the high level processing concept represented by the original query . For example a developer may desire to identify and confirm the requirements for implementing a high level processing concept e.g. send secure XML . In one implementation Exemplar may generate requirements documentation and end user documentation based on the help content related to the other relevant application logic the relevant API call logic and the relevant API call logic used to build the new application and identify the requirements in support of the new application .

The memory may also include expanded search logic . Table 5 above shows an expanded query where the search logic forms the expanded query by combining the original query and the basis API call list to form the expanded query . More generally the expanded search logic combines the original query and the basis logic results to form the expanded query and executes an expanded search using the expanded query . The basis logic results may include the basis API call list including zero or more basis API call identifiers e.g. the basis API call identifier and a basis application list including zero or more basis application identifiers e.g. the basis application identifier . The expanded search logic thereby obtains the expanded search results . The expanded search result may include potentially relevant applications and potentially relevant API calls that include zero or more potentially relevant application identifiers and zero or more potentially relevant API call identifiers e.g. potentially relevant API call identifier and potentially relevant API call identifier .

The memory may also include analyzer logic that the processor executes to identify application metadata and API metadata of the potentially relevant applications and the potentially relevant API calls respectively. Examples of application metadata include application descriptions application logic comments application parameter names and application parameter types of existing applications. Similarly examples of API metadata include API descriptions API logic comments API parameter names and API parameter types.

The analyzer logic may generate the data flow graph and control flow graph to obtain the API call graph . The API call graph may include nodes e.g. node and node that represent potentially relevant API calls and data flow edges e.g. data flow edge between the potentially relevant API calls to indicate data flow. provides additional examples. The analyzer logic may determine the data flow edge count corresponding to the number of connections between potentially relevant API calls within the potentially relevant application . A graph with n nodes has as many as n n 1 edges between nodes. The data flow edge count provides insight into the degree of connectedness for the data flow graph . The analyzer logic may also assign link values to the edges between nodes discussed in detail below. In one implementation the analyzer logic may determine the connectivity rankings e.g. strong connectivity ranking and weak connectivity ranking for each connection between the potentially relevant API calls based on common API parameters discussed in detail below.

In one implementation the logic analyzer produces the API call graphs . The logic analyzer may identify the application metadata and API metadata of the potentially relevant applications and the potentially relevant API calls respectively to analyze the data flow paths and connectivity between the potentially relevant API calls . The logic analyzer may provide the application metadata and API metadata to the heuristic relevance ranking engine . In an alternative implementation the heuristic relevance ranking engine may identify application metadata and API metadata and produce the data flow graph and control flow graph using logic analysis formulas rules and equations to obtain the API call graphs . The data flow graphs control flow graphs and API call graphs may be represented as mathematical structures. The logic analyzer may obtain the API call graphs as a result of comparing data flow and control flow between potentially relevant API calls .

In one implementation the logic analyzer may perform control flow analysis on the potentially relevant application to obtain control flow graphs and perform data flow analysis on the control flow graphs to obtain data flow graphs. The data flow graphs control flow graphs and API call graphs may similarly include nodes and edges. The logic analyzer may obtain a control flow graph by logically partitioning a potentially relevant application as a result of parsing the logic of the potentially relevant application into nodes that represent logic that includes API calls. The logic analyzer may assign parsed logic of the potentially relevant application to an assigned node until the logic analyzer identifies a potentially relevant API call or branching logic e.g. if then switch case and do while and add the assigned node to the control flow graph . Where a program includes multiple potentially relevant applications the logic analyzer may merge the control flow graphs produced for each potentially relevant application into a single control flow graph . The logic analyzer may obtain the API call graph by comparing the edges in the control flow graphs with the edges in the data flow graph . For example where a control flow graph includes an edge that a data flow graph does not include the logic analyzer may not include the edge in the corresponding API call graph . However where a control flow graph includes an edge that the data flow graph also includes the logic analyzer may include the edge in the API call graph .

In one implementation the logic analyzer may receive user input to determine particular dependencies between API calls. For example where a potentially relevant application uses a function pointer e.g. a type of pointer used in C and C languages to reference a potentially relevant API call and a hash table e.g. a data structure that associates keys with values to store an object that represents a data element passed between API calls the logic analyzer may receive user input to determine dependencies between API calls because the logic analyzer may otherwise interpret multiple possible dependencies between API calls when in fact only one or a finite set of valid dependencies exists.

In another implementation the logic analyzer may analyze the data flow paths e.g. edges between nodes discussed below e.g. link heuristics of the potentially relevant applications and potentially relevant API call logic to determine the connectivity rankings of each connection between potentially relevant API calls . In one implementation the heuristic relevance ranking engine may determine the application heuristic relevance ranking for the potentially relevant application shown in as potentially relevant application A based on the total number of API calls n represented by nodes that represent different potentially relevant API calls found in the potentially relevant application the total number of connections between the potentially relevant API calls e.g. edges equal to n n 1 e.g. data flow edge count the quality of the connections e.g. strong connectivity or weak connectivity and the type of link e.g. loop link single link or no link between the potentially relevant API calls .

The applications metadata and API metadata may describe the data flow paths between the different potentially relevant API calls e.g. nodes within the potentially relevant application . For example the logic analyzer may determine common API parameters and logic branches e.g. if then else found within the potentially relevant application and potentially relevant API calls to generate the data flow graphs control flow graphs and API call graphs . The logic analyzer may as also illustrates identify the function e.g. K x J x S y P y F x and G z of each potentially relevant API call e.g. and to determine the connectivity rankings .

In one implementation the logic analyzer may assign a weight W e.g. connectivity ranking to each connection between the potentially relevant API calls e.g. nodes . The logic analyzer may assign weak connections a weight of 0.5 and strong connections a weight of 1.0 depending on multiple factors. For example edge edge and edge may represent weak connections between potentially relevant API calls represented by node pairs and and and and e.g. function pairs K x and F x K x and J x and S y and P y respectively . Following the above example where functions K x and F x share a common API parameter but neither function generates the value of the common API parameter then the logic analyzer may assign the connectivity ranking between node pair and represented by edge a weak connection weight of 0.5. A weak connection assigned to a node pair e.g. and may indicate a low relative probability e.g. in comparison to the connectivity rankings of other node pairs that the node pair implements the high level processing concept represented by the original query . The logic analyzer may use other heuristic analysis methods and tools to determine whether to assign a weak connection to a connectivity ranking .

Alternatively edge and edge may represent strong connections between potentially relevant API calls represented by node pairs and and and e.g. function pairs K x and P y and J x and S y respectively . The logic analyzer may determine that where function J x produces variable y which both J x and S y share then the node pair and represented by edge may be assigned a strong connectivity ranking . A strong connection assigned to a node pair e.g. and may indicate a high relative probability e.g. in comparison to the connectivity rankings of other node pairs that the node pair implements the high level processing concept represented by the original query . The logic analyzer may use other heuristic analysis methods and tools to determine whether to assign a strong connection to a connectivity ranking .

The logic analyzer may also assign a link value L e.g. link value to each connection between potentially relevant API calls . For example Exemplar system may assign a link value L equal to 1 where a loop link e.g. edges form a loop exists between potentially relevant API calls e.g. nodes . Exemplar system may assign a link value L equal to 0.5 where a single link e.g. edge exists between potentially relevant API calls e.g. nodes . In another implementation Exemplar system may assign a link value L equal to 0 where no link exists between potentially relevant API calls e.g. node represents a potentially relevant API call that does not have a connection with other potentially relevant API calls in a potentially relevant application . Additional different or fewer weights may be used. The heuristic relevance ranking engine may use the connectivity rankings and link values assigned to each connection between potentially relevant API calls to determine the application heuristic relevance ranking according to 

The logic analyzer may determine an API call heuristic relevance ranking for a potentially relevant API call based on the connectivity ranking and link value assigned to each edge that includes the potentially relevant API call . For example where m represents the number of node pair including a particular node e.g. and and and and and the number of edges e.g. and that include the node equals m m 1 and the assigned value for each connectivity ranking and link value for each edge that includes the node represent W and L respectively the API call heuristic relevance ranking for the node may be determined according to Equation 1 above where m substitutes for n 

The Exemplar system greatly reduces the time cost and other resource expenditures associated with implementing a new application. The Exemplar system produces relevant results starting with high level processing concepts. A software developer may use the relevant applications to rapidly build new application prototypes.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and cope of the invention. Accordingly other implementations are within the scope of the following claims.

