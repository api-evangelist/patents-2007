---

title: System and method for dynamically configuring a multi-model node table
abstract: A system and method are described for dynamically generating a table containing data from multiple model nodes. For example, a computer-implemented method according to one embodiment of the invention comprises: displaying a plurality of attributes from multiple different nodes of an application; providing a user interface allowing a user to select attributes from the plurality of attributes to be displayed as columns within a table; receiving an identification of a set of attributes within the plurality of attributes selected by the user; and storing the identification of the set of attributes as configuration data within local data storage, the local data storage being separate from a system data storage in which program code and data for the application is maintained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589394&OS=08589394&RS=08589394
owner: SAP AG
number: 08589394
owner_city: Walldorf
owner_country: DE
publication_date: 20071129
---
This invention relates generally to the field of data processing systems. More particularly the invention relates to a system and method for dynamically configuring a table with data from multiple model nodes.

Traditional client server systems employed a two tiered architecture such as that illustrated in . Applications executed on the client side of the two tiered architecture are comprised of a monolithic set of program code including a graphical user interface component presentation logic business logic and a network interface that enables the client to communicate over a network with one or more servers . A database maintained on the server provides non volatile or persistent storage for the data accessed and or processed by the application .

The business logic component of the application represents the core program code of the application i.e. the rules governing the underlying business process or other functionality provided by the application. The presentation logic describes the specific manner in which the results of the business logic are formatted for display on the user interface. The database includes data access logic used by the business logic to store and retrieve data.

The limitations of the two tiered architecture illustrated in become apparent when employed within a large enterprise. For example installing and maintaining up to date client side applications on a large number of different clients is a difficult task even with the aid of automated administration tools. Moreover a tight coupling of business logic presentation logic and the user interface logic makes the client side code very brittle. Changing the client side user interface of such applications is extremely hard without breaking the business logic and vice versa. This problem is aggravated by the fact that in a dynamic enterprise environment the business logic may be changed frequently in response to changing business rules. Accordingly the two tiered architecture is an inefficient solution for enterprise systems.

In response to limitations associated with the two tiered client server architecture a multi tiered architecture has been developed as illustrated in . In the multi tiered system the presentation logic business logic and database are logically separated from the user interface of the application. These layers are moved off of the client to one or more dedicated servers on the network . For example the presentation logic the business logic and the database may each be maintained on separate servers and respectively.

This separation of logical components and the user interface provides a more flexible and scalable architecture compared to that provided by the two tier model. For example the separation ensures that all clients share a single implementation of business logic . If business rules change changing the current implementation of business logic to a new version may not require updating any client side program code. In addition presentation logic may be provided which generates code for a variety of different user interfaces which may be standard browsers such as Internet Explorer or Netscape Navigator .

The multi tiered architecture illustrated in may be implemented using a variety of different application technologies at each of the layers of the multi tier architecture including those based on the Java 2 Enterprise Edition J2EE standard the Microsoft .NET standard and or the Advanced Business Application Programming ABAP standard developed by SAP AG. For example as described below in a J2EE environment the business layer which handles the core business logic of the application is comprised of Enterprise Java Bean EJB components with support for EJB containers. Within a J2EE environment the presentation layer is responsible for generating servlets and Java Server Pages JSP interpretable by different types of browsers at the user interface layer .

As illustrated in each layer of the J2EE architecture includes multiple containers. The Web container for example is itself comprised of a servlet container for processing servlets and a Java Server Pages JSP container for processing Java server pages. The EJB container includes three different containers for supporting three different types of enterprise Java beans a session bean container for session beans a entity bean container for entity beans and a message driven bean container for message driven beans. A more detailed description of J2EE containers and J2EE services can be found in RGKK SAMS TYEJB 21 D 2003 see e.g. pages 353 376 .

A system and method are described for dynamically generating a table containing data from multiple model nodes. For example a computer implemented method according to one embodiment of the invention comprises displaying a plurality of attributes from multiple different nodes of an application providing a user interface allowing a user to select attributes from the plurality of attributes to be displayed as columns within a table receiving an identification of a set of attributes within the plurality of attributes selected by the user and storing the identification of the set of attributes as configuration data within local data storage the local data storage being separate from a system data storage in which program code and data for the application is maintained.

Described below is a system and method for dynamically configuring a table with data from multiple model nodes. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.

The display of data records in tables and forms and the associated editing of the tables and forms e.g. selecting deleting sorting etc by clients are central functions in Web based applications. Thus various techniques are provided within the J2EE architecture for creating and working with tables in response to client requests. In particular under a model view controller MVC architecture illustrated in Web based content using tables may be created within the Web Container using controllers and views that operate in conjunction with models within the EJB container . A detailed description of the MVC architecture is beyond the scope of the present application but briefly the controller manages the underlying table structure and data referred to in as a context node . The table structure is presented to Web clients in the form of one or more views which indicate for example how the table is presented within a Web page. Controllers may be implemented by servlets and views by Java server pages. The model within the EJB container provides an interface between the controller and the underlying table data stored within the database . See e.g. Gand Kmentioned above for additional detail on the MVC architecture at pages 148 152.

The view may be a table in which case the table receives its data from a multi element context node. At runtime each element of the node is mapped to a table row. Thus the number of table rows is identical to the number of node elements. The table columns are mapped to the context node attributes.

Various existing application server platforms employ a Model View Controller architecture to generate views for requesting clients. For example Web Dynpro is a programming paradigm developed by SAP AG the assignee of the present application which implements a Model View Controller architecture for generating and displaying views e.g. tables to end users. While certain embodiments of the invention are described herein within the context of Web Dynpro it should be noted that the underlying principles of the invention are not limited to any particular programming paradigm.

A table view shows data typically obtained from a persistent layer illustrated as remote system and system database in . In one embodiment the remote system is an R 3 system designed by SAP AG the assignee of the present application . The data are obtained from the remote system using a Remote Function Call RFC or Business Application Programming Interface BAPI . While the remainder of this application will refer to an RFC the underlying principles of the invention are not limited to any particular protocol.

A called RFC populates a model node with data. illustrates an exemplary context model node from an RFC called Ua Rfc Pdece Tree Query Childrn Input which is made of input nodes ending in ITQC in the example and output nodes ending in OTQC . A remote system provides data that are located in the RFC output models nodes. In the example shown in the RFC returns data in five output nodes . Rather than containing data one of the nodes Bapiret2 OTQC has messages that indicate if the RFC call has been successful or has failed.

In certain architectures such as Web Dynpro a table can only receive data from a single context node. Thus if an RFC returns data that needs to be shown in more than one node a value node illustrated in is created used as the source node of the table. The value node is populated with data from the RFC output model nodes . In the example shown in the value node called TableExploded receives data from three different model nodes from the same RFC output Et Object OTQC Et Edge OTQC and Et Tnode OTQC. The data are transferred from these three RFC output model nodes to the table value node TableExploded in order to be displayed in one table .

In sum a table is mapped to one and only one context node which is a value node if the table contains data provided by an RFC call which results in multiple output model nodes.

 Personalization allows users or administrators adapt an application to their personal requirements. Current systems offer some personalization options at the table level and table column level. For example an end user may hide or rearrange columns e.g. moving columns left or right . However the personalization tools used in current configurations do not allow users to add new columns.

Certain Collaborative Cross Applications or xApps designed by SAP AG offer an application called the Configurator that allows a user to create a table from an RFC call. The table is directly mapped to all elements of one output node of the RFC call and the elements not intended to be shown are ignored. The table configuration is saved in a permanent data layer e.g. within a system database . When it is time to generate the table the configuration is called and the columns to be shown are built dynamically. One significant limitation however if that the Configurator allows a table to be mapped one and only one RFC output model node.

In contrast the embodiments of the invention described herein allow an application administrator or other user to add new columns to a table whose data comes from any number of different RFC calls. One embodiment of a method implemented by the dynamic table generation logic to perform this function is illustrated in . At the attributes from a variety of different output model nodes are displayed for the user. One embodiment of a user interface for allowing the user to select attributes from multiple model nodes is illustrated in described below . At step the user s attribute selections are detected and at unique identifiers are generated for each attribute selected by the user. As described below in one embodiment the unique identifier comprises the name of the context node combined with e.g. appended to the attribute name. At configuration data containing the selected attributes is stored within a local storage such as the local database shown in

In response to a user request from a client at runtime at the dynamic table generation logic dynamically builds the context node attributes of the table using the configuration data stored within the local database . In one embodiment the new built attribute name is the name of the unique identifier generated in . At the dynamic table generation logic dynamically populates each newly created attribute by using its unique name. Its name indicates under which RFC output model node and attribute to select to retrieve the data. At the dynamic table generation logic dynamically builds the new table columns. In one embodiment each new column has its own cell editor mapped to the corresponding attribute created in . As is known by those of skill in the art the cell editor allows an end user or administrator to edit the contents of a cell when the table is not in read only mode.

One embodiment of the invention will be described with respect to . This example employs six RFC output model nodes which are labeled Et Edge OTQC Et Hier OTQC Et Node OTOC Et Object OTOC Et Tnode OTQC Et Tline OTQS. Note that all nodes whose names end with OTQC identified as in are output model nodes from one RFC call and the node which ends with OTQS identified as in is an output model node from another RFC call. Consequently this example uses output model nodes from two different RFC calls.

If the administrator does not know the name of the node he can run a small help program that shows in the logger the names of all context nodes. The original table prior to editing by the administrator is illustrated in . A first series of columns are provided for attributes from RFC call and a second series of columns are provided for attributes from RFC call . The columns of the RFC call are grouped columns under the header Prices. By default the RFC call provides data for the two columns that are named Row Type and MoQ Minimum Order Quantity .

In one embodiment the dynamic table generation logic shows all possible attributes of all nodes mentioned in the application property. In the administrator selects the table node he wants to modify from drop down menu . In the illustrated example the administrator has selected TableExploded. Once the table node selected from the drop down menu all attributes of the nodes associated with the table in the application property are displayed. Columns are displayed for node name attribute name attribute text selection boxes for selecting particular attributes and header . In the illustrated example the nodes have a total of 316 attributes although only 10 attributes rows are displayed in .

In one embodiment the administrator selects the additional attributes to add to the table as columns by checking selection boxes for the rows associated with the attributes. For example in the attribute Node Id of node Et Hier OTQC has been selected by checking the checkbox within row . Once a set of attributes has been selected in this manner the administrator saves the configuration by selecting the save button . The configuration including the newly selected attributes is then saved within the local database and subsequently used to generate the table. If the administrator wants to modify the configuration in the future he recalls the configuration by using the Load Config Button . In the illustrated example the administrator has chosen seven new columns each column from a different output node except for the output node Et Tline OTQS that has two new columns Material Price and Valid From . The administrator can also change the header of the new columns. In one embodiment the header of a new column is the name of the attribute of the RFC output model node. The default column name is listed under the column Attribute Text . In this example the administrator has changed the header of the new columns by changing the name under the Header column .

In one embodiment the unique identifier used to identify each attribute selected by the administrator comprises the node name combined with the attribute name. For example the last selection shown in is the attribute Cost Datval from the node Et Tline OTQS so in this embodiment its unique identifier is Et Tline OTQS Cos Datval. Regardless of the format used the unique identifier indicates exactly under which attribute and which model node the data for this column are maintained in the context. As previously mentioned in one embodiment the unique identifiers are stored within the configuration data on the local database . Subsequently during runtime the unique identifiers are retrieved to identify all attributes from all model nodes which are to be included within the table.

Specifically at runtime the dynamic table generation logic reads the configuration data from the local database and dynamically creates and populates the new table node attributes. The dynamic table generation logic also dynamically creates the table columns and dynamically maps the cell editors of the table columns to their respective new attributes. Returning to the above example the TableExploded node has its new attributes built dynamically and the names of the new attributes are their unique identifiers. For example the attribute Cos Datval of node Et Line OTQS is built dynamically using its unique identifier Et Tline OTQS Cos Datval. The six other attributes illustrated in are built according their unique identifiers in the same manner.

Once the dynamic attributes and all other table node attribute are populated the new table columns are built dynamically. As illustrated in in the above example the new table has the seven new columns two of them are from the Et Line OTS RFC output model node and are placed under the column grouped header Price. Using portal personalization the administrator can rearrange if desired the order of the columns including the new columns.

In summary the system and method described above allows application administrator or other user to add new columns to a table. The new columns can be created from any output model node of any RFC call. The additional configuration of the new columns is saved in a permanent layer which is separate from the system database . In the embodiments described above the permanent layer is a local database containing configuration data associated with the application. Because the configuration data is stored separately and used only at runtime the underlying program code and data for the application e.g. maintained on the remote system does not need to be modified.

It should be noted that a formal database structure is not required for local storage of the configuration data. For example the configuration data may be stored within a file system in any type of file format e.g. text XML etc while still complying with the underlying principles of the invention.

Each new column is identified by a unique identifier which indicates from which RFC output model node and from which attribute the data for this new column is retrieved. At runtime the following steps take place 

The appropriate new attributes of the table node are created dynamically according to the saved configuration.

Each new attribute is populated with the correct data using the unique attribute identifier that indicates where the data are located i.e. under which RFC model output node and which attribute .

The table columns are built dynamically one column per new attribute and their cell editors are respectively mapped to the corresponding attribute.

In addition one embodiment of the invention also uses the portal personalization techniques described above that allow the administrator to rearrange and hide table columns thereby increasing the customization possibilities of any tables shown in an application.

A system architecture on which embodiments of the invention may be implemented is illustrated in . The architecture includes a plurality of application server instances and . The application server instances and each include a group of worker nodes and also sometimes referred to herein as server nodes respectively and a dispatcher and respectively. The application server instances communicate through a central services instance using message passing. In one embodiment the central services instance includes a locking service and a messaging service described below . The combination of all of the application server instances and and the central services instance is referred to herein as a cluster. Although the following description will focus solely on instance for the purpose of explanation the same principles apply to other instances within the cluster.

The worker server nodes within instance provide the business and presentation logic for the network applications supported by the system including for example the model video controller architecture described herein. Each of the worker nodes within a particular instance may be configured with a redundant set of programming logic and associated data represented as virtual machines in . In one embodiment the dispatcher distributes service requests from clients to one or more of the worker nodes based on the load on each of the servers. For example in one embodiment the dispatcher maintains separate queues for each of the in a shared memory . The dispatcher fills the queues with client requests and the worker nodes consume the requests from each of their respective queues. The client requests may be from external clients e.g. browser requests or from other components objects within the instance or cluster.

In one embodiment the worker nodes may be Java 2 Enterprise Edition J2EE worker nodes which support Enterprise Java Bean EJB components and EJB containers at the business layer and Servlets and Java Server Pages JSP at the presentation layer . In one embodiment JSPs are used to implement the different views described above and servlets are used to implement the controllers . In this embodiment the virtual machines implement the J2EE standard as well as the additional non standard features described herein . It should be noted however that certain high level features described herein may be implemented in the context of different software platforms including by way of example Microsoft .NET platforms and or the Advanced Business Application Programming ABAP platforms developed by SAP AG the assignee of the present application.

In one embodiment communication and synchronization between each of the instances is enabled via the central services instance . As mentioned above the central services instance includes a messaging service and a locking service. The message service allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example messages from one server may be broadcast to all other servers within the cluster via the messaging service e.g. such as the cache configuration messages described below . Alternatively messages may be addressed directly to specific servers within the cluster i.e. rather than being broadcast to all servers . In one embodiment the locking service disables access to i.e. locks certain specified portions of configuration data and or program code stored within a central database . The locking service locks data on behalf of various system components which need to synchronize access to specific types of data and program code. In one embodiment the central services instance is the same central services instance as implemented within the Web Application Server version 6.3 and or 6.4 developed by SAP AG. However the underlying principles of the invention are not limited to any particular type of central services instance.

In addition unlike prior systems one embodiment of the invention shares objects across virtual machines . Specifically in one embodiment objects such as session objects which are identified as shareable are stored within a shared memory region and are made accessible to multiple virtual machines . Creating new object instances from scratch in response to client requests can be a costly process consuming processing power and network bandwidth. As such sharing objects between virtual machines as described herein improves the overall response time of the system and reduces server load.

In a shared memory implementation a shared memory area or heap is used to store data objects that can be accessed by multiple virtual machines . The data objects in a shared memory heap should generally not have any pointers or references into any private heap e.g. the private memory regions heaps of the individual virtual machines . This is because if an object in the shared memory heap had a member variable with a reference to a private object in one particular virtual machine that reference would be invalid for all the other virtual machines that use that shared object.

More formally this restriction can be thought of as follows For every shared object the transitive closure of the objects referenced by the initial object should only contain shared objects at all times. Accordingly in one implementation of the invention objects are not put into the shared memory heap by themselves rather objects such as the session objects described herein are put into the shared memory heap in groups known as shared closures. A shared closure is an initial object plus the transitive closure of all the objects referenced by the initial object.

Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine executable instructions which cause a general purpose or special purpose processor to perform certain steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

Elements of the present invention may also be provided as a machine readable medium for storing the machine executable instructions. The machine readable medium may include but is not limited to flash memory optical disks CD ROMs DVD ROMs RAMs EPROMs EEPROMs magnetic or optical cards.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example although many of the embodiments set forth above relate to a Web Dynpro Java or J2EE implementation the underlying principles of the invention may be implemented in virtually any client server environment. Moreover although some of the embodiments set forth above are implemented within a shared memory environment the underlying principles of the invention are equally applicable to a non shared memory environment. Finally it should be noted that the terms client and server are used broadly to refer to any applications components or objects which interact over a network.

Accordingly the scope and spirit of the invention should be judged in terms of the claims which follow.

