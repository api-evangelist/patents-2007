---

title: Method and system for rapidly developing and deploying sensor-enabled software applications
abstract: A system for deploying component-based software systems for the implementation of desired sensor data process flows makes use of a toolset of software components specially tailored for building sensor data process flows. In one or more embodiments, the system comprises a front-end application operative to generate system specifications from user input, each system specification defining a desired component-based software system of one or more sensor components and their corresponding configurations in accordance with sensor component class definitions (e.g., the toolset) for a predefined set of sensor components tailored for building desired sensor data process flows. The system further includes a back-end application operative to store the sensor component class definitions for use in instantiating sensor components as needed, receive system specifications, and dynamically build and run the corresponding desired component-based software systems within a run-time environment provided by the back-end application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735060&OS=07735060&RS=07735060
owner: Augusta Systems, Inc.
number: 07735060
owner_city: Morgantown
owner_country: US
publication_date: 20070308
---
This application claims priority under 35 U.S.C. 120 as a continuation in part of the United States patent application filed on 14 Feb. 2007 entitled METHOD AND SYSTEM FOR RAPIDLY DEVELOPING SENSOR ENABLED SOFTWARE APPLICATIONS and assigned application Ser. No. 11 674 893 the disclosure of which is expressly incorporated herein by reference and which itself claims priority under 35 U.S.C. 120 as a continuation in part of the United States patent application filed on 29 Jun. 2006 entitled RECONFIGURABLE HIERARCHICAL COMPONENT BASED ARCHITECTURE FRAMEWORK AND METHODS FOR RAPIDLY DEVELOPING SENSOR DEVICE ENABLING SOFTWARE APPLICATIONS and assigned application Ser. No. 11 478 085 the disclosure of which also is expressly incorporated herein by reference.

The present invention generally relates to software development systems and methods and particularly relates to a method and system for rapidly developing and deploying sensor enabled software applications.

IDEs integrated development environments such as the VISUAL STUDIO development environment offered by MICROSOFT greatly facilitate the development of complex software applications. However whether or not an IDE is used developing sensor enabled software applications represents a significant programming challenge.

For example a given software application may be required to collect and process sensor data from a variety of local and or remote sensors. Generally at least for each type of sensor involved and for each type of connection local or remote file or database etc. the programmer must add dedicated program code. Further given the possible interrelationships represented by the data being collected from different types of sensors and or from sensors in different locations and given the often asynchronous nature of sensor data events coordinating the collection processing and interlinking of such data is challenging to say the least.

While the range of features and operations of sensor enabled software applications varies as widely as the range of sensor types and desired functionality most or all such applications commonly share the requirements of obtaining processing and storing sensor data. In many instances even these basic requirements require significant programmer effort given the often asynchronous nature of sensor based data acquisition the wide range of data types involved and the potentially complex data and processing flows involved. To that end a component based software toolset and corresponding method enable rapid development of sensor enabled software applications based on defining and providing a set of sensor related software components that operate as simple building blocks which are layered or hierarchically linked together to form complex and robust sensor enabled software applications.

For example in one or more embodiments a component based software toolset for rapidly developing sensor enabled software applications includes a number of building block components i.e. it includes a number of class definitions enabling a programmer to instantiate the building block components as needed or desired within the sensor enabled software application being developed. Thus in one more embodiments the toolset comprises software component class definitions for a plurality of sensor related software components including data source components data destination components data series components and data field components.

Correspondingly this disclosure describes and claims a system for deploying component based software systems for the implementation of desired sensor data process flows. The system makes use of the above described toolset or variations thereof. In one or more embodiments the system comprises a front end application operative to generate system specifications from user input each system specification defining a desired component based software system of one or more sensor components and their corresponding configurations in accordance with sensor component class definitions e.g. the toolset for a predefined set of sensor components tailored for building desired sensor data process flows. The system further includes a back end application operative to store the sensor component class definitions for use in instantiating sensor components as needed receive system specifications and dynamically build and run the corresponding desired component based software systems within a run time environment provided by the back end application.

Those skilled in the art will appreciate that the front end and back end applications may comprise separate applications configured for installation at the same computer or at different computers. In such embodiments the front end application allows users to define system specifications to be built and run by the back end application. That is each component based software system comprises one or more sensor components selected from the predefined set of sensor components and configured by a user as needed to implement all or part of a desired sensor data process flow. With this framework the user defines desired component based software systems using the front end application and the back end application dynamically builds and runs them such that a target computer hosting the back end application performs the desired sensor data processing.

With the above framework in mind a programmer can build sophisticated sensor data acquisition and processing flows simply by adding inter linking and configuring a few simple components as building blocks. Further the system described herein for deploying component based software systems allows a user to build templates e.g. system specifications for desired component based software systems in a front end application in accordance with the software components defined in the toolset and then transfer those templates to a back end application for dynamic instantiation and running. While not limited to installation on separate computers the front and back end applications advantageously allow the user to generate system specifications at one location and then distribute or transfer those specifications to any number of computers which may be geographically dispersed network accessible computers intended for desired sensor data processing.

Of course the present invention is not limited to the above features and advantages. Indeed those skilled in the art will recognize additional features and advantages upon reading the following detailed description and upon viewing the accompanying drawings.

With the above broad applicability in mind illustrates that in at least one embodiment the toolset is configured as an add in to an IDE Integrated Development Environment which includes a GUI graphical user interface for drag and drop application development a programmatic interface for command line text editor based programs and other IDE tools and supporting software . In at least one such embodiment the IDE comprises MICROSOFT VISUAL STUDIO and the toolset comprises an add in toolset for VISUAL STUDIO. In this and in other IDE embodiments the toolset provides graphical representations of its defined sensor related components such that the programmer can instantiate those components as needed via drag and drop programming. Further the toolset supports programmatic instantiation of its components and for at least some of those components supports programmatic control such as manual data reads event triggers etc. as will be explained later herein.

Of course those skilled in the art will appreciate that the toolset broadly comprises a set of sensor related components that allow programmers to build sophisticated sensor enabled software applications by adding predefined sensor related components and interlinking those components to define potentially complex sensor data processing flows. As such the toolset may be configured as an add in for IDEs other than VISUAL STUDIO and different versions of the toolset may be produced for different IDEs. Further as illustrated in the toolset may comprise a standalone software application although it still may link with other installed applications such as language compilers etc. and may therefore include program code providing its own graphical and programmatic interfaces and respectively and may provide a host of additional supporting development tools and functions .

To obtain sensor data from the data source the programmer instantiates a data source component which is linkable to a specified source of sensor data and operative to obtain incoming sensor data from the specified source. That is the data source component allows the programmer to specify the particular data source or sources for some types of data source components from which to acquire sensor data and further provides one or more software methods or functions for reading or receiving sensor data from the specified data source. Thus generally speaking the programmer adds a data source component for each source of sensor data of interest and each data source component acts as an input conduit for sensor data from the linked source. Note too that one or more embodiments of the data source component can obtain data from more than one source. That is a given data component can be reconfigured on the fly to bring in data from more than one source or in at least some embodiments it can operate with changeable identifiers or commands that bring in data from different sources.

To collect incoming sensor data from the illustrated data source component the programmer instantiates a data series component . The data series component is linkable to a specified data source component and is operative to generate an in memory data series table not shown in and to automatically collect incoming sensor data from the linked data source component in its data series table. As such the programmer adds as many data series components as desired for collecting the incoming sensor data from a given data source component . Further the programmer links each data series component to a desired number of data destination components one is illustrated such that each data series component automatically provides new table data from its data series table to each linked data destination component.

Thus in the context of the data source component obtains sensor data from the data source and thus acts as a source of incoming sensor data. In turn the data series component links to the data source and automatically collects that incoming sensor data into its data series table. Further in turn newly populated table data may be passed by the data series component to the linked data destination component which may be of a type that writes data to files to a database or that sends the table data over a network socket connection.

Notable details to be more fully explored later herein are that one or more embodiments of the data series component can be configured to catch filter or otherwise process the incoming sensor data to conditionally evaluate the incoming sensor data and or the processed data and to raise one or more programmer specified events based on the conditional evaluation. However it should be understood that even in their most simple embodiments the data source component data series component and data destination component together define a configurable sensor data processing flow that allows the software application being developed to obtain sensor data from a given data source and automatically collects that sensor data into system memory optionally qualifies and or processes it and then passes it along to a desired destination subject to that qualification and processing. All of this can be done without any or with very little manual programming using point and click programming techniques.

Those skilled in the art may have recognized that the above example alluded to the potential sophistication of the data series component . illustrates one embodiment of the data series component in more detail as defined by the associated class definitions provided in one or more embodiments of the toolset . The illustrated data series component generates an in memory data series table and includes one or more data field components each one defining a corresponding data field i.e. column in the data series table . The data series component optionally further includes output target components data event components and event condition components . Note that in the illustrated hierarchy the data field components are children of the data series component as are the data event components and the output target components while the event condition components are children of respective ones of the data event components . Those skilled in the art will recognize the illustrated hierarchy as logically advantageous but non limiting. 

As explained before each data field component is operative to define a data field in the data series table of the parent data series component by controlling which portion of incoming sensor data is stored in a corresponding column of the data series table and by controlling the data type used for storing that portion of the incoming sensor data in the corresponding column. The data field component includes methods enabling the programmer to specify these properties. That is data field component is defined to include one or more software methods or functions operative to receive programmer input identifying the portion of incoming sensor data to store in the corresponding column and indicating the desired data type to be used for storing that portion of the incoming sensor data.

In more detail each data field component allows the programmer to specify which portion of the incoming sensor data should be stored in the data series table field defined by that data field component . Also where that portion of data is itself composite in some sense the data field component further allows the programmer to specify the elements or components of that composite data that is specifically of interest. For example assume that a given data field component is configured to take a byte array from the incoming sensor data. In that case the data field component allows the programmer to identify the one several or a range of array elements within that byte array that are of particular interest such that only those specified elements are captured. Aiding this functionality the data field component may be defined such that an instantiated data field component is operative to display data element selection options that are tailored for the particular data type that the programmer has selected for that data field component e.g. offset and mask values for string array binary packet .

In at least some embodiments the class definitions for the data field component also include one or more software methods or functions operative to perform on the fly data conversion as needed such that the indicated portion of the incoming sensor data that is to be stored in the corresponding column of the corresponding data series table is automatically converted to the desired data type. This dynamic data conversion may be quite sophisticated and enables the conversion of disparate data types e.g. float values to time date stamps .

In the broader context each data field component is configurable by virtue of various options relating to the type of input data the portions of elements of input data that are of interest for the data field defined by the given data field component and the data type of the defined data field which may be quite different than the data type of the incoming data portion that is of interest . In at least one embodiment of the toolset the options presented for configuring a data field component change as configuration decisions are made i.e. the range of options presented narrows as higher level options are successively set meaning that the options presented at any given time are only those remaining options that are relevant or sensible. Indeed in one or more embodiments of the toolset some or all of the component definitions include software methods or functions whereby the option property settings of an instantiated component presented to the programmer are dynamically narrowed or tailored to display only those items appropriate for the current configuration state of the component. 

As an example the field relationships that can be configured for a given data field component are configurable via a number of options but subsets of those options make sense for one type of input data but not others. Thus in one embodiment of the toolset the options presented to the programmer for a given data field component dynamically change as a function of the type of data source component that is linked to the parent data series component .

As one example for a command component type as the input source the options for specifying the input data items of interest are the parameters associated with the command function or the return value s associated with the command function. As another example if the parent data series component links to another data series component as its source of data the options for setting the data field definitions indicate the data fields defined in the data series table of the source data series component or can be related to an eXtensible Markup Language XML version of the data fields in the source data series component .

Further regardless of what provides input data to a given data series component the toolset includes program code enabling data field components to be used for defining custom data fields. In at least one such embodiment the class definitions allow an instantiated data field component to be used for defining a custom data field in the data series table of its parent data series component . In this sense the term custom denotes data not mapped directly from the incoming sensor data although the custom value may be derived from that data.

For example assuming that a given data series component includes two data field components that have been configured to define first and second integer data fields in the data series table of their parent data series component . With that the programmer could add a third data field component and configure it to generate a custom data field value by adding the first two data field values. As such each time a new row in the data series table is populated with new values for the first and second integer data fields their sum would be stored in the custom data field of that row.

More generally in at least one embodiment the toolset allows the programmer to define custom values by combining the incoming data for two or more defined data fields to obtain a custom field or to otherwise mathematically or logically process all or part of the incoming data to derive a custom value. In other instances custom values may comprise current time date stamps row count values etc. In short the custom value generation capability of the data field components allows custom data values to be stored whenever a new row in the data series table is populated with incoming sensor data.

Thus the data field components added to a given data series component define the schema of the data series table in that given data series component . That is each added data field component defines a corresponding column in the data series table controls which data is stored in that column and controls the type of data held in that column performing data conversion if the incoming data for that column is of a different type.

While the data field components control data inputs to the data series table the output target components control or at least direct data output from the data series table . More particularly one or more embodiments of the toolset include class definitions allowing the programmer to instantiate output target components as desired within the parent data series component . Each output target component links the data series table of the parent data series component to a specified data destination component . More generally each output target component is operative to link the data series table of its parent data series component to a data destination component such that the parent data series component automatically passes data from its data series table to any data destination component linked to it by a given output target component . In at least some embodiments each output target component provides a Boolean enable flag that can be set and cleared programmatically enabling run time enabling and disabling of the output link between a given data series component and targeted data destination component .

Notably in one or more embodiments of the toolset data series components can be configured by the programmer to set the size number of rows of the data series table and to control how data overflow conditions are handled. For example as the data series component automatically populates new rows in its data series table in response to newly incoming sensor data it will generally reach the maximum row count. At this point in accordance with programmer specified preferences newly incoming sensor data will be ignored i.e. not written to the table or newly incoming sensor data will be added to the table according to a specified overwrite preference e.g. oldest data overwritten first . As such the data series table can be frozen once its maximum size is reached or it can be operated as for example a circular buffer.

In any case even the above basic arrangement of components provides sophisticated essentially automatic sensor data flow processing. To appreciate this point assume that the data source component obtains new incoming sensor data from the data source e.g. new data comes in from a network connection. That sensor data automatically passes to the data series component . The data field components break the incoming data down or otherwise parse it such that desired portions of the incoming data are mapped to the appropriate columns of the data series table and if necessary perform automatic on the fly data type conversion so that the data actually stored in the data series table is of the desired data type. Thus the data field components collectively operate to automatically populate a new row in the data series table with the mapped converted data.

Then as a function of a new row of data being populated in the data series table each output target component automatically passes the new row data out to the programmer specified data destination component . The programmer can add as many output target components as there are desired unique destinations for the table data and this allows the table data of one data series component to be mapped to multiple data destination components . As non limiting examples data destination components can represent database writers file writers network socket connections and other components within the toolset .

As a further point of flexibility at least some embodiments of data series components allow one data series to be linked as the data source component for another data series component . Such linking allows one data series component to pass table data from its data series table along to another data series component which will store all or a portion of that table data according to its particular configuration.

Adding further to the sophistication of the data series component one or more embodiments of the toolset include class definitions allowing the programmer to instantiate data event components for given data series components . In at least one such embodiment data event components are added as children of a data series component . Each data event component is operative to conditionally trigger a desired action responsive to incoming sensor data for its parent data series component .

As simple non limiting examples the programmer can configure one or more data event components to filter or otherwise process incoming sensor data. For example incoming sensor data can be blocked from the table unless it is at or above a defined threshold. As another example incoming sensor data can be filtered or otherwise adjusted as it is incoming to the parent data series component . The action s taken by data event components is conditional based on an evaluation of the incoming data. To support conditional evaluation the toolset includes class definitions and supporting methods functions allowing the programmer to instantiate event condition components for each data event component . Each event condition component is operative to define a condition to be tested or otherwise evaluated as the basis for conditionally triggering the desired action of the parent data event component . That is an event condition component is operative to receive one or more user defined conditions used by the linked data event component . With this logical framework data event components are configured such that multiple event condition components are addable to a given data event component wherein each data event component includes software methods or functions providing logical AND ing and OR ing associations between multiple event conditions.

In more detail the specific operation and conditional triggering of a given data event component is defined by the programmer based on configuring the event condition component s added as children of the given event condition component . With this arrangement each data event component may be understood as comprising one or more conditional expressions event conditions wherein each conditional expression is defined by a child event condition component .

In at least one embodiment an event condition component operates with two expression values 1 the incoming sensor data value of interest for a given data field component and 2 a user defined value which may be entered by the programmer another data field value within the same series whether newly incoming or previously stored in the data series table of the parent data series component as selected by the programmer. Thus as a non limiting example the programmer can define a conditional expression that may be defined using the sub data intended for a given data field in a given data series table and a past value of that same data field to allow filtering of that data. Note that conditional evaluation is performed after any of the dynamic data type conversion operations carried out by any of the involved data field components is completed so that compatible or like data types are involved in the comparison s .

Regardless the two expression values are linked by an operation e.g. greater than equal to less than contains etc. which is specified by the programmer. With the expression values thus identified and the conditional relationship between the two values defined a given data event component conditionally triggers responsive to incoming sensor data as a function of whether its defined condition s is satisfied. Where multiple conditions i.e. multiple event condition components are defined for a given data event component the programmer can specify whether the data event component should trigger as a function of OR ing or AND ing those multiple conditions.

As those skilled in the art will appreciate the conditional logic afforded by the above structure enables the programmer to define very sophisticated data collection and filtering functions provide alarm based functions etc. For example a given data series component can be made to ignore newly incoming sensor data unless one or more values as segregated by the field component mappings exceed a given threshold. By ignoring the data the field components do not write data into the data series table and the output target components do not pass data along to the specified data destination components . Thus data not of interest can be blocked from propagating into the processing flow. The data event components also have in at least some embodiments programming hooks allowing the programmer to conditionally trigger the execution of custom code and essentially any number of conditional actions may be taken.

To appreciate such functionality in operation immediately before a row of data values are inserted into the data series table by the field components the data series component or other program code within the toolset checks to see if there are any data event components . If so every event condition conditional expression defined for each event component is evaluated. If the event conditions for a given one of the data event components are satisfied e.g. true then the conditional action defined by that data event component is performed. Otherwise the conditional action is not performed.

Conditional event triggering sub data selection and automatic conversion data destination targeting and other functions afforded by data series components make them a useful building block for programmers developing sensor enabled software applications. However the encapsulation and hierarchies illustrated in for the data series component are extended in one or more embodiments of the toolset such that the toolset offers programmers a fully hierarchical set of building blocks. While various embodiments of the toolset adopt varying hierarchical arrangements of component building blocks illustrates the arrangement adopted in one embodiment of the toolset .

According to the illustrated embodiment the toolset includes a sensor system component which is operative to contain among other items a related collection of data source data series and data field components. That is the programmer can instantiate a data sensor system component and then instantiate within it the desired number of child data source components data series components and data destination components . As such and as its name implies the sensor system component effectively provides programmers with the ability to create a complete sensor data processing sub system within their software applications simply by instantiating via drag and drop or program code a sensor system component and populating it with the desired configuration of child components.

For example the program code defining the data source component class includes program code defining a file reader component class enabling the programmer to instantiate file reader components as needed each one operative to obtain sensor data from a user specified data file. More particularly the file reader component with its included properties and methods reads data from a specified file and provides an indication that new data is available.

In that manner any data series component that is linked to the file reader component recognizes that the file reader component has read new data from its target file and automatically pulls that new data in from the file reader component . To facilitate automatic population of new file data into the data series table of a linked data series component the data series component allows the programmer to specify file reader as the input type and to specify the file reader name or identifier to link the specifically desired file reader component with the data series table of the data series component . Note that multiple file reader components may be instantiated within any given sensor system component and any data series component within the same sensor system component can specify any file reader component within the same sensor system component as its input.

Once a file reader component is instantiated and a given data series component is linked to it file data is read from the target file using read methods provided by the file reader component . These read methods provide numerous options that enable the programmer to specifically define what part s of the file need to be read. When linked to a given data series component every time a row of data is read from the target file that data is automatically populated in the corresponding data series table subject of course to the field definitions imposed on that table and subject to any conditional events defined for that table.

As non limiting examples file reader components include software methods or functions enabling them to read among other formats XML Comma separated values CSV Binary Excel and Text files. In the case of XML files the file reader component allows the programmer to specify a node depth indicating the node depth of the data. Finally file reader components also include file close methods that allow their target files to be released for other use. As such file reader components allow the software application to automatically read sensor data from a local or network available data file and push that data into the data processing flow s defined by the selected arrangement of sensor components as provided by the toolset .

Similar data retrieval functionality is provided for databases via the database reader component class definitions which allow the programmer to instantiate database reader components as needed each operative to obtain sensor data from a user specified database. Thus database reader component instantiated within a parent sensor system component serves as the data source component for any one or more of the data series components that reside within that parent sensor system component .

The programmer uses each database reader component to read data from a database table and then automatically insert that data into a corresponding data series table . To accomplish this the database reader component includes software methods and properties that enable it to read data from a target database and indicate the availability of that new data such that any link data series component automatically populates a new row in its included data series table with that new data subject of course to the field definitions imposed on that table and on any event conditions associated with that table.

The class definitions for the database reader components include methods and properties that allow the programmer to set input type and name values that link a given database reader to the desired target database. More particularly the programmer can specify the type of database connection string connection type provider driver location of the database server database name database table name and authentication credentials as well as a query statement. Non limiting examples of supported database types include SQLServer where SQL denotes Structured Query Language Access MySQL and Oracle. Connection strings and provider drivers for SQLServer Access MySQL and Oracle databases are automatically generated and provided. In cases of a database outside of the aforementioned database types the connection strings and provider driver may be linked in for compatibility with closed proprietary databases.

In any case once a database reader component is instantiated and configured by the programmer it acts as a source for sensor data for any data series component that is linked to it. As with the file reader components any number of data series components within the same parent sensor system component can be linked to the same database reader component .

Still further data retrieval options are available to the programmer via use of command components . That is the program code defining the data source component class includes in one or more embodiments of the toolset program code defining a command component class. These class definitions enable the programmer to instantiate command components each operative to wrap a user specified API e.g. a WINDOWS API or unmanaged DLL such that the user specified API or unmanaged DLL operates as a source of sensor data within the parent sensor system component . Effectively command components allow the programmer to integrate third party program code meant for specific types of sensors or other data sources. Non limiting examples include third party cameras frame grabbers data acquisition devices etc.

In operation the programmer instantiates a command component and one or more child command parameter components for each API DLL function to be wrapped within the sensor system component . A single command component represents one function that needs to be wrapped from the API or unmanaged DLL . The command component can have a return value just like a function. The various parameters arguments associated with the third party function being wrapped must be defined by using command parameter components . In general a command component is created for every function to be wrapped and for each such command component a command parameter component is instantiated for each parameter or argument needed for the wrapped function. Callbacks can also be implemented dynamically in order to interact with the third party function. Advanced data types such as structures classes etc. can also be passed in as command parameters or received as return arguments.

As with the database and file reader components and a given command component can operate as a data source component for any number of data series components within the same sensor system component . With that arrangement data reads or the equivalent acquisition function can be exercised for the API DLL function wrapped by a given command component and the command component indicates the availability of the new data such that any linked data series components automatically populate a new row in their respective data series tables subject to field definitions and event conditions.

One advantageous use of command components is the marshaling of sensor data from unmanaged to managed code. That is the command components enable the programmer to use dedicated WINDOWS API and unmanaged DLL functions such as driver software for special types of sensors in a managed code environment such as the .NET environment of MICROSOFT VISUAL STUDIO.

Also note that command components can be controls as well. For example one command component can read a motion detector via the DLL function it wraps. Assuming that a return value of that function indicates motion another command component can be used to call a function that unlocks perimeter doors sounds alarms etc.

Further while the command components provide an advantageous mechanism for obtaining data via WINDOWs API and unmanaged DLL functions data of interest also may be generated via managed code DLLs of other functions operating within a given software application incorporating one or more of the toolset s components. Data from such sources and others can be input to a given data series component using an add values method or function provided in the toolset . In at least one embodiment the class definition for data series components includes an add values method. 

The add values method can be called programmatically at run time for example and it provides for the direct input of specified data into the data series table of the data series component for which the method is invoked. The data input by the add values method is processed via the data field components and any data event components like other data incoming to a data series component . 

As one example of the add values method use assume that the desired source of input data for a given data series component is the serial port of a PC not shown . Serial port data values may be available via functions that do not require wrapping via command components . As such those functions may be called to obtain serial port data and that obtained data may be pushed into a given data series component using the add values method of that given data series component .

Of course the toolset also offers a number of advantageous data output mechanisms as well which include a number of destination components that serve as targets for output data and in one or more embodiments software methods or functions for outputting table data from the data series table of a given data series component . For example at least one embodiment of the toolset includes program code defining a memory stream method or function that on invocation outputs one or more rows of table data from a data series table of an instantiated data series component as stream data. The ability to stream out a full row of table data in a single stream is advantageous for certain types of data such as large byte arrays etc. In at least one such embodiment the data series component class definition s include a memory stream method that can be invoked for any given data series component of interest.

As for defined data destination components in one or more embodiments the program code comprising the toolset includes class definitions allowing the programmer to instantiate several different types of data destination components . Non limiting examples of data destination component types include database writer components and file writer components .

Each database writer component instantiated within a parent sensor system component allows the exportation of table data from the data series tables of the data series components that are linked to that database writer component through output target components . Note that in an alternate embodiment output target components are not used and data destination components include software methods or functions allowing them to be linked to respective data series components . 

To facilitate the logging of table data from the linked data series components each database writer component allows the programmer to define the source of the data to be logged the output parameters the connection management details and the database type. An appropriately configured database writer component thus is operative to log data in real time for a specified data series component . Notably the database writer component automatically creates if the database table doesn t exist and inserts data into the database table whenever a row of data gets added to the related data series table assuming that the database writer component is enabled. Moreover the database connections are automatically opened and closed and the connection strings and drivers needed to connect to the various database formats are automatically provided depending on the connection type and database type specified. Additional information such as the username password database name table name and file path can be specified within the constructs provided by the database writer component .

Similarly file writer components enable the programmer to output table data from a linked data series component for example to a target file specified by the programmer. That is each file writer component instantiated by the programmer enables the exportation of table data to any one or more common data file formats. Each file writer component thus allows the programmer to specify the source of the data to be logged the output parameters to be used and the file type involved. With that information the file writer component automatically creates if the file doesn t exist and inserts table data into the data file whenever new table data is added to the data series table of a linked data series component .

While the above examples of data source component types and data destination component types provide convenient mechanisms for bringing sensor data into a sensor system component and outputting structured data table data from that sensor system component further illustrates two component types capable of serving as inputs and outputs namely server components and client components .

Broadly stated one or more embodiments of the toolset include class definitions enabling the programmer to instantiate server components and client components as needed. Each server component and client component is operative to obtain sensor data from user specified network socket connections or to send table data from a linked data series table through a user specified network socket connection. Moreover each such component supports Transport Control Protocol Internet Protocol TCP IP and User Datagram protocol UDP communications for both IPv4 and IPv6. As will be described later this capability allows protocol conversion from IPv4 to IPv6 or vice versa merely by linking together an appropriately configured client server component pair. 

In more detail each server component can send data to and or receive data from a plurality of specified network addresses and each server component can be linked to any number of client components . In contrast each client component either sends data to or receives data from one network address or linked server component at a time. In more detail each server component can simultaneously maintain multiple network connections where the client maintains only one network connection at a time. However because the network connections can be re specified for servers and clients on the fly a given client component can connect one at a time to any number of network addresses. These one to many and many to one mappings between server components and client components enable complex interlinking between component building blocks and provide for very sophisticated sensor data processing flows.

For example a given data series component in a parent sensor system component may be linked to a server component within the same sensor system component using an output target component . Thus with respect to that given data series component the linked server component operates as a data destination component and automatically receives structured data table data as new rows are populated in the data series table of that given data series component . In turn the sensor system component can broadcast that table data to any number of specified network addresses and or to any number of linked client components which may be configured as data source components for other data series components in the same sensor system component .

Thus a server component can send and receive from any number of network addresses and linked client components it can be configured to do one or both for any given network address or linked client component . On the other hand each client component links to one network address or server component at a time and either sends or receives data from that one address or server component . Consistent with this interlinking framework a server component can link to any number of data series component as a data source for those data series component . Similarly any number of data series components can target a given server component as a data destination.

In more detail each instantiated server component allows the programmer to specify the IP addresses of interest and corresponding details for security mask port protocol UDP or TCP IP version v4 or v6 and packet size. Files messages byte arrays and data series table rows can be sent using server components and client components . Security protection can be specified by an IP security mask property of the sever component .

Each server component with its included properties and methods defines how to output data via TCP or UCP IPv4 or IPv6 and or how to receive data via TCP or UDP IPv4 or IPv6 . Among other things by using server components in conjunction with client components data can be transmitted via TCP or UDP IPv4 or IPv6 in real time over Local Area Networks LANs and Wide Area Networks WANs .

The client components offer like functionality in terms of network connectivity. One significant difference as mentioned above however is that individual client components either send data to or receive data from one connection e.g. one server component whereas each server component can send data to and receive data from or bi directionally do both for any number of network connections. Indeed a server component can be configured such that some of its network connections are inputs some are outputs and some are bidirectional. In this manner table data incoming to a given sensor component can be broadcast to any number of connections.

Helpfully at least one embodiment of the server and client components and includes software methods allowing each instantiated server component and client component to append a programmer specified custom header to outgoing data. This allows for example a given server or client component or to stamp the data it is sending to mark its origin its state of processing etc.

In more detail one or more embodiments of the data series components allow the programmer to set options for header operations. For example assuming that the input type property of a given data series component has been set to server or client the configurable options for that data series component will include one or more header options such as NONE meaning that no processing is performed on the header appended by a source server or client component or to the incoming sensor data or CONTAINS meaning that some action will or will not be taken depending on the contents of the appended header . One conditional action would be to ignore the incoming sensor data in dependence on the contents of the appended header. Note that this header processing functionality happens before the data fields processing performed by the data field components .

Turning from the example collection of components that are children of the sensor system component also illustrates two components included in one or more embodiments of the toolset that are peers with the sensor system component and that provide useful operations involving one or more sensor system components . Namely illustrates a sensor system group component with its child group data series component and group trigger component and further illustrates a sensor relay component .

Put simply a sensor system group component collects table data from the data series tables in one or more data series components that are of interest and merges that data into an in memory group data series table that is generated by its child group data series component .

In other words a sensor system group component is much like a sensor system component except that the inputs to sensor system group components are selected data fields from the data series tables of specified data series components in one or more sensor system components . With that similarity the group data series component is the same or similar to the data series components used in sensor system components . Thus as with the data series components and their respective data field components the group data series component uses data field components to define the schema for collecting data into its group data series table .

In general terms an instantiated sensor system group component provides pick lists or other selection mechanisms for identifying the sensor system components that are of interest for data merging. This selection convenience is further extended by providing selection mechanisms allowing the programmer to identify the data series components within each such sensor system component such that the data series tables that are of interest to the programmer with regards to group data collection may be easily identified.

As will be explained one or more embodiments of the toolset allow the programmer to configure different types of sensor system group components . However in general toolset program code enables the instantiation of sensor system group components that are each operative to generate a group data series table in system memory and to merge user selected table data from the data series tables of one or more data series components into the group data series table .

In one type of sensor system group component referred to as a bulk merge type the sensor system group component can be commanded e.g. programmatically commanded at run time to collect selected data fields from the same rows in the data series tables in any number of data series components whether the data series components are in one or multiple sensor system components .

In more detail a bulk type sensor system group component allows the grouping of data fields from one or more data series tables based upon primary key s . With the invocation of a bulk merge method the given sensor system group component merges the contents taken from primary key data fields in the data series tables within any number of specified data series components into a new row in the group data series table of that given sensor system group component . More particularly the contents of primary key data fields in the current row of each specified data series table are collected and populated in a new row of the group data series table upon invocation of a bulk merge.

In support of the above bulk merge functionality the data field components can include a primary key property or value enabling the data field component to be designated as a primary key for the data series table of its associated data series component . With that designation the corresponding data field column in the data series table of the parent data series component will be identified as a primary key data field.

In another type of sensor system group component data merging is triggered according to triggering conditions defined by the group triggering component which is instantiated as the child of a parent sensor system group component . Complementing this arrangement the class definitions further enable the programmer to instantiate sensor group trigger components each operative to link to a user specified sensor system group component e.g. in a parent child relationship and to receive user input identifying one or more event conditions to be used as triggers for obtaining the user selected table data and merging it into the group data series table of the linked sensor system group component .

Thus for a simple group type of sensor system group component the programmer adds group trigger components as desired to define the event conditions that will trigger the collection of group data from the data series tables of the specified data series components . As with a data event component the programmer adds a group trigger component for each event to be defined and then adds event condition components as children of each group trigger component to define the conditional evaluation test for determining whether the group event will be triggered.

An instantiated sensor system group component can be set to one type or the other via configuration options presented to the programmer. In either case data automatically is collected into the group data series table when an event based group trigger instructs the group data series component to add the current values of all the linked data fields of the specified data series tables or when a bulk merge method supported by the sensor system group component is invoked e.g. called in software.

Turning to sensor relay components each instantiated sensor relay component is operative to link a first data series component in one sensor system component to a second data series component in the same or another sensor system component such that the first data series component operates as a data source for the second data series component . In other words each sensor relay component defines a link that allows a data series component residing within one sensor system component to relay table data to another data series component residing in a different sensor system component . With a relay link in place the second data series component automatically receives a new row of table data anytime the first data series component populates a new row of its data series table .

By using sensor relay components table data can be passed between different sensor system components using only one server component or client component . To understand the advantage of linking data series components in the above manner as opposed to for example linking two client components in the same sensor system component to the same server component one should appreciate that each such client connection uses a connection port. In instances where it is desirable to minimize the number of open connection ports such as when going through secure network firewalls strategic use of sensor relay components can minimize the number of open ports needed.

For example assume that it is desired to send table data out from multiple data series tables through one network connection. To accomplish this the programmer can use sensor relay components to pass table data from one or more data series components into another data series component in or across sensor system components such that that other data series component effectively collects the data from the other relay linked data series components . In turn table data from that data series component can be output to one client component .

For example illustrates a data series collection component as a child of a parent sensor system component . The data series collection component is addable to the parent sensor system component and is operative to allow the programmer to add individual data series components e.g. . . . as desired to the parent sensor system component wherein each data series component is linkable by the programmer to one data source component within the parent sensor system component and is operative to collect sensor data from the linked data source component into its in memory data series table .

Further while not illustrated the toolset may provide a data fields collection component addable to a parent data series component and operative to allow the programmer to add individual data field components as desired to the parent series component each said data field component operative to define a data field in the data series table of the parent data series component .

The figure further illustrates several examples of a data sources collection component which is addable to the parent sensor system component and is operative to allow the programmer to add individual data source components as desired to the parent sensor system component each said data source component acting as a source of sensor data. Here the data sources collection component is not generically represented but rather is represented by specific examples of data sources collection components.

For example one sees that a data sources collection component may comprise a commands collection component that is addable to the parent sensor system component and is operative to allow the programmer to add command components e.g. . . . as desired to the parent sensor system component each said command component operative to wrap a WINDOWS API function or an unmanaged DLL as a data source component within the parent sensor system component such that the WINDOWS API function or unmanaged DLL acts as a source of sensor data within the parent sensor system component .

As another example one sees that the data sources collection component may comprise a file readers collection component . This component is operative to allow the programmer to add file reader components e.g. . . . as desired to the parent sensor system component each file reader component linkable to a target file by the programmer and operative to read data from the target file such that the target file acts as a source of sensor data.

The data sources collection component additionally or alternatively may comprise a database readers collection component operative to allow the programmer to add database reader components e.g. . . . as desired to the parent sensor system component each database reader component linkable to a target database by the programmer and operative to read data from the target database such that the target database acts as a source of sensor data.

Further in at least one embodiment the toolset may be defined as a web services data source component that operates much like the command components . However where command components obtain data by wrapping API DLL functions the web services components obtain data via web applications.

Turning from data sources to data destinations the sensor system component may include a data destinations collection component addable to a parent sensor system component which is operative to allow the programmer to add individual data destination components as desired to the parent sensor system component each said data destination component linkable by the programmer to any number of data series components within the parent sensor system component and operative to receive the sensor data collected by the linked data series components .

As with the data sources collection component does not illustrate a generic data destinations collection component but rather illustrates several specific examples any or all of which may be included in the parent sensor system component . As a first example the figure illustrates that the data destinations collection component may comprise a file writers collection component operative to allow the programmer to add file writer components e.g. . . . as desired to the parent sensor system component . Each file writer component is linkable to a target file by the programmer and operative to write sensor data from any linked data series components to the target file such that the target file acts as a destination for sensor data collected by the linked data series components .

Additionally or alternatively the data destinations collection component may comprise a database writers collection component operative to allow the programmer to add database writer components e.g. . . . as desired to the parent sensor system component . Each database writer component is linkable to a target database by the programmer and operative to write sensor data from any linked data series components to the target database such that the target database acts as a destination for sensor data collected by the linked data series components .

The figure further illustrates as a data sources collection component and or as a data destinations collection component a servers collection component that is addable to the parent sensor system component and operative to allow the programmer to add server components e.g. . . . as desired to the parent sensor system component . Each server component is configurable by the programmer to operate as a data source component and or data destination component . That is each server component supports multiple simultaneous network connections and can send and or receive data from any one or all of those connections.

The figure further illustrates as a data sources and or data destinations collection component a clients collection component that is addable to the parent sensor system component and operative to allow the programmer to add client components e.g. . . . as desired to the parent sensor system component . Each client component is configurable by the programmer to operate as a data source component receiving data from a specified network address or as a data destination component sending data to a specified network address. Note that at least one embodiment of client components allows a given client component to be configured with multiple connection configurations e.g. a list of network address but only one such connection is active at a time. However during run time execution the active address of a given client component can be changed or updated to change what it is connected with.

Continuing with non limiting examples of the object models adopted for the component building blocks of the toolset illustrate object models for the data series component and the data event component . With respect to one sees an example wherein the data series component includes a data series table component which offers methods and properties for building and accessing the data series table generated by each instantiated data series component . The model further includes a data fields collection component operative to allow the programmer to add as many data field components e.g. . . . as desired for defining the schema to be used for structuring data stored in the data series table .

The model further includes a data events collection component operative to allow the programmer to add data event components e.g. . . . as desired to a parent data series component . Likewise the model further includes an output targets collection component operative to allow the programmer to add output target components e.g. . . . as desired to a parent data series component .

Referring now to one sees that in the illustrated object model an event conditions collection component may be instantiated as a child of a parent data event component . The event conditions collection component is operative to allow the programmer to add event condition components e.g. . . . as desired to a parent data event component .

Continuing with object model examples illustrates an object model that may be used by the toolset for the sensor system group component . In addition to the sensor system group components that have already been discussed the object model illustrates a group triggers collection component which is operative to allow the programmer to add group trigger components e.g. . . . as desired to a parent sensor system group component .

The model further includes a group data series table component which functions much like the data series table component of the data series component i.e. it provides for generation and manipulation of the group data series table generated by each instantiated sensor system group component .

Of course other object models with other parent child relationships may be used in at least some instances to effect the same or similar functionality in the toolset . Notably for any given hierarchical component model one or more embodiments of the toolset include program code supporting component copying which may be referred to as a cloning function that can be performed at design time and can be invoked programmatically at run time. With component cloning the toolset generates a complete copy of a selected component or of selected groups of components wherein the copied components include all of the configured details option settings values etc. of the original component s .

As a further convenience at least one embodiment of the toolset includes program code supporting component serialization and de serialization. More particularly the toolset may include program code to serialize and de serialize an instantiated component and any components contained therein to and from an XML file.

Turning from implementation details to a practical although non limiting example of using the toolset depicts PC personal computer that is configured for development of a sensor enabled software application using an embodiment of the toolset which may be held in installed form in a storage device of the PC . The PC further includes a CPU central processing unit system or working memory e.g. DRAM and is connected to keyboard and mouse peripherals and a monitor . The PC also may be connected to a network and of particular interest for this example an external camera e.g. a USB connected camera device where USB denotes Universal Serial Bus .

As a non limiting example of developing sensor enabled software applications the toolset and or supporting operating system and development software installed on the PC provide a GUI which provides one or more programming windows and provides access to the sensor component building blocks of the toolset . For example the GUI may display a component palette toolbox which provides for convenient selection and instantiation of the sensor components included in the toolset . The GUI also may provide design and coding windows which provide for graphically based forms design and other drag and drop design operations as well as code editing windows.

With the above development system provides one example use of the toolset wherein selected sensor components within the toolset are used to obtain data as desired from the attached camera . First one may assume that the camera manufacturer provides driver software for the camera and that such software is installed on the PC . In the diagram the DLL CAMERA SDK.DLL represents the unmanaged DLL to be used for interfacing with the camera .

To wrap this unmanaged DLL i.e. to use the unmanaged DLL within a managed code environment such as the .NET framework of VISUAL STUDIO the programmer instantiates a command component sets it name to CameraCommand for example and links it to a take picture function of the camera DLL DLL CAMERA SDK.DLL DLL FUNCTION TakePicture . Because the TakePicture function to be exercised by the command component returns two parameters integer data and the picture itself as a ByteArray the programmer instantiates two child command parameter components and . The first command parameter component is configured for integer data and the second command parameter component is configured for ByteArray data.

The programmer then links an instantiated data series component to the command component . That is the programmer configures the data series component to link to the command component as its data source component such that the data series component receives camera data from the command component as its incoming sensor data. Further the programmer instantiates three data field components and that control the collection of camera data in the data series table while the data series table component creates manages the data series table into which the camera data is stored as structured by the field data components and .

Further assuming that the programmer desires to output table data from the data series table to a network connection and to a data file the programmer instantiates two output target components and one linking the data series component with a file writer component FileWriter and the other linking the data series component with a server component MyServerSocket . The server component is configured with the appropriate network connection information addresses while the file writer component is configured with the desired file name and desired method s of writing data to the file.

With the above configuration the software application or system in which the toolset components are included can initiate a data read from the camera by calling a read method provided by the command component . In response the command component calls the TakePicture function as defined by the CAMERA SDK.DLL and the command parameter components and allow the resulting camera data to be passed to the data series component .

The data series component automatically adds a new data series row to its data series table responsive to the newly incoming camera data subject to the filtering parsing and optionally data conversion operations of the data field components and . Further the newly added table data is passed along from the data series component to the specified data destinations file writer component and server component as linked to the data series component via the output target components and . In turn that data is written to the specified file by the file writer component to the targeted data file and is sent by the server component to the targeted network addresses.

Those skilled in the art should appreciate that the above example represents the linking to an unmanaged DLL for camera control and data retrieval the structuring and formatting of the resultant camera data in an automatically updated in system memory table and the automatic passing of data from that table to a data file and any number of network connections all without requiring the programmer to write a single line of program code. In this instance and in significantly more complicated scenarios the toolset thus represents a potentially enormous timesaver for programmers. Further the toolset enhances application robustness and simplicity by providing standard component building blocks that include components and properties enabling straightforward interlinking between components.

With the above and other examples in mind and considering the toolset in its various embodiments those skilled in the art should keep in mind that broadly the toolset provides an apparatus and method of facilitating the rapid development of sensor enabled software applications. In at least one such embodiment the toolset supports a method of rapidly developing sensor enabled software applications comprising providing software component class definitions for a plurality of sensor related software components.

The class definitions include definitions for a data source component linkable to a specified source of sensor data and operative to obtain incoming sensor data from the specified source such that a programmer adds a data source component for each source of sensor data of interest.

The class definitions further include a data series component linkable to a specified data source component and operative to generate an in memory data series table and to automatically collect incoming sensor data from the linked data source component in its data series table such that the programmer adds as many data series components as desired for collecting the incoming sensor data from a given data source component.

The class definitions further include a data field component operative to define a data field in the data series table of an associated data series component according to programmer selected properties and to thereby control automatic population of that data field by the associated data series component such that for each given data series component the programmer adds as many data field components as there are desired data fields for the data series table of that given data series component.

The class definitions further include a data destination component linkable to one or more specified data series components and operative to receive table data from the data series tables of the linked data series components such that the programmer adds as many data destination components as desired and links each data destination component to as many data series components as desired.

Still further the class definitions include a sensor system component operative as a container for related collection of data source data destination data series and data field components such that the programmer instantiates a sensor system component and adds data source data destination data series and data field components as desired.

Still further the class definitions include a sensor system group component linkable to a number of sensor system components and operative to generate an in memory group data series table and merge specified table data from specified ones of the data series tables in the linked sensor system components into its group data series table.

Still further the class definitions include a sensor relay component operative to link a first data series component contained within a first sensor system component to a second data series component contained within the same or a second sensor system component such that the first data series component operates as a data source component for the second data series component.

Still further the class definitions include a data event component that is operative to conditionally catch or filter incoming sensor data for an associated data series component according to one or more specified triggering conditions such that for a given data series component the programmer adds as many data event components as there are desired conditional catching or filtering operations to be conditionally triggered for the incoming sensor data. Complementing that functionality the class definitions further include an event condition component operative to define a programmer specified triggering condition for an associated series data event such that the programmer builds an associated set of triggering conditions for a given data event component by adding and configuring a corresponding number of event condition components.

Still further the class definitions include server components and client components wherein each server component is linkable by the programmer as a data destination component or as a data source component for one or more specified client components and wherein each client component is linkable by the programmer as a data destination component or a data source component to a specified server component. According to these class definitions in one or more embodiments the server and client components include within each such definition software methods or functions supporting TCP IP or UDP based network communications using either or both IPv4 and IPv6.

Further according to these definitions the server component is linkable by the programmer to any number of specified network addresses and is operative to act as a data source component or as a data destination component for individual ones of the specified network addresses. Similarly according to these class definitions the client component is linkable by the programmer to a specified network address and is operative to act as a data source component or as a data destination component for the specified network address.

Still further the class definitions include at least one of a file reader component operative to read sensor data from a specified data file a database reader component operative to read sensor data from a specified database a command component operative to wrap a specified WINDOWS API function or unmanaged DLL and obtain sensor data via the specified WINDOWS API or unmanaged DLL. Complementing these functions the class definitions may further include a command parameter component operative to allow the programmer to specify function parameters or arguments for obtaining sensor data via the specified WINDOWS API or unmanaged DLL i.e. by specifying a particular command component such that the command parameter component passes the specified parameter to that command component for use with the API or DLL wrapped by that command component.

Still further in one or more embodiments of the toolset one or more of the toolset components e.g. data series components command components etc. include programmatic hooks allowing programmatic extension of their behavior and or modification of their behavior. For example program code can via one or more hooks inspect or update property values and other configuration settings of a given component. One example would be the run time modification of network address information for a server component or a client component or . Another example would be the additional proprietary compression or encryption code either to a data series component or to a data destination component .

Also as a general point those skilled in the art should appreciate that the toolset can be implemented as an add in for an IDE or implemented as a standalone development system. By way of non limiting examples the toolset can be implemented as a standalone application for the WINDOWS MAC OS X LINUX and UNIX operating systems and variants thereof and can be implemented as an IDE add in for MICROSOFT VISUAL STUDIO ECLIPSE open source NETBEANS SUN MICROSYSTEMS WEBSPHERE IBM and other IDEs.

Whether configured as an IDE add in or as a development application in its own right the toolset offers a powerful set of sensor related component class definitions allowing the programmer to instantiate the number and types of sensor related components needed for a particular application and to interlink and configure these components to define the desired sensor data processing flows.

Moreover as alluded to earlier in the context of standalone software applications for implementing sensor data process flows may be based on an embodiment of the toolset . As used herein a given sensor data processing flow comprises a desired set or sequence of processing operations for sensor data such as acquiring filtering and storing distributing. Sensor data process flows thus represent a desired set or collection of processing steps or actions to be taken with regard to particular sensor data and generally relate to identified sources and or destinations of sensor data.

In any case illustrates one embodiment of such standalone software wherein a system is configured for deploying component based software systems for the implementation of desired sensor data process flows. Note that one or more of the software components in the toolset can be used to call functions output control data commands etc. Thus it should be understood that the component based software systems can be used to interface with actuators e.g. doorlocks alarms etc. in addition to or in alternative to their use in implementing desired sensor data processing. 

The illustrated system comprises a front end application and a back end application . While not considered part of the system it should be noted that the front end application may be installed or otherwise embodied on a first computer and the back end application may be installed or otherwise embodied on a second computer which preferably is communicatively linked to the first computer such as through the Internet . Of course in one or more embodiments of the system the front end application and the back end application may be installed or embodied on the same computer and indeed they may comprise functional subparts of an integrated application.

Referring momentarily to the front end application in one or more embodiments is operative to generate system specifications from user input and the back end application in one or more embodiments is operative to generate component based software systems based on processing the system specifications . In this sense a given system specification may be considered as a template for a desired collection of sensor components to be instantiated and configured by the back end application . Thus in the context of this disclosure each system specification defines a desired component based software system of one or more sensor components and their corresponding configurations in accordance with sensor component class definitions for a predefined set of sensor components that are tailored for building sensor data process flows. In at least one embodiment the system specifications are generated in accordance with the sensor component class definitions contained in the toolset and the corresponding component based software systems are generated by instantiating selected sensor components from the toolset .

Thus a system specification may be understood as a collection of information that identifies the particular types numbers and configurations of sensor components selected from the predefined set of sensor components in the toolset that are to be instantiated in the corresponding component based software system . In turn each component based software system may be understood as comprising one or more sensor components instantiated from the toolset and configured in accordance with information in the corresponding system specification . For example a given component based software system may comprise one or more sensor system components configured to perform user specified sensor data processing operations.

Continuing with the system description the back end application is operative in one or more embodiments to store the sensor component class definitions for use in instantiating sensor components as needed. The back end application is further operative to receive system specifications and dynamically build and run the corresponding desired component based software systems within a run time environment provided by the back end application .

Thus in one or more embodiments the back end application includes or accesses the software class definitions comprising the toolset . With access to these class definitions the back end application can instantiate the particular sensor components to be included in a given component based software system as identified by the system specification corresponding to that given component based software system .

In any case as noted above the front end and back end applications and may comprise an integrated application or may comprise separate but complementary applications. In either embodiment the front end and back end applications and can be installed on the same computer and on different computers.

For example at least the front end application may be installed on the first computer and at least the back end application may be installed on the second computer which may be remote from the first computer but preferably is communicatively linked to it such as through the Internet . In this context a user of the first computer can define desired component based software systems based on inputting the information needed to generate the corresponding system specifications and can then transfer those system specifications to the second computer where the back end application dynamically builds and runs the desired component based software systems .

More particularly in one or more embodiments the user of the first computer can cause the back end application executing at the second computer to build new component based software systems on the fly and or to modify existing component based software systems on the fly based on transferring new and or modified system specifications to the second computer. More generally the front end application is operative to communicate with the back end application for transfer of system specifications from the first computer to the second computer such that a user of the first computer defines the system specifications for the desired component based software systems and transfers them to the second computer whereupon the back end application dynamically builds and runs the desired component based software systems at the second computer .

As non limiting advantageous operation particularly in the context of transferring system specifications the front end application is operative in one or more embodiments to package the system specifications generated from the user input and to transfer the packaged system specifications to the back end application . In such embodiments the back end application is configured to un package each packaged system specification received from the front end application and to build and run the corresponding desired component based software systems from the un packaged system specifications.

As a non limiting example the front end application in one or more embodiments is operative to package system specifications by serializing them into extensible Markup Language XML files. In such embodiments the back end application is operative to un package packaged system specifications by parsing metadata and corresponding data from the XML files.

Further the back end application in one or more embodiments is operative to transfer system specifications to other like back end applications which may be running at different but communicatively linked computers such that one back end application executing on one computer can share systems specifications with another back end application executing on another computer. In such embodiments the back end applications may be configured to package system specifications for transfer.

As a point of further flexibility and user convenience in at least one embodiment of the system the front end application is operative to store system specifications for recall inspection and modification by a user. Complementing this capability the back end application is operative to dynamically update an existing component based software system running within its run time environment responsive to receiving a modified system specification for the existing component based software system .

In the same or other embodiments of the system the front end application is operative to define functional associations between sensor components in a desired component based software system and external executable programs callable within the run time environment of the back end application and is operative to identify any such functionally associated external executable programs to the back end application .

This functionality allows for example the back end application to start and stop or otherwise manage one or more executable programs within its run time environment such that those executable programs can be used as needed or desired in the sensor data processing being carried out by the component based software systems running within the run time environment of the back end application . Thus at least one embodiment of the back end application is operative to initiate or call the functionally associated external executable programs as identified by the front end application such that one or more external executable programs can be executed to support operation of the component based software systems running within the run time environment of the back end application .

As a non limiting example one or more embodiments of the front end application include a remote configuration interface accessible to a user via a computer network having a connection with a host computer running the back end application . That is the front end application may comprise a web browser application and or a transferable applet e.g. a JAVA applet such that a user having remote access to a computer system running the front end application can define system specifications as needed or desired. Alternatively in another embodiment the front end and back end applications and comprise separate applications configured for installation and execution on a same computer and or different computers wherein the different computers preferably are communicatively linked such that the front end application can communicate with the back end application .

With the above described embodiments of the system in mind respectively illustrate non limiting functional embodiments of the front end application and the back end application . Beginning with the front end application as illustrated in one sees that it functionally comprises a user interface a system specification generator and a back end application interface .

In operation the user interface provides for example a graphical screen or sets of graphical screens allowing the user to input information for defining a given system specification such as types numbers names links and other configuration settings for a selected set of sensor components corresponding to the sensor components defined in the toolset . Of course the front end application generally includes functions for saving this input in the form of files or in some other retrievable format and such information can be saved collectively for different back end applications or separately for each of one or more back end applications . In such cases the different back end applications generally have different logical names and or are selectable using different network addresses. 

In any case the system specification generator generates system specifications from the user input received via the user interface and can include functionality for packing unpacking system specifications . In any case the back end application interface transfers system specifications packed or otherwise to a targeted back end application .

Where the front end application and the back end application are integrated together the back end application interface may be an internal purely logical transfer function that makes the system specifications or their corresponding memory held data structures available for processing by the program code comprising the back end application . However in other embodiments such as where the front end and back end applications and are configured for installation on separate computers if desired the back end application interface may comprise a more full featured network communication function which may support TCP IP communications with one or more back end applications . Indeed in at least one embodiment the front end and back end applications and use server and or client components and or instantiated from the toolset to carry out intercommunication between them.

Turning to one sees a non limiting embodiment of the back end application which complements the previously described front end application . In the illustrated embodiment the back end application comprises a front end application interface for communicating with the front end application e.g. for receiving system specifications and other related or supporting information a specification processor for processing system specifications which can include functionality for packing unpacking system specifications . The back end application further comprises a system generator for generating component based software systems from corresponding system specifications . To that end the back end application provides a run time environment in which it dynamically builds and runs one or more component based software systems in accordance with one or more corresponding system specifications .

In one or more embodiments a user defines system specifications for desired component based software systems using a configuration screen shown in one embodiment in which may be provided on a computer monitor by program code included in the front end application . The illustrated configuration screen provides control inputs for adding configuring system specifications corresponding to desired component based software systems and further includes a listing of component based software systems defined by existing system specifications and the status of those systems in terms of whether they are loaded or unloaded in the run time environment of a targeted back end application and whether they are set for manual or automatic loading re loading into the run time environment of the targeted back end application .

Notably the configuration screen thus allows a user to browse existing system specifications create new system specifications and correspondingly transfer new or updated system specifications to the currently targeted back end application . In that manner the user can add or modify the component based software systems being run by the targeted back end application . Moreover the configuration screen allows the user to see the component based software systems resident at the targeted back end application and to load activate and unload deactivate them as needed or desired.

Thus it should be understood that the one or more embodiments of the screen depict a hybrid design time run time context wherein the user uses the screen to design system specifications for new desired component based software systems to be subsequently built and run at the back end application . However the screen also allows the user a live view of the component based software systems existent at the targeted back end application and allows the user to activate deactivate and or modify those preexisting component based software systems as needed or desired.

Further while the depicted screen depicts advantageous controls for building managing and transferring system specifications to one or more back end applications it should be understood that in at least one embodiment other mechanisms exist for building system specifications . For example IDEs may be used to create system specifications e.g. the IDE based embodiment of the toolset may provide the ability to create and edit system specifications . Also in at least one embodiment system specifications can be generated using a text editor or like tool. Of course in any of these or other embodiments described herein the back end application may include functionality to validate or otherwise authenticate received system specifications such as by confirming sender identity checking security codes or keys etc. Additionally or alternatively one or more embodiments of the back end application require secure log in or the like to thereby restrict the transfer of component based software systems and or other configuration information. 

Using the illustrated screen a user can identify executable programs to be managed by the back end application within its run time environment e.g. the screen provides controls for browsing and selecting executable programs and displays a listing of identified executable programs. Further the screen provides controls allowing the user to specify whether each executable program should be started or stopped by the back end application and whether the executable program should be automatically restarted e.g. at reboot. Still further the screen provides controls for the user to transfer the identified executable programs to the back end application .

More particularly the illustrated screen controls allow a user to specify executables to be managed by the back end application and further allows the user to specify whether individual ones of those executables be manually or automatically started and whether they should manually or automatically stopped. With manual stoppage the given executable continues running after the back end application terminates with automatic stoppage the back end application terminates the given executable as part of shutting down. Note too that the screen controls allow the user to specify command parameters to be associated with corresponding ones of the listed executables thereby allowing the user to specify for example run time parameters to be passed to the executable by the back end application as part of initiating it.

It should be understood that the one or more embodiments of the screen depict a hybrid design time run time context wherein the user uses the screen to identify executable programs of interest and if needed to transfer them to the targeted back end application . However the screen also allows the user a live view of the executable programs currently being managed in the run time environment of the targeted back end application and allows the user to start stop and or auto start those existing executable programs as needed or desired.

By way of non limiting example an executable program of interest may be a serial port monitoring program or other hardware port monitoring program capable of acting as data source for one or more component based software systems . As such the user can use the front end application to identify the monitoring program and transfer it to the back end application and can use the front end application to generate a given system specification that defines one or more sensor components that link to the monitoring program as a data source. As such the back end application correspondingly loads executes the monitoring program and the component based software system dynamically built from the given system specification will functionally link to the monitoring program during live operation within the run time environment .

Broadly then those skilled in the art will appreciate that the system in any of its various embodiments supports a method of deploying component based software systems for the implementation of desired sensor data processing at a first computer. illustrates one embodiment of the method which comprises providing first computer software for installation at the first computer Step . This first computer software includes class definitions for a predefined set of sensor components comprising a collection of software objects tailored for building component based software systems to effect desired sensor data processing e.g. the software includes the toolset .

The method further includes configuring the first computer software such that it is operative during execution to receive system specifications Step . Each system specification defines a desired component based software system by identifying types and numbers of sensor components from the predefined set of sensor components to be included in the desired component based software system and by identifying configuration settings for those included sensor components.

The method further includes configuring the first computer software such that it is operative during execution to dynamically build the desired component based software systems by instantiating sensor components from the predefined set of sensor components and configuring them in accordance with their corresponding system specifications Step and to dynamically run the desired component based software systems within a run time environment provided by the first computer software Step . In so doing the first computer software thereby carries out the desired sensor data processing at the first computer.

In at least one embodiment the method further includes providing second computer software that is operative during execution to provide a user interface enabling a user to define the system specifications based on the user selecting sensor components from the predefined set of sensor components and configuring the selected sensor components in accordance with the desired sensor data processing to be carried out at the first computer. As such the method may further include configuring the second computer software such that a user at a remote computer having a communication link with the first computer can define the system specifications for the desired component based software systems to be built and run by the first computer software at the first computer. In at least one embodiment that comprises implementing the second computer software as separately installable software for installation at the remote computer such that the user of the remote computer can define the system specifications for transfer to the first computer.

In such embodiments the method may include configuring the second computer software such that a user at a remote computer having a communication link with the first computer can define the system specifications for the desired component based software systems to be built and run by the first computer software at the first computer based on implementing the second computer software as a web browser interface for the first computer software. With that implementation the user of the remote computer defines the system specifications via the web browser interface.

Broadly then the above method may be implemented in computer readable media storing a first computer program for rapidly implementing desired sensor data processing at a target computer. The first computer program is intended for installation and execution by the target computer and comprises class definitions for a predefined set of sensor components comprising a collection of software objects specially tailored for sensor data processing. The first computer program further comprises program code operative to dynamically process system specifications each system specification identifying types numbers and configurations of sensor components from the predefined set of sensor components to be included in a desired component based software system . The first computer program further comprises program code operative to provide a run time environment for dynamically building and running the desired component based software systems at the target computer each desired component based software system carrying out all or part of the desired sensor data processing at the target computer.

The first computer program may further comprises program code operative to provide a user interface enabling a user to define new system specifications as needed or desired such that during execution of the first computer program by the target computer a user having local or remote access to the target computer can cause the first computer program to process the new system specifications and dynamically build and run the corresponding new component based software systems . Such program code also may be operative to enable the user to inspect and modify preexisting system specifications such that during execution of the first computer program by the target computer a user having local or remote access to the target computer can cause the first computer program to process modified system specifications and dynamically update the corresponding preexisting component based software systems .

Of course as noted there may be a second computer program such as in one or more embodiments of the front end application that is installable at a remote computer having a communication link with the target computer. The second computer program comprises program code operative to provide a user interface enabling a user of the remote computer to define new system specifications and transfer them to the target computer such that during execution of the first computer program by the target computer the user of the remote computer can cause the first computer program to process the new system specifications and dynamically build and run the corresponding new component based software systems . Such processing also encompasses the modification of existing system specifications and the updating of corresponding existing component based software systems .

That is the first or second computer software includes program code operative to provide a user interface enabling a user of the remote computer to inspect and modify preexisting system specifications such that during execution of the first computer program by the target computer the user of the remote computer can cause the target computer program to process modified versions of the preexisting system specifications and dynamically update the corresponding preexisting component based software systems .

Further the program code operative to transfer system specifications to the target computer may comprise program code to package the system specifications together or individually and to transfer the packaged system specifications over the communication link to the target computer. In at least one embodiment the program code to package the system specifications comprises program code to generate extensible Markup Language XML files from the system specifications including metadata and data identifying the selected sensor components and their corresponding definitions.

In at least one embodiment the first computer program further comprises program code to receive packaged system specifications via a communication link wherein the packaged system specifications represent remotely generated system specifications that were packaged for transfer over the communication link and further comprising program code to un pack the packaged system specifications for processing. Such program code may comprise instructions to parse metadata and data contained in XML files representing packaged system specifications .

With the above in mind those skilled in the art will appreciate that the present invention is limited only by the following claims and their legal equivalents.

