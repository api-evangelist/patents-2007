---

title: Securing a flash memory block in a secure device system and method
abstract: A technique for securing a flash memory block in a secure device system involves cryptographic techniques including the generation of a Message Authentication Code (MAC). The MAC may be generated each time a file is saved to one or more data blocks of a flash memory device and stored with the file's metadata and to each of the data blocks. A technique for reading and storing versioned files may be employed when applications utilize versioning.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08200961&OS=08200961&RS=08200961
owner: iGware, Inc.
number: 08200961
owner_city: Mountain View
owner_country: US
publication_date: 20070226
---
This application claims priority of U.S. Provisional Application 60 860 049 entitled SECURING A FLASH MEMORY BLOCK IN A SECURE DEVICE SYSTEM AND METHOD filed Nov. 19 2006 which is hereby incorporated by reference in its entirety.

Flash memory has gained widespread use in consumer devices and appliances where data secrecy and authenticity are substantial requirements. Several techniques are used to provide secrecy and authenticity for data on a flash memory device. The security mechanism may be implemented in the flash memory device driver and associated operating system implementation.

Encryption and decryption of data is common in computer data storage devices. Cryptographic techniques are often employed when storing data. While the employment of such techniques offer a level of security from unauthorized access different computer platforms utilize the same cryptographic methods when storing and reading data from storage devices. These methods include but are not limited to Data Encryption Standard DES Advanced Encryption Standard AES and SHA Secure Hash Algorithm functions. Because different platforms employ common cryptographic methods it is possible to remove a storage device from one computer and read the encrypted data on another computer which uses the same methods if one has access to the key. For adequate security the key should not be a common key for every platform or the security would rely on the secrecy of that single key only.

In some applications message authentication codes e.g. HMACs are used to provide authentication verification data for message blocks. The storage of a MAC in the data block should give rise to acceptable data and read write performance overhead. One desirable feature is to provide a method that is robust to bit errors in flash memory devices. Another desirable feature is that the data from multiple applications should be protected from each other in the operating system. That is it should not be possible to use one application to gain access to control or modify another application or its data.

The USB flash drive is a common storage device using flash memory for its relatively small size offers the end user ease of portability of computer information or data stored thereon. For instance an end user can install the flash drive device on a USB port of one computer store the information to the device remove the device install it on a USB port of another computer and read the stored information. Even if the data may be encrypted by one platform the data is not secure given the employment of common cryptographic techniques on other platforms unless the keys are protected by the platform. In addition there are a variety of devices available to consumers which allow them to both read and write to the flash memory device. Thus a further security mechanism is necessary to protect against security breaches of flash memory devices.

The foregoing examples of the related art and limitations related therewith are intended to be illustrative and not exclusive. Other limitations of the related art will become apparent to those of skill in the art upon a reading of the specification and a study of the drawings.

A technique for providing a security mechanism for the flash memory device and the data blocks integral to it involves the employment of cryptographic methods that extract and use informational variables that are specific to device while installed in one computer platform. The data block is the unit of access of data on the flash memory device. Because a data block of a flash memory device is readable and writable using a variety of devices available to consumers a mechanism is necessary to protect against security breaches of the flash memory device.

In an illustrative embodiment data written to the data blocks is encrypted and a MAC is used for authentication. Data read from the data blocks is decrypted and the MAC is verified. The order is interchangeable. In a typical secure device a security kernel is loaded with authentication and supports a secure object store and an API interface to various clients. The encryption decryption functions calculation of MAC and verification of data is performed in the security kernel. The security kernel protects keys in a keys database and enforces the ownership of keys and maintains the secrecy. The key is not accessible to another I O driver e.g. the network driver. The key corresponding to the flash device driver is stored in non volatile memory accessible to the security kernel alternatively a key may be generated internally and stored using a random number generator RNG . The security kernel interfaces with the operating system via an Application Programming Interface API which permits only the flash operating system to obtain the key for the purposes of encryption decryption calculation of MAC and verification of data. The key is not exposed across the API boundary. The security kernel can identify the caller and enforce the protections on key usage. Without such protections other I O drivers or applications could breach the security of the flash operating system by compromising software or data of any client that can access the security API.

In the following description several specific details are presented to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or in combination with other components etc. In other instances well known implementations or operations are not shown or described in detail to avoid obscuring aspects of various embodiments of the invention.

The computer interfaces to external systems through the communications interface which may include a modem or network interface. The communications interface can be considered to be part of the computer system or a part of the computer . The communications interface can be an analog modem ISDN modem cable modem token ring interface satellite transmission interface e.g. direct PC or other interfaces for coupling a computer system to other computer systems. Although conventional computers typically include a communications interface of some type it is possible to create a computer that does not include one thereby making the communications interface optional in the strictest sense of the word.

The processor may include by way of example but not limitation a conventional microprocessor such as an Intel Pentium microprocessor or Motorola power PC microprocessor. While the processor is a critical component of all conventional computers any applicable known or convenient processor could be used for the purposes of implementing the techniques described herein. The memory is coupled to the processor by a bus . The memory which may be referred to as primary memory can include Dynamic Random Access Memory DRAM and can also include Static RAM SRAM . The bus couples the processor to the memory and also to the non volatile storage to the display controller and to the I O controller .

The I O devices can include a keyboard disk drives printers a scanner and other input and output devices including a mouse or other pointing device. For illustrative purposes at least one of the I O devices is assumed to be a block based media device such as a DVD player. The display controller may control in a known or convenient manner a display on the display device which can be for example a cathode ray tube CRT or liquid crystal display LCD .

The display controller and I O controller may include device drivers. A device driver is a specific type of computer software developed to allow interaction with hardware devices. Typically this constitutes an interface for communicating with the device through a bus or communications subsystem that the hardware is connected to providing commands to and or receiving data from the device and on the other end the requisite interfaces to the OS and software applications.

The device driver may include a hardware dependent computer program that is also OS specific. The computer program enables another program typically an OS or applications software package or computer program running under the OS kernel to interact transparently with a hardware device and usually provides the requisite interrupt handling necessary for any necessary asynchronous time dependent hardware interfacing needs.

The non volatile storage which may be referred to as secondary memory is often a magnetic hard disk an optical disk or another form of storage for large amounts of data. Some of this data is often written by a direct memory access process into memory during execution of software in the computer . The non volatile storage may include a block based media device. The terms machine readable medium or computer readable medium include any known or convenient storage device that is accessible by the processor and also encompasses a carrier wave that encodes a data signal.

The computer system is one example of many possible computer systems which have different architectures. For example personal computers based on an Intel microprocessor often have multiple buses one of which can be an I O bus for the peripherals and one that directly connects the processor and the memory often referred to as a memory bus . The buses are connected together through bridge components that perform any necessary translation due to differing bus protocols.

Network computers are another type of computer system that can be used in conjunction with the teachings provided herein. Network computers do not usually include a hard disk or other mass storage and the executable programs are loaded from a network connection into the memory for execution by the processor . A Web TV system which is known in the art is also considered to be a computer system but it may lack some of the features shown in such as certain input or output devices. A typical computer system will usually include at least a processor memory and a bus coupling the memory to the processor.

The computer system may be controlled by an operating system OS . An OS is a software program used on most but not all computer systems that manages the hardware and software resources of a computer. Typically the OS performs basic tasks such as controlling and allocating memory prioritizing system requests controlling input and output devices facilitating networking and managing files. Examples of operating systems for personal computers include Microsoft Windows Microsoft Vista Linux and Mac OS . Delineating between the OS and application software is sometimes rather difficult. Fortunately delineation is not necessary to understand the techniques described herein since any reasonable delineation should suffice.

Typically the OS provides a customary hierarchical directory and file based organization of data stored on the flash memory device. In addition it enforces typical access control based on read write and execute permissions on directories and files. This access control is enforced when data accesses to the flash are made through the operating system which itself is part of an authenticated secure OS on a secure device.

The lowest level of an OS may be its kernel. The kernel is typically the first layer of software loaded into memory when a system boots or starts up. The kernel provides access to various common core services to other system and application programs.

As used herein algorithmic descriptions and symbolic representations of operations on data bits within a computer memory are believed to most effectively convey the techniques to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

An apparatus for performing techniques described herein may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as by way of example but not limitation ROM RAM EPROM EEPROM magnetic or optical cards any type of disk including floppy disks optical disks CD ROMs DVDs and magnetic optical disks or any known or convenient type of media suitable for storing electronic instructions.

The algorithms and displays presented herein are not inherently related to any particular computer architecture. The techniques may be implemented using any known or convenient programming language whether high level e.g. C C or low level e.g. assembly language and whether interpreted e.g. Perl compiled e.g. C C or Just In Time JIT compiled from bytecode e.g. Java . Any known or convenient computer regardless of architecture should be capable of executing machine code compiled or otherwise assembled from any language into machine code that is compatible with the computer s architecture.

In the example of the secure system includes a secure processor an OS a flash memory device driver a flash memory device and protected memory . In the example of the OS includes a security kernel which in turn includes a key store an encryption decryption engine and a security API . In another embodiment security kernel may contain a Random Number Generator RNG not shown . It should be noted that one or more of the described components or portions thereof may reside in the protected memory or in unprotected memory not shown .

It should further be noted that the security kernel is depicted as residing inside the OS by convention only. It may or may not actually be part of the OS and could exist outside of an OS or on a system that does not include an OS. For the purposes of illustrative simplicity it is assumed that the OS is capable of authentication. In an embodiment the flash memory device driver may also be part of the OS . This may be desirable because loading the flash memory device driver with authentication can improve security.

An example of a flash memory device that may be used as the flash memory device is described later with reference to . The flash memory device driver stores data to and reads data from the flash memory device . The flash memory device driver has a unique protected or secret key associated with it which is stored in the key store of the security kernel . In an alternative a protected key may be stored using the random number generator RNG not shown capabilities stored in the security kernel . The security kernel enforces the use of the protected key. In an embodiment the flash memory device driver owns a key s in the key store in the security kernel which is not accessible by another I O driver e.g. networking. The security kernel is exposed to the security API and the flash memory device driver may use the protected key to encrypt and decrypt or calculate a Message Authentication Code MAC or a keyed Hash Message Authentication Code HMAC .

For illustrative simplicity the protected memory is represented as a single memory. However the protected memory may include protected primary memory protected secondary memory and or secret memory. It is assumed that known or convenient mechanisms are in place to ensure that memory is protected. The interplay between primary and secondary memory and or volatile and non volatile storage is known so a distinction between the various types of memory and storage is not drawn with reference to .

In an embodiment the security kernel may be loaded at start up. In another embodiment a portion of the security kernel may be loaded at start up and the remainder loaded later. Any known or convenient technique may be used to load the security kernel in a secure manner.

The key store is a set of storage locations for keys such as the protected key of the flash memory device driver . The key store may be thought of as an array of keys though the data structure used to store the keys is not critical. Any applicable known or convenient structure may be used to store the keys. In a non limiting embodiment the key store is initialized with static keys but variable keys are not initialized or are initialized to a value that is not secure . For example some of the key store locations are pre filled with trusted values e.g. a trusted root key as part of the authenticated loading of the security kernel . The private key in the non volatile memory could be retrieved and stored in the keystore for future use.

The encryption decryption engine is in an embodiment capable of both encryption and decryption. For example in operation an application may request of the security API a key handle that the application can use for encryption. The encryption decryption engine may be used to encrypt data using the key handle. Advantageously although the security API provides the key handle in the clear the key itself never leaves the security kernel .

The security API is capable of performing operations using the keys in the key store without bringing the keys out into the clear i.e. the keys do not leave the security kernel or the keys leave the security kernel only when encrypted . The security API may include services to create populate and use keys and potentially other security material in the key store . In an embodiment the security API also provides access to internal secrets and non volatile data including secret keys and device private key s . For example the flash memory device driver private key might be stored in the key store and used by the security API . One API call could be used to return a device certificate using an algorithm discussed herein to generate the certificate . Another API call can be constructed to use the private key to compute a shared key for decryption or use the private key to sign a message or certificate. Depending upon the implementation the security API may support cryptography operations using hardware acceleration.

One or more of the data blocks are associated with a file stored in the flash memory device . The data blocks include respective metadata to N referred to collectively as metadata and stored data to N referred to collectively as stored data . Stored data in data blocks may be encrypted using such encryption functions as by way of example but not limitation DES or AES. In the illustrative embodiment in the discussion that follows each data block is protected by a MAC and a file Version Number VN f which are described later.

In an illustrative embodiment metadata is stored in spare area of flash pages. Spare area may be physically located before after or within the data area that includes the stored data . Thus in the example of the depiction of the metadata above the stored data is for illustrative purposes only and should not be construed as a limitation.

An operating system or secure kernel through the use of a flash memory device driver may provide a customary hierarchical directory and file structure stored in the flash memory device . In addition the operating system or security kernel may enforce typical access controls based on read write and execute permissions on files stored in the flash memory device . This access control may be enforced when request for access to the stored data is made from a secure device. This does not alone protect the device against security breaches that involve removing the flash memory device and reading or reprogramming the device external to the secure device on a different device thereby circumventing the protections of the secure device. Customers may use a variety of known or convenient devices that allow the flash memory device to be not only readable but also writeable. A further security mechanism may be desirable to protect against this.

In an illustrative embodiment to provide security to the data blocks the stored data of each of the data blocks is encrypted and a calculated MAC is stored along with the block. Conversely stored data read from each data block is decrypted and the calculated MAC is verified. The order is interchangeable.

A number of variables may be mandatorily included to the flash memory data block to calculate the MAC. In an illustrative embodiment the inclusion of informative data is enforced by trusted software in a security kernel as part of the MAC calculation. In a specific implementation of this embodiment the trusted software and flash device driver are the only means to access the flash device and that in turn may be enforced by hardware and software mechanisms. This potentially ensures stored data in each data block becomes unusable if the flash memory device is tampered with.

The specific trusted device driver is alone given access to the relevant key and informative data to compute a suitable HMAC. Any other part of the operating system or untrusted software is prevented by the security kernel from creating usable or verifiable data on the flash device. This enforcement is performed by the security kernel by using privileged data to identify the caller of a security API. This might include as examples process ID thread ID user ID and other techniques used to separate the ownership space.

One value that could be included in the calculation of the MAC is a unique value that is assigned to each file and stored in a flash header as conventional file metadata. Another value that could be included in the calculation of the MAC is a value that represents a logical block index of each flash memory data block and stored in spare area. Other variables that could be included in the calculation of the MAC include physical block numbers owner ID variables of either an application or the computer system or application ID variables. In addition an application can request an ID to be tagged to data written to the file that is managed by the application. The tagging ID could be included in the calculation of the MAC. This way that application can manage the protection of data blocks of two managed files from each other.

In an illustrative embodiment of a method for creating an authentication code one might create a value HMAC h HMAC data where data is the array. In such an embodiment a user may supply the data array and the security kernel may enforce appending a few mandatory values for example 

In some cases the application might request the addition of a tagging ID. For example a user may supply the data array and the tagging ID as inputs to the API and the security kernel may compute 

The location and sequences of these quantities are not fixed and can be varied in practice as long as the same fixed order is used for verification in the kernel. The important aspect is that this tagging of these quantities cannot be suppressed controlled or treated optional on this device by the caller. The trusted kernel will enforce the rules as necessary to add the authentication information to the block of data.

In some applications it is desirable to maintain the current or latest version of a file or data in a flash memory device to prevent roll backs to an earlier version. This provides protection for the client because it prevents a user from substituting flash memory devices and manipulating stored data in the flash memory data blocks. This can be particularly desirable if usage data consumption information or pay per view information is stored on the flash memory device. This may also be useful to store security information like server validity or revocation lists where the information should be updated and maintained at the current version number. Software patching and updating mechanisms including mandatory security updates could also use this feature to implement secure versioning.

In an illustrative embodiment a security kernel enforces a strict increase of version numbers. The security kernel may store GVN n in secure non volatile memory. This number is updated when any versioned file is updated and it is accessible and updateable by for example an operating system by making an API call to the security kernel.

The flash header of a flash memory device may include file system metadata including a value GVN f which may be in sync with the value GVN n. The metadata is in an illustrative embodiment itself protected by a MAC created using any necessary or desirable informational values. The flash header may also include version numbers VN f respectively associated with each file stored on the flash memory device.

When the version number of a versionable file changes the VN f associated with the file is updated GVN f and GVN n are subsequently updated the MAC is recalculated and the resultant MAC is stored. Thus a change in version number of a file affects the MAC of the set of the data blocks associated with the file. GVN n in this embodiment is a part of NV memory inside the chip and only accessible to the security kernel making it exceptionally resistant to tampering. This provides a flexible mechanism whereby the hardware security on the secure chip is extended to implement secure versioning on the flash memory device and versioning applies only to the files that use versioning. This latter method is useful if the number of writes to non volatile memory is to be conserved. This general technique extends the protection of tamper resistant on chip rewritable memory to maintain secure versioning of data stored in the flash memory data blocks. If desired by the end user secure versioning could be mandated to include all files or flash data blocks on the flash memory device.

Advantageously if someone attempted to replace a data block from a prior version the HMAC would have included implicitly a prior version number and hence would not match against the HMAC computed with the correct number in the verified metadata.

In an illustrative embodiment the MAC is 20 bytes in length and stored in the flash header and each metadata and spare area of the file. The block headers of the files may utilize data block spare area along with bit error information ECC and status information. The benefit of storing this information in the spare area is that it is read along with the data without additional overhead and the spare area is utilized to accommodate this extra MAC information rather than including it with the stored data on the data block .

Another aspect of storage involves robustness against single bit and double bit errors on flash. Two copies of the MAC are capable of being stored in the spare area. If each of the two MACs is verified with the MAC calculated by the security kernel the information stored in stored data is considered valid. If only one of the two MACs is verified the unverified MAC is assumed to have a single bit error. The block is copied to another data block a new MAC pair is written to a new block and the old block is regarded as freed. If neither MAC verifies the data is assumed tampered with or a multi bit error is assumed. Block access returns a failure and stored data of data block is not read.

The usage of spare area to store the MAC is justified as shown in the following example Consider a 128 MB flash part that is organized into logical blocks each including eight 2K byte pages. The spare area of each page includes one status byte per page and 3 ECC bytes for every 512 bytes. If two copies of the MAC are factored into the equation the result reflects that 2 20 8 3 4 8 144 bytes of the spare area are used. The model has 512 bytes of spare area for each block thus there is sufficient space to include two MAC values along with the ECC information in the spare area.

As used herein the term embodiment means an embodiment that serves to illustrate by way of example but not limitation.

It will be appreciated to those skilled in the art that the preceding examples and embodiments are exemplary and not limiting to the scope of the present invention. It is intended that all permutations enhancements equivalents and improvements thereto that are apparent to those skilled in the art upon a reading of the specification and a study of the drawings are included within the true spirit and scope of the present invention. It is therefore intended that the following appended claims include all such modifications permutations and equivalents as fall within the true spirit and scope of the present invention.

