---

title: Process extension wizard for coherent multi-dimensional business process models
abstract: This disclosure relates to methods, systems, and software for processing a coherent multi-dimensional business process model. The software includes computer-readable instructions embodied on media to identify a coherent multi-dimensional business process model based on at least a portion of a first model for a business process and at least a portion of a second model for the business process. The software then parses the multi-dimensional business process model to identify at least one extension point, each extension point operable to interface a disparate business tool with the business process. The software is further operable to present an extension wizard to a client for a particular one of the identified extension points. It can create entities and extensions in various modeling environments and development environments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08386996&OS=08386996&RS=08386996
owner: SAP AG
number: 08386996
owner_city: Walldorf
owner_country: DE
publication_date: 20070629
---
This disclosure relates to computer systems and methods and more particularly to methods systems and software for generating presenting or otherwise managing coherent multi dimensional business process models based on a plurality of disparate models.

Enterprise software systems are generally large and complex. Such systems can require many different components distributed across many different hardware platforms possibly in several different geographical locations. In order to design configure update or implement an enterprise software system one is generally required to understand details of the system at varying levels depending on his role in designing managing or implementing the system. For example a systems administrator may need a high level technical understanding of how various software modules are installed on physical hardware such as a server device or a network and how those software modules interact with other software modules in the system. A person responsible for configuring the software may utilize a high level functional understanding of the operations that each functional component provides. An application designer may utilize a low level technical understanding of the various software interfaces that portions of the application require or implement. And an application developer may utilize a detailed understanding of the interfaces and functionality he is implementing in relation to the remainder of the system. But the flow of a business process within an application today is typically hidden from a user. In some cases it is possible to manually create a textual or graphical documentation of this process flow. However this documentation is typically not detailed enough and can become quickly outdated since its consistency with the actual application software is not initially verified or maintained automatically.

Within a development environment an application can be developed using modeling systems. In general these models can specify the types of development objects or components that can be used to build applications as well as the relationships that can be used to connect those components. In an object oriented architecture for example a defined application can include a combination of various data objects and resources i.e. development objects . In that example relationships among the development objects can include a relationship indicating that one data object inherits characteristics from another data object. Another example architecture is the model view controller MVC architecture. Applications built using the MVC architecture typically include three different types of components models which store data such as application data views which display information from one or more models and controllers which can relate views to models for example by receiving events e.g. events raised by user interaction with one or more views and invoking corresponding changes in one or more models. When changes occur in a model the model can update its views. Data binding can be used for data transport between a view and its associated model or controller. For example a table view or a table including cells that are organized in rows and columns can be bound to a corresponding table in a model or controller. Such a binding indicates that the table is to serve as the data source for the table view and consequently that the table view is to display data from the table. Continuing with this example the table view can be replaced by another view such as a graph view. If the graph view is bound to the same table the graph view can display the data from the table without requiring any changes to the model or controller. In the MVC architecture development objects can include models views controllers and components that make up the models views and controllers. For example application data in a model can be an example of a component that is a development object.

To graphically model an application such that a combination of abstract graphical representations represent the components of the application and the relationships between those components a developer typically uses a drawing tool such as Microsoft Visio that provides abstract representations and tools for manipulating and or generating abstract representations. For example a user of the drawing tool such as a developer can choose to use a circle or any other suitable abstract representation or model to represent a class such as a class defined in the C or other object oriented programming language of an application developed under the object oriented architecture. The circle that represents a development object can include data from the development object. For example a name of a class i.e. data from a development object can be entered in a text box that is part of the circle and that name can be displayed in the center of the circle. In addition to drawing tools the developer can also use other graphical tools to generate graphical representations and models e.g. Unified Modeling Language UML diagrams or Business Process Execution Languages BPEL from application code or vice versa.

This disclosure relates to methods systems and software for processing a coherent multi dimensional business process model. In a first aspect software for processing a coherent multi dimensional business process model includes computer readable instructions embodied on media and operable when executed to identity a first model and a second model for a business process. The computer readable instructions are further operable when executed to transform at least a portion of the first model and at least a portion of the second model into a coherent multi dimensional business process model. The computer readable instructions are further operable when executed to present at least a subset of the coherent multi dimensional business process model to a client.

Implementations can include any all or none of the following features. For example the first model can include a business process variant flow model and the second model can include a state action model. In another example the software may be further operable to perform various functionality such as for example enriching the business process variant flow model with inbound interactions and relevant business objects and enriching the state action model with flagged actions and configuration links. The software may also scan the business process variant flow model for one or more associated business objects. The software can be further operable to scan the business process variant flow model for one or more associated status schemes and to transform the state action model into an allowed model for each identified business object and ordered by the status scheme. The software may also transform at least a portion of one or more business object flow models into the coherent multi dimensional business process model. In yet another example the software can regenerate the coherent multi dimensional business process model in response to the first model being changed.

In another aspect the software includes computer readable instructions embodied on media and operable to identify a coherent multi dimensional business process model based on at least a portion of a first model for a business process and at least a portion of a second model for the business process. This multi dimensional business process model may previously exist or be a model generated using one of the transformation techniques disclosed herein. The software then parses the multi dimensional business process model to identify at least one extension point each extension point operable to interface a disparate business tool with the business process. The software is further operable to present an extension wizard to a client for a particular one of the identified extension points.

In some cases this identified multi dimensional business process model can be protected from modification by the client. The extension wizard can present one or more extensibility patterns compatible with the particular extension point. The extensibility patterns can be selected from the following add a business task add field add after process add before process and add in between process. The extensibility wizard can be operable to present a series of questions to the client based on the first model. The software can be further operable to add one or more modeling elements at the particular extension point in response to client input.

The foregoing example software as well as other disclosed processes may also be computer implementable methods. Moreover some or all of these aspects may be further included in respective systems or other devices for executing implementing or otherwise supporting processing a coherent multi dimensional business process model. The details of these and other aspects and embodiments of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the various embodiments will be apparent from the description and drawings as well as from the claims.

This disclosure generally describes an example environment for processing a coherent multi dimensional business process model. At a high level the model is a representation of a software system part of a software system or an aspect of a software system. The model can be associated with one or more views. A view of the model represents a subset of the information in the model. For purposes of discussion the term model will be used to refer to both the model and a view of the model. The model can be used in a software development process to describe or specify a software application or parts or aspects of a software application for developers implementing or modifying the application. The model specifies the design to a useful level of detail or granularity. In this way a compliant implementation or deployment of the modeled functionality can conform to the specification represented by the model. For example the model may represent a sequence of steps executed to achieve a business result. According to the particular design each step can result in the change of state of a business object. Business processes can be part of triggered by and superior to other business processes. Business processes can be modeled in a hierarchy. As described herein the business process hierarchy includes a requirements definition design specification and implementation description level but other ways of defining a business process or other view hierarchy are possible. Thus the models described herein can be written in description notations appropriate for process modeling. As described in more detail below the model may include any number of logical layers each of which include one or more domains and represent a logical category of modeling such as high level business views system independent process views and implementation views. Each layer may be considered a sub model or a model in its own right that can be bound with other layers models. Moreover each logical layer can in some cases be bound with a plurality of lower layers such as one system independent process view being bound to a number of disparate but similar implementation views. Often the domains in one layer substantially match the domains in other bound layers.

In this disclosure techniques are provided to automatically generate a business process flow representation out of underlying more technical models used in the design and runtime of the application software. The actual flow of a business process within the application is spread over different areas like system integration internal status and action management of a business object as well as user tasks and workflows. These techniques take this different information sources to generate a detailed view of the complete process flow that can be both well readable for a user and still has a tight link to the actual technical implementation of the software. Creating such a reliable representation of the process flow within an application greatly reduces the efforts for companies to adapt the software to their needs by reducing the learning efforts. Further this generated process flow model can be the basis for easy extensions and adaptations.

With respect to example environment is typically a distributed client server system that spans one or more networks such as . As described above rather than being delivered as packaged software portions of environment may represent a hosted solution often for an enterprise or other small business that may scale cost effectively and help drive faster adoption. In this case portions of the hosted solution may be developed by a first entity while other components are developed by a second entity. Moreover the processes or activities of the hosted solution may be distributed amongst these entities and their respective components. In some embodiments environment may be in a dedicated enterprise environment across a local area network or subnet or any other suitable environment without departing from the scope of this disclosure.

Turning to the illustrated embodiment environment includes or is communicably coupled with server and one or more clients at least some of which communicate across network . Server comprises an electronic computing device operable to receive transmit process and store data associated with environment . For example server may be a Java 2 Platform Enterprise Edition J2EE compliant application server that includes Java technologies such as Enterprise JavaBeans EJB J2EE Connector Architecture JCA Java Messaging Service JMS Java Naming and Directory Interface JNDI and Java Database Connectivity JDBC . But more generally provides merely one example of computers that may be used with the disclosure. Each computer is generally intended to encompass any suitable processing device. For example although illustrates one server that may be used with the disclosure environment can be implemented using computers other than servers as well as a server pool. Indeed server may be any computer or processing device such as for example a blade server general purpose personal computer PC Macintosh workstation Unix based computer or any other suitable device. In other words the present disclosure contemplates computers other than general purpose computers as well as computers without conventional operating systems. Server may be adapted to execute any operating system including Linux UNIX Windows Server or any other suitable operating system. According to one embodiment server may also include or be communicably coupled with a web server and or a mail server.

Server often includes local memory . Memory may include any memory or database module and may take the form of volatile or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. Illustrated memory includes one or more data objects and at some point one or more modeled elements . But memory may also include any other appropriate data such as HTML files or templates data classes or object interfaces software applications or sub systems and others whether illustrated or not . For example memory may include pointers or other references to data objects that were published to a location remote from server . In this way a local developer or non technical business analyst may use a remote model or modeling domain to efficiently supplement the particular aspect that he is modeling or viewing.

Data objects are elements for information storage in object oriented computing systems. Data objects can describe the characteristics of an item using a series of data fields that for example can correspond to described characteristics. Typically a programmer will predefine standard object classes referred to in the present specification as object types that are hardcoded into a set of machine readable instructions for performing operations. Object types are blueprints for describing individual objects using a defined set of class attributes or properties . Instantiated objects that are members of such standard object types can be applied in a variety of different data processing activities by users for example customers who are largely unaware of the structure of the standard object types. Put another way the data objects are generally logical structures that can be modeled and then instantiated upon deployment to store particular data. Business objects may be a particular form of data object that a developer can utilize or reference in the front end of any business or other modeled application.

According to some embodiments the developer or other analyst may use a model driven development environment to compose an application using models of business logic or processes data objects user interfaces and so forth without having to write much if any code. Moreover these models can include or be different logical layers of abstraction including system specific system independent business independent instances. Indeed one of these logical layers may represent actual code or modules whether source or executable to assist developers. These layers of abstractions can include different domains that provide different views on the particular abstraction including graphical interfaces business processes or logic and data flow. In some circumstances some or all of these models may conform to a particular metamodel or metadata infrastructure. To aid the developer analyst or other user working with the model portions may be extracted from the perhaps very large model . A view of this extracted portion can then be presented to the requesting or another user often via interface . The extracted portion of model can be intersected or aggregated with extracted portions to generate a unified view on the subset. For example the user may utilize a filter provided by modeling environment to drill down to a more manageable subset. This example user may then provide customized criteria to focus on particular portions of this subset.

Modeling environment includes extensibility wizard . Extensibility wizard identifies points at which the presented portion of the coherent multi dimensional business process model may be extended with additional elements. These multi dimensional business process model may previously exist or be models generated using one of the transformation techniques disclosed herein or one similar . For example one or more elements of the business process represented by the portion may be interfaced with a business tool or application that is disparate from the business process using additional elements.

Some or all of the data objects and models may be stored or referenced in a local or remote development or metamodel repository. This repository may include parameters pointers variables algorithms instructions rules files links or other data for easily providing information associated with or to facilitate modeling of the particular object. More specifically each repository may be formatted stored or defined as various data structures in eXtensible Markup Language XML documents text files Virtual Storage Access Method VSAM files flat files Btrieve files comma separated value CSV files internal variables one or more libraries or any other format capable of storing or presenting all or a portion of the interface process data and other models or modeling domains. In short each repository may comprise one table or file or a plurality of tables or files stored on one computer or across a plurality of computers in any appropriate format as described above. Indeed some or all of the particular repository may be local or remote without departing from the scope of this disclosure and store any type of appropriate data.

In addition to memory illustrated server includes example processors and . The processors and may each be a central processing unit CPU a blade an application specific integrated circuit ASIC or a field programmable gate array FPGA . Both processors and may execute instructions and manipulate data to perform the operations of server . Although illustrates two processors and in server only one or more than two processors may be used according to particular needs desires or particular embodiments of environment . In the illustrated embodiment processor executes model driven development tool or environment and processor executes modeled business application . At a high level the modeling environment and application are operable to receive and or process requests from developers and or users and present at least a subset of the results to the particular user via an interface.

The GUI modeling environment may be any development tool toolkit application programming interface API application or other framework that allows a developer to develop configure and utilize various business elements that can be more easily modeled during modeling or during design time of a particular business application. For example the model driven framework or environment may allow the developer to use simple drag and drop techniques to develop pattern based or freestyle user interfaces and define the flow of data between them. Such drag and drop techniques may include selecting inputting identifying or some other indication that the developer is interested in a particular object or element. The result could be an efficient customized visually rich online experience. In some cases this model driven development may accelerate the application development process and foster business user self service. It further enables business analysts or IT developers to compose visually rich applications that use analytic services enterprise services remote function calls RFCs APIs and stored procedures. In addition it may allow them to reuse existing applications and create content using a modeling process and a visual user interface instead of manual coding in other words the modeling environment can be used to create modify and examine the model.

In some cases this example modeling environment may provide a personalized secure interface that helps unify enterprise applications information and processes into a coherent role based portal experience. Further the modeling environment may allow the developer to access and share information and applications in a collaborative environment. In this way virtual collaboration rooms allow developers to work together efficiently regardless of where they are located and may enable powerful and immediate communication that crosses organizational boundaries while enforcing security requirements. Indeed the modeling environment may provide a shared set of services for finding organizing and accessing unstructured content stored in third party repositories and content management systems across various networks . Classification tools may automate the organization of information while subject matter experts and content managers can publish information to distinct user audiences. Regardless of the particular implementation or architecture this modeling environment may allow the developer to easily model various elements using this model driven approach. As described in more example detail later the model is deployed and environment may translate the model into the required code for at least one application or web service. This deployed business application may then be modified or enhanced as appropriate using the modeling environment .

More specifically application may represent any modeled software or other portion of business functionality or logic. A first instance of application may represent a first application that is .NET based while a second instance of application may be a similar hosted web based solution. In yet another example application may be a modeled composite application with any number of portions that may be implemented as Enterprise Java Beans EJBs or the design time components may have the ability to generate run time embodiments into different platforms such as J2EE ABAP Advanced Business Application Programming objects or Microsoft s .NET. In a further example application may merely be a modeled and published web service. Further while illustrated as internal to server one or more processes associated with modeling environment or application may be stored referenced or executed remotely. For example a portion of an application may be a web service that is remotely called while another portion of the application may be an interface object bundled for processing at remote client . Moreover modeling environment or application may each be a child or sub module of other respective software modules or enterprise applications not illustrated without departing from the scope of this disclosure.

Regardless of the particular implementation software may include software firmware wired or programmed hardware or any combination thereof as appropriate. Indeed each software component may be fully or partially written or described in any appropriate computer language including C C Java Visual Basic assembler Perl any suitable version of 4GL as well as others. It will be understood that while the software illustrated in is shown as a single module that implements the various features and functionality through various objects methods or other processes the software may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

Server may also include interface for communicating with other computer systems such as clients over network in a client server or other distributed environment. In certain embodiments server receives data from internal or external senders through interface for storage in memory and or processing by processor or processor . Generally interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with network . More specifically interface may comprise software supporting one or more communications protocols associated with communications network or hardware operable to communicate physical signals. Interface may allow communications across network via a virtual private network VPN SSH Secure Shell tunnel or other secure network connection.

Network facilitates wireless or wireline communication between computer server and any other local or remote computer such as clients . Network may be all or a portion of an enterprise or secured network. In another example network may be a VPN merely between server and client across wireline or wireless link. Such an example wireless link may be via 802.11a 802.11b 802.11g 802.20 WiMax and many others. While illustrated as a single or continuous network network may be logically divided into various sub nets or virtual networks without departing from the scope of this disclosure so long as at least a portion of network may facilitate communications between server and at least one client . In other words network encompasses any internal or external network networks sub network or combination thereof operable to facilitate communications between various computing components in environment . Network may communicate for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and other suitable information between network addresses. Network may include one or more local area networks LANs radio access networks RANs metropolitan area networks MANs wide area networks WANs all or a portion of the global computer network known as the Internet and or any other communication system or systems at one or more locations. In certain embodiments network may be a secure network associated with the enterprise and certain local or remote clients .

Client is any computing device operable to connect or communicate with server or network using any communication link. At a high level each client includes or executes at least GUI and comprises an electronic computing device operable to receive transmit process and store any appropriate data associated with environment . It will be understood that there may be any number of clients communicably coupled to server . Further client 110 developer and user may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover for ease of illustration each client is described in terms of being used by one user. But this disclosure contemplates that many users may use one computer or that one user may use multiple computers. As used in this disclosure client is intended to encompass a personal computer touch screen terminal workstation network computer kiosk wireless data port smart phone personal data assistant PDA one or more processors within these or other devices or any other suitable processing device. For example client may be a PDA operable to wirelessly connect with external or unsecured network. In another example client may comprise a laptop that includes an input device such as a keypad touch screen mouse or other device that can accept information and an output device that conveys information associated with the operation of server or clients including digital data visual information or GUI . Both the input device and output device may include fixed or removable storage media such as a magnetic computer disk CD ROM or other suitable media to both receive input from and provide output to users of clients through the display namely the client portion of GUI or application interface .

GUI comprises a graphical user interface operable to allow the user of client to interface with at least a portion of environment for any suitable purpose such as viewing application model or model subset view data . As the models are filtered at least a viewable portion of the results are presented using GUI . Generally GUI provides the particular user with an efficient and user friendly presentation of data provided by or communicated within environment . More specifically GUI can include a modeling editor that presents views of models based upon filters. The modeling editor can be connected with the modeling environment or other development environment such that the modeling editor and or the modeling environment can automatically generate an application model e.g. a model of an application that is being developed from a graphical model and or vice versa. The modeling editor can allow a user to freely choose graphical objects that can represent one or more development objects or no development objects at all. The modeling editor can support representing different abstraction levels that correspond to a graphical model. For example this modeling editor can support modeling a detailed view or an abstract view of a graphical model. Typically the information that is represented in a graphical model can be freely edited. For example a graphical model can be edited to include user descriptions or business information that is not part of the development objects and or relationships among development objects. Changes to development objects and or relationships among development objects can be automatically reflected in an associated graphical model and or vice versa. Accordingly GUI may comprise a plurality of customizable frames or views having interactive fields pull down lists and buttons operated by the user. GUI may also present a plurality of portals or dashboards. For example GUI may display a portal that allows developers or information managers to view create and manage data objects or models. GUI is often configurable supporting a combination of tables and graphs bar line pie status dials etc. and is able to build real time dashboards. It should be understood that the term graphical user interface may be used in the singular or in the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interlace. Indeed reference to GUI may indicate a reference to the front end or a component of any application or software as well as the particular interface accessible via client as appropriate without departing from the scope of this disclosure. Therefore GUI contemplates any graphical user interface such as a generic web browser or touchscreen that processes information in environment and efficiently presents the results to the user. Server can accept data from client via the web browser e.g. Microsoft Internet Explorer or Mozilla Firefox and return the appropriate HTML or XML responses to the browser using network .

In certain embodiments the modeling environment may implement or utilize a generic declarative and executable GUI language generally described as XGL . This example XGL is generally independent of any particular GUI framework or runtime platform. Further XGL is normally not dependent on characteristics of a target device on which the graphic user interface is to be displayed and may also be independent of any programming language. XGL is used to generate a generic representation occasionally referred to as the XGL representation or XGL compliant representation for a design time model representation. The XGL representation is thus typically a device independent representation of a GUI. The XGL representation is declarative in that the representation does not depend on any particular GUI framework runtime platform device or programming language. The XGL representation can be executable and therefore can unambiguously encapsulate execution semantics for the GUI described by a model representation. In short models of different types can be transformed to XGL representations.

The XGL representation may be used for generating representations of various different GUIs and supporting various GUI features including full windowing and componentization support rich data visualizations and animations rich modes of data entry and user interactions and flexible connectivity to any complex application data services. While a specific embodiment of XGL is discussed various other types of XGLs may also be used in alternative embodiments. In other words it will be understood that XGL is used for example description only and may be read to include any abstract or modeling language that can be generic declarative and executable.

Turning to the illustrated embodiment in modeling tool may be used by a GUI designer or business analyst during the application design phase to create a model representation for a GUI application. It will be understood that modeling environment may include or be compatible with various different modeling tools used to generate model representation . This model representation may be a machine readable representation of an application or a domain specific model. Model representation generally encapsulates various design parameters related to the GUI such as GUI components dependencies between the GUI components inputs and outputs and the like. Put another way model representation provides a form in which the one or more models can be persisted and transported and possibly handled by various tools such as code generators runtime interpreters analysis and validation tools merge tools and the like. In one embodiment model representation maybe a collection of XML documents with a well formed syntax.

Illustrated modeling environment also includes an abstract representation generator or XGL generator operable to generate an abstract representation for example XGL representation or XGL compliant representation based upon model representation . Abstract representation generator takes model representation as input and outputs abstract representation for the model representation. Model representation may include multiple instances of various forms or types depending on the tool language used for the modeling. In certain cases these various different model representations may each be mapped to one or more abstract representations . Different types of model representations may be transformed or mapped to XGL representations. For each type of model representation mapping rules may be provided for mapping the model representation to the XGL representation . Different mapping rules may be provided for mapping a model representation to an XGL representation.

This XGL representation that is created from a model representation may then be used for processing in the runtime environment. For example the XGL representation may be used to generate a machine executable runtime GUI or some other runtime representation that may be executed by a target device. As part of the runtime processing the XGL representation may be transformed into one or more runtime representations which may indicate source code in a particular programming language machine executable code for a specific runtime environment executable GUI and so forth that may be generated for specific runtime environments and devices. Since the XGL representation rather than the design time model representation is used by the runtime environment the design time model representation is decoupled from the runtime environment. The XGL representation can thus serve as the common ground or interface between design time user interface modeling tools and a plurality of user interface runtime frameworks. It provides a self contained closed and deterministic definition of all aspects of a graphical user interface in a device independent and programming language independent manner. Accordingly abstract representation generated for a model representation is generally declarative and executable in that it provides a representation of the GUI of model that is not dependent on any device or runtime platform is not dependent on any programming language and unambiguously encapsulates execution semantics for the GUI. The execution semantics may include for example identification of various components of the GUI interpretation of connections between the various GUI components information identifying the order of sequencing of events rules governing dynamic behavior of the GUI rules governing handling of values by the GUI and the like. The abstract representation is also not GUI runtime platform specific. The abstract representation provides a self contained closed and deterministic definition of all aspects of a graphical user interface that is device independent and language independent.

Abstract representation is such that the appearance and execution semantics of a GUI generated from the XGL representation work consistently on different target devices irrespective of the GUI capabilities of the target device and the target device platform. For example the same XGL representation may be mapped to appropriate GUIs on devices of differing levels of GUI complexity i.e. the same abstract representation may be used to generate a GUI for devices that support simple GUIs and for devices that can support complex GUIs and the GUIs generated by the devices are consistent with each other in their appearance and behavior.

Abstract generator may be configured to generate abstract representation for models of different types which may be created using different modeling tools . It will be understood that modeling environment may include some none or other sub modules or components as those shown in this example illustration. In other words modeling environment encompasses the design time environment with or without the abstract generator or the various representations a modeling toolkit such as linked with a developer s space or any other appropriate software operable to decouple models created during design time from the runtime environment. Abstract representation provides an interface between the design time environment and the runtime environment. As shown this abstract representation may then be used by runtime processing.

As part of runtime processing modeling environment may include various runtime tools and may generate different types of runtime representations based upon the abstract representation . Examples of runtime representations include device or language dependent or specific source code runtime platform specific machine readable code GUIs for a particular target device and the like. The runtime tools may include compilers interpreters source code generators and other such tools that are configured to generate runtime platform specific or target device specific runtime representations of abstract representation . The runtime tool may generate the runtime representation from abstract representation using specific rules that map abstract representation to a particular type of runtime representation. These mapping rules may be dependent on the type of runtime tool characteristics of the target device to be used for displaying the GUI runtime platform and or other factors. Accordingly mapping rules may be provided for transforming the abstract representation to any number of target runtime representations directed to one or more target GUI runtime platforms. For example XGL compliant code generators may conform to semantics of XGL as described below. XGL compliant code generators may ensure that the appearance and behavior of the generated user interfaces is preserved across a plurality of target GUI frameworks while accommodating the differences in the intrinsic characteristics of each and also accommodating the different levels of capability of target devices.

For example as depicted in example an XGL to Java compiler may take abstract representation as input and generate Java code for execution by a target device comprising a Java runtime . Java runtime may execute Java code to generate or display a GUI on a Java platform target device. As another example an XGL to Flash compiler may take abstract representation as input and generate Flash code for execution by a target device comprising a Flash runtime . Flash runtime may execute Flash code to generate or display a GUI on a target device comprising a Flash platform. As another example an XGL to DHTML dynamic HTML interpreter may take abstract representation as input and generate DHTML statements instructions on the fly which are then interpreted by a DHTML runtime to generate or display a GUI on a target device comprising DHTML platform.

It should be apparent that abstract representation may be used to generate GUIs for Extensible Application Markup Language XAML or various other runtime platforms and devices. The same model representation may be mapped to various runtime representations and device specific and runtime platform specific GUIs. In general in the runtime environment machine executable instructions specific to a runtime environment may be generated based upon the abstract representation and executed to generate a GUI in the runtime environment. The same XGL representation may be used to generate machine executable instructions specific to different runtime environments and target devices.

According to certain embodiments the process of mapping a model representation to an abstract representation and mapping an abstract representation to some runtime representation may be automated. For example design tools may automatically generate an abstract representation for the model representation using XGL and then use the XGL abstract representation to generate GUIs that are customized for specific runtime environments and devices. As previously indicated mapping rules may be provided for mapping model representations to an XGL representation. Mapping rules may also be provided for mapping an XGL representation to a runtime platform specific representation.

Since the runtime environment uses abstract representation rather than model representation for runtime processing the model representation that is created during design time is decoupled from the runtime environment. Abstract representation thus provides an interface between the modeling environment and the runtime environment. As a result changes may be made to the design time environment including changes to model representation or changes that affect model representation generally to not substantially affect or impact the runtime environment or tools used by the runtime environment. Likewise changes may be made to the runtime environment generally to not substantially affect or impact the design time environment. A designer or other developer can thus concentrate on the design aspects and make changes to the design without having to worry about the runtime dependencies such as the target device platform or programming language dependencies.

One or more runtime representations including GUIs for specific runtime environment platforms may be generated from abstract representation . A device dependent runtime representation may be generated for a particular type of target device platform to be used for executing and displaying the GUI encapsulated by the abstract representation. The GUIs generated from abstract representation may comprise various types of GUI elements such as buttons windows scrollbars inputs boxes etc. Rules may be provided for mapping an abstract representation to a particular runtime representation. Various mapping rules may be provided for different runtime environment platforms.

As described with respect to modeling tool may be used by a GUI designer or business analyst during the application design phase to create a model representation for a GUI application. In addition modeling tool may be used during other modeling phases and by other types of users to create model representations for a GUI application. illustrates example modeling phases using the example modeling environment of or some other modeling environment. Modeling phases may include development rollout solution implementation and solution operation . In some implementations development and rollout represent a product innovation lifecycle while solution implementation and solution operation represent a customer engagement lifecycle. Development may include for example determining requirements of a product or application writing a specification for the product or application designing the product or application and writing software code for the product or application. Rollout may continue with software coding and also includes generating detailed documentation and or detailed models as well as sales collaterals and or sales models. Solution implementation may continue with generation of sales collaterals and or models and also includes adapting the product or application as well as extending the design of the product or application. Solution operation may include for example monitoring the product or application and optimizing processes in the product or application. Generation of a multi dimensional business process model provides access to modeling phases for review and or changes by a user.

Modeling tool enriches or extends BPVT model with additional information associated with process component . Modeling tool adds business objects from process component to BPVT model that are relevant for variation . Particularly modeling tool adds customer invoice customer invoice request and customer invoice run business objects to process component . In some implementations the ARIS method is enhanced to allow BPVT model to connect to business objects . Business objects represent a business object in the real world such as a purchase order. Business objects describe information operations and interactions associated with a business process. By invoking methods such as BAPIs Business Application Programming Interface external applications can access and manipulate the business objects. Here the term business object is used to refer to business process object master data object and mass data run object MDRO . If a business object has more than one status scheme for a given business object node then the status scheme to be used in the generation of the multi dimensional business process model is determined. The determined status scheme is stored as an attribute on the connection between the business object node and BPVT . In addition modeling tool identifies interactions with other process components used by the BPVT . The interactions may be outbound interactions as shown in the BPVT model or inbound interactions.

In addition to BPVT models modeling tool may use additional model types such as a status and action model SAM when generating a multi dimensional business process model. illustrates an enriched SAM . This example SAM includes customer invoice SAM . SAM includes actions and statuses associated with the customer invoice business object.

Modeling tool uses SAMs to generate process flow models. Modeling tool flags actions in SAM that arc used in generating a process flow model. Modeling tool may identify the existing modeled outbound agents and automatically flag those actions which set statuses that trigger outbound agents or task agents. Flagged actions indicate when an operation or task is called. For example modeling tool may flag actions and as triggering outbound agents or task agents based on selected status values for statuses respectively. For those actions which can set more than one status value in an exclusive or XOR mode e.g the action check consistency can set the values consistent or inconsistent modeling tool adds a link to the relevant configuration. This configuration can be a link to a configuration table in an application platform. This link may serve as information to the customer to indicate where the configuration may be changed.

Modeling tool indicates which actions of the same business object or another business object are automatically called during creation of the business object. For example during creation of the customer invoice business object a check consistency action is automatically called as indicated by edge . Modeling tool indicates which actions automatically call another action of the same business object or another business object. For example execute action of the customer invoice run mass data run object automatically calls release action of the customer invoice business object as indicated by edge . If a call depends on configuration parameters such as the call represented by edge a link to the configuration may be provided.

This transformation step begins with modeling tool creating actions and within the customer invoice request customer invoice and customer invoice run business objects respectively. Modeling tool may connect actions with edges using a particular set of rules. For example if an action sets a status value that enables another action modeling tool may connect the actions with an edge. In another example modeling tool may connect three or more actions using a logical AND or a logical OR element such as where an action is based on more than one action or an action changes a status that enables more than one action.

Modeling tool links synchronous outbound operations to actions by automatic flow edges directed from the action to the operation and from the operation back to the action. Modeling tool links synchronous outbound operations by retrieving the model of the synchronous outbound agent to obtain the information describing which action triggers the agent. Modeling tool links the corresponding action with the operation.

Modeling tool links asynchronous and synchronous inbound operations to actions using automatic edges no conditions directed from the operation to the action e.g. edge . Modeling tool links inbound operations by determining which actions the inbound agent is triggering.

Metamodel includes extension points . Extension points maintain application platform integrity during extension of the model. Wizard determines at which locations the model may be extended. Extension points are shown in the flow model at a process step level. Extension points define where the user can make an extension and wizard automatically determines possible extension patterns that are allowed those patterns are shown actively to the user . Extension points may be specific to process components. An extension point may be an entry and or exit point corresponding to actions and status values respectively. A process step can have 0 n entry and or exit points . Entry points are shown on the left of process steps and exit points are shown on the right of process steps when presented by wizard to a user. Allowed pattern extensions for entry points include Add Before extensions and Add in Between extensions. Allowed pattern extensions for Exit Points include In Between extensions Add After extensions Add Task extensions and Start User centric process extensions.

Metamodel includes extension patterns . Extension patterns include before process extensions after process extensions new business task extensions start user centric process extensions in between process extensions add A2X service extensions and add held extensions .

Before process extension occurs when a user adds a new externally provided process which is run before an application platform process is started. Before process extension triggers the application platform process typically asynchronously. In some implementations some process components use the same operation for inbound operations such as customer invoice processing. If the same inbound operation or service is used then wizard asks the user the question Do you want to reuse the following service and presents the service to the user. In one scenario a user selects extension point . Depending on the extension point wizard presents extension patterns that are allowed given selected extension point . The user chooses new before process extension pattern . If the extension point is positioned on a process step which contains more than one action having an entry point for this pattern the process step is expanded and wizard prompts the user has to select an extension point on an action. Wizard then prompts the user to input names for new entities such as composite process components and operations. Wizard may present default or initial names such as Maintain for operations and . . . Processing for the composite process components. The user may complete the names. If the user is reusing a service then wizard presents agent rules for the user to adapt. If the user is not reusing a service then wizard derives the name of the agent from the name of the composite process component inserted by the user e.g. Maintain based on . Wizard creates a new process component interaction model. Wizard may also extend or create processing component process variant type BPVT model and or process component model. Wizard also outputs agents interfaces operations and messages resulting from the extension made by the user. Wizard identifies incomplete entities for the user.

After process extension occurs when a user adds a new externally provided process which is triggered asynchronously from within an application platform. In some implementations existing application platform processes are not affected by after process extensions . In one example a user extends the model for Intrastat a system of collecting information and producing statistics on the movement of goods between Member States of the European Union to provide data from customer invoice processing and Supplier Invoice Processing . Wizard extends the model by adding an outbound agent interface and operation to send the data. Again tire user selects the extension point where the extension is to occur. The user selects the new after process extension . If the extension point is positioned on a process step which contains more than one action having an entry point for this pattern the step is expanded and the wizard prompts the user to select an extension point on an action. Wizard asks the user Do you want to reuse a service If the user does not want to reuse a service then wizard prompts the user to input names for new entities such as composite process components and operations. The wizard may propose Inform of for operations and . . . Component for the process components. The user may complete the names. If the user is reusing a service wizard presents agent rules to the user for the user to adapt. Otherwise wizard may determine the agent name from the name of the composite process component provided by the user e.g. Maintain based on . Again wizard creates a new process component interaction model. Wizard may also extend or create processing component process variant type BPVT model and or process component model. Wizard also outputs agents interfaces operations and messages resulting from the extension made by the user. Wizard can typically identify incomplete entities for the user. In some implementations the underlying models are completed test ready by the wizard. For example the relevance condition start condition change condition or cancel condition for an outbound process agent are filled. Conditions are different depending on the fact if it s a synchronous or asynchronous process agent. The outbound process agent can be created in two systems in an enterprise services repository ESR and the corresponding proxy in backend system perhaps containing automatically created coding.

New business task extensions may occur during pre configuration and or configuration of BTM tasks at design time in fine tuning user interfaces e.g. adapt deadline change responsibility category change default priority change title change description. In another example new business task extensions may occur after a project manager has assigned a resource to a project a BTM task is triggered that informs the resource about a start end and duration of a new project task. A task may be added to trigger a local user centric process. Wizard adds a new business task agent and task type to an existing process component. A business object triggers the task creation via a task agent. Wizard prompts the user to select which action is the main condition to trigger task creation. Each action in the flow model may be a candidate for this condition or more specifically the status value an action sets during execution. The user selects the extension point . The user selects new business task extension . If the extension point is positioned on a process step which contains more than one action having an entry point for this pattern the step is expanded and wizard prompts the user has to select an extension point on an action. Wizard prompts the user to input a name for the new task. Wizard prompts the user to select a usage type from a list of possible usage types. The user may also input attributes for task agent and task type. Wizard determines a task agent name from the task name input by the user. Wizard creates and or extends the process component task model. Wizard creates a task type and a task agent in an extension layer. The conditions for the task agent are often created ready to test in backend particularly relevance condition start condition change condition cancel condition and completion condition. The task type can be created in backend and attributes such as i responsible user and ii the GUI presented if the task is created are prefilled ready to test.

Start user centric process extension occurs when a user adds a new externally realized user centric process. This is triggered asynchronously from within the application platform. In some implementations existing application platforms processes are not affected. A user selects the extension point . The user selects the start user centric process extension . If the extension point is positioned on a process step which contains more than one action having an extension point for this pattern the step is expanded and wizard prompts the user has to select an extension point on an action. Wizard asks the user the question Do you want to reuse the following service Wizard presents the service to the user. Wizard prompts the user to input a name of the user centric process. If a service is not reused then wizard prompts the user to input names for new entities such as operations. Wizard may propose names. The user may complete the names. If a service is not reused then wizard determines the agent name from the name of the composite process component inserted by the user. Again wizard creates a new process component interaction model. Wizard may also extend or create process component process variant type BPVT model and or process component model as well as Status and Action model S AM . For this the wizard determines which status scheme is to be extended. Depending on the process step template chosen the status scheme is extended via a process step one or more actions one or more status value as well as connections between them. For each of these entities corresponding entities are often created in the ESR as data type extensions attached to the business object which is manipulated by the wizard . Additionally the corresponding proxies are often created in backend by wizard . Wizard also outputs agents interfaces operations and messages resulting from the extension made by the user. Wizard identifies incomplete entities for the user.

New in between process extensions may be asynchronous or synchronous sequential or parallel and mandatory or optional. If in between process extension is optional the user may define multiple possibilities under which the step is executed. This may affect underlying models such as process agents and SAM. A new process step is typically realized in a composite process component. In some instances wizard questions whether it should be created in user centric component or process component. The additional process or process step is triggered by an application platform business object via a message. When the composite process component executes the process step the process step sends data back to the same process component. For example in the case of a sequential asynchronous in between process such as Professional Services project processing gives project and task data such as start end and duration to the new composite process component Workforce processing. Wizard searches for resources and when found the resources are given back to project processing. A new action within project processing is needed which changes the status of a task from open to staffed. For example in the case of a sequential asynchronous in between process if a parcel has to be shipped Logistics Execution sends data to a composite process component of a Shipper. The shipper finds out which Carrier can transport the parcel. When a suitable carrier is found the information is sent back to Logistics Execution. In another example for a parallel process step realized in a composite process component an additional credit check is called during Sales Order creation. The step is executed in another process component and triggered by application platform business object Sales Order. When a sales order is created several steps like consistency check and ATP check are executed. In addition the credit check may be executed in parallel before processing in supply chain management continues. The standard process continues if the new process step is executed. This can be ensured via creation of constraints the connections which are inserted into S AM scheme mentioned above . Additionally the user can decide whether to execute the new process step for each business object instance or only for some. Outbound delivery can send deliveries for packages to the carrier while the others are executed in standard process. For this the wizard creates rules deciding for which instances the process step is active and for which ones not.

New in between process extension may begin with a user selecting the extension point . The user selects new in between process extension . If the extension point is positioned on a process step which contains more than one action having an entry point for this pattern the step is expanded and wizard prompts the user to select an extension point on an action. If there are multiple connections going from the action to other actions process steps wizard prompts the user to select an extension point before which the process step is inserted. If the user selects a process step having more than one action with extension points the step is expanded and wizard prompts the user to select an extension point on an action. Wizard asks the questions. Is the new process a sequential in between process and Is the new process asynchronous If the process is not asynchronous wizard asks Is the new process realized synchronously in a composite process component If the process is not realized synchronously in a composite process component wizard asks Is the new process realized within a new process step residing in this process component Wizard asks. Do you want to reuse the following service choreography and wizard presents the choreography to the user in the form of a process component interaction model. Wizard asks Is the new process step optional Wizard asks Will the action following the extension be called automatically Wizard asks Will the extension action be called automatically If a service or process component is not reused wizard prompts the use to input names for new entities such as composite process components outbound operations and inbound operations. The wizard may propose names such as inform of for Outbound Operation Execute Action for inbound operation and . . . Processing for the Composite Process Component. The user may complete the names. Wizard extends the SAM based on the new process step. If a service is not reused then wizard determines the agent name from the name of the composite process component inserted by the user. Again wizard creates a new process component interaction model. Wizard may also extend or create processing component process variant type BPVT model and or process component model. Wizard also processes manages or implements inbound and outputs agents interfaces operations and messages as well as status scheme extensions and business configuration resulting from the extension made by the user. Wizard identifies incomplete entities for the user.

Add A2X service extension may be used if a new user interface or user centric component accesses application platform core services. If the core service is an action and appears in SAM for the process variant a user may extend the process step the core service is located in by selecting the action. Then the user selects pattern Add A2X Services . Alternatively the user may select the pattern Add A2X Service without having selected a core service. Wizard then presents a list of core services form which the user may select. Wizard creates a new interface operation and perhaps synchronous agent. In some implementations the agent is a generic one and signature mapping and coding are generated in the ESR and backend.

Add field extension occurs when a user adds a new field to a business object. In addition a user may use a field from a business object in another business object. The user may select a business object and then pattern add field or the user may select a pattern add field and then select a business object from a list presented by wizard . Wizard presents the business object node structure. The user selects a node from the structure. The user may input text meta data such as name type and technical name. Wizard asks Do you want to create value help for the new field If the user answers yes then the user may input data for value help such as fixed values. Wizard asks Do you need data flow extension i.e. shall the field be reused in other BOs If yes then the user selects from a list the possible data flow extensions. Wizard asks Will the field be used on dropdown list UI Report form If yes then the user selects from a list the user interfaces reports and forms on which the field will appear. In some implementations the field is not shown in the flow model. Wizard may provide links that allow a user to navigate to the user interface report and or form on which the field appears. Wizard creates the field in the model stores possible values for the field enables navigation for the field and in the ease of data flow extension creates a message type extension which can include extensions in ESR and backend.

For business configuration extension a third system may be extended by the wizard such as a Business Design Time Repository. Overall entities can be created in different development environments. For example modeling tools such as ARIS for status and action management ESR backend via proxies and so forth can be used. Coding can be created by the wizard as appropriate. Accordingly Business Process Variant models are created or extended from the process flow model as shown in . Particularly wizard may facilitate automatic generation of underlying models in ESR backend and configuration at design time such as for example automatic coding creation in backend in proxies or via rules . It may also work provide navigation possibilities from process flow model to underlying executable models as illustrated in . In some cases the flow model itself may not be changed unless via patterns.

Process either receives an extension point user selection or an add field pattern extension user selection. For example wizard may indicate to the user possible extension points for extension of the flow model. The user may select the extension point in the flow model or the user may select the add field extension .

Process receives a pattern extension user selection if the process has not already received the add field selection. For example wizard may receive a user selection indicating extension pattern or .

If add field extension is selected then process receives a definition of field details from the user. For example wizard may receive a field name type and mandatory or optional indication from the user. Process receives a definition of the field on a user interface. For example wizard may receive information defining on which user interfaces reports and or forms the field appears. Process receives a definition of a data flow for the field.

If add business task is selected then process receives a definition of task details from the user. For example wizard may receive a name type and or trigger for the new task. The wizard automatically creates task type and task agent with conditions in backend as described above .

If add before after or in between process extension is selected then process receives a definition of an interaction between an application platform and the composite process component. For example wizard may receive information defining an interaction between a customer invoice process component and an application platform for a country tax system such as the Golden Tax in China. Process receives a new application platform or process step behavior. For example wizard may receive answers from a user indicating whether a new process component is called asynchronously or synchronously sequential or parallel if a process step is added and automatically triggered or manually triggered. In each case the S AM scheme is normally extended. If a process component is used then in some instances a process component interaction model is created the process component model is extended a BPVT model is extended and a new BPVT model is created in ESR modeling environment. In the case of an automatic trigger coding can be generated by the wizard in backend.

If after prompting the user to select an extension point process receives an extension point selection then process prompts the user to select a pattern extension. Process may prompt the user to provide a specific extension point depending on the selected pattern extension and the elements within the process step that includes the previously selected extension point. Process may request information regarding the interaction and details of the added process such as an entry point a precise entry point a realization component a name for the added process whether the added process is synchronous or asynchronous whether the task is used for user centric processes which instances of the step will realize the extension and whether a user may choose the realization of the extension execution. Process may request that the user provide behavior information regarding the added process such as whether the step is automatically executed a pattern for the process step and any additional business tasks or fields added with the process step.

The user may select the add in between extension to create processing for a Golden Tax. In the Golden Tax scenario a customer invoice requires a unique identifier ID provided by a government authority. In some implementations the ID is required to send an invoice. The Golden Tax is designed to prevent tax fraud and may be mandatory in certain countries like China. To comply with these rules customer invoice processing is extended. Before the customer invoice can be released another process is triggered to interact with an application that processes the Golden Tax ID and the communication with the government. After the ID is known customer invoice processing is called again with the ID and the original process can continue. The wizard helps ensure that standard process is used in other countries except China via a rule indicating instances for which the new process step will be created.

Referring to extensibility wizard presents interface showing operations a process component flow interactions and a process step created as a result of the in between process extension. The confirm process step invokes the notify operation to notify the golden tax process component when a customer invoice is created. The golden tax process component handles communication with the government organization to retrieve the golden tax ID. The golden tax process component invokes the execute operation to pass the golden tax ID to the confirm process step . The execute operation returns processing to the confirm process step and customer invoicing resumes. AS a result of answers to questions and inputs made by the user wizard generates the flows . For example the flow between the confirm process step and the notify operation is a configurable automatic flow e.g. automatically flows to operation for invoices to Brazil or China . Wizard generates the manually triggered flows . For example the golden tax process component may be performed using human interaction. Wizard generates the automatic flow from the execute operation to the confirm process step .

Referring to the extensibility wizard presents a menu of options in the interface . By selecting a display my extensions control a user may request that the interface present extensions created by the user. A user may review outstanding incomplete extension elements by selecting a show operation queue control . A user may request that the wizard check the consistency of the flow model by selecting a check consistency control . A user may undo a pattern extension by selecting an undo pattern control . By selecting regenerate model a user may request that the wizard incorporate changes made to the various layers of the model into the coherent multi dimensional business process model. A user may review details e.g. view business tasks or other elements not currently shown of the flow model by selecting a show details control . A user may enter an expert mode for example to modify underlying data structures or models by selecting an expert mode control .

The preceding figures and accompanying description illustrate processes and implementable techniques. But environment or its software or other components contemplates using implementing or executing any suitable technique for performing these and other tasks. It will be understood that these processes are for illustration purposes only and that the described or similar techniques may be performed at any appropriate time including concurrently individually or in combination. In addition many of the steps in these processes may take place simultaneously and or in different orders than as shown. Moreover environment may use processes with additional steps fewer steps and or different steps so long as the methods remain appropriate.

In other words although this disclosure has been described in terms of certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

