---

title: Software technique to correlate conceptually similar entities
abstract: Various technologies and techniques are disclosed for providing a framework with a common set of domain-specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model-specific object instances. A particular model-specific object instance of a particular one of the object models can be retrieved using a common set of domain-specific entity identifier types. An instance of a particular domain-specific entity identifier type can be retrieved from a corresponding one of the model-specific object instances. One or more extensibility mechanisms allow third parties to extend the set of domain-specific entity identifier types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08813101&OS=08813101&RS=08813101
owner: Microsoft Corporation
number: 08813101
owner_city: Redmond
owner_country: US
publication_date: 20070328
---
In the world of computer programming object models are application programming interfaces APIs and or classes that are used to represent specific types of information relating to some problem domain. Multiple object models frequently refer to the same domain of conceptual entity using their own internal representation. Individual object models are typically designed to facilitate some particular style of data access or algorithmic processing. Take for example a method object called Method A that represents a specific function in some computer program. There might be a performance analysis tool that stores performance data over a period of time for a certain method object called Method A . There might be a debugger that also stores debugging information for a method object called Method A . There might also be source code written using a software development program that contains the actual implementation for Method A . Each program uses its own model specific object instances for referring to the same conceptual entity called Method A .

A problem arises when a process wants to correlate the different objects corresponding to Method A in a meaningful fashion. One approach that is sometimes taken is to independently recognize that they are referring to the same conceptual entity by invoking model dependent application programming interfaces to retrieve the entities using model dependent data extracted from the other model. For example suppose that a debugger wants to use performance analysis data for a comparison. The debugger could ask the performance analysis tool for the data. The performance analysis tool would then analyze the performance record from the performance model extract a method signature recompose the method signature into a format that is acceptable to the debugger and pass that information to the debugger. This solution is tedious and also only works if the object models make the data public and provide mechanisms for the entity data to actually be requested. When the data is actually private or the object model does not expose a way of accessing that data a client may not be able to correlate these models at all.

Various technologies and techniques are disclosed for providing a framework with a common set of domain specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model specific object instances. A particular model specific object instance of a particular one of the object models can be retrieved using a common set of domain specific entity identifier types. An instance of a particular domain specific entity identifier type can be retrieved from a corresponding one of the model specific object instances. One or more extensibility mechanisms allow third parties to extend the set of domain specific entity identifier types.

In one implementation an application programming interface is provided with an abstract entity identifier class with domain specific entity identifier types being required to derive from the abstract entity identifier class thereby allowing object models representing a conceptually similar entity to use the domain specific entity identifier types to correlate model specific object instances.

This Summary was provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

For the purposes of promoting an understanding of the principles of the invention reference will now be made to the embodiments illustrated in the drawings and specific language will be used to describe the same. It will nevertheless be understood that no limitation of the scope is thereby intended. Any alterations and further modifications in the described embodiments and any further applications of the principles as described herein are contemplated as would normally occur to one skilled in the art.

The system may be described in the general context as a framework application that allows conceptually similar entities to be correlated but the system also serves other purposes in addition to these. In one implementation one or more of the techniques described herein can be implemented as features within a framework program such as MICROSOFT .NET Framework or from any other type of program or service that provides platforms for building applications. In another implementation one or more of the techniques described herein are implemented as features with other applications that deal with object models each having their own manner of referencing the same conceptual entity.

In one implementation a framework is provided that has application programming interfaces APIs for allowing conceptually similar entities to be correlated. The framework has a common set of domain specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model specific object instances. The term domain specific entity identifier types as used herein is meant to include identifiers implemented in an abstract class for the purpose of describing some conceptual entity in a particular domain. The term model specific object instance is meant to include an object instance obtained from some specific model instance. Take for example the scenario that was previously described in the background. Suppose there is a performance analysis tool that stores performance data over a period of time for a certain method object called Method A . Suppose also that there is a debugger that also stores debugging information for a certain method object called Method A . Suppose also that there is source code written using a software development program that contains the actual implementation for Method A . Each program uses its own model specific object instances for referring to the same conceptual entity called Method A . If some process wants to see the performance and debugger data for Method A the common set of domain specific entity identifier types can be used in order to correlate these object instances together in a meaningful fashion.

As shown in an exemplary computer system to use for implementing one or more parts of the system includes a computing device such as computing device . In its most basic configuration computing device typically includes at least one processing unit and memory . Depending on the exact configuration and type of computing device memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line .

Additionally device may also have additional features functionality. For example device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and need not be discussed at length here. In one implementation computing device includes framework application . Framework application will be described in further detail in .

Turning now to with continued reference to a framework application operating on computing device is illustrated. Framework application is one of the application programs that reside on computing device . However it will be understood that framework application can alternatively or additionally be embodied as computer executable instructions on one or more computers and or in different variations than shown on . Alternatively or additionally one or more parts of framework application can be part of system memory on other computers and or applications or other such variations as would occur to one in the computer software art.

Framework application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for providing a framework with a common set of domain specific entity identifier types that a plurality of object models representing a conceptually similar entity can use to correlate model specific object instances logic for providing one or more extensibility mechanisms to allow third parties to extend the set of domain specific entity identifiers types logic for enabling the domain specific entity identifier types to be extended by allowing one or more model specific object instances to be provided for one or more domain specific entity identifier types that a particular one or more of the object models did not originally support logic for enabling the domain specific entity identifier types to be extended by allowing one or more domain specific entity identifier types to be provided for model specific object instances that a particular one or more of the object models did not originally support and other logic for operating the application . In one implementation program logic is operable to be called programmatically from another program such as using a single call to a procedure in program logic .

Turning now to with continued reference to the stages for implementing one or more implementations of framework application are described in further detail. is a high level process flow diagram for framework application . In one form the process of is at least partially implemented in the operating logic of computing device . The process begins at start point with providing a framework with a common set of domain specific entity identifier types unique or non unique that object models representing conceptually similar entities from a domain can use to correlate to model specific object instances stage . The framework allows a particular model specific object instance of a particular one of the object models to be retrieved using a common set of domain specific entity identifier types stage . In one implementation the correlation using the identifier types is independent of the model specific object instance types stage . An instance of a particular domain specific entity identifier type can be retrieved from a corresponding one of the model specific object instances stage . The process ends at end point .

In one implementation all entity identifier classes derive from this common ModelIdentifier abstract base class. They typically offer additional data that a client can specify at instantiation time. Object models typically access these data through public properties exposed by those subclasses.

An entity identifier is a domain specific symbolic reference that can be applied to multiple models sharing a set of related entity identifier types sometimes called an ontology. On the other hand a model handle is a soft reference to a single model specific object instance. The model handle abstraction permits tools to refer to entities in other object models in a uniform way. It can also avoid holding any model specific data objects. When the tool wants to interact with a model object it obtains it by de referencing the handle.

One implementation of IHandleModelService aggregates all instances of ModelHandleFactory on and ModelIdentifierFactory on and delegates client requests to the appropriate one. Implementations of IModel that do not understand a particular entity identifier are expected to invoke IHandleModelService thereby allowing third parties to extend them.

The IHandleModelService implementation aggregates all ModelHandleFactory instances. When it receives a request for a model handle it chooses the appropriate one based on the metadata listed above. It then delegates control to this factory to produce the requested model handle.

The IHandleModelService implementation aggregates all ModelIdentifierFactory instances. When it receives a request for an entity identifier it chooses the appropriate one based on the metadata listed above. It then delegates control to this factory to produce the requested entity identifier.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. All equivalents changes and modifications that come within the spirit of the implementations as described herein and or by the following claims are desired to be protected.

For example a person of ordinary skill in the computer software art will recognize that the client and or server arrangements user interface screen content and or data layouts as described in the examples discussed herein could be organized differently on one or more computers to include fewer or additional options or features than as portrayed in the examples.

