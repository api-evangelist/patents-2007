---

title: Analyzing wait states in a data processing system
abstract: A computer implemented method, apparatus, and computer usable program code for collecting information about threads. A thread entering a wait state is detected. Information is selectively obtained about a set of threads in the wait state using a policy to produce an action in response to the thread entering the wait state. A history containing the collected data may be saved and used to determine changes to patterns.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323578&OS=09323578&RS=09323578
owner: International Business Machines Corporation
number: 09323578
owner_city: Armonk
owner_country: US
publication_date: 20070529
---
This application is a continuation in part application of U.S. application Ser. No. 11 335 798 filed Jan. 19 2006 now U.S. Pat. No. 7 474 991 and is a continuation in part application of U.S. application Ser. No. 11 420 068 filed May 24 2006.

The present invention relates generally to an improved data processing system and in particular to a method and apparatus for processing data. Still more particularly the present invention relates to a computer implemented method apparatus and computer usable program code for analyzing the performance of a data processing system.

In designing and writing code for applications one objective is for the application to scale well when more than one processor is used. A complex application such as WebSphere Application Server may support many different transactions. It is important that this application be able to take advantage of multiple threads and multiple processors. When the work load increases an application that scales well should be able to take advantage of multiple processors and have better performance than when only a single processor is available. If the application does not scale well then the availability of additional processors does not necessarily improve performance. In fact the availability of additional processors may actually degrade performance.

Currently determining why an application does not scale well is often a very difficult problem. One aspect of understanding the scaling of applications is to determine what threads are waiting to execute and why they are waiting to execute. This type of data may help determine the flow between different threads such as Java threads. A thread may wait for a requested operation or function to be completed. For example a thread or routine may request data to be read from a storage device. This thread or routine is placed into a waiting mode until the operation to return data is completed. Waiting occurs for any type of input output I O in these examples.

Currently this type of information is obtained by generating notifications or calls for all wait and notification mechanisms used in a particular environment. This type of notification also is considered too invasive. Again the code to make the callout receive the callout and make the determination of importance may include much more than the code that processes the event. This type of perturbation affects the value of profiling and analyzing applications.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for collecting information about threads. A thread entering a wait state is detected. Information is selectively obtained about a set of threads in the wait state using a policy in response to the thread entering the wait state.

The policy may specify obtaining information about a thread of interest in the set of threads if a number of threads in the set of threads exceeds a threshold when the thread enters the wait state. The policy may specify obtaining information about the set of threads if the number of threads in the set of threads exceeds a threshold when the thread enters the wait state. The policy also may specify obtaining information about the set of threads if a processor is in an idle state when the thread enters the wait state.

Call stack information may be obtained about a thread of interest in the set of threads in the wait state using the policy. A reason may be obtained as to why the thread of interest in the set of threads is in the wait state using the policy. A reason also may be obtained as to why a thread of interest in the set of threads entered the wait state using the policy. The information about the set of threads may be analyzed to identify a pattern for a reason why threads are in the wait state.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . Clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub NB MCH and a south bridge and input output I O controller hub SB ICH . Processing unit main memory and graphics processor are coupled to north bridge and memory controller hub . Processing unit may contain one or more processors and even may be implemented using one or more heterogeneous processor systems. Graphics processor may be coupled to the NB MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB and other ports and PCI PCIe devices are coupled to south bridge and I O controller hub through bus and hard disk drive HDD and CD ROM are coupled to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to south bridge and I O controller hub .

An operating system runs on processing unit and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processing unit . The processes of the illustrative embodiments may be performed by processing unit using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

The hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is generally configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

With reference now to a block diagram illustrating the relationship of software components operating within a computer system that may implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. JVM is one software application that may execute in conjunction with the operating system. JVM provides a Java run time environment with the ability to execute a Java application or applet which is a program servlet or software component written in the Java programming language. The computer system in which JVM operates may be similar to data processing system in or computer in described above. However JVM may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the JVM which supports all aspects of Java s environment including its architecture security features mobility across networks and platform independence.

The JVM is a virtual computer i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.

The JVM is the name of a virtual computer component that actually executes Java programs. Java programs may not be run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code is executable on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just in time compiler or JIT.

A JVM loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM. The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes but JVMs may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for collecting information on wait states occurring during execution of a program. In the illustrative embodiments filter criteria are identified in which the criteria identified are associated with a wait state. A determination is made as to whether the filtering criteria are met when a set of requesters is in a wait state. This set of requesters may be one or more requesters depending on the particular implementation. Information about a requester in this set of requesters is collected in response to determining that the filter criteria have been met.

In these examples a wait state is a state in which a set of one or more requesters are waiting for some event to occur. This event may be for example waiting for ownership of a monitor to access a resource controlled or associated with a monitor. In these examples the resource is a method that is accessed by the requester. The wait state also may occur for example when a set of one or more requesters is waiting for an operation to occur or complete. The operation in these examples is the completion of an input output I O request.

The different illustrative embodiments provide a computer implemented method apparatus and computer usable program code for collecting stack information when threads entering a wait state meet some policy. This policy may be for example a specified number of threads entering the wait state or some particular thread of interest entering a wait state. In the illustrative examples a reason why a thread enters a wait state may be obtained. In these examples this reason is identified through a reason code that may be obtained through the operating environment. This operating environment may be an operating system or a Java virtual machine. These reason codes may be used to identify a pattern as to why threads enter a wait state. This information may be analyzed and presented through the generation of reports.

With reference now to a diagram illustrating components used to collect information about the execution of threads is depicted in accordance with an illustrative embodiment. Profiling program may be used to collect data such as wait state data and idle state data . The collection of this information by profiling program may be triggered based on threads entering a wait state that meets policy .

Policy is a set of one or more rules that identify when information about a thread should be collected. For example policy may state that wait state data should be collected when the number of threads entering a wait state exceeds a threshold level. Policy also may contain a rule that causes the collection of wait state data and idle state data when a thread having a particular identifier enters a wait state. Yet another rule may specify that wait state data is collected if any thread associated with a process having a particular identifier enters a wait state.

Policy also may specify that wait state data is gathered only when a processor enters an idle state in addition to threads entering an idle state. This determination as to whether a processor enters an idle state may be identified through idle state data . Further idle state data may provide information such as a trace to be used to determine how long a thread in a wait state has been in the wait state. Further idle state data also may be used to determine when a thread entered the wait state and exited the wait state.

In these illustrative examples profiling program may gather wait state data and idle state data directly. Alternatively profiling program may generate sampling daemon to gather this state data. History contains wait state data and idle state data from prior periods of time. This data may be for a particular job or jobs that were previously run. Wait state data and idle state data collected by profiling program may be compared to the data in history to see if patterns can be found or if variances from patterns occur in analyzing why threads enter wait states.

Thereafter profiling program may generate report . Report may take various forms such as an arc flow report. Another example is a graph identifying threads and when particular threads are in a wait state during different periods of time.

Policy may state that for a particular thread entering a wait state data should be collected for that thread every five seconds.

Turning now to a diagram illustrating components used to collect information from a monitor in accordance with an illustrative embodiment. In these examples requesters and request access to resource . Resource is associated with monitor . In this example requesters and take the form of threads and resource is a method accessed through monitor . Requests include any operation or service that is not being performed synchronously such as a database query or a credit card verification request. These services may be on the same machine or on a different machine. In a Java Virtual Machine JVM thread library is the component that schedules the thread that is waiting on a service. In an operating system the operating system itself typically the scheduler handles the dispatching of the threads that are waiting on a service.

Monitor provides serial access to resource . In other words monitor only allows one requester to use resource at a particular time. For example if requester requests access to resource monitor provides that access if no other requester is currently using resource . In this case requester is said to own monitor . Thus if requester requests access to resource monitor does not allow access. Requester is called a contending requester. In other words monitor locks resource for use by requester .

When requester releases resource monitor then allows requester to take ownership of monitor to access resource . Monitor may maintain a list of requesters waiting to access resource in queue . Selecting which requester should own a monitor from a group of contended requesters may be performed using any type of priority or selection scheme desired. For example a first in first out priority scheme may be employed.

In these examples the requests are sent to monitor through thread library . Thread library is a component in a Java Virtual Machine that works with threads executing in the environment. This particular component provides functions such as scheduling locking infrastructure placing threads in a wait state that wait for resources and other functions involving threads.

The illustrative embodiments include processes in thread library that are used to identify the presence of a wait state and filter criteria associated with the wait state. This filter criteria is used to determine whether a set of one or more requesters in a wait state meet the filter criteria. When these criteria are met information about one or more of the requesters in the set of requesters is collected. In this particular example an ability to identify specific monitors or locks for call outs or other actions is provided in thread library . Thread library allows for monitors of interest to be selected for call outs or other actions.

The selection of monitors may be made through user input stored in policy . In these examples policy is a set of rules and data used to determine when to collect data when a wait state is present. In addition to identifying monitors of interest policy also includes filter criteria that are to be met before an action is taken. Policy also may define what type of data is to be collected and from what requesters or processes associated with the wait states. In this example requester and requester are associated with the wait state. Requester owns monitor and uses resource while requester is a contended requester waiting to obtain ownership of monitor .

These criteria may be defined through user input. These filter criteria may take various forms. For example thresholds may be used to specify the minimum number of contended threads before taking action. Alternatively the threshold may identify a maximum number contended requesters after which no further notifications are made. These contended threads are requesters waiting to access resource in these examples. In this example monitor is the monitor selected for sampling of call outs.

Another example of filter criteria that may be specified includes selecting by thread name thread group or monitor identifiers. In this manner if a particular thread having a selected name that is stored in policy is waiting for access to resource an action such as a call out may be made. A call out is a call that is made to a program such as profiling program . Additionally if the thread having the selected name in policy is using the particular resource a call out also may be made. The specified criteria may include other occurrence thresholds such as generating a call every ten times monitor is requested.

The criteria contained within policy may be selected or designated by a user through graphical user interface GUI in these examples. Graphical user interface also may provide a presentation of information relating to the code being executed to facilitate the selection of filter criteria.

For example GUI may present displays of threads that are being executed. From this display a user may select one or more threads to form filter criteria as described above. As another alternative GUI may display monitors that are present for the execution of the code. From this display the user may select one or more monitors as monitors of interest for which data is to be collected when different criteria are met.

Additionally GUI also may display actual code lines or modules or sections within the code being executed to allow the user to select portions of the code to form filter criteria. GUI also may display areas of the code in which execution is occurring as well as information as to how often particular portions of code are executed to allow the user to select portions of code for monitoring.

In these examples when the filter criteria are met an action is initiated or taken. More specifically thread library generates a call to profiling program . This call may identify the requester currently using resource as well as the current requester or all requesters that are waiting to use resource . With this information profiling program may collect information such as call stacks using interface . A call stack is a list of frames in which the first frame is the top most frame in the stack. In these examples each frame typically contains the method jmethodID identification of the method entered and possibly the byte code if being executed interpretively. Additional information may be available such as a program counter and a byte coded body method a table associating variable names with values a stack and a synchronization flag indicating whether the method currently executing is synchronized. A call stack identifying each method called for the waiting threads may be recorded in a tree in which the tree indicates the number of occurrences of this particular stack. This indication is made in these examples by incrementing a counter at the leaf node of the stack.

In these examples interface is a Java Virtual Machine Tools Interface JVMTI . This interface allows for the collection of call stack information. Call stacks may be for example standard trees containing count usage for different threads or methods. The Java virtual machine tool interface is an interface that is available in Java 2 software development kit SDK version 1.5.0. The Java virtual machine profiling interface JVMPI is available in Java 2 platform standard edition J2SE SDK version 1.5.0. These two interfaces allow processes or threads to obtain information from the Java virtual machine in the form of a tool interface to the Java virtual machine. Either interface or any other interface to a Java virtual machine may be used to obtain call stack information for one or more threads. Further these interfaces may be used to obtain reasons as to why the thread is in a wait state. In these examples the reasons are returned as reason codes by interface .

Alternatively call stacks may be separate stacks and include timestamps that are useful for monitor analysis. Further arcflow reports also may be generated on selected monitors and conditions in this sampling. Arcflow is a model for recording and reporting resource consumption for a broad range of performance data and analysis questions. The resources include for example interpreter cycles heap objects allocated heap byte allocated JITed code instructions executed and objects of different classes. These and other resources of interest may be used by consumers such as for example a thread an object an interpreted method a system call and a JITed method. Arcflow collects performance data which may be for example sampled data counter data or some other type of data of interest. This collected data is stored in a trace file and reports are generated from the trace file. This model is used to capture the relationships between consumers and resources.

An arcflow report may include information identifying performance data such as the number of occurrences or calls made and the resource consumption or processor time taken. This type of information is associated with the consumer or object requesting the particular resource. In these examples the consumer is the method. Arcflow reports also may include other information such as a percentage of the total consumption time rather than what is actually used by the particular consumer.

When this information is collected by profiling program the information is stored as profiling data for analysis. Profiling program may generate arcflow reports for analysis. In particular this analysis may yield results that allow a better understanding as to why a program does not scale well.

In these examples the selected action is a call to profiling program . Of course other actions may be taken depending on the particular implementation. For example thread library may directly retrieve call stacks rather than calling profiling program . By collecting statistics such as the typical wait time for a specific service thread library may adjust its scheduling algorithm to check for rescheduling only after some minimum time has occurred. When the call out occurs due to a notification support is present for a reason code that identifies the cause of the notification. In these examples reason codes are used. Reason codes could include for example timeout or disk I O completed. This information allows for the collection of statistics to help with the identification of patterns. With this information profiling program may collect information such as call stacks using interface . For example if the application is trying to monitor traffic patterns as a function of day time to adjust traffic light changes where sensors detect specific conditions collecting the posting reason data allows for better understanding of why there are flow problems. Further the depth of a thread s call stack may be used as additional criteria for making the call out.

Profiling program identifies where a program spends time during execution. This type of information may be used to discover how a program uses memory what types of objects are used and how many objects are used.

In these examples the processes used to select monitors for sampling as well as the criteria needed to trigger the sampling are implemented within thread library . Of course these processes could be implemented in other components in addition to or in place of thread library .

Another example of comparing filter criteria to a wait state involves requesters that have requested an operation such as an I O operation.

Turning now to a diagram illustrating components in generating an action in response to criteria being met while one or more requesters are waiting for a notification is depicted in accordance with an illustrative embodiment. In this example one or more of requesters and have requested operation to be performed through thread library . In these examples operation is an I O operation such as a request to read data from disk.

Notification mechanism in thread library is used to notify requesters and when operation has completed. Although these examples show requesters and requesting the same operation the embodiments may be applied to different operations. Further any operation may be used in the illustrative embodiments. Notification mechanism notifies a requester such as requester that operation has completed.

Notification mechanism in these examples includes a lock with a work area for waiting routines. The work area includes information on the status owner number of requests a semaphore and other information. Notification mechanism monitors waiting requesters. In particular notification mechanism looks at a semaphore status to see if waiting requesters are present. A semaphore is a protected variable or abstract data type and constitutes the classic method for restricting access to shared resources for example storage in a multiprogramming environment. An implementation of a semaphore allows for a mechanism to indicate a status of some activity and could take the form a shared space or variable to allow for inter process communications. In these examples the semaphore should be considered a shared memory area that includes or has a pointer to information regarding the criteria for making a callout or for performing an operation related to the semaphore.

Additionally in these examples notification mechanism is a component in which the processes of the illustrative embodiments may be implemented. Of course these processes may be implemented in other components in place or in addition to notification mechanism . In this particular example of an illustrative embodiment notification mechanism also determines when an action will be initiated for wait state for a set of one or more requesters waiting for an operation to complete. In these examples notification mechanism is a new mechanism that is used to notify or initiate an action.

In this embodiment notification mechanism uses policy to initiate the action. Policy contains the filter criteria used to determine when and what actions to take in these examples. Additionally policy may specify what operations are the ones for which information will be collected in addition to when or under what conditions information will be collected. The identification of the filter criteria is stored within policy in these examples. In an illustrative embodiment when a semaphore is initialized a determination is made using policy as to whether the semaphore is a selected semaphore for additional monitoring. If the semaphore is identified for additional monitoring then an additional semaphore work area is allocated to contain the selection criteria. When the semaphore is owned or requested a determination is made whether there are any additional criteria to be applied. In an alternative embodiment a simple flag or pointer may be used to point to the specific policy related to the specific semaphore.

These filter criteria may include for example thresholds that specify the minimum number of waiting threads before activating notification mechanism for contended requesters. Also there may be specified a maximum number of contended requesters which when met indicate that no further processing takes place until the number of waiting threads is below the specified maximum. This maximum restriction is especially helpful when there is a call out that identifies all the requesters. In another example a call out is made when the number of requesters exceeds a previous maximum by a specified granularity. For example a call out is made or an operation is performed when number of waiting threads is 10 or has increased by 10.

Additionally policy may include identification by thread name thread group or some other identifier as to when notification mechanism is to be activated. In addition time thresholds between start wait notify events generated by thread library also may be used to determine when notification mechanism is to be activated.

In these examples GUI may be used to present information to the user and allow the user to select filter criteria described above.

When the filter criteria stored in policy are met notification mechanism performs a selected action such as generating a call to profiling program . Profiling program is an example of profiling program such as profiling program in . Other actions include for example collecting one or more call stacks to identify the calling sequence for the criteria for the sequence that has been met.

In these examples profiling program collects data and stores this data as profiling data for later use. In this depicted example thread library generates a call out to profiling program that includes the notifying thread and notified threads to allow profiling program to collect information such as call stacks through interface . In these illustrative embodiments interface is a Java Virtual Machine Profiling Interface JVMPI or a Java Virtual Machine Tools Interface JVMTI . Call stacks may take the form of standard trees with count usage or may be separate stacks that include timestamps for monitor analysis.

Additionally when a call out is generated a reason code may be added to identify the cause of the notification. The reason code would be generated by the threading component using policy . Thread library would typically determine if the operation did not occur in a specified time. This determination is usually performed by specifying a timeout on the semaphore request. The call out to the profiler would typically be performed by a separate component such as the JVMTI component.

Alternatively another component including a native operating system may have generated the reason code. Thread library would need to pass on or translate the reason code generated by the component that detected the condition. These reason codes may include for example a timeout has occurred disk I O has been completed or a disk write has completed. Whether a monitor is one selected for monitoring is determined using a policy such as policy . This type of information may be used with the collection of statistics to identify patterns of operations. For example if an application monitoring for traffic patterns as a function of day time may adjust traffic light changes or sensors to detect specific conditions. The collection of reason codes may allow for a better understanding of why flow problems may occur for this system.

These illustrative embodiments provide a computer implemented method apparatus and computer usable program product for collecting data on idle states occurring during execution of code in a data processing system. In these examples the aspects of the present invention analyze the transition and process states and collect idle counts during the execution of the code to form collected idle counts. This collecting of idle counts includes collecting information for a system having a transition between an idle state and a non idle state. This system information may be information about a thread. The aspects of the present invention identify on a per processor and per thread basis the number of idle states intervals occurring for individual processors and all processors.

Additionally the per thread information identifies a number of dispatches from running to idle state and from idle state to running. Additionally the total number of dispatches for the current processor and total number of idle dispatches for all processors are identified. Different embodiments allow for the association of idle information with entry exit trees used to track execution of threads. On any entry or exit event idle information may be applied to a node in these examples. Additionally when nodes in a tree are constructed a unique node address is added for each node to allow correlation of the context with the trace records. Alternatively any unique node identifier may be used to provide a correlation between nodes and trace records. This unique node address is also written to a shared thread work area as entries and exits are processed. This node address may also be written into a trace record by a device driver. In this manner reports may be generated for various idle related events.

Turning now to a diagram illustrating components used to identify idle states during processing is depicted in accordance with an illustrative embodiment. In this depicted example the components are examples of hardware and software components found in a data processing system such as data processing system in .

Processor generates interrupt and operating system generates call . Call is identified and processed by device driver . In these examples the call is generated by a presently used operating system dispatcher located in operating system . This dispatcher is hooked or modified to generate a call or a branch to device driver when an event of interest occurs. When call is received from operating system device driver determines whether the dispatch is directed towards an idle processor thread or to a processor thread that is not idle in threads . Device driver updates state information for processor and performs operations such as accumulating counts and writing records in to trace . Device driver saves state information in data area and returns control back to the dispatch routine within operating system .

Device driver receives call through hooks in these examples. A hook is a break point or callout that is used to call or transfer control to a routine or function for additional processing such as determining idleness occurring during execution in these examples.

In these illustrative examples device driver increments counters for processors in which idle states occur to indicate the number of times a processor is idle during execution in state information . Device driver writes counts or state information which is accessible by application . Device driver writes or increments a counter each time the idle thread is dispatched at either the entry from the dispatch to the idle thread or the exit from the idle thread to the dispatch and copies or accumulates this information for a thread into an area accessible by the thread. At each entry or exit application records the current count for the number of idle states and compares this to a last count for the number of idle states for a particular thread. The difference between the two counts is accumulated into the current node in tree .

Further in these illustrative examples device driver may include reason codes within state information . These reason codes may be received from the operating environment such as operating system . Some operating systems provide reason codes to identify why threads are not executing. Device driver receives this information from operating system within call in these examples. Depending on the implementation operating system may provide the reason code information directly to the called routine about the thread or threads involved in the dispatch. In these examples the called routine is device driver . In other implementations the called routine could be a profiling program. Operating system may pass a reason code for either the thread that was dispatched from the thread that was dispatched to or both. Alternatively operating system may provide interfaces for device driver to query the state of a thread or threads.

In these illustrative examples the state information includes a count of the number of times that the operating system has dispatched to or from the idle thread. The counts are made on a per processor basis. Additionally an overall count for all the processors also may be maintained. These counts are maintained by device driver in these examples. This information may be collected by application to generate report regarding idle states of processor . Application may access data area to process information and record information in tree .

Application is an application that is event based for example the application receives a call out on any entry or exit to a routine. For Java it may use the Java Virtual Machine Profiling Interface JVMPI requesting entry exit notification. For C programs it may request hooking by the compiler at function entry and exits. In this application any reference to method may also be applicable to a function. Tree is constructed as entries and exits are processed. The aspects of the present invention store the number of idle states that have occurred in nodes within tree .

A count of the number of times that the thread for a processor has gone into an idle state is accumulated in a current node. The current node is the node for the method that has been entered into in executing the thread. When a method is entered the current idle count is identified. When the method is exited or another method is entered the new idle count is identified. The difference between the base of current idle counts and the new idle count is accumulated into the current node in tree . When the node is created a unique identifier is also placed in the node. When entries or exits are processed the node identifier for the current node being processed may be written by the application to a shared work area that is also accessible by a device driver. This unique identifier may be associated with or used to identify this node for correlation with other trace information in these illustrative examples.

In an alternative embodiment each time a dispatch occurs in which a thread with a unique identifier is dispatched with a change from its idle count device driver also generates a trace record for placement into trace . This particular trace record contains an identification of the current node address at the time of the interrupt. This node address is the unique identifier in these examples. This current node address is placed into trace along with idle counts.

As a result application may access nodes within tree and trace to generate report . The combination of the information from trace and tree provide idle information needed to analyze and determine why processors become idle during execution of code. In these illustrative examples report contains information as to when processors are idle with respect to execution of threads . Additionally data area also includes blocked thread statistics table . Blocked thread statistics table includes various information about threads that are in a wait state. These threads are ones that have been blocked from executing for one reason or another. Blocked thread statistics table may include information such as for example total runtime number of timeslices since last sample maximum timeslice value and yield count from last sample. These statistics are stored in a data structure such as a table in these examples.

In this illustrative example only a single processor is illustrated. The aspects of the present invention may be applied to multi processor systems in which two or more processors are present. In these types of systems a counter may be assigned to each processor as well as a counter for the overall number of times that idle states have occurred in all of the processors within the data processing system.

Turning to a diagram illustrating state information is depicted in accordance with an illustrative embodiment. In this example state information is an example of state information in . State information contains processor area and thread communication area .

In this example process area contains the number of idle dispatches for each processor. As depicted process area contains idle dispatch information for processors and . Thread communication area contains information for individual threads. The information in thread communication area may be accessed by the application and by the device driver. This area could be for example shared memory or specific requests to read or write to the area. In this example thread communication area contains state information for threads and . Each of these sections in thread communication area contains information that may include any or all of the following an identification of the processor last dispatched the number of idle dispatches on that processor at the time that the thread was last dispatched the total number of idle dispatches on all processors at the time the thread was dispatched the total number of dispatches while on any specific processor and an identification of the node pNode. This identification may be the address of the node or any other unique identifier with the application s context. pNode may be written by the application as it processes entries and exits.

A call tree is constructed to identify all the functions or methods being called by any function or method. Each node in the call tree uniquely identifies a thread s call stack. For example in described below node C identifies the call stack A B C. The call tree is constructed by monitoring method functions entries and exits. This can be done in several different ways in C programs most modern compilers provide a function begin and function end label that can be utilized by an application program. This feature is usually provided by the compiler as a compiler option flag. In dynamic programs such as Java the architecture usually provides the ability to hook into code execution Java virtual machine profiler interface JVMPI or its replacement the Java virtual machine tools interface JVMTI sending an event on method entry and exit to monitor code. Using either of these methods as well as others it is possible to create the program s call tree as code execution is processed. For more information about constructing call trees and applying base time or metric such as idle counts refer to IBM Systems Journal Vol. 39 Nov. 1 2000 pgs. 118 134 A unifying approach to performance analysis in the Java environment. 

This call tree can be stored in trace in or as a separate file that can be merged in by application in . Application in can use this call tree to provide the application s path as it goes into an idle state.

Turning to a diagram of a tree is depicted in accordance with an illustrative embodiment. Tree is an example of tree in . Tree is accessed and modified by an application such as application in . In this example tree contains nodes and . Node represents an entry into method A node represents an entry into method B and nodes and represent entries into method C and D respectively. These nodes are created during entries and exits into various methods by threads. In the illustrative examples each of these nodes is associated with a unique node identifier which is then written into a trace such as trace in . The unique node identifier in these examples is the address of the node in memory. The information in these nodes also allow for retrieval of call stack information. The tree s node identifies the path to the node. For example node is labeled D . This node s call stack is A B D.

Turning now to a diagram illustrating information in a node is depicted in accordance with an illustrative embodiment. Entry is an example of information in a node such as node in . In this example entry contains method function identifier tree level LV calls callees CEE base maximum amount of BASE time for any one event MMAX allocated objects AO allocated bytes AB Dispatches to idle DIP Idle counts for all processors and node identifier pNode .

Entry also contains idle counts for all processors and idle counts on a processor . The information within entry is information that may be generated for a node within a tree. For example method function identifier contains the name of the method or function. Tree level LV identifies the tree level of the particular node within the tree. For example with reference back to if entry is for node in tree level would indicate that this node is a root node.

Calls indicates the number of calls made to the particular method. Base identifies the accumulated time on the method. The accumulated time is often stored in terms of numbers of instructions or cycles. Maximum time MMAX for any one event identifies the maximum time that occurs for a particular event. Allocated objects AO identifies the number of objects allocated to the method and allocated bytes AB identifies the number of bytes allocated by the method. A unique identifier for the node in this case the address or pointer to node identifier may be written in the Node at the time the node is created. In addition node identifier may be provided to the device driver in a preferred embodiment by writing the currently active pNode at entries and exits to a data area shared between the device driver and the application.

In addition the illustrative embodiments include other information used to determine why a particular processor is idle during certain periods of time when executing code. For example node identifier is employed such that trace records may be merged with information in the different nodes of a tree. This node identifier is an address of the node within memory in these examples. Idle count identifies the total number of times that any processor was idle while the method was executing. Dispatches to idle DIP consists of the number of dispatches to idle on the same processor as the method was last running. Other counts and approaches could be used for example count only dispatches from the thread to idle or count only dispatches from idle to the thread.

Turning to a diagram illustrating a trace record is depicted in accordance with an illustrative embodiment. In this example trace record is an example of a trace record within trace in . Trace record contains time stamp current node address and idle counts . Trace record is generated when there is a dispatch to or a dispatch from a thread that contains a pNode and there is also a change of idle counts from those in the thread work area and those maintained by the device driver. This record may be correlated to a call tree such as tree in . The correlation of this information with information within a tree showing entries into and exits from methods provides an ability to recover both the thread and the complete call stacks with the address of the current tree node found in current node address .

Time stamp indicated when the particular event occurred. Additionally idle counts indicates changes or count relating to dispatches to or from idle for the processor on which the thread had last been dispatched or the total number of idle counts for all processors or the number of dispatches to idle from the thread or the number of dispatches from idle to the thread. The information may be compressed by providing indications of what has changed and including only the change information. Current node address corresponds to the information stored in node identifier in .

With reference now to a diagram illustrating an entry in a table for maintaining statistics is depicted in accordance with an illustrative embodiment. Entry is an example of an entry in a table or data structure such as information found in block thread statistics table in . Entry is an example of information that may be written by a device driver such as device driver in .

In this example entry includes process identifier PID thread identifier TID runnable state monitor thread runnable vs. non runnable state number of times in a non runnable state number of timeslices since last sample total runtime and maximum timeslice value .

Process identifier PID identifies the process to which a particular thread is associated with. Thread identifier TID is used to identify a thread that has entered the wait state. Runnable versus non runnable state is a field in which identifies the current state of the thread. A runnable state is a state in which a thread can execute but may be in a wait state because the timeslice has run out. A thread would not be in a runnable state if the thread is waiting on a lock or waiting for I O to complete.

Number of times in a non runnable state contains information identifying the number of times a thread has caused itself to enter a non runnable state. Number of timeslice since last sample is a field in which the number of times a thread has been dispatched to execute may be stored.

Total runtime is the total time that the thread has executed since being created. Maximum timeslice value identifies the longest execution time within a timeslice that a thread executed before being dispatched out or the amount of time a thread executed before a timeslice for the thread expired.

Of course other information also may be stored within entry depending on the particular implementation. The different information in these examples identifies different statistics that may be of interest and is used to determine why a thread was in a wait state. For example other information that could be kept in entry for the table might include identifying the amount of time the thread is in a runnable state versus the amount of time the thread is in a non runnable state. This information could be reflected as a percentage. Also if the device driver causes the sampling thread to be woken to collect sample data then the information may include information reflecting changes that have taken place from the last sample.

Turning now to a flowchart of a process for monitoring for a wait state is depicted in accordance with an illustrative embodiment. In this particular example the wait state is one that occurs when waiting for access to the resource or waiting for an operation to complete. The process illustrated in may be implemented in a component such as thread library in .

The process begins by monitoring for a wait state step . In this example the wait state may be any state in which a set of one or more requesters are waiting. For example the requesters may be waiting for access to the resource through a monitor or for an operation to complete. A determination is made as to whether the filter criteria are met for the wait state step . This filter criteria may simply be a determination that known selection criteria is specified and no further action is required. One illustrative implementation uses a flag or pointer in the semaphore itself to indicate if any criteria are present to check. If the filter criteria are met in step the process performs an action step with the process terminating thereafter. If the process determines the criteria were not met or no criteria specified in step the process returns to step to monitor for a wait state.

Turning now to a flowchart of a process for generating an action in response to filter criteria being met for a wait state is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a component such as thread library in .

The process begins by identifying a monitor step . Whether a monitor is one selected for monitoring is determined using a policy such as policy in . Then the process identifies filter criteria to be met for the monitor step and watches the monitor step . In this example the filter criteria are obtained by the thread library from a policy such as policy in . A determination is made as to whether the filter criteria are met for the wait state step . In step the wait state occurs with the presence of one or more requesters waiting for access to the monitor. If the filter criteria are met in step the process performs an action based on the criteria met step with the process terminating thereafter.

In this particular example the action is one such as a call to a profiling program when certain criteria are met with respect to a monitor of interest. If the process determines the filter criteria were not met in step the process returns to step to watch the monitor.

Turning now to a flowchart of a process for initiating an action when filter criteria are met during a wait state is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a component such as thread library in .

The process begins by identifying a set of one or more waiting requesters step . The requesters are processes or routines that have requested an input output I O operation in these examples. The requesters wait until the I O operation has completed. These requesters are notified by a notification mechanism such as notification mechanism in when the operation has completed.

Then the process identifies filter criteria for notification step . These filter criteria may be for example 10 requesters are present or a timeout period has passed. The process then determines if the set of waiting requesters meet the filter criteria step . If the waiting resources meet the filter criteria in step the process performs an action based on those criteria step with the process terminating thereafter.

Turning back to the determination made in step if the waiting resources do not meet the filter criteria the process returns to step and continues to identify filter criteria for notification.

Next is a flowchart of a process for generating a call out with a reason code in accordance with an illustrative embodiment. The process in is a more detailed description of step in .

The process begins by identifying a reason code for notification step . In the illustrative embodiments the reason code takes a form or format that is usable by the program that is called. The process then places the reason code in a call step . Finally a call is made to a profiling program step with the process terminating thereafter.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for collecting information relating to requesters in a wait state. Filter criteria associated with a wait state are identified. A determination is made as to whether the wait state is met when a set of requesters is in the wait state. In response to the filter criteria being met information about one or more requesters is collected. This information may be used to identify reasons as to why the different wait states are occurring.

Turning to a flowchart of a processor for incrementing counters for threads in an idle state is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a device driver such as device driver in .

The process begins by monitoring threads step . A determination is made as to whether a thread is switching from an idle state step . This determination may be made by a device driver in response to dispatches occurring during execution of code by a processor. If the thread is switching from an idle state the processor associated with the thread is identified step . The process then increments the counter for the identified processor step . The process then proceeds to update the thread data area with idle counts step . These idle counts may include the specific processor idle counts or idle counts for all processors or any other idle count as described in this application. Then the process proceeds to step as described above. Step is described in more detail in the description of below.

With reference again to step if the thread is not switching from an idle state the process proceeds to step as described above.

Turning now to a flowchart of a process for monitoring an active thread is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in an application such as application in . The application monitors a thread that is active using this process to update counts in a node when a thread enters or exits a method.

The process begins by identifying last idle counts step which could be kept in its thread node. Thereafter the process monitors the thread for entries and exits into methods step . A determination is made as to whether an entry or exit has been detected step . If an entry or exit into a method is not detected the process returns to step to continue to monitor the thread.

Otherwise the process identifies the current idle count step . The current idle counts are identified from counters present in a work area such as data area in . These counts may be any of the counts being maintained in the thread work area by the device driver for example it could be the dispatch to idle count for a particular processor on which the thread had been executing or it could be the counts of all dispatches to idle for all processors. A determination is made as to whether a difference is present between the base count and the current idle count step . If a difference is present the process updates the current node with the difference between the two counts step with the process then returning to step . With reference again to step if a difference is not present the process also returns to step without updating any of the nodes or it could add the difference of zero.

Turning now to a flowchart of a process for combining trace records with nodes in a tree is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in an application such as application in . This process is used to combine trace records with trees. The correlating or associating of information in a tree may involve for example writing the information into the node or creating a new node depending on the particular implementation. The combining of trace records as described in may occur on different data processing systems. For example the data may be captured from an embedded device or remote data processing system. This information may be collected and combined at another data processing system for analysis.

The process begins by selecting a trace record for processing step . A determination is made as to whether the trace record has an address to a node step . If the trace record has an address to a node the node is located in the tree using the node address step . The process then associates the trace record with the tree node step . Step may be implemented by placing the information from the trace record into the tree node. Alternatively a new node may be created. Thereafter a determination is made as to whether additional unprocessed trace records are present step . If additional unprocessed trace records are present the process returns to step . Otherwise the process terminates.

With reference again to step if the trace record does not have an address to a node the process proceeds to step as described above. In this manner information may be combined from trace records identifying idle counts with a tree constructed by processing entries and exits. By correlating the idle count or event information with this tree an analysis may be made as to why a processor is idle during certain points of execution.

With reference now to a flowchart of a process for handling dispatching from an idle thread is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a device driver such as device driver in . In particular is a more detailed description of step in . This figure describes a single dispatch in these examples.

The process begins when a thread is dispatched and a determination is made if the dispatch is from idle step If the dispatch is from idle then the process continues by incrementing the number of idle dispatches for the processor step . In any case the process continues by making a determination as to whether the dispatch is to a thread of interest step . The thread of interest may be any thread or a particular thread that has been identified for monitoring. If the dispatch is not to a thread of interest in step the process terminates. Otherwise a determination is made as to whether the thread of interest was last dispatched to the current processor step .

If the thread of interest was last dispatched to the current processor the dispatch processor s idle delta is set equal to the new number of idle dispatches on that processor at the time the thread was dispatched minus the last number of idle dispatches for the processor step . The last processor dispatched and the last number of idle dispatches for the processor are available in the thread work area. The new number of idle dispatches on that processor are in the per processor work area.

The change of values are placed or accumulated in the thread work area. If the last processor dispatched is not the current processor as specified in the thread work area then in a preferred embodiment the difference between the current value of the number of idle dispatches on the previous processor available in the per processor work area and the previous number of idle dispatches on the thread available in the thread work area may be added to the total number of dispatches on processor in the thread work area.

In this embodiment the total number of dispatches on the last dispatched processor is also kept in the thread work area. Then or later the thread work area is updated with the new processor and the new number of dispatches for that processor in the thread work area step . Thereafter the total dispatch delta is set equal to the sum of the number of idle dispatches for all processors minus the total number of idle dispatches on all processors at the time thread was dispatched step . In alternative embodiment the process proceeds directly to this step from step if the processor last dispatched is not the current processor. Next the process updates the processor last dispatched in the thread work area with the current processor step .

Then the number of idle dispatches on the processor at the time the thread was dispatched is updated with the number of idle dispatches for the processor step . Next the process updates the total number of idle dispatches on all processors at the time the thread was dispatched with the sum of the number of idle dispatches for all processors step . A determination is made as to whether the pNode is null step . The pNode is the address for a node on a tree used to trace entries into and exits from methods. This determination is made to see whether a node is present. If the pNode is null the process terminates. Otherwise a determination is made as to whether the dispatched idle delta or the total dispatched delta is not equal to zero step . If both are equal to zero the process terminates. Otherwise a trace record is written with the pNode and either the dispatch processor delta total dispatch delta or both values step with the process terminating thereafter.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program product for generating data for use in determining why a processor may be idle during execution of code. The different embodiments also allow for the occurrence of idle states in a processor to be correlated to other execution information such as methods being entered or exited and call stack information. With this combined information reports may be generated to analyze why a processor enters an idle state during execution and whether those idle states may be reduced by code optimization or changes.

Turning next to a flowchart of a process for collecting information about threads is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a software component such as device driver in . This process is initiated by a device driver in these examples each time a dispatch of a thread occurs.

The process begins by waiting for a thread to be dispatched to idle step . A thread of interest is then selected for processing step . In these examples a thread of interest may be identified by the device driver using an entry in a table such as entry in . In particular monitor thread in is an example of a field where an indication may be made as to whether a thread is a thread of interest.

Depending on the policy a single thread may be selected or multiple threads may be selected. As an example all threads associated with a particular process may be threads of interest. The number of times in a non runnable state for the thread is updated in a blocked thread statistics such as in blocked thread statistics table in . In particular a field such as number of times in a non runnable state in entry may be updated with the information obtained in step . Thereafter the total runtime is updated in the statistics thread step . This update may be made in total runtime in entry in .

Next a determination is made as to whether additional unprocessed threads of interest are present step . If additional threads of interest are present the process returns to step to select a thread of interest for processing.

If additional threads of interest are no longer present a determination is made as to whether a sample criteria has been met step . The sample criteria is defined using a policy in these examples. This policy may be for example policy in . The criteria in the policy may specify that when a certain number of threads have entered an idle state data regarding threads of interest should be collected.

Alternatively the criteria may state that if a particular thread of interest enters an idle state information should be collected from the blocked statistics that have been gathered. If the sample criteria has not been met the process returns to step to wait for another thread dispatch.

Otherwise the process wakes the sampling daemon step . In these examples this sampling daemon is a thread that is spawned or generated by a profiling program. The sampling daemon may be for example sampling daemon in . The process then waits for the sampling daemon to read data from the blocked thread statistics table step . After the sampling daemon has read the data from the blocked thread statistics table the process resets the yield count from the last sample the number of timeslices since the last sample the total runtime and the maximum timeslice value step with the process terminating thereafter.

Turning now to a flowchart of a process for determining whether sample criteria has been met is depicted in accordance with an illustrative embodiment. The process illustrated in is a more detailed example of step in . The criteria illustrated in this flowchart is an example of one set of criteria that may be implemented for determining whether sampling should occur.

The process begins by identifying a thread entering a wait state step . Thereafter a determination is made as to whether the thread is a thread of interest step . If the thread is a thread of interest a determination is made as to whether the processor has entered an idle state step . If a processor has entered an idle state an indication is made that the sample criteria has been met step with the process terminating thereafter.

With reference again to step if the processor is not entering an idle state an indication is made that the sample criteria has not been met step with the process terminating thereafter. With reference again to step if the thread is not a thread of interest the process also proceeds to step as described above.

In this manner the process illustrated in sets out an implementation of one policy that may be used to determine when to sample information. Alternatively step could be changed to make the determination as to whether the additional thread results in the number of threads in an idle state exceeding a threshold. Of course the process in will vary depending on the policy being implemented. As another example in some cases step may be omitted.

Turning next to a flowchart illustrating initialization performed for collecting statistics is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a thread such as sampling daemon in .

The process begins by setting control variables step . These control variables are different variables for which data is desired. The control variables are for various metrics such as for example time count and non runnable count. The time identifies a sample interval. The variable count identifies a count of yields between samples that are used to trigger a dump or collection of data. The non runnable count is an identification or number of threads that are non runnable. The process sends a device driver an identification of the threads of interest step with the process terminating thereafter. These threads of interest in these examples are identified using a policy such as policy in . The threads of interest are sent to the device driver so that the device driver will know when to collect data for different threads that execute.

Turning now to a flowchart of a process for collecting data is depicted in accordance with an illustrative embodiment. The process illustrated in is an example of a process that would be implemented in a software component such as sampling daemon in . This process is initiated when the sampling daemon is woken by the device driver.

The process begins by selecting an unprocessed thread of interest for processing step . This thread of interest is identified using a policy such as policy in . Thereafter the Java stack and the reason code for the selected code are copied step . This information may be obtained by the process through accessing a data area such as data area in . Alternatively or in addition the process may use an interface to a Java virtual machine such as interface in or interface in to obtain call stack information and more reason codes for each thread of interest.

Depending on the particular implementation the reason code may be obtained from the operating system from the Java virtual machine or from both sources. If reason codes are available from both the operating system and the Java virtual machine the reason code providing the most detail is used in the analysis in these examples.

The reason code may indicate that a thread is in an idle state or blocked from executing because a resource such as an I O interface or device is unavailable. Another example of a reason that the reason code may return is that a particular file has been locked by another thread causing the current thread to be placed in an idle state to wait for the file to become available.

Thereafter statistics are copied from the blocked thread statistics table step . In these examples the blocked thread statistics table may be blocked thread statistics table in . Next a determination is made as to whether additional unprocessed threads of interest are present step . If additional unprocessed threads of interest are present the process returns to step . In step the statistics copied from the blocked thread statistics table are for the thread of interest.

If additional unprocessed threads of interest are not present the process sends a notification to the device driver that the gathering of data has completed step . Thereafter the process may generate a report step with the process terminating thereafter.

In the depicted examples a device driver is used to identify when criteria is met for collecting information. In these examples the device driver identifies when a thread enters or leaves a wait state as well as other statistics about the thread s execution time. Other information about the thread in these examples is collected by an interface to a Java virtual machine. In these examples this other information takes the form of call stacks. Of course depending on the particular implementation the different processes implemented in the device driver could be implemented in an interface to the Java virtual machine such as interface in or interface in depending on the particular implementation.

With reference now to a flowchart of a process for comparing executions of jobs to a history is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented in a software component such as profiling program in . The process illustrated in is a real time process in which the comparison of data occurs as the data is collected. Depending on the particular implementation this process may be performed after all of the data has been collected for a particular job. In these examples a job is a single instance of a program or application.

The process beings by collecting data for a job step . In these examples the data is wait state data such as wait state data in . Additionally the data collected also includes idle state data such as idle state data in relating to the execution of the job.

The process then compares the data with a history for the job step . This history is data collected for execution of the job over some period of time. The comparison may include for example correlating the time at which the data is collected for the current job with a corresponding time in the history for the job. The correlation also may extend to particular days and months depending on the particular implementation. Thereafter a determination is made as to whether a difference in the data is present step .

If no difference in the data is present the process returns to step . In many cases some differences may be present. If a difference in the data is present a determination is made as whether the difference exceeds a threshold or some other criteria step . If the difference exceeds a threshold the process generates a notification step . The notification may be for example an entry in a log a notification presented on a display or an email message sent to a user. With reference again to step if a difference in the data does not exceed the threshold the process returns to step to continue collecting data. The process in step also returns to step .

Thus illustrative embodiments provide a computer implemented method apparatus and computer usable program code for collecting information about threads. A thread entering a wait state is detected. Information is selectively obtained about a set of threads in the wait state using a policy in response to the thread entering the wait state

Although the depicted examples for the different illustrative embodiments are described with respect to a Java Virtual Machine the embodiments may be implemented in other types of environments other than a Java Virtual Machine. For example the embodiments may be implemented in any virtual machine or in an operating system. The embodiments of the present invention may be implemented in any environment in which wait states are present. For example the described features for the illustrative embodiments may be applied to other constructs or locking mechanisms other than a monitor. The different features may be applied to requesters waiting for operations to complete in any operating environment.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store or communicate the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device . Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

Further a computer storage medium may contain or store a computer readable program code such that when the computer readable program code is executed on a computer the execution of this computer readable program code causes the computer to transmit another computer readable program code over a communications link. This communications link may use a medium that is for example without limitation physical or wireless.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

