---

title: Protection domains for a computer operating system
abstract: A protection domain system is implemented to provide protection for applications executing in a computing environment. Protection domains are allocated system resources and may contain executing tasks. The protection domain system may allow tasks to access resources in other protection domains to which attachments have been made. Attachment is transparent to the software developer. The protection domain system provides flexibility in implementing operating system services and defining protection hierarchies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08359575&OS=08359575&RS=08359575
owner: Wind River Systems, Inc.
number: 08359575
owner_city: Alameda
owner_country: US
publication_date: 20070430
---
This application is a Divisional application of U.S. patent application Ser. No. 09 480 309 filed on Jan. 10 2000 now U.S. Pat. No. 7 213 247 entitled Protection Domains for a Computer Operating System. The entire disclosure of this prior application is considered as being part of the disclosure of the accompanying application and hereby expressly incorporated by reference herein.

Traditional multitasking operating systems e.g. UNIX Windows have been implemented in computing environments to provide a way to allocate the resources of the computing environment e.g. CPU memory Input Output I O devices among various user programs that may be running simultaneously in the computing environment. The operating system itself comprises a number of functions executable code and data structures that may be used to implement the resource allocation services of the operating system.

Operating systems have also been implemented in a so called object oriented manner. That is when a particular function and or data structure defined by a class definition is requested the operating system creates instantiates an object that uses executable code and or data structure definitions specified in the class definition. Such objects thus may contain executable code data structures or both. Objects that perform actions are typically referred to as tasks also known as threads and a collection of tasks may be referred to as a process. Upon loading and execution of the operating system into the computing environment system tasks and processes will be created in order to support the resource allocation needs of the system. User applications likewise upon execution may cause the creation of tasks user tasks processes user processes and other objects in order to perform the actions desired from the application.

In order to protect the operating system and each task running in the computing environment from interference from other tasks also running in the computing environment typical operating systems apportion the computing environment s execution space e.g. its memory into a system space and a user space. The system space includes the operating system tasks while the user space includes any user tasks. Typically operating systems are designed so that user tasks cannot directly access the memory apportioned to system tasks and also may not access the memory allocated to other user tasks . The operating system itself however can access all portions of memory.

Conceptually this protection model is illustrated by . In a computer system controlled by an operating system there may be any number of user processes and system tasks executing at one time. User processes each include a number of user tasks . Because each user process is only allocated a portion of the system memory the operating system may restrict access by any user task affiliated with a particular user process to the memory allocated to another process. Typically however system tasks have unrestricted access to each other and each user process indicated by direct connections .

Additional protection may be provided by the CPU of the computing environment through the use of protected processing modes. For example a CPU may provide supervisor and user modes of operation where supervisor mode allows full use of all CPU instructions and facilities and user mode restricts the use of certain system critical instructions and facilities. Typical operating systems designate system processes to run in supervisor mode and user processes to run in user mode.

There may be instances however when a user task desires access to facilities controlled by the operating system. For example a user task may want access to a network I O connection the control of which is delegated to a system task. In order to make such access the user task is required to request execution of the system functions that perform the desired actions via a system call typically implemented via a special instruction used to cause the processor executing the code to trap to a trap routine implemented in the system software that makes a function call to the desired facilities of the operating system. Thus the user task executing the system call cannot directly access the instructions and data structures of the system functions it wishes to execute but rather must employ a special access procedure represented in as connections . Furthermore since the user task is not permitted access to system resources another task must be created by the operating system in the system space in order to perform the requested action. While this procedure protects the operating system from potential interference caused by user tasks it increases system processing overhead and thus increases execution time .

There may also be instances where it is desirable to allow a user process to access functions provided in other user processes. For example it is desirable to implement applications in a modular fashion and to re use modules already implemented by other applications. Under traditional operating system implementations such re usable code modules called shared libraries may be implemented in one of two ways. First the shared library can be implemented in the user space and any task that desires access to a function of the shared library may be allowed to directly call the function. This first implementation may be undesirable because it allows errant or malicious tasks to make changes to the shared library that may permanently corrupt the library. Second the shared library can be implemented within the operating system space and any user task that desires access to a function of the shared library must perform an indirect call to the system the system call described above . Although implementing the shared library within the system provides protection from corruption execution time is increased due to the overhead incurred from the system trap. Moreover if the shared library software is not carefully designed and implemented erroneous shared library functions can interfere with other system processes potentially causing damage to the operating system.

Certain operating systems called real time operating systems have been developed to provide a more controlled environment for the execution of application programs. Real time operating systems are designed to be deterministic in their behavior i.e. responses to events can be expected to occur within a known time of the occurrence of the event without fail. Determinism is particularly necessary in mission critical applications although it is generally desirable for all operating systems. Real time operating systems are therefore implemented to execute as efficiently as possible with a minimum of overhead. As a result prior real time operating systems have typically employed relatively simplistic protection models for system and user process typically all processes execute in the same space thus allowing direct access to all system resources by all user tasks system calls can be made directly without a trap instruction . This protection model provides the fastest execution speed but is deficient in providing system protection.

Certain operating systems have also been implemented in so called embedded computing environments for example an electronic device that includes a computer system embedded within the device e.g. automobiles medical devices cellular phones .

Embedded computing environments tend to include less resources than standard desktop PC type computing environments for example less memory may be used and a limited set of I O devices may be supported. Embedded computing environments also tend to vary widely using different CPUs and other hardware. As a result operating systems used in embedded computing environments are designed to be portable across multiple processor environments and scalable to the particular hardware and functionality of the electronic device. The need for portability and scalability make its beneficial to implement the operating system using as little system space as possible and in a modular fashion. Real time operating systems such as VxWorks from Wind River Systems Alameda Calif. are particularly suitable for use in the embedded computing environment.

While the simple protection model used in real time operating systems was adequate for simple controlled implementations the simple protection model impairs the use of real time operating systems in more demanding computing environments. Such capability is desirable for use of the real time operating system in the growing field of so called information appliances electronic devices that provide desktop PC type applications in smaller non desktop PC type devices mobile phones personal digital assistants television set top units etc. These information appliances can allow for the execution of application programs from vendors other than the maker of the appliance which may be more complex than typical embedded applications and may also allow for networking between the appliance and other systems. Users of such devices have a lower tolerance for system delays and failures as are prevalent in desktop PC systems. In such an environment the ability to provide a protection model that prevents interference by malfunctioning and or malicious tasks while maintaining high execution speeds portability and system scalability is desirable.

According to an exemplary embodiment of the present invention a computer system is described comprising a system space having a number of memory locations and a number of protection domains at least one of the number of protection domains owning a portion of the system space. Also according to the exemplary embodiment according to the present invention a protection domain is described comprising a memory space and a protection view designating a set of protection domains for unrestricted memory access.

A first method is also described as part of the exemplary embodiment according to the present invention. The method includes loading a code module into a memory space of a first domain the code module including an instruction having a symbol reference and determining if the reference symbol is to an external location outside of the memory space. The method also includes generating a link stub for the symbol reference when the symbol reference is to an external location to access the external location and redirecting the instruction to the link stub.

A second method is also described as part of the exemplary embodiment according to the present invention. The second method includes the steps of creating a task in a first domain the task executing a number of instructions executing a jump instruction in the number of instructions that refers to a link stub corresponding to an external location in a second domain and executing the link stub.

A method for debugging a code module is also described as part of the exemplary embodiment according to the present invention. The method for debugging including the steps of loading a developmental code module into a protection domain in a computing environment the protection domain having a protection view the protection view being set to a first setting and changing the protection view to a second setting to isolate the protection domain in the computing environment. The method also including the steps of performing a debugging operation using the developmental code module and changing the protection view back to the first setting.

According to an embodiment of the present invention a system is provided that implements a protection domain system. The protection domain system segregates the computing environment into a number of protection domains. Each protection domain is a container for system resources executable code and data structures as well as for executing tasks and system objects such as semaphores and message queues . Each resource and object in the system is owned by exactly one protection domain. The protection domain itself is a self contained entity and may be isolated from other system resources and objects to prevent tasks executing in the protection domain from potentially interfering with resources and objects owned by other protection domains and vice versa .

The protection domain system also however provides mechanisms by which tasks executing in one protection domain may access resources and objects contained in a separate protection domain. Each protection domain includes a protection view that defines the system resources and objects to which it has access i.e. the resources and objects which it can see . By default each protection domain has a protection view that includes only the system resources and objects contained within that protection domain. However a protection domain may acquire access to the resources of other protection domains by attaching to these protection domains. When a first protection domain has obtained unprotected attachment to a second protection domain the second protection domain is added to the protection view of the first protection domain. Executable code in the first protection domain may use unprotected links to selected functions in the second protection domain allowing tasks executing in the first protection domain to use the resources and access the objects of the second protection domain with a minimum of execution overhead. Executable code in the first protection domain may also be linked to data structures or specific memory addresses in the second protection domain without restriction.

Unrestricted access by all tasks executing in one protection domain to all the resources and objects of another protection domain may not be desirable however for reasons of system protection and security. The protection domain system provides a further mechanism whereby individual tasks executing in a first protection domain may access resources or objects contained in a second protection domain but without adding the second protection domain to the protection view of the first protection domain. This access is achieved by protected attachment of the first protection domain to the second protection domain via a protected link between executable code in the first protection domain and selected functions in the second protection domain. Using the protected link a task running in the first protection domain may for example make a direct function call to a function existing in the second protection domain without the need to alter the protection view of the first protection domain. Tasks in the first protection domain are prevented from accessing the second protection domain except through this protected link thus preventing unauthorized accesses of functions and data in the second protection domain. As will be described below protected linking can be achieved without the need to use different code instructions for protected and unprotected accesses increasing implementation flexibility and without the need to create separate tasks in the protected protection domain to perform the desired actions.

This protection domain system according to the present invention allows the operating system to dynamically allocate system resources among processes and flexibly implements and enforces a protection hierarchy. This protection hierarchy can be formulated to control the impact of poorly written or malicious applications on the operating system and other applications running in the computer system in a manner that is transparent to applications developers and incurs minimal execution overhead. The protection domain system can also enable modular software implementations and development without sacrificing system protection or incurring extensive overhead.

An exemplary embodiment of a computing environment implementing a protection domain system according to the present invention is illustrated by . is a block diagram of an exemplary computer system . Computer system includes a CPU which is coupled to a physical memory system and a number of I O systems . Connection of the CPU to the physical memory system and the number of I O systems may be according to any of the well known system architectures e.g. PCI bus and may include additional systems in order to achieve connectivity. I O systems may comprise any of the well known input or output systems used in electronic devices e.g. key pad display pointing device modem network connection . Physical memory system may include RAM or other memory storage systems operational memory and read only memory and or other non volatile storage systems for storage of software an operating system other applications to be executed in computer system . Alternately software may be stored externally of computer system and accessed from one of the I O systems e.g. via a network connection . CPU may also include a memory management unit MMU not shown for implementing virtual memory mapping caching privilege checking and other memory management functions as is well known.

System space includes an operating system which controls access to all system resources such as physical memory system and I O systems . Operating system includes executable code and data structures as well as a number executing tasks and system objects that perform system control functions e.g. context switching between tasks . Operating system may be loaded into system space for example upon power up of the computer system via a bootstrap loader.

Exemplary operating system according to the present invention implements a protection domain system in which all resources and objects are contained within protection domains. The exemplary protection domain system is object oriented each protection domain itself is actual a system object. The structure of each protection domain is defined through a protection domain class definition. A protection domain may be created for example by instantiating a protection domain object based on the protection domain class. Only the operating system can create or modify or destroy a protection domain although user tasks can request such actions through a protection domain application programming interface API provided by the operating system . A protection domain object is owned by the protection domain that requested its creation.

Upon creation of protection domain the protection view of the protection domain will be established. The protection view represents the protection domains to which tasks executing in the protection domain may have access. An exemplary protection view data structure that may be used to represent the protection view is illustrated in . Protection view data structure is a bit map in which each protection domain in system space is represented by a single bit. Where a bit is set the protection domain has unprotected access to the corresponding protection domain in system space . Where a bit is not set unprotected access is not permitted. Operating system may maintain information for mapping each bit to an existing protection domain. The size of the bit map defines the maximum number of protection domains supported in the system space in this example sixty four protection domains are possible. Note that other data structures could also be used to represent the protection view which avoid this limitation.

The default condition for protection domain is a protection view that includes only the resources and objects of protection domain and no other protection domains. In the exemplary bit map of protection view data structure this default condition may be represented by setting the bit corresponding to protection domain while leaving the remaining bits cleared value zero . Protection domain may expand its protection view by being attached to other protection domains during the linking process when code modules or other objects are loaded into protection domain which will be further described below.

Also upon creation of protection domain a set of protection domain attributes may be specified. These attributes may be used to control the actions allowed by tasks executing in protection domain the linking permitted between protection domain and other protection domains in the system space and other characteristics of the protection domain . Among the protection domain attributes supported by protection domain are 

Also upon creation of protection domain memory space may be loaded with a number of code modules this loading may also be deferred until a later time . A code module may contain executable code data structures and or other information to be used by a loader application during the loading process. The executable code will include a number of instructions which may include instructions that reference other executable code or data structures outside of code module e.g. via a jump or branch instruction to execute a function . These references may be made using symbols that are intended to represent the memory location of the desired code or data structure. In order to determine resolve the memory address value of these symbols the loading of code modules may include a linking process described below that attempts to resolve symbol references by searching for other occurrences of the symbol either in other code modules already loaded into the protection domain or in code modules loaded into other protection domains. Note that symbols may also include the memory address itself in which case no resolution is needed although other linking activities may still be performed as described below .

Symbols that reference locations external to protection domain indicate that a link is needed between protection domain and the protection domain that owns the external location referenced by the symbol. Inter protection domain linking is achieved through the use of linking table and symbol table . An exemplary linking table is shown in . A linking table entry is provided for each symbol that requires an inter protection domain link. The linking table entry includes the symbol itself and a link stub which comprises a number of executable instructions used to access the external location. A simple link stub may comprise only a jump instruction to cause a jump to the address of the external location although additional instructions may be included in the link stub as needed to implement the protection goals of the system. As part of the loading and linking process described below instructions that include symbols referencing external locations are redirected to the linking table entry corresponding to the symbol and specifically to the link stub corresponding to the symbol .

Symbol table is used in conjunction with linking table . An exemplary symbol table is shown in . A symbol table entry is provided for each symbol used in protection domain . The symbol table entry includes the symbol itself the address for the memory location referenced by the symbol and whether the symbol may be used as an entry point. Symbol table may be used for linking within protection domain as well as for inter protection domain linking. Symbols that are permitted to be linked by code modules outside of protection domain are indicated to be entry points by specifying such in the entry point field of symbol table .

The linking table and entry points enable a number of beneficial features of the protection domain system. First executable code does not have to be written to take into account any protection facilities and can simply call external functions as if those functions were internal to the protection domain. The distinction between protected and unprotected accesses is not forced onto the code writer but rather is a function of the protection domain. Second addressing limitations of some instructions of some CPUs can be avoided because all inter protection domain function calls are handled through the linking table not the instruction making the call. Third the protection scheme can be enforced both when code modules are linked in the process of creating the linking table and while tasks are running using the link stubs .

Protection domain may also include authorization information that may be used for example in permission checking for attachment of protection domains and other security checking operations as will be further described below.

Protection domain may also own tasks and system objects . Protection domain may include no tasks purely a data buffer or passive shared library of functions or a number of tasks that either have been created spawned in the protection domain native tasks or are visiting protection domain i.e. native to another protection domain . Tasks may be spawned for example upon completion of loading and linking code modules described below . System objects are created by the operating system at the request of a task executing in protection domain . Such system objects may include semaphores message queues and watchdog timers as are well known as well as other protection domains. The structure and operation of tasks in the protection domain system will be described in more detail below.

As mentioned previously all system resources and objects are owned by a protection domain. The system space will therefore include at least one protection domain a protection domain that owns the code modules and other objects associated with the operating system . shows operating system contained within a single system protection domain . Upon loading and execution of the operating system one of the first actions performed during loading is to create the system protection domain. The system protection domain initially owns all system resources and objects and ultimately owns all other protection domains created within the system space . The system protection domain may have a protection view that includes all protection domains in the system so that any task executing in the system protection domain may access executable code and data in any protection domain.

In the current example all protection domains are objects that are created and maintained by the operating system . Accordingly operating system maintains a protection domain list data structure that tracks all protection domains currently in existence in the system space . illustrates an exemplary protection domain list data structure . The protection domain list includes a record for the system protection domain object and records for any other protection domain objects in existence. An exemplary record in the protection domain list may include entries for the protection domain name entry memory mapping information for the protection domain entry a list of code modules downloaded into the protection domain entry a list of system objects owned by the protection domain entry the protection domain attributes entry a list of global symbols provided by the protection domain entry and a count of the number of tasks executing in the protection domain entry . Other information may be stored in the protection domain list depending on the specific implementation of the protection domain system. Protection domain list allows the operating system to reclaim resources used by a protection domain when the protection domain is no longer needed destroyed .

As mentioned above the protection view represents the system resources available to objects in a particular protection domain i.e. the resources and objects that can be seen in the protection domain . Each protection domain has a protection view that by default includes only its own memory space and system objects. In this default condition the protection domain cannot access any resources or objects that exist in other protection domains. Thus this limited protection view prevents direct linking of executable code to the resources and objects of other protection domains and prevents tasks executing in the protection domain from accessing the resources and objects of other protection domains preventing possible corruption of the resources and objects of other applications or the operating system.

There may be instances when access to other protection domains is desirable. For example an application may want to place a library of commonly used functions or a common data structure in a separate protection domain in order to allow other applications to access these functions and data structures without allowing access to the application s own protection domain . Also applications will need to access the system protection domain in order to access resources and objects controlled by the operating system . The protection domain system permits such access through a mechanism called attachment which may be employed when a code module is loaded into a protection domain and needs to link to executable code and other objects located outside the protection domain. Attachment may be unprotected where the protection view of the protection domain is changed to include the attached protection domain or may be protected where only particular protected links are permitted between each protection domain.

The following discussion will illustrate some exemplary attachment mechanisms and exemplary processes by which unprotected links and protected links may be established between protection domains. The discussion will be directed to the general case of the implementation of the exemplary protection domain system and to a specific example of an application being loaded into system space where operating system has already been loaded and is executing in system protection domain

The specific example of the loading of application is shown in . Application comprises two code modules each having a size of 10000 h bytes which are each intended to use separate protection domains one for application specific functions executable code and data structures and one for storage of common functions and data a shared library that will be used by the application and possibly other applications later loaded. Code module includes executable code that includes instructions that reference functions called foo and goo neither of which are part of code module . Code module includes executable code for the function foo . Operating system includes executable code for the function goo . Since these functions foo and goo are not present in code module their calls are represented by a symbol for example the function name that acts as a surrogate for the address of the memory location of the entry point for the function. Code module will allow other code modules to link to its functions such as foo provided they provide proper authorization. Function foo has as its entry point a relative address of 00001110h i.e. relative to the first instruction in code module and code module includes a symbol for foo indicating this relative address. Operating system will not permit access to its protection domain but will allow calls to goo through protected linkage. Function goo has as its entry point an address of 00001000h .

In step the protection domain into which the code module will be loaded is determined. Code modules can be loaded into existing protection domains or newly created protection domains or protection domains built in the development system which may be indicated by the instruction provided to perform the loading process or as part of the code module itself. Where a code module is being loaded into an existing protection domain this determination may also include checking the protection domain attributes to determine whether the target protection domain permits code module loading. In this example new protection domain is created for code module by requesting that the operating system create a new protection domain object. shows protection domain indicating it has been allocated addresses 0001000h to 0001FFFFh. The addresses for this protection domain are provided to the loader. Protection domain is created with protection domain attributes not shown that indicate that other protection domains may make unprotected attachment to the resources and objects of protection domain

In step the memory allocation of the protection domain s memory space is compared to the code module to determine if enough memory has been allocated. If additional memory is needed a request is made to the operating system to allocate additional memory to the protection domain. In the present case where protection domain has been created as part of the loading of code module the memory needed can be specified as part of the protection domain creation request.

In step the code module is loaded into the memory space of the protection domain. The actual memory locations that will receive the executable code and data structures of code module can be determined based on the size of the memory space the presence of other code modules in the memory space and other system specific factors. In this example code module is loaded into protection domain such that the executable code for function foo begins at address 00011110h.

Loading also causes the protection domain s symbol table to be updated to include symbols identified in the code module. A symbol table used in the present example for protection domain is shown in . In this case the symbol for the function foo is loaded into symbol table along with its corresponding address which at this point is still its relative address 00001110 and an indication that it is an entry point for external linking.

In step the executable code of the code module is relocated based on its actual memory address. When the code module is loaded into the protection domain s memory space address offsets are generated that represent the quantity that should be added to memory references in the executable code in order to reflect the actual memory locations of the referenced items. Alternately a code module may specify it can only be loaded into particular memory locations unrelocatable code which can be indicated to the operating system in step so that the desired memory locations can be allocated. The protection domain symbol table is updated to include the actual addresses of the symbols of the code module. In this example an offset of 00010000 is added to each memory reference in code module and to each entry in symbol table including foo which now has a corresponding address of 00011110 matching its actual entry point .

In step the executable code of the loaded code module is linked. Linking involves resolving addresses for symbols referenced in the executable code of the code module. The executable code is parsed and symbols are compared against the protection domain symbol table . When a symbol is found in the symbol table the corresponding address for the symbols is substituted for the symbol in the executable code. When the symbol is not found in the protection domain symbol table a linking table entry is created in the protection domain linking table indicating that the executable code is referencing an external location outside of the protection domain . The address of the linking table entry is then substituted for the symbol in the executable code. If a linking table entry for the unresolved symbol already exists that linking table entry may be used. In this case no external function calls are made by the executable code of code module so no linking table entries are made in linking table

In step inter protection domain links are created using the protection domain linking table . The details of this procedure are discussed below in the discussion of the linking of code module .

Once the code module has been loaded and linked the loader determines whether additional code modules need to be loaded step . If not the loader execution is complete step . Alternatively the loader can be instructed to begin execution of the loaded code modules by requesting the creation of a task step . In such a case the operating system can create a task owned by the protection domain executing in the protection domain using the executable code of the loaded code module. In this example code module still needs to be loaded so the loader repeats steps in order to load code module

The loading of code module the application specific executable code and data structures begins by retrieving code module from non volatile memory system of physical memory system step . In this example since code module specifies that creation of a new protection domain is needed to hold it protection domain is created step via request to operating system . This protection domain is allocated memory addresses 00090000 to 0009FFFF step corresponding to the size of code module . The executable code and data structures of code module are loaded into memory space of protection domain step and any internal symbols are entered in symbol table . No entry points are provided by code module so none of the entries in symbol table are designated as entry points . Memory references and symbol corresponding addresses are adjusted using the offset 00090000 step .

In step the executable code of code module is linked to resolve symbol addresses. References to internal symbols are resolved based on the symbol table . Symbols not found in symbol table generate linking table entries in linking table for inter protection domain references and the addresses for the entries in linking table are substituted for the symbols in the executable code.

In step inter protection domain links are created using the protection domain linking table . The sub steps of this process are shown in the flow chart of and will be first explained as applied to a generic protection domain and then as applied to the example of . In step the symbol name from an unresolved entry in a protection domain s linking table is used to search the symbol tables of each protection domain for a matching symbol. This search may be simplified by maintaining a global symbol table for all entry points exposed by protection domains in the operating system. If no match is found step a default address is entered for the symbol in the link stub of the linking table entry for the symbol indicating that no link has been established step and any remaining linking table entries are processed. Alternately an error may be generated causing the loading process to abort or if the linking process is being performed on an development system a notification can be provided indicating that no link has been established for the symbol.

When a match is found the protection view of the protection domain is checked to determine if the corresponding address for the symbol is within the protection view of the protection domain step . If so the corresponding address for the symbol is inserted into the link stub of the linking table entry for the symbol step . If the symbol address is outside the protection view of the protection domain a request is made to the operating system to permit attachment to the protection domain containing the symbol step . This request may include protection domain authorization information which can be used to verify the authority to make an attachment. The operating system consults the protection domain list to determine the protection domain attributes of the protection domain to which attachment is being requested step . If no attachment is permitted a default address is entered for the symbol in the link stub for the symbol s linking table entry indicating that no link has been established step and any remaining linking table entries are processed. Alternately an error may be generated causing the loading process to abort or if the linking process is being performed on an development system a notification can be provided indicating that no link has been established for the symbol.

If the protection domain containing the symbol permits unprotected attachment by the requesting protection domain the protection view of the requesting protection domain is altered to include the symbol s protection domain step . The corresponding address for the symbol is then inserted into the link stub of the linking table entry for the symbol step and any remaining linking table entries are processed. If the protection domain containing the symbol permits only protected attachment by the requesting protection domain the protection views of the protection domains are not altered but the corresponding address for the symbol is still inserted into the link stub of the linking table entry for the symbol step and any remaining linking table entries are processed. Note that by not adding the protection domain of the symbol to the protection view of the calling code module the memory address for the symbol will be outside of the memory accessible by the protection domain of the calling code module.

Applying the inter protection domain linking steps described above to the linking of code module the entry points for all protection domains are searched for the symbol foo step which is the first entry in linking table see . Foo is found step in the symbol table of protection domain the shared library see which has not yet been added to the protection view of protection domain step . Attachment of protection domain to protection domain is requested step and unprotected attachment is granted. step . Protection domain is added to the protection view of protection domain step . The corresponding address for the symbol foo is inserted into the link stub of the linking table entry for the symbol foo step such that the link stub for the linking table entry for the symbol foo will now perform a jump to the corresponding address 00011110 which is the location of the function foo in the memory space of protection domain .

The process is repeated for the linking table entry for symbol goo in linking table . The entry points for all protection domains are searched for the symbol goo step . Goo is found step in the symbol table of protection domain the system protection domain which has not been added to the protection view of protection domain step . Attachment of protection domain to protection domain is requested step however system protection domain does not permit unprotected attachment to its resources and will only grant protected attachment step . As a result the corresponding address for the symbol goo is inserted into linking table step such that the link stub for the linking table entry for the symbol goo will perform a jump to the corresponding address 00001000 which is the location of the function goo in the memory space of system protection domain . The protection view of protection domain however is not altered.

Once the code module has been loaded and linked the loader determines whether additional code modules need to be loaded step . Since no more code modules are specified by application the loader execution is complete step . Alternatively the loader can be instructed to begin execution of the loaded code modules by requesting the creation of a task step . In such a case the operating system can create a task owned by the protection domain executing in the protection domain using the executable code of the loaded code module step .

The exemplary loading and linking process provides system protection by using the protection domain system to prevent improper or unauthorized linking against the contents of protection domains. Thus the loading and linking process provides a method to enforce the system protection provided by the protection domain system at the time of the loading and linking of applications.

The protection domain system also provides beneficial system protection during the course of application execution. Tasks executing in the system space using the protection domain system are prevented from making unpermitted accesses of memory locations outside of the specified protection view thus further protecting the system from erroneous or malicious accesses that may not have been eliminated during the linking process.

The following example will illustrate the execution of an exemplary task spawned in protection domain to execute application . Task spawning may occur at the completion of the loading and linking process for application or at a later time through a request to the operating system to create a task object. Task is initialized to execute the executable code of code module Task is also initialized with a task protection view equal to the protection view of protection domain which in this case includes protection domain

Eventually execution of task will reach the instruction that references the function foo . The linking process has redirected this reference to the link stub for the symbol foo in linking table which causes a direct jump to the location 00011110 see which is the entry point for the function foo . Since protection domain is within the protection view of protection domain the jump to the memory location for function fooo is within the permissible address range for memory accesses which may be enforced for example by the MMU of CPU . Task continues execution in protection domain executing the function foo . When execution of the function foo has completed task returns to protection domain and continues executing the executable code of code module . Note that the only additional overhead that has been incurred using the protection domain system has been the additional link stub which is minimally a single jump instruction.

Execution of task will eventually reach the instruction that references the function goo which will cause a redirection to the linking table and execution of the link stub for the symbol goo. The link stub for goo attempts a jump to location 00001000 see. . However memory location is allocated to the system protection domain which is not in the protection view of task . As a result the jump to address 00001000 causes the generation of a processor exception for a memory fault. This exception causes the execution of an exception handling routine in the operating system to deal with the memory fault exception. This exception handling routine implements the instructions that allow the task to switch to a protection domain outside of the task s protection view.

In step the task protection view is changed to include the protection view of protection domain owning the memory location to access in this case the protection view of the system protection domain . The privilege mode of task is also changed if the privilege mode of the called protection domain is different that the task s native privilege mode. In step the exception handler sets the context information in task control block so that the next instruction executed by the task is the requested entry point in this case memory location 00001000 the entry point for function goo . In step execution of task recommences at the requested entry point here the function goo . 

Once execution of function goo is completed the reverse protection switch may employed to return the task to its previous protection domain. The protection switch stack is unwound popping the return address for the function call and the pre exception state information task protection view protection domain processor privilege mode . The pre exception state information is used to restore the task state information to pre exception values and execution is passed to the return address for the function call for example an instruction subsequent to the function call .

The exemplary protection switching mechanism described above allows a single task to execute between any number of protection domains whether a protected or unprotected attachment exists without the use of different calling instructions in the executable code for either type of attachment. There is no need to instantiate additional tasks in each protection domain since tasks may visit each protection domain having resources to which access is needed. No complex and lengthy message passing schemes need to be implemented. Furthermore because the protected link only causes the task protection view to be switched to include the protection domain of the called function any other tasks also executing in the task s protection domain still cannot access the protection domain of the called function without using the protected link thus protecting against unrestricted accesses.

Among the many implications of the protection domain system according to the present invention is that the operating system need not be implemented as a single monolithic entity for protection purposes. The operating system itself can be divided into a number of protection domains each of which employs protected links to allow access by user tasks and system tasks. illustrates an example of an operating system which employs two protection domains a kernel protection domain and a graphics protection domain . Kernel protection domain owns the core operating system code and objects e.g. interrupt service routines while graphics protection domain owns the executable code and other objects related to a graphical user interface GUI of the operating system . Kernel protection domain may provide access to its features via protected linking to entry points which correspond to a kernel API provided by the operating system . Likewise graphics protection domain may provide access to its features via protected linking to entry points which corresponds to a GUI API provided by the operating system .

Separating operating system tasks is beneficial in a number of ways. It is possible to design the operating system in a modular fashion such that only those modules which are needed in the computer system are implemented which reduces the operating system s footprint for those computer systems that are small and do not require certain operating system services. Also by dividing the operating system into smaller protection domains erroneous code executing in one portion of the operating system is less likely to corrupt other areas of the operating system that are in separate protection domains.

Another implication of the protection domain system according to the present invention is the ability to dynamically define the linkages and thus the level of protection between protection domains. The exemplary attachment mechanisms described above unprotected linking and protected linking both use the same calling instruction for function calls in any executable code written for use in the protection domain system. For example executable code written in the protection domain system described above can use for example a jump instruction to a called function regardless of whether an unprotected link or protected link is allowed. One of the ways in which the protection feature is enforced is at run time i.e. when tasks are executing is by comparing the function call against a protection view of the task executing the function call. Thus whether the link is protected or unprotected may be dependent on the protection view of the particular task which is making the call.

A task is created in protection domain to run the executable code of the second application. Task has a task protection view identical to that of protection domain that is task has a task protection view that includes protection domains and . Task may call a function in the shared library of protection domain which is then executed over the unprotected link between protection domain and protection domain . If the called function in the shared library then calls a function in protection domain i.e. a system function the protection view of task is checked as part of the function call. Because task has a task protection view that includes protection domain the function call to protection domain is by unprotected link e.g. no exception is generated rather than by protected link as was the case before task executed. Note that if the executable code of protection domain was required to use different instructions to implement protected or unprotected linkage task would either be forced to use the linkage existing at link time in this example a protected linkage or a separate protection domain using a copy of the shared library of protection domain would need to be created to provide the unprotected link for task thereby increasing system resource usage .

Another implication of the protection domain system according to the present invention is the ability to flexibly configure the protection hierarchy of various protection domains in a computer system. Certain applications running in a computing environment may be more trusted than others for example applications written by certain programmers or vendors may be considered more fault proof than others. Trusted applications which are less likely to cause system corruption may be allowed to make unprotected access for example to operating system functions thus allowing these trusted applications to execute with low overhead in as fast a manner as possible. Untrusted applications may be allowed to make only protected access to system functions. The level of protection that is enforced against a particular application can be realized using the features of the protection domain system. Trusted applications can be described as being privileged in the sense that the application is privileged to make unprotected accesses to sensitive system resources not in the sense of processor protection mode although privileged applications may execute using a privileged processor mode as well .

Software development is another situation that benefits from the flexible protection hierarchy feature. Software development is typically performed in a development environment that includes a debugging tool that allows executable code under development to be examined for errors. During this development process it may be desirable to have the maximum protection possible from programming errors in the code being developed both as a way to uncover hidden programming errors and to prevent damage to other applications in the computer system including the operating system . In such a case the protection view of the protection domain s containing the executable code under development may be set such that their linkage to other more stable protection domains in the system is restricted to protected links.

In step a debugging operation is performed for the code module. This debugging operation may use a debugging tool to allow run time observation of the code module under development and other known debugging operations. Since the protection view of the protection domain of the code module under development does not include all other protection domains tasks executing in the protection domain will only be permitted to make calls to functions outside the protection view via protected links. Although protected links in the present example incur additional execution overhead due to the exception handling routine during the debugging process this overhead is likely not to be critical. When debugging is complete the protection view can be set to a privileged level to allow calls using unprotected links to those protection domains which are intended to be in the protection view step . This may be achieved for example using the protection level facility to manipulate the linking permissions of affected protection domains either during system execution or prior to system execution as part of a re load of the affected protection domains .

Note that the protection domain system allows variation in the level of system protection for debugging purposes without the need to alter code modules during debugging. Because the exemplary protection system is implemented by managing the linkage between object modules and not by using specific instructions for protected calling methods the same code module may be executed as is debugged without the need for recompilation.

In the preceding specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

