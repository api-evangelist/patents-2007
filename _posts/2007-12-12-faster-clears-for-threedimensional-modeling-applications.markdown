---

title: Faster clears for three-dimensional modeling applications
abstract: A graphics processing subsystem defines a bounding area as the portion of the display buffer and other memory buffers occupied by one or more rendered objects. When clearing the memory buffers, only the portions of the buffers corresponding to the bounding area need to be cleared. A graphics pipeline includes a bounding area memory to store bounding area values. The bounding area values are modified during rendering so that each rendered primitive falls within the bounding area values. The graphics processing subsystem clears a portion of the memory buffer in response to a clear command specifying a bounding area. The clear command may include a set of bounding area values defining the bounding area, or alternatively a reference to the bounding area memory. For applications that draw objects in isolation, the bounding area will be smaller than the window, resulting in a decreased time requirement for clearing the memory buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07898549&OS=07898549&RS=07898549
owner: NVIDIA Corporation
number: 07898549
owner_city: Santa Clara
owner_country: US
publication_date: 20071212
---
This application is a divisional of U.S. patent application Ser. No. 10 641 279 filed Aug. 13 2003 which disclosure is incorporated herein by reference for all purposes.

The present invention relates to the field of computer graphics. Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional scene from a given viewpoint. This process called rendering generates a two dimensional image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene.

As the demand for computer graphics and in particular for real time computer graphics has increased computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems the rendering process is divided between a computer s general purpose central processing unit CPU and the graphics processing subsystem. Typically the CPU performs high level operations such as determining the position motion and collision of objects in a given scene. From these high level operations the CPU generates a set of rendering commands and data defining the desired rendered image or images. For example rendering commands and data can define scene geometry lighting shading texturing motion and or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering commands and data.

During rendering the graphics processing subsystem typically stores the rendered image in one or more memory buffers. The rendered image is then periodically read from memory buffer and output to a display device. To create animation the graphics processing subsystem must generate a large number of successive images. The graphics processing subsystem typically creates each rendered image and stores the rendered image in a memory buffer just prior to its output to a display device. Before storing a rendered image in a memory buffer the graphics processing subsystem must clear the data from any previously rendered images stored in the memory buffer.

Clearing memory buffers typically involves overwriting previous image data with a default value such as a background color or a default depth stencil or alpha value. Previously graphics processing subsystems would need to clear the entire memory buffer between successive images. As image resolutions which increase the memory buffer size and frame rates have increased the time needed to clear the memory buffers has become a large factor in overall rendering performance. Further many rendering applications referred to as three dimensional modeling applications typically render one or more objects in isolation leaving most of the image unchanged from its default values.

It is desirable for a graphics processing subsystem to decrease the amount of time spent clearing memory buffers by avoiding memory writes to portions of the memory buffers unchanged from their default values. It is further desirable that the improved graphics processing subsystem be adaptable to a variety of different rendering methods and to be compatible with existing rendering applications graphics rendering APIs and operating systems.

An embodiment of the invention defines the bounding area as the portion of the display memory buffer and other memory buffers occupied by the rendered object or objects. When the memory buffers are to be cleared only the portions of the memory buffers corresponding to the bounding area needs to be overwritten with default values. The memory buffer may be a display memory buffer or a supplemental memory buffer such as a depth buffer. The bounding area can be determined as geometric primitives are rasterized or alternately from the transformed geometry prior to rasterization. In one implementation a graphics processing subsystem determines the bounding area for a rendered image. A graphics driver then reads the bounding area from the graphics processing subsystem and instructs the graphics processing subsystem to clear the bounding area.

In an embodiment a graphics processing subsystem includes a graphics pipeline adapted to process a rendering command defining a geometric primitive and a bounding area memory connected with the graphics pipeline and adapted to store a set of bounding area values defining a bounding area. The graphics pipeline is adapted to update the set of bounding area values stored in the bounding area memory so that the geometric primitive falls within the bounding area. In further embodiment the graphics processing subsystem is further adapted to compare a bounding region associated with the geometric primitive with the set of bounding area values.

The graphics processing subsystem is further adapted to clear a portion of the memory buffer in response to a clear command specifying a bounding area associated with the memory buffer. In one embodiment the clear command includes a set of bounding area values defining the bounding area. In an alternate embodiment the clear command references the bounding area memory.

In another embodiment the bounding area memory of the graphics processing subsystem includes a connection with a rasterizer stage of the graphics pipeline such that the set of bounding area values are determined from a set of pixels output by the rasterizer stage. In an alternate embodiment the bounding area memory of the graphics processing subsystem includes a connection with a raster operation stage of the graphics pipeline such that the set of bounding area values are determined from a set of pixels output by the raster operation stage. In a further embodiment the graphics processing subsystem is further adapted to modify the set of bounding area values in response to a line width value and or in response to a point size value.

In an additional embodiment the graphics processing subsystem is adapted to reset the set of bounding area values stored in the bounding area memory in response to a reset command.

A graphics subsystem is further connected with data bus and the components of the computer system . The graphics subsystem includes a graphics processing unit GPU and graphics memory. Graphics memory includes a display memory e.g. a frame buffer used for storing pixel data for each pixel of an output image. Pixel data can be provided to display memory directly from the CPU . Alternatively CPU provides the GPU with data and or commands defining the desired output images from which the GPU generates the pixel data of one or more output images. The data and or commands defining the desired output images is stored in additional memory . In an embodiment the GPU generates pixel data for output images from rendering commands and data defining the geometry lighting shading texturing motion and or camera parameters for a scene.

In another embodiment display memory and or additional memory are part of memory and is shared with the CPU . Alternatively display memory and or additional memory is one or more separate memories provided for the exclusive use of the graphics subsystem . The graphics subsystem periodically outputs pixel data for an image from display memory and displayed on display device . Display device is any device capable of displaying visual information in response to a signal from the computer system including CRT LCD plasma and OLED displays. Computer system can provide the display device with an analog or digital signal.

In a further embodiment graphics processing subsystem includes one or more additional GPUs similar to GPU . In an even further embodiment graphics processing subsystem includes a graphics coprocessor . Graphics processing coprocessor and additional GPUs are adapted to operate in parallel with GPU . Additional GPUs generate pixel data for output images from rendering commands similar to GPU . Additional GPUs can operate in conjunction with GPU to simultaneously generate pixel data for different portions of an output image or to simultaneously generate pixel data for different output images. In an embodiment graphics coprocessor performs rendering related tasks such as geometry transformation shader computations and backface culling operations for GPU and additional GPUs .

Additional GPUs can be located on the same circuit board as GPU and sharing a connection with GPU to data bus or can be located on additional circuit boards separately connected with data bus . Additional GPUs can have their own display and additional memory similar to display memory and additional memory or can share memories and with GPU . In an embodiment the graphics coprocessor is integrated with the computer system chipset not shown such as with the Northbridge chip used to control the data bus .

Three dimensional modeling application includes a display region that displays a rendered image of object . As can be seen in the example of the majority of the display region is empty. Three dimensional modeling application includes graphical user interface elements such as menu bar and toolbar . The graphical user interface elements and allow users to control the three dimensional modeling application . In an embodiment the three dimensional modeling application uses a three dimensional graphics application programming interface API such as OpenGL or DirectX to render object in display region . The three dimensional modeling application uses a two dimensional graphics API such as GDI or Xlib to render the graphical user interface elements and .

At step a bounding area of the display region is reset to a zero or null value. In an embodiment of the invention the bounding area is a rectangular region. In this embodiment the location and size of the bounding area are defined by the location of opposite corners of the rectangular region for example minimum and maximum x and y coordinates or x and y coordinates of one corner and the x and y dimensions of the rectangular region. In a further embodiment the bounding area includes multiple rectangular regions each with a location and size defined as above.

At step the graphics processing subsystem renders the object and tracks the size of the bounding area of the display region. In an embodiment each geometric primitive such as a triangle or quad is associated with a bounding rectangle. As the geometric primitives are drawn by the graphics processing subsystem the minimum and maximum extents of the bounding rectangle are compared with the bounding area of the display region. If the bounding rectangle of the primitive falls outside of the bounding area of the display region the bounding area of the display region is expanded to include the bounding rectangle of the primitive. This comparison is repeated during the rendering of each geometric primitive. In an embodiment a device driver used to interface the three dimensional modeling application with the graphics processing subsystem is used to determine the bounding area of the display region. In an alternate embodiment discussed in detail below the bounding area is determined by the graphics processing subsystem.

In one implementation of step the minimum extents of the bounding area of the display region are set to the minimum of the minimum x and y extents of the bounding rectangle and the previous minimum x and y extents of the bounding area of the display area. Similarly the maximum extents of the bounding area of the display region are set to the maximum of the maximum x and y extents of the bounding rectangle and the previous maximum x and y extents of the bounding area of the display area.

In an alternate embodiment of step the three dimensional modeling application sends a display list which is a static set of geometric primitives to the graphics processing subsystem. In this embodiment the bounding volume can be precomputed for the entire display list prior to rendering. In one implementation of this embodiment a device driver determines the bounding volume from a display list created by the three dimensional modeling application.

In some applications the display list is reused for multiple frames and or for multiple identical objects in a single frame. In these applications a different coordinate transformation can be applied to the display list to reposition an object for different rendered images or to create multiple copies of an object in a frame. In an embodiment a bounding volume is associated with the display list. Both the display list and the bounding volume are processed by the same coordinate transformation. The transformed bounding volume is then converted to a bounding area for the image. In a further embodiment the bounding area computed for a display list is merged with any other bounding areas associated with the image in a similar manner as described above.

To render the image step writes pixel data to a display memory buffer. Additionally step may also read and or write data to additional memory buffers such as depth buffers stencil buffers and alpha buffers. Typically these additional buffers are used to hold information needed for rendering.

Following the completion of rendering of an image at step the graphics processing subsystem displays the rendered image. At step the graphics processing subsystem clears the display memory buffer and any other memory buffers used to render the image. This can be done by writing a default memory buffer values to each of the memory buffers. For example a default or background color can be written into the display buffer to erase the previous image. For a depth buffer a default depth value can be written to the depth buffer.

In an embodiment of the invention the graphics processing subsystem only needs to clear the portion of the memory buffers corresponding to the bounding area computed during rendering. This greatly reduces the amount of time spent clearing the memory buffers. In an embodiment of step the graphics processing subsystem draws a rectangle over the bounding area in each memory buffer that has the desired default memory buffer value. In an alternate embodiment of step the graphics processing subsystem uses a blit engine to rapidly write the desired default memory buffer to bounding area in each memory buffer.

In a further embodiment if there are multiple bounding areas associated with a rendered image then step is repeated for each bounding area. In yet a further embodiment step ignores the bounding area and clears the entire memory buffer in response to activity by other APIs with the display region such as two dimensional graphics APIs used to draw graphical user interface elements. This ensures that there will be no artifacts from previous images when rendering a new frame.

Multiple memory buffers can be used for rendering to maximize performance and ensure that animation is flicker free. The graphics processing subsystem renders a first image into a first display buffer. As the first image is being rendered the graphics processing subsystem displays a previously rendered image stored in a second buffer. Upon completion of rendering of the first image in the first buffer the image in the first buffer is displayed. While the first image is being displayed the graphics processing subsystem renders a second image. In a variation of this technique a first buffer is used for rendering a new image a second buffer is used to display a previously rendered image and a third buffer holds a previously rendered image on deck to be displayed at the next screen refresh interval.

The front memory buffer is connected with the display device thereby displaying the first image. While the first image is being displayed the graphics processing subsystem clears memory buffers and and renders the next image. In an embodiment the graphics processing subsystem clears the first image from memory buffers and as described in method above.

In an embodiment the front memory buffer is completely cleared upon initialization of the three dimensional modeling application. As a first rendered image is copied to the front memory buffer the bounding area associated with the first image is retained for future use. Additionally this bounding area is cleared in memory buffers and to prepare to render a second image. As a second image is rendered in the back memory buffer a second bounding area is associated with the second image. To copy the second image from the back buffer to the front buffer the graphics processing system only needs to copy the portion of the second image corresponding to the union of the first bounding area associated with first image and the second bounding area associated with the second image. Following the transfer of the second image to the front buffer the first bounding area is discarded and the second bounding area is retained for future use in copying a third image to the front buffer .

While the first image is being displayed the graphics processing subsystem clears a second display memory buffer and depth buffer . The graphics processing subsystem then renders the next image into the second display memory buffer . Following completion of the next image the graphics processing subsystem connects the second display memory buffer with the display device clears memory buffers and and renders a third image into display memory buffer .

In this embodiment the graphics processing subsystem alternately displays and renders into each of the memory buffers. As shown in the graphics processing subsystem engages the connections and to display a first image in memory buffer while rendering a second image in memory buffer . Next the graphics processing subsystem disengages connections and and engages connections and to display the second image in memory buffer and render a third image in memory buffer . As supplemental memory buffers such as depth buffer are typically not displayed to the user graphics processing subsystem uses the same supplemental memory buffers to assist rendering images into either of the display memory buffers and .

In an embodiment the graphics processing subsystem clears the images from memory buffers and as described in method above. However in this embodiment the image in the supplemental memory buffer is from the previous frame while the image in the display memory buffer is from the penultimate frame. Because objects can and typically do change position from frame to frame the graphics processing subsystem must keep track of the bounding areas from the previous two frames. The bounding area of the previous frame is used to clear the supplemental memory buffers. The bounding area of the penultimate frame is used to clear the display memory buffer.

In graphics subsystem the rasterizer stage determines the bounding area as each geometric primitive is processed. In an embodiment a bounding region of each geometric primitive is a rectangular region. The bounding region of each geometric primitive is then compared with the bounding area of the rendered image stored in bounding area memory . In an embodiment the bounding area memory is a register storing minimum and maximum x and y coordinates of the bounding area. In a further embodiment the graphics processing subsystem stores a copy of the bounding area memory in additional memory such as additional memory shown in to facilitate access by the device driver.

If the bounding rectangle of the primitive falls outside of the bounding area the bounding area is updated to include the bounding rectangle of the primitive. In an embodiment the bounding area is updated by setting the minimum x and y values in bounding area memory to the minimum of the minimum x and y values of the bounding region of the geometric primitive and the previous minimum x and y values of the bounding area memory . Similarly the maximum x and y values in the bounding area memory are set to the maximum of the maximum x and y values of the bounding region of the geometric primitive and the previous maximum x and y values of the bounding area memory .

The updated bounding area is then stored in bounding area memory . This comparison is repeated during the rendering of each geometric primitive. Once all of the geometric primitives in a frame have been processed by rasterizer stage the bounding area memory will contain the bounding area for the final rendered image. The memory buffers can then be cleared using the values of the bounding area memory . In a further embodiment the values of the bounding area memory are saved to be used in clearing a future frame such as when using the graphics processing subsystem in discussed above. Additionally the rasterizer stage can clear the values of the bounding area memory prior to processing a new frame.

The raster operation stage determines the bounding area in a similar manner to the rasterizer discussed in . The raster operation stage determines a bounding region for the set of pixels associated with each geometric primitive as it is processed by the graphics processing subsystem . The raster operation stage processes the set of pixels associated with a geometric primitive and may discard some pixels as a result of depth testing stencil masking or other operations. The minimum and maximum x and y values of the remaining pixel set are then compared with the bounding area of the rendered image stored in bounding area memory . If the extents of the remaining pixel set fall outside of the bounding area stored in bounding area memory the bounding area is expanded to include the remaining pixel set.

The updated bounding area is then stored in bounding area memory . This comparison is repeated during the rendering of each geometric primitive. Once all of the geometric primitives in a frame have been processed by raster operation stage the bounding area memory will contain the bounding area for the final rendered image. The memory buffers can then be cleared using the values of the bounding area memory . In a further embodiment the values of the bounding area memory are saved to be used in clearing a future frame such as when using the graphics processing subsystem in discussed above. Additionally the raster operation stage can clear the values of the bounding area memory prior to processing a new frame.

In an embodiment of method discussed above the bounding area for a frame is computed as the geometry is being rendered. Upon completion of the computation of the bounding area the bounding area is used almost immediately to clear one or more memory buffers. In one implementation of method a device driver reads the bounding area values from the bounding area memory or from a copy of the bounding area memory stored in additional memory and then sends a clear command to the graphics processing subsystem. In an embodiment the clear command specifies the bounding area to be cleared for example by including the minimum and maximum x and y coordinates of the bounding area. This type of clear instruction is referred to as a direct clear instruction. The device driver must quickly read the bounding area from the graphics processing subsystem and issue a clear command. Otherwise the graphics processing subsystem will be idle waiting for the device driver.

A further embodiment of the invention avoids the possibility of idling the graphics processing subsystem by employing a different type of clear instruction. In this embodiment a clear instruction directs the graphics processing subsystem to clear an area specified by the values stored in the bounding area memory. The device driver can send this instruction referred to as an indirect clear instruction to the graphics processing subsystem without knowing the values specifying the bounding area. To execute this instruction the graphics processing subsystem accesses the bounding area memory to determine the bounding area and performs a clear operation in the appropriate memory buffer over the bounding area. In an embodiment this clear instruction can be stored in a command buffer well in advance of its execution by the graphics processing subsystem. In this embodiment the graphics processing subsystem retrieves and executes instructions from the command buffer in the order they were written by the device driver.

In yet a further embodiment both types of clear instructions can be combined to efficiently clear all of the memory buffers in a rendering system such as that described with reference to . illustrates an embodiment of a method suitable for use with this type of rendering system. At step the bounding area memory defining the bounding area of a frame is cleared to a default value. In an embodiment the minimum extents of the bounding area are set to a default maximum value and the maximum extents of the bounding area are set to a default minimum value so that the comparison test as described above is performed correctly for the first geometric primitive processed by the graphics processing subsystem.

At step a first frame is rendered to a first memory buffer using the supplemental memory buffers as needed. As the geometric primitives of the first frame are rendered the graphics processing subsystem determines the values of a first bounding area. The values of the first bounding area are stored in the bounding area memory of the graphics processing subsystem.

At step the first memory buffer is connected with the display device so that the first frame is displayed. While the contents of the first memory buffer is being displayed the graphics processing subsystem begins the rendering of a second frame. In order to render the second frame at step a second memory buffer is cleared. During the rendering of the second frame the entire second memory buffer must be cleared rather than a small portion associated with a bounding area. However as discussed below during subsequent iterations of this method step only needs to clear a bounding area associated with the second memory buffer.

At step any supplemental memory buffers used to render the first frame such as a depth buffer are cleared so they can be reused to render a second frame. The supplemental buffers are cleared using the bounding area values stored in the bounding area memory. In an embodiment the device driver clears the supplemental memory buffers using an indirect clear command. As described above the indirect clear command can be issued by the device driver well in advance of its execution by the graphics processing subsystem. This ensures that the graphics processing subsystem is not delayed following the completion of rendering in step to wait for the device driver to read the bounding area memory.

At step the values of the first bounding area are copied to memory for future use as discussed below. Following step step resets the values of the bounding area memory similar to step discussed above.

Once the second and supplemental memory buffers have been cleared step renders the second frame to the second memory buffer using the supplemental memory buffers as needed. As the geometric primitives of the second frame are rendered the graphics processing subsystem determines the values of a second bounding area. The values of the second bounding area are stored in the bounding area memory of the graphics processing subsystem.

At step the second memory buffer is connected with the display device so that the second frame is displayed. While the contents of the second memory buffer are being displayed the graphics processing subsystem begins the rendering of a third frame. The third frame can be rendered into the now unused first memory buffer. In order to render into the first memory buffer the first memory buffer must be cleared of the first frame and the supplemental buffers must be cleared of the second frame. At step the first memory buffer is cleared using the first bounding area values previously copied at step . In an embodiment the device driver issues a direct clear instruction including the values of the first bounding area to the graphics processing subsystem. Because of the substantial amount of time typically required to complete steps through the device driver has sufficient time to read the first bounding area values and to issue a direct clear instruction.

At step the supplemental memory buffers used to render the second frame are cleared so they can be reused to render a third frame. The supplemental buffers are cleared using the second bounding area values stored in the bounding area memory. In an embodiment the device driver clears the supplemental memory buffers using an indirect clear command.

At step the second bounding area values are copied from the bounding area memory to memory for future use in clearing the second memory buffer similar to step discussed above.

Following completion of step the graphics processing subsystem is ready to render a third frame. For the third and subsequent frames the method can be repeated beginning with step . In this embodiment all odd numbered frames will be rendered to the first memory buffer and all even numbered frames will be rendered to the second memory buffer. Additionally step which initially required the entire second buffer to be cleared can be modified during subsequent executions of method to clear only the bounding area associated with the second memory buffer. The bounding area associated with the second memory buffer is copied to memory in step . In an embodiment the device driver issues a direct clear instruction including the values of the second bounding area to the graphics processing subsystem similar to step .

This invention provides a very efficient way to clear memory buffers used to create rendered images by only clearing the portion of the memory buffer changed by a previous frame. Although the invention has been discussed with respect to specific examples and embodiments thereof these are merely illustrative and not restrictive of the invention. For example the invention can be used by a graphics processing subsystem with three or more display memory buffers rather than merely two display memory buffers as discussed above. Additionally although the use of bounding areas is discussed with reference to rendering geometric primitives the invention can be applied to any output of the graphics processing subsystem such as bitmaps which are typically used to create text labels on parts of a model rendered by a three dimensional modeling application.

A further embodiment of the invention performs other types of graphics operations instead of clears using the bounding area. For example accumulation operations which blend pixels from several images into a supplemental display memory buffer can be performed faster when the clear color is black by only accumulating pixels within the bounding area of an image to the supplemental display memory buffer. In another example blit operations that copy pixels from a source image to a destination image only need to copy pixels from the area clipped by the bounding area of the source image. This example can be applied when the source and destination images do not overlap and the destination image area does not intersect the bounding area. Thus the scope of the invention is to be determined solely by the claims.

