---

title: Centralized adaptive network memory engine
abstract: There is a constant battle to break even between continuing improvements in DRAM capacities and the growing memory demands of large-memory high-performance applications. Performance of such applications degrades quickly once the system hits the physical memory limit and starts swapping to the local disk. We present the design, implementation and evaluation of Anemone—an Adaptive Network Memory Engine—that virtualizes the collective unused memory of multiple machines across a gigabit Ethernet LAN, without requiring any modifications to the either the large memory applications or the Linux kernel. We have implemented a working prototype of Anemone and evaluated it using real-world unmodified applications such as ray-tracing and large in-memory sorting. Our results with the Anemone prototype show that unmodified single-process applications execute 2 to 3 times faster and multiple concurrent processes execute 6 to 7.7 times faster, when compared to disk based paging. The Anemone prototype reduces page-fault latencies by a factor of 19.6—from an average of 9.8 ms with disk based paging to 500 μs with Anemone. Most importantly, Anemone provides a virtualized low-latency access to potentially “unlimited” network memory resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07925711&OS=07925711&RS=07925711
owner: The Research Foundation of State University of New York
number: 07925711
owner_city: Binghamton
owner_country: US
publication_date: 20071215
---
The present application claims benefit of priority from U.S. Provisional Patent Application No. 60 870 320 filed Dec. 15 2006 the entirety of which is expressly incorporated herein by reference.

Rapid improvements in DRAM capacities have been unable to keep up with the unprecedented the growth in memory demands of applications such as multimedia graphics processing high resolution volumetric rendering weather prediction large scale simulations and large databases. The issue is not whether one can provide enough DRAM to satisfy these modern memory hungry applications rather provide more memory and they ll use it all up and ask for even more. Simply buying more memory to plug into a single machine is neither sustainable nor economical for most users because 1 the price per byte of DRAM within a single node increases non linearly and rapidly 2 memory bank limitations within commodity nodes prevent unrestricted scaling and 3 investment in specialized large memory hardware is prohibitively expensive and such technology quickly becomes obsolete.

In this constant battle to break even it does not take very long for large memory applications to hit the physical memory limit and start swapping or paging to physical disk which in turn throttles their performance. At the same time it is often the case that while memory resources in one machine might be heavily loaded large amounts of memory in other machines in a high speed LAN might remain idle or under utilized. In typical commodity clusters one often sees a mixed batch of applications of which some have very high memory demands while most have only low or moderate demands. Consequently instead of paging directly to a slow local disk one could significantly reduce access latencies by first paging over a high speed LAN to the unused memory of remote machines and then turn to disk based paging only as the last resort after exhausting the available remote memory. Remote memory access can be viewed as another level in the traditional memory hierarchy which fills the widening performance gap between very low latency access to main memory and high latency access to local disk.

Recent years have also seen a phenomenal rise in affordable gigabit Ethernet LANs that provide low latency support for jumbo frames packet sizes greater than 1500 bytes and offer attractive cost to performance ratios. An interesting question naturally follows from the above discussion Can we transparently virtualize or pool together the collective unused memory of commodity nodes across a high speed LAN and enable unmodified large memory applications to avoid the disk access bottleneck by using this collective memory resource Prior efforts 6 11 10 17 19 12 20 23 to address this problem have either relied upon expensive interconnect hardware ATM Myrinet Infiniband or used bandwidth limited 10 100 Mbps networks that are far too slow to provide meaningful application speedups. In addition extensive changes were often required either to the large memory applications or the end host operating system. Note that the above research question of transparent remote memory access is different from the research on Software Distributed Shared Memory DSM 9 systems that permits nodes in a network to behave as if they were shared memory multiprocessors often requiring use of customized application programming interfaces.

Experiences in the design implementation and evaluation of the Adaptive Network Memory Engine Anemone system are described. Anemone virtualizes the collective unused memory resources across nodes in a commodity gigabit Ethernet LAN and allows unmodified memory hungry applications to transparently benefit from low overhead access to potentially unlimited remote memory resources. The Anemone system makes the following specific contributions. 1 Anemone presents a unified virtual interface for each memory client to access an aggregated pool of remote memory. 2 Any application can benefit from Anemone without requiring any code changes recompilation or relinking. Anemone system is implemented in pluggable kernel modules and does not require any changes to the core operating system. 3 Anemone is designed to automatically adapt as the applications memory requirements change and or the cluster wide memory resource availability changes. It effectively isolates the clients from changes in the aggregate memory pool and isolates the memory contributors from changes in client memory requirements. 4 To the best of our knowledge Anemone system is the first attempt at evaluating the feasibility of remote memory access over commodity gigabit Ethernet with jumbo frame support.

Performance evaluations were conducted using two realworld unmodified applications ray tracing and large in memory sorting. Anemone reduces page fault latencies by a factor of 19.6 from an average of 9.8 ms with disk based paging to about 500 s with Anemone. Anemone speeds up single process large memory applications by a factor of 2 to 3 and multiple concurrent large memory applications by a factor of 6 to 7.7.

As shown in Anemone contains three main components Memory Engine Memory Servers and Memory Clients. The memory engine is a dedicated entity for global memory resource management that coordinates the interaction between the clients executing large memory applications and servers hosting remote memory. The memory engine itself is not the primary source of remote memory rather it helps to pool together and present a unified access interface for the remote memory resources across the gigabit network. The memory engine transparently maps the client memory requirements to available remote memory and hides the complexity of memory resource management from both memory clients and back end servers. The memory engine uses a lightweight window based Reliable Memory Access Protocol RMAP to communicate with both the memory clients and memory servers.

The client side face of the memory engine consists of a number of Virtual Access Interfaces VAI which are logical devices not physical devices that memory clients use to access remote memory. Memory access requests from the client are sent using RMAP to this remote VAI device in the form of read write requests. The engine can simultaneously support VAIs for multiple clients and also support multiple memory servers to contribute unused memory. Each VAI can have attributes such as logical capacity priority and reliability requirements.

Upon a write the Client Module sends the page to the engine which forwards the page to be stored on one of the back end memory servers. Successive pages including pages from the same client can be can be sent by the memory engine to any of the memory servers based upon different types of server selection algorithms. Upon a read the client sends a read request to the memory engine which then looks up its internal mapping tables to locate the server holding the requested page retrieves the page from that server and transmits it to the client.

The memory engine also maintains a cache of frequently accessed pages that it searches first before contacting a memory server. The memory engine uses a hash table to map clients pages to servers. The hash key a page s identity is composed of the triplet Client IP address Offset VAI id. The engine can host many VAIs each having one VAI id. The offset in the triplet is specified in clients read write requests. The engine maintains a small request queue for each client to service groups of read write requests. Since the engine can handle any number of servers acknowledgment pages coming from different servers destined for a particular client may arrive out of order. Hence the queue is searched upon receipt of a reply from a server. This allows for a pipelined stream of page data from multiple servers to be returned to the client.

The memory servers store client s data pages that are forwarded by the memory engine. Servers may or may not be a general purpose machine in the cluster. Each memory server can choose to set aside a portion of its unused memory for use by remote clients. Depending upon each server s own memory requirements the amount of contributed memory may change dynamically in coordination with the memory engine. The memory engine balances the load among multiple memory servers based upon a usage to capacity ratio. A more complete criteria might include ratio of number of pages stored at each server to its contributed capacity the frequency of read requests being made to each server or the CPU utilization at each server. Just like the engine each server also uses a hash table keyed by the identity of a page. The difference is that the data attached to a unique key in the engine is the location of a page whereas it is the page itself in the server.

To maintain transparency for large memory applications the memory client is designed as a pseudo block device PBD that appears to be a regular block device to the client system while in reality it is a convenient frontend to transparently manage remote memory access. The PBD is configured as a primary swap partition to which the swap daemon can send read write requests at runtime in response to page faults from large memory applications. The virtual memory subsystem interacts with the swap daemon to page out page in memory contents to from the PBD. The fact that the primary swap device is in fact remote memory of one or more memory servers is transparent to both the application and swap daemon. The PBD is a self contained pluggable kernel module that transparently sits above the network device driver and does not require any changes either to the memory intensive application or to the client s operating system. The PBD includes a small write back cache to store often requested pages locally and a pending queue of requests to be sent out to the VAI. The size of the cache and the queue together is bounded to a preallocated 16 MB of memory to avoid creating additional memory pressure. For write requests if the page already resides in the cache or if there is space available then the page is written to cache. If the number of pages in the cache exceeds a high water mark victim pages are evicted based on LRU policy. For read requests a page that already resides in the cache is returned directly to the swap daemon. Upon a cache miss the read request is forwarded to the VAI. If the cache and the pending request queue are full the swap daemon needs to wait because requests are being generated faster than can be transmitted reliably.

The choice of communication protocol in Anemone is guided by the following considerations. Use of TCP for reliable communication turns out to be too expensive because it incurs an extra layer of processing in the networking stack. Anemone also does not need TCP s features of congestion control and in order byte stream delivery. Additionally Anemone does not need network layer IP routing functionality because it operates within a LAN. The need for packet fragmentation is eliminated because gigabit networks support the use of Jumbo frames which allowMTU Maximum Transmission Unit sizes larger than 1500 bytes typically between 9 KB and 16 KB . Thus an entire 4 KB or 8 KB memory page including headers can fit inside a single jumbo frame.

Consequently Anemone uses its own reliable window based datagram protocol called RMAP for communication but without the requirement of in order delivery. All the communication modules in the clients engine and the servers operate right above the network device driver. The RMAP implementation includes five network functions. REGister and UNREGisterconnect and disconnect a client with the memory engine. When the engine receives a REG request it allocates a VAI and returns a file handle for it. When the engine receives an UNREG request it deallocates the VAI and all meta data associated with that client and frees remote pages belonging to the clients. READ WRITE and their associated ACK messages provide basic reliability for reading and writing between the clients engine and servers. If a READ WRITE communication does not receive its associated acknowledgment after a given amount of time the request is retransmitted. Finally a STAT function is made available to allow the client to gather information about its corresponding VAI s in the engine such as available memory and average workload.

A lightweight flow control strategy has also been implemented in RMAP. As paging requests arrive from the client s swap daemon a fixed size FIFO transmission queue fills up. To empty the transmission queue the client module uses a window to limit the number of outstanding network memory requests. When the queue is full the client stalls any upper layer paging activity until ACKs come in and shrink the queue. These ACKs are allowed to arrive out of order. The RMAP implementation also provides several other tunable parameters. The first parameter is the window size which controls the number of packets waiting for acknowledgment in the transmission queue. The second parameter is a retransmission timeout which triggers RMAP to check if there are any packets awaiting retransmission. The third parameter is the per packet retransmission latency i.e. the amount of time between successive retries of the same request. Finally the fourth parameter specifies the wait latency between successive packet transmissions.

Anemone s implementation sits directly on top of the data link layer. In Linux a software based interrupt mechanism called a softirq handles the demultiplexing of incoming packets for Layer 3 protocols. The Anemone module uses a Linux hook called NetFilter to receive Anemone specific packets after the softirq fires. From here Anemone processes the request schedules communication and returns control to the kernel all in one shot. The hash tables used in the engine and server consume very little memory. The number of buckets in the hashtable remains static upon startup and are allocated using the get free pages call. Linked lists contained within each bucket hold bucket entries managed by the Linux slab allocator instead of the kmalloc mechanism which causes fragmentation .

An experimental prototype involves 8 machines one client one engine and six memory servers with more nodes being added as we write this paper. The client engine and server components are implemented in Linux 2.6 using loadable kernel modules. All machines contain 2.6 3.0 GHz Pentium Xeon processors. The client machine has 256 MB of memory Server 1 has 2.0 GB Server 2 has 3.0 GB Servers 3 through 6 have 1.0 GB of memory and the Engine has 1.0 GB. All machines use Intel Pro 1000 MT gigabit network cards and are connected by an 8 port SMC Networks gigabit Ethernet switch supporting jumbo frames. For disk based tests we used a Western Digital WD400BB disk with 40 GB capacity and 7200 RPM speed. Of the 8 GB of remote memory available to use the server machines themselves consume a significant part for kernel memory. A header is attached to each 4 KB page received and stored by the servers. The slab allocator assigns a complete 4 KB page to this extra header in addition to the 4 KB page of data thus reducing the effective remote memory available to less than 4.0 GB. We plan to incorporate a scatter gather style solution to this issue by using the Linux slab allocator to separate the header from the page data.

A page in operation is more time critical than page out operation because application cannot proceed without the page. Here we examine the various components of the latency involved in processing a page in request using Anemone. A request for a 4 KB page involves the following steps 1 A request is transmitted from the client to the engine. 2 The engine requests the page from a server. 3 The server returns the requested page to the engine. 4 The engine returns the page back to the client. The entire sequence requires 4 network transmissions. Table 1 shows the average amount of time consumed at each of these 4 stages over 1000 different randomized read requests to the Anemone system providing 2 GB of remote memory. It turns out that the actual computation overhead at the client the engine and the server is negligibly small less than 10 microseconds. The majority of the latency involved is spent in the client engine and engine server communication.

The client latency includes making a read write request either via the swap daemon or via a system call invoking the client module and sending off the request to the engine. The computation values are measured by time stamping the request when it is generated and subtracting the timestamp when the request is completed.

For the engine this time includes the difference between the time the page out page in request is received and the time when it finally responds to the client with an ACK or a data page. For the server it is simply the difference between time the request for the page arrives and the time the reply is transmitted back to the engine. These computation times are also small and clearly demonstrate the bottleneck the network creates.

The total round trip paging latency for Anemone is consistently around 500 microseconds with around 250 microseconds between each hop. The time spent in completing a ping request on our network between two machines takes an average of 150 microseconds which is a good lower bound on how fast Anemone can get using our RMAP protocol. Hence there is still about 100 microseconds of room to improve in Anemone at each round trip hop when compared to a baseline ping. Furthermore the time to place 4k bits on a gigabit link is not much more than 4 microseconds which means that a great deal of the transmission time is spent in sending transmission receiving interrupts allocating ring buffers and sending the data over the bus to the NIC. Optimizing these pieces is not easy to do without significant modifications. Conclusively the kernel based version of Anemone is 19.6 times faster than disk based block requests that require seek rotation.

In order to compare read write latencies obtained with Anemone against those obtained with disk we next plot the distribution of observed read and write latencies for sequential and random access patterns. compare the cumulative distributions of latencies with disk and Anemone for random and sequential reads respectively. Though real world applications rarely generate purely sequential or completely random memory access patterns these graphs provide a useful measure to understand the underlying factors that impact application execution times. For random read requests in most requests to disk experience a latency between 5 to 10 milliseconds. On the other hand most requests in Anemone experience only around a 500 microsecond latency. In our most recent experiments with a distributed Anemone architecture we have measured even lower latencies of 210 microseconds due to absence of the memory engine. For sequential read requests in the disk shows a slightly superior latency distribution than Anemone. Most sequential requests are serviced by disk within 3 to 5 microseconds because sequential read accesses fit well with the motion of the disk head eliminating seek and rotational overheads. In contrast Anemone still delivers a range of latency values most of them still around 500 microseconds mainly because network communication latency dominates though it is masked to some extent by the prefetching performed by the swap daemon or file system. The write latency distributions for both disk and Anemone are observed to be very similar. Most latencies are close to 10 microseconds because writes typically return after writing to the buffer cache. Due to space constraints the corresponding figures for write latency distribution can be found in 15 .

This section evaluates the performance improvements seen by two unmodified single process large memory applications using the Anemone system. The first application is a graphics rendering program called POV Ray 21 . The POV Ray application was used to render a scene within a square grid of unit spheres. The size of the grid was increased gradually to increase the memory usage of the program in 100 MB increments. shows the completion times of these increasingly large renderings up to 1.2 GB of memory versus the disk using an equal amount of local swap space. The figure clearly shows that Anemone delivers increasing application speedups with increasing memory usage and is able to improve the execution time of a single process POV ray application by a factor of up to 2.9 for 1.2 GB memory usage. The second application is a large in memory Quick sort introsort program that uses an STL based implementation from SGI 22 with a complexity of O N log N comparisons. We sorted randomly populated large in memory arrays of integers. clearly shows that Anemone again delivers application speedups by a factor of up to 1.8 for single process Quicksort application having 1.2 GB memory usage.

In this section the performance of Anemone was tested under varying levels of concurrent application execution. Multiple concurrently executing memory intensive processes tend to stress the system by competing for computation memory and I O resources and by disrupting any sequentiality in paging activity. show the execution time comparison of Anemone and disk as the number of POV ray and Quick sort processes increases. The execution time measures the time interval between the start of the multiple process execution and the completion of last process in the set. Each process consumes 100 MB of memory. As the number of processes increases the overall remote memory usage also increases. The figures show that execution times using disk based swap increase steeply with an increasing number of concurrent processes. This is because the paging activity gradually loses the sequential access property as the number of processes increases. This makes the disk seek and rotational overheads a dominant factor in disk I O latency. On the other hand Anemone reacts very well to concurrent system activity and the total execution time increases very slowly. This is because unlike disk based paging Anemone encounters an almost constant paging latency over the network even as the paging activity loses sequentiality of access. With 12 concurrent memory intensive processes Anemone achieves speedups of a factor of 7.7 for POV ray and a factor of 6.0 for Quick sort.

Anemone is the first system that provides unmodified large memory applications with completely transparent and virtualized access to cluster wide remote memory over commodity gigabit Ethernet LANs. The earliest efforts at harvesting idle remote memory resources aimed to improve memory management recovery concurrency control and read write performance for in memory database and transaction processing systems 14 13 4 16 . The first two remote paging mechanisms 6 11 incorporated extensive OS changes to both the client and the memory servers and operated upon 10 Mbps Ethernet. The Global Memory System GMS 10 was designed to provide network wide memory management support for paging memory mapped files and file caching. This system was also closely built into the end host operating system and operated upon a 155 Mbps DEC Alpha ATM Network. The Dodo project 17 1 provides a user level library based interface that a programmer can use to coordinate all data transfer to and from a remote memory cache. Legacy applications must be modified to use this library.

Work in 19 implements a remote memory paging system in the DEC OSF 1 operating system as a customized device driver over 10 Mbps Ethernet. A remote paging mechanism 20 specific to the Nemesis 18 operating system was designed to permit application specific remote memory access and paging. The Network RamDisk 12 offers remote paging with data replication and adaptive parity caching by means of a device driver based implementation.

Other remote memory efforts include software distributed shared memory DSM systems 9 . DSM systems allow a set of independent nodes to behave as a large shared memory multi processor often requiring customized programming to share common objects across nodes. This is much different from the Anemone system which allows pre compiled high performance applications to execute unmodified and use large amounts of remote memory provided by the cluster. Samson 23 is a dedicated memory server over Myrinet interconnect that actively attempts to predict client page requirements and delivers the pages just in time to hide the paging latencies. The drivers and OS in both the memory server and clients are also extensively modified.

Simulation studies for a load sharing scheme that combines job migrations with the use of network RAM are presented in 25 . The NOW project 2 performs cooperative caching via a global file cache 8 in the xFS file system 3 while 24 attempts to avoid inclusiveness within the cache hierarchy. Remote memory based caching and replacement replication strategies have been proposed in 5 7 but these do not address remote memory paging in particular.

The design implementation and evaluation of the Adaptive Network Memory Engine Anemone system that enables unmodified large memory applications to transparently access the collective unused memory resources of nodes across a gigabit Ethernet LAN is presented. A working Anemone prototype was implemented and performance evaluations conducted using two unmodified real world applications namely ray tracing and large in memory sorting. When compared to disk based paging Anemone speeds up single process applications by a factor of 2 to 3 and multiple concurrent processes by a factor of 6 to 7.7. The scalability and fault tolerance of Anemone might be improved using a completely peer to peer memory sharing architecture which does not include a memory engine. The reliability of Anemone might be improved using page replication for higher availability. Another promising direction is to use compression of pages to reduce communication and increase the effective memory capacity.

Although this invention has been illustrated by reference to specific embodiments it will be apparent to those skilled in the art that various changes and modifications may be made which clearly fall within the scope of the invention. The invention is intended to be protected broadly within the spirit and scope of the appended claims.

