---

title: Accessing function from different addressing bit system
abstract: A system and method of accessing functions includes running n-bit based code in an n-bit supporting system environment. An m-bit based provider object is instantiated in an m-bit hardware and operating system environment server. The provider object provides an interface between the n-bit based code and m-bit based server functions. m-bit based server functions are accessed from the n-bit based code via the m-bit based provider object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08813104&OS=08813104&RS=08813104
owner: CA, Inc.
number: 08813104
owner_city: Islandia
owner_country: US
publication_date: 20071217
---
With the widespread availability of 64 bit hardware and operating systems application vendors are moving toward providing 64 bit server applications to the exclusion of 32 bit server applications. Many legacy applications were written with 32 bit addressing for 32 bit hardware and operating systems. While many 64 bit hardware and operating systems may run the 32 bit applications certain application settings and metrics might only be available through 64 bit APIs from 64 bit code.

A method of accessing functions includes running n bit based code in an n bit or m bit hardware and operating system environment. An m bit system may also support an n bit mode. An m bit based provider object is instantiated in an m bit hardware and operating system environment server which may or may not be the same system running the n bit based code. The provider object provides an interface between the n bit based code and m bit based server functions. m bit based server functions are accessed from the n bit based code via the m bit based provider object.

In various embodiments when the n bit based code is running remotely from the m bit based provider object the n bit based code may be running on n bit based operating system and hardware or may be running in an n bit mode under an m bit operating system and hardware or may also run on an n bit operating system on m bit capable hardware.

In one embodiment a system includes a provider that runs in an m bit environment and exposes m bit functionality of an application through m bit based APIs to m bit functions. The provider exposes such APIs to n bit based agents via component object model COM interfaces.

In a further embodiment a computer readable medium has instructions for causing a computer to implement a method of accessing functions. The method includes instantiating an m bit based provider object in an m bit hardware and operating system environment server wherein the provider object provides an interface between the n bit based code and m bit based server functions. n bit based method calls are received from an n bit based agent. m bit based server functions are accessed from the n bit based agent via the m bit based provider object.

In the following description reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific embodiments which may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that structural logical and electrical changes may be made without departing from the scope of the present invention. The following description of example embodiments is therefore not to be taken in a limited sense and the scope of the present invention is defined by the appended claims.

The functions or algorithms described herein may be implemented in software or a combination of software and human implemented procedures in one embodiment. The software may consist of computer executable instructions stored on computer readable media such as memory or other type of storage devices. The term computer readable media is also used to represent any means by which the computer readable instructions may be received by the computer such as by different forms of wired or wireless transmissions. Further such functions correspond to modules which are software hardware firmware or any combination thereof. Multiple functions may be performed in one or more modules as desired and the embodiments described are merely examples. The software may be executed on a digital signal processor ASIC microprocessor or other type of processor operating on a computer system such as a personal computer server or other computer system.

A method and system for managing m bit applications from n bit code is described. Functions in the m bit applications are accessed by the n bit code by use of COM mechanisms. Several embodiments and variations are described. Some embodiments allow reuse of existing 32 bit code with access to 64 bit extensions without having to port or test the existing code. Such reuse can help avoid interoperability issues with existing large infrastructure applications that may not be available as 64 bit applications.

In one embodiment application is a 64 bit Windows Application exposing management and configuration interfaces through Microsoft Windows PowerShell with application specific .NET extensions. An example for such an application is Microsoft Exchange 2007.

Agent in one embodiment is an application module running in isolated 32 bit WoW64 Windows on Windows 64 mode for managing or monitoring an application running in 64 bit mode. Typically agent provider and application may be running on the same system which supports both n and m bit code communicating via a COM interface . In a further embodiment the application associated with agent may be running on a client machine while the 64 bit environment may be a server communicating over a network or other communication medium via distributed component object model DCOM interface .

Access to application management and configuration functionality is provided by provider which may be a .NET application module running in 64 bit mode. The provider exposes service APIs application program interfaces as COM interfaces and may be implemented as a standard .NET Interop assembly. These types of assemblies are inproc COM servers contained in dynamic link libraries DLLs . Note that similar concepts may be used in other object based frameworks in further embodiments.

In order to gain access to the m bit application management and configuration interface the assembly is registered as a local out of proc m bit COM server. This can be achieved by means of DLL surrogation. DLL surrogation may be implemented by using the m bit version of the operating system provided default DLL surrogation host DLLHost.exe or by implementing a custom DLL surrogation host which may be written in C in one embodiment.

In an alternative embodiment the provider exposes service APIs application program interfaces as COM interfaces and may be implemented as a standalone m or 64 bit .NET application implementing a local COM out of proc server as an EXE.

Either implementation of the provider may be installed and configured on a computer running the application . Provider services can be accessed by an agent running locally that is on the computer running the application and the provider by instantiating a server object through COM APIs or by an agent running remotely through DCOM APIs.

In one embodiment agent is a 32 bit COM client. In order to access any of the m bit functionality exposed by the provider the agent creates an instance of the provider using the providers CLSID as indicated at in which is a flow diagram illustrating accessing interactions between agent provider and application with extensions or functions . Time is represented in the vertical direction in .

Initially a global provider object is created that remains alive for the lifetime of the agent application. For thread safety and improved error handling the agent instantiates short lived provider objects whenever it needs to access m bit functionality.

Since provider in one embodiment is an out of proc COM server the instance obtained by the agent application is just a proxy object that interacts with the COM runtime services . Proxy object may be referred to as a COM server proxy stub.

When the agent instantiates the global provider object the COM runtime creates a running instance of the provider application in m bit mode as indicated at . Launching the provider application can be a time consuming operation and the global provider object in the agent is kept alive for the lifetime of the agent application to prevent the provider application to go down requiring frequent re launches. Any short lived provider objects the agent might instantiate are serviced by the process that is started by the COM runtime when the global provider is instantiated by the agent so creating a short lived provider object involves little overhead.

On instantiation the provider performs initializations to be ready to execute requests from the agent. In particular an invoker object is created at that is used for executing the m bit application expressions later on . The invoker object exists for the lifetime of the provider object and handles repeated execution of m bit application expressions.

Even though the user interface of m bit application is a console based text application m bit application does not manipulate text like traditional shells do but rather works on objects that live in the Microsoft .NET Framework. For performance reasons and improved error handling traditional text based shell processing is not used in one embodiment redirection text file parsing but .NET objects are directly manipulated. Therefore the invoker object creates a so called run space that represents a m bit application object context with application specific extensions. The run space is kept alive during the lifetime of the invoker object and thus the provider object.

The invoker object initializes the runspace with some common definitions that are frequently referred to in the upcoming method calls . Returns are indicated at and . The common definitions may be variables like for example the name of the local computer 

Alternatively utility functions consisting of m bit application code that can be called later from the service methods of the provider preventing code duplication and improving maintainability.

After these initializations all calls return and the agent has obtained an initialized provider proxy object . Through this object the agent can now call any service methods the provider exposes thereby accessing m bit functionality that is otherwise not available.

To invoke an m bit provider method the agent calls the corresponding method on the provider proxy object it has obtained at . Three different types service methods may be implemented by provider in various embodiments.

A first service method is referred to as a simple method. Simple methods are declared with zero or more formal parameters that are passed by value on invocation. Simple methods may or may not return a result.

Complex methods may be declared with zero or more formal parameters that are passed by value and one or more formal parameters that are passed by reference on invocation. Complex methods may be utilized when several pieces of information are being retrieved from m bit mode through just one method invocation. Although the information could be retrieved by multiple simple method call this would involve multiple transitions between n and m bit mode which are performance intense. Utilizing complex methods reduces the number of n m bit transitions and thus is a means of performance optimization. Complex methods typically return a result as well.

Simple and complex methods may have m bit application code embedded that is evaluated during method execution at . They are pre wired for the functionality they implement. In a third method generic methods allow the agent to pass raw application code directly from n bit mode for evaluation in the m bit application with application extensions context and may receive back a result of a specific data type. In one embodiment such code may be commands represented in script code. Generic methods allow extensions of the m bit related agent functionality without updating the provider. Generic methods can also be used to execute user defined m bit application scripts through the provider when a certain condition in the agent occurs e.g. agent monitors storage fragmentation. User configures the agent to treat 80 storage fragementation as critical and defines a m bit application script to take the storage offline and defragment it as action. Once the fragmentation goes critical the agent retrieves the user script and without any knowledge of its content it passes it through a generic method to the provider where it triggers the desired action in m bit mode .

Regardless of the method type the call in the agent on the provider proxy object will go into the COM runtime and any parameters passed to the method will be marshaled from n bit to m bit mode at and . The COM runtime invokes the desired service method on a specific instance of a provider object created earlier in the provider application through the .NET Framework. The method receives the marshaled parameters and builds an m bit application expression which might be just a single cmdlet invocation or a more complex m bit application script out of the parameters at . This m bit application expression is then passed to the invoker which runs it through the m bit application with application extensions context . Executing the expression normally returns a .NET object or a collection of .NET objects. If any error occurs an exception is thrown from the m bit application context which will be caught by the invoker and be translated into an empty result.

The service method of the provider object processes the result of the m bit application invocation and returns the requested information back to the caller. Depending on the method type the result value and or the content of actual parameters passed by reference is marshaled from m to n bit mode by the COM runtime . In n bit mode the results are unmarshaled initial method invocation returns and the n bit agent has received the desired information from m bit mode.

The provider proxy object inside the agent can handle any number of method invocations as indicated at during its lifetime.

A block diagram of one or more example computer systems that execute programming for performing the above methods is shown in . A general computing device in the form of a computer may include a processing unit memory removable storage and non removable storage . Memory may include volatile memory and non volatile memory . Computer may include or have access to a computing environment that includes a variety of computer readable media such as volatile memory and non volatile memory removable storage and non removable storage . Computer storage includes random access memory RAM read only memory ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM flash memory or other memory technologies compact disc read only memory CD ROM Digital Versatile Disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium capable of storing computer readable instructions. Computer may include or have access to a computing environment that includes input output and a communication connection . The computer may operate in a networked environment using a communication connection to connect to one or more remote computers. The remote computer may include a personal computer PC server router network PC a peer device or other common network node or the like. The communication connection may include a Local Area Network LAN a Wide Area Network WAN or other networks.

Computer readable instructions stored on a computer readable medium are executable by the processing unit of the computer . A hard drive CD ROM and RAM are some examples of articles including a computer readable medium.

The Abstract is provided to comply with 37 C.F.R. 1.72 b to allow the reader to quickly ascertain the nature and gist of the technical disclosure. The Abstract is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims.

