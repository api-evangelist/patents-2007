---

title: Memory block compaction method, circuit, and system in storage devices based on flash memories
abstract: A solution for managing a storage device based on a flash memory is proposed. A corresponding method starts with the step for mapping a logical memory space of the storage device (including a plurality of logical blocks) on a physical memory space of the flash memory (including a plurality of physical blocks, which are adapted to be erased individually). The physical blocks include a set of first physical blocks (corresponding to the logical blocks) and a set of second—or spare—physical blocks (for replacing each bad physical block that is unusable). The method continues by detecting each bad physical block. Each bad physical block is then discarded, so to prevent using the bad physical block for mapping the logical memory space.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07991942&OS=07991942&RS=07991942
owner: STMicroelectronics Pvt. Ltd.
number: 07991942
owner_city: Greater Noida (UP)
owner_country: IN
publication_date: 20070509
---
This application is related to U.S. patent application Ser. No. 12 075 991 now Pat. No. 7 882 301 entitled WEAR LEVELING IN STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD Ser. No. 11 801 687 entitled RESTORING STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD and Ser. No. 11 801 742 entitled MANAGEMENT OF ERASE OPERATIONS IN STORAGE DEVICES BASED ON FLASH MEMORIES which have a common filing date and owner and which are incorporated by reference.

Embodiments of the present invention relate to the storage device field. More specifically embodiments of the present invention relate to the management of storage devices based on flash memories.

Storage devices based on flash memories have become very attractive in recent years. For example they are commonly used as mass memories also known as solid state mass memories in data processing systems. These storage devices are compact robust and have low power consumption. Therefore they are advantageous especially in portable systems such as mobile telephones which are typically supplied by batteries.

Each flash memory used to implement the above mentioned storage devices can be erased only in blocks having a relatively large size for example 16 128 Kbytes . Therefore once data has been written into the flash memory this data cannot be updated any longer unless the corresponding whole block is erased . In order to emulate operation of a random access device such as in standard hard disks a translation layer is provided on top of the flash memory. The translation layer manages any update of the data stored in the flash memory by writing a new version thereof in a different area of the flash memory at the same time updating corresponding mapping information .

A problem of the flash memory is that some of its blocks may be defective or bad and then unusable. Typically the bad blocks are detected in a factory before shipping the storage device during a corresponding test process such as of the Electrical Wafer Sorting EWS type. Moreover the bad blocks may appear in the field during operation of the storage device . For example this happens when the erasure of a block fails because of an excessive wearing of its memory cells which endurance to the erasures is intrinsically limited .

In order to alleviate this problem it has been proposed to skip any bad block and to replace it with a next one in the flash memory that is good i.e. available to be used . The technique is well suited to a sequential use of the storage device however it is very difficult to apply when the storage device must support a random access.

Another approach that has been used consists of providing a set of spare or redundancy blocks which are reserved for replacing the bad blocks. The bad blocks are then mapped on the corresponding spare blocks by means of a replacement table for example of the associative type . Particularly for each bad block the replacement table stores an indication of the spare block to be used in substitution of the bad block. Before performing any operation on a current block of the flash memory an entry in the replacement table for the current block is searched. If the entry is not found the operation is performed on the good current block. Conversely the operation is performed on the spare block associated with the bad current block in the replacement table.

A drawback of the solution described above is that it involves a large waste of area of the flash memory for implementing the spare blocks. Indeed the spare blocks are used only when they must replace corresponding bad blocks. Otherwise the spare blocks are completely useless. As a result the number of spare blocks is generally maintained relatively low for example several units . However this strongly reduces the capability of ensuring the correct operation of the flash memory with a high number of bad blocks.

Moreover every operation on the flash memory requires the above mentioned search in the replacement table for a possible spare block associated therewith . Therefore this adversely affects an access time of the storage device.

In this respect it should be noted that the time that is spent to search an entry for the current block in the replacement table depends on its size. This further limits the number of spare blocks that can be provided. The problem is particularly acute when the flash memory has a very large size. Indeed the overhead in the access time increases with the number of the spare blocks so that it must be kept low in absolute terms to ensure an acceptable access time. Therefore the number of spare blocks decreases in relative terms as the size of the flash memory increases.

In general embodiments of the present invention are based on the idea of managing bad blocks dynamically.

More specifically an embodiment of the invention proposes a method for managing a storage device based on a flash memory. The method starts with the step for mapping a logical memory space of the storage device including a plurality of logical blocks on a physical memory space of the flash memory including a plurality of physical blocks which are adapted to be erased individually . The physical blocks include a set of first physical blocks corresponding to the logical blocks and a set of second or spare physical blocks for replacing each bad physical block that is unusable . The method continues by detecting each bad physical block. Each bad physical block is then discarded so as to prevent using the bad physical block for mapping the logical memory space.

A proposed implementation is based on the use of a bad block table stored in the flash memory and a corresponding unavailable list loaded in a working memory .

Moreover each new bad physical block may be added to the unavailable list during operation of the storage device in response to a failure of a corresponding erase operation .

Preferably the bad block table is created when the flash memory is formatted with each new bad physical block appearing later on that is identified by means of a corresponding flag .

The proposed solution is typically applied when a root physical block and one or more child physical blocks are used for each logical block.

A recovery procedure is also proposed for reducing the logical memory space when there are too many bad physical blocks.

For this purpose the empty logical blocks to be locked are preferably selected in a portion of the logical memory space that is not used to store meta data.

In an embodiment of the invention a garbage collection procedure is forced when the flash memory leaves a safe status and a current write operation involves an increase of the child physical blocks.

In addition the garbage collection procedure is forced when the flash memory enters a critical status and the current write operation involves an increase of the used root or child physical blocks.

The garbage collection procedure may be forced on a logical block having the minimum number of programmed physical sectors in its child physical block s .

Another embodiment of the invention proposes a method for managing a storage device based on a flash memory. The storage device emulates a logical memory space including a plurality of logical blocks each one having a plurality of logical sectors that are adapted to be written repeatedly . The logical memory space is mapped on a physical memory space of the flash memory including a plurality of physical blocks that are adapted to be erased individually with each one having a plurality of physical sectors that are adapted to be programmed once . Consecutive versions of the logical sectors of each logical block are stored in succession in the physical sectors of a root physical block and one or more child physical blocks when the root physical block is full . The method includes defining a mapping structure for mapping each logical sector on an associated physical sector of a corresponding physical block which stores the last version of the logical sector. For each written logical block having at least one logical sector that is written the mapping structure includes a sector map. The sector map has a field for each logical sector of the written logical block. The field stores an indication of the associated physical sector such as its physical offset in the physical block when the logical sector is written or a value equal to the indication of a predefined physical sector of the written logical block such as the first one when the logical sector is not written. A further field is used for storing an indication such as its position in the sector map of the logical sector being written in the predefined physical sector.

Moreover another embodiment of the invention proposes a data processing system including one or more storage devices.

The following discussion is presented to enable a person skilled in the art to make and use the invention. Various modifications to the embodiments will be readily apparent to those skilled in the art and the generic principles herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

With reference now to a mobile telephone is illustrated. The telephone is formed by several units that are connected in parallel to a communication bus . In detail a microprocessor P controls operation of the telephone . A RAM is directly used as a working memory by the microprocessor . Several peripheral units are further connected to the bus through respective drives . Particularly a storage device implements a solid state mass memory. The storage device is used to store data that should be preserved even when a power supply of the telephone is off for example a firmware of the microprocessor application programs and personal information of a user of the telephone such as an address book . Moreover the telephone includes input units for example a keypad a microphone and a camera and output units for example a display and a loudspeaker . A transceiver RX TX implements any communications with a telephone exchange not shown in the figure to send and receive information.

Passing now to the storage device is based on a flash memory . The flash memory includes a matrix of memory cells with NAND architecture not shown in the figure . The flash memory programs and reads the memory cells at the level of physical pages for example each one consisting of 528 bytes . On the other hand the memory cells are erased at the level of far larger physical blocks for example each one including 256 physical pages . Therefore once a physical page has been programmed so as to write the desired data into it this physical page cannot be updated any longer unless the whole respective physical block is erased or the update only involves the programming of its memory cells .

A control unit manages the flash memory so as to emulate a random access to the storage device . The control unit is based on a micro controller . The micro controller accesses a RAM being used as a working memory and a series of registers . An interface couples the micro controller with the flash memory another interface instead couples the same micro controller with the drive of the telephone for the storage device not shown in the figure .

Operation of the micro controlled is managed by firmware which is stored in the flash memory and then loaded at least partially into the RAM when the micro controller is running the firmware is initially installed onto the flash memory during a manufacturing process of the storage device.

A functional scheme of the same storage device is illustrated in . The flash memory provides a physical memory space . The physical memory space consists of its physical blocks which can be erased individually. Each physical block is identified by a corresponding physical block number for example of 12 bits for accessing up to 4096 physical blocks . In turn each physical block includes its physical pages which can be programmed only once for each memory cell and read individually. Each physical page is identified by a corresponding physical offset within the physical block of 8 bits in the example at issue wherein each physical block includes 256 physical pages .

The storage device emulates a logical memory space . The logical memory space consists of logical sectors for example each one of 512 bytes which can be written repeatedly to any value and read individually. The logical sectors are grouped into logical blocks for example each one including 256 logical sectors . Each logical block is identified by a corresponding logical block number for example again of 12 bits for accessing up to 4096 logical blocks . Each logical sector is identified by a corresponding logical offset within the logical block of 8 bits in the example at issue . The different versions of the logical sectors are written into corresponding physical sectors each one typically consisting of a single physical page . The physical sector includes a main area for storing the value of the logical sector and a spare area for storing service information i.e. 512 bytes and 16 bytes respectively in the example at issue .

The logical memory space consists of a predefined number NL of logical blocks for example NL 4096 for a logical memory space of 4096 256 512 512 Mbytes . In an embodiment of the present invention as described in detail in the following the physical memory space consists of a higher number NP of physical blocks. The number of physical blocks NP is equal to the number of logical blocks NL plus a number NS of spare blocks. The spare blocks NS consist of additional physical blocks that are available to replace any physical block that is bad. However unlike the static bad block management techniques that have been proposed in the past the spare blocks are not distinct from the other physical blocks and they are not necessarily all good . In other words the whole physical memory space including the spare blocks as well being indistinguishable from the other physical blocks is used to map the logical memory space with the bad physical blocks that are managed dynamically within it .

The proposed solution reduces any waste of area of the flash memory for implementing the spare blocks. Indeed no physical blocks are now reserved for use as spare blocks with the whole physical memory space that is instead used to map the logical memory space . This allows increasing the number of spare blocks and then the capability of ensuring the correct operation of the flash memory even with a high number of bad physical blocks.

Moreover every operation may now be performed directly on each physical block without any search for determining whether it must be replaced with a corresponding spare block. This has a beneficial impact on the access time of the storage device especially when its flash memory has a large size .

In an embodiment of the present invention one of the physical blocks is dedicated to store a Bad Block Table BBT . For example the bad block table is stored in the first physical block of the physical memory space that is good. For each physical block the bad block table stores a bad flag that is asserted when the physical block is bad while it is deasserted otherwise . Therefore in the example at issue wherein the physical memory space may include up to 4096 physical blocks and each physical sector has a main area of 512 bytes the bad block table is stored in 4096 512 8 physical sectors of the corresponding physical block. Each physical sector used to store the bad block table is identified by means of a corresponding table flag which is written in its spare area. Typically the table flag consists of a specific bit that is asserted for the physical sectors storing the bad block table while it is deasserted for the other physical sectors . In this way the table flag of the first physical sector of the different physical blocks may also be used to identify the one storing the bad block table when it is asserted . The bad block table is written into the flash memory every time it is formatted by erasing all its physical blocks and it remains unchanged until the next format operation .

Typically the mapping of the logical memory space on the physical memory space is implemented by a Flash Translation Layer FTL . Particularly each logical block is associated with one or more physical blocks organized into a tree structure . In a specific implementation the logical block is associated with a physical block that defines a root node and possibly with another physical block that defines a leaf node depending on the root node . The logical sectors of the logical block are written in succession into consecutive physical sectors of the associated physical block s . The writing of the logical sectors starts from the root physical block and then continues to the leaf physical block once the root physical block is full. Since the physical sectors can be programmed only once any time a logical sector must be updated its new version is written into another physical sector. When a logical sector is written into a physical sector its value is stored in the main area of the physical sector. The spare area instead stores an indication of the corresponding logical sector for example its logical offset . The spare area of the first physical sector of each physical block is also used to store an indication of the corresponding logical block for example its logical block number and an indication of the position of the physical block in the tree structure i.e. root node or leaf node .

For this purpose the translation layer manages a Logical to Physical L2P mapping structure . As described in detail in the following the mapping structure associates each logical block with its root physical block and leaf physical block if any . In turn the mapping structure associates each written logical sector with the physical sector in the root physical block or in the leaf physical block wherein its last version is stored. The mapping structure is created at least partially during an initialization of the storage device at its power on by reading the relevant information stored in the spare areas of the different physical sectors . The mapping structure is then maintained up to date according to the operations performed on the storage device.

The translation layer also manages a free list . The free list indicates the physical blocks that are erased and then available to write data by means of their physical block numbers . Preferably the erased physical blocks are arranged in the free list in increasing order of their number of erasures. This information is used by the translation layer to implement a wear leveling algorithm which is aimed at distributing the number of erasures of the physical blocks uniformly throughout the whole flash memory as described in the co pending patent application entitled WEAR LEVELING IN STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD U.S. Pat. No. 7 882 301 the entire disclosure of which is herein incorporated by reference to the maximum extent allowable by law . The free list is created at the initialization of the storage device by reading an Aging Block Table ABT not shown in the figure. The aging block table for example stored in the last physical block of the physical memory space that is good includes an indication of the number of erasures of each physical block. The free list is then maintained up to date according to the operations performed on the storage device.

The translation layer also interfaces with a service that implements a garbage collection procedure. When the garbage collection service is invoked for a specific logical block its old root and leaf physical blocks are compacted into a new root physical block. The old root and leaf physical blocks are then erased. Typically a natural garbage collection procedure is performed whenever a write operation is required on a logical block having both the root and leaf physical blocks associated with it that are full so that the desired write operation would not be possible . Preferably in this case any previous version of the logical sector to be written is not copied into the new root physical block since it would be useless .

The translation layer controls the physical memory space through a hardware adaptation layer . The adaptation layer exports a command interface for reading programming the physical pages and for erasing the physical blocks of the flash memory. The adaptation layer implements different functions that are required to access the flash memory such as a low level driver of the flash memory an ECC manager and the like . Particularly the adaptation layer includes a bad block manager which is aimed at making any bad physical block opaque to the flash translation layer . For this purpose the bad block manager controls an unavailable list which stores an indication of the physical blocks that are currently bad by means of their physical block numbers . The unavailable list is created at the initialization of the storage device. In this phase the unavailable list is populated with the bad physical blocks indicated in the bad block table i.e. that became bad during the format operation . The unavailable list is further populated with any other bad physical block that became bad after the format operation as indicated by a bad block flag in the spare area of its first physical sector being asserted. During operation of the storage device the unavailable list is then updated by adding any physical block that becomes bad because its erasure fails. Conversely when the programming of a physical sector fails the same operation is attempted again on a next physical sector without any effect on the status of the corresponding physical block which will become bad at its next erasure . The unavailable list facilitates the management of the bad physical blocks. Indeed the required information is now available directly in the working memory of the control unit thereby reducing the slow accesses to the flash memory.

Moving now to when the storage device implements the above described root leaf mapping technique its correct operation requires that the number of spare blocks NS should be at least 2 for the sake of simplicity in the following the additional physical blocks required for service information such as the two physical blocks for storing the bad block table and the aging block table will be disregarded . Indeed let us assume that only a single leaf physical block may be present at the time. In this case once all the logical blocks are written into corresponding root physical blocks equal to the number of logical blocks NL one more physical block is required for storing the leaf physical block. Moreover another physical block is required to perform a garbage collection procedure when a write operation involves the generation of another leaf physical block.

However as shown in any bad physical blocks are now included in the physical memory space that is used to map the logical memory space . Therefore the same constraint should be satisfied also taking into account a number NB of the bad physical blocks that are currently present as defined by the following correctness condition to be satisfied 2.

Typically the number of spare blocks NS is chosen far higher than 2. Suggested values of the number of spare blocks NS are 2 20 of the number of logical blocks NL and preferably 5 15 such as 10 . Therefore in the example at issue wherein the number of logical sectors NL is 4096 the number of spare blocks NS may be set to 4096 10 100 409. In this way it is possible to ensure the correct operation of the storage device even when a relatively high number of bad physical blocks appear. Moreover the storage device now allows having more leaf physical blocks at the same time. This reduces the frequency of the garbage collection procedure with a corresponding improvement in the performance of the storage device.

When the above mentioned correctness condition is not satisfied the storage device cannot support its full logical memory space any longer. For example as shown in the figure let us consider a very simplified scenario wherein the logical memory space only includes NL 10 logical blocks identified by their logical block numbers from LB 0 to LB 9 . Each logical block being written i.e. including one or more written logical sectors is indicated by means of a corresponding reference LBi with i 0 . . . 9 while the empty logical blocks i.e. with all the logical sectors that are not written are left unfilled. The physical memory space being used to map the logical memory space includes NP 13 physical blocks i.e. it has NS NP NL 13 10 3 spare blocks identified by their physical block numbers from PB 0 to PB 12. The physical blocks that are currently used to store the logical blocks are indicated by means of the corresponding references LB LB with a white background for the root physical blocks and a gray background for the leaf physical blocks. The erased physical blocks are instead left unfilled. The bad physical blocks are denoted by means of a cross. In the example at issue the logical blocks LB 1 LB 5 and LB 7 LB 8 are written while the logical blocks LB 0 LB 6 and LB 9 are empty. For this purpose the root physical blocks PB 12 PB 6 PB 3 PB 11 and PB 5 are used to store the logical blocks LB LB LB LB and LB respectively. The logical block LB is stored in the root physical block PB 0 and the leaf physical block PB 4 while the logical block LB is stored in the root physical block PB 9 and the leaf physical block PB 7. The physical blocks PB 1 and PB 8 are erased whereas the physical blocks PB 2 and PB 10 are bad. In this case the correctness condition is not satisfied since NS NB 3 2 1 not 2 . Therefore it would not be possible to write all the NL 10 logical blocks with the remaining good physical blocks NP NB 13 2 11 neither with a single leaf physical block at the time .

In the solution according to an embodiment of the present invention when this happens a recovery procedure is performed in an attempt to restore the correct operation of the storage device . For this purpose the garbage collection procedure is forced on every logical block that is stored in a pair of root and leaf physical blocks being always possible when the garbage collection procedure is forced as described in the following. As a result each pair of root and leaf physical blocks are compacted into a new root physical block and their erasure is then attempted. Every erase operation that succeeds generates a corresponding erased physical block whereas every erase operation that fails generates a corresponding bad physical block. At this point there is verified whether the empty logical blocks are enough to allow reducing the logical memory space i.e. increasing the number of spare blocks NS accordingly so as to satisfy the correctness condition. Denoting with NE the number of the empty logical blocks this means that the following recovery condition should be satisfied 2 that is 2 

If so the minimum number of empty logical blocks required to satisfy the recovery condition i.e. NK 2 NS NB is locked so that is not possible to use them. In other words the number of logical blocks that are now available differentiated with a prime notation is 

In this way the logical memory space is reduced by the number of locked logical blocks NK. However this allows restoring its correct operation with the correctness condition that is again satisfied 2 2 2 .

The proposed feature makes it possible to continue using the storage device with a graceful degradation of its performance even when the number of bad physical blocks increases excessively.

Preferably the logical blocks to be locked are selected according to the usage of the logical memory space by a file system of the mobile telephone including in its operating system . Typically the file system stores payload data consisting of actual data of interest and corresponding meta data being used to describe the payload data . For example the meta data is used to define a directory organization to store attributes of its files such as a type a protection mode a time stamp and the like. Most of the file systems store the meta data into a specific portion of the logical memory space. For example the meta data is stored at the beginning of the logical memory space i.e. starting from the first logical block LB 0 . In this case the logical blocks to be locked are selected in the other portion of the logical memory space that is not used for the meta data. In the example at issue the logical blocks to be locked are then selected at the end of the logical memory space i.e. starting from the last logical block LB NL 1 . This choice avoids any problem for the file system which may be caused by the unavailability of some logical blocks for storing the meta data.

In the example at issue as shown in the old root physical block PB 0 and the old leaf physical block PB 4 used to store the logical block LB are compacted into the new root physical block PB 1 while the old root physical block PB 9 and the old leaf physical block PB 7 storing the logical block LB are compacted into the new root physical block PB 8. All the old physical blocks PB 0 PB 4 PB 7 and PB 9 are then erased successfully. In this case the recovery condition is satisfied since the number of empty logical blocks NE 3 is at least equal to 2 NS NB 2 3 2 1. Therefore it is possible to lock NK 1 empty logical block so as to restore the correct operation of the storage device. The empty logical block to be locked is selected starting from the end of the logical memory space . In the example at issue the selected empty logical block will consist of the logical block LB 9 as indicated by means of a cross in the figure . In this way the logical memory space is reduced to NL NL NK 10 1 9 logical blocks with the number of spare blocks NS NS NK 3 1 4 that is increased accordingly. Therefore the correctness condition is again satisfied since NS NB 4 2 2 2 .

Considering instead during the above described garbage collection procedures only the old physical block PB 4 is erased. Conversely the erasures of the old physical blocks PB 0 PB 7 and PB 9 fail so that they become bad. In this case the recovery condition is not satisfied since the number of empty logical blocks NE 3 is lower than the required value of 2 NS NB 2 3 5 4 so that their locking would not be enough to restore the correct operation of the storage device . Therefore all the logical blocks LB 1 LB 9 are locked as indicated by a corresponding global cross so as to make the whole logical memory space read only until its next format operation .

With reference now to in the solution according to an embodiment of the present invention the storage device also implements a forced garbage collection procedure to ensure the full accessibility to the logical memory space . Preferably this garbage collection procedure should be performed while the storage device is idle. However in some cases this is not sufficient. Moreover some telephones do not support the possibility of invoking the garbage collection procedure during an idle thread of their operating system. This requires the necessity of performing the garbage collection procedure during operation of the storage device i.e. during a write operation .

In detail the flash memory is in a safe status until the leaf physical blocks plus 1 do not exceed the spare blocks actually available taking into account any bad physical blocks . Indeed in this case the physical blocks are enough to store all the logical blocks with the leaf physical blocks being present at the moment and at the same time to perform at least one garbage collection procedure. This is possible without requiring any further garbage collection procedure to erase more physical blocks and then irrespectively of the failure of the corresponding erase operations. Denoting with NU a number of the used physical blocks and with NW a number of the written logical blocks the number of leaf physical blocks is equal to NU NW. Therefore the flash memory is in the safe status when the following safe condition is satisfied 1 where F denotes the number of free physical blocks and B denotes the number of bad physical blocks.

However the flash memory can continue working even after leaving the safe status when the safe condition is not satisfied any longer even if in this case the correct operation of the storage device cannot be always ensured should a high number of erase operations fail . Indeed the garbage collection procedure might be delayed until the flash memory enters a critical status wherein only one garbage collection procedure can be performed. This happens when a single physical block is erased i.e. the following critical condition is satisfied 1.

In an embodiment of the present invention the garbage collection procedure is performed after leaving the safe status safe condition not satisfied whenever the leaf physical blocks increase. In other words the garbage collection procedure is performed whenever a write operation is required on a logical block having the associated root physical block that is full new leaf physical block . Once the flash memory entered the critical status critical condition satisfied instead the garbage collection procedure is performed whenever the used root or leaf physical blocks increase. In other words the garbage collection procedure is performed when a write operation is required on a logical block having the associated root physical block that is full new leaf physical block or on a logical block being empty new root physical block . It should be noted that at least one pair of root leaf physical blocks always exists in both cases assuming that the correctness condition is satisfied.

In this way the number of leaf physical blocks does not increase any longer once the flash memory has left the safe status. Therefore when the flash memory enters the critical status the logical memory space will be exploited at its best with almost all the logical blocks being written unless the physical memory space includes many bad physical blocks . In this way the risk of having the flash memory locked because the correctness condition is not satisfied when the garbage collection procedure in the critical condition is unable to erase any physical block i.e. the erasures of both the old root and leaf physical blocks fail only occurs when the whole logical memory space or at least most of it has been filled. This avoids degrading the performance of the storage device when many leaf physical blocks are present with only half the logical memory space that is exploited in the worst condition when each logical block is stored in a pair of root and leaf physical blocks. Moreover in the critical status the garbage collection procedure is performed only when it is strictly necessary to maintain one erased physical block . In any case the overhead on any write operation is at most equal to the time required to perform a single garbage collection procedure. This maintains the overhead acceptable in every operative condition. As a result the performance of the storage device is substantially uniform without degrading after any fixed point .

As a further improvement the logical block on which the garbage collection procedure should be performed is selected so as to minimize its execution time. For this purpose the leaf physical block having the minimum number of physical sectors that are programmed is determined. The logical block associated with this leaf physical block is then selected for the garbage collection procedure. This choice ensures that the number of last versions of the logical sectors to be copied into the new root physical block is reduced. As a result it is possible to minimize the negative impact of the garbage collection procedure on the corresponding write operation.

For example shows a scenario again with the logical memory space including NL 10 logical blocks and with the physical memory space including NP 13 physical blocks i.e. having NS 3 spare blocks wherein the flash memory has just left the safe status but it has not entered yet the critical status. The logical blocks LB 1 LB 2 LB 3 LB 4 LB 5 LB 7 and LB 8 are written in the physical blocks PB 0 root and PB 4 leaf PB 12 root PB 9 root and PB 7 leaf PB 6 root PB 3 root PB 11 root and PB 5 root respectively while the logical blocks LB 0 LB 6 and LB 9 are empty. The physical blocks PB 1 PB 8 and PB 10 are erased whereas the physical block PB 2 is bad. In this case the safe condition is not satisfied since NU NW 1 9 7 1 3 is higher than F B 3 1 2 therefore it would not be possible to ensure the capability of writing the remaining empty logical blocks LB 0 LB 6 and LB 9 and performing at least one garbage collection procedure with the remaining 3 erased physical blocks in any condition. Conversely the critical condition is not satisfied since NU NB 9 1 10 is lower than NP 1 13 1 12.

Moving to let us assume now that a write operation on the logical block LB 6 must be performed. Since the logical block LB 6 is empty this involves using an erased physical block such as PB 1 for its new root physical block. The write operation does not involve any increase of the number of leaf physical blocks again equal to 2 so that no garbage collection procedure is performed. In this case the critical condition remains not satisfied since NU NB 10 1 11 is again lower than NP 1 12.

Conversely when a write operation must be performed on the logical block LB 7 this increases the number of the leaf physical blocks assuming that the corresponding root physical block PB 11 is full. Therefore in this case a garbage collection procedure is performed. In the example at issue as shown in for this purpose the logical block LB is selected assuming that its leaf physical block PB 4 includes a number of programmed physical sectors lower than the one of the other leaf physical blocks i.e. PB 7 . As a result an erased physical block such as PB 10 is used for its new root physical block wherein the logical block LB is compacted . The old root PB 0 and leaf PB 4 physical blocks associated therewith are then erased successfully.

With reference now to the desired write operation on the logical block LB is performed this involves the use of an erased physical block such as PB 8 for its new leaf physical block. As above the critical condition remains not satisfied since NU NB 10 1 11 is again lower than NP 1 12.

Moving to a write operation on the logical block LB must now be performed. Since the logical block LB is empty this involves using an erased physical block such as PB 0 for its new root physical block. The write operation does not involve any increase of the number of leaf physical blocks again equal to 2 so that no garbage collection procedure is performed. In this case however the critical condition becomes satisfied since NU NB 11 1 12 is now equal to NP 1 12.

Let us assume now that a write operation must be performed on the logical block LB. Since the logical block LB is empty the write operation increases the number of used physical blocks for its new root physical block . Therefore in this case a garbage collection procedure is performed. In the example at issue as shown in for this purpose the logical block LB is selected assuming that its leaf physical block PB 8 includes a number of programmed physical sectors lower than the one of the other leaf physical blocks i.e. PB 7 . As a result an erased physical block such as PB 4 is used for its new root physical block wherein the logical block LB is compacted . The old root PB 11 and leaf PB 8 physical blocks associated therewith are then erased successfully.

With reference to the desired write operation on the logical block LB is performed. This involves the use of an erased physical block such as PB 11 for its new root physical block with the critical condition that remains satisfied since NU NB 11 1 12 is again equal to NP 1 12.

Moving to a proposed implementation of the above mentioned mapping structure according to an embodiment of the present invention is illustrated. With reference in particular to the mapping structure includes a block map that associates each logical block with the corresponding root and leaf physical blocks. For this purpose the block map has an entry for each logical block in a position corresponding to its logical block number . The entry of the block map includes a root field and a leaf field. If the logical block is written the root field indicates the associated root physical block by means of its physical block number . Otherwise if the logical block is empty the root field has a null value. When the logical block is written root field different from null the leaf field indicates the associated leaf physical block if any again by means of its physical block number . Otherwise if no leaf physical block is associated with the written logical block the leaf field has the null value.

For example as shown in the figure let us consider a very simplified scenario wherein the physical memory space only includes 8 physical blocks identified by the corresponding physical block numbers from PB 0 to PB 7 . The physical memory space is used to map a logical memory space of 5 logical blocks again denoted with LB LB . The block table then includes 5 entries from LB 0 to LB 4. In the example at issue the entry LB 0 indicates that the corresponding logical block LB is stored in the root physical block PB 2 and in the leaf physical block PB 4. The entries LB 1 and LB 4 instead indicate that the corresponding logical blocks LB and LB are stored in the root physical blocks PB 7 and PB 3 respectively with no leaf physical blocks . At the end the entries LB 2 and LB 3 indicate that the corresponding logical blocks LB and LB are empty.

Passing to for each physical block that is used as a root or leaf physical block for a corresponding logical block the mapping structure then includes a corresponding tree node . The tree node has a number field which stores the corresponding physical block number. A program field is instead used to store an indication of its last physical sector that is programmed by means of the corresponding physical offset from PS 0 to PS 255 in the example at issue . In this way when the used physical block is full the program field will be equal to the total number of physical sectors of the used physical block i.e. 255 otherwise the program field plus one will indicate the next erased physical sector being available to be programmed . At the end the tree node includes a position field that indicates whether the used physical block is a root node or a leaf node for example by means of the values 1 and 2 respectively .

Particularly the figure shows the tree nodes for the above described physical memory space with the used physical blocks PB 2 PB 4 and PB 7 . In this case the used physical blocks PB 2 PB 3 and PB 7 are root nodes position field equal to 1 and the used physical block PB 4 is a leaf node position field equal to 2 . The used physical block PB 2 is full since all its physical sectors are programmed as illustrated with a gray color written field equal to 255 while the other used physical blocks PB 3 PB 4 and PB 7 still have some physical sectors that are erased as illustrated in white color written field lower than 255 .

With reference now to for each used physical block the mapping structure further includes a sector map . As above the sector map has a number field storing the corresponding physical block number. The sector map then includes a sector array which is formed by a sector field for each logical sector of the associated logical block in a position corresponding to its logical offset i.e. from LS 0 to LS 255 in the example at issue . If the logical sector is written the sector field indicates the associated physical block by means of its physical offset PS 0 . . . 255 which stores the last version thereof. Otherwise if the logical sector is empty the sector field should take another value indicating that the logical sector is not written in any physical sector . It should be noted that in this case the last version of the logical sector and the empty logical sector are in relative terms only with respect to the physical block at issue. In other words when the physical block is a root node and a leaf physical block is also associated with the same logical block the actual last version of each logical sector might be stored in the leaf physical block. Likewise when the physical block is a leaf node each empty logical sector might instead be written in the root physical block.

In the example at issue wherein all the combinations that are possible with 1 byte 8 bits i.e. 256 from 0 to 255 are used to identify the physical sectors the provision of another value to indicate the empty logical sectors would require the use of an additional byte assuming that the byte is the smallest unit of information that is treated by the storage device . In order to solve this problem in an embodiment of the present invention the physical offset of a predefined physical block for example PS 0 is also used in the sector field to indicate that the corresponding logical sector is empty. In this case a validation field of the sector map is then provided to solve the ambiguity arising from the use of the same value 0 for indication that the logical sector is empty or it is written in the first physical sector. For this purpose the validation field stores the physical offset of the single logical sector that is written in the first physical block. In this way all the others sector fields storing the same value 0 indicate that the corresponding logical sectors are empty.

The proposed solution strongly reduces the size of each sector map . Indeed the validation field only requires a single additional byte instead of the 256 bytes that would be required to identify the empty logical sectors with a dedicated value in each sector field .

It should be noted that once the validation field has been set to the logical offset of the logical sector being written into the first physical sector at the first write operation on the physical block its value may remain unchanged even if a next version of the same logical sector is written into another physical sector. This does not cause any problem since the corresponding sector field will include the correct physical offset of the physical sector wherein the last version of the logical sector is stored. However it allows using a single byte for storing the validation field without the need of an additional byte for a null value indicating that it is not valid any longer .

Particularly the figure shows the sector maps for the root physical block PB 2 and the leaf physical block PB 4 that are associated with the logical block LB. In this case the sector map of the root physical block PB 2 number field equal to 2 indicates that the last version in the root physical block of the logical sectors LS 0 LS 1 LS 2 LS 3 LS 253 and LS 255 are stored in the physical sectors PS 33 PS 36 PS 103 PS 110 PS 51 and PS 222 respectively. The validation field indicates that the logical sector LS 253 was written in the first physical block. However in this case one or more next versions of the same logical sector were written in other physical sectors until the last one in the physical sector PS 51 as indicated in the corresponding sector field . As far as the sector fields including the value 0 are concerned i.e. the ones for the logical sectors LS 252 and LS 254 they are not identified in the validation field therefore the corresponding logical sectors are empty in the root physical block .

Likewise the sector map of the leaf physical block PB 4 number field equal to 4 indicates that the last version in the leaf physical block of the logical sectors LS 2 LS 252 and LS 255 are stored in the physical sectors PS 70 PS 48 and PS 62 respectively. As far as the sector fields including the value 0 are concerned the validation field indicates that the logical sector LS 1 is the one actually written in the first physical block the other logical sectors associated with the sector fields including the value 0 but not indicated in the validation field i.e. the logical sectors LS 0 LS 3 LS 253 and the LS 254 are instead empty in the leaf physical block .

Therefore the last versions of the logical sectors LS 1 LS 2 LS 252 and LS 255 are then written in the physical sectors PS 0 PS 70 PS 48 and PS 62 respectively of the leaf physical block PB 4. The logical sectors LS 0 LS 3 LS 253 and LS 254 are instead empty in the leaf physical block PB 4. However the last versions of the logical sectors LS 0 LS 3 and LS 253 are written in the physical sectors PS 33 PS 110 and PS 51 respectively of the root physical block PB 2 the logical sector LS 254 which is empty in the root physical block PB 2 as well is actually not written in any physical sector.

The block map and the tree nodes for all the used physical blocks are created during the initialization of the storage device. Conversely this is generally not possible for the sector maps of all the used physical blocks since this would require the use of a too large area of the working memory . Therefore the sectors maps are created when an operation must be performed on each logical block for the corresponding root physical block and leaf physical block if any . In the solution according to an embodiment of the invention for this purpose a cache structure is exploited. The cache structure has a predefined number of entries such as 5 10 for corresponding sector maps. Each freshly created sector map is added to the cache structure be removing the oldest one according to a FIFO policy . This avoids re creating the sector map s when operations must be performed on logical blocks that were accessed recently so that their sector map s are already available in the cache structure.

With reference now to the logic flow of an exemplary process that can be implemented in the above described storage device to control its operation is represented with a method .

The method begins at the black start circle and then passes to block in this phase the bad block table is searched by scanning the physical blocks of the flash memory forwards starting from the first one until the physical block storing the bad block table is found as indicated by the table flag of its first physical sector being asserted and it is then read. Continuing to block the unavailable list is created and populated with the bad physical blocks indicated in the bad block table.

A loop is then performed for each other physical block of the flash memory. The loop starts at block wherein the service information of a current physical block starting from the first one is retrieved from the spare area of its first physical sector . The method then branches at block according to the condition of the current physical block. Particularly if the physical block is erased the block is executed if the physical block is used the blocks are executed and if the physical block is bad the block is executed. In any case the method then passes to block .

Considering now block this branch is followed when the physical block is identified as erased for example when a corresponding flag in the spare area of its first physical sector is asserted . In this case a new entry for the erased physical block identified by its physical block number is added to the free list in the correct position corresponding to its number of erasures as indicated in the aging block table previously loaded . The flow of activity then descends into block .

With reference instead to block this branch is followed when the physical block is identified as used for example when a corresponding flag in the spare area of its first physical sector is asserted . In this case the physical block number of the physical block is inserted into the entry of the corresponding logical block in the block map and more specifically into the root field or into the leaf field according to its position in the tree structure as indicated in the spare area of the first physical sector . Continuing to block a new tree node for the used physical block is then created with its physical block number in the number field the physical offset of its last programmed physical sector in the program field and the value indicating whether it is a root node or a leaf node in the position field again as indicated in the spare area of the first physical sector . The flow of activity then descends into block .

Moving at the end to block this branch is followed when the physical block is identified as bad since the corresponding bad block flag is asserted . In this case a new entry for the bad physical block identified by its physical block number is added to the unavailable list. The flow of activity then descends into block .

Considering now block a test is made to verify whether all the physical blocks of the flash memory have been processed. If not the method returns to block to repeat the same operations for a next physical block. Conversely the storage device enters a waiting condition at block .

As soon as any operation is required on the storage device the process descends into block . The method then branches at block according to the type of the desired operation. Particularly if a format operation is required the blocks are executed if a write operation is required the blocks are executed and if a read operation is required the blocks are executed. In any case the method then returns to block waiting for the request of a next operation. Conversely when the storage device is switched off the method ends at the concentric white black stop circles .

Considering now block format operation a loop is performed for each physical block of the flash memory the loop starts by attempting to erase a current physical block. A test is then made at block to verify a result of the erase operation. If the erase operation succeeded the erased physical block is added to the free list at block . Conversely if the erase operation failed the bad block flag is asserted into the bad physical block at block . Continuing to block the corresponding bad flag for the bad block table is asserted as well starting from a condition wherein all the bad flags are deasserted . In both cases physical block either erased or bad the method then descends into block . In this phase there is verified whether the erase operation has been attempted on all the physical blocks of the flash memory. If not the method returns to block to repeat the same operations for a next physical block. Conversely the bad block table so obtained with the bad flags for the bad blocks being asserted is saved at block into the first erased physical block of the flash memory. The method then returns to block .

With reference instead to block write operation the critical condition is evaluated. The flow of activity then branches at block according to the result of the evaluation. Particularly when the critical condition is satisfied the blocks are executed whereas the blocks are executed otherwise in both cases the method then passes to block .

Considering now block critical condition satisfied meaning that the flash memory entered the critical status a test is made to determine whether the write operation involves an increase of the used physical blocks root physical block full or empty logical block . If so the used physical block having the minimum number of programmed physical sectors is selected at block . Continuing to block a garbage collection procedure is performed on the logical block associated with the selected leaf physical block so that its old root and leaf physical blocks are compacted onto a new root physical block and their erasure is then attempted . The method then verifies at block the result of the garbage collection procedure. When one or more physical blocks have been not erased successfully i.e. the old root and or the old leaf physical blocks became bad a test is made at block to verify whether a further garbage collection procedure can be performed this is true when at least one more leaf physical block and at least one erased physical block remained. If so the method returns to block to repeat the same operations described above. Conversely the storage device is locked in read only mode at block and the write operation is rejected . The method then returns to block for formatting the flash memory after saving the stored data so as to restore its operation . Referring back to block when both the old root and the old leaf physical blocks have been erased successfully the flow of activity descends into block . The same point is also reached from block directly when the write operation does not involve any increase of the used physical blocks i.e. it only involves the programming of a physical sector in an existing root or leaf physical block being not full .

With reference instead to block critical condition not satisfied the safe condition is evaluated. The method when verifies at block whether the safe condition is satisfied. If not meaning that the flash memory left the safe status a test is made at block to determine whether the write operation involves an increase of the leaf physical blocks root physical block full . If so the leaf physical block having the minimum number of programmed physical sectors is selected at block . Continuing to block a garbage collection procedure is performed on the logical block associated with the selected leaf physical block so that its old root and leaf physical blocks are compacted onto a new root physical block and their erasure is then attempted . The method then verifies at block the result of the garbage collection procedure. When one or more physical blocks have been not erased successfully i.e. the old root and or the old leaf physical blocks became bad a test is made at block to verify whether a further garbage collection procedure can be performed this is true when at least one more leaf physical block and at least one erased physical block remained. If so the method returns to block to repeat the same operations described above. Conversely the storage device is locked in read only mode at block and the write operation is rejected the method then returns to block for formatting the flash memory after saving the stored data so as to restore its operation . Referring back to block when both the old root and the old leaf physical blocks have been erased successfully the flow of activity descends into block . The same point is also reached directly from block when the write operation does not involve any increase of the leaf physical blocks i.e. it involves the writing of an empty logical block or the programming of a physical sector in an existing root or leaf physical block being not full or from block when the safe condition is satisfied meaning that the slash memory is still in the safe status .

With reference now to block when a new physical block must be used as a root node or as a leaf node the first erased physical block is extracted from the free list. A test is now made at block to determine whether the sector maps for the root physical block and the leaf physical block if any associated with the logical block are available in the cache structure. If not each missing sector map is created and added to the cache structure at block by removing the oldest one . Particularly the new sector map with the physical number of the corresponding physical block in the number field is populated by scanning the physical block forwards until all the programmed physical sectors have been processed or the end of the physical block is reached for each programmed physical block its physical offset is stored into the sector field overwriting any previous value in the position corresponding to the logical offset of the logical sector that is written therein as indicated in its spare area . The logical offset of the logical sector that is written in the first physical sector is also stored into the validation field. The method then descends into block the same point is also reached directly from block when all the required sector map s are already available in the cache structure. At this point the desired write operation is performed at the same time updating the relevant sector map accordingly .

The flow of activity then continues to block wherein the correctness condition is evaluated. The flow of activity branches at block according to the result of the evaluation. When the correctness condition is not satisfied the recovery condition is evaluated at block . Different branches are now followed at block according to the result of this further evaluation. If the empty logical blocks are enough to satisfy the recovery condition the minimum number of empty logical blocks required to satisfy it is selected at block starting from the end of the logical memory space . The selected empty logical blocks are removed at block from the logical memory space. The method then returns to block . Referring back to block when the recovery condition is not satisfied all the logical blocks are locked in read only mode at block the method again returns to block for formatting the flash memory after saving the stored data so as to restore its correct operation .

With reference at the end to block read operation as above a test is made to determine whether the sector maps for the root physical block and the leaf physical block if any associated with the logical block are available in the cache structure. If not each missing sector map is created and added to the cache structure at block as described above . The method then descends into block . The same point is also reached directly from block when all the required sector map s are already available in the cache structure. At this point the desired read operation is performed. The method then returns to block .

Naturally in order to satisfy local and specific requirements a person skilled in the art may apply to the solution described above many logical and or physical modifications and alterations. More specifically although the present invention has been described with a certain degree of particularity with reference to preferred embodiment s thereof it should be understood that various omissions substitutions and changes in the form and details as well as other embodiments are possible. Particularly the proposed solution may even be practiced without the specific details such as the numerical examples set forth in the preceding description to provide a more thorough understanding thereof. Conversely well known features may have been omitted or simplified in order not to obscure the description with unnecessary particulars. Moreover it is expressly intended that specific elements and or method steps described in connection with any disclosed embodiment of the invention may be incorporated in any other embodiment as a matter of general design choice.

Particularly the proposed solution lends itself to be implemented with equivalent methods by using similar steps removing some steps being non essential or adding further optional steps moreover the steps may be performed in a different order concurrently or in an interleaved way at least in part .

Similar considerations apply if the storage device emulates an equivalent logical memory space with a different number and or size of the logical blocks likewise the physical blocks may have a different size. In any case the proposed number of spare blocks is merely illustrative and it must not be interpreted in a limitative manner.

Alternatively the bad block table may have another structure for example consisting of a list of the physical block numbers of the bad physical blocks . Moreover it is also possible to replace the unavailable list with an equivalent structure for example consisting of a chain implemented with pointers a table and the like .

The bad physical blocks may also be detected in response to other events for example even when a write operation fails .

The use of the bad block flags or any equivalent indicators is not strictly necessary. For example nothing prevents updating the bad block table continuously according to the unavailable list such as periodically or when the storage device is switched off .

The proposed solution lends itself to be implemented on a flash memory wherein each physical block or logical block includes physical sectors or logical sectors respectively with a different number and or size. Alternatively it is possible to implement the mapping of the logical memory space on the physical memory space with different techniques for example by associating a tree structure with a root node and multiple child nodes with each logical sector by storing the required information in any other way and the like .

Similar considerations apply to the number of empty logical blocks to be locked during the recovery procedure. Moreover the recovery procedure may be implemented in a different way for example without compacting all the logical blocks at the beginning of it .

Nothing prevents selecting the empty logical blocks to be locked in a different way for example starting from the beginning of the logical memory space or even without any constraint.

Moreover it is possible to allow some further write operations on the storage device even when the recovery condition is not satisfied by locking it only when this is not possible any longer .

Alternative algorithms are also feasible to force the garbage collection procedure. For example when the erasure of each physical block is postponed by inserting it into an invalid list as described in the co pending patent application entitled MANAGEMENT OF ERASE OPERATIONS IN STORAGE DEVICES BASED ON FLASH MEMORIES Ser. No. 11 801 742 the entire disclosure of which is herein incorporated by reference to the maximum extent allowable by law it is possible to try erasing one invalid physical block before invoking the garbage collection procedure. Moreover it is also possible to implement an algorithm for restoring the storage device when a power loss occurs during the garbage collection procedure as described in the co pending patent application entitled RESTORING STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD Ser. No. 11 801 687 the entire disclosure of which is herein incorporated by reference to the maximum extent allowable by law .

Likewise the erasing of one invalid physical block may also be attempted before invoking the garbage collection procedure when the flash memory enters the critical status.

Nothing prevents selecting the logical block on which the garbage collection procedure should be performed in a different way for example simply according to a round robin policy .

The proposed block map tree nodes and or sector map are not strictly necessary and they may be replaced in whole or in part with a standard mapping structure. Vice versa it should be noted that these additional features are suitable to be used alone or combined with the other additional features even without the above described dynamic bad block management technique. Of course similar considerations apply if the empty logical sectors are indicated with a value equal to the physical offset of any other predefined physical sector such as the last one .

Even though in the preceding description reference has been made to a flash memory with NAND architecture this is not to be interpreted in a limitative manner. More generally the proposed solution lends itself to be used in a storage device based on any other flash memory for example of the NOR type of the phase change type and the like or other types of memories having block erase requirements.

Similar considerations apply if the program which may be used to implement each embodiment of the invention is structured in a different way or if additional modules or functions are provided. Likewise the memory structures may be of other types or may be replaced with equivalent entities not necessarily consisting of physical storage media . In any case the program may take any form suitable to be used by or in connection with any control system of the storage device such as software firmware or microcode. Moreover it is possible to provide the program on any medium being adapted to be used by the control system the medium can be any element suitable to contain store communicate propagate or transfer the program. For example the medium may be of the electronic magnetic optical electromagnetic infrared or semiconductor type examples of such medium are the flash memory itself or a ROM where the program can be pre loaded wires wireless connections broadcast waves and the like. In any case the solution according to the present invention lends itself to be implemented with a hardware structure for example integrated in a chip of semiconductor material or with a combination of software and hardware.

Alternatively the control system being used to manage the storage device may have a different structure or it may include equivalent components.

Likewise the above described architecture of the storage device is merely illustrative and it must not be interpreted in a limitative manner.

It should be readily apparent that the proposed structure might be part of the design of an integrated circuit. The design may also be created in a programming language moreover if the designer does not fabricate chips or masks the design may be transmitted by physical means to others. In any case the resulting integrated circuit may be distributed by its manufacturer in raw wafer form as a bare die or in packages. Moreover the proposed structure may be integrated with other circuits in the same chip or it may be mounted in intermediate products such as mother boards .

In any case it should be noted that the storage device may be used in any other data processing system further examples of such system are an MP3 player a digital camera a PDA a laptop computer and the like

From the foregoing it will be appreciated that although specific embodiments of the invention have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention.

