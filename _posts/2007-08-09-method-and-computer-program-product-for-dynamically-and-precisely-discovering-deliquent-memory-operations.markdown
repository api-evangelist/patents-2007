---

title: Method and computer program product for dynamically and precisely discovering deliquent memory operations
abstract: A method and computer product for dynamically and precisely discovering delinquent memory operations through integration of compilers, performance monitoring tools, and analysis tools are provided. The method includes compiling an application, and linking the application with a tracing library to generate executable, compiler annotated information and linker mapping information. The application is executed to obtain runtime trace information that includes hardware performance counters and tracing library instrumentation events. The trace information, the compiler annotated information, and the linker mapping information are analyzed to produce a delinquent memory operation file containing delinquent memory operation information. The delinquent memory operation information of the delinquent memory operation file is read by the compiler to perform memory reference mapping to guide static analysis and memory hierarchy optimization. The memory reference mapping maps delinquent memory operations precisely, both externally in a user source code and internally in a compiler intermediate representation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08122439&OS=08122439&RS=08122439
owner: International Business Machines Corporation
number: 08122439
owner_city: Armonk
owner_country: US
publication_date: 20070809
---
IBM is a registered trademark of International Business Machines Corporation Armonk N.Y. U.S.A. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

This invention relates to avoiding cache misses in performance critical paths and particularly to identifying instructions that can be classified as delinquent memory operations.

The effective use of processor caches is crucial to the performance of applications. Currently compiler optimizations have increasingly focused on the memory hierarchy and a variety of efforts have attempted to reduce cache misses. Experiments show that a very small number of memory referencing instructions cause the vast majority of cache misses which degrade the performance dramatically. We call these instructions delinquent memory operations.

It would be desirable to have methods and computer program products to identify delinquent memory operation instructions for effective cache optimizations such as data prefetching and data reorganization.

In accordance with an exemplary embodiment a method for dynamically and precisely discovering delinquent memory operations through integration of compilers performance monitoring tools and analysis tools is provided. The method includes compiling an application and linking the application with a tracing library to generate executable compiler annotated information and linker mapping information. Further the application is executed to obtain runtime trace information that includes hardware performance counters and tracing library instrumentation events. Also the trace information the compiler annotated information and the linker mapping information are analyzed to produce a delinquent memory operation file containing delinquent memory operation information. Additionally the delinquent memory operation information of the delinquent memory operation file is read by the compiler to perform memory reference mapping to guide static analysis and memory hierarchy optimization. The memory reference mapping maps delinquent memory operations precisely both externally in a user source code and internally in a compiler intermediate representation.

In accordance with the exemplary embodiment a computer program product tangibly embodied on a computer readable medium is also provided for dynamically and precisely discovering delinquent memory operations through integration of compilers and performance tools. The computer program product includes instructions for causing a computer to execute the above method.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

The detailed description explains the exemplary embodiments of the invention together with advantages and features by way of example with reference to the drawings.

The present disclosure describes a method to dynamically discover delinquent memory operations precisely through a set of tools that include compiler support profiling using sampled hardware counters and analysis tools.

Currently delinquent memory operation identification is done either through static analysis or dynamic profiling. Delinquent memory operations can be identified at compile time using memory access patterns and cache behavior analysis. Static delinquent memory operation identification usually lacks accuracy due to unknown runtime cache behavior information. Dynamic profiling can be done through compiler instrumentation binary instrumentation tools or simulation modeling. For the dynamic profiling approach through compiler or binary instrumentation the compiler or binary instrumentation tool inserts instructions in an application directly or invokes application programming interfaces API provided by library packages to read hardware performance counter data records the cache statistics internally and records delinquent memory operation information. This approach might change the cache behavior due to internal data structure accesses. Profiling can also be done through trace driven simulation based monitoring. Simulation based monitoring is usually very costly for large scale applications due to the high overhead and potential inaccuracy from the simulators.

The exemplary embodiment provides a method which may be implemented in the device to dynamically and precisely discover delinquent memory operations through the integration of compilers performance monitoring tools and analysis tools to boost application performance by avoiding cache misses in performance critical paths.

The compiler generates annotated information about instruction groups what optimizations such as inlining and unrolling are performed what symbol mappings are conducted etc. This information is used by both the analysis tools at a delinquent memory operation analysis stage and the compiler at a re compilation stage

A predefined instrumentation library is provided as part of the performance monitoring tools to trace the memory regions of the memory that are accessed by each memory reference at runtime. This allows the analysis tools to generate the information on accessed memory regions address range access density etc.

Sampling based dynamic profiling is used as part of the performance monitoring tools to discover the delinquent memory operations e.g. which cache level the cache misses occurred in and what is the cache miss frequency. A set of the analysis tools are used to analyze the information from the low level trace output linker output run time log output and compiler report output. Two approaches are utilized to deal with the inaccuracy of the instruction address trace which may be an inherent problem in most superscalar processors due to the mode in which groups of instructions are tracked together in the processor pipeline. The first approach uses compiler static analysis to further identify which instructions are actually delinquent when there are multiple loads in an instruction group. In this exemplary case the compiler does not need further dynamic information and can use the information directly for optimization. In the second approach the compiler generates instructions that force the processor to separate memory reference instructions into distinct groups.

With the integrated compiler performance monitoring tools and analysis tools the analysis tools can identify delinquent memory operations at low instruction levels and the compiler maps delinquent memory operations precisely in the intermediate representation level which in turn identify memory references at the user source level. The compiler maintains the information about what transformations are done and keeps line information consistent through different optimization phases and internal symbol mapping.

As non limiting examples the exemplary embodiment may be implemented in an IBM PowerPC architecture. This is based on the availability of the hardware performance monitor unit provided by IBM PowerPC architecture which makes it possible to count instruction and data cache misses serviced at the different levels of the memory hierarchy as well as sample the addresses for these misses with a certain frequency.

As mentioned herein the process of the exemplary embodiment provides a method to dynamically discover delinquent memory operations precisely through the integration of the compiler s performance monitoring tools and analysis tools to boost application performance by avoiding cache misses in performance critical paths. Existing techniques lack the interaction between the compiler s and performance and analysis tools.

Moreover it has traditionally been difficult to generate the address traces and memory hierarchy miss rate information precisely especially on modern super scalar architectures with deep pipelining and out of order execution. On typical modern processors instructions are grouped or cracked and tracked as a group throughout the execution pipeline. Thus several memory instructions may end up in the same group and the hardware performance monitoring unit cannot precisely detect which is the cache missing instruction. The exemplary embodiment however uses the compiler to refine instruction groups without changing runtime cache behavior and thus facilitate the discovery of particular delinquent memory operation instructions more precisely.

After a delinquent memory operation instruction is identified at the instruction level it is very difficult sometimes impossible to map it at the user s source level without the help of the compiler . Especially when aggressive optimizations are applied the compiler is used to reconstruct the mapping to user source level code . In the exemplary embodiment the compiler generates an annotated listing i.e. compiler annotated information that contains additional information on the location of memory referencing instructions. The annotated listing is used by the delinquent memory operation analysis tool e.g. the performance tools and or the analysis tools and the compiler . The delinquent memory operation analysis tool e.g. the performance tools discovers delinquent memory operations at the instruction level by using the annotated listing . The compiler reads the delinquent memory operation information discovered by the delinquent analysis tool and performs precise memory reference mapping both at internal intermediate representation level and at user source level with the combination of dynamic profiling information and static analysis.

The process compiles an application and links the application with a tracing library to generate executable compiler annotated hints information and linker mapping information at . The application is executed to gather runtime tracing information through hardware performance counts at . The runtime tracing hardware trace information the compiler generated annotated hints information and the linker generated mapping information along with sampling information are analyzed to produce a file containing delinquent memory operation information at . The fire containing delinquent memory operation information may comprise the file name function name line number delinquent memory operation name memory region identifier memory region start address memory region size etc. At the delinquent memory operation information is read in by the compiler to perform memory reference mapping with the guidance of static analysis and memory hierarchy optimization to map delinquent memory operations precisely both externally in the user source and internally in the compiler intermediate representation e.g. a compiler internal form to represent delinquent memory operation information .

An attached Appendix herein incorporated by reference provides non limiting examples of functions used in dynamically and precisely discovering delinquent memory operations through integration of compilers and performance tools . Also the Appendix provides non limiting examples of the performance tools interacting with the compiler in accordance with the exemplary embodiment including instructions for code that may be used or a computer program product. In the Appendix the tools 1.1 1.2 1.3 and 1.4 discussed herein may be considered part of the performance tools .

The detailed examples of the exemplary embodiment described above are for explanatory purposes only and are not meant to be limiting in any way.

The capabilities of the present invention can be implemented in software firmware hardware or some combination thereof.

As one example one or more aspects of the present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The article of manufacture can be included as a part of a computer system or sold separately.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The flow diagram depicted herein is just an example. There may be many variations to this diagram or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the exemplary embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

To gather dynamical trace information 1 Compile the application with specified options qlist qsource qreport qxflag CPO1 to generate the compiler annotated listing. 2 Link with the instrumentation library so that memory region can be recorded at runtime 3 Generate the link map files and 4 Pass the required parameters to the tool and run application to gather the trace information.

The wrapper functions are implemented in a dynamically linked library wrap mm.so . The dynamically linked library records the address of the calling instruction which invokes the corresponding standard library memory management function and records a log entry with the gathered information. These log entries should be synchronized with the corresponding memory access instructions from the trace. Synchronization is performed by using the AIX e.g. IBM UNIX Operating System trace API to inject the memory management log entries directly into the trace of sampled cache misses. This creates a relative ordering which significantly simplifies the instruction to memory region mapping.

The required parameters for the 1.2 tool are the following frequency sampling frequency group and counter performance counting group and counter within the group cpu the largest processor number i.e. the number of processors available in the system 1 tracerawfile this is the name of the raw trace file generated by eprof. tracetextfile trace text file name maxbufsize this is the memory buffer size used for sampling. and maxfilesize this is the maximum size of the trace on disk .

As a result of executing the tool 1.2 the trace text file trace.txt is generated. As non limiting examples the Trace.txt has lines in the following format 

010 0.017933002 0.000696 type 0000000000000001 caller 0000000100000A94 address 000000011004F330 size 0000000000000280 Case 1 

In the first case the columns include the time memory management function was called the type of function e.g. malloc free etc. the instruction address of the call or rather of the instruction following the call the data address of the allocated block and die size of the allocated block.

In the second case the concern is with the iaddress daddress pair. These are hex addresses of a particular sampled instruction and the data address accessed that these hex addresses caused the miss.

After compiling the program application and executing the program with the tool in 1.2 the following files are available for analysis to generate a file containing delinquent memory operation information 1 the original source files 2 whole program listing with annotations generated by the compiler 3 the map file generated by linker and 4 the hardware trace File intermixed with memory management calls.

Below depicts a non limiting example of the delinquent memory operation information in an instruction group generated by the analysis tool 1.3 

After re compiling the program with the delinquent memory operation information generated in tool 1.3 qxflag CPO2 the compiler builds a global call graph goes through each call graph node to map the delinquent memory operations into the internal symbol index and records the delinquent memory operation information. This delinquent memory operation information is used to restructure the code to eliminate the cache misses to insert data prefetch instructions to schedule instructions based on the latency etc.

