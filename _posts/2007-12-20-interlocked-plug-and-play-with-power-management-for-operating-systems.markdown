---

title: Interlocked plug and play with power management for operating systems
abstract: The present invention provides a unified layer for Plug and Play (PnP) components and power management components while relieving device drivers from system-level complexities associated with implementing PnP and/or power management functionality. The layer operates at a level between low-level device drivers and more complex operating system tasks. The subject invention simplifies designing device drivers having proper power management support by creating an infrastructure that allows a device driver to operate within a driver framework or model and without having to process Plug-and-Play or Power Management I/O Request Packets (IRPs) directly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08413171&OS=08413171&RS=08413171
owner: Microsoft Corporation
number: 08413171
owner_city: Redmond
owner_country: US
publication_date: 20071220
---
This application is a Divisional of U.S. patent application Ser. No. 10 833 534 filed Apr. 28 2004 and entitled INTERLOCKED PLUG AND PLAY WITH POWER MANAGEMENT FOR OPERATING SYSTEMS which is related to co pending U.S. patent application Ser. No. 10 833 542 filed Apr. 28 2004 entitled INTERLOCKED PLUG AND PLAY WITH POWER MANAGEMENT FOR OPERATING SYSTEMS. The entireties of these applications are incorporated herein by reference.

The present invention relates generally to systems and methods that facilitate power management between devices drivers systems and processes. More particularly the present invention relates to a middleware or system level layer that offloads power management decisions and processing from lower level device drivers to an operating system framework.

Some operating systems support the concepts of Plug and Play PnP Power Management and System Management for a plurality of different device drivers. Unfortunately the complexity involved in implementing PnP and Power has caused thousands of device drivers to be written in a manner that may cause operating system problems e.g. system crash . Beyond system failures many designers of device drivers choose to simplify their drivers as much as possible so that they do not have to complicate their designs with difficult programming problems testing problems and or verification problems. This often leads to drivers which perform Power Management in the simplest way possible which is merely to leave the corresponding device turned on consuming full power at all times. This consequently leads to laptop and tablet computers that consume more energy than they need to thus causing shorter battery life than possible.

In one current operating system scenario existing programming models do not always facilitate implementing PnP and Power management considerations in an efficient or robust manner. For example a PnP start event may be modeled as an implicit power up event even though the power manager did not send it. Similarly PnP stop and remove events are implicit power down events. This implies that coordination and synchronization between PnP and Power events would then be performed inside every device driver and not merely inside PnP or Power Managers.

In another example power management in some models may be broken into two separate concepts system power management and device power management. Thus the operating system or components associated therewith decides when the system is awake or asleep and the individual device drivers decide when the devices should be awake or asleep. In many ways this is desired since it implies that device power policy can be managed by software components that have the most device domain knowledge. In many other ways it s frustrating for a device driver designer since it forces the designer to track system power states responding to them by putting the device into appropriate device power states. This tracking and coordination is complex and error prone at best.

In order to save battery power it should be theoretically possible to turn off devices that aren t currently being used. This goal is difficult to achieve with existing models since the device driver has to track system concepts such as general idleness time since the device was last asked to perform a task and so forth. Turning unused devices off can certainly save power however many devices need to remain powered on in order that software can be aware that a human has interacted with them. A good example is a floppy disk drive. It would be desirable if the floppy were turned off when it is not being used since it is very rarely used in many situations. The operating system can certainly turn it on before it starts writing to the floppy or reading from it. The problem arises when a user puts a new floppy into the drive. Software should typically respond by changing any windows that currently show the contents of the floppy and updating them with the list of newly inserted files. If a disk change notification is not sent then the device cannot be turned off.

The above floppy drive problem can be solved in a drivers framework by allowing each device to have a wake signal at the hardware level that can bring the device back into a working state. The problem is that almost all hardware in existence ties the wake signal into logic that controls the current power state and the current power state is managed with a completely separate event. Thus device drivers are forced to use two completely separate and unsynchronized events to manage a process that is essentially an interconnected and synchronized hardware subsystem. In view of the problems listed above and others many machines such as laptop computers suffer from poor battery life.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

The present invention relates to systems and methods that support Plug and Play PnP and power management operations at a higher level domain than at a device driver level. In one aspect the present invention creates an infrastructure that allows a device driver to operate within an operating system framework or model without having to process Plug and Play or Power Management events e.g. I O Request Packets IRPs directly. The infrastructure provides system and device level synchronization of PnP and power related events that effectively coordinates and guides efficient power operations. Such operations include allowing devices to remain in low power states to conserve battery life while mitigating complex system level considerations for entering and returning from these states.

In one aspect the present invention merges the concepts of PnP and Power which are largely separate in various operating system models. One example implementation of the present invention includes employment of three state machines that act as a layer to bridge operating system components and device driver power requirements. This layer of state machines creates an environment for device drivers that processes operating system interactions on behalf of the driver allowing the driver to only implement the components needed for desired driver functionality. Furthermore the layer is rich enough to allow a device to save maximal power without much coding or design effort on the part of the driver designer.

The present invention offers several advantages over conventional operating system models such as Significantly improving the quality of device drivers which can directly reduce the number of system problems Can be provided as part of a Driver Framework which mitigates code development for driver designers Significantly improve opportunities for battery life savings including system tuning and power optimization algorithms and Allowing a driver written for one style of operating system to be easily migrated to another style of operating system by removing power management and PnP processing from the device layer to middle or system level layers.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced all of which are intended to be covered by the present invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The present invention provides a unified layer for Plug and Play PnP components and power management components while relieving device drivers from system level complexities associated with implementing PnP and or power management functionality. The layer operates at a level between low level device drivers and more complex operating system tasks. The subject invention simplifies designing device drivers having proper power management support by creating an infrastructure that allows a device driver to operate within a driver framework or model and without having to process Plug and Play or Power Management I O Request Packets IRPs directly. This creates an environment for device drivers that process framework interactions on behalf of the driver allowing the driver to implement desired functionality while mitigating overall driver complexities. These features can be achieved by defining multiple state machines that manage PnP and Power related events that in turn promote energy savings on a system wide level.

As used in this application the terms component model system framework object stack and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal .

Referring initially to a power management system is illustrated in accordance with an aspect of the present invention. The system includes an operating system framework that interacts with one or more device drivers via a middleware layer that coordinates Plug and Play PnP requirements and power requirements between the framework and the drivers. In general the middleware layer includes one or more state machines or processing components that control and synchronize power operations for the system . The state machines include a PnP state machine that tracks events from a PnP manager not shown while coordinating with a power state machine that manages device power events and a power policy state machine that manages system power events. The state machines are described in more detail below with respect to .

By offloading power management considerations from the device driver level and moving such processing to the middleware layer several performance and design enhancements are achieved over conventional systems. One feature relates to simplifying the design of the drivers . For example these drivers no longer have to attempt to account for system level considerations and can more simply respond to events Interrupt Request Packets IRPs and call backs from the middleware layer without substantial concern for coordination between other drivers and or other components of the system . Moreover since complex functional requirements are effectively transferred from the drivers to the middleware layer the drivers can be implemented as essentially operating system independent drivers. This implies that a driver in one operating system e.g. Windows can be easily transported and operated in another operating system e.g. Linux and vice versa.

Because of the flexibility and simplicity offered by the middleware layer device drivers can be put into low power states and returned to normal operating conditions in a straightforward and robust manner thus conserving overall system power. As can be appreciated the middleware layer and state machines can be implemented in various designs and can have all or portions thereof incorporated within the framework . Also the drivers can be designed for substantially any device such as network devices memory devices volatile or nonvolatile acoustical devices display devices printers bus devices USB devices infrared devices power devices keyboards mice and so forth. Furthermore the state machines can be implemented in substantially any language such as Unified Modeling Language UML Very High Speed Hardware Description Language VHDL programming languages such as C and so forth. In general the following serve as general guidelines for the PnP Power and framework components described herein 

Referring now to a system illustrates state machine interactions in accordance with an aspect of the present invention. As noted above three formal state machines can be defined however more or less than three can be employed. A first state machine referred to as the PnP State Machine tracks PnP events or I O Request Packets IRPs from a Plug and Play PnP manager . This machine responds by feeding events into other state machines and by calling PnP related functions supplied by a device driver which fill in driver specific behavior. A second state machine referred to as the Power State Machine tracks device Power Management events or IRPs at . This machine also manages device power states by calling driver supplied functions where necessary.

A third state machine referred to as the Power Policy State Machine tracks system Power Management events or IRPs supplied by a system Power Manager . In one aspect the Power Policy State Machine manages tracking overall system state along with device usage deciding what power state the device should be in. The Power Policy Machine sends device Power management IRPs at that can become input events for the Power State Machine . Generally each of these state machines and generate some events that are consumed by the other machines or other components. Together they make up a larger system for implementing PnP and Power in the device driver or drivers . When the machines are integrated into a Driver Framework or operating system layer they can be employed by a plurality of different device drivers solving many problems such as system power consumption driver complexity and system robustness.

In general the state machines can provide a plurality of different states that are entered into and or exited from via one or more events. For example various sample states are illustrated at including system power states that are derived from the Advanced Configuration and Power Interface ACPI specification that is conventionally known and available from a plurality of sources such as the Internet. These states are generally defined as follows 

System power states are primarily defined in terms of motherboard CPU core logic characteristics and generally do not relate to individual devices themselves. Each device in the system generally has its own power states. These are defined as follows 

To enter and exit these and other states one or more events can occur. In general there are several classes of events those that are universal to all operating systems since they are dictated by hardware and those that may be specific to a particular type of operating system e.g. Windows . Some example events are illustrated at include Power Up Power Down Power Policy Start Power Policy Stop Power Implicit D Power Implicit D and so forth.

Generally the state machines support a system that implements a general mechanism for all PnP Device Power and Device Power Policy events. The system includes entry into states in one state machine that can cause transitions to occur in other state machines or components. In one example entry into the D state causes a Power Up event to be sent to the other state machines since these machines may have been sent events that caused the device to start being used. This would result in an ImplicitD event sent to the Power state machine which unifies the PnP and Power machines. The PnP state machine however waits until the Power state machine has completed the move into D. In a multiprocessing operating system components generally do not want to wait by sitting in a loop with the processor these components suspend operations. Thus the Power Up event alerts the PnP state machine and causes it to start running again finishing the PnP operation.

Specific state processing implementation examples include entry into a lower power state in the Power state machine causes a Power Down event to be fed into the Power Policy and the PnP state machines. In another case entry into the D state in the Power state machine causes some or all of the I O queues not shown in the driver top edge queues to be released so that new requests can be processed.

As can be appreciated a plurality of state actions events IRP s and processing can occur within or between state machines drivers and operating system components. Other examples of various actions include 

Turning to an exemplary processing stack is illustrated in accordance with an aspect of the present invention. The stack can include one or more stack objects. For example the objects can include a Functional Driver Object FDO a filter object supplied by an operating system framework and a Physical Driver Object PDO . As illustrated IRP s can be propagated up or down the stack for respective processing wherein framework components or drivers can be driven and synchronized from a respective IRP.

It is noted that some operating systems or frameworks support the concept of driver stacking. For example when an application opens up a handle to a device it controls the device by sending I O Request Packets IRPs to the stack of drivers at . Generally each of those drivers in the stack may react to modify or otherwise handle the IRPs that it observes. When one driver is finished with an IRP it passes it down to the driver below it. There is also an opportunity for a driver to see an IRP after the driver below it has completed it as illustrated in . These type of stack actions are relevant since each physical device may have several drivers acting on it in some manner. Typically at the least there will be a Functional Driver or FDO and a Physical Driver or PDO. 

Generally in each driver stack each driver handles PnP and Power events. However one driver in the stack should track system power events and status deciding when the device should be powered on or off. Consequently the PnP State Machine and the Power State machine can be instantiated in any device driver. The Power Policy State Machine should be instantiated in the driver that is the power policy owner for the device stack . Thus the Power State Machine and the Power Policy State machine should exist or be implemented as separate entities or components. The following discussion describes various aspects of the state machines events IRP s framework interactions Application Programming Interfaces APIs and example system scenario s for which the state machines apply.

Referring now to exemplary events for a PNP state machine are illustrated in accordance with an aspect of the present invention. Before proceeding with a discussion of it is noted that the respective state machines can process more or less events or other events than the example events discussed in these Figures. Generally the PNP state machine responds to the following external events 

Turning to exemplary events for a Power state machine are illustrated in accordance with an aspect of the present invention. Generally the Power state machine responds to the following external events 

Since there are generally fewer events that feed into the Power state machine it is acceptable to look at side conditions when choosing a target state. Specifically several transitions observe a POWER STATE TYPE. The Power state machine can be designed to process FDOs PDOs filters bus filters and the like. It is valid whether or not the driver is also the power policy owner.

Referring to exemplary events for a Power Policy state machine are illustrated in accordance with an aspect of the present invention. Generally the Power Policy state machine is instantiated when the driver decides to be the power policy owner for the stack. This will usually be true if the driver is an FDO. It will usually not be true otherwise. The Power Policy state machine is primarily responsible for deciding when the device should be in D D D or D. It also decides whether the device should be armed for wakeup. The Power Policy state machine sends IRP MN SET POWER IRPs to the stack that have D state information in them. It also sends IRP MN WAIT WAKE.

The Power Policy state machine makes distinctions between waking from S and waking from S not noted as Sx. The distinction is relevant since many devices have different usage scenarios for waking from S and waking from Sx. Consider a few examples 

For the above reasons there can be separate callbacks related to Wait Wake for S and Sx. A similar approach as the Power state machine could be taken to automatically register the same callbacks for the S and Sx cases. But unlike the power situation the common case here is different behavior for S and Sx which implies that most drivers may end up overriding the default callbacks. Also the Power Policy state machine is similar to the Power state machine in that some of its callbacks should be called under the constraint that they will not generate a page fault.

When the Power Policy state machine chooses to move the device out of D it selects between D D and D. The device should be as deeply asleep as it can be without disabling functionality both when the computer is remaining in S and when it is going to sleep. For the most part latency differences between D D and D are not as relevant as they tend to be on the order of milliseconds. The ACPI specification and other available power management documents imply that the differences between D D and D mostly relate to wakeup latency. In practice this has not been the case. There are of course some notable exceptions e.g. CRT monitors but most devices have wakeup latencies that are mostly on the order of a few milliseconds.

By default the Framework assumes that any FDO is the power policy owner and any filter or PDO is not. If this is not true then the driver can call this function to deterministically mark the device as either an owner or a non owner. The Framework can instantiate a Power Policy state machine and corresponding WDFPOWERPOLICY object for any device that owns the power policy for its stack.

If a driver calls this API the device stack should be torn down. If the driver calls with WdfDeviceFailedAttemptRestart as the FaileDAction then the Framework can attempt to cause the stack to be built up again. Either condition can cause the driver to experience a process such as a SurpriseRemove situation for example.

It is expected that for catastrophic software failures the driver would set FailedAction to WdfDeviceFailedAttemptRestart and for catastrophic hardware failures the driver would set FailedAction to WdfDeviceFailedNoRestart. If the hardware can be fixed by passing through a D uninitialized state then a driver may specify TRUE for a hardware error.

In general the Framework may not provide callbacks for every state in its state machines however the driver can register for states that it wants to access. The above functions provide that capability.

These state machine related callbacks above generally do not replace formal event callbacks that a driver can register for using conventional registration APIs. For instance if the driver registered for a state change notification on a RestartingSelfManagedIo state it would not replace the EvtDeviceSelfManagedIoRestart callback related to this state.

This function sets a property on a device. If TRUE the Framework should allow a Stop or Remove of the device. If FALSE it should not. The default is TRUE. A driver may change the setting. This function is generally intended for devices which must not stop their respective queues. They can inform the Framework in advance that their driver should run without substantial interruption.

The driver then performs desired normal operations when power is first applied to the device. This may include downloading firmware to the device unmasking internal interrupt sources and so forth. Since the Framework takes care of unblocking queues and other aspects the driver should generally perform hardware related operations in this callback.

PreviousState can indicate the state that the device was most recently in which may be useful when waking. If the device was previously unstarted it likely had no valid D state so PreviousState should be WdfPowerDeviceUnspecified. This can be called when the device gets an IRP MN START DEVICE or IRP MN SET POWER D for example.

If the TargetState is WdfPowerDeviceD Final the device is being stopped or removed. If the driver needs to perform any actions on the device that will assume the device will not return to D they should be performed here.

TargetState should only be WdfPowerDevicePrepareFor Hibernation if the device is on the hibernation path e.g. it got IRP MN DEVICE USAGE NOTIFCATION Hibernation and the target S state is S.

If the TargetState is WdfPowerDevicePrepareFor Hibernation the driver should perform suitable operations to quiet the device without shutting it off. It should also gather states that may be necessary for putting the device back in D after the system resumes from hibernation. It is noted that the device should not be powered off since this device may be used to save the hibernation file to disk. This callback can be called when the device gets IRP MN STOP DEVICE IRP MN REMOVE DEVICE or IRP MN SET POWER Dx.

This callback is invoked when the device is assigned a new set of PnP resources. The driver should take note of them and possibly map them using them for device control routines. This is also a place to call USB related functions that have to wait until the device has gotten a Start command. Examples of these USB functions are 

If the driver returns failure the stack should be torn down. While the hardware is available and the driver may access it in this state it is probably more suitable for the driver to wait for EvtDeviceD Entry before access the hardware. Exceptions include operations that involve finding out exactly which version of the hardware is actually present.

This callback is invoked when a device is being removed. Hardware is no longer accessible at this point. There should be no outstanding I O it should have been flushed and the queues should be canceling operations by this point. The driver should be concerned with freeing memory tearing down structures and cleaning up software states for example at this point. The driver should not access hardware in this callback.

This callback is invoked after the driver has stopped driver operations that are not being managed by the Framework. It is invoked on Remove and Surprise Remove. The driver should perform outstanding cleanup work. The driver should not access hardware during this callback.

This callback is invoked when the driver should start operations that are not being managed by the Framework. This callback should be the first in the SelfManagedIo group invoked as the driver starts. It should be invoked once when the device is started.

If a driver fails this callback the Framework should inform the PnP manager that the device has failed which should cause the PnP manager to tear the stack down. EvtDeviceSelfManagedloCleanup will be called if failure is returned from this function.

This callback is invoked when the driver should pause operations that are not being managed by the Framework. It should be invoked on Dx transitions except when EvtDeviceSelfManagedIoStop has been called but EvtDeviceSelfManagedIoRestart has not. This callback differs from EvtDeviceSelfManagedIoStop in that failure should be interpreted as fatal causing the stack to be torn down. Hardware may be available while this callback is invoked. If the device is surprise removed while it is in the D state this function will be called when hardware is not available.

This callback is invoked when the driver should resume operations that are not being managed by the Framework. It should be invoked after EvtDeviceSelfManagedIoSuspend or EvtDeviceSelfManagedIoStop was invoked. Hardware is available while this callback is invoked.

This callback is invoked when the driver should stop queues that are not being managed by the Framework since the device is being stopped in response to IRP MN QUERY STOP or IRP MN QUERY REMOVE. This should occur before the Framework stops Framework managed queues which is before the device exits the D state. If a driver fails this callback the Framework should fail the IRPs. This is intended to be a valid way to indicate that temporal conditions exist wherein the driver cannot be stopped or removed. Hardware is available while this callback is invoked.

This callback is invoked when the device is pulled out of the system physically or logically. This is largely informational as the Framework can still process queues and the callback EvtDeviceRemove should be invoked later. It is expected that if drivers register for this callback they will use it for reporting specific error conditions. Hardware is not available while this callback runs.

This callback is invoked when the device is losing ownership of its PnP resources and the driver should un map items that it has previously mapped. If the driver returns failure then the stack should be torn down. The driver may not access hardware during this callback. The device has already been moved into the D state.

This event is generated when the device has initially received an IRP MN START DEVICE request. The event is sent before the request itself is sent down the device stack if the device is an FDO or completed immediately if the device is a PDO. The IRP at this point is neither queued nor pended.

This event is generated when the device has sent the IRP MN START DEVICE request down the stack and it has been completed successfully. Before sending the event the IRP is queued and pended. If the device generating this event is a PDO this event is generated after the PnpEventStartDevice event without further IRP processing. Upon completion of processing this event the state machine will complete the start request up the stack.

This event is generated when the device receives the IRP MN QUERY REMOVE DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be processed accordingly. If the event was processed successfully the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO. If the event was processed unsuccessfully the IRP will be completed immediately with error.

This event is generated when the device receives the IRP MN QUERY STOP DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be processed accordingly. If the event was processed successfully the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO. If the event was processed unsuccessfully the IRP will be completed with error.

This event is generated when the device receives the IRP MN CANCEL REMOVE DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.

This event is generated when the device receives the IRP MN CANCEL STOP DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.

This event is generated when the device receives the IRP MN STOP DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.

This event is generated when the device receives the IRP MN REMOVE DEVICE request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.

This event is generated when the device receives the IRP MN SURPRISE REMOVAL request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.

PnpEventEject This event is generated when the PDO receives the IRP MN EJECT request. Before sending the event the IRP will be queued and pended. Upon completion of processing this event the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO. PnpEventPowerUp

This event is generated by the power state machine to indicate that the device has returned to D either implicitly or explicitly. This event may have been in response to a power up request made by the pnp state machine to power up the device.

This event is generated by the power state machine to indicate that the device been put into a Dx state either implicitly or explicitly. This event may have been in response to a power up request made by the pnp state machine to power down the device.

This event is generated by the power state machine to indicate that a request for the device to return to D has failed. Reception of this event will lead to the device stack being torn down.

This event is generated by the power state machine to indicate that a request for the device to go into a Dx state has failed. Reception of this event will lead to the device stack being torn down.

This event is sent by the parent PnP state machine to all of its enumerated children that are still present. This event is sent when the parent is being removed from the system. The parent will wait for each child to send a PnpEventChildrenRemovalComplete event to it before finishing processing of the PnpEventRemove event. The PnpEventChildrenRemovalComplete event is sent by the child PnP state machine to its parent when it has been successfully removed.

This function specifies the S idle capabilities and associated settings of the device. The function allows the driver writer to specify the following 

This function is called by the driver or a Framework component to indicate that the device has I O to process. If the count changes from 0 to non zero and if the device is in a low power state then the Power Policy state machine may send IRP MN SET POWER D in order to bring the device into the working state so that it can handle the I O requests. If WaitForDO is TRUE the device will be in D when the function returns to the caller. If FALSE is specified the device will be brought back into the D state asynchronously.

This function is called by the driver or a Framework component to indicate that the I O referred to by a previous call to WdfDevicePowerReference is complete. When the total count of outstanding I O drops to 0 it causes an event to be fed into the Power Policy state machine possibly causing it to send IRP MN SET POWER Dx so that the device moves into a low power state.

This function specifies the wake from Sx capabilities and associated settings of the device. The function allows the driver writer to specify the following 

This event is sent by the PnP state machine when the power policy state machine needs to be start. This start will be from the created or stopped Normal state. The PnP state machine sends this event after it has successfully processed the PnpEventStartDeviceCompleted event and while processing a PnpEventCancelStop from the query stopped state.

This event is sent by the PnP state machine when the power policy state machine is to stopped. This event will be sent when PnP state machine receives an IRP MN QUERY STOP DEVICE or IRP MN QUERY REMOVE DEVICE request. In response to this event the power policy state machine will disarm the device if armed for wake from S. Upon completion of processing of this event the power policy owner and the non owner state machines will send a PowerlmplicitD event to the power state machine.

This event is generated by the operating system when it is notifying system components that the machine is about to enter a lower power state. If the device has idled out and is in a low device Dx state the power policy state machine will attempt to bring the device back into D so that the device can be put into the correct Dx state for the new system state. This event differs from the PwrPolSx even in that the transition to a lower system power state can fail at this point. When a PwrPolSx event is generated the transition to a low system power state is not reversible.

This event is generated by the operating system when the system has returned from a lower system power state Sx or an attempt to enter a lower system power state has failed. The power policy state machine will put the device back into a power policy started state.

This event is generated when the device receives an IRP MN SET POWER SystemPowerState that is not for the PowerSystemWorking state. In response to this event the power policy state machine will decide what the appropriate Dx state the device should be put into and if the device should be armed to wake the machine from the state from which the machine is going into.

This event is generated when the device receives an IRP MN SET POWER SystemPowerState that is for the PowerSystemWorking state. In response to this event the power policy state machine can bring the device back into the D state or keep it in the Dx state if it was not armed for wake from Sx and the device is enabled for idle with out wake and is currently idle.

This event is generated by the power state machine when the device has been moved into a Dx state. This event is used as the synchronization mechanism between the power and power policy state machines between the actual request of the Dx IRP and the completion of the transition into that state.

This event is generated by the power state machine when the device has been moved into a D state. This event is used as the synchronization mechanism between the power and power policy state machines between the actual request of the D IRP and the completion of the transition into that state.

This event is generated when the device receives an IRP MN WAIT WAKE request. In response to this event the power policy state machine will invoke the EvtDeviceArmWakeFromS or EvtDeviceArmWakeFromSx event callback depending on the current state of the state machine.

This event is generated by the device when an IRP MN WAIT WAKE request is completed successfully by the wait wake owner of the stack. In response to this event the power policy state machine make invoke the EvtDeviceWakeFromSTriggered or EvtDeviceWakeFromSxTriggered event callback depending on the current state of the state machine.

This event is generated by the device when an IRP MN WAIT WAKE request is completed unsuccessfully by the wait wake owner of the stack. In response to this event the power policy state machine will invoke either the EvtDeviceDisarmWakeFromS or EvtDeviceDisarmWakeFromSx event callbacks to undo the arming performed in EvtDeviceArmWakeFromS or EvtDeviceArmWakeFromSx.

This event is generated by the device when the device has idled out into a Dx state and there is a need to bring the device back into D. For instance this need may be the arrival of a request into a power managed queue or the driver calling WdfDevicePowerReference. In response to this event the power policy state machine may bring the device back into the D state disarming it from wake if it had been previously armed.

This callback is invoked when the device has triggered its wake signal from Sx. The Framework should process the aspects of wake including moving the device back into D the system back into S restarting I O queues and so forth. Thus the driver probably does not have to register for this. It s mostly informational.

This event is generated when the device either receives a WMI request to change the S idle policy or the driver has called WdfDeviceUpdateSIdleSettings. In response to this event the power policy state machine may bring the device back into D disable the idle timer and put the device into the new power policy state as specified by the event source.

This event is sent by the PnP state machine when the device receives an IRP MN SURPRISE REMOVAL request. In response to this event the power policy state machine will not invoke any driver event callbacks which may touch hardware. Upon completion of processing of this event the power policy owner and the non owner state machines will send a PowerlmplicitD event to the power state machine.

This callback is invoked when the driver should arm its device to wake from S. Note that this does not include setting the bits in the PCI Power Management Capability structure. The PCI driver should perform that function. A driver should register for this callback if it needs to do additional operations such as reconfiguration of internal interrupt signals to wake for example.

This callback is invoked when the driver should disarm internal wake sources. This does not include setting bits in the PCI Power Management Capability structure. The driver generally only needs to undo operations it performed in EvtDeviceWakeArm.

This callback is invoked when the device has triggered its wake signal from S. The Framework will handle the components of wake including moving the device back into D restarting I O queues and so forth. Thus the driver probably does not have to register for this. It s mostly informational.

This callback is invoked when the driver should arm its device to wake from Sx. Note that this does not include setting the bits in the PCI Power Management Capability structure. The PCI driver should perform that function. A driver should register for this callback if it needs to perform additional operations such as reconfiguration of internal interrupt signals to wake for example.

This callback is invoked when the driver should disarm internal wake sources. Again this should not include setting bits in the PCI Power Management Capability structure. The driver performs undo top operations performed in EvtDeviceWakeArm.

This callback is invoked when the device has triggered its wake signal from Sx. The Framework should process the aspects of wake including moving the device back into D the system back into S restarting I O queues and so forth. This function is not guaranteed to be called if the device has actually triggered wake because there is an inherent race condition between the system power notification arriving to the device and the wake notification completing from the bus below it. Thus the driver probably does not have to register for this. It s mostly informational.

This event is sent by the device when it receives an IRP MN SET POWER DevicePowerState PowerDeviceD request. In response to this event the power state machine will bring the device into the D state calling the appropriate callbacks to restore the device s state. Upon successful processing of this event the power state machine sends a PnpEventPowerUp event to the PnP state machine and a PwrPolPowerUp event to the power policy state machine Upon failure to process this event the power state machine will send a PnpEventPowerDownUp event to the PnP state machine.

This event is sent by the device when it receives an IRP MN SET POWER DevicePowerState PowerDeviceDx request. In response to this event the power state machine will put the device into the Dx state calling the appropriate callbacks to save the device s state. Upon successful processing of this event the power state machine will send a PnpEventPowerDown event to the PnP state machine and a PwrPolPowerDown event to the power policy state machine Upon failure to process this event the power state machine will send a PnpEventPowerDownFailed event to the PnP state machine.

When device is the wait wake owner for the stack this event is sent by the device when it receives an IRP MN WAIT WAKE request. Before sending this event the wake request is pended. In response to this event the EvtDeviceEnableWakeAtBus event callback may be invoked.

This event is sent when the driver calls the WdfDeviceCompleteWaitWakeRequest API with a successful NTSTATUS value and the device is currently armed for wake at the bus level. In response to this event the power state machine may call EvtDeviceDisableWakeAtBus and complete the previously pended wake request. It is the power policy owner s responsibility to bring the device back into the D state.

This event is sent when the driver calls the WdfDeviceCompleteWaitWakeRequest API with an unsuccessful NTSTATUS value and the device is currently armed for wake for wake at the bus level. In response to this event the power state machine may call EvtDeviceDisableWakeAtBus and complete the previously pended wake request.

This event is sent when the power policy owner attempts to cancel an outstanding wait wake request. In response to this event the power state machine may call EvtDeviceDsiableWakeAtBus and complete the previously pended wake request.

This event is sent by both the power policy owner and non owner state machines. In response to this event the power state machine will bring the device into a D state. Upon completion of processing this event the power state machine will send a PnpEventPowerUp event to the PnP state machine and a PwrPolPowerUp event to the power policy state machine.

This event is sent by both the power policy owner and non owner state machines. In response to this event the power state machine will bring the device into the Dx state. Upon completion of processing this event the power state machine will send a PnpEventPowerDown event to the PnP state machine and a PwrPolPowerDown event to the power policy state machine

This event is sent by the parent power state machine to each child state machine when the parent enters the D state.

This event is sent by the PnP state machine when the device receives an IRP MN QUERY STOP DEVICE or IRP MN QUERY REMOVE DEVICE. In response to this event the power state machine moves to a state where it will expect a PowerlmplicitD event to be sent by the power policy state machine. When the PowerlmplicitD event is received the device will be moved into the Dx state and the appropriate callbacks will be called.

This event is sent by the PnP state machine when the device receives an IRP MN SURPRISE REMOVAL. In response to this event the power state machine will move to a state where it will expect a PowerlmplicitD event to be sent by the power policy state machine. When the PowerlmplicitD event is received the device will not be moved into the Dx state since it is no longer present in the system. No event callback which is allowed to touch hardware will be called.

This event is sent by the device when it receives an IRP MN DEVICE USAGE NOTIFICATION request disabling a device usage such as being on the paging path . In response to this event the power state machine may move from a non pageable D state to a pageable D state if the device initially had the DO POWER PAGABLE flag set.

This event is sent by the device when it receives an IRP MN DEVICE USAGE NOTIFICATION request enabling a device usage such as being on the paging path . In response to this event the power state machine may move from a pageable D state to a non pageable D state if the device initially had the DO POWER PAGABLE flag set.

A Framework queue object is generally involved in PnP Power in at least two ways. First it should be possible for the Power state machine to cause certain device s queues to hold or release depending on what power state the device is in. Second the queue should report to a Power Policy object when the queue transitions from idle to busy by calling WdfDevicePowerReference and from busy to idle by calling WdfDevicePowerDereference. In general a driver should be able to stipulate that a queue is one that participates in power decisions or it should stipulate that a queue is one that should not affect power decisions.

A Framework file object should be involved in PnP Power in one instance at least. For example it should allow for a driver to indicate that the device should not be put in a low power state while a particular file handle is open by calling WdfDevicePowerReference and WdfDevicePowerDereference. 

This is mostly true for devices which do not have a clear way of knowing when they are active or when there is something plugged into them. The most common example would be a serial port which may mark every open file handle as needing to keep the device active. This should generally be a rare requirement.

The process depicts some example considerations and system interactions such as device type considerations filter considerations and device operations. This process discussion is followed by some specific examples of the respective process components. In general state processing in accordance with the present invention can be provided in accordance with a plurality of conditions and or applications. Proceeding to of the process such conditions or state processes can change depending on several factors such as the type of device and associated driver that is interacting with the state machines previously described. For example this can include interactions with software only type objects where there is no actual hardware to control and thus state processing is somewhat minimized. Other type devices can include self contained devices having no internal power management considerations but are targets for other type operations such as a selective suspend state and yet other devices interact with more directly with the various states and events previously described. Some examples of these and other situations are described below.

At driver determinations and state processes can be affected by considerations of whether or not certain objects are present in a stack such as whether a Functional Driver Object FDO or filter object is present in the stack. At various state processes are possible depending on the power management situation at hand. These can include normal state operations at system sleep operations at system wake operations at and device removal operations at whereby the following discussion illustrates various exemplary situations that may occur with respect to the process . It is to be appreciated that a plurality of PnP or Power Management processes can occur that are in accordance with the event and state processes previously described.

In this aspect there is no actual hardware thus there is no power to manage and no plug to play with. Therefore this device driver generally only needs to respond minimally to PnP and power IRPs.

Since software only devices are not particularly interested in hardware related aspects it generally only provides callbacks for 

This type device generally consists of a single device e.g. PCI USB or ISA with no internal concept of power. It generally has no hardware states corresponding to D D D or D. It may or may not be enumerable. It may or may not be removable.

EvtDeviceDEntry performs hardware initialization when the device enters D. Even though the hardware doesn t support D states it may need to be reprogrammed when coming out of a sleep state.

Since this driver is instantiated e.g. within Windows via an AddDevice call and since this driver does not call WdfFdoInitSetFilter it is automatically marked as the Power Policy Owner. This implies that the Framework will automatically create an instantiation of the Power Policy state machine to go along with it. This driver generally instantiates one WDFQUEUE object and lets the defaults remain which implies that it responds to changes in power states.

This device can be moved between off and on. If there are no open handles to the device it can be moved into D. If a handle is opened when the device is in D then it will be moved to D. At times the device is in D an external event may occur that will trigger PME . This can result in the device being moved back into D. This may happen when the machine is in S or when the machine is asleep. This type device may correspond roughly to a modem for example.

EvtDeviceCreate Tracks the number of open file handles. When called it calls WdfDevicePowerReference.

EvtDeviceClose Tracks the number of open file handles. When called it calls WdfDevicePowerDereference.

One of at least two sub scenarios may happen next. First bringing the device on line may cause an application or service that is registered for device notification to open a handle to this device. Second no handles may be opened.

This above situation leads to at least two cases the wake signal fires and a handle is opened. First what happens when a handle is opened 

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture USA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 1102.3 Token Ring IEEE 1102.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the present invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly the present invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

