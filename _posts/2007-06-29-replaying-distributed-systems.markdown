---

title: Replaying distributed systems
abstract: Replaying distributed systems involves playing a distributed system in a simulator using data from a real-world operation. In an example embodiment, a simulation process is to simulate a distributed system that has a first instance and a second instance. The simulation process includes a first simulation object corresponding to the first instance and a second simulation object corresponding to the second instance. In another example embodiment, communications between the first instance and the second instance are simulated within the simulation process using function calls between the first simulation object and the second simulation object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07925487&OS=07925487&RS=07925487
owner: Microsoft Corporation
number: 07925487
owner_city: Redmond
owner_country: US
publication_date: 20070629
---
Distributed systems can involve many nodes. In fact these nodes can number in the tens hundreds thousands millions or more nodal instances. Each instance may be for example a process an application a physical device some combination thereof and so forth. The individual nodes of a distributed system can operate interactively with one other with two other or with many other nodes of the distributed system. Such interactions may occur once or be repeated.

The many nodes of a distributed system usually communicate messages between and amongst each other. Each node also functions locally by acting on local resources. These various actions and interactions result in many different non deterministic concurrences happening within the distributed system. As a result of these concurrent events and the sheer number of nodal instances bugs in distributed systems are usually difficult to analyze. It is even more difficult to diagnose and or identify the cause or causes of bugs in distributed systems.

Replaying distributed systems involves playing a distributed system in a simulator using data from a real world operation. In an example embodiment a simulation process is to simulate a distributed system that has a first instance and a second instance. The simulation process includes a first simulation object corresponding to the first instance and a second simulation object corresponding to the second instance. In another example embodiment communications between the first instance and the second instance are simulated within the simulation process using function calls between the first simulation object and the second simulation object. In yet another example embodiment data from a real world operation of the distributed system for each instance is memory mapped such that each respective data file can be switched into simulation process memory space when the simulation process switches so as to simulate each respective instance.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement etc. implementations are described herein.

One paradigm for debugging distributed systems is to employ replay technology. With replay technology trace logs are recorded while the real world distributed system operates. The trace logs can record such things as inputs memory states and so forth. Inputs can include non deterministic inputs such as received messages random number generations and so forth. The nodal instances of the distributed system are then simulated in a replay manner by applying respective trace logs to respective instances. Conflicts and other inconsistencies may be detected between the trace logs and the simulated instances.

A distributed simulation may be accomplished using the following group replay approach Each respective instance which is often simulating a real world process may be simulated with a respective process. With this approach real world messages between simulated instances are realized in the simulation as local process communications LPCs or inter process calls. To enforce the correct happens before ordering a separate controller process is created as part of the simulation. This controller process also exchanges LPCs with other processes.

However the approach described above entails a number of disadvantages. For example each process consumes some level of resources e.g. memory kernel space etc. so the number of instances that can be simulated per device is relatively limited. Secondly LPCs between two processes involve operating system calls which are time consuming. Third the code executing each process for each instance is redundantly duplicated. Fourth the operating system s scheduler in conjunction with the process controlling the simulation introduces additional overhead. Fifth it is likely that there are many memory swaps from disk to random access memory RAM . These and other disadvantages can limit the scalability and or performance of group replay using the above described approach.

In contrast certain embodiments as described herein can improve performance and or scalability. Any given single implementation may include one or more of the following example aspects. These example aspects are presented in the context of the following example embodiment Each instance of multiple instances of a distributed system is simulated by a single simulation process. For example each respective instance may correspond to a respective simulation object of the simulation process. A simulation controller may also be part of the simulation process. Consequently there are fewer process level resources being consumed. The distributed system replaying may be accomplished with one set of process information and process code segment. Furthermore messages between simulated instances may be simulated with function calls which are relatively fast.

Moreover instance states from the trace logs and or simulated states during the replaying may be implemented as memory mapped files. In addition to potentially reducing disk swapping the memory space of the simulation process may be redirected to the memory mapped file corresponding to the instance currently being simulated. These example aspects and other aspects as well as alternative aspects of multiple different embodiments are described further herein below with particular reference to .

In an example embodiment each instance may be a process an application a part of an application a physical device a part of a physical device a protocol implementation a module formed from processor executable instructions some combination thereof and so forth. Each instance may comprise a node of distributed system . Nodes and thus instances may be co located within a single application and or physical device located in different applications and or physical devices located in the same or different networks and so forth. By way of example only each instance may be a peer entity of a peer to peer P2P network.

As illustrated distributed system simulator includes simulated distributed system . Simulated distributed system includes simulated instances . . . and simulated messages . In an example embodiment distributed system simulator performs a simulation on distributed system to produce simulated distributed system . This simulation may involve a replaying of distributed system . An example replaying is described herein below with particular reference to .

In an example embodiment distributed system is operated in the real world and trace events are logged into trace logs . . . . These trace logs are collected from the different real world instances and input into distributed system simulator . By way of example but not limitation such trace logs can include nondeterministic events such as messages received from the network data read from files thread scheduling decisions environmental system calls etc. memory address allocations heap relinquishments etc. system times random number generation etc. and so forth.

In operation trace logs are replayed by distributed system simulator . For example during a replay events from different instances are collected from trace logs sequentialized into a total execution order based on a logical clock and re executed one by one in distributed system simulator . More specifically the executable binary may be rerun inside the simulator with e.g. non deterministic events being fed from trace logs .

Distributed system simulator produces simulated states of instances . It can also produce inconsistencies between the simulated states and logged states as evidence of potential bugs. Comparisons between the simulated states and the logged states may be performed manually or may be performed automatically by distributed system simulator . From the inconsistencies one or more bugs can be detected and identified to thereby make a bug determination . After determining the existence and makeup of a bug a developer or other programmer can create and apply a fix to instances of distributed system .

Generally an example embodiment of distributed system simulator may function as follows One simulation process is used to replay instances . . . . File mapping is used to handle memory switches between different instances. For instance the state of an instance is stored in a memory mapped file and it is mapped into the process memory space on demand. Thus to switch the replayed instance from A to B the entries in a page table of the simulation process may be updated to the base address of the mapped memory of instance B. The simulation process aspect is described herein below with particular reference to . The memory mapping aspect is described herein below with particular reference to . These example aspects may be used separately or together.

In an example embodiment simulation process executes in a user space . Operating system executes in a kernel space . Generally scheme can be employed to replay a distributed system using trace logs of that are derived from a real world operation of multiple instances . . . . With scheme a simulation is performed for n respective instances . . . using n respective simulation objects . . . .

As illustrated the n instances . . . of distributed system are simulated by n simulation objects . . . that are each within a single simulation process . Alternatively x simulation objects may be simulated in n x different simulation processes with x representing an integer having a value of two or greater. When two or more simulation objects are created and or present within a given simulation process communications between any such two simulation objects may be implemented with function calls.

Thus intra process communications can be realized as function calls. Function calls between two simulation objects can simulate real world communications e.g. as recorded by trace logs between two instances . Function calls can also be used for other communications between two simulation objects . Function calls can be realized by way of example only as thread level calls. Consequently they can be made without relying on a slower operating system call.

Function calls can also be used for communication exchanges involving simulation controller . Simulation controller is responsible for orchestrating the simulation of distributed system . Simulation controller controls the application of trace logs as the replaying simulation unfolds. It is responsible for the temporal ordering of events and thus maintains the happens before relationships that occurred during the real world operation. By way of example only a logical clock such as Lamport s logical clock may be employed.

Instructions and other communications from and responses to simulation controller can also be implemented within simulation process as function calls . This can be more efficient than making calls to the operating system. Moreover simulation controller can avoid some measure of conflict with the operating system s scheduling efforts by relying on user level scheduling instead of kernel level scheduling.

In the drawings are flow diagrams and respectively. Implementations of flow diagrams and may be realized for example as processor executable instructions. Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth. The acts of these flow diagrams may be performed in many different environments by one or more of a number of different devices and or with a variety of operating system and or middleware configurations. Hence although the descriptions of certain blocks and the acts thereof reference other elements that are described herein they do so by way of example only. The order in which the methods are described is not intended to be construed as a limitation and any number of the described blocks can be combined augmented rearranged and or omitted to implement a respective method or an alternative method that is equivalent thereto.

At block a second instance of the distributed system is simulated in the simulation process. For example a second instance of distributed system may be simulated in simulation process . Second instance may be simulated by for instance a second simulation object a simulation object is implicitly but not explicitly shown in .

At block messages between the first and second instances of the distributed system are simulated as intra process function calls within the simulation process. For example messages between first and second instances and of distributed system may be simulated as intra process function calls within simulation process . The function calls by way of example only may be thread calls and they may avoid making an operating system call.

At block a simulation controller is implemented in the simulation process with the simulation controller playing trace logs corresponding to the first and second instances of the distributed system. For example a simulation controller may be implemented within simulation process . Simulation controller may play respective first and second trace logs that correspond to respective first and second instances of distributed system . Simulation controller may ensure that the temporal order of events as they occurred in the real world operation of distributed system is maintained during the simulated replaying operation of simulated distributed system .

At block simulation process memory is switched from a first memory mapped file corresponding to the first instance to a second memory mapped file corresponding to the second instance. First and second memory mapped files that correspond respectively to first and second instances and as well as simulation process memory switching are described in relative detail herein below in the following section with particular reference to . Generally a replaying simulation involves the following three parts occupying virtual memory space process information a data segment and a code segment. The data from trace logs may be mapped on demand into RAM. As the replaying unfolds respective trace log data for respective simulation instances are mapped into the data segment when the code segment is to process a given simulation instance.

At block the output of the replayed distributed system is provided as the results of a simulation. For example output resulting from the replaying of a distributed system by a distributed system simulator may be the simulated states of multiple instances may be inconsistencies between simulated states and trace logged states some combination thereof and so forth.

In an example embodiment each respective instance . . . corresponds to a respective instance state . . . . Each respective instance state . . . is associated with a respective memory mapped file . . . . Simulation process is associated with simulation process memory . Generally simulation process can be directed to a different memory mapped file by switching which memory mapped file is currently assigned to be process memory . This memory switching or mapping is performed when simulation process switches from simulating one instance e.g. with a simulation object to simulating another instance e.g. with another simulation object .

More specifically each instance state includes the data from a trace log of a corresponding instance and or the current simulated state of the corresponding instance . The contents of instance state are memory mapped to a file to create memory mapped file . For example the contents of a disk based file having instance state may be mapped and moved into a RAM based file having instance state . This memory mapped file can usually be accessed more quickly.

As illustrated each memory mapped file . . . may be switched . . . into being process memory . In other words memory accesses to simulation process memory by simulation process may be redirected or mapped to a desired memory mapped file . An example technique for implementing such a memory redirection is described herein below with particular reference to .

More specifically for an example embodiment a virtual memory paradigm is implemented by an operating system of on which a distributed system simulator is running. With the virtual memory paradigm memory is divided into pages and swapped from disk to RAM to increase the total apparent amount of RAM on the device. As illustrated the memory is separated into p pages of memory . . . with p being some integer.

Page mapping table is used to map memory addresses to different pages. Page mapping table includes r page reference entries . . . with r being some integer. Each value in a page reference entry points to a memory page .

Although virtual memory paradigms may be implemented in a variety of manners the following describes virtual memory by way of example but not limitation Memory mapped file is associated with a memory area having memory pages starting with memory page . Memory mapped file is associated with a memory area having memory pages . . . starting with memory page .

In an example virtual memory operation a simulation memory address is divided into a high portion and a low portion. The high portion references or points to a page reference entry of page mapping table . At one time value of page reference entry points to memory page which directs simulation process at arrow to memory mapped file . This corresponds to a simulation of first instance .

At another time the simulation of distributed system switches to instance which corresponds to simulation of another instance . To accommodate this switching of instances that are being simulated simulation process memory of is to be switched to memory mapped file . Value of page reference entry is changed so that it references or points to memory page . This effectively redirects simulation process at arrow to memory mapped file . The low portion of simulation memory address is usually used as an offset within a given page . For a typical 32 bit MICROSOFT WINDOWS operating system implementation by way of example only adjusting value can entail changing 8 bytes of memory while adjusting a whole page can entail changing 4 kilobytes of memory.

At block a second file that is associated with a second instance state is memory mapped with the second instance state corresponding to a second instance. For example a second instance state corresponding to a second instance may be memory mapped to create a second memory mapped file a second instance state and a memory mapped file are implicitly but not explicitly shown in the drawings .

At block it is determined that a simulation process is to switch from simulating the first instance to simulating the second instance. For example a distributed system simulator and or a simulation controller thereof may determine that simulation process is to switch from simulating first instance to simulating second instance .

At block simulation process memory is switched from the first memory mapped file corresponding to the first instance to the second memory mapped file corresponding to the second instance. For example simulation process memory of simulation process may be switched or redirected from first memory mapped file corresponding to first instance to second memory mapped file corresponding to second instance .

Block A describes example act s for implementing the act s of block . At block A in a page table page reference entry associated with the simulation process memory a first value pointing to the first memory mapped file is replaced with a second value pointing to the second memory mapped file. For example in a page mapping table at a page reference entry that is associated with a simulation process memory e.g. via at least a portion of a simulation memory address a first value that points to first memory mapped file is replaced with a second value that points to second memory mapped file a pointing or directing is implicitly but not explicitly shown in the drawings by way of the variable n .

Generally a device may represent any computer or processing capable device such as a server device a workstation or other general computer device a data storage repository apparatus a personal digital assistant PDA a mobile phone a gaming platform an entertainment device a router computing node a mesh or other network node a wireless access point some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In an example embodiment of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more human device interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports a network communications stack a radio and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii human device interfaces include those that communicate by wire or wirelessly to human device interface equipment e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device . Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth.

Thus realizations for replaying distributed systems may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology and one may be realized as a general purpose processor e.g. a central processing unit CPU a microprocessor a controller etc. a graphics processing unit GPU a derivative thereof and so forth. Media may be any available media that is included as part of and or accessible by device .includes volatile and non volatile media removable and non removable media storage and transmission media e.g. wireless or wired communication channels hard coded logic media combinations thereof and so forth. Media is tangible media when it is embodied as a manufacture and or as a composition of matter. For example media may include an array of disks or flash memory for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed and or otherwise processed link s on network for transmitting communications and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein. Such functions include but are not limited to i those acts that are illustrated in flow diagrams and of ii those of a distributed system simulator of et seq. iii those undertaken to replay a distributed system e.g. as shown in and other schemes and techniques described herein combinations thereof and so forth.

The devices acts aspects features functions procedures modules data structures techniques components parts etc. of are illustrated in diagrams that are divided into multiple blocks and other elements. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks and or other elements can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses arrangements etc. for replaying distributed systems.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other example embodiments have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

