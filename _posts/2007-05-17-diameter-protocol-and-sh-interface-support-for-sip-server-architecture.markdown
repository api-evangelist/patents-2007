---

title: Diameter protocol and SH interface support for SIP server architecture
abstract: A SIP server can be distributed over a cluster network and handle the processing of various SIP communications. A Diameter protocol web application can be deployed on the engine tier of the SIP server for enabling communication between the SIP server and an HSS. A profile service API can be provided that allows applications running on the SIP server to access user profile data stored on the HSS. The applications can also be allowed to subscribe to notifications about changes to the user profile data on the HSS. An Sh interface provider can be deployed on the SIP server for generating and responding to Diameter command codes. SIP servlets can access the user profile data in the form of an XML document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08219697&OS=08219697&RS=08219697
owner: Oracle International Corporation
number: 08219697
owner_city: Redwood Shores
owner_country: US
publication_date: 20070517
---
The present application claims the benefit of U.S. Provisional Patent Application No. 60 800 949 entitled DIAMETER PROTOCOL AND SH INTERFACE SUPPORT FOR SIP SERVER ARCHITECTURE by Anno R. Langen et al. filed on May 17 2006 which is incorporated herein by reference in its entirety.

The following commonly owned United States Patents and Patent Applications including the present application are related to each other. Each of the other patents applications are incorporated by reference herein in their entirety 

U.S. patent application Ser. No. 11 378 188 entitled SYSTEM AND METHOD FOR MANAGING COMMUNICATIONS SESSIONS IN A NETWORK by Reto Kramer et al. filed on Mar. 17 2006 now U.S. Pat. No. 7 870 265 issued Jan. 11 2011 

U.S. patent application Ser. No. 11 384 056 entitled SYSTEM AND METHOD FOR A GATEKEEPER IN A COMMUNICATIONS NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. Provisional Patent Application No. 60 801 091 entitled SIP AND HTTP CONVERGENCE IN NETWORK COMPUTING ENVIRONMENTS by Anno R. Langen et al. filed on May 16 2006 

U.S. Provisional Patent Application No. 60 800 943 entitled HITLESS APPLICATION UPGRADE FOR SIP SERVER ARCHITECTURE by Anno R. Langen et al. filed on May 16 2006 

U.S. Provisional Patent Application No. 60 801 083 entitled ENGINE NEAR CACHE FOR REDUCING LATENCY IN A TELEOMMUNICATIONS ENVIRONMENT by Anno R. Langen et al. filed on May 16 2006 

U.S. patent application Ser. No. 11 434 022 entitled SYSTEM AND METHOD FOR CONTROLLING DATA FLOW BASED UPON A TEMPORAL POLICY by Narendra Vemula et al. filed on May 15 2006 now U.S. Pat. No. 7 953 877 issued May 31 2011 

U.S. patent application Ser. No. 11 434 024 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY PUSH PROTOCOLS BASED UPON A POLICY by Bengt Inge Jakobsson et al. filed on May 15 2006 

U.S. patent application Ser. No. 11 434 010 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY MULTIMEDIA MESSAGE PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 now U.S. Pat. No. 7 957 403 issued Jun. 7 2011 

U.S. patent application Ser. No. 11 434 025 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY SHORT MESSAGE PEER TO PEER PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 

U.S. patent application Ser. No. 11 432 934 entitled SYSTEM AND METHOD FOR SHAPING TRAFFIC by Jan Thomas Svensson filed on May 12 2006 now U.S. Pat. No. 7 788 386 issued Aug. 31 2010.

The current invention relates generally to managing telecommunications and more particularly to providing diameter and sh interface support for an SIP server.

Conventionally telecommunications and network infrastructure providers have relied on often decades old switching technology to providing routing for network traffic. Businesses and consumers however are driving industry transformation by demanding new converged voice data and video services. The ability to meet these demands often can be limited by existing IT and network infrastructures that are closed proprietary and too rigid to support these next generation services. As a result telecommunications companies are transitioning from traditional circuit switched Public Switched Telephone Networks PSTN the common wired telephone system used around the world to connect any one telephone to another telephone to Voice Over Internet Protocol VoIP networks. VoIP technologies enable voice communication over vanilla IP networks such as the public Internet. Additionally a steady decline in voice revenues has resulted in heightened competitive pressures as carriers vie to grow data service revenues and reduce churn through the delivery of these more sophisticated data services. Increased federal regulation security and privacy issues as well as newly emerging standards can further compound the pressure.

However delivering these more sophisticated data services has proved to be more difficult than first imagined. Existing IT and network infrastructures closed proprietary network based switching fabrics and the like have proved to be too complex and too rigid to allow the creation and deployment of new service offerings. Furthermore latency and migration of services have become important issues in addressing the processing of telecommunications as more and more users expect seemingly instantaneous and uninterrupted access to their devices.

An SIP server can be distributed over a cluster network and handle the processing of various SIP communications. A Diameter protocol web application can be deployed on the engine tier of the SIP server for enabling communication between the SIP server and an HSS. A profile service API can be provided that allows applications running on the SIP server to access user profile data stored on the HSS. The applications can also be allowed to subscribe to notifications about changes to the user profile data on the HSS. An Sh interface provider can be deployed on the SIP server for generating and responding to Diameter command codes. SIP servlets can access the user profile data in the form of an XML document.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. References to embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

In the following description numerous specific details are set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail so as not to obscure the invention.

Although a diagram may depict components as logically separate such depiction is merely for illustrative purposes. It can be apparent to those skilled in the art that the components portrayed can be combined or divided into separate software firmware and or hardware components. For example one or more of the embodiments described herein can be implemented in a network accessible device appliance such as a router. Furthermore it can also be apparent to those skilled in the art that such components regardless of how they are combined or divided can execute on the same computing device or can be distributed among different computing devices connected by one or more networks or other suitable communication means.

In accordance with embodiments there is provided a system and method for providing Diameter protocol and Sh interface support for a session initiation protocol SIP server architecture. A SIP server as described in the present disclosure can be distributed over a cluster network and handle the processing of various SIP communications. In one embodiment the SIP server includes an engine tier for processing a multitude of messages and transactions as well as a state tier for maintaining the data associated with these transactions. A Diameter protocol web application can be deployed on the engine tier of the SIP server for enabling communication between the SIP server and an HSS. A profile service API can be provided that allows applications running on the SIP server to access user profile data stored on the HSS. The applications can also be allowed to subscribe to notifications about changes to the user profile data on the HSS. An Sh interface provider can be deployed on the SIP server for generating and responding to Diameter command codes. SIP servlets can access the user profile data in the form of an XML document.

A Session Initiation Protocol SIP Server and a Network Gatekeeper can comprise a portfolio of products that collectively make up the Communications Platform . The SIP Server provides the Communications Platform with a subsystem in which application components that interact with SIP based networks may be deployed. The Network Gatekeeper provides a policy driven telecommunications Web services gateway that allows granular control over access to network resources from un trusted domains.

A variety of shared and re usable software and service infrastructure components comprise the Communications Platform . For example an Application Server such as the WebLogic Application Server by BEA Systems Inc. of San Jose Calif. This Application Server may be augmented and adapted for deployment in telecommunications networks while providing many features and functionality of the WebLogic Server counterpart widely deployed in enterprise computing environments. Application Server embodiments for use in the telecommunications applications can provide a variety of additional features and functionality such as without limitation 

Analogously communications platform embodiments can provide a variety of additional features and functionality such as without limitation 

Communications platform comprises a SIP Server WLSS and a Network Gatekeeper WLNG . Tools for interacting with Web Services such as a Web Service Universal Description Discovery Interface WS UDDI a Web Service Business Process Execution Language WS BPEL may be coupled to the SIP Server and the Network Gatekeeper in embodiments. A log trace and database can assist with troubleshooting. In some deployments the Communications Platform can interface with an OSS BSS system via resource adapters . Such interfaces can provide access to billing applications Operation Administration and Maintenance OAM applications and others. A policy engine can control the activities of the above described components which can be implemented in a scalable cluster environment SCE .

A Communications Platform embodiment can provide an open high performance software based fault tolerant platform that allows operators to maximize revenue potential by shortening time to market and significantly reducing per service implementation and integration cost and complexity. The Communications Platform is suitable for use by for Network Infrastructure Vendor Network Operators and Communications Service Providers in multiple deployment scenarios ranging from fully IMS oriented network architectures to hybrid and highly heterogeneous network architectures. It is not restricted to use only in carrier networks however and may be deployed in Enterprise communications networks without restriction or extensive customization. When deployed in conjunction with an IP Multimedia Subsystem the Communications Platform can serve in the role of an IMS SIP Application Server and offers Communications Service Providers an execution environment in which to host applications such as the WebLogic Network Gatekeeper components and standard service enablers.

As illustrated the SIP server can be used as a back to back user agent B2BUA in a typical telecommunications environment. A B2BUA can take the place of an intermediary between communications between user agents including various cellular phones wireless devices laptops computers applications and other components capable of communicating with one another electronically. The B2BUA can provide multiple advantages including controlling the flow of communication between user agents enabling different user agents to communicate with one another e.g. a web application can communicate with a cellular phone as well as various security advantages. As an illustration the user agents can transmit to the SIP server instead of communicating directly to each other and thus malicious users can be prevented from sending spam and viruses hacking into other user agent devices and otherwise compromising security.

The SIP server can be implemented as a Java Enterprise Edition application server that has been extended with support for the session initiation protocol SIP as well as other operational enhancements that allow it to meet the demanding requirements of the next generation protocol based communication networks. In one embodiment the SIP server can include an Enterprise Java Beans EJB container a Hyper Text Transfer Protocol HTTP servlet container an SIP servlet container various Java 2 Enterprise Edition J2EE services and SIP and HTTP components. The SIP stack of the server can be fully integrated into the SIP servlet container and can offer much greater ease of use than a traditional protocol stack. A SIP servlet Application Programming Interface API can be provided in order to expose the full capabilities of the SIP protocol in the Java programming language. The SIP servlet API can define a higher layer of abstraction than simple protocol stacks provide and can thereby can free up the developer from concern about the mechanics of the SIP protocol itself. For example the developer can be shielded from syntactic validation of received requests handling of transaction layer timers generation of non application related responses generation of fully formed SIP requests from request objects which can involve correct preparation of system headers and generation of syntactically correct SIP messages and handling of lower layer transport protocols such as TCP UDP or SCTP.

In one embodiment the container is a server software that hosts applications i.e. contains them . In the case of a SIP container it hosts SIP applications. The container can perform a number of SIP functions as specified by the protocol thereby taking the burden off the applications. At the same time the SIP container can expose the application to SIP protocol messages via the SIP Servlet API on which applications can perform various actions. Different applications can thus be coded and deployed to the container that provides various telecommunication and multimedia services.

As illustrated a message such as a phone call request or some other transfer of data associated with SIP can come into the cluster from the internet such as over VoIP phone or some other type of network . This message can be received and handled by a load balancer which can be responsible distributing message traffic across the engines such as engine node and engine node in the cluster. The load balancer can be a standard load balancing appliance hardware device and it is not necessary that it be SIP aware there is no requirement that the load balancer support affinity between the engines and SIP dialogs or transactions. However in alternative embodiments certain advantages may be obtained by implementing a SIP aware load balancer as discussed in further detail below. Alternatively the load balancer can be implemented as software that distributes the messages to the various engines. In the various embodiments the primary goal of the load balancer can be to provide a single public address that distributes incoming SIP requests to available servers in the SIP server engine tier . Such distribution of requests can ensure that the SIP server engines are fully utilized. The load balancer can also be used for performing maintenance activities such as upgrading individual servers or applications without disrupting existing SIP clients.

In one embodiment the SIP server can provide a two tier cluster architecture model to handle the incoming messages. In this model a stateless engine tier can process all signaling traffic and can also replicate transaction and session state to the state tier and its partitions . Each partition can consist of any number of nodes replicas distributed across any number of hosts such as host and host which can be implemented as computers linked in a cluster type network environment. The state tier can be an n way peer replicated Random Access Memory RAM store that maintains various data objects which can be accessed by the engine nodes in the engine tier. In this manner engines can be provided a dual advantage of faster access to the data objects than retrieving data from a database while at the same time engines can be freed up from having to store the data onto the engine tier itself. This type of separation can offer various performance improvements. The state tier can also function as a lock manager where call state access follows a simple library book model i.e. a call state can be checked out by one SIP engine at a time .

The engine tier can be implemented as a cluster of SIP server instances that hosts the SIP servlets which provide various features to SIP clients. In one embodiment the engine tier is stateless meaning that most SIP session state information is not persisted in the engine tier but is obtained by querying the state tier which can in turn provide replication and failover services for SIP session data. In alternative embodiments the engine tier can have state maintained in a local near cache for improving latency.

The primary goal of the engine tier can be to provide maximum throughput combined with low response time to SIP clients. As the number of calls or their duration increases more server instances can be added to the engine tier to manage the additional load. It should be noted however that although the engine tier may include many such server instances it can be managed as a single logical entity. For example the SIP servlets can be deployed uniformly to all server instances by targeting the cluster itself and the load balancer need not maintain affinity between SIP clients and individual servers in the engine tier.

In various embodiments the state tier can be implemented as a cluster of SIP server instances that provides a high performance highly available in memory store for maintaining and retrieving session state data for SIP servlets. This session data may be required by SIP applications in the SIP server engine tier in order to process incoming messages. Within the state tier session data can be managed in one or more partitions where each partition manages a fixed portion of the concurrent call state. For example in a system that uses two partitions the first partition could manage one half of the concurrent call state e.g. A M and the second partition can manage the other half e.g. N Z . With three partitions each can manage a third of the call state and so on. Additional partitions can be added as needed to manage large number of concurrent calls.

In one embodiment within each partition multiple servers can be added to provide redundancy and failover should the other servers in the partition fail. When multiple servers participate in the same partition those servers can be referred to as replicas because each server maintains a duplicate copy of the partition s call state. For example nodes and of the partition can be implemented as replicas. Furthermore to increase the capacity of the state tier the data can be split evenly across a set of partitions as previously discussed. The number of replicas in the partition can be called the replication factor since it determines the level of redundancy and strength of failover that it provides. For example if one node goes down or becomes disconnected from the network any available replica can automatically provide call state data to the engine tier.

Replicas can join and leave the partition and each replica can serve as exactly one partition at a time. Thus in one embodiment the total available call state storage capacity of the cluster is a summation of the capacities of each partition .

In one embodiment each partition can peer replicated meaning that clients perform all operations reads writes to all replicas in the partition wherein the current set of replicas in the partition is called the partition view . This can provide improved latency advantages over more traditional synchronous primary secondary architecture wherein one store acts as a primary and the other nodes serve as secondaries. Latency is reduced because there is no wait for the second hop of primary secondary systems. The peer replicated scheme can provide better failover characteristics as well since there does not need to be change propagation delay.

In one embodiment the engine nodes can be responsible for executing the call processing. Each call can have a call state associated with it. This call state can contain various information associated with the call such as the ids of the caller callee where the caller is what application is running on the callee any timer objects that may need to fire in order to process the call flow as discussed below as well as any other data that may correlate to a call or a message. The state for each call can be contained in the state tier . The engine tier on the other hand could be stateless in order to achieve the maximum performance. In alternative embodiments however the engine tier can have certain amounts of state data stored thereon at various times.

In one embodiment a typical message processing flow can involve locking getting the call state processing the message and then putting unlocking the call state. The operations supported by the replicas for normal operations can include 

In various embodiments the engine tier can maintain mainly short lived objects and any long lived objects which may be needed for message processing can be stored on the state tier. This can provide improvements in latency during garbage collection. As an illustration the Java Virtual Machine JVM garbage collector can safely and quickly remove the short lived objects from memory without interfering with the execution of various other threads which may be in the process of executing. The longer lived objects on the other hand are not as easily removed by the garbage collector since they may be referenced and depended on by various entities and thus in some cases the JVM garbage collector may need to stop processing all threads in order to safely perform its garbage collection. This is due in part to the scoping of the short lived and long lived objects. Short lived objects typically exist in a different more localized memory scope than the long lived objects which may be referenced by more entities. Thus it can be more difficult for garbage collectors to ensure that every executing entity has finished using the long lived objects and various threads are usually stopped in order to perform their regular garbage collection. This can introduce latency.

In order to deal with such issues the engine tier can maintain mostly short lived objects. In cases where longer lived objects are needed by the engine tier they can be retrieved from the state tier used as short lived objects in the engine tier and subsequently pushed back to the state tier. This can be advantageous in that garbage collection can cause lesser interference with thread execution in the engine tier.

In various embodiments the state tier can maintain call state in various data objects residing in the random access memory RAM of a computer. This can provide significant access speed advantages to the engine tier over the use of a database. Alternatively if latency is not an issue call state can be maintained in a database or some other form of persistent store which can be accessed albeit slower by the engine tier. State of various applications running on the SIP server can also be maintained on the state tier. Developers can be provided an API to allow their applications to access the state tier and to store various data thereon for later access by various applications. Alternatively application state may be stored in a database.

In various embodiments the SIP server can enable communications with a home subscriber server HSS by implementing the Diameter protocol and the Sh interface. The SIP server can access the HSS in order to query or update a user s data stored on the HSS or to subscribe and receive notifications when a user s data changes thereon.

An HSS server can be thought of as a database for storing information about individual users. Typically this information includes a user profile which can be accessed via the Sh interface of the Diameter protocol. The profile can be sent over the protocol as groups of name value pairs and it can be implemented by the SIP server in handling telecommunications with various clients and users. For example the SIP server may treat various phone calls differently depending on the information about the user that is provided by the HSS server.

In various embodiments the engine tier of the SIP server can have applications running thereon which handle communications as well as retrieve provide information to and from the HSS server. The user data available to the SIP server may be defined by a service running on the SIP server or it may be a subset of the user s IMS profile data hosted on the HSS. The Sh interface can define the IMS profile data that can be queried and updated via Sh. The user data accessible via the Sh interface can be presented as an extensive markup language XML document.

The SIP server can implement the Diameter base protocol as a web application that is deployed to the server or run as a standalone client. Diameter can be supported over various transport protocols such as TCP and TLS. The Sh interface can be implemented as a provider to the base Diameter web application. This provider can transparently generate and respond to Diameter command codes defined in Sh application specification. A higher level application programming interface API can be provided that can enable SIP servlets to manage user profile data as an XML document using the XML Document Object Model DOM . Furthermore subscriptions and notifications for changed profile data can be managed by implementing a profile listener interface in a SIP servlet.

As illustrated a load balancer can be the SIP client entry way to the cluster network implementing the SIP server. As previously discussed the load balancer can distribute traffic to the engine nodes in the engine tier which can query the state tier replicas in various partitions for state needed to process the traffic.

The HSS server can often be a most connected to element in the IMS network. As such many carriers find the scalability of the HSS to be important and too many connections undesirable. The SIP server architecture can provide for Diameter relay nodes in order to limit the number of open connections to the HSS. The redundant instances of the relay node can also provide for fault tolerance in case one fails. The Diameter relay nodes can maintain a sticky connection for responses to the various engines and can be a simple relay node e.g. need not write any headers but simply allow messages to pass through .

In various embodiments the engine tier can implement a high number of engine nodes which may need access to the HSS server. Rather than creating an open connection on the HSS for every engine node relays can be provided which can allow requests and responses to pass through to and from the HSS. In this manner the number of direct connections to the HSS server can be reduced to a smaller number e.g. 1 or 2 .

The Diameter can also be able to map diameter responses back to the appropriate context. For example the Diameter implementation can keep state associated by using a triplet of user referenced application session and data referenced parameters.

In various embodiments the Diameter web application can be deployed on the engine tier cluster to each engine node as previously discussed. The web application can be started before all the other web applications and SIP servlets deployed to the cluster. Further the SIP server can provide an API for querying and modifying subscriber profile data or to manage subscriptions for receiving notifications about changed profile data. There can be two approaches for managing profile data. One approach can manage profile data by the application. Using this approach the SIP servlet can explicitly request user profile documents and nodes using the Sh provider application. The provider can return a local document set which can then be read or modified by the servlet using standard DOM techniques. The updates to the local documents can be applied to the HSS after a commit operation or immediately after modifying the data. Under another approach the SIP server container can maintain a document set for all SIP servlets that are registered to process a given SIP message. Servlets can specify the required user profile data as the value in a parameter of the deployment descriptor and the container can then ensure that data is available to servlet methods as they are executed. The container can also automatically apply updates to the document set data whenever it writes the associated call state to the state tier.

Servlets that use application managed profile data can explicitly obtain a document set from a factory and then use the document set like a map collection object. Document sets can be retrieved by specifying a key that selects both the Sh XML document and one or more XML nodes. For example the document selector and the node selector can be separated by a specified character s .

In one embodiment the document selector string identifies the XML document to be retrieved by a Diameter interface. The first portion of the selector can identify the Diameter interface provider to use for retrieving the document. The next element can be a URI that corresponds to the User Identity or Public Identity of the user whose profile is being retrieved. The following element can specify the data reference type being requested. Other requests can use an access key specified by another element. More such elements can also be provided.

The node selector can define the nodes of the Sh document that is retrieved. For example the repository data reference can return an XML document with a schema defined by a specific application. The node selector you specify can conform to the same schema.

In various embodiments the SIP server can further provide a helper class to easily retrieve a profile document. For example the getDocument method of the helper class can take a constructed document set key and an existing application session object and return a read only version of the document. In order to modify the document a copy can be made and edited and sent along with the document set key as arguments to the putDocument method.

In various embodiments with container managed profile data the SIP server can make a document set available to application methods as they are executed. Thus instead of constructing an explicit document set key a user data specification can be created as a parameter in the application deployment descriptor. This user data specification can indicate the SIP methods in which the profile data is needed and can also define the Sh data reference document and nodes of interest to the method. The SIP servlet container can substitute portions of the user data specification with data matching the user associated with the call being processed. The container can then retrieve the nodes identified in the user data specification and make them available to the servlet method when it is executed. The servlet method can access the user profile data by accessing the request attribute name assigned to the user data specification. Any updates to the profile data can be transmitted to the HSS when the call state data associated with the SIP dialog is written to the state tier.

As illustrated a generic profile service API can be implemented by the SIP server running on an engine node in order to allow an application to access the HSS server . In some embodiments the application can be a converged application able to handle communications from SIP clients as well as HTTP clients . The profile service API can thus enable the application to obtain information associated with individual users from the HSS server. For example the application can query or update a user s data stored on the HSS via the use of the profile service. Similarly the application can subscribe to and receive notifications when a user s data changes on the HSS. The Diameter base protocol can be implemented as a web application deployed on the engine tier cluster. It can use a load order value of one in order to ensure that it starts before all other web applications and SIP servlets. The Sh interface can be implemented as a provider to the base Diameter web application . This provider can transparently generate and respond to the Diameter command codes which defined in the Sh application specification. The user profile data can be provided to the SIP servlets as an XML document . Under the application managed approach discussed above the SIP servlet can explicitly request user profile documents and can then use standard DOM techniques for reading and modifying the profile data in the local document set. The updates can be applied to the HSS server after a commit operation or immediately after modifying the data. Under the container managed approach on the other hand the SIP server container can automatically maintain a document set for all SIP servlets that are registered to process a given SIP message. The container can then apply the updates to the document set when it writes the associated call state to the state tier as previously described. Subscriptions and notifications for changed profile data can be managed by implementing a profile listener interface in a SIP servlet.

In this manner the generic profile service API provides a simple and improved way for the SIP server to access data associated with various users. In various embodiments a multitude of methods can be defined for accessing the documents from the HSS server via the profile service. The following is an exemplary illustration of the various methods that can be implemented 

As illustrated the engine node can send various requests to and receive appropriate responses from the HSS server by way of the SIP server relay node . The vertical lines extending from the engine node relay node and HSS illustrate that time is flowing downwards as communications are sent back and forth. For example the engine node can initiate a user data request UDR to the relay node which can in turn forward the request to the HSS server . The HSS server can then respond by sending an appropriate user data answer UDA to the relay node which can forward this answer back to the requesting engine node.

Continuing with the illustration once the engine node has received the appropriate user data it can choose to subscribe to receive notifications from the HSS server . It can initiate this subscription process by sending a subscribe notifications request SNR to the relay node which can forward the request to the HSS. The HSS server can respond with a subscribe notifications answer to the relay node which can be forwarded back to the relay node. The SNA can inform the engine node whether the subscription request was successful and whether the engine node is now able to receive notifications.

As illustrated various systems which are external to this diagram can modify the target user profile after the engine node has subscribed as previously discussed. Whenever such modifications to data occur the HSS can send a push notification request PNR to the relay node which can relay that information to the engine node. As such the engine node can be notified that the user profile has been updated and can take appropriate action such as requesting the updated user profile.

In various embodiments communications such as UDR UDA SNR SNA and PNR can be defined Sh Diameter commands for accessing user profile data on the HSS server. For example the user data request is a request from an application server to an HSS server requesting the profile data associate with a particular user. The following are nonlimiting examples of various requests and responses which may be communicated between the engine node and the HSS server 

As an illustration a sample servlet which can use the profile service to retrieve and write user profile data is shown below 

In various embodiment the engine tier can also have applications deployed thereon which handle various call flows in the form of SIP communications between the SIP server and clients. For example whenever a user initiates an SIP conversation to the SIP server an application can make appropriate responses which can include obtaining user profile data as discussed above. An example of a SIP communication call flow is illustrated below.

As illustrated a back to back user agent B2BUA having a running SIP server thereon can take the place of being an intermediary between the communications sent between various users. This can be done for purposes of controlling the call and message flow between user agent and user agent and in order to prevent any unwanted behavior and messages e.g. spamming hacking viruses etc. from being sent to the user agent device. It should be noted that although user agent and user agent are illustrated as telephones in the SIP messages can come from various other sources as well. For example the user agent can also be a cell phone a wireless device a laptop an application or any other component that can initiate a SIP type of communication. Similarly while illustrates communications between two user agents there can be more such user agents taking part of a single communication session. For example during a conference call there may be 20 or 30 user agents for all attendees of the conference each of which could send SIP messages to the B2BUA and receive transmissions back therefrom.

Continuing with the illustration a telephone call can be set up between user agent and user agent via the use of the SIP server. The first message sent from user agent to the SIP server on the B2BUA can be an invite message requesting to set up a telephone call with user agent . The invite message can be received by the load balancer of the SIP server and it can be directed to an engine in the engine tier for processing.

In various embodiments the engine tier e.g. an application executing thereon can then perform logic for determining various factors associated with the call such as determining whether user agent is allowed to make the type of call attempted to be initiated determining whether the callee that will be contacted is properly identified as well as any other logic that the server may need to calculate before attempting to set up a telephone call. This information can be obtained by querying the HSS server for user profile data in the manner discussed above. The engine can then generate state around the fact that a call is being set up including generating the proper long lived and short lived objects associated with the messages. The engine can also determine how to find the target of the call i.e. user agent and the right path to route the message to the callee. As illustrated herein user agent is an originator as well as the terminator of the call and user agent is referred to as the callee.

After receiving the invite message the SIP server can send a 100 trying message back to user agent indicating that it has received the invite message and that it is in the process of handling it. The 100 trying message is part of the SIP protocol definition and can be used by a server in order to stop the user agent from re transmitting the invite request. In cellular phone environments the user agent may have interference which might cause an interruption or loss of various messages. Therefore SIP protocol defines various re transmission schemes in order to handle such mobility and interruptions. Messages such as 100 trying 180 ringing and 200 OK are just some of the examples of messages defined in SIP for handling communication.

Continuing with the illustration the SIP server can then send an invite message to the user agent and can receive back a 180 ringing message indicating that user agent has received the invitation and is now waiting for a user to answer. The SIP server engine tier can then transmit the 180 ringing message back to user agent . When a person finally answers the phone user agent can then send a 200 ok message to the SIP server the server can transmit that message to user agent . The user agent can send an acknowledgement Ack message to the SIP server which can be transmitted along to user agent and at this point a sound transfer conversation can be set up between the two user agents. This sound transfer can be implemented via real transfer protocol RTP on a media server. At the end of the conversation either user agent can choose to terminate the call by sending a Bye message. In this illustration user agent terminates the call by sending a Bye message to the SIP server which sends it off to user agent . After receiving back a 200 ok message from user agent the SIP server can transmit that message to user agent and the conversation can be truly ended.

In various embodiments the vertical lines such as those extending downward from the user agents and the B2BUA can each illustrate and be referred to as a single call leg. The call flow for each call leg may be time sensitive as some messages should be received or sent before others can be initiated. For example as illustrated herein the user agent A may continue to re transmit the initial invite message until it receives a 100 trying message from the B2BUA . As such in some cases certain messages may need to be processed synchronously while others may be allowed to process in parallel.

It should be noted that this illustration of a call may be overly simplified for purposes of clarity. For example there can be various other message transmissions not illustrated such as authentication messages for caller callee determining the type of user agent the SIP server is communicating with and various other handshaking messages that can be exchanged between the SIP server and the user agents. Furthermore message transmitting steps may be added changed interrupted or rearranged in case of interference or failure of various components.

As previously discussed in various embodiments there may be specific sequences of messages exchanged between the SIP server and the user agents for controlling the flow of the call. These sequences can be controlled by various timer objects residing on the SIP server. As a nonlimiting illustration after receiving the invite message from one user agent the SIP server will typically forward that invite to another user agent and wait for a response. If no response is received within a period of time e.g. a number of milliseconds then the invite message may need to be retransmitted to the second user agent because it may be assumed that the user agent did not receive the first message. This type of re transmission can be controlled by the protocol timer objects which may be residing in the state tier. In one embodiment an initial Ti timer value of 500 milliseconds can control the retransmission interval for the invite request and responses and can also set the value of various other timers.

In various embodiments there are also other timer objects which can be executing on the level of the entire call. For example if after a specified period of time nothing is heard back from either user agent the entire call may be purged from the system. This specified period of time can also be controlled by firing a timer object.

In one embodiment as engine tier servers add new call state data to the state tier state tier instances queue and maintain a complete list of SIP protocol timers and application timers associated with each call. Engine tier servers can periodically poll the partitions of the state tier to determine which timers have expired given the current time. In order to avoid contention on the timer tables multiple engine tier polls to the state tier can be staggered. The engine tier can then process the expired timers using threads in the sip.timer.Default execute queue. Thus the processing of the timer objects can be executed by the engine server as determined by the state tier server. For example the state tier can tell the engine A to execute the first half of all due timer objects e.g. 1 100 and tell engine B to execute the other half e.g. 101 200 . The state tier can also simultaneously push the state onto the engine since the state may need to be employed in executing the timer objects. The engines can then process the timer objects e.g. by sending appropriate messages ending appropriate calls and can later again query poll the state tier for which timers have become due.

When used with the near cache the state data may not need to be pushed onto the engine server since that data may already be available in the cache. Thus when processing timers the timers can be fetched from the state tier however upon the timer firing the engine can fetch the call state using the cache. Further performance optimization can be obtained by changing the selection of tiers to give affinity to the engine holding the cache for a particular call. Thus the timers which are going to be executed can be sent to the appropriate engines which have the proper call state in the cache thereon.

In various embodiments it may be preferable to synchronize system server clocks to a common time source e.g. within a few milliseconds in order achieve maximum performance. For example an engine tier server with a system clock that is significantly faster than other servers may process more expired timers than the other engine tier servers. In some situations this may cause retransmits to begin before their allotted time and thus care may need to be taken to ensure against it.

In various embodiments the SIP Servlet API can provide a timer service to be used by applications. There can be TimerService interface which can be retrieved from as a ServletContext attribute. The TimerService can define a createTimer SipApplicationSession appSession long delay boolean isPersistent java.io.Serializable info method to start an application level timer. The SipApplicationSession can be implicitly associated with the timer. When a timer fires an application defined TimerListener is invoked and ServletTimer object passed up through which the SipApplicationSession can be retrieved which provides the right context of the timer expiry.

In various embodiments the engine tier servers continually access the state tier replicas in order to retrieve and write call state data. In addition the engine tier nodes can also detect when a state tier server has failed or become disconnected. For example in one embodiment when an engine cannot access or write call state data for some reason e.g. the state tier node has failed or become disconnected then the engine can connect to another replica in the partition and retrieve or write data to that replica. The engine can also report that failed replica as being offline. This can be achieved by updating the view of the partition and data tier such that other engines can also be notified about the offline state tier server as they access state data.

Additional failover can also be provided by use of an echo server running on the same machine as the state tier server. The engines can periodically send heartbeat messages to the echo server which can continually send responses to each heartbeat request. If the echo server fails to respond for a specified period of time the engines can assume that the state tier server has become disabled and report that state server as previously described. In this manner even quicker failover detection is provided since the engines can notice failed servers without waiting for the time that access is needed and without relying on the TCP protocol s retransmission timers to diagnose a disconnection.

Failover can also be provided for the engine tier nodes. As previously discussed the engine tier nodes can periodically poll the state tier nodes in order to determine which timer objects it needs to execute. In turn the state tier nodes can notice whenever the engine tier node has failed to poll. If a specified period of time elapses and the engine tier has not polled the state tier the state server can then report that engine as unavailable e.g. having failed or disconnected from the network . In this manner failover can be implemented for both the state tier and the engine tier thereby providing a more reliable and secure cluster for message processing.

In other aspects the invention encompasses in some embodiments computer apparatus computing systems and machine readable media configured to carry out the foregoing methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art.

Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The present invention includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include but is not limited to any type of rotating media including floppy disks optical discs DVD CD ROMs microdrive and magneto optical disks and magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

Stored on any one of the machine readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems and user applications.

Included in the programming software of the general specialized computer or microprocessor are software modules for implementing the teachings of the present invention including but not limited to providing systems and methods for providing the SIP server architecture as discussed herein.

Various embodiments may be implemented using a conventional general purpose or specialized digital computer s and or processor s programmed according to the teachings of the present disclosure as can be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as can be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits and or by interconnecting an appropriate network of conventional component circuits as can be readily apparent to those skilled in the art.

Call logs The ability to view calls made over a given period of time online ability to associate names with phone numbers integrate call log information to other applications such as IM.

Do not disturb The ability to specify policies around receiving calls for example all calls during office hours to be automatically forwarded to a mobile terminal all calls during the night to be directed to voice mail etc.

Locate me This is advanced call forwarding. Rather than have all calls forwarded to a single location e.g. voice mail when the caller is busy Locate me can try multiple terminals in series or in parallel. For example a user may have two office locations a mobile and a pager and it may make sense to forward a call to both office locations first then the pager and then the mobile terminal. Locate me is another example of feature interaction.

Personal conferencing A user could use an existing application e.g. IM client to schedule a Web audio conference to start at a certain time. Since the IM client already has personal profile information the conferencing system sends out the Web conference link information either through IM and or email to the participants. The phone contact information in the profile is used to automatically ring the participants at the time of the conference.

Lifetime number This is the facility where a single virtual number can travel with a customer wherever they live. Even if they move the old number continues to work and reaches them at their new location. This is really the analog of static IP addresses in a phone network.

Speed dial This is the ability to dramatically expand the list of numbers that can be dialed through short key and accelerator combinations. This is another example of a converged application since it s very likely that when a user will set up this information when they work through the call logs on the operator user portal and the updated information needs to be propagated to the network side in real time.

Depending on the service level agreement users are willing to sign up to the quality of media delivered e.g. number of frames per second will vary. The policy engine enables segmenting the customer base by revenue potential and to maximize return on investment made in the network.

A typical example here is the need for applications that have a short lifetime extremely high usage peaks within their lifetime and immediacy. For example voting on American Idol during the show or immediately afterwards has proved to be an extremely popular application.

The final class of applications is one that combines wireline and wireless terminal usage scenarios. An example of an integrated application is the following a mobile terminal user is on a conference call on their way to work. When he reaches his office he enters a special key sequence to transfer the phone call to his office phone. The transfer happens automatically without the user having to dial in the dial in information again. It s important to note hear that this capability be available without the use of any specific support from the hand set a transfer button for example .

Various embodiments include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs microdrives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs paper or paper based media and any type of media or device suitable for storing instructions and or information. Various embodiments include a computer program product that can be transmitted in whole or in parts and over one or more public and or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. In various embodiments the transmission may include a plurality of separate transmissions.

Stored one or more of the computer readable medium media the present disclosure includes software for controlling both the hardware of general purpose specialized computer s and or processor s and for enabling the computer s and or processor s to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers user interfaces and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

