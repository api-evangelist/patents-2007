---

title: Transactional memory system which employs thread assists using address history tables
abstract: A computing system uses specialized “Set Associative Transaction Tables” and additional “Summary Transaction Tables” to speed the processing of common transactional memory conflict cases and those which employ assist threads using an Address History Table and processes memory transactions with a Transaction Table in memory for parallel processing of multiple threads of execution by support of which an application need not be aware. Special instructions may mark the boundaries of a transaction and identify memory locations applicable to a transaction. A ‘private to transaction’ (PTRAN) tag, directly addressable as part of the main data storage memory location, enables a quick detection of potential conflicts with other transactions that are concurrently executing on another thread of said computing system. The tag indicates whether (or not) a data entry in memory is part of a speculative memory state of an uncommitted transaction that is currently active in the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117403&OS=08117403&RS=08117403
owner: International Business Machines Corporation
number: 08117403
owner_city: Armonk
owner_country: US
publication_date: 20071030
---
This application is a continuation in part and contains subject matter which is related to the subject matter of the following co pending application which is assigned to the same assignee as this application International Business Machines Corporation of Armonk N.Y. The below listed application is hereby incorporated herein by reference in its entirety 

U.S. Ser. No. 11 748 044 filed May 14 2007 entitled COMPUTING SYSTEM WITH OPTIMIZED SUPPORT FOR TRANSACTIONAL MEMORY by Thomas Heller et al.

IBM is a registered trademark of International Business Machines Corporation Armonk N.Y. U.S.A. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

This invention relates to multiprocessor and multithreaded computing systems and particularly to a computing system which uses specialized Set Associative Transaction Tables and additional Summary Transaction Tables to speed the processing of common transactional memory conflict cases and those which employ assist threads using Address History Tables.

Current multiprocessor and multithreaded computing systems allow the performance of a single software application to be scaled to many times the possible performance of a single threaded application. Current software and hardware systems provide for the parallel processing of multiple threads of execution. Software applications can use existing thread libraries such as the POSIX pthread library to control the creation of multiple threads of parallel execution. The use of multiple threads works well for applications that operate on easily partitioned tasks and data course grain locks can be used to control access to the few shared data structures to prevent rare conflicts between the data updates of multiple threads.

Many software applications contain data structures that must be shared among multiple threads and have frequent concurrent inspections and updates of the shared data structures. These applications require additional modifications in order to obtain good scaling when using large numbers of threads. Applications which use multiple threads of execution that access shared data structures currently require the use of specialized data locking routines in order to produce a reliable outcome that is free from deadlocks and corrupted data. The majority of existing multithreaded applications in this category use fine grained software locks to achieve good performance and correct operation. Writing high performance multithreaded programs which use fine grained software locks is extremely difficult and requires expert programming skills. The lack of these skills in the software industry severely limits the production of multithreaded applications which require the use of shared data structures and therefore the usefulness of multithreaded and multiprocessor computing systems for certain application classes including many forms of transaction processing.

Various Transactional Memory systems have been proposed and built to provide a simpler programming model for constructing multithreaded applications that need to control access to shared data structures. These systems allow software running on one thread of execution to optimistically assume that shared data structures can be updated without conflict with the accesses and updates of other threads of execution. The speculative updates to memory are kept pending until the transactional memory system confirms that no conflicts with storage accesses of other threads have occurred. The transactional memory system must be able to discard the pending speculative updates when conflicts between the storage accesses of multiple threads are detected. The existing systems range from those that rely completely on new software constructs to those that rely on a mixture of hardware and software to obtain reasonable performance. Some existing systems have very high overhead in terms of the number of instructions executed in support of the required transactional memory behavior. Other existing systems have limitations associated with data cache structures that hold the pending updates to memory.

The shortcomings of the prior art are overcome and additional advantages are provided through the provision of a transactional memory computing system which uses an assist thread and associated software speeds the processing of transactions. The assist thread is used to parallelize the execution of the required Transaction Table and allows the main thread of execution to continue to the next instruction with little delay. A specialized data buffer is provided for fast communication between the main thread of execution and the assist thread.

The computing system now provides specialized Set Associative Transaction Tables SATT and additional Summary Transaction Tables Load Summary Tables LSTs and Store Summary Tables SSTs to speed the processing of common transactional memory conflict cases. All of these specialized Transaction Tables are used by transactional memory hardware or a transactional memory assist thread to reduce the execution overhead required for some common transactional memory operations. The Set Associative organization of the tables allows for very fast indexing when the transactional memory system is attempting to resolve a potential address conflict while processing a transaction. The Summary Transactional Tables LSTs and STTs allow the most critical information to be packed into a minimal number of data bytes so that they can be effectively cached in small fast hardware data caches that are close to the microprocessor core. The compact format of the Summary Transactional Tables as seen by the L1 caches enable the searching of the tables with a minimal number of load operations. The compact format also allows for a fast reset of the tables without the need to provide address pointers to multiple copies of the tables in memory. The conflict resolution of the invention is focused on improving the performance of certain common transactional memory operations which cause main storage accesses. Both the performance of an application using transactional memory constructs and the overall system throughput are improved with the use of the current invention.

In accordance with the invention a combination of specialized Set Associative Transaction Tables and additional Summary Transaction Tables to speed the processing of common transactional memory conflict cases is used with a private to transaction PTRAN tag attached to each increment of real system memory and a log of speculative loads and stores to provide an improved implementation of a transactional memory computing system. SATTs LSTs and SSTs are implemented as software tables that are kept in real memory and managed by an assist thread . Hardware is provided to quickly detect conflicts between the storage accesses of transactions running on multiple threads of execution. The use of the tag in memory and associated conflict detection hardware included in this invention provides a much faster transactional memory system with much less overhead when compared to existing systems. It is an improvement over software only transactional memory systems since it eliminates some of the software overhead associated with tracking the speculative state of transactions. It also provides the ability to detect storage conflicts at a very fine level down to a single byte as opposed to prior art software systems that track updates to entire software objects which may be hundreds or thousands of bytes. Existing software systems will either give frequent over indication of potential data conflicts or incur very large software path length penalties when attempting to track the updates to individual components of software objects.

System and computer program products corresponding to the above summarized methods are also described and claimed herein. Many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The paper Architectural Semantics for Practical Transactional Memory McDonald et al Computer Systems Laboratory Stanford University 2006 compares some of the proposals and provides references for many others. The invention can be used to increase the speed of execution for any of them. The preferred embodiment is described for the PowerPC architecture but anyone skilled in the art could apply the same approach to any other architecture such as IBM z Series Sun Sparc Intel IA32 etc. Anyone skilled in the art could extend the current invention for use with other Application Programming Interfaces APIs that may be created for other specialized versions of transactional memory implementations.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

As a result of the summarized invention technically we have achieved a solution which is also an improvement over existing hardware based transactional memory systems that rely on changes to cache coherence protocols. It allows the hardware system to deal with transactions which are long enough to overflow average size caches and doesn t involve the virtual memory management overhead of prior art schemes. It also allows for the ability to detect conflicts at a finer granularity than the cache line granularity of prior art systems that are tightly coupled with data caches. The current invention also allows for the fast execution of nested transactions.

The detailed description explains the preferred embodiments of the invention together with advantages and features by way of example with reference to the drawings.

in there is a computing system illustrating an embodiment of our invention which has one or more microprocessors coupled to a physical memory array via an interconnection element . The physical memory array stores transaction data and private to transaction PTRAN tags which are associated with every increment of real system memory. The interconnection element can be implemented as a shared bus or crossbar switch. The invention applies to systems which use any other scheme of interconnecting physical memory to a multiprocessor system which may be implemented in one or more chips. The memory could be broken down into smaller portions and distributed across private connections to each of the CPU chips as done for the IBM Systems using the Power4 microprocessor or for the AMD Opteron based servers. The microprocessors and memory controllers may be located together on a single silicon chip or they may be spread across multiple chips.

The physical memory of the computing system is divided into n increments. One or more private to transaction bits PTRAN associated with every increment of real system memory are provided for each of the n increments. The invention allows for the choice of any memory increment size and the best choice will depend on workload characteristics hardware costs and data caching structure used in the target system. An increment of 16 bytes is used in the illustrated embodiment. The PTRAN bit s are used to indicate whether or not a data entry in memory is part of the speculative memory state of an uncommitted transaction that is currently active in the system.

Special new instructions BEGIN AIG END AIG as illustrated by the Nested AIG code sequence of are used to mark the beginning and end of a group of instructions. The instructions which execute between the special new instructions are referred to as an Atomic Instruction Group AIG illustrated by AIG instructions shown in Instruction A Instruction A Instruction A . Additional storage access rules are used when a processor is executing instructions which are part of an Atomic Instruction Group. All of the storage locations modified by the AIG group of instructions are updated in memory in an atomic fashion. The updates to the storage locations are kept pending until the processor and or software application indicates that they should be committed . All of the updates are either committed to normal memory at once or they are discarded. The results are discarded when hardware and or software detects a conflict between the storage accesses of multiple AIGs that are executing concurrently in the multiprocessor system. The invention provides a way for hardware to quickly detect potential conflicts between the storage accesses of multiple AIGs. Although the invention uses special new instructions to mark the boundaries of a transaction any other method could be used to identify a group of memory locations that are to be updated in an atomic fashion. The invention is compatible with any number of software interfaces that may be used to implement a transactional memory system. The invention can provide the same fast conflict detection for any system which is attempting to provide an atomic update of multiple storage locations. The invention also applies to systems which mark the boundaries of an instruction group in any other ways including compiler generated hints attached to other instructions internal microprocessor commands generated by internal microcode or millicode.

The PTRAN tag is one or more bits associated with an increment in memory which is set for all memory accesses generated by instructions that are part of an Atomic Instruction Group. A processor inspects the bit before attempting to set it this enables the quick detection of potential conflicts with other AIGs that are concurrently executing on other threads. The setting of the bit may be accomplished by a TS test and set operation of the IBM z Architecture as described by the IBM z Architecture Principles of Operation or any other equivalent operation that enables an atomic update in a multithreaded or multiprocessor system.

Turning now to it will be seen that Transaction Tables are created as part of the real system memory which is illustrated here as physical memory. The Transaction Tables could also created in logical or virtual memory. Any system to map the logical system memory to the physical system memory can be used and there are numerous examples known in the art which can be used such as those in the IBM zSeries IBM s p Series Sun Microsystems SPARC Intel s IA32 etc. A Transaction Table entry is made when instructions that are part of an Atomic Instruction Group cause a memory location to be inspected or updated. A Thread ID is associated with each Transaction Table. A Next Entry register is used as an index into the Transaction Table and indicates which entry should be written next. A Table Origin indicates the address of the first entry of the Transaction Table for its thread . The Transaction Table is used to hold additional information beyond the simple information that is associated with the PTRAN tag bit or bits that are associated with the memory location that has been inspected or updated. This additional information is related to the speculative state associated with an Atomic Instruction Group. In an illustrated IBM zSeries or pSeries CPU embodiment which we describe here we prefer to use a single PTRAN bit. In this case the Transaction Table will contain all additional information about the speculative state therefore the PTRAN bit will only indicate that a physical address is involved in an AIG. This is illustrated for Transaction Table A as the address the transaction info identifier and old or new data . Other embodiments of the current invention may use additional PTRAN bits which can be used by hardware or software to speed the processing of certain events involved in the processing of Atomic Instruction Groups or the speculative states of any other transactional memory system. The combination of using just a single bit in memory and associating that bit with a more complete description of the transactional state in the Transaction Tables provides a transactional memory system which requires very little hardware overhead without incurring the performance penalty seen in prior art software transactional memory systems.

Turning again to it will be seen as we said that an entry in the Transaction Table A for example comprises the address that has been inspected or updated inside of an AIG a Tran Info field and a Data Field . A store instruction that is part of an AIG will cause the system to copy the old data value from the original storage location to the Transaction Table entry for that address and the new speculative data is placed in the main storage location.

The invention can be made to work with the new values held in the Transaction Table if desired. The preferred embodiment places the old data value in the transaction table. This allows the system to be optimized for the case where most transactions are successful. The old data can be discarded quickly when it is no longer needed when a transaction is committed permanently to memory by changing the pointer to the transaction table or by clearing the contents of the transaction table. The Tran Info field of a Transaction Table entry includes any transaction information that is needed to make detailed decisions about the need to cause a transaction failure. It also has provisions for additional information to allow efficient support of nested transactions virtualized transactions or other extensions of the transactional memory architecture. In the preferred embodiment the Tran Info field includes an indication of whether the storage access of the associated address was a load type access or a store type access. The Tran Info field can also indicate whether the address is shared among multiple AIGs in the system.

An override of this AIG active mode may be provided. The override could be associated with the logical memory segment or logical memory page which contains the target address. An override forces the system to treat the storage request as normal in spite of the fact that the request is part of an AIG. If the override is active then the result of the decision will cause normal processing to take place. Assuming that an AIG is active and the override is not then the associated PTRAN bit is inspected at an inspection step . A load instruction inside of an AIG detects upon inspection the state of the PTRAN bit. When the PTRAN bit is already set it is due possibly to the actions of another thread executing on the same processor or on another processor. If at the inspection step it is found that the PTRAN bit is not set then the processor sets the PTRAN bit and make a record of the access in the Transaction Table for the active AIG by adding to the Transaction Table at the Set PTRAN step and then the complete load can continue . If the PTRAN bit is already set the address which caused this potential conflict is compared with the addresses already entered in the processor s Transaction Table. If the PTRAN bit was set when tested at the inspection step by another load earlier in the same AIG it is already part of the AIG as tested and determined and then the complete load may continue . Each Transaction Table contains the addresses for a particular AIG. Accordingly if the address was not already part of the AIG as tested and determined then the address for the load is not found in the processor s Transaction Table and then the processor checks whether the address is enabled for sharing among AIGs in a determination step for AIG sharing . If the address is not currently enabled for sharing among multiple AIGs the processor may signal other processors in the system to request a shared AIG access for this address during the determination step whether sharing is allowed among AIGs . A shared access can be granted if no other AIG in the system has speculatively written the storage location. If the shared access is not granted then the AIG fails otherwise the load address is added to the Transaction Table and the Tran Info field is updated to indicate that the address is a load access that is shared among multiple AIGs in the system.

The Store Processing Flowchart shows the actions for processing a store that is part of an AIG. When a processor attempts a store type access initially a store decision is made to determine whether the access is part of an AIG and whether the special storage access rules for AIG accesses apply. The mode of the processor is checked in a similar method as previously described for load accesses. If the special mode of operation under which the special access rules for AIG accesses apply is not active then the store is treated as a normal store . Assuming that an AIG is active the associated PTRAN bit is inspected at the store process inspection step . If the PTRAN bit is not already set then the PTRAN bit is set at the store transaction step and a new entry is added to the Transaction Table . The old data is moved to the Transaction Table entry the address is written to the new entry and the Tran Info field is updated. The Tran Info field is marked to indicate that the access associated with this entry was a store type access. The new store data is written to memory after the setting of the PTRAN bit is completed. If the inspection of the PTRAN bit indicates that the bit was already set then a decision is made based on whether the current store address is already part of an AIG which is active on the processor. The Transaction Table for the processor is examined if it is determined that the address is present in the Transaction Table then the Tran Info for the entry is checked and a decision as to shared access entry is made. If the Tran Info indicates that the entry is a load type access entry that is shared among multiple AIGs the transaction fails otherwise the Tran Info field for the associated entry is updated to indicate a store type access and the store is processed .

Turning now to the Commit Processing Flowchart of it will be seen that the invention includes a set of actions completed when the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory as determined initially at a test step . If not the processing continued in AIG mode . An AIG is committed to memory when the processing of the loads and stores of the AIG according to flowcharts from and does not result in a Transaction Failure. In the case of AIG success then testing determines the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory. Then the Transaction Table is examined and each entry for the AIG to be committed is read and its associated PTRAN bit is reset in memory at the Transaction Table commit step determination.

A specialized hardware engine may be used to complete the performance of this commit operation. A combination of processor caches multiprocessor coherency actions and the current invention can be used to provide software with the illusion that all of the memory updates for a single AIG occur simultaneously even though the main memory storage arrays are not updated simultaneously. During the commit processing the resetting of the PTRAN bits continues until the last valid entry in the Transaction Table has been determined to be reached . At this point the AIG is considered to be committed and the performance by the engine therefore completes .

Some conditions prevent the completion of an AIG. These conditions may be detected during load processing while executing an AIG or during store processing while executing an AIG . There are many other possible processor conditions that may cause the need to abort the processing of an AIG. These include error conditions detected in the system as well as other conditions that would require significant additional hardware support to enable the processor to handle them correctly. Many prior art transactional memory architectures include provisions for the abort of transactions and for a subsequent retry. Prior art software constructs can be used together with the current invention to eliminate the need to provide hardware to deal with all possible special cases. A simple example is the case of a timer interrupt in the middle of processing an AIG. The interrupt may cause the processor to spend a large amount of time running code that is not part of the partially completed AIG. It may not be desirable for the processor to keep the AIG active during this time. The system can force a transaction failure for any AIG that is currently executing when a timer interrupt occurs. A similar approach can be used for any other special case events occurring in the processor.

Transaction failures or forced retries are handled according to the process of the Rollback Processing Flowchart for rollback processing shown in . Turning now to it will be seen that the lack of a transaction failure condition allows the processor to continue in the AIG active mode . The preferred embodiment of the current invention uses an eager policy with respect to detecting transaction failures and causing transaction rollback. Also the invention may be used in systems that wait until the end of a transaction to take the actions required for a rollback. The memory updates executed as part of an Atomic Instruction Groups are either committed to normal main storage at the same time or they are discarded with a rollback operation .

Upon finding a transaction failure condition failure several additional steps are required . Rollback Transaction Table processing entry steps provide that the Transaction Table for the AIG is inspected and any old data is written back to the main memory address indicated in the entry. The PTRAN bit for the associated address is reset. The rollback processing continues until the last valid entry in the table has been processed . After the last valid entry has been processed the rollback is complete . The actions taken by the processor at this point will differ based upon various software architectures for transactional memory. Any of transactional memory architectures described in the background may be used. In some cases the AIG will be retried from the beginning. In other cases special software handlers will be invoked to deal with the transaction failure. The current invention may be used with any of these different architectures.

The current invention supports the execution of nested transactions. A second AIG may be included within the scope of the first AIG as shown in . Each BEGIN AIG special instruction statement causes the system to create a Transaction Table and to associate the table with the AIG. Decisions about whether or not a storage address belongs to an AIG may include the inner AIG A or the combination of the inner and outer AIGs A B . The END AIG special instruction statement ends the transaction sequence but as shown a sequence for a specific transaction Transaction B may be nested within another sequence Transaction A The use of multiple Transaction Tables may be used to support many nesting architectures for transactional memory. Multiple versions of the old data may be stored in any number of Transaction Tables at any nesting depth. Prior art transactional memory systems that rely on data caches to hold speculative state are unable to provide similar support for nested transactions without adding additional state information to cache directories and adding additional complexity to the cache coherency protocol. Nesting support on prior art systems would impose a large hardware complexity penalty on those designs. The current invention can also be extended to include a combined Transaction Table that includes entries from both the inner AIG Instruction B Instruction B and the outer AIG Instruction A Instruction A Instruction A . This Combined Transaction Table may be used in place of the individual Transaction Tables or in addition to the individual Transaction Tables.

There are many additional hardware features that can be added to the invention to speed the processing of the Transaction Table manipulations and the setting and resetting of the PTRAN bit s . Since the PTRAN bit is part of the main storage data it can be cached in the normal data caches of the system. The Transaction Tables are also part of main storage and can also be cached. Additional control information can be added to the data caches to indicate whether a specific address has been enabled for shared AIG access and therefore eliminate the need to search the Transaction Table for some cases.

The capabilities of the present invention as described above can be implemented in software firmware hardware along with some combination of software and firmware.

As one example one or more aspects of the present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The computing system described herein is able to detect the signal and recover a computer program embodied therein. It makes no difference whether the computer program is embodied in a physical media such as a hard drive or computer memory or on a CD or within a data signal. The underlying program is usable by the computing system to execute the steps described for a computer readable memory to execute the encoded functions regardless of the format of origin of the encoded program or whether the format is a disk or a signal.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The preferred embodiment identifies the beginning of an AIG after decoding of an instruction . If it is determined that a BEGIN AIG instruction has been decoded the processor enters a new mode of execution AIG MODE otherwise the instruction is executed as usual and processing continues with the next instruction .

Prior to entering AIG MODE the architected state of the processor is saved in the same manner that a traditional Program Call is handled in the IBM Z Series architecture. Any similar state saving mechanism may be used on any other processor architecture. The processor may return directly to this saved state if the AIG fails or may return to this state after a series of other error handling routines have been invoked. While in AIG MODE decoding of instructions continues . If a load or store is decoded then special handling of these loads and stores is required . The steps required for the processing of a load inside of an AIG are described in those for a store inside of an AIG are described in . After loads and stores in an AIG are processed it is determined whether there has been an AIG failure as described in the descriptions of and . If there is a failure then special handlers are invoked . The actions of the special handlers for transaction failure may vary depending on the architecture of the system using the invention. Many methods of dealing with transaction failures have been described in the prior art any of them could be used for this purpose. The possible methods include retrying the transaction from the beginning for a set number of attempts waiting for the condition that caused the failure to change calling specialized software routines to resolve conflicts among threads etc. These possible failure handlers may require the rollback of the AIG which caused the failure . If no failure was detected then it is determined whether the load or store was the last instruction of the AIG . If the instruction is the last instruction in the AIG then the AIG is committed using the process described in . The processor then exits the AIG Mode and continues with the next sequential instruction after the AIG .

The decoding of instruction other than loads and stores inside of an AIG does not necessarily require special processing . If the instruction is not a load or store type instruction then it is determined whether the instruction is another BEGIN AIG . Nested AIG instructions require special handling . The prior art contains many different ways of handling nested transactions. The current invention can be used to support any of them. The nested AIG handler for the preferred embodiment adds the instructions of the inner AIG to the outer AIG creating a single larger AIG. Other embodiments of the invention may provide different rules of processing for loads and stores that are part an inner nested transaction as well as special rules for the commitment and failure handling of inner nested transactions. If it is determined that the instruction is not a BEGIN AIG then the instruction is executed and it is next determined whether the instruction is the last instruction of the AIG. The preferred embodiment uses the decoding of an END AIG instruction to indicate that the last instruction of an AIG has been reached. If the last instruction of the AIG has been reached then the AIG is committed to memory and the processor exits the AIG MODE of operation .

Turning to it will be seen that the current invention uses a new Address History Table that is part of a multithreaded microprocessor that has been designed for support of transactional memory. The preferred embodiment uses a microprocessor that supports simultaneous multithreading SMT but other forms of multithreading such as hardware multithreading HMT may be used. The microprocessor in the preferred embodiment supports 4 simultaneous threads. Entries in the AHT are written by the load store units over new interfaces that carry command control address and data information. Command and control information may also be written into the AHT from the Instruction Execution Pipelines . The contents of the AHT may be copied or moved to the General Purpose Registers of the microprocessor over the new interface provided for that purpose.

The steps necessary for processing the storage accesses of an AIG using the assist thread are shown in . In the preferred embodiment the assist thread is another thread of execution on the same microprocessor that is currently executing the AIG. The assist thread could also be running on another processor core and accessing the AHT indirectly through shared memory or any other suitable interface. The assist thread could also be on another microprocessor chip or in another system running on the same Instruction Set Architecture ISA as the main thread or on a different ISA. A single assist thread can be used to support the execution of any number of AIGs which are running on other threads of execution. The preferred embodiment uses one assist thread per microprocessor core. The assist thread does not need to take any action if there is no AIG active on any thread running on the microprocessor core that it is assisting. If an AIG is active the assist thread determines whether there is a valid entry in the AHT . In the preferred embodiment a non zero Entry Type indicates a valid entry. If no entry in the AHT is valid the assist thread waits for N cycles before checking again. The value N can be set by hardware software or any other suitable means. The optimal value will depend upon many factors which may be determined at run time or predetermined at some earlier time. Valid entries are read out of the AHT by the assist thread and may be moved to general purpose registers that are made available by whatever microprocessor architecture that the assist thread is executing on. The Thread ID field is used to determine thread of execution that created the AHT entry. The assist thread uses the Thread ID to determine which set of AIG Transaction Tables must be updated. The preferred embodiment uses a single AHT to hold the information related to all of the AIGs that are simultaneously executing on the multiple threads of execution of the multithreaded core. Other implementations may use one AHT per thread and use a single assist thread to check for valid entries in all of the AHTs in a round robin fashion. Other implementations may use one AHT per thread and use multiple assist threads.

If the Access Type of the entry is a special command the assist thread determines the type of command and takes the appropriate actions . If the Access type is not a special command then the assist thread uses the Access Type and Address to update the software tables associated with the correct AIG.

In the preferred embodiment the assist thread performs the actions shown in and as part of the actions shown in . These actions include setting the PTRAN bit. After processing store type accesses that are part of an AIG the assist thread indicates to the load store units that the held store may be released. The preferred embodiment uses a specialized instruction pipeline command to provide this indication to the load store unit.

In parallel with the AIG active decision another decision is made by the load store unit. Each cycle it is determined whether the instruction pipeline of the microprocessor indicates that a store should be released. If a store is to be released it is determined whether the load store unit is currently holding a store that has an address that matches the address of the store to be released. If the addresses match then the store is released to memory or to caches in systems that use caches. If the addresses do not match then no action is taken regarding the held stores and the load store unit waits for another indication that a store is to be released .

Now the computing system has been developed which uses specialized Set Associative Transaction Tables and additional Summary Transaction Tables to speed the processing of common transactional memory conflict cases used with a private to transaction PTRAN tag attached to each increment of real system memory and a log of speculative loads and stores to provide an improved implementation of a transactional memory computing system it will be recognized that shows additional steps required when the PTRAN Bit is found to be already set during the processing of a load type storage access within the bounds of a transaction. It must be determined whether the address is already part of the current group because the PTRAN bit was set by the current transaction.

Turning now to the computing system which uses specialized set associative Transaction Tables shows multiple Set Associative Transaction Tables SATT or multiple set associative transaction tables. At least one SATT is created for the system executing AIGs. The preferred embodiment uses one SATT for each microprocessor. All of the hardware threads that share a single microprocessor share a single SATT. Each entry in the SATT contains the address of one storage access that occurred during the execution of an AIG. The SATT is used in addition to the Transaction Table. A set associative transaction table SATT will be seen as illustrated in to have a number of congruence classes which allow fast search based on a subset of the storage address used in the system. These are stored in a supervisory area of the computing system. The fast access of these tables is performed like set associative data cache searching.

In the preferred embodiment the SATTs LSTs and SSTs are implemented as software tables that are kept in real memory and managed by an assist thread . Other implementations of the invention may implement any one of these tables or all of these tables in hardware. The entire tables of the SATTs LSTs and SSTs or any portion of their entries may be buffered by hardware in any suitable caching structure.

The entries of the SATTs LSTs and SSTs may be kept in linear tables in the real system memory. They may also be mapped to any other format that is optimized for faster search improved caching behavior reduced memory footprint or other optimized feature.

The actions required to create entries in the SATT and LST during the processing of a load request are shown in . It is first determined whether the storage access is part of an AIG A . Normal load processing A is used if the request is not part of an AIG. A decision is made A based on the current setting of the PTRAN Bit for the address of the current storage request. If the PTRAN Bit is not set then the LSTs for the hardware threads on the processor associated with the current request are accessed. All of the LST bits for the congruence class corresponding to the current request s address are examined. If the SATT congruence class is full A then the transaction must fail A due to a lack of room in the SATT congruence class. An SATT congruence class is considered full if all 4 of the SATT entries for that congruence class are already valid. An SATT entry is valid if one or more of the associated LST entries associated with that SATT entry is set. If there is still room in the SATT congruence class the bits of the LSTs for the target congruence class are walked through to find the first available SATT entry. One of the LST bits associated with the available SATT entry is set the appropriate LST for the hardware thread currently executing the AIG. The address is written to the associated SATT entry using the same displacement into the table as the displacement used to mark the LST.

If the PTRAN Bit is already set then it must be determined whether the address of the current load is already part of the AIG A . It can be that this decision was determined by walking through all of the entries of the associated Transaction Table to find a potential match. However a faster method shown in is used in . If it is determined that the address is already part of the current AIG then the load is completed A . If the address is not part of the current AIG it is still possible for the load to be processed. It may be determined A that the address is either currently marked as shared among AIGs or that the address may be changed to the state which allows it to be shared among AIGs . This may be determined by state information that is kept in the Transaction Tables. In this case A the address is added to the transaction table of the current AIG and the entry is marked as shared among AIGs .

The actions required to create entries in the SATT LST and SST during the processing of a store request are shown in . When a processor attempts a store type access a decision B is made to determine whether the access is part of an AIG and whether the special rules for AIG storage accesses apply. If the special mode of operation is not active then the store is treated as a normal store B . Assuming that an AIG is active the associated PTRAN bit must be inspected B . If the PTRAN bit is not already set then the PTRAN bit must be set. The LSTs for the 4 threads of the processor are accessed and the bits are read for the corresponding congruence class. If the congruence class is full B then the transaction must fail B . An SATT congruence class is considered full if all 4 of the SATT entries for that congruence class are already valid. An SATT entry is valid if one or more of the associated LST entries associated with that SATT entry is set. If one or more of the SATT entries in the congruence class is available then the processing of the store access continues B . The PTRAN bit is set and a new entry is added to the Transaction Table. The next available SATT entry in the associated congruence class is written and the corresponding SST bit is set. The LST bit associated with the available SATT entry is set in the appropriate LST for the hardware thread currently executing the AIG . The address is written to the associated SATT entry using the same index into the table. The old data is moved to the Transaction Table entry the address is written to the new transaction table entry and the Tran Info field is updated. The Tran Info field is marked to indicate that the access associated with this entry was a store type access. The new store data is written to memory after the setting of the PTRAN bit is completed. If the inspection of the PTRAN bit B indicates that the bit was already set then a decision B is made based on whether the current store address is already part of an AIG active on this thread. This decision can be made by examining the Transaction Table for the current thread. But in accordance with the combination of the LST and SATT entries are used to quickly determine if the address is part of the current AIG. The additional steps to make this determination are shown in . If the steps shown in indicate that the address is part of the current AIG then it is determined B whether the address is enabled to be shared among multiple AIGs. If the Tran Info indicates that the entry is a load type access entry that is shared among multiple AIGs the transaction fails B otherwise the Tran Info field for the associated entry is updated to indicate a store type access B the associated SST entry is set to 1 the old data is moved to the associated Transaction Table entry and the store is processed.

As stated in the original application a PTRAN bit is provided for each increment of real storage in the computing system. The preferred embodiment of the current invention uses a storage increment of 16 bytes QW each PTRAN bit is associated with one QW of real storage. Other implementation may use a larger increment such as 128 Bytes. Some implementations may also provide faster access and checking on PTRAN bits that are buffered in data caches. It may be beneficial for those systems to provide a storage increment granularity for the PTRAN bit that is 128 Bytes or 64 Bytes in order to match the line size of the cache. This may also provide the method of adding transactional memory support to existing systems that requires the fewest design changes and the lowest overall complexity in some cases. Systems that provide PTRAN bit buffering in this manner may still use the current invention to provide the illusion of a smaller storage increment than that used for the buffering. In one possible example a QW storage increment granularity can be tracked in the SATT entries at the same time that the L2 cache hardware provides a 128 Byte storage increment granularity at the L2 cache level.

Some implementations of the current invention may also include hardware or a combination of hardware and software that eliminates the need to provide a hardware PTRAN bit for every increment of real memory but still provides the illusion that the PTRAN bit exists for every increment. This may be beneficial to systems where the hardware cost of providing a PTRAN bit per increment is too high.

The capabilities of the present invention can be implemented in software firmware hardware or some combination thereof.

As one example one or more aspects of the present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The article of manufacture can be included as a part of a computer system or sold separately.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided embodied in a physical media.

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

