---

title: Performing policy conflict detection and resolution using semantic analysis
abstract: A method and system for managing a policy includes, in response to determining the presence of a conflict, determining a semantic equivalence between a component of a policy rule and at least one additional policy rule. The determining a semantic equivalence is performed by using a semantic reasoning algorithm that includes the steps of determining a first policy target of a first policy rule and a second policy target of a second policy rule, determining a meaning of the first policy target and a meaning of the second policy rule, assigning a confidence value based on the determined meaning of the first policy, assigning a confidence value based on the determined meaning of the second policy, performing a semantic comparison between the first policy target and the second policy target, and determining, based at least in part on the semantic comparison, the presence of a conflict between the first and second policy targets.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08327414&OS=08327414&RS=08327414
owner: Motorola Solutions, Inc.
number: 08327414
owner_city: Schaumburg
owner_country: US
publication_date: 20070621
---
This invention relates in general to the fields of policy management network management and self management i.e. autonomic computing systems and more specifically to the sub field of policy conflict detection and resolution.

Conflict detection and resolution is a complex topic. There are a host of references on conflict detection. shows a representative and comprehensive Policy Based Network Management PBNM system known in the art. This architecture explicitly identifies five different levels of conflict detection and resolution globally between policy servers globally across the different components of a particular policy server locally for all Policy Decision Points PDPs in a domain of a policy server local to a particular PDP within a specific domain of a given policy server and local per device i.e. a PEP in a domain.

A policy conflict occurs when the conditions of two or more policy rules that apply to the same set of managed objects are simultaneously satisfied but the actions of two or more of these policy rules conflict with each other.

A simplified model of a policy rule is a triplet consisting of three clauses event condition and action. Events are used to trigger the evaluation of a policy rule conditions specify if the policy rule is applicable and actions define what to do. Therefore there are three main types of conflicts that can occur in a PBNM system. The conflicts include conflicts between different policy rules conflicts between the actions within a policy rule and conflicts between policy rules within a policy rule e.g. sub rules within a rule .

Unfortunately this architecture does not address semantic conflicts. Semantics are neither considered in the definition of a policy conflict nor in the definition of a policy rule. This is true of all other policy rule definitions in the existing art.

There are mechanisms known in the art to detect policy conflicts. However these mechanisms fail to detect all of the above mentioned types of policy conflicts. For example two policies could pass all tests for conflicts and still have semantic conflicts e.g. two policies that when instantiated have conflicting side effects or conflicting directives based on different meanings .

A method and system are disclosed for managing a policy where the method includes determining a presence of a conflict and in response to determining the presence of a conflict determining a semantic equivalence between a component of a policy rule and at least one additional policy rule.

In accordance with an added feature of the invention the determining a semantic equivalence is performed by using a semantic reasoning algorithm.

In accordance with an additional feature of the invention the semantic reasoning algorithm further includes determining a first policy target of a first policy rule and a second policy target of a second policy rule determining a meaning of the first policy target and a meaning of the second policy rule assigning a confidence value based on the determining the meaning of the first policy assigning a confidence value based on the determining the meaning of the second policy performing a semantic comparison between the first policy target and the second policy target and determining based at least in part on the semantic comparison the presence of a conflict between the first policy target and the second policy target.

In accordance with an additional feature the present invention further includes determining whether a policy rule has a corresponding set of at least one policy event at least one policy condition and at least one policy action and then creating an error message if the policy rule does not have a corresponding set of at least one policy event at least one policy condition and at least one policy action.

In accordance with an additional feature of the invention the step of determining whether a policy rule has a corresponding set of at least one policy event at least one policy condition and at least one policy action includes determining the presence of one or more mandatory fields and then creating an error message if the one or more mandatory fields are not present.

In accordance with an additional feature the present invention includes determining the presence of at least one unknown data structure in the set of at least one policy event at least one policy condition and at least one policy action of a policy rule and in response creating an error message if an unknown structure is present.

In accordance with yet another feature the present invention includes determining a presence of at least two continuum levels determining a mismatch of the at least two continuum levels and creating an error message.

In accordance with yet a further feature a method and system are disclosed for managing a policy where the method includes using one or more of an information model a data model and an ontology to associate semantics from one or more different sources to one or more policies in a set of policies establish a relationship of semantic equivalence between the policies in the set of policies and determine a degree of conflict between the policies by using the relationship of semantic equivalence in a semantic equivalence algorithm.

In accordance with still a further feature the present invention includes estimating based on the degree of conflict which has been determined a probability of two or more of the policies conflicting with each other.

As required detailed embodiments of the present invention are disclosed herein however it is to be understood that the disclosed embodiments are merely exemplary of the invention which can be embodied in various forms. Therefore specific structural and functional details disclosed herein are not to be interpreted as limiting but merely as a basis for the claims and as a representative basis for teaching one skilled in the art to variously employ the present invention in virtually any appropriately detailed structure. Further the terms and phrases used herein are not intended to be limiting but rather to provide an understandable description of the invention.

The terms a or an as used herein are defined as one or more than one. The term plurality as used herein is defined as two or more than two. The term another as used herein is defined as at least a second or more. The terms including and or having as used herein are defined as comprising i.e. open language . The term coupled as used herein is defined as connected although not necessarily directly and not necessarily mechanically.

The present invention solves the limitations defined in the prior art by using a combination of information and data models ontologies and machine based reasoning mechanisms to 1 associate semantics from one or more different sources to each policy 2 establish a lattice of semantic equivalence between different policies and 3 determine the degree of conflict between policies by using a semantic equivalence algorithm. Significantly the degree of conflict provides a probabilistic estimation of whether two or more policies will in fact conflict.

Each policy server includes several components for performing conflict resolution at different abstractions within that server. A policy conflict occurs when the conditions of two or more policy rules that apply to the same set of managed objects are simultaneously satisfied but the actions of two or more of these policy rules conflict with each other. Each policy server has its own policy server controller which coordinates policies in its respective policy server. The policy server controller has a set of domains which are in communication with the policy server controller via a server bus . Each domain is coupled to a policy decision capability which may be represented by a single or set of policy decision points PDP . The PDPs evaluate policy conditions that are targeted at specific domains such as QoS and security. Hence the function of the policy controller is to ensure that policy decisions between domains that it governs do not conflict with each other. This addresses the most common existing and legacy deployments of policy management wherein separate policy control is assigned to different functions to be managed. However this should not limit the present invention.

Policy Decision Points PDPs communicate with a set of devices one or more of which enforce the policies provided by the PDPs. This is collectively denoted as the Policy Enforcement Point PEP . Each PEP performs its own conflict detection and resolution. The PEP is able to communicate directly with the server bus via a second server bus .

The above case illustrates one or more PDPs in one or more domains affecting the same PEP and is the most straightforward case of policy conflict. However it is also possible for the one or more PDPs in one or more domains to affect different PEPs that are related to each other. For example consider two network devices A and B that are supposed to communicate with each other. Assume that policy rules are used to determine if that communication is to be allowed or not. A conflict will occur if one policy rule allows device A to communicate with device B but the other policy rule does not allow device B to communicate with device A.

The PEP thus receives policy rules from one or more PDPs from one or more domains. However the PEP may not be able to execute these policy rules. For example the policy rules may be in a language that the PEP does not understand.

Reviewing the different types of conflict detection that illustrates within a domain that this invention detects there are 

The policy based system in accordance with one embodiment of the present invention also includes a policy broker . The policy broker controls how different policy servers interact with each other and ensures that conflicts do not exist between the policy servers . The policy broker also coordinates the application of different policy rules in different policy servers .

The policy based system in accordance with one embodiment of the present invention further includes a policy console . This component is used by policy authors and editors to create update store delete manage and deploy policy rules in the system.

The Policy Analyzer of includes six important entities the Model Repository the Policy Repository the Ontology Repository the XML Translation Logic the Semantic Bus and the Semantic Analysis Logic . Connection to the Policy Management Software which is responsible for enabling the user to create edit read update delete store and manage Policies is conceptually done through a simple API represented as the two arrows labeled Semantic Analysis Request and Semantic Analysis Result shown in .

Information and data models are stored in the Model Repository . One preferred embodiment of the present invention will use the simplified Directory Enabled Networks new generation DEN ng policy model as described in John C. Strassner Morgan Kaufmann Publishers 2004 the contents of which are hereby incorporated by reference for its information and data model representation as this approach enables a close correlation to be maintained between the information model and the set of data models. Note that there will usually be a set of data models since different management data has different characteristics and usage patterns requiring different repository implementations for both the storing and querying of management data. If the embodiment shown in is not used then equivalent functionality must be supplied. provides a superset of the capabilities of .

For purposes of the present invention an information model is defined as an abstraction and representation of the entities in a managed environment. This includes definition of their attributes operations and relationships. It is independent of any specific type of repository software usage or access protocol. A data model as used herein is a concrete implementation of an information model in terms appropriate to a specific type of hardware and software platform defining a single repository that uses a specific access protocol or protocols and language or languages to define its management data. It includes data structures operations and rules that define how the data is stored accessed and manipulated.

In general the information model and data models can be located in multiple repositories since vendor specific devices and applications usually have their own vendor specific data models that are used. Developers may not have derived their data models from a single information model hence there may be no inherent correlation between objects and attributes in each of the data models. Furthermore policies often use information and or data models for their construction and specification. generalizes the approach of by enabling data from all three repositories the Policy Repository the Data Model Repository and the Information Model Repository to be sent via a Model Bus to Model Correlation Logic whose function is to determine how each element of each repository is related to each other. This is discussed further below. However this is not the optimal representation of the present invention for reasons to be shown shortly. Rather the purpose of is to illustrate the subtle problems involved in various scenarios and to show how this invention handles them.

Policies are stored in the Policy Repository . This may be done before or after the Policy is input to the present invention as well as before or after the component s interested in using the Policy have started its their processing. This is done to ensure compatibility with legacy systems since many early policy management implementations recommended storing the Policy first before any validation or processing of it was done.

Embodiments of the present invention can accommodate two very different forms of policies. The first and preferred form of policy is a representation which either uses or is derived from knowledge from information and or data models i.e. the information and or data model is used to define and represent the structure of the policy rule as is shown in John C. Strassner Morgan Kaufmann Publishers 2004 . The logic necessary to accommodate this form of policy is shown in . Note that in this figure the Policy Repositories have been separated from the Ontology Repositories . This is because in this approach the policy is already in a form compliant with information model and data model processing while the ontology is not. Hence knowledge from the information data and policy repositories is combined into the model bus and then analyzed using the model correlation logic while knowledge from the ontology due to its different format and representation are separated and fed directly into the XML translation logic. Two examples of this form of policy are Ponder2 a description of which can be found at http ponder2.net and DEN ng a description of which can be found in the above referenced Policy Based Network Management book. The second form of policy is one in which an information or data model is not the primary element used to define the representation or structure of a policy rather an ontology is used to do this. Examples of this approach can be found in A. Uszok et. al. and Lalana Kagal Tim Finin and Anupam Joshi the entirety of which is hereby incorporated by reference. This requires a slight modification of as shown in and explained in detail below.

The purpose of the Policy Correlation Logic shown in is to examine the format and structure of the policies in each of the possibly many Policy and Ontology Repositories to determine if each policy is derived from either a model information or data model or an ontology. If it is then this logic is able to verify that the policy rule is correctly formed by comparing its representation to that of the representation defined in the corresponding model and or ontology.

The Model Correlation Logic shown in performs a model mapping between the different data models in the system. An exemplary model mapping is shown in . A model mapping is a translation from one type of model to another type of model. Model mapping changes the representation and or level of abstraction used in one model to another representation and or level of abstraction in another model. Hence its output is a normalized form of data contained in the possibly different set of data models being used in the system.

One might wonder why the Policy Correlation Logic does not feed the Model Correlation Logic . There are two reasons for this. First if a policy is not derived from an information and or data model then it makes no sense to connect the output of the Policy Correlation Logic to the input of the Model Correlation Logic . Second even if a policy is derived from an information and or data model the representation and structure of the policy may not be completely defined by the models. Hence additional examination of the policy specification is desired.

Ontologies have their root in philosophy where the study of ontology is a branch of metaphysics that deals with nature of being. In computer science and knowledge engineering ontologies define theories of what exists. For purposes of the present invention ontologies are interesting for at least two reasons 1. ontologies offer a formal mechanism for defining a better understanding of facts and 2. shared ontologies ensure that different components and applications communicate about different aspects of the same entity in a standard way.

Ontologies are used to model declarative knowledge. By this we mean knowledge in which the relationships between the data are declared or stated and then one or more automatic mechanisms are used to answer queries about the data.

Numerous definitions of ontologies can be found. Once such definition is found in J. Strassner chapter submitted to Elsevier Publishing for the book to be published in 2007 the entirety of which is hereby incorporated by reference. For purposes of the present discussion an ontology is defined as a formal explicit specification of a shared machine readable vocabulary and meanings in the form of various entities and relationships between them to describe knowledge about the contents of one or more related subject domains throughout the life cycle of its existence. These entities and relationships are used to represent knowledge in the set of related subject domains. Formal refers to the fact that the ontology should be representable in a formal grammar. Explicit means that the entities and relationships used and the constraints on their use are precisely and unambiguously defined in a declarative language suitable for knowledge representation. Shared means that all users of an ontology will represent a concept using the same or equivalent set of entities and relationships. Subject domain refers to the content of the universe of discourse being represented by the ontology.

The Ontology Repository is used to store one or more ontologies that are used in semantic analysis of both Policies and model elements that the Policies refer to. The Ontology Repository is a separate storage entity because of at least two reasons. First the Ontology Repository being a separate storage entity enables the use of common off the shelf COTS components to realize the Repository note that such COTS components also include additional tools such as reasoners which can be used by the Semantic Analysis Logic that are not part of COTS components to realize Model and Policy Repositories and respectively. Second the structure of the ontology data as well as the protocols used to access and edit those data are significantly different than those of information and data models.

The XML Translation Logic of is shown in greater detail in . The XML Translation Logic contains a Data Abstraction Layer that enables embodiments of the present invention to be used with different types of storage mechanisms and hence different types of repositories. emphasizes the principle of abstraction. DEN ng is an information model which is independent of platform language and protocol but is used to define one or more data models for the system. Each data model is fine tuned to a particular set of platform language and protocol requirements. This enables different applications to make use of different management information since each type of management information has its own storage access and other requirements. It is impossible or at least very difficult to design a single repository that can simultaneously meet all of these different needs since for example each type of management data requires different query languages and hence different types of data structures to meet different requirements of different management applications. This problem is solved by using a combination of a common information model e.g. DEN ng and a set of standard model mappings that translate information including the definition and representation of Policies into one or more data models.

The role of the common information model is to define the information in a technology neutral fashion once so that different model mappings can be used to translate this data according to the specific needs of a particular repository in an optimal fashion. Thus the common information model and the set of model mappings are used together to implement the conceptual Policy Repository shown in . Hence this Policy Repository accommodates the storage of Policies with the data that they apply to which is useful for enabling model driven code generation.

Without a common data abstraction layer the n different systems that need to access data in the Policy Repository must access that data from potentially m different data stores. This is very undesirable as it means that each of the n data processing systems must support up to m different protocols and interfaces which in turn implies at least one but probably more language with its own set of data structures. A much better and more scalable solution is to provide a common Data Abstraction Layer whose purpose is to determine from which Repository to get the requested data. In order to do this the Data Abstraction Layer may also need to reformulate the original query posed by the data processing component in order for that query to be executed in a more efficient manner. Thus we centralize this problem and require just the Data Abstraction Layer of the Policy Repository to shoulder the burden of interfacing with the plethora of different data processing components that comprise the rest of the Policy Management System .

The Data Abstraction Layer provides a single interface to a multiplicity of Policy and Ontology Repositories. The XML Translation Logic translates the different types of queries and commands that each Repository understands into a common XML format and vice versa.

The purpose of the semantic bus is to provide a single interface for enabling the Semantic Analysis Logic to communicate with the Model Repository the Policy Repository and with the Ontology Repository . Since the structure and representation of data in these two repositories is different embodiments of the present invention insert adaptation software to translate native data received from either repository to a common XML based format for the Semantic Analysis Logic to process. Similarly data from the Semantic Analysis Logic that needs to be stored in either repository is converted from the common XML based format to a native format appropriate for the particular repository that is being used. This is shown in . One advantage of this approach is that the different components of the Semantic Analysis Logic can now be designed and implemented using a single data format.

The Semantic Analysis Logic includes a set of mechanisms that provide two functions 1. Detecting semantic conflicts between two policies at the same level of abstraction e.g. between two business policies and 2. Detecting semantic conflicts between two policies at different levels of abstraction e.g. between a business policy and an implementation policy . The Semantic Analysis Logic uses ontologies to accomplish the above two tasks.

The concept of a template is fundamental to certain embodiments of the present invention. As used in this invention a template is a pre defined pattern that is used to design new policy rules groups of policy rules and their constituent components. Conceptually a policy template is similar to how templates are used in popular word processing programs. In the present invention a template is used to simplify the processes of reusing and customizing existing policy rules to meet the specific needs of a given application.

Embodiments of the present invention assume the use of a combination of keywords and noise words to demarcate various fields in a template. A keyword is an identifier that has a particular meaning to the policy language being analyzed. Keywords are reserved words meaning that they have a particular meaning to the language and hence cannot be used generically. For example a keyword such as IF may identify a flow of control and hence cannot be used in a generic sense such as for the name of a variable. Noise words are language elements that are present only for the purpose of making it easier for certain constituencies to understand a word phrase or sentence however noise words don t change the meaning of that word phrase or sentence. For instance in the sentence Mary has retrieved a total of 10 records has and a total of are noise words as neither provide any useful information above or beyond the other words.

We assume that a combination of keywords and noise words are used to demarcate fields that have special meaning in the policy languages that are examined by this invention. This enables the policy author to indicate specific fields e.g. words numbers or even sentences that are contextually significant to the end user. In this approach keywords are used to impart meaning while noise words are used to make the sentence or phrase easier to understand for novice users. This invention can be used for languages that do not use this approach as long as there is a means of differentiating the set of fields that are editable by the user from the non editable structure of the policy rule. The concept of a template is shown in .

One preferred use of key words is as a pair. Two examples of such pairs in are the pair BEGIN COMMENT END COMMENT and the pair CREATE POLICYRULE END POLICYRULE DEFINITION . This makes the template easier to parse as the pair of keywords identifies a field. It also makes the meaning of the policy easier to understand for the novice user as the additional noise words make the phrase more readable. The present invention can cope with keywords that do not form such pairs as long as the policy grammar is available in a machine readable form.

Enabling a user to customize a template also enables the user to modify that template and or its contents into a potentially wrong or unrecognizable state. Embodiments of the present invention advantageously avoid this problem by detecting modifications to the template validating their correctness and then either automatically fixing any problems detected or presenting the erroneous text to the policy author so that the policy author can fix it.

Referring to the combination of keywords and noise words are used to establish a particular context for validating user input. For example the noise word NAMED occurs in two different contexts CREATE POLICYRULE NAMED and ON OCCURRENCE OF EVENT NAMED . Each context can have different rules for determining if the user supplied input AuthenticateUser and Logon respectively as shown in is correct or not. Put another way the present invention may use one set of rules to determine if the first user supplied input AuthenticateUser is correct and a completely different set of rules to determine if the second user supplied input Logon is correct. Hence the invention establishes the particular context for each entry in each of its templates. The establishment of context means that the invention can recognize situations which do not follow the pre defined rules of the template. For example if a user modifies the keyword CREATE POLICYRULE to CREATE RULE embodiments of the present invention can match these terms with a particular confidence level and then either 1 change the user modified term back to the form in the template and or 2 locate the keyword s pair and convert it to a similar format. Of course this invention can also query the user to determine what the user would like to do in such a case revert back to the standard form as defined in the template or modify the template.

A logical question may be if the template is followed exactly how can there be a conflict A simplistic definition of the term policy conflict is as follows A policy conflict occurs when the events of two or more policy rules cause the conditions of those policy rules to execute at the same or an overlapping time period that apply to the same set of managed objects but the actions of two or more of these policy rules conflict with each other. In other words even if the user follows the template exactly the user may still unwittingly cause a policy conflict due for example to the user s lack of understanding of the particular semantics associated with two policy rules. Such conflicts may be direct causing a different action to happen to the same object or indirect causing resources required for other actions to become unavailable .

If the template is not followed then the present invention has the opposite challenge of determining if an input is valid or not. The invention uses ontologies and semantic reasoning to determine whether an unknown element is valid or not. Semantic reasoning attempts to determine the set of meanings that an entity e.g. a new word that is not in the vocabulary of the Policy Management System has as well as relationships between that entity and other entities that the system knows about e.g. is it a synonym of another word . This will be further explained below.

The mechanism shown in represents the setup required to semantically analyze and augment the set of policy rules to examine for conflicts i.e. the steps shown in the actual semantic analysis and augmentation is shown in .

The flow of begins at step and moves directly to step where the semantic analysis and augmentation setup process is initialized by first retrieving the language that is to be analyzed from the Policy Repository . This enables this invention to be used for a plurality of languages. Hence this first step tries to match the subject language to one of its pre defined languages stored in the Policy Repository . This is most easily done by matching the language to one of the policy templates which are also stored in Policy Repository . This is because each policy template is constructed from a particular language. If a policy template is recognized then the process skips the intermediate processing steps as indicated in and moves directly to step since each policy template is defined using a particular policy language. If it cannot recognize the subject language as fitting one or more policy templates the flow moves to step where it then tries to recognize the most basic elements of a policy rule a set of Policy Events a set of Policy Conditions and a set of Policy Actions. If it cannot recognize a Policy Rule and its constituent components then this is either a malformed Policy or the input policy contains a structure that this invention cannot understand and in step an error is raised.

If a Policy Rule and all of its constituent components are recognized in step the flow moves to step and checks to see if the requisite mandatory fields that make up the constituent components of the Policy Rule are recognized. For example a Policy Condition must be of the generic form . If it cannot the flow moves to step where an error is raised. If it can recognize the requisite mandatory fields that make up the constituent components of the Policy Rule the flow moves to step and then checks for any unknown data structures. For the purposes of this discussion an unknown data structure is a grammatical construct that the present invention cannot understand. For example a noun or verb may have been introduced into the policy rule that is not in the language specification that this invention is currently using. For example an unknown noun could be an unknown Managed Entity and an unknown verb could indicate a particular policy action or constraint that is currently undefined. Either of these indicates that key parts of the input language are unknown to this invention and so an error is raised. In this context largely unknown is a qualitative assessment which determines whether enough of the key elements of the language are known i.e. have existing definitions and relationships both in the models as well as in the ontologies or not.

If unknown structures are found in step the flow moves to step and an error message is produced. Alternatively if the policy language is recognized the policy continuum level or levels referenced by the language are then retrieved. This is needed to ensure that the user hasn t crafted a language that uses elements from two different continuum levels as this is not allowed due to the inherent mismatch of concepts involved. Note that multiple policy continuum levels are allowed as long as they are embodied in separate policy rules. Construction and management of a policy continuum along with translation of policies into forms appropriate for differing layers of a policy continuum within a network is disclosed in United States Patent Application Publication Number 20080162109 entitled Creating and Managing a Policy Continuum published on Jul. 3 2008 which is hereby incorporated by reference in its entirety. Hence the system checks in step for the presence of multiple levels of the policy continuum. If multiple levels are found the flow moves to step and checks for policy rules that have terms that are unique to two or more different levels. If these are found the process terminates by creating an error message in step . Otherwise additional policy languages are loaded in step along with the templates in step for each policy language. These templates serve as filters to strip out words and phrases that do not add semantic meaning to the Policy Statement so that the semantic analysis logic need only examine words that have an associated meaning. Based on this a set of applicable information and data models as well as ontologies are loaded in step . Step represents the end of the setup operations to start the operations shown in .

A process flow chart showing the operation of the Semantic Analysis Logic is shown in . Note that the present invention assumes that one or more of a set of pre defined policy templates are used and that all of the language syntax and semantics used to write the policy rules being read is known. The significance of these two points is as follows. A policy template is a formal regular structure that defines the representation of a policy rule and its components e.g. the events conditions and actions contained in a policy rule . If a policy template is not used then the definition and structure of a policy rule must be dynamically discovered. Similarly if the syntax and semantics of the language are not known ahead of analysis time then these characteristics must also be dynamically discovered.

In summary the overall process performed by the steps of ensures that all policy rules have been semantically analyzed and augmented as necessary. Once this is done all policy rule pairs are examined for semantic conflicts.

After step of the flow moves to step of . In step a determination is made as to whether an unmodified standard template is being used. If the Policy Rule uses an unmodified standard template then the Policy Rule is formed from a standard template definition and hence simpler mechanisms that require less computational resources can be employed to check for semantic conflicts than if the Policy Rule has modified a standard template. Therefore if the answer to the inquiry of step is yes the flow moves to step . In step the components i.e. a set of Policy Events a set of Policy Conditions and a set of Policy Actions of the first Policy Rule are retrieved.

Semantic conflict detection is computationally expensive. Best practices dictate that simpler conflicts first be detected. An exemplary check for this case includes removing the noise words step establishing the context step and then running the process which is an efficient way to determine if there are simple conflicts present as described in United States Application Publication Number 20080126287 entitled Method For Management of Policy Conflict in A Policy Continuum published on May 29 2008 which is hereby incorporated by reference in its entirety. Step checks to see if there are conflicts present. If the answer to step is yes then the function terminates at step if not then the invention takes the No branch from step to check for semantic conflicts.

Semantic conflict checking is performed in step using any semantic reasoning algorithm that can determine the semantic equivalence between a component of the Policy Rule to be examined and all other Policy Rules. An example of such an algorithm is given in A. Wong P. Ray N. Paramesh J. Strassner JSAC 2005 special publication on semantics. Further details of the Run Semantic Reasoning function of step are shown in . This function iterates over each component of the Policy Rule to check if the best meaning for that particular language element of the Policy Rule i.e. what the Policy Subject and Target refer to and what the exact Policy Event Condition and Action clauses entail conflicts with any other Policy Rule. If this process fails to determine a best meaning then an error is raised otherwise the flow moves to step where a confidence check is performed. This enables the invention to use a programmable threshold to measure the accuracy of the semantic equivalence matching. If sufficient accuracy is not obtained then the processing moves to and terminates with an error otherwise a check is made in step to see if there are additional policies. If there are the next Policy Rule is retrieved in step and the process repeats starting again at step . Otherwise the process terminates at step .

For example assume two Policy Rules A and B are being checked for conflicts. Assume further that Policy Rule A contains two Policy Targets and Policy Rule B contains three Policy Targets. will first parse Policy Rule A into its constituent components namely its Policy Subjects Policy Targets Policy Events Policy Conditions and Policy Actions. Then it will retrieve the best meaning for each of the two Policy Targets in Policy Rule A in step . If the process is unable to either find a Policy Target or retrieve the best meaning of a Policy Target then an error is raised. Otherwise in step the process retrieves the best meaning for each of the Policy Targets for each of the Policy Rules that this Policy Rule is being tested against. For example assume that the Policy Targets of Policy Rule A are a host computer and an Internet gateway. Assume that the Policy Targets of Policy Rule B are a video monitor a router and a host computer. Through semantic analysis the process compares synonyms antonyms holonyms and meronyms along with custom application specific relationships as described earlier to each Policy Target of each Policy Rule. The following can be concluded from this example as a result of this semantic analysis 

Since all five semantic conflict tests are the same only one will be described. The component of the Policy Rule to be examined Policy Target is shown for illustrative purposes in is retrieved. Then the best meaning of the element of the Policy Rule being examined and the best meaning of that same element for all other Policy Rules are retrieved. The semantic equivalence confidence factor is recorded for all pairs. A semantic comparison of all pairs of the element of the Policy Rule being tested is then performed. If a conflict is found the conflicting elements are recorded else the next element of the Policy Rule is retrieved. This process starts with testing all Policy Targets and then successively tests all Policy Subjects Policy Actions Policy Conditions and finally Policy Events. The process then returns to step of for further processing.

If at step of it was determined that the template was modified then the template is analyzed to see if there is enough similarity between its structure and the language vocabulary and grammatical rules that have been pre defined for use by the system. Put another way the system now determines whether the inability to match a pre defined template is because the structure of the template has been changed but not its grammatical elements a small number of grammatical elements have either been changed or introduced but the overall structure has been retained or a combination of both.

Embodiments of the present invention can handle limited deviations from both the structure of the template as well as the introduction of new meanings for a given word and or new words. This is accomplished using linguistic morphology in step . If the nature of the template deviations are relatively minor the template can be modified to accommodate these changes using linguistic morphology. This is represented by decision block labeled Mappable along with the subsequent step . These tests are similar in nature to those described above except that they are more granular. For example since the template was not matched then the process must determine the meaning of all words. If a new word or phrase is encountered then the system must attempt to determine its meaning using its constituent morphemes.

A morpheme literally is defined as an element in a system of forms. Linguistics defines a morpheme as the smallest form that is paired with a particular meaning. A form is any physical structure e.g. combination of symbols . A word is usually constructed of multiple morphemes. Compound words which combine multiple words derive their meaning from their constituent morphemes. Morphology is the science of the structure of words. In linguistic morphology a morpheme is the smallest lingual unit that carries semantics. A lexeme is an abstract unit that in morphology roughly corresponds to a set of words that are different forms of the same word e.g. run runs running and ran are forms of the same lexeme . The use of the forms of a lexeme is governed by rules of grammar e.g. subject verb agreement and compound tense rules . A lexicon consists of lexemes.

Morphology is a set of formal methods that analyze the structure of words of a language. This is done by breaking a word into its constituent morphemes. The meaning of the word is found by considering the effect that each of its constituent morphemes has. For example a common way of designating a plural form in English is with the suffix s . However when two morphemes have different meanings e.g. seahorse and catbird the resultant compound word has vastly different meaning than just changing it from a single to a plural form. Morpheme analysis is harder than it seems the same morpheme can have vastly different meanings e.g. in means not in words like incapable but means into or within in words like include . When multiple forms have the same meaning they could be different morphemes e.g. andr in android and man both mean a male human or one morpheme e.g. a and an two different forms of the same Greek morpheme meaning not or without these are also called allomorphs.

As in above if at any time a meaning cannot be established the process aborts with an error in step otherwise the process continues to step . At this point after following the flow of a set of semantic equivalence tests are run. These tests match the non noise elements of the Policy Statement to terms in a universal lexicon established by the combination of the knowledge in the Policy and Ontology Repositories to arrive at a best meaning for the Policy Statement. This is then done for all Policy Statements and finally for the Policy itself. If at any time a meaning cannot be established the process aborts with an error otherwise the process continues.

Note that in either of the above cases the process might find different confidence levels assigned to different meanings. This can be resolved by repeatedly using one or more linguistic morphology processes to arrive at an agreed upon confidence. If the result is not OK then the process is aborted and an error is raised. Otherwise the system first checks for more Policy Statements of the same Policy and subsequently for different Policies.

In one embodiment of the present invention the computing system includes one or more processors such as processor . The processor is connected to a communication infrastructure e.g. a communications bus crossover bar or network . Various software embodiments are described in terms of this exemplary computer system. After reading this description it will become apparent to a person of ordinary skill in the relevant art s how to implement the invention using other computer systems and or computer architectures.

The computing system can include a display interface that forwards graphics text and other data from the communication infrastructure or from a frame buffer for display on the display unit . The computing system also includes a main memory preferably random access memory RAM and may also include a secondary memory as well as various caches and auxiliary memory as are normally found in computer systems. The secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a manner well known to those having ordinary skill in the art. Removable storage unit represents a floppy disk a compact disc magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated the removable storage unit includes a computer readable medium having stored therein computer software and or data. The computer readable medium may include non volatile memory such as ROM Flash memory Disk drive memory CD ROM and other permanent storage. Additionally a computer medium may include for example volatile storage such as RAM buffers cache memory and network circuits. Furthermore the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and or a network interface including a wired network or a wireless network that allow a computer to read such computer readable information.

In alternative embodiments the secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into the policy server . Such means may include for example a removable storage unit and an interface . Examples of such may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to the computing system .

The computing system in this example includes a communications interface that acts as an input and output and allows software and data to be transferred between the policy server and external devices or access points via a communications path . Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be for example electronic electromagnetic optical or other signals capable of being received by communications interface . The signals are provided to communications interface via a communications path i.e. channel . The channel carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link and or other communications channels.

In this document the terms computer program medium computer usable medium and computer readable medium are used to generally refer to media such as main memory and secondary memory removable storage drive a hard disk installed in hard disk drive and signals. The computer program products are means for providing software to the computer system. The computer readable medium allows the computer system to read data instructions messages or message packets and other computer readable information from the computer readable medium.

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable the computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable the processor to perform the features of the computer system.

As should now be clear embodiments of the present invention represent the underlying meaning of entities being modeled as one or more ontologies and uses semantic reasoning to augment the knowledge obtained from the information and data models to better understand the intent of the policy author s . This invention then constructs a policy continuum from the one or more policies supplied to it and defines a set of mechanisms to manage the constructed policy continuum.

Although specific embodiments of the invention have been disclosed those having ordinary skill in the art will understand that changes can be made to the specific embodiments without departing from the spirit and scope of the invention. The scope of the invention is not to be restricted therefore to the specific embodiments and it is intended that the appended claims cover any and all such applications modifications and embodiments within the scope of the present invention.

