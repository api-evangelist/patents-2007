---

title: Event queuing and consumption
abstract: Techniques are described to provide event queuing and consumption. In an implementation, events received at an event router are queued after determining that a switch is to be performed from a first event consumer to a second event consumer. Events previously queued at the first event consumer are communicated to the second event consumer, and when completed, the events queued at the event router are communicated to the second event consumer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484660&OS=08484660&RS=08484660
owner: Microsoft Corporation
number: 08484660
owner_city: Redmond
owner_country: US
publication_date: 20070613
---
Events may be encountered in computing environments in a variety of ways. For example an event may be triggered by a user such as through a keystroke by right clicking a mouse and so on. In another example events may also be triggered by applications whether executed locally at a client or remotely over a network connection. The events may then be communicated and processed in a variety of ways such as by being passed from an operating system to an application to cause a file to be opened saved and so forth.

In some instances a variety of different entities may be available at any one time to consume events by what may be referred to in the following discussion as event consumers . For example a first application may be configured to consume content of a particular type while a second application may be configured to consume content of another type. Therefore techniques were developed to permit switching between these event consumers when desired such as when switching between types of content consumption. Traditional techniques that were employed to manage how these events are consumed however could be inefficient when switching between consumers thereby reducing the speed and efficiency of devices that employed these traditional techniques. Additionally these traditional techniques could even encounter errors due to dropped e.g. missed events due to processing of out of order events and so on.

Techniques are described to provide event queuing and consumption. In an implementation events received at an event router are queued after determining that a switch is to be performed from a first event consumer to a second event consumer. Events previously queued at the first event consumer are communicated to the second event consumer and when completed the events queued at the event router are communicated to the second event consumer.

In a further implementation an event consumption system includes an event router to route events to a plurality of event consumers. The events are serialized in a particular order one after another for consumption by a respective one of the event consumers. When a deactivate event is encountered a switch is to be performed from a first one of the event consumers to a second one of the event consumers by queuing events at the event router until events from a queue of the first event consumer are transferred to the second event consumer.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Events form part of the backbone of processing performed in a computing environment. For example an event may be triggered by a user e.g. by right clicking a mouse by an application e.g. by calling an application programming interface may be communicated remotely over a network connection and so on. Traditional techniques that were employed to manage events however could be inefficient and result in errors such as by processing events out of order dropping events and so on.

Techniques are described to queue and consume events. In an implementation an event consumption system includes an event router and a plurality of event consumers. The event router knows which event consumers are active and is responsible for communicating events to the appropriate queue of the appropriate event consumer. When a switch is to be made from a current event consumer to a new event consumer the event router queues the events. Events already queued at the current event consumer are streamed to the new event consumer after which the events queued at the event router are then streamed to the new event consumer. In this way serialization of the events is maintained while ensuring that events are not lost . Further discussion of the event consumption system may be found in relation to the following sections.

In the following discussion an exemplary environment is first described that is operable to perform event queuing and consumption techniques. Exemplary procedures are then described that may be employed in the exemplary environment as well as in other environments. Although these techniques are described as employed within a television environment in the following discussion it should be readily apparent that these techniques may be incorporated within a variety of environments without departing from the spirit and scope thereof.

The client may be configured in a variety of ways. For example the client may be configured as a computer that is capable of communicating over the network connection such as a desktop computer a mobile station an entertainment appliance a set top box communicatively coupled to a display device as illustrated a wireless phone and so forth.

The content provider includes one or more items of content where k can be any integer from 1 to K . The content may include a variety of data such as television programming video on demand VOD files one or more results of remote application processing and so on. The content is communicated over the network connection to the head end .

Content communicated via the network connection is received by the head end and may be stored as one or more items of content where n can be any integer from 1 to N . The content may be the same as or different from the content received from the content provider . Distribution from the head end to the client may be accommodated in a number of ways including cable radio frequency RF microwave digital subscriber line DSL and satellite.

The client as previously stated may be configured in a variety of ways to receive the content over the network connection . The client typically includes hardware and software to transport and decrypt content received from the head end for rendering by the illustrated display device. Although a display device is shown a variety of other output devices are also contemplated such as speakers.

The client for instance may include digital video recorder DVR functionality. For example the client may include a memory to record content as content where c can be any integer from one to C received via the network connection for output to and rendering by the display device. Thus content that is stored in the memory of the client may be copies of the content that was streamed from the head end . Additionally content may be obtained from a variety of other sources such as from a computer readable medium that is accessed by the client and so on.

The client as illustrated includes a communication module that is executable on a processor and is storable in the memory of the client to control content playback on the client such as through the use of one or more command modes i.e. trick modes . The command modes may provide non linear playback of the content i.e. time shift the playback of the content such as pause rewind fast forward slow motion playback and the like. The processor is not limited by the materials from which it is formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context executable instructions may be electronically executable instructions that are performed by the processor . Additionally although a single memory is shown a wide variety of types and combinations of memory may be employed such as random access memory RAM hard disk memory removable medium memory and other types of computer readable media.

The content may also be representative of time shifted content such as video on demand VOD content that is streamed to the client when requested such as movies sporting events and so on. For example the head end may execute a content manager module to provide a VOD system such that the content provider supplies content in the form of complete content files to the head end . The head end may then store the content as content . The client may then request playback of desired content by contacting the head end e.g. a VOD server and requesting a feed of the desired content. The content manager module may also be representative of functionality to configure content received from the content provider to be suitable for transmission over the network connection such as to packetize the content for distribution over the Internet configuration for a particular broadcast channel map the content to particular channels and so on.

In another example the content may further be representative of content e.g. content that was recorded by the head end in response to a request from the client in what may be referred to as a network DVR example. Like VOD the recorded content may then be streamed to the client when requested. Interaction with the content by the client may be similar to interaction that may be performed when the content is stored locally in the memory .

Thus in the environment of the client may consume content from a variety of sources. For instance the content provider may broadcast the content over a network connection to a multiplicity of network operators an example of which is illustrated as head end . The head end may then stream the content over a network connection to a multitude of clients an example of which is illustrated as client . The client may then store the content in the memory as content and or render the content immediately for output as it is received such as when the client is configured to include digital video recorder DVR functionality. The client may also be configured to consume content when configured as VOD pay per view content music images and so on. Thus the client may consume a wide range of content.

To consume this content from this variety of content the communication module is illustrated as including an event consumption system to manage consumption of a plurality of event consumers where e can be any integer from one to E . For example the event consumers may be configured in a variety of ways such as a native platform a virtual machine applications and so on. The event consumption system may therefore be used to provide events to these different event consumers to maintain serialization and reduce lost events further discussion of which may be found in relation to the following figure.

In any such system events may be encountered that are serialized and ordered for consumption in the same order in which the events were generated. This is illustrated in as included events and in the queue of the native event consumer and events and in the queue of the managed event consumer . Even though the event are serialized as illustrated in these events may be consumed by different respective event consumers. In the illustrated implementation each of the events is configured for consumption by a single entity and not multiple entities at the same time. For example an event may be consumed by the managed event consumer or the native event consumer but not both.

A variety of different situations may be encountered to cause a switch from one event consumer to another event consumer. For example the events themselves can cause a switch from one consumer to another an outside entity e.g. an application may cause a switch and so on. When switching between event consumers the event consumption system may employ techniques to determine which mechanism will consume particular queued events when to switch between event consumers and when to propagate the queued events from a current consumer to a new consumer while retaining the original order in which the events were generated.

For example as shown in the event consumption system may be employed within a television environment to consume different types of content. In such a system the native event consumer may be configured to consume traditional broadcast content while the managed event consumer may be configured to control consumption of other types of content such as video on demand. For instance the native event consumer may support native code written in C and C . In addition the managed event consumer may have a virtual machine that supports managed code written in C . Both the native event consumer and the managed event consumer consume events and keep their own separate event queues respectively.

In this example managed applications A that receive events generally do not handle tuning to particular channels. Instead the events are handled by the native event consumer . For instance if a user is running a managed application to consume video on demand and then presses the 2 0 and 1 keys of a remote control to tune to channel the managed application sees the 2 key and decides that it is not capable of handing this input at this time. Therefore these three key events are sent to the queue of the native event consumer after they have already been placed in the queue of the managed event consumer .

Further channel tuning in this example implies a switch from the managed application of the managed event consumer to a native application of the native event consumer that provides channel tuning and thus any additional events generated are also sent to the native queue. Further these events are to be inserted after the 2 0 and 1 keys. If this is not done properly the keys may be processed by the native event consumer out of order resulting in a tune to a different channel. For instance if the switch from the managed event consumer to the native event consumer happens between the 0 and the 1 keys the client may tune to channel instead.

Accordingly the event consumption system employs the event router that knows which of the event consumers are active and sends events to the appropriate queue e.g. queues . For instance when the managed applications A are launched the event router is told to send events to the queue of the managed event consumer and the managed applications A consumes those events. When either of the managed applications A reaches an event that it is not capable of handling it sends the event to the queue of the native event consumer via an application programming interface API . If this event results in a switch from the managed event consumer to the native event consumer then the event router is told to stop sending events to the managed event consumer and to store subsequent events for future use by the native event consumer in a queue .

At this point the event consumption system is informed that the managed applications A are to be deactivated and it should communicate events that remain in the queue e.g. events to the native event consumer . Then a special Reset event is injected into the managed event queue signifying the end of the event stream. The managed application s A may then service the events in the queue of the managed event consumer by sending them to the queue of the native event consumer using the API. Once the events are communicated the managed event consumer informs the event router to communicate events that have been stored in the queue to the native event consumer in the order that they were generated.

Thus the event consumption system may enforce serialization of events and ensure that events are not dropped or handled out of order during context switches. Traditional techniques used to provide a switch between event consumers prevented events from being generated during a context switch. However the techniques described herein may provide significantly better performance than such traditional techniques because events may be continually generated and queued during a switch with little impact on end user performance thus being transparent to the user. Further discussion of switching between event consumers may be found in relation to the following procedures.

It should be noted that one or more of the entities shown in may be further divided e.g. the head end may be implemented by a plurality of servers in a distributed computing system combined and so on and thus the environment of and the embodiment of the event consumption system of is illustrative of one of a plurality of different environments and systems that may employ the described techniques.

Generally any of the functions described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module functionality and logic as used herein generally represent software firmware hardware or a combination thereof. In the case of a software implementation for instance the module functionality or logic represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices. The features of the event techniques are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

The following discussion describes event techniques that may be implemented utilizing the previously described environment systems and devices. Aspects of each of the procedures may be implemented in hardware firmware or software or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion reference will be made to the environment of the event consumption system of and the embodiments of the event consumption system of .

One or more managed applications are launched and events are routed to a managed event consumer block that manages the managed applications an example of which is depicted in . As shown in the embodiment of events are provided to a queue of the managed event consumer by the event router which were generated after the events in the queue of the native event consumer . Like before events are also serialized and placed in the queue such that event is consumed by managed application A while event is added after event in the queue . Thus queue may also maintain a serialized order like queue . As depicted in the native application may continue to consume events from the queue while the managed event consumer receives events thus avoiding the delay encountered using traditional event management techniques.

An event that is not capable of being handled by the managed event consumer is communicated to the native event consumer block . For example depicts an exemplary embodiment showing the event consumption system of as communicating an event from a managed event consumer and more particularly the managed application A to the native event consumer . The managed application A for instance may receive an event that is identified as likely to be processed by the native event consumer such as a channel change event in the example of . Therefore in this example the managed application A communicated event to the queue of the native event consumer without communicating it through the event router . As before the native application may still continue consuming events from the queue . Likewise the queue of the managed event consumer may continue to receive the event from the event router . Thus the event consumption system may continue to process events even when events are communicated between event consumers.

A determination is made that a switch is to be performed from the managed event consumer to the native event consumer block . For example the communication of the event from the managed application A to the native event consumer may indicate that the switch is to be made as subsequent events e.g. events are likely to also be incapable of being performed by the managed application A . A variety of other examples are also contemplated such as an out of band indication from an outside source e.g. an application executing outside of the event consumption system as further described in relation to .

In response to this indication to switch events received at the event router are queued after determining that the switch is to be performed block . For example depicts an exemplary embodiment showing the event consumption system of as queuing events during a switch from the managed event consumer to the native event consumer . As before the native application may continue to consume events from the queue of the native event consumer .

Events that were previously queued at the managed event consumer are communicated to the native event consumer block . For example as shown in the exemplary implementation of the managed event consumer may receive a deactivate event which may be obtained from a variety of sources such as outside sources as previously described from the managed application A in response to the event that was not capable of being processed by the managed application A from the native event consumer in response to reception of the event from the managed application A and so on. In this example the deactivate event may also be used by the event router as an indication of when to begin storing the events in the queue . A variety of other examples are also contemplated.

In response to the deactivate event in this example the managed event consumer places a Reset event at the end of the queue to indicate an end to the events stored in the queue of the managed event consumer .

Events that were previously queued at the managed event consumer are sent to the native event consumer block in order to maintain the serialization. In this way the events may be provided in the correct order after events in the queue of the native event consumer . In the illustrated embodiment of the native application continues to consume events thereby reducing and even eliminating downtime that was encountered using traditional techniques.

Events queued at the event router are communicated to the native event consumer when the communicating of the events from the managed event consumer to the native event consumer is completed block . Continuing with the previous example depicts an exemplary embodiment showing the event consumption system of . The managed event consumer and or the managed application A may encounter the Reset event after communicating events to the queue of the native event consumer . In response to encountering this event the managed event consumer may send a notification to the event router to begin streaming events from the queue to the native event consumer . The event router like the managed event consumer may then stream the events to maintain serialization such that the native event consumer receives and correctly places these events after the events received from the managed event consumer in the queue . Thus serialization of the events received by the event consumption system in may be maintained. A variety of other examples are also contemplated without departing from the spirit and scope thereof.

Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed invention.

