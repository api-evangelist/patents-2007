---

title: Systems and methods for graphics hardware design debugging and verification
abstract: Disclosed are systems and methods for debugging and analyzing graphics hardware designs. Hardware designs are represented by a software model implemented in a programming language. Graphics operations can be executed in the software model as well as in reference software models to allow a user to analyze the accuracy of a graphics hardware design and/or a device driver implementation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08146061&OS=08146061&RS=08146061
owner: Via Technologies, Inc.
number: 08146061
owner_city: Taipei
owner_country: TW
publication_date: 20071212
---
The present invention generally relates to graphics hardware and more specifically to systems and methods for debugging and verifying a graphics hardware design using software models representing the hardware design.

Integrated circuit IC design typically involves several stages each using a different tool of suite of tools. An IC designer typically writes code in one of several programming languages. Concurrent with the code writing process is simulation in which the designer runs a simulator tool to test the design using the program code as input. As simulation reveals problems the designer edits the code to fix problems and simulates again. After simulation a synthesizer translates the code into a logical representation of an IC. Other IC tools then transform this logical representation into a physical IC in the form of a Field Programmable Gate Array FPGA Application Specific Integrated Circuit ASIC or custom silicon IC.

Several types of programming languages are available to an IC designer. One family of languages can be described as Hardware Design Languages HDL also known as Register Transfer Languages RTLs . Commonly known RTLs include Verilog and VHDL. RTLs are considered to be low level because they describe hardware specific features such as timing and parallelism. Another choice for IC design includes languages such as C and C and variants thereof that were traditionally used to develop software rather than hardware. These software languages allow the designer to write code at a much higher level of abstraction which can increase designer productivity.

However as many prevalent simulation and synthesis tools use HDL as input rather than C C an IC designer may choose to write code in C C and translate the code into HDL. The translation can be done manually automatically or using a combination of both techniques. Further simulation and synthesis tools using HDL as input often may not offer robust debugging capabilities to allow a hardware designer to easily and effectively debug a hardware design. For example such simulation and synthesis tools typically allow a hardware designer or tester to examine data dumped and extracted from the simulation and synthesis tool but they typically do not allow for more granular or detailed debugging operations and testing of graphics hardware designs.

An embodiment of the present invention may be described as a system for verifying a graphics hardware design. The system may include a script engine configured to translate a script representing graphics functions into commands processed by a software graphics driver. The software graphics driver processes the commands within a graphics processing model. The graphics processing unit model may correspond to a graphics processing unit hardware design and may be configured to generate at least one graphics frame corresponding to graphics functions within the script.

The system may also include a script engine configured to execute the commands within the software graphics driver and the graphics processing model. The script engine can be configured to display the at least one graphics frame and generate debugging information from the graphics processing model. The system may also include a debugger configured to allow for debugging capabilities of the graphics processing model.

Another embodiment may be described as a method of verifying a graphics hardware design. The method may include the step of translating a script representing graphics functions into commands processed by a software graphics driver. The method may also include the step of processing the commands within the software graphics driver and a graphics processing unit model representing a graphics hardware design. The method may also include the step of generating at least one frame corresponding to the graphics functions within the script.

Another embodiment may be described as a computer readable medium having a program for analyzing a graphics hardware design. The embodiment may include logic for translating a script into commands processed by a software graphics driver logic for processing the commands within the software graphics driver and a graphics processing unit model representing the graphics hardware design and logic for generating at least one frame corresponding to graphics functions within the script.

Other systems methods features and or advantages will be or may become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods features and or advantages be included within this description and be protected by the accompanying claims.

Reference is now made in detail to the description of the embodiments as illustrated in the drawings. While several embodiments are described in connection with these drawings there is no intent to limit the disclosure to the embodiment or embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents. Disclosed herein are systems and methods for verifying a graphics hardware design. The systems and methods provide the ability for a graphics hardware designer or tester to perform stepwise execution of applications including graphics operations to analyze and locate potential flaws in a graphics hardware design. Further a user of the disclosed systems and methods may also set breakpoints in a script representing a software application s graphical component to further analyze the graphics hardware design.

A user may also generate and analyze graphics or video frames utilizing at least three execution pathways to further verify and test a graphics hardware design. A user can generate a frame utilizing a reference runtime and a reference rasterizer a reference runtime a reference software device driver and the graphics hardware being tested or a software device driver and the graphics hardware being tested. The at least three testing pathways can allow a user to analyze and test the graphics hardware design as well as a software device driver written to support the graphics hardware. A user may utilize a single script and execute the script utilizing multiple execution pathways simultaneously and analyze resultant video or graphics frames.

Reference is now made to which depicts a functional block diagram of an exemplary system for verifying a graphics hardware design in accordance with embodiments of the invention. The depicted system includes an editor which is an optional component of a system of the disclosure for creating a script used for verifying a graphics hardware design. As an example a user of the system wishing to verify or analyze a graphics hardware design can create a script by hand that includes commands representing graphics operations where the commands are defined by a script language.

Alternatively a script can be created by a script generator . A script generator can log or capture graphics operations from a software application having a graphical component. For example a software application utilizing the exemplary Direct3D or OpenGL graphics application programming interfaces may contain calls to a graphics runtime or graphics application programming interface which can be logged or captured and transformed into commands defined by a script language. In this manner a script representing the graphics operations of a software application such as a game or other application having a graphical component can be transformed into a script which can be utilized within the depicted script engine . Scripts generated by the script generator can be edited with the editor so that a user of the system can add remove or alter the script commands representing graphics operations. For example a user of the system may wish to remove portions of a script generated by the script generator that the user determines are superfluous or unnecessary for the proper evaluation of a graphics hardware design.

Graphics processing hardware receives commands from the software graphics driver to process data and generate frames of graphics or video for display to a screen or other similar output device. Graphics processing hardware designs can vary among manufacturers but typically in conjunction with a software graphics driver are able to execute commands defined by a standardized software application programming interface such as the Direct3D API or OpenGL API.

The script generator can capture or log commands from a software application to generate graphics content or from an application s graphical component. The script generator can convert such commands to commands in a script defined by a script language. As a non limiting example script commands in a script language can be grouped into at least four groups of command types common commands 2D commands 3D commands and video commands. In this non limiting example the command groups have analogues in corresponding API functions of a software graphics API.

For example common commands can include commands that define the version and type of graphics API utilized by the graphics operations the display mode or resolution of the graphical operations color quality or density and other attributes relevant to the generation of a graphics or video frame that should be appreciated by a person of ordinary skill in the art. Further common commands can also include commands defining one or more breakpoints within a script as well as commands directing the script engine to dump debugging information to a file display or other output device. The debugging information can include information relevant to the debugging of a graphics hardware design.

Common commands can also include other additional commands useful for debugging purposes. For example commands to jump to another point in a script may be useful for a user analyzing a hardware design. The usefulness of jump capabilities that maintain or discard the state of the rendering process should also be appreciated. An additional exemplary debugging command can include a command that causes a debugging message to be displayed or stored in a file. This may be useful for a user evaluating a graphics hardware design to alert the user of certain information he wishes to see during the execution of a script or to merely alert the user that a certain portion of the script has been reached. Further commands to clear D Z S buffers can be included. Additionally a command that displays the rendered graphics or video frame or flips the frame can be included in the script language. It should be appreciated by a person of ordinary skill in the art that a D buffer is a buffer containing information pertaining to render target for color data. It is also referred to in the art as a destination buffer. It should also be appreciated that a Z buffer refers to a depth buffer where depth information of each pixel is stored. It should further be appreciated that an S buffer refers to a stencil buffer where a stencil value of each pixel is stored. These buffers are the major memory locations of a 3D rendering result. Additionally script commands enabling the programming of low level hardware registers in a graphics processing unit can provide control of detailed functions inside a GPU or a model representing a GPU.

2D commands 3D commands and video commands can include those commands that have analogues within a particular graphics application programming interface such as the Direct3D API or OpenGL API. It should be appreciated that the above mentioned commands may vary depending on the particular graphics API utilized by the software application or the graphics hardware design utilized by the script engine however those of ordinary skill in the art and with knowledge of graphics API s should recognize these potential variations.

Reference will now return to the functional block diagram of . As previously noted the depicted system utilizes a script that can be created by either an editor or a script generator . The script contains commands corresponding to graphics operations that are defined by a script language. The script can be executed by a script engine which can offer a user of the system various alternative execution pathways for the verification and analysis of a graphics hardware design. The various execution pathways can allow a user to utilize the graphics hardware design that the user is testing as well as reference systems in order to generate frames of graphics or video for comparison. The script engine interprets a script from commands representing graphical operations defined by a script language to commands executed by the script engine to generate graphics frames as well as allow a user of the system to analyze and debug a graphics hardware design utilized for the generation of the frames.

The script engine can also include a user interface to allow a user to visually interact with and or control the script engine via a keyboard mouse or other input device as well as a display or other output device. The user interface also allows the script engine to display the results of at least one of the execution pathways to the user. The user interface can further allow a user to compare the results of at least two execution pathways in analyzing a graphics hardware design.

The depicted system may further include a script engine interface that allows the script engine to execute a script represented in a script language within a graphics hardware design via a graphics device driver . In other words the script engine interface can translate script commands to a format that can be processed by a device driver as translation may be required from the script containing commands defined by a script language to device driver calls and subsequent calls within a graphics processing unit or a model representing a graphics processing unit. The implementation of the script engine interface may vary depending on the device driver and graphics processing unit model utilized with the depicted system as the system can be configured to execute a script with varying device drivers and models according to their communications protocols.

The depicted system may include a graphics processing unit model . The graphics processing unit model may be a software model representing a hardware design of a graphics processing unit which may allow a designer or tester to analyze and verify a particular hardware design without producing a physical GPU unit for testing. As noted above hardware designers may create a graphics hardware design using a hardware description language. It should be appreciated that a hardware design represented in a hardware description language can be translated into a model of the design utilizing a programming language such as C or other similar languages allowing a designer to create working software models of a hardware design. Such models can be utilized within the framework of the depicted system to create a working graphics system that can generate graphics or video frames for testing and verification purposes.

For example it is known that the logic gates described by an HDL design can be translated into a language such as C to create a model of the hardware design that can be utilized for modeling and testing purposes. Such models can be known in the art as C models to describe the programming language used to create a usable model of the graphics hardware design. It is further known that device drivers are typically software components that facilitate communication between an operating system s graphics subsystem and graphics hardware. In the depicted system the device driver may also be analyzed and verified by interacting with the script engine interface and the graphics processing unit model .

Because the graphics processing unit model simulates a functioning hardware graphics processing unit it can generate graphics or video frames or GPU images that can be displayed to a user via the user interface . In other words the graphics processing unit model can generate a GPU image representing the commands in the script and executed by the script engine in the graphics processing unit model via the script engine interface and device driver . The GPU image can be analyzed by a user of the depicted system via the user interface or through the use of other tools. Further the user interface can be configured to zoom and analyze in further detail certain aspects of the generated image. A user of the depicted system can analyze the generated GPU image to test or verify a graphics hardware design represented by the graphics processing unit model that is translated from an HDL design.

Further because the graphics processing unit model is represented in a programming language such as C a person of ordinary skill in the art would appreciate that trace information or other debugging data can be generated during the execution of a script and captured for analysis. In particular data revealing the utilization of data within certain components of a hardware design can be captured and analyzed during the testing and verification of a design that may prove useful for debugging purposes. In addition a user of the system may elect to display certain trace information via the user interface .

The depicted system includes a reference runtime which communicates with the script engine and receives commands from the script engine for the processing of script commands. A user of the depicted system may elect to execute a script utilizing a reference runtime which can include as a non limiting example a software vendor provided runtime such as the Direct3D runtime. The system further includes a reference driver which is a reference software driver that can be created as a prototype of a production graphics driver.

It should be appreciated that a reference driver can be created to act as an interface between an application and a model representing a hardware design and to also verify features defined in a graphics specification. Additionally a reference driver may provide a baseline for performance analysis or profile a performance target for a graphics hardware design. The reference driver can communicate with the graphics processing unit model and cause the model to generate reference driver images or reference driver frames which correspond to commands in the script and generated by the graphics processing unit model under the direction of the script engine reference runtime and reference driver . In this way a user of the system may analyze and verify the design of a device driver by utilizing a reference driver to generate video or graphics frames with the same hardware design.

A user may also analyze trace information generated as a result of the generated reference driver image as well as cause the image and trace information to be displayed via the user interface . The user may also compare the reference driver image and GPU image as well as zoom rotate or otherwise manipulate both images via the user interface to test and verify the design of a device driver and graphics hardware design by analyzing images generated by the system.

The depicted system also includes a reference rasterizer that can render video or audio frames or render a reference image based on commands in the script and communicated to the reference rasterizer via the reference runtime . The reference rasterizer can be provided by a software vendor or creator of a graphics application programming interface such as the Direct3D or OpenGL graphics API s as a reference tool for graphics hardware designers. A reference rasterizer can also be created independently as a reference implementation of functions of a graphics API. The reference rasterizer is typically a tool implemented in software to simulate a reference hardware implementation but typically does not possess the necessary performance characteristics desired in the market nor does it translate into an implementable hardware design. The reference rasterizer can generate a reference image based on commands in the script and communicated via the reference runtime . A user may wish to view the reference image via the user interface or compare the reference image to the reference driver image or GPU image to analyze and verify a hardware design or device driver implementation.

The depicted system offers at least three execution pathways for the execution of a script. The various execution pathways may be chosen by a user via the user interface or by commands embedded in a script. The various execution pathways may be executed in parallel so that a user may compare generated images side by side via a user interface or by analyzing trace information. Reference is now made to which depicts a functional block diagram of a system of the disclosure with one of the possible execution pathways highlighted. The highlighted execution pathway is one example of an iteration of the depicted system s execution. It should be appreciated that multiple iterations of the execution pathway may be desirable to analyze test or verify a graphics hardware design represented by the graphics processing unit model.

The highlighted execution pathway illustrates a pathway for the depicted system to execute a script via the script engine within a device driver and a graphics processing unit model representing a hardware design that the user of the system may wish to analyze or verify. As noted above hardware designs are typically conceived in an HDL and often in a higher level programming language such as C. Designs represented in an HDL can typically be translated into a higher language such as C. Such a representation of the hardware design can be utilized within the system as the graphics processing unit model. A user of the system may also wish to test or analyze the design of a device driver written to assist a computer operating system s interaction with graphics hardware.

The highlighted execution pathway illustrates a pathway including a device driver and a hardware design embodied in the GPU model that can be evaluated and tested. Trace information can also be generated for further analysis of various aspects of the model and device driver. The highlighted image is generated as a result of an iteration of the system executing a script within the script engine interface the device driver and the graphics processing unit model representing a hardware design of a graphics processing hardware system. The image generated by the system can represent a graphics or video frame and can be analyzed zoomed and manipulated by a user via the user interface so that the user may analyze verify or debug a graphics hardware design represented by the graphics processing unit model . The system may also complete multiple iterations of the generation of images to create moving graphics and video for analysis by the user of the system via the user interface .

Reference is now made to which illustrates an alternative execution pathway of the depicted system. The highlighted execution pathway offers a user of the system the ability to generate a reference driver image which represents a graphics or video frame generated using a reference device driver in combination with the graphics processing unit model representing a hardware design. In this way the user of the system may verify or analyze the device driver by comparing images generated utilizing the device driver as well as the reference device driver . As noted above the reference device driver may be created by a software vendor providing a graphics API such as the Direct3D API or by a third party implementing a driver that operates according to a reference specification that may not take advantage of a hardware design as efficiently as a hardware specific device driver developed by a hardware vendor.

The reference driver image generated as a result of an iteration of the system may be compared to an image generated as a result of the execution pathway of via the user interface . For example the reference driver image and image can be zoomed rotated or otherwise manipulated so that a user may analyze the accuracy of each generate generated image. Further analysis may be undertaken on the generated images to verify and analyze a hardware design as well as a software device driver design and implementation. The highlighted execution pathway allows a user of the system to analyze a hardware design represented by the graphics processing unit model by executing a script utilizing a reference driver as well as a device driver developed for use and or distribution with graphics hardware produced in accordance with the design being tested.

Reference is now made to which illustrates an additional alternative execution pathway of the depicted system. The highlighted execution pathway allows a user to generate a reference image utilizing a reference runtime . As noted above it should be appreciated that the reference runtime can represent a runtime provided by a software vendor providing a graphics API such as the Direct3D API. The reference runtime may then communicate with a reference rasterizer which can generate frames of video or graphics in the form of a reference image. It should also be appreciated that as noted above the reference rasterizer can be implemented to perform graphics operations according to a graphics API to provide a reference or baseline for comparison purposes to assist in the ensuring of the accuracy of a hardware design or a software device driver.

The reference image represents a video or graphics frame generated utilizing only reference implementations of a graphics API and a reference rasterizer representing reference graphics hardware. The reference image can be compared to a reference driver image or an image via the user interface which can be useful for a user of the system to evaluate a device driver or a hardware design represented by the graphics processing unit model . For example the reference image can be zoomed rotated or otherwise manipulated within the user interface as well as compared to a reference driver image or an image to assist a user in verifying and analyzing a graphics hardware design.

Reference is now made to which illustrates an embodiment of the disclosure that includes a debugger providing additional functionality for a user of the system. The debugger can offer debugging capabilities that allow a user of the depicted system to further interact with or control the execution of a script within the script engine . For example the debugger can interact with the script engine to offer control over the execution of a script to a user of the system. For example the debugger can allow a user to perform stepwise execution of the script while highlighting or otherwise denoting a current location in the script during execution via the user interface . It should be appreciated that although not specifically illustrated in the other figures the similar debugger may be included and interfaced with the script engine of the other illustrated embodiments.

Further via the user interface a user may control stepwise execution of the script via the user interface . A user may choose to continue uninterrupted execution of the script or continue stepwise execution of the script in his or her analysis of the script as well as hardware designs or device drivers utilized by the script . For example if a script utilizing the graphics processing unit model or device driver causes frames not conforming to an expected result a user may utilize the debugger to determine which script commands if any cause such a failure. In this way a user may better understand which parts if any of a hardware design or device driver cause the failure.

Further the debugger via the user interface can allow a user to place or set breakpoints within a script . It should be appreciated that a breakpoint allows a user to cause a script executed within the script engine to pause or stop when a breakpoint within a script is reached. Breakpoint functionality can be useful in the analysis of a hardware design represented by a graphics processing unit model or a device driver utilized within a particular chosen execution pathway. Further the debugger may present trace information generated by the graphics processing unit model to the user via the user interface . Trace information can include data being input to the graphics processing unit model as well as data generated by the model. The debugger and or user interface can present the trace information and allow for advanced functionality such as sorting searching variable tracking variable manipulation and other debugging functionality that should be appreciated. It should further be appreciated that stepwise execution of a script breakpoints and views into the trace information offered to a user of the system by the debugger and user interface can allow a user to analyze or verify designs of a graphics processing unit with greater granularity relative to building a hardware GPU and testing it using methods known in the art.

Reference is now made to which depicts a flowchart of a method according to the disclosure. In step graphics operations in a software application are captured in order to generate a script in an automated way. For example a software application may make requests to a graphics API within an operating system in order to generate frames of graphics or video. These requests can be captured in order to generate a script processed by a script engine as described above. In step the captured graphics operations are translated into a script containing script commands defined by a script language. As a non limiting example script commands can be separated into four categories common commands 2D commands 3D commands and video commands. In step a script is generated from the captured graphics commands. The script includes script commands defined by a script language as noted above. The script includes commands that correspond to the graphics operations captured from a software application including a graphical component. For example a series of graphical operations within a software application for drawing 3D objects can be captured and represented by a script that may be executed within various execution pathways. Or alternatively a script including script commands for generating graphics or video frames can be manually created by a user.

In step an execution pathway in which to execute the script is determined. As noted above in reference to the embodiment of multiple execution pathways are available for a user of systems and methods of the disclosure for the analysis and verification of a hardware design and or device driver implementation. For example a user may choose to execute a script within the execution pathway beginning with step which includes the translation of the script . The commands defined by a script language located within the script are translated into a format that can be processed by a software device driver . As noted above a script contains script commands defined by a script language which may not be in a format that is understandable by a device driver. Therefore the script commands are translated into a format typically generated by a operating system s graphical calls made in response to functions executed within a graphics API such as the Direct3D or OpenGL graphics API s.

In step the commands are processed with software graphics driver or a device driver . As is known a device driver is a software component allowing an operating system or other software application to interface with a hardware component such as a graphics process unit which may or may not have standardized communications protocols known by the operating system used for interfacing with the hardware component and executing operations within the component. In step the commands processed by the software graphics driver are executed within a graphics processing unit model. As noted above a graphics processing unit model can be a software model of a graphics hardware design that allows a user analyzing or verifying a hardware design to interact with a software model rather than a hardware prototype or hardware GPU. It should be appreciated that such a model can be implemented in C or other programming languages by translating a hardware design written in a hardware description language HDL into a high level programming language such as C. Alternatively some hardware designers implement hardware designs in a language such as C and no translation is necessary. It should further be appreciated that utilizing such C models allow for the creation of working software models of a hardware design. They allow for easier manipulation of the model relative to a hardware design represented by a HDL when for example implementing debugging functionality is desired. Manipulating a model represented in a high level programming language for testing and analysis purposes is far easier relative to a model represented by a HDL because of the flexibility the high level programming language offers.

In step a graphics or video frame is generated by the graphics processing unit model representing the commands in the script processed by the software driver and executed by the graphics processing unit model. The generated graphics or video frame can be analyzed to evaluate a hardware design represented by the graphics processing unit model via a user interface or other methods appreciated by a person of ordinary skill in the art. For example a user may analyze whether the generated frame is consistent with an expected result from the script executed by a script engine . A user may examine or manipulate the generated frame via a user interface or compare the generated frame to a frame generated from an alternative execution pathway.

Step depicts the beginning of an alternative execution pathway from the step of determining an execution pathway. The depicted pathway differs from the above noted pathway in that the commands translated from the script in step are processed within a reference runtime in step . Subsequently the commands are processed within a reference software driver in step . As noted above in reference to embodiments disclosed above a reference software driver can be a software driver that may not necessarily take full advantage of a hardware design but is implemented according to a reference graphics API such as the Direct3D or OpenGL graphics API s. In step the commands processed by the reference software driver are executed within a graphics processing unit model representing a hardware design. This execution pathway can allow a user to execute a script utilizing a graphics processing unit model and a reference software driver expanding the testing and analysis possibilities for a user. A graphics or video frame is generated in step from the commands in the script processed by the reference software driver and executed by the graphics processing unit model. Further a user may compare frames generated in step to frames generated in step to analyze or verify a hardware design represented by the graphics processing unit model or the implementation of a software driver or device driver.

Step depicts yet another alternative execution pathway available to a user for the testing or analysis of a graphics hardware design. This execution pathway allows a user to process commands of a script within a reference runtime step and execute the commands within a reference rasterizer step . As noted above a reference runtime is a software component known in the art and typically provided by a software graphics API provider or implemented according to a reference specification. The commands processed by the reference runtime are executed within a reference rasterizer in step . As noted above in reference to above disclosed embodiments the reference rasterizer can generate video or graphics frames in step . A reference rasterizer as is known in the art is a software implementation of a reference graphics processing unit according to a graphics API such as the Direct3D API that can be used to generate graphics or video frames according to a reference specification. Hardware vendors may use a reference rasterizer during the development of hardware as a baseline to which hardware designs and implementations can be compared for accuracy. This alternative execution pathway allows a user to compare frames generated in step to frames generated in other execution pathways to analyze and verify hardware designs represented by a graphics processing unit model as well as software driver implementations.

Reference is now made to which depicts a system for graphics hardware design debugging and verification including a computer system having a display and user input device which may be a keyboard or a mouse for example. Computer system may also form a node on a network such as but not limited to a LAN or a WAN. In this configuration scripts or graphics operations used for generating a script may be delivered from a remote server over network to computer system . The connection between the remote server and computer system may be any number of physical networking interfaces such as a CAT 5 Firewire 802.11 wireless as well as other connections. Computer system may also include optical drive to receive and read an optical disk which may have scripts or software applications having graphics operations for the generating of a script stored thereon.

Computer system includes memory which may be used to store a number of executable modules therein. In this embodiment a script translation module script processing module and frame generating module are stored therein. Memory may include a number of other modules which for example could be sub modules of script translation module script processing module and frame generating module .

Script translation module may translate a script containing graphical operations into a format that can be transmitted to a software driver or device driver configured to interact with graphics hardware or a software model representing a graphics hardware design. As noted above a device driver can be a software component configured to facilitate communication between an operating system or other software application and a hardware component such as a hardware graphics processing unit. The script translation module may operate differently depending on whether a script will be executed within a device driver a reference driver a reference runtime or other software components that interact with hardware or software models representing a hardware design or specification. For example if graphical operations represented by a script are to be processed within a device driver the script translation module will translate script commands into a format for the device driver. Alternatively if graphical operations represented by a script are to be processed within a reference runtime the script translation module will translate script commands into a format for the reference runtime.

Script processing module can execute a script by causing translated script commands to be executed within a software driver or device driver. Script processing module controls the execution of a script and can include debugging functionality to allow a user to utilize stepwise execution of the script as well as breakpoint functionality. For example a user may set a breakpoint within a script and script processing module may pause execution of the script at the set breakpoint allowing a user to examine various data regarding script execution and continue execution of the script should the user desire.

Frame generating module may generate graphics or video frames according to an execution pathway chosen by a user. Frame generating module can contain at least three execution pathways which are discussed above in reference to above disclosed embodiments. For example frame generating module can contain a test execution pathway that utilizes a software driver or device driver and a software model representing a hardware design a reference driver execution pathway that utilizes a reference device driver and the software model representing a hardware design and a reference execution pathway utilizing a reference runtime and a reference rasterizer. These at least three execution pathways within the frame generating module allow a user to analyze a hardware design represented by a software model as well as a software driver or device driver implementation. Frame generating module may allow one or more execution pathways to be utilized in parallel so that a user may execute the same or similar script utilizing multiple execution pathways to compare generated frames resulting from the script execution. For example a user may utilize the test execution pathway and the reference execution pathway in parallel to evaluate whether the hardware design and software driver implementation are producing desired results relative to frames generated by the reference execution pathway.

Note that in some embodiments script translation module script processing module and frame generating module may be combined into a single module that performs any combination of the tasks performed by each of the modules separately. Thus any modules or submodules described herein are not limited to existing as separate modules. In reality all modules may operate apart from one another or could easily be combined as one module. In some embodiments a user may interact and control the operation of script translation module script processing module and frame generating module through user input device and a graphical user interface within display .

Each of the script translation module script processing module and frame generating module and any sub modules may comprise an ordered listing of executable instructions for implementing logical functions. When script translation module script processing module and frame generating module and any sub modules are implemented in software it should be noted that the system can be stored on any computer readable medium for use by or in connection with any computer related system or method. In the context of this document a computer readable medium is an electronic magnetic optical or other physical device or means that can contain or store a computer program for use by or in connection with a computer related system or method. Script translation module script processing module and frame generating module and any sub modules can be embodied in any computer readable medium for use by or in connection with an instruction execution system apparatus or device such as a computer based system processor containing system or other system that can fetch the instructions from the instruction execution system apparatus or device and execute the instructions.

In the context of this document a computer readable medium can be any means that can store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer readable medium can be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a nonexhaustive list of the computer readable medium would include the following an electrical connection electronic having one or more wires a portable computer diskette magnetic a random access memory RAM electronic a read only memory ROM electronic an erasable programmable read only memory EPROM EEPROM or Flash memory electronic an optical fiber optical and a portable compact disc read only memory CDROM optical .

Processing device can include any custom made or commercially available processor a central processing unit CPU or an auxiliary processor among several processors associated with the computer system a semiconductor based microprocessor in the form of a microchip a macroprocessor one or more application specific integrated circuits ASICs a plurality of suitably configured digital logic gates and other well known electrical configurations comprising discrete elements both individually and in various combinations to coordinate the overall operation of the computing system.

The memory can include any one of a combination of volatile memory elements e.g. random access memory RAM such as DRAM and SRAM etc. and nonvolatile memory elements e.g. ROM hard drive tape CDROM etc. . The memory typically comprises a native operating system one or more native applications emulation systems or emulated applications for any of a variety of operating systems and or emulated hardware platforms emulated operating systems etc. For example the applications may include application specific software which may include any of the script translation module script processing module and frame generating module . One of ordinary skill in the art will appreciate that memory can and typically will comprise other components which have been omitted for purposes of brevity.

Input output interfaces provide any number of interfaces for the input and output of data. For example where the computer system comprises a personal computer these components may interface with user input device which may be a keyboard or a mouse. Where the computer system comprises a handheld device e.g. PDA mobile telephone these components may interface with function keys or buttons a touch sensitive screen a stylist etc. Display can comprise a computer monitor or a plasma screen for a PC or a liquid crystal display LCD on a hand held device for example.

With further reference to network interface device comprises various components used to transmit and or receive data over network . By way of example the network interface device may include a device that can communicate with both inputs and outputs for instance a modulator demodulator e.g. a modem wireless e.g. radio frequency RF transceiver a telephonic interface a bridge a router network card etc. 

Accordingly the above embodiments are merely examples of the many possible ways to perform graphics hardware design debugging and verification. It should be emphasized that many variations and modifications may be made to the above described embodiments. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

