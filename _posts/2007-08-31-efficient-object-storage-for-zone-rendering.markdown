---

title: Efficient object storage for zone rendering
abstract: Similar, contiguous primitives are stored as a single primitive in zone rendering bins. A primitive packet used in the bin is allowed to vary in length and the currently open type of primitive is recorded on a per-bin basis. A special code is used to specify a variable number of subsequent indices. With this mechanism, the hardware is able to start outputting and replicating primitive commands into bin lists on the fly without requiring the buffering of the entire primitive. Given the variable nature of the primitive instruction, multiple similar/sequential primitives can be concatenated using a single primitive command header.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07791601&OS=07791601&RS=07791601
owner: 
number: 07791601
owner_city: 
owner_country: 
publication_date: 20070831
---
This application is a continuation of U.S. patent application Ser. No. 10 848 018 filed on May 17 2004 issued as U.S. Pat. No. 7 298 371 on Nov. 20 2007 in the name of Peter L. Doyle entitled EFFICIENT OBJECT STORAGE FOR ZONE RENDERING which is a continuation of Ser. No. 10 039 006 filed Dec. 31 2001 now U.S. Pat. No. 6 747 653 issued Jun. 8 2004 in the name of Peter L. Doyle entitled EFFICIENT OBJECT STORAGE FOR ZONE RENDERING.

The present invention relates generally to graphics systems and more particularly to graphics rendering systems.

Computer graphics systems are commonly used for displaying graphical representations of objects on a two dimensional video display screen. Current computer graphics systems provide highly detailed representations and are used in a variety of applications. In typical computer graphics systems an object to be represented on the display screen is broken down into graphics primitives. Primitives are basic components of a graphics display and may include points lines vectors and polygons such as triangles and quadrilaterals. Typically a hardware software scheme is implemented to render or draw the graphics primitives that represent a view of one or more objects being represented on the display screen.

The primitives of the three dimensional objects to be rendered are defined by a host computer in terms of primitive data. For example when the primitive is a triangle the host computer may define the primitive in terms of X Y and Z coordinates of its vertices as well as the red green and blue R G and B color values of each vertex. Additional primitive data may be used in specific applications.

Image rendering is the conversion of a high level object based description into a graphical image for display on some display device. For example an act of image rendering occurs during the conversion of a mathematical model of a three dimensional object or scene into a bitmap image. Another example of image rendering is converting an HTML document into an image for display on a computer monitor. Typically a hardware device referred to as a graphics rendering engine performs these graphics processing tasks. Graphics rendering engines typically render scenes into a buffer that is subsequently output to the graphical output device but it is possible for some rendering engines to write their two dimensional output directly to the output device. The graphics rendering engine interpolates the primitive data to compute the display screen pixels that represent the each primitive and the R G and B color values of each pixel.

A graphics rendering system or subsystem as used herein refers to all of the levels of processing between an application program and a graphical output device. A graphics engine can provide for one or more modes of rendering including zone rendering. Zone rendering attempts to increase overall 3D rendering performance by gaining optimal render cache utilization thereby reducing pixel color and depth memory read write bottlenecks. In zone rendering a screen is subdivided into an array of zones and per zone instruction bins used to hold all of the primitive and state setting instructions required to render each sub image are generated. Whenever a primitive intersects or possibly intersects a zone that primitive instruction is placed in the bin for that zone. Some primitives will intersect more than one zone in which case the primitive instruction is replicated in the corresponding bins. This process is continued until the entire scene is sorted into the bins. Following the first pass of building a bin for each zone intersected by a primitive a second zone by zone rendering pass is performed. In particular the bins for all the zones are rendered to generate the final image.

Conventionally the storage of 3D primitive instruction in a bin is formatted as follows a one 32 bit header describing the type of primitive and an explicit count of vertex indices followed by a series of 16 bit vertex indices with a possible trailing 16 bit pad to ensure 32 bit alignment in the bin . The explicit count in the header required knowledge of the size i.e. number of indices of the primitive at the time the primitive instruction is generated. The 32 bit header contributes to the bin list bandwidth and footprint requirements of zone rendering.

Embodiments of the present invention provide for efficient object storage for zone rendering. In particular similar contiguous primitives to be stored as a single primitive in the zone rendering bins. To enable this the primitive packet used in the bin is allowed to vary in length and the currently open type of primitive is recorded on a per bin basis.

In the detailed description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be understood by those skilled in the art that the present invention maybe practiced without these specific details. In other instances well known methods procedures components and circuits have been described in detail so as not to obscure the present invention.

Some portions of the detailed description that follow are presented in terms of algorithms and symbolic representations of operations on data bits or binary signals within a computer. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to convey the substance of their work to others skilled in the art. An algorithm is here and generally considered to be a self consistent sequence of steps leading to a desired result. The steps include physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. It should be understood however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the specification discussions utilizing such terms as processing or computing or calculating or determining or the like refer to the action and processes of a computer or computing system or similar electronic computing device that manipulate and transform data represented as physical electronic quantities within the computing system s registers and or memories into other data similarly represented as physical quantities within the computing system s memories registers or other such information storage transmission or display devices.

Embodiments of the present invention may be implemented in hardware or software or a combination of both. However embodiments of the invention may be implemented as computer programs executing on programmable systems comprising at least one processor a data storage system including volatile and non volatile memory and or storage elements at least one input device and at least one output device. Program code may be applied to input data to perform the functions described herein and generate output information. The output information may be applied to one or more output devices in known fashion. For purposes of this application a processing system includes any system that has a processor such as for example a digital signal processor DSP a micro controller an application specific integrated circuit ASIC or a microprocessor.

The programs may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The programs may also be implemented in assembly or machine language if desired. In fact the invention is not limited in scope to any particular programming language. In any case the language may be a compiled or interpreted language.

The programs may be stored on a storage media or device e.g. hard disk drive floppy disk drive read only memory ROM CD ROM device flash memory device digital versatile disk DVD or other storage device readable by a general or special purpose programmable processing system for configuring and operating the processing system when the storage media or device is read by the processing system to perform the procedures described herein. Embodiments of the invention may also be considered to be implemented as a machine readable storage medium configured for use with a processing system where the storage medium so configured causes the processing system to operate in a specific and predefined manner to perform the functions described herein.

An example of one such type of processing system is shown in . Sample system may be used for example to execute the processing for methods in accordance with the present invention such as the embodiment described herein. Sample system is representative of processing systems based on the microprocessors available from Intel Corporation although other systems including personal computers PCs having other microprocessors engineering workstations set top boxes and the like may also be used. In one embodiment sample system may be executing a version of the WINDOWS operating system available from Microsoft Corporation although other operating systems and graphical user interfaces for example may also be used.

Processor issues signals over common bus for communicating with memory or graphics and memory controller in order to manipulate data as described herein. Processor issues such signals in response to software instructions that it obtains from memory . Memory may be a dynamic random access memory DRAM device a static random access memory SRAM device or other memory device. Memory may store instructions and or data represented by data signals that may be executed by processor graphics device or some other device. The instructions and or data may comprise code for performing any and or all of the techniques of the present invention. Memory may also contain software and or data. An optional cache memory may be used to speed up memory accesses by the graphics device by taking advantage of its locality of access. In some embodiments graphics device can offload from processor many of the memory intensive tasks required for rendering an image. Graphics device processes data signals and may be a complex instruction set computer CISC microprocessor a reduced instruction set computing RISC microprocessor a very long instruction word VLIW microprocessor a process implementing a combination of instruction sets or other processor device such as a digital signal processor for example. Graphics device may be coupled to common bus that transmits data signals between graphics device and other components in the system including render cache and display device . Graphics device includes rendering hardware that among other things writes specific attributes e.g. colors to specific pixels of display and draw complicated primitives on display device . Graphics and memory controller communicates with display device for displaying images rendered or otherwise processed by a graphics controller . Display device may comprise a computer monitor television set flat panel display or other suitable display device.

Memory stores a host operating system that may include one or more rendering programs to build the images of graphics primitives for display. System includes graphics device such as a graphics accelerator that uses customized hardware logic device or a co processor to improve the performance of rendering at least some portion of the graphics primitives otherwise handled by host rendering programs. The host operating system program and its host graphics application program interface API control the graphics device through a driver program.

When a primitive intersects a zone the corresponding primitive instruction is placed in the bin associated with the zone intersected. Per zone instruction bins are thus used to hold primitive instructions and state setting instructions required to render each sub image and are generated by comparing the screen space extent of each primitive to the array of zones . Thus as the primitives are received the present invention determines which zone s each primitive intersects and replicates the primitive instructions into a bin associated with each of these zones .

The process of assigning primitives and their attributes to zones is referred to as binning. Bin refers to the abstract buffer used for each zone where a bin will typically be realized as a series of instruction batch buffers . Binning performs the necessary computations to determine what primitives lie in what zones and can be performed by dedicated hardware and or software implementations.

In one typical implementation a driver writes out a set of primitive instructions to be parsed by the graphics binning engine . In particular the information necessary for primitive binning is stored in vertex buffers which includes first buffer and second buffer . As discussed in detail below first buffer stores vertex X and Y data while second buffer contains the remainder of the vertex data. For each zone intersected by a primitive the graphics binning engine writes corresponding primitive instructions into buffers associated with the zones intersected. Given the split vertex buffers and graphics binning engine is now permitted to read and cache only vertex screen X and Y data from first buffer . Some primitives will intersect more than one zone in which case the primitive instruction is replicated in bins corresponding to the intersected zones . For example the lightning bolt depicted in intersects nine zones . This process is continued until the entire scene is sorted into bins .

Referring to in a typical implementation a graphics primitive and state setting instruction stream referred to as a scene input list is initially applied to graphics binning engine ring buffer associated with graphics binning engine . The scene input list may be a single temporally ordered scene description as received by the application programming interface API . Graphics binning engine is typically implemented as a hardware binning engine HWB . One skilled in the art will recognize that a software or software plus hardware binner could be used as well. The graphics binning engine parses scene input list and determines which zone s each primitive intersects.

As previously noted the zones are associated with bins . Graphics binning engine compares the screen space extent of each primitive to the array of zones and replicates the associated primitive commands into corresponding bins . Bins are comprised of chained series of command buffers typically stored within non contiguous physical memory pages. A bin list is a list of buffers which comprise each bin . Pages are initially allocated to the bin memory pool BMP . The bin pointer list is initialized with the page numbers of the pages and stores write pointers into each bin list .

The graphics binning engine also maintains the current graphics state by parsing associated state setting instructions contained with the scene input list . Prior to placing a primitive command in any given bin the graphics binning engine typically precedes the primitive command in the bin with any required state setting instructions.

After the scene input list has been completely parsed the associated bins i.e. bin 0 bin 1 . . . bin n 1 are ready to be used by the graphics rendering engine to render the scene. As discussed in detail below instructions are included at the end of the scene input list to cause the graphics binning engine to increment the register in pending scene counter by one and initiate rendering of the binned scene. For example graphics binning engine sends a render instruction to graphics rendering engine ring buffer associated with graphics rendering engine via path .

Once all the primitives are sorted and the command structures completed a second pass is made to render the scene one zone at a time. Following the first pass of building a bin for each zone intersected by a primitive a second zone by zone rendering pass is performed. In particular the bins for all the zones are rendered to generate the final image with each scene rendered one zone at a time. The order with which the zones are rendered is typically not significant. All bins associated with primitives that touch pixels within a particular zone are rendered before the next zone is rendered. A single primitive may intersect many zones thus requiring multiple replications. As a result primitives that intersect multiple zones are rendered multiple times i.e. once for each zone intersected .

Rendering performance improves as a result of the primitives being sorted by their intersection with zones that are aligned to the render cache . Since the graphics device is only working on a small portion of the screen at a time i.e. a zone it is able to hold the frame buffer contents for the entire zone in a render cache . The dimensions of the zone are typically a constant tuned to the size and organization of the render cache . It is by this mechanism that the render cache provides optimal benefits reuse of cached data is maximized by exploiting the spatial coherence of a zone . Through use of the zone rendering mode only the minimum number of color memory writes need be performed to generate the final image one zone at a time and color memory reads and depth memory reads and writes can be minimized or avoided altogether. Use of the render cache thus significantly reduces the memory traffic and improves performance relative to a conventional renderer that draws each primitive completely before continuing to the next primitive.

The requirement for an explicit vertex count in the object instruction header is eliminated. Instead a special code is used to specify a variable number of subsequent indices. A special index value of 0xFFFF is reserved to terminate the vertex index sequence. With this mechanism the hardware is able to start outputting and possibly replicating primitive commands into bin lists on the fly without requiring the buffering of the entire primitive. Given the variable nature of the primitive instruction multiple similar sequential primitives can be concatenated using a single primitive command header. This reduces the bandwidth and footprint overhead caused by separate primitive instruction headers.

While the present invention has been described with respect to a limited number of embodiments those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention.

