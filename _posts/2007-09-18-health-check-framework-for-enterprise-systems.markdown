---

title: Health check framework for enterprise systems
abstract: A health check framework for enterprise systems is described herein. In one embodiment, a health check framework includes one or more first layer methods as public interfaces to allow an application client to initiate one or more stages of a health checking session, where the first layer methods are independent of a particular component of the enterprise system. The health check framework further includes one or more second layer methods to provide an abstract interface to the one or more system and/or application components with respect to the one or more first layer methods. The second layer methods include one or more methods that are specific to a corresponding one of the system and/or application components of the enterprise system. During a health check session, the first layer methods invoke the second layer methods to perform health check operations. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07954014&OS=07954014&RS=07954014
owner: SAP AG
number: 07954014
owner_city: Walldorf
owner_country: DE
publication_date: 20070918
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates generally to enterprise computing. More particularly this invention relates to a health check framework for enterprise systems.

Conventional IT information technology systems require considerable time effort knowledge and experience in order to implement monitor and operate on a day to day basis. Even large IT departments often become lost in a maze of complex tools and technologies and thousands of pages of administration guides that are usually necessary to operate and maintain the components of such IT systems. Moreover IT departments in particular IT administrators are overwhelmed with various day to day reactive support tasks and often have limited resources and operating budgets to handle those support tasks which typically include normal system management activities such as manually monitoring checking and clearing log files performing patches and updates executing backup and recovery procedures and user management and managing and assisting end users such as processing service requests and supporting end users having trouble with the customer s systems.

The task of manually monitoring each component of the IT system to ensure the health of the system is particularly difficult for many IT departments. Not only is this task time consuming but also it requires significant IT resources to complete. Moreover the practice of manually monitoring the system can be complicated and error prone. Further there has been a lack of efficient ways for developing and or maintaining functionalities of monitoring components of the IT system.

A health check framework for enterprise systems is described herein. In one embodiment a health check framework includes one or more first layer methods as public interfaces to allow an application client to initiate one or more stages of a health checking session where the first layer methods are independent of a particular component of the enterprise system. The health check framework further includes one or more second layer methods to provide an abstract interface to the one or more system and or application components with respect to the one or more first layer methods. The second layer methods include one or more methods that are specific to a corresponding one of the system and or application components of the enterprise system. In response to a health check session initiated from the application client the first layer methods invoke the second layer methods to collect data from the one or more system and or application components to evaluate the collected data and to issue a status report concerning the operating health of the one or more system and or application components of the enterprise system.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

A health check framework for enterprise systems is described herein. In the following description numerous details are set forth to provide a more thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to certain embodiments of the invention a health framework is provided to allow a health check client to initiate and perform a health check session on the health of system and or application components of an enterprise system such as for example an enterprise resource planning ERP system. The health check framework includes one or more public interfaces or methods to allow the health check client to invoke the health check framework which may be scheduled periodically or on demand. The public methods are independent of system and application components being monitored. The public methods then invoke another layer e.g. lower layer of methods which are used to performed detailed specific health check operations where this layer of methods provides abstract interfaces to the system and or application components from the public interfaces. These methods of the lower layer may be system and or application components specific and these methods of the lower layer may further invoke further lower layer or layers of methods to access the system and or application components. Each of the methods in a lower layer may be encapsulated by the public interfaces and may be developed using object oriented programming techniques where each method may be implemented as an object. Certain methods of lower layer may inherit from a base class by overloading and or virtualizing a base method. As a result specific operations regarding a specific system and or application component may be developed independently in a corresponding object or class and invoked by other methods or classes. The health check system designed in this way would be more flexible and scalable.

According to one embodiment the system can utilize a health check framework embedded in client systems which may be initiated by a health check application client to periodically or constantly monitor the system and application components of the client systems and create incidents and or administration tasks if a critical situation is detected. The incidents are provided to users such as IT administrators with instant access to context or diagnostic information to resolve or elevate the incident. Incidents can be generated automatically after detection of a change in the system or the application components e.g. a change in system or application component activity a monitored performance value exceeding a pre defined threshold or a change in system or application component status such as a queue overflow that stops a business process etc. 

An incident is any event which is not part of standard operation of an IT service and which causes or may cause an interruption to or a reduction in the quality of that service e.g. faults errors malfunctions etc. of an IT service . Should such an event occur the subject matter described herein automatically collects context or diagnostic data associated with the event such as technical and application information package the context data with a problem description and severity in an incident report and generates an incident service request. An administration task is a single activity or a group of activities within the IT system that need to be performed in order to reach specific end results. Administration tasks can relate to a defined activity such as the change of a configuration parameter. Administration tasks also can be used for incident and problem solution prevention i.e. the execution of regulation maintenance steps required to help keep the IT system stable and other activities such as configuration changes parameterization user creation and system restart. A simple example of an administration task is a how to guide which describes a well defined activity step by step. A complex example of an administration task is a guided activity transaction e.g. a wizard which guides the user through a well defined activity.

Client systems also can include other embedded services including but not limited to an integrated operations handbook software maintenance management incident processing and management embedded support and safeguarding. The integrated operations handbook can include automated task and incident handling and a central administration console for operational management. Each task in the integrated operations handbook is associated with specific details of handling the task such as when the task has to be performed event based or time based the responsible person role documentation on the task and information on the service level agreement. A guided activity transaction e.g. a wizard may be provided to help a user perform an administration task which guides the user through a defined activity. The incident processing and management service embedded support can provide end user support for incidents created by a health check monitoring process or the user and provide end user support and automated context collection for resolving incidents created by an end user. An end user can manually create an incident through a support application which can be invoked from any application screen to report a malfunction in the application or the user can use a support button for example in a self service view of a control center user interface.

Note that the system is illustrated as an example and other configurations arrangements and network topologies for system are possible including more or fewer clients and or multiple back end systems. In some variations the application provider system and or the service provider system are is integrated with the client systems through the network which can be configured to facilitate continuous or periodic data exchange between the systems and the client systems using known networking protocols such as TCP IP and HTTP. In some variations an application provider system need not be used in system . Likewise a service provider system need not be used in alternative variations of system .

From time to time system configuration information associated with the client systems is transmitted to the back end system s . In some implementations the back end system s request s system configuration information from the client systems on a scheduled basis using for example a polling scheme. In other implementations the client systems send information to the back end system s continuously or periodically or in response to one or more events for example notification of an incident or administration task.

The system configuration information includes system operational parameters of the system and application components such as generated system events and performance values. The system configuration may be configured via a user interface as shown in . Based on the retrieved or pushed system configuration information the health check monitor invokes the health check framework to initiate a health check session which utilizes a variety of methods or APIs application programming interfaces of the framework to perform certain health check operations. Based on the result of the health check session report generator may generate a health check report which may be presented to a user via user interface as shown for example in .

In one embodiment health check framework includes a variety of layers such as layers of methods where each method may be implemented as an object using object oriented programming languages. For example health check framework includes a public interface layer which exposes certain publicly available methods including initialization method preprocess method process method and post process method . Each of the methods may further invoke one or more of middle layer having a variety of methods that are defined in more details. While methods are exposed to client at least a portion of methods of middle layer may be encapsulated and not directly accessible by client .

In one embodiment middle layer includes various methods each corresponding to a certain functionality e.g. common functionalities including data collector object comparison logic long text handling object group interface object incident handling object status handling object task handling object and error warning message object . These objects may invoke further lower layer of methods to perform operations specifically designed for the corresponding health check content.

According to certain embodiments of the invention via object oriented techniques e.g. using object oriented programming languages such as Java and or .NET etc. layer may be defined via a base class and methods may be defined as common public methods of the base class e.g. public function members accessible by an external client or caller while methods involved in layers may be defined as encapsulated methods that are not publicly available e.g. protected and or private function members and may only be accessed by the methods of layer .

In addition certain methods having common functionalities may be defined at layer and any specific implementation that deviates from the common methods may be defined within layers for example by overloading and or virtualizing the corresponding method. For example methods of data collector object may be used frequently however for each of the system application components the specific way to collect such data may be different. As a result layer may include another object that inherits overloads and or virtualizes at least a portion of the methods in the data collector object . Furthermore as another example status handling object may invoke data collector object to collect certain statuses of a system application component as the data collector object may be designed to collect any data including status. Thus although the API exposed to client may remain the same specific implementation of a method may be implemented or modified within layers and may be developed by different developers in different development phases. Other configurations may exist.

At block one or more second layer methods are defined and provided to provide an abstract interface to one or more system application components with respect to one or more first layer methods. The second layer methods include one or more methods that are specific to a corresponding one of system application components. The second layer methods are encapsulated in one or more objects without being exposed to the client. At block in response to a health check session initiated from the client one or more first layer methods invoke at least a portion of second layer methods to collect data from one or more system application components. The collected data is then evaluated to determine the health of the particular system application components. Thereafter a health report is generated based on the evaluation. Other operations may also be performed.

According to certain embodiments the core of checks is implemented in the comparison logic which is used to create auto close incidents tasks. is a block diagram illustrating an example of comparison logic interfaces according to one embodiment. In order to simply the development of check content referring to multiple comparison strategy classes such as ITSAM CL HC COMP STRA VALUE ITSAM CL HC COMP STRA COLOR ITSAM CL HC COMP STRA LOG are defined. The interface ITSAM IF HC COMP STRA is reused also by class ITSAM CL HC EXCP LIST which is designed for exception list handling. The class ITSAM CL HC COMP STRA is an abstract class is used for code sharing. It implements the interface above and all three comparison strategy classes are its subclasses. When developing checks each check normally should redefine method ITSAM IF HC CHECK DETAIL SET COMP STRATEGY and tell which strategy it will use for create auto close incidents tasks. In rare cases that the comparison strategy of the check is not covered by the three classes the method ITSAM IF HC CHECK DETAIL COMPARE SPECIAL have to be redefined and special comparison logic should be implemented there.

According to certain embodiments of the invention most of the concrete checks are implemented as local class of their corresponding check group class. They all inherit from base class ITSAM CL HC CHECK PROCESS. Normally only certain methods such as methods ITSAM IF HC CHECK DETAIL SET COMP STRATEGY and ITSAM IFHC CHECK DETAIL SET SHORTTEXT may be redefined as shown in .

According to certain embodiments of the invention most of the old client e.g. DSADEV related codes are encapsulated with class ITSAM CL HC DSA GEN and function group ITSC DSA EXT. This will help to achieve the old client decoupling and provide backward compatibility as shown in . The generic DSA handling is implemented in class LCL HC DSA GEN. If any check has special DSA handling logic one local class should be created and special logic should be implemented there. The central instantiation method is LCL HC DSA GEN ITSC IF HC DSA GET INSTANCE. If any check has its own DSA handling class a developer should change the instantiation code inside this method.

Thus as described above the processing logic continually or periodically checks the system and application components residing in an enterprise system and creates incidents and or administration tasks if a critical situation is detected. Initially an operator of an enterprise system e.g. an IT administrator configures the service level for enterprise system using for example a service level configuration user interface as described in . The operator may define the schedule that a health check session is performed e.g. constantly or periodically such as every hour or daily.

Once the health check system has been configured the system and application components of the enterprise system whether decentralized or local are monitored for the occurrence of any events as shown in . An event for example is a change in system or application status or a system or an application performance value exceeding a threshold as shown in . Monitored events are stored and pushed to an evaluation engine e.g. comparison logic as part of the health check framework where the pushed events are evaluated.

The evaluation of events may include two processes. In the first process each event can be routed based on rule logic e.g. AND OR NOT AND etc. which e.g. may be retrieved from a rules catalog of an integrated electronic operations hand book which also includes other data storages such as a task catalog and configuration data. The rules logic may include scenarios such as if A AND B then C or if A AND B then NOT C. The rules based classification and routing can include time dependent rules logic such as if A happens more than B times in C seconds then D or if A happens AND NOT B happens within the next C seconds then D. The rules logic can also include logic that classifies and routes an event based on severity and system impact such as for an evaluation of a single event regarding its attributes in point in time. Moreover the rules logic can include logic that classifies and routes events based on an evaluation of a single event according to the frequency of its occurrence.

For example some events can be meaningless if they occur only once but can indicate a severe issue if they happen more frequently such as a performance event that occurs more often over time. The rules logic further can include logic that classifies and routes different events occurring at the same time which may be useful to identify the actual system status. For example if a certain server does not respond and the corresponding network link indicates a network failure then the actual problem is more likely a network issue rather than a service problem. This information can be used in order to trigger an appropriate system analysis. The rules logic also can include logic that classifies and routes multiple events occurring over a period of time.

As an example of an event being classified and routed based on rule logic assume a database response time exceeds a certain threshold which causes the generation of an event. But say e.g. the event occurs only during the night while a time consuming batch job is running. As a result the rules based classification and routing process may determine that the event need not be routed for further processing. As another example assume the database time exceeds a certain threshold several times and the response time values increase over time during productive working hours. As a result the rules based classification and routing process may determine that the event needs to be routed for further processing e.g. by the evaluation. Typically these routed events are critical system events from the application components.

According to certain embodiments processing logic retrieves the routed event input e.g. response time values file system usage CPU usage etc. and determines whether the routed event should be classified as an incident or an administration task. In some implementations additional information about the routed event may be desired and can be retrieved from the system and application components associated with the event in order to determine whether the routed event should be classified as an incident or an administration task. Based on the retrieve information the tasks which are necessary to analyze and resolve the event are selected from e.g. a task catalog data storage of an integrated electronic operations handbook and processed to determine whether to classify the routed event as an incident or an administration task. If the tasks necessary to analyze the event are located the event is classified as an administration task otherwise the event is classified as an incident.

In other words classifying the generated event as either an incident or an administration task can be based on predefined criteria as provided by the task catalog of the integrated operations handbook. The task storage includes predefined task events and can also include other information such as task schedules task responsibilities and service level agreement data. In some implementations the task storage defines the responsible person for processing the task event. Thus in some implementations evaluating whether a routed event should be classified as an incident or task can be accomplished by searching the task storage of the operations handbook to determine if the routed event is listed in the operations handbook. If the generated event is not listed then the generated event can be classified as an incident. If the generated event is listed then the generated event can be classified as an administration task.

If the generated event is evaluated and determined to correspond to an administrative task e.g. a configuration parameter needs to be changed according to a predefined schedule an administration task is created and associated context data is provided with the administration task. Optionally an administration task can be time based triggered e.g. periodic administration task or a combination of time based triggered and event based triggered. Next the created administration task may be optionally displayed during task management.

If the generated event is evaluated and determined to correspond to an incident an incident is created and may be optionally displayed in a service desk environment. According to one embodiment the context or diagnostic data associated with the incident is automatically collected. The context or diagnostic data may include e.g. technical and application information that is usually required to resolve the incident. The context data can include e.g. relevant system and application information from all architectural layers such as a user interface layer enterprise service layer a business object layer and a system layer. Because the context data is automatically collected at or near the time the event which caused the creation of the incident occurred the state of the system or application components causing the incident is preserved unlike conventional systems in which an operator may attempt to resolve the incident after the associated log files or other system or application component context information may have already been deleted .

Thereafter an incident report is generated which provides an explanation of the why the incident was triggered with the collected context data. Thereafter an incident service request is generated typically by a service desk such as a Customer Relationship Management CRM system residing on an application platform within the enterprise system. In such implementations the service desk receives the incident report stores the report and generates the service request. The incident service request may then be optionally displayed in a user interface so that an operator or other end user can be visually notified of the incident service request and track the status of the incident service request.

As shown in the computer system which is in a form of a data processing system includes a bus or interconnect coupled to a processor and a ROM a volatile RAM and a non volatile memory . Processor may include multiple processors and or core logics that constitute central processing units CPUs of the system and thus control the overall operations of the system. According to certain embodiments processor accomplish this by executing software stored in any of the memories such as for example applications and operating system etc. Processor may include one or more programmable general purpose or special purpose microprocessors digital signal processors DSPs programmable controllers application specific integrated circuits ASICs programmable logic devices PLDs or the like or a combination of such devices.

The processor which may be for example an Intel processor or a PowerPC processor is coupled to cache memory as shown in the example of . The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive a DVD RAM a Flash memory or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required.

While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals. Alternatively I O controller may include an IEEE 1394 adapter also known as FireWire adapter for controlling FireWire devices. Other components may also be included.

Thus a health check framework for enterprise systems has been described herein. Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

