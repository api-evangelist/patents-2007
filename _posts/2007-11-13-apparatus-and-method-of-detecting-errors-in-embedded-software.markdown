---

title: Apparatus and method of detecting errors in embedded software
abstract: A method and apparatus for detecting errors in an application software of an embedded system are provided. The method of detecting errors in an application software includes determining a development language of the application software and an operating system on which the application software is executed; replacing an error detection syntax inserted in order to examine an error in a predetermined function of the application software, with an error detection syntax according to the result of the determination; and performing exception handling for an error occurring in the function according to the result of the replacement, and logging error information according to the exception handling. According to the method and apparatus, an error can be automatically detected and logged irrespective of a development language and an operating system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589889&OS=08589889&RS=08589889
owner: Samsung Electronics Co., Ltd.
number: 08589889
owner_city: Suwon-Si
owner_country: KR
publication_date: 20071113
---
This application claims the benefit of Korean Patent Application No. 10 2006 0120954 filed on Dec. 1 2006 in the Korean Intellectual Property Office the disclosure of which is incorporated herein in its entirety by reference.

One or more embodiments relate to an apparatus and a method of detecting an error and more particularly to a method and apparatus for detecting an application error of an embedded system.

An embedded system is an apparatus which has an embedded microprocessor or microcontroller and performs only functions that are specified by an original designer. Generally the embedded system is a specific application system which as part of a system larger than the embedded system includes hardware and software in order to perform special tasks.

Embedded systems are applied to a variety of application fields for example a control field including factory automation home automation robot control and process control a terminal device field including mobile phones personal digital assistants PDAs smart phones and LBS Location Based Services an information appliance field including printers Internet refrigerators video game consoles and HDTVs and a network device field including exchanges routers home servers and home gateways 

Meanwhile as embedded systems are applied to an increasing variety application fields and the number of digital applications increases the functions of embedded systems have become more complicated and in line with the increase in the variety of hardware systems embedded software has been developed with a variety of development languages on a variety of operating systems. Accordingly the number of software bugs has also been increasing.

In this changing environment when a plurality of programs are tested or debugged in an embedded terminal to find errors or bugs it takes much time to find errors that are purely related to the application because of errors caused by the application s dependency on a hardware system or an operating system occur. Also in the case of a poor embedded development environment that does not support exception handling in an operating system it is difficult to detect an exception of an application.

Also in the case of most small sized operating systems that do not support an MPU even though the development languages through through support exception handling functions an operating system that does not support the functions cannot detect critical errors. However in an operating system that does support the error detection functions through some hardware exception handling functions the error detection function supported by the operating system can be used irrespective of the development language k .

However the conventional technology has many problems which will be described below. Firstly when an application is developed on an operating system if a hardware problem occurs the hardware problem should be fixed and then the application can be verified or if a complicated error occurs due to a combination of the application and the operating system it takes much time to find a bug purely in the application and to stabilize the application. Secondly in an environment of a poor operating system or a development language that does not support exception handling it is impossible to automatically detect an error in an application and thus it is difficult to debug the application. Thirdly because an exception handling API is supported in different ways or not supported depending on the development environment in the case of software meant to be reused in a variety of operating system such as middleware it is difficult to reuse the software while performing exception handling. Fourthly when coding is performed by using only an exception handling API provided by the conventional technology the number of source lines increases in order to process debugging and logging with reducing intervals in which exceptions occur and thus code readability is lowered and the source becomes complicated.

Additional aspects and or advantages will be set forth in part in the description which follows and in part will be apparent from the description or may be learned by practice of the invention.

One aspect of the embodiments provides a system for verifying embedded software in a desktop environment irrespective of hardware and operating systems.

Another aspect of the embodiments also provides a method and apparatus for detecting an error with a function for automatically detecting and logging an error irrespective of development languages and operating systems.

One aspect of the embodiments also provides a method of reusing an application and an error checking code developed in a desktop in an embedded system by providing an error verification system and an error detector independently of development languages and operating systems.

According to an aspect of the embodiments there is provided a desktop error verification system for verifying an error in an application of an embedded system the system including application programming interface API wrappers corresponding to an API supported by a plurality of operating systems OSs of the embedded system each of the API wrappers corresponding to one of the plurality of the OSs wherein the API wrapper is replaced by an API corresponding to the function of the API of the embedded system and supported by a desktop OS and the API wrapper calls the replaced API thereby verifying an error in the application.

According to another aspect of the embodiments there is provided a method of detecting errors in an application including determining a development language of the application and an operating system on which the application is executed replacing a predetermined error detection syntax inserted in order to examine an error in a predetermined function of the application with an error detection syntax according to the result of the determination and performing exception handling for an error occurring in the function according to the result of the replacement and logging the error information according to the exception handling.

According to another aspect of the embodiments there is provided a method of detecting an error in an application including inserting ERR DETECT TRY and ERR DETECT CATCH at the start and end respectively of a function for examining an error in the application and coding the function determining the Try type at ERR DETECT TRY and an OS on which the application is executed and replacing ERR DETECT TRY with a Try syntax according to the result of the determination if an error occurs in the function determining the Catch type at ERR DETECT CATCH and an OS on which the application is executed and replacing ERR DETECT CATCH with a Catch syntax according to the result of the determination and searching for an exception handling code for the error performing the exception handling according to a found exception handling code and logging the error information according to the exception handling.

According to another aspect of the embodiments there is provided a method of detecting an error in an application which is developed on a desktop OS after loading the application and an error detection syntax developed on the desktop OS on an embedded system without modification the method including verifying an error on the desktop OS according to an error detection syntax included in a predetermined function of the application by using an error verification system of the desktop OS including API wrappers corresponding to an API supported by a plurality of OSs of the embedded system each of the API wrappers corresponding to one of the plurality of the OSs loading the verified application on the embedded system determining a development language of the application and an OS of the embedded system on which the application is executed replacing the error detection syntax with an error detection syntax corresponding to the development language and the OS according to the result of the determination and according to the result of the replacing performing exception handling for an error occurring in the function and logging the error information according to the exception handling.

According to another aspect of the embodiments there is provided an apparatus for detecting errors in an application including a determination unit determining a development language of the application and an operating system on which the application is executed a replacement unit replacing a predetermined error detection syntax inserted in order to examine an error in a predetermined function of the application with an error detection syntax according to the result of the determination an exception handling unit performing exception handling for an error occurring in the function according to the result of the replacement and an error logging unit logging the error information according to the exception handling.

According to still another aspect of the embodiments there is provided a computer readable recording medium having embodied thereon a computer program for executing the methods. Details and improvement of the present invention will be disclosed in dependent claims.

Reference will now be made in detail to the embodiments examples of which are illustrated in the accompanying drawings wherein like reference numerals refer to the like elements throughout. The embodiments are described below to explain the present invention by referring to the figures.

Referring to at the top of development languages . . . k through an application . . . n an error detector an embedded OS and an error verification system are shown while at the bottom of an embedded OS including operating systems . . . m without an error detection function and an OS having an error detection function is shown.

The development languages . . . k through are programming languages for developing an application and may be for example visual basic C and Java. Each language declares or has an exception handling syntax which is required for detecting and processing errors and bugs and all the exception handling syntaxes are different from each other. There are also some languages that do not support exception handling.

In general embedded operating systems can be broken down into hard real time operating systems RTOSs and soft RTOSs in terms of restrictions in real time processing and can be broken down into thread based RTOSs and process based RTOSs in terms of the execution environment of an application software program.

In the thread based OS an OS kernel and an application program have the same execution environment that is the same address space and for example VxWorks pSOS Nucleus Plus and C OS are included. In the process based OS an OS kernel and an application software program follow a process performing model and thus the application software is executed in an address space different from that of the kernel and for example Windows CE Windows NT Embedded 4.0 and Embedded Linux are included.

Each of these OSs supports only an application programming interface APIs that is suitable for the OS. For example Windows CE is an OS newly designed for an embedded system but supports most of Win32 APIs and thus is classified as a Windows OS. However Windows CE supports only APIs suitable for an embedded system among all Win32 APIs.

The embedded OS is an OS supporting an MPU and the OS is a small sized OS that does not support an MPU.

The error verification system is used to develop and test the application software on a desktop OS irrespective of the development language and the OSs and and automatically detects and verifies an error. In the conventional OSs and if exception handling is not supported or if an application is developed directly on an OS stabilization of only the application takes much time. However through the corresponding verification system an application is developed on a desktop OS by commonly using an API supported by the embedded OSs and and when a test is performed error verification effect can be achieved. Also a time taken for downloading on a development board and executing a program source whenever the program source is changed can be reduced. A detailed structure of the error verification system will be explained later with reference to .

The error detector can automatically detect an error of the application software even under an environment such as an OS that does not support an exception handling function and even when the exception handling function is provided in a variety of AIP types in different OSs. Also by using the error verification system of the desktop the error detector enables the application software that is initially stabilized to be commonly used in a variety of OSs and of the embedded system without modifying the application software . An error detection algorithm and detailed functions of the error detector will be explained later.

Referring to while testing the application software which is developed by using a variety of development languages . . . k in the desktop OS irrespective of the development language and the OSs and the error verification system can automatically detect and verify an error.

The error verification system operates on a desktop OS and provides an API wrapper of an embedded OS . Thus an application software is developed in the desktop. However an environment providing the same functions as in the development of an application in the embedded OS is provided and the advantage of abundant development tools and debugging environments can be used. An OS in an embedded system provides a variety of APIs. In order to use this API in a desktop OS without change and to develop an application an API wrapper should be supported by each OS.

Here the wrapper is data which presets a frame in front of actual data or a program which sets another program so that the other program can be successfully executed. The wrapper also includes a program or script that sets a range of activities and enables execution of another program that is more important than the wrapper.

The API wrapper for each OS is illustrated in . The functions of the wrapper can be broadly broken down into 9 functions. A task management API which is supported by each OS is defined as a task management API wrapper and is also referred to as the task management API wrapper and this is replaced by a task management desktop API that is supported by the desktop OS . Here the task is a unit of jobs in an OS. Each task is assigned a priority level and has a set of CPU registers and its own stack area and thus is capable of performing an independent program. Accordingly in an OS task management is performed and an API performing this function is a task management API.

Due to this structure although an application is developed on the desktop OS the task function is performed internally in the embedded OS.

In this manner a scheduler API wrapper of the OS is replaced by a scheduler Desktop API a timer API wrapper is replaced by a timer Desktop API a synchronization management API wrapper is replaced by a synchronization management Desktop API a process communication API wrapper is replaced by a process communication Desktop API a memory management API wrapper is replaced by a memory management Desktop API a device I O system API wrapper is replaced by an I O system Desktop API a file system API wrapper is replaced by a file system Desktop API and other API wrappers with a variety of functions that are supported in the embedded OS are replaced by corresponding APIs for another desktop API .

Here the meaning of the replacement is as follows. For example it is assumed that the name of an API for generating an execution module in the error verification system is CreateTask and an OS A uses a function name NuCreateTask and an OS B uses a function name TaskCreate. Then if the desktop OS is Windows XP but programming is performed assuming that the error verification system uses the OS A and if an application developer uses the function name CreateTask the OS A is called by NuCreateTask that is the function name suitable for the OS A at the bottom of the wrapper. Then when the application is ported from the OS A to the OS B if only NuCreateTask at the bottom of the wrapper is automatically replaced without modifying the application so that the application can be called by the function name TaskCreate the application can be quickly applied to a variety of OSs without restrictions.

More specifically the desktop APIs through illustrated at the bottom in are used in the same manner and the API wrapper calls the desktop APIs through in each OS. Accordingly an error verification test of an application software in the error verification system based on the desktop OS can be performed by the same code as is used for development of an application on the embedded OS without modifying the source code.

When the wrappers through are not prepared with respect to the commercial or non commercial embedded OS at the source level or when APIs are added to the existing embedded OS the API wrapper storage unit stores a table which allows mapping with the APIs through already supported by the desktop OS thereby providing an environment for execution on the embedded OS without modifying source codes one by one. In the API wrapper storage unit the sizes of a stack and a memory used in an embedded environment can be set to limit the environment. Accordingly even when the application is developed in a desktop environment a limited embedded environment is provided.

The terminal console and GUI monitoring environment providing unit provides the same environment as the screen output and terminal control in an embedded environment to a desktop OS.

Referring to first an application software is developed with a variety of development languages on a desktop OS by using the error verification system described above in operation . Then in operation error detection of the developed application is initially performed on the desktop OS. Here the error detection can be performed in a variety of debugging environments and through this process the developed application software is stabilized. In operation the program source of the stabilized application software is loaded on an embedded OS without modification. In operation by using an error detector according to an embodiment errors in the loaded application software are detected.

As illustrated in the application software which is developed and stabilized by using the error verification system on the desktop OS can be loaded on the embedded OSs and and reused without modifying the sources.

According to the conventional technology when embedded software developed on a desktop OS is loaded on an embedded system the source code should be modified and then loaded or in an environment such as with an OS development languages it is difficult to debug and stabilize the application software .

However according to an embodiment an application software can be developed and debugged and initially stabilized through a long run test by using a variety of development tools and a convenient development environment through the error verification system on the desktop OS and then a source code corresponding to the application software can be reused directly in the embedded OSs and without modifying the source code. This is because if the application software uses an API supported by the embedded OSs and the source code does not need to be modified because the API wrapper with the same name can be used. Also since an API supported by the error detector operates irrespective of OSs and development languages the source code can also be reused without modification. For example developers of information terminals ranging from very light to high end products including refrigerators MP3 players and mobile phones can develop an application software such as middleware and application softwares purely with the error verification system software without a development board. Then with the application software in the OS which does not support error detection and by using the error detector the developer can detect errors of and stabilize the application software initially in the desktop OS . Accordingly the time taken for detecting an error in the application software by the conventional technology having the side effects of the unification of hardware and OSs and can be reduced to a minimum. A more specific algorithm of this error detector will be explained with reference to . are flowcharts illustrating an error detection algorithm independently of development languages and operating systems according to an embodiment.

Referring to algorithms for an exception handling method supported in a variety of ways in OSs and development languages and an error detection method capable of independently handling an environment that does not support exception handling will now be explained.

As described above through this error detection algorithm the development source that is stabilized by an error detection method which is used when an application software is developed in the error verification system illustrated in can be reused in another OS and other hardware.

First as illustrated on the left hand side of table 1 below when an application is developed ERR DETECT TRY is inserted into line 003 which is a start part of an interval for examining an error and then coded and ERR DETECT CATCH is inserted into 020 which is an end part of the interval for examining an error and then coded. According to this if a critical error occurs inside a function between lines 001 and 021 the error is detected and logged at line 020 and thus it can be confirmed that the error occurred at a specific time.

Also as illustrated on the right hand side of table 1 one or more macros may be inserted. That is ERR DETECT TRY is inserted into line 003 ERR DETECT CATCH is inserted into line 010 and then coding is performed. ERR DETECT TRY is inserted into line 012 and ERR DETECT CATCH is inserted into line 020 and then coding is performed. According to this if a critical error occurs between lines 001 and 021 the error is detected and logged at lines 010 and 020 and thus it can be confirmed that the error occurred at a specific interval and at a specific time in an Example API function. This simple interface for an application software developer makes it easy to develop an application software.

Also an advantage for detecting an error in an application software exists. For example it is assumed that n application software sources exist and m functions for each application software source exist. If an application software is implemented by using more than tens of thousands of functions m n it is very difficult to find an error due to mistakes by a developer irrespective of hardware and OSs. In addition more time will be taken in order to detect errors of the application software because of defects occurring when hardware and Oss are combined.

As described above if only two macros ERR DETECT TRY and ERR DETECT CATCH are essentially inserted into the start and end of an interval for detecting an error in each of all functions and then coded only n m 2 macros are added. However according to the conventional method the number of required jobs is n m coding lines for handling errors error logging lines the number of times of changing intervals .

Also when portability is low because of a use method and types different from those of Try and Catch syntaxes provided by a system and the error detection function is not provided each line should be found from all sources and should be footnoted or deleted. By replacing these two macros with syntaxes internally comparing development languages and OSs portability can be provided without modifying a source code. An error detection algorithm of an application which is coded after ERR DETECT TRY and ERR DETECT CATCH are added is illustrated in .

In the error detector according to an embodiment the ERR DETECT TRY syntax compares the types and OSs of Try. Here the types of Try are different depending on development languages such as  try try Try RRM HANDLER TRY . . . and  try in operation .

An environment without an error detection function provides its own error detection algorithm. Also other types of Try syntaxes that are supported in other environments exist. In operation it is determined whether these Try syntaxes match. If the Try syntaxes do not match replacement of the Try syntax is performed according to the type of a Try handler supported by the development language and the OS in operation . That is by comparing the types and OSs of Try syntaxes ERR DETECT TRY is replaced by a Try syntax corresponding to the type and OS.

Then in operation preparation for searching for exception handling is performed. Here the exception indicates a case where an application runs away from a normal flow and causes congestion in an abnormal path. The exception includes an error or a bug and means that an unexpected abnormal state occurs in the middle of operating a computer system and due to the abnormal state a program in execution is affected. For example exception handling is processed with syntaxes such as catch finally throws and throw by declaration of a programmer. When an exception occurs catch determines whether to restore the flow of a program by identifying the exception or to finish the program. The exception may be processed directly at the place where the exception occurs or by pointing out a place in which the exception is processed the exception may be thrown for exception handling.

In operation if a critical error occurs in an interval after the interval in which ERR DETECT TRY begins ERR DETECT CATCH does not terminate the system and prepares to handle an exception situation and then compares the types and OSs of Catch. Then in operation it is determined whether or not Catch syntaxes match. If the Catch syntaxes do not match replacement of the Catch syntax is performed according to the type of a Catch handler supported by a development language and an OS in operation . That is the Catch syntax is replaced by any of  except 1 RRM HANDLER CATCH catch . . . an environment without an error detection function providing its own Catch algorithm and a Catch handler supported by other environments.

In operation the type of a system error is searched for. That is an API wrapper supported by the OS and development language is substituted and the source name and line in which an error occurs are recognized through exception handling.

In operation an exception code that currently occurs is searched for. Here a corresponding error is selected from exception handling codes as illustrated in table 2 below. Table 2 illustrates ERR ACCESS VIOLATION ERR DIVIDE BY ZERO and ERR STACK OVERFLOW which will be explained below with reference to .

First before logging an error in order to prevent an error during logging caused by exceptional situations occurring in many places at the same time according to multitask and multithread the processing order is synchronized by using mutex. Here mutex is an abbreviation of the term mutual exclusion and is used to execute mutual exclusion. That is mutex is used to prevent threads having critical sections from being executed at the same time but be executed mutually exclusively. Here the critical section is a part that may cause a problem if the section is executed at the same time in a program. If a thread is executed in a critical section other threads cannot access the critical section and have to wait until the current thread leaves the critical section.

In operation it is examined whether an already generated mutex exists because the mutex for logging an error does not need to be generated frequently. In operation it is determined whether an already generated mutex exists. If the mutex does not exist a mutex is newly generated in operation . In operation the handle of the already generated mutex or the newly generated mutex is opened.

Then in operation it is examined whether or not a mutex interval is used by other tasks. If the mutex interval is used by other tasks a current task waits for a while. In operation in order to log an error mutex lock is performed. In operation as illustrated in table 3 below the time when the current exception occurs the type of the error the name of the source and the source line are logged.

Here in relation to the method of logging since the management of the capacity and files of an embedded terminal is not easy because of a huge amount of logs recorded in real time as a history logging may be set so that logs can be stored in units of hours or minutes. Also according to other methods logging files may be selectively deleted periodically or may not be deleted during a test performing time. Also in the case of a terminal selectively connected to a network logging contents may be downloaded to a remote desktop system or server periodically thereby saving a storage space of the terminal.

Then in operation the mutex lock is released. Finally when the system is terminated the mutex of the error file logging that is already generated is released.

As described above by using only two functions ERR DETECT TRY and ERR DETECT CATCH at the start and end of an interval for examining an error automatic error detection and logging functions can be provided so that a source can be reused irrespective of development languages and OSs.

If the application is thus coded and compiled a user may not be exposed to an error item such as a situation in which the system is down and exceptional error items are logged with less affect on other systems. Accordingly in a long run test and maintenance after providing a product the logs can be effectively utilized.

Referring to the error detection apparatus is composed of a determination unit a replacement unit an exception handling unit an error logging unit and a storage unit .

The determination unit determines an OS of an embedded system in which a development language of an application and the application are executed.

The replacement unit replaces ERR DETECT TRY and ERR DETECT CATCH included in an error detection syntax coded while an application is developed on a desktop OS with error detection syntaxes according to the determination result of the determination unit that is a Try syntax such as  try try Try RRM HANDLER TRY . . . and  try which vary depending on development languages and are supported by other environments and a Catch syntax such as  except 1 RRM HANDLER CATCH catch . . . which are supported by other environments. For an environment without an error detection function a Catch algorithm of the error detection apparatus is provided.

The exception handling unit performs exception handling of an error occurring in a function according to the result of replacing in the replacement unit . Then the error logging unit logs error information according to the exception handling.

Also the storage unit stores an error examination algorithm capable of examining an error and provides its own Try and Catch algorithms in a case where error examination is not supported by a development language and an OS that is in an environment without an error detection function.

Referring to in operation ERR DETECT TRY and ERR DETECT CATCH are installed at the start interval and the end interval respectively of a function. Table 4 illustrates that ERR DETECT TRY is coded at 43 ERR DETECT CATCH is coded at 48 ERR DETECT TRY is coded at line ERR DETECT CATCH is coded at line ERR DETECT TRY is coded at 56 and ERR DETECT CATCH is coded at line .

In operation if a first memory violation occurs ERR DETECT CATCH at line detects an error. That is as illustrated in table 4 the size of an allocated memory is 100 . However if 100000 is set at line that is if a memory violation occurs ERR DETECTION CATCH at line detects the error and the error is logged in operation . Then in operation if a second memory violation occurs that is if 200000 is set at line ERR DETECT CATCH at line detects the error and the error is logged in operation . In operation if these memory violations occur the system continues to run without a down time. Then a log file as illustrated in table 5 is generated allowing a developer to analyze the time when an error occurred the types of errors the source names and the source lines from this log file.

More specifically when a task goes beyond an allocated memory area and violates another memory area the violation is automatically detected and the system can continue to run without a user experiencing down time. Basically ERR DETECT TRY and ERR DETECT CATCH are executed at the start interval and end interval of a function. When the memory is incorrectly used at two places in the function as illustrated in table 4 only the place where the first violation occurs in the memory is indicated according to the conventional technology. However according to the current embodiment ERR DETECT TRY and ERR DETECT CATCH are executed in each interval in a more detailed manner thereby making code generation easier. Also when the first exception situation occurs the error is detected by ERR DETECT CATCH at line but the system does not stop and continues to run the following lines and when the second exception situation occurs the error is detected by ERR DETECT CATCH at line . Accordingly when errors caused by the developer exist the critical error situations at the two places can be identified through logging. As a result the time when an error occurred the types of errors the source names and the source lines as shown in a log file can be identified.

Accordingly all places in a specific function where errors occur due to mistakes of a developer can be detected and a system can be prevented from going down. When N exceptions are processed development and error detection are made to be easier. Also in an error verification system the size of a memory can be set so that a limited memory environment of an embedded system can be provided.

Referring to in operation ERR DETECT TRY and ERR DETECT CATCH are installed at the start interval and the end interval respectively of a function. As illustrated in table 6 ERR DETECT TRY is coded at line and ERR DETECT CATCH is coded at line . Then in operation when a divide by zero error occurs at line ERR DETECT CATCH at line detects the error.

In operation the error is logged. In operation the system does not go down and continues to run normally. In operation errors are analyzed by using a log file as illustrated in table 7.

More specifically 0 is input as variable iData. Here if the denominator is 0 the error is not detected when compiling is performed and if exception handling is not performed the system may be terminated. If exception handling is performed the error is automatically detected at ERR DETECT CATCH and logged and thus the time the type the source name and the source line are recorded in a log file.

The divide by zero error is a slight error effective only in the current function and does not cause an error in other areas and thus the divide by zero error is one that does not stop the entire system. Accordingly the error is logged thereby allowing a developer to analyze it later after performing a long run test. The long run test is performed without debugging and when a user uses the system the system is made to continue to run without a down time.

Referring to in operation ERR DETECT TRY and ERR DETECT CATCH are installed at the start interval and the end interval respectively of a function. As illustrated in table 8 ERR DETECT TRY is coded at line and ERR DETECT CATCH is coded at line . Then in operation when a stack overflow occurs ERR DETECT CATCH at line detects the error. In operation the error is logged. In operation the system does not go down and continues to run normally. In operation errors are analyzed by using a log file as illustrated in table 9 below.

More specifically when a stack overflow occurs in a function SimulateStackOverflowAdoptExcept without moving into the function the error is automatically detected and logged at ERR DETECT CATCH in SimulateException which is an upper function that is immediately called and is an upper level function.

In a log file the time the type of the error the source name and the source line are recorded to indicate that the error occurred at ERR DETECT CATCH at 14 of the previously called function SimulateException even if a stack overflow occurs in the function SimulateStackOverflowAdoptExcept .

Also the system can continuously run without a system down time with giving trust to the user while the developer can collect these log files thereby stabilizing an application software in the development stage and in addition providing continuous maintenance and patches. Also even in an error verification system a stack size with respect to each task can be set such that a limited stack environment with respect to the task of an embedded system can be provided.

According to an aspect of the embodiments with respect to an API supported by a plurality of OSs of an embedded system API wrappers for respective OSs are included and the API wrappers are replaced by corresponding APIs supported by the desktop OS and the API wrappers call the replaced APIs. In this way software for the embedded system can be verified on the desktop OS irrespective of hardware and OSs.

Also according to an aspect of the embodiments the development language of an application software and the OS on which the application runs are determined and an error detection syntax which is inserted in order to examine an error in a specific function of the application software is replaced by an error detection syntax according to the result of the determination. Then according to the error detection syntax used as the replacement exception handling of an error occurring in the function is performed and the error information according to the exception handling is logged thereby automatically detecting and logging the error irrespective of development languages and OSs.

Also by using the error verification system and error detection apparatus irrespective of development languages and OSs according to an embodiment an application software and an error examination code developed on a desktop OS can be reused in the embedded system without modifying the code.

One or more embodiments can also be embodied as computer readable codes on a computer readable recording medium. The computer readable recording medium is any data storage device that can store data which can be thereafter read by a computer system. Examples of the computer readable recording medium include read only memory ROM random access memory RAM CD ROMs magnetic tapes floppy disks optical data storage devices and carrier waves such as data transmission through the Internet .

While one or more embodiments have been particularly shown and described with reference to exemplary embodiments thereof it will be understood by those of ordinary skill in the art that various changes in form and details may be made therein without departing from the spirit and scope of the embodiments as defined by the following claims. The embodiments should be considered in descriptive sense only and not for purposes of limitation. Therefore the scope of the invention is defined not by the detailed description of the invention but by the appended claims and all differences within the scope will be construed as being included in the embodiments.

