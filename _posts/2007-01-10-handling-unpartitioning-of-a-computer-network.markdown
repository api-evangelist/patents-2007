---

title: Handling un-partitioning of a computer network
abstract: A system and method for handling un-partitioning of a computer network are disclosed. Routing information may be stored on a first node in the network when the network is partitioned into a first group of nodes and a second group of nodes, where the first node is in the first group of nodes. Storing the routing information on the first node may include storing information usable to route messages to nodes in the first group of nodes. A technique for determining when the second group of nodes has become un-partitioned from the first group of nodes (i.e., for determining when the partition has been repaired) may be employed. In response to determining that the second group of nodes has become un-partitioned from the first group of nodes, the routing information on the first node may be modified. Modifying the routing information on the first node may include storing information useable to route messages to nodes in the second group of nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07899934&OS=07899934&RS=07899934
owner: Symantec Corporation
number: 07899934
owner_city: Mountain View
owner_country: US
publication_date: 20070110
---
This application is a divisional of U.S. patent application Ser. No. 10 403 562 now abandoned entitled HANDLING UN PARTITIONING OF A COMPUTER NETWORK filed Mar. 31 2003.

This invention relates to computer networks and more particularly to a system and method for handling un partitioning of a computer network.

Distributed computing has become increasingly popular as computer networks have proliferated. A wide variety of network protocols and network routing techniques are in use today. One protocol in widespread use is the Transmission Control Protocol Internet Protocol TCP IP used for Internet communication. TCP IP is based on a model that assumes a large number of independent networks are connected together by gateways called routers. The collection of interconnected IP networks is uniformly addressed by an IP address. The routing used to provide network independent addressing is transparent to client and target software. All a client needs to know to send a message to a target is that target s IP address. TCP enforces an ordered delivery of messages. The concept of a message response with data is not directly supported by TCP but instead is provided by the application layer.

Another network protocol in widespread use is the User Datagram Protocol UDP . No reliable connections are established in the UDP protocol and thus no guarantees of message delivery are made. UDP also does not enforce an ordered delivery of messages. Like the TCP protocol the concept of a message response is not directly supported by UDP but instead is provided by the application layer.

One type of networking is referred to as peer to peer or P2P networking. Peer to peer networking has seen rapid growth. As used herein a peer to peer network is generally used to describe a decentralized network of peer nodes where each node may have similar capabilities and or responsibilities. Participating peer nodes in a P2P network may communicate directly with each other. Work may be done and information may be shared through interaction between the peers. In addition in a P2P network a given peer node may be equally capable of serving as either a client or a server for another peer node.

A peer to peer network may be created to fulfill some specific need or it may be created as a general purpose network. Some P2P networks are created to deliver one type of service and thus typically run one application. For example Napster was created to enable users to share music files. Other P2P networks are intended as general purpose networks which may support a large variety of applications. Any of various kinds of distributed applications may execute on a P2P network. Exemplary peer to peer applications include file sharing messaging applications distributed information storage distributed processing etc.

Various embodiments of a system and method for handling un partitioning of a computer network are disclosed. According to one embodiment a plurality of nodes may be coupled to each other to form the network. Coupling the plurality of nodes to each other may comprise creating a plurality of links. Each link may comprise a virtual communication channel between two nodes.

In some cases the network of nodes may become partitioned. As used herein the network is partitioned if there are at least two nodes in the network node A and node B such that there is no sequence of links starting from node A and connecting eventually to node B. In this situation the network has essentially become separated into two or more groups of nodes where nodes in one group cannot communicate with nodes in another group.

According to one embodiment of the method routing information may be stored on a first node in the network when the network is partitioned into a first group of nodes and a second group of nodes where the first node is in the first group of nodes. Storing the routing information on the first node may comprise storing information usable to route messages to nodes in the first group of nodes.

A technique for determining when the second group of nodes has become un partitioned from the first group of nodes i.e. for determining when the partition has been repaired may be employed. In response to determining that the second group of nodes has become un partitioned from the first group of nodes the routing information on the first node may be modified. Modifying the routing information on the first node may comprise storing information useable to route messages to nodes in the second group of nodes or modifying the previously stored routing information to enable messages to be sent to nodes in the second group of nodes .

In one embodiment storing the routing information on the first node before the network becomes un partitioned may comprise storing information usable to route messages to a first one or more instances of a first network address e.g. a first one or more instances of a role where the first one or more instances of the first network address are located on nodes in the first group of nodes. In this case modifying the routing information on the first node after the network becomes un partitioned may comprise storing information usable to route messages to a second one or more instances of the first network address wherein the second one or more instances of the first network address are located on nodes in the second group of nodes.

In one embodiment the method may further comprise performing a recovery operation to re build routing information on the first node after determining that the second group of nodes has become un partitioned from the first group of nodes.

In various embodiments any technique or algorithm may be utilized to determine that the network has become un partitioned. An exemplary algorithm is described below.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

As shown nodes A E may be coupled through a network . In various embodiments the network may include any type of network or combination of networks. For example the network may include any type or combination of local area network LAN a wide area network WAN an Intranet the Internet etc. Example local area networks include Ethernet networks and Token Ring networks. Also each node may be coupled to the network using any type of wired or wireless connection mediums. For example wired mediums may include a modem connected to plain old telephone service POTS Ethernet fiber channel etc. Wireless connection mediums may include a satellite link a modem link through a cellular service a wireless link such as Wi Fi a wireless connection using a wireless communication protocol such as IEEE 802.11 wireless Ethernet Bluetooth etc.

The peer to peer network may comprise a decentralized network of nodes where each node may have similar capabilities and or responsibilities. As described below each node may communicate directly with at least a subset of the other nodes . Messages may be propagated through the network in a decentralized manner. For example in one embodiment each node in the network may effectively act as a message router.

Referring now to a diagram of one embodiment of a node in the peer to peer network is illustrated. Generally speaking node may include any of various hardware and software components. In the illustrated embodiment node includes a processor coupled to a memory which is in turn coupled to a storage . Node may also include a network connection through which the node couples to the network .

The processor may be configured to execute instructions and to operate on data stored within memory . In one embodiment processor may operate in conjunction with memory in a paged mode such that frequently used pages of memory may be paged in and out of memory from storage according to conventional techniques. It is noted that processor is representative of any type of processor. For example in one embodiment processor may be compatible with the x86 architecture while in another embodiment processor may be compatible with the SPARC family of processors.

Memory may be configured to store instructions and or data. In one embodiment memory may include one or more forms of random access memory RAM such as dynamic RAM DRAM or synchronous DRAM SDRAM . However in other embodiments memory may include any other type of memory instead or in addition.

Storage may be configured to store instructions and or data e.g. may be configured to persistently store instructions and or data. In one embodiment storage may include non volatile memory such as magnetic media e.g. one or more hard drives or optical storage. In one embodiment storage may include a mass storage device or system. For example in one embodiment storage may be implemented as one or more hard disks configured independently or as a disk storage system. In one embodiment the disk storage system may be an example of a redundant array of inexpensive disks RAID system. In an alternative embodiment the disk storage system may be a disk array or Just a Bunch Of Disks JBOD used to refer to disks that are not configured according to RAID . In yet other embodiments storage may include tape drives optical storage devices or RAM disks for example.

Network connection may include any type of hardware for coupling the node to the network e.g. depending on the type of node and type of network . As shown in memory may store lower level network software . The lower level network software also referred to as link layer software may be executable by processor to interact with or control the network connection e.g. to send and receive data via the network connection . The lower level network software may also be responsible for discovering or setting up communication links from the node to other nodes. Memory may also store topology and routing T R layer software which utilizes the lower level network software . Memory may also store client application software which utilizes the T R layer software .

The T R layer software may be executable by processor to create and manage data structures allowing client application software to communicate with other nodes on the peer to peer network e.g. to communicate with other client application software executing on other nodes . The client application software may utilize the T R layer software to send messages to other nodes . Similarly the T R layer software may pass messages received from other nodes to the client application software e.g. messages which originate from client application software executing on other nodes . The T R layer software may also be involved in forwarding messages routed through the local node where the messages originate from another node and are addressed to another node in the network . Functions performed by the T R layer software are described in detail below.

In one embodiment nodes may be organized into multiple realms. As used herein a realm refers to a concept used to organize the network into sections of nodes that communicate with each other in a low latency reliable manner and or physically reside in the same geographic region. For any given node links may be built from the node to its near neighbors as well as to remote neighbors. As used herein a near neighbor is a node that resides in the same realm as the reference node and a remote neighbor is a node that resides in a different realm than the reference node. In one embodiment the T R layer software may be operable to utilize realm information to restrict send operations to the local realm. This may be useful for example to avoid the overhead of a WAN transfer. An application programming interface API for sending a message may allow the client application software to specify whether or how to restrict the send operation in this manner.

In various embodiments the peer to peer network may be utilized to perform any of various kinds of applications. As one example client application software may execute to perform distributed data storage such that data is distributed across various nodes in the peer to peer network . However in various embodiments any of various kinds of client application software may utilize the T R layer software to send and receive messages for any desired purpose.

As shown in in one embodiment the functionality of the T R layer software may be modularized into builder functionality and router functionality. For example a builder component or engine may be responsible for creating and managing data structures or routing information representing topology of the peer to peer network . A router component or message routing engine may utilize the data structures or routing information to send or forward messages to other nodes in the network . The builder and router may interface with each other as necessary. For example as described below in the event of a network failure which invalidates existing routing information the router may request the builder to recover or rebuild routing information so that the router can send or forward a message using a different route.

In one embodiment as each node joins the peer to peer network the node may establish links with at least a subset of other nodes in the network . As used herein a link comprises a virtual communication channel or connection between two nodes . The lower level network software may be responsible for performing a node discovery process and creating links with other nodes as a node comes online in the network . The lower level network software may include a link layer which invokes a node discovery layer and then builds virtual node to node communication channels or links to the discovered nodes. The resulting set of connected nodes is referred to herein as a link mesh . illustrates an exemplary link mesh for a set of nodes . Each hexagon represents a node and each line represents a link between two nodes .

According to one embodiment the T R layer software may provide client application software with a tree based view of the underlying link mesh as a means of exchanging messages between nodes . As used herein a tree may comprise an undirected acyclic and connected sub graph of the underlying link mesh . Each vertex in a tree may be a node . Each connection between nodes in a tree is referred to herein as an edge. Thus each tree effectively comprises a subset of the link mesh.

As described below a portion of the T R layer software e.g. builder executing on the nodes may be operable to create tree data structures based on the link mesh . Multiple trees may be created based on the link mesh . Client application software may utilize the trees to send messages to other nodes . For example client application software executing on a node A may invoke router on node A through an application programming interface API . Router may send the client s message to another node B. Router executing on node B may forward the message to another node C and so on until the message arrives at its destination node X. At each node the message may be forwarded according to routes based on a tree created by builder on the respective node. For example a route may specify a tree edge over which to send the message. Thus at each node the message may be sent over one of the tree edges which may be mapped to one of the node s links i.e. the virtual communication channel used to actually send the message.

Router executing on destination node X may notify client application software executing on node X of the received message and client application software may process the message accordingly. As described below the T R layer software may also handle one or more responses returned by the client application software at node X to the client application software at sender node A. These responses may include a variable amount of application data.

Using trees as a basis for sending messages between nodes may be advantageous in several ways. As described below each tree may have one or more nodes that may be addressed by a role . Each message may be addressed to a particular role on a particular tree. Thus when the message is sent to the role associated with the tree only nodes attached to the specified tree or a subset of nodes attached to the specified tree see the message e.g. as opposed to all nodes on the link mesh seeing the message. The T R layer may also be able to detect and discard duplicate messages automatically. Also an ordered delivery of messages may be enforced based on the position of the sender node and receiver node s on the tree.

In one embodiment the concept of a message response may be directly supported by the T R layer. As described above the concept of a response including data is not directly supported by protocols such as UDP or TCP but instead must be provided by the application layer. Thus application programmers for a client application that utilizes the T R layer may be relieved from the burden of implementing a separate response protocol. In other words the concept of a message response including data may be integrated in a sender to receiver back to sender protocol provided by the T R layer. As described below in one embodiment each message sent may have a variable number of responses.

To send a message client application software may create a data structure that contains an application header and application data . The client application software may then request the T R layer software to send the message including the application header and application data to client application software executing on another node . It is noted that both instances of the client application software may utilize a common tree.

Before invoking the lower level network software to send the message to the destination node the T R layer software at the sender node may create its own data structure including a T R layer header and the message received from the client application. Similarly a link layer and transport layer may build their own data structure including their own respective headers as shown in . On the receiving end of the message transfer each protocol layer e.g. transport link and T R may un wrap its own message from its header until finally the client application software at the destination node receives its message.

Most message based protocols require some addressing scheme to name a destination endpoint as the target of a message. IP based protocols for example use an IP address to name a node on a network.

According to one embodiment of the T R layer message addressing is based on the concept of a role . As used herein a role may refer to a location independent address for a computer network. A location independent address may comprise information usable to address a message without specifying where the message recipient is located in the network e.g. without specifying a particular node in the network.

The T R layer may include an interface allowing client application software to create a role on one or more nodes on a tree more specifically the client application software may create an instance of the role on each of the one or more nodes . Each node on which an instance of the role is created is said to have the role or host the role or host an instance of the role . In one embodiment each role may be identified using a string e.g. the name of the role. In other embodiments roles may be identified in other ways e.g. using integers.

Thus a complete network address for sending a message may comprise information identifying a tree and a role on the tree. For example in one embodiment the tree may be identified using a tree ID such as a 128 bit Universally Unique ID UUID and a role may be identified using a variable length string. Universally Unique IDs or UUIDs may be allocated based on known art which ensures that the UUIDs are unique. Any node may allocate a UUID without having to communicate with another node which may be advantageous in terms of efficiency. 

In another embodiment a network address for sending a message may also include information identifying a portion of client application software to receive the message. For example the network address may also include information identifying a protocol ID associated with a client application that utilizes the T R layer. Multiple protocols may utilize the same tree. Thus each message may be sent on a particular tree and more particularly to a particular set of nodes on the tree i.e. the nodes having the specified role. As the message arrives to each node on the specified tree and having the specified role the protocol ID may be used to determine which protocol on the node or which portion of client application software receives the message. In another embodiment there may not be multiple protocols or a message may be sent without specifying a particular protocol ID. If no protocol ID is specified the message may be delivered to all protocols bound to the tree.

Any semantic meaning associated with a role may be done so by the client application and not by the T R layer. For example roles such as owner or instrumentation manager may appear to the T R layer as just two different strings that each designate a separate target on a tree for message transfers. The T R layer may treat client application messages simply as a set of bytes.

Sending messages to roles instead of directly to nodes may have a number of advantages. For example a given role may be assigned to any tree vertex node and the role may move from node to node dynamically. Also a single role may be assigned to multiple tree nodes. Thus a message addressed to the role may reach each of the nodes which have the role.

Role based addressing may also allow distributed software to run in a peer to peer manner. Nodes do not need to keep track of global state such as knowing which other nodes are present on the network or which roles are bound to which nodes. A node may simply accomplish an operation by routing a message to a particular role without needing to know which particular node or nodes have the role.

A role which is restricted to a single node is referred to herein as an exclusive role. A role which is associated with multiple nodes is referred to herein as a non exclusive or shared role. It is noted that a non exclusive role may be associated with a single node. Each instance of a shared role may have an associated role instance ID such as a 128 bit UUID.

Each node may maintain a list of role instances which are associated with that node for each tree i.e. a list of local role instances hosted by that node. The node may also maintain routing information that allows messages to be routed from the node to remote instances of the role i.e. role instances associated with or hosted by other nodes. For example the routing information may define one or more edges for the node. Each edge may be mapped to one of the node s links and may be used to route a message to one or more remote instances of a role. Each link may support many mapped tree edges. Thus at each node along the message path from a sender node to the target node s the node may deliver the message to a local instance of the role if there is one and may forward the message to other role instances using the respective edge or edges.

In one embodiment at each node the routing information for a given role may include information directly specifying how to route a message to every instance of the role. For example for each node the node may have an edge associated with each instance of the role where each edge points to another node to which or via which the message can be sent to the respective role instance. The role name and the instance ID for the respective instance of the role may be associated with each edge allowing the edges to be disambiguated for shared roles.

In another embodiment the routing information at one or more nodes may include information directly specifying how to route a message to only a subset of the role instances. Thus if there are N instances of the role a given node may have knowledge of less than N instances of the role. As one example a first node may have knowledge of only a single instance of the role. For example the first node may have an edge associated with a particular instance of the role such that messages addressed to the role are routed to a second node to which the edge points. The second node may in turn have two or more edges each associated with different role instances such that messages addressed to the role and received from the first node are forwarded by the second node to multiple nodes and continuing in this manner until each instance of the role receives the message.

The embodiment in which nodes can have routing information regarding only a subset of the role instances may allow nodes to leverage each other s knowledge. Thus routing data may be localized i.e. the routing data does not have to be published to every node on the tree. This may increase efficiency of the system. Allowing nodes to leverage each other s routing information may also enable recovery operations to operate more efficiently to rebuild routing information after a link failure.

One example of a technique for allowing a given node to maintain routing information for less than all N instances of a role is to utilize scoped roles. In a system employing scoped roles each node that does not host an instance of the role must know how to reach only one node that has the role if there is one . Each node that does host an instance of the role must be able to eventually reach all other nodes that host an instance of the role.

Client applications may utilize an API to manage roles in various ways. For example in one embodiment client applications may be able to perform the following tasks related to roles 

Client application software may create or publish a role by requesting the T R layer to publish the role in order to establish an address on a tree. The client application software may also remove or un publish the role to remove the address. In one embodiment creation publication and removal un publication of roles may also be initiated by the T R layer. The process of publishing a role instance may cause a series of edges to be created from a set of potential sender nodes to the target node on which the role instance is published.

In one embodiment publishing a role instance is accomplished by broadcasting publish messages from the publishing node to other nodes. In one embodiment the publish message may be broadcast using a particular broadcast scope as described below. At each node that receives the publish message an edge may be created that maps upon the link over which the publish message was received or an existing edge may be updated with information to indicate that the edge is also usable to route messages toward the new role instance . The result is a series of edges distributed over a set of nodes each edge pointing toward the role instance that was published. Un publishing a role may cause existing edges to the role to be removed.

Each node that receives the publish message may forward the publish message to one or more other nodes e.g. according to the broadcasting scope used. In one embodiment a node which receives the publish message and already hosts another instance of the role may not continue forwarding the received publish message for the new instance. This may allow the type of routing data localization described above.

The publish message may include a message ID e.g. a UUID that uniquely identifies the respective publish operation. This enables the publish message to be distinguished from any other message being sent. Each node that receives the publish message may stop forwarding the publish message if the node has already received the publish message as identified by its message ID .

As noted above in one embodiment the publish message as well as other types of messages may be broadcast using a particular broadcast scope. For example a broadcast on all links a broadcast on tree or a broadcast on role routes type of broadcast may be performed. The type of broadcast may determine what links are chosen at any given node to continue forwarding the message. For the broadcast on all links type the message may be sent on all links from each node that receives the message. For the broadcast on tree type the message may be sent on all links that correspond to existing edges of the tree i.e. edges that were created by previous publish operations . For the broadcast on role routes type the message may be sent on all links that correspond to edges pointing to previously published instances of the role.

In the case of a broadcast on tree operation if the tree is not fully built described below at the local node the message is forwarded over all links from that node. This does not affect how further nodes forward the message. Similarly in the case of a broadcast on role routes operation if the role is not fully built described below and if the tree is fully built then the broadcast reverts temporarily to broadcast on tree. If the role is not fully built and the tree is also not fully built the broadcast reverts temporarily to broadcast on all links.

In one embodiment the information that is broadcast for a Publish operation or an Un publish operation may include 

As noted above a role instance may be designated as exclusive when it is the only instance of the role. Publishing a role instance as an exclusive instance of the role may cause any existing edges to other instances of the same role to be removed or overwritten. In the event that a simultaneous publish of role instances is attempted where each instance is intended to be exclusive the instance IDs of the role instances may be used to ensure that only one role instance is actually recognized. For example the role with the largest or smallest instance ID value may win.

An un publish operation for an exclusive role instance may cause all edges to the role to be removed on all nodes. An un publish exclusive operation may be performed even when there is no local role instance to remove.

It is possible that one or more nodes in a network may fail. illustrate the process of publishing a role on a network in which a node has failed.

When nodes or links fail affected tree edges i.e. those edges mapped to the broken link or links become broken and need to be repaired. In one embodiment trees may be allowed to remain with broken edges in an incomplete state such that not all routes to all roles have been determined at every node. Each tree may be repaired or recovered independently at the time the tree is next needed by a send operation. The recovery operation may result in not finding some roles if a node with a role no longer exists. Therefore the T R layer may employ a timeout mechanism to terminate the recovery operation if necessary. Tree recovery is described in detail below.

In one embodiment it may also be the case that temporary cycles exist in a tree. The T R layer may be operable to detect cycles and fix them with no loss of messages or message ordering. Detecting and breaking cycles is described in detail below.

As described above a message addressed to a role or virtual network address may be sent to a set of physical nodes attached to a single tree by utilizing a series of edges. The physical location of the role or virtual network address may advantageously be re mapped. As noted above roles may dynamically move from one node to another node. The T R layer may move or re assign a role from one node to another node when instructed to do so by the client application software. For example in one embodiment the message response mechanism provided by the T R layer may include an option allowing a message receiver node the current role owner to give up the role to a node which sends a request role message. Thus the role may move from the message receiver to the message sender. The message receiver node may also grant the role to the message sender node without giving up the role so that the two nodes each have an instance of the role.

When the role is granted without give up the sender node may publish a new instance of the role. In one embodiment moving the role from the message receiver node to the message sender node i.e. when the receiver node gives up the role may be accomplished by first un publishing the role from the receiver node and then publishing the role at the sender node. In a more efficient embodiment however edges on affected nodes may simply be re pointed toward the sender node eliminating the need to un publish the role and re publish the role at the new location. In this re pointing operation edge updates may be localized to just those nodes along the message path from the sender node new role holder to the receiver node previous role holder .

As described above client applications and the T R layer may view the peer to peer network as a set of trees each with a set of assigned roles. Routing may occur from a sender to a role within the context of a single tree. Each node in the peer to peer network may act as a message router.

As described above messages may be routed by associating a series of edges with a role. At each node along the message path an edge or multiple edges at that node serves to point towards the target node or nodes that has the desired role. Some nodes that route messages may also be a message destination. Other nodes may act solely as a router never assuming a role. Messages may continue to be routed until all role instances have been reached.

As noted above each tree may have an associated ID which identifies the tree. For example in one embodiment a tree ID may comprise a unique 128 bit UUID. The tree ID may be valid for all network nodes. In one embodiment the T R layer may accept the tree IDs from client application software as a means for naming the trees. In another embodiment the T R layer may be responsible for creating the tree IDs.

The T R layer software may associate edges with each tree ID. As described above each edge may be mapped onto an underlying link. This mapping may give each edge a direction away from the local node and towards another node. For each edge one or more roles that are found in the direction of the edge may be associated with the edge.

The T R layer software on each node may maintain routing information. For example for each particular tree for which the node has routing data the node may have information specifying roles on the tree to which the node has routes. For each of these roles instances of the role may be mapped to edges as described above.

In one embodiment the routing information may include routing entries stored in one or more routing tables. In various embodiments the routing entries may be structured in any of various ways and may comprise information of varying levels of granularity. For example in one embodiment each routing entry may be associated with a particular role and a particular tree and may specify one or more edges that point toward instances of the role.

According to one embodiment two routing tables may be used to hold routing entries. The first routing table is referred to herein as the primary routing table. The primary routing table may be stored in the memory of the node. The second routing table is referred to herein as the secondary routing table. The secondary routing table may be stored in the storage of the node. In one embodiment the routing entries in both the primary routing table and the secondary routing table may be the same. In another embodiment the primary routing table may be used to store the most recently used routing entries and the secondary routing table may be used to store other routing entries. Routing entries may be swapped in and out of the primary routing table from the secondary routing table as necessary similar to the manner in which data is swapped in and out of a memory cache. In another embodiment there may be only one routing table.

In one embodiment information regarding local role instances for the node may not be maintained in the routing table s . The information regarding local role instances may be maintained as long as a node is up. If a node fails routing information for remote roles may be rebuilt when the node comes back up.

As the number of nodes in the network increases one or more of the nodes may run out of memory and may also possibly run out of storage so that all edges to all roles throughout the network cannot be maintained on the local node. In one embodiment this problem may be solved by enabling the T R layer to remove least recently used routing entries from the routing table as necessary. For example for a routing table stored in the memory if an out of memory situation occurs or is near for the memory or if a routing table reaches a maximum size then the routing entry that was least recently used may be removed from the routing table e.g. so that a new routing entry can be added in its place. Similarly for a routing table stored in the storage if an out of storage situation occurs or is near for the storage or if the routing table reaches a maximum size then the routing entry that was least recently used may be removed from the routing table. This may allow new routing entries to be added to the routing tables as necessary.

If at a later time the node ever needs a routing entry that was replaced in the table the routing entry may be re created. For example if the routing entry corresponded to a first tree and the node needs to forward a message addressed to a role on the first tree then the first tree may be rebuilt or information regarding the first tree may be re acquired.

As used herein a role is said to be fully built on any given node when edges leading to all instances of the role on all other nodes have been created for that node or when the node has sufficient edges so that a message addressed to the role eventually reaches all instances of the role when sent in the manner described above. For example a role on a given node may be fully built when the node has sufficient edges to neighbor nodes such that a message sent to the role using those edges is ensured to reach all instances of the role provided that the neighbor nodes each ensure that they are fully built before forwarding the message.

In one embodiment roles may be scoped meaning that a node that does not have a role must know how to get to only one node that has the role if there is one . Nodes that do have the role must be able to eventually reach all other nodes with that role.

In one embodiment a role is considered fully built once one of the following conditions has been met 

A tree is said to be fully built on any given node if all of the tree s roles are fully built on that node. It is noted that in some situations a tree may be marked fully built while a role associated with the tree is marked not fully built. This may occur when a new role is published. The role may be initialized to not fully built while the tree is initialized to fully built. A tree may be marked as not fully built only if one of its roles has gone from fully built to not fully built. Once each of a tree s not fully built roles has been rebuilt and marked fully built the tree may be again marked as fully built.

In one embodiment when a new node joins the link mesh the node may need to gain access to trees. This may be accomplished by using a simple request response protocol that yields the set of known tree IDs. The new node may then create its own edges to point towards existing roles on the tree. Once this process is accomplished each tree and each of its roles may be marked as fully built for the new node.

When a link fails at a node all roles that have edges over the failed link may be marked as not fully built for the node. As noted above a recovery operation may be performed when necessary to send or forward a message to one of the roles that previously was pointed to by an edge over the failed link.

Because each role may be shared by different nodes a message sent to a single role may be delivered to many nodes that in turn send one or more responses or replies back to the sending node. In one embodiment the T R layer may utilize a session mechanism to support this one to many reply model. The session mechanism may facilitate the automatic routing of responses back to the original sending node.

According to one embodiment of the session mechanism a long lived state information element referred to herein as a breadcrumb may be stored at each node along the message path. The breadcrumb state information may point back via a link towards the original message sender. An initial breadcrumb may be created in response to each send operation. The initial breadcrumb may indicate that the original sender is on the current node e.g. may indicate this via a null link. As the message is forwarded on to other nodes a new breadcrumb may be created on each receiving node where the breadcrumb points back over the link by which the message was just received.

As a result a trail of breadcrumbs may compose a route from the target receiver node back to the original sender node and passing through all the intermediary forwarding nodes. When the receiver node responds to the message the incoming link specified in the breadcrumb may be used to route the response back to the sender. Similarly each of the forwarding nodes may use the links specified in their respective breadcrumbs to route the response back to the sender node.

In one embodiment breadcrumb elements may remain active until a response is marked as last reply. When all last replies from all receivers of the message have been received over a link the breadcrumb element at the local node may be deleted thus preventing any more replies. Thus the session may be created when the send operation is initiated and ended when all last reply responses have been processed. Each response whether it as a last reply response or not may be propagated to the sender as it is generated and may not be held by nodes along the message delivery chain.

In one embodiment an alternative means of ending the session using aggregated replies may also or may alternatively be provided. According to the aggregated reply model all responses may be held at a given node until all last reply responses have arrived at the node from target destinations to which the node forwarded the original message. Aggregated replies work by consolidating each individual response into a single response that is matched with the send that was previously issued. As the send operation fans out to more nodes responses are returned using the breadcrumb elements . The responses may be consolidated at each forwarding node. Not until the consolidated response is completely built with all individual responses included is the single consolidated reply passed back towards the original sender.

If a send has been issued and then a link fails at a node along the message delivery chain the T R layer software at the node where the link failed may automatically generate a response referred to as a null reply that indicates the failed link. This null reply may be treated like all other responses working in both aggregated and non aggregated sessions. If the sender receives no null replies the sender knows that it has received all the responses from the various receivers once the last reply comes back. However if a null reply comes back the sender knows it has not received all replies and thus may re send the message.

Also if no role instance can be reached then the T R layer software may return a role not found message to the sender. Thus the sender may receive either a role not found response or one or more responses with the last one indicated which in the absence of a null reply indicates that all responses have been received. These features may enable the sender to send messages without utilizing or depending on a timeout mechanism.

In various embodiments the T R layer software may determine that no role could be reached using any of various techniques. For example the router on a given node may experience the role not found condition when it can no longer reach any role instances. When this occurs a role not found message may be returned to the node that forwarded the message. However the role not found message may not be forwarded back any further unless that node receives a role not found message from all links over which the node forwarded the message. For example if node A forwards a message to nodes B and C and node B returns a role not found message to node A and node C returns a response other than a role not found message then the role not found message sent from node B to node A may be ignored. Thus for a role not found message to get all the way back to the sender all nodes that received the message must have been unsuccessful in attempting to reach the role.

In one embodiment the T R layer software may also or may alternatively support a one way send model in which replies to a message are not allowed and thus sessions are not utilized. For example one way send operations may be useful for broadcasting information that does not warrant a reply. Breadcrumb elements may not be created when a one way send operation is performed.

In one embodiment the T R layer may support listener ports through which client application software at a given node can listen for messages. A listener port may connect one or more listening clients with one or more trees that are bound to the listener port. Client application software can listen to all messages sent on a tree even those not addressed to the local node. Client application software that listens to all messages regardless of role is referred to herein as a snooper. illustrates the snooper concept.

Client applications may utilize application listener ports to receive information from the T R layer. For example through application listener ports client applications may be notified of messages received from senders responses to messages replies from receivers and events fired. A listener port is somewhat similar to the concept of a socket. Client software listeners may be added to and removed from a listener port.

Also the listener port may be opened and closed as desired. Each listener port may implement an interface to accept events generated by the T R layer messages and responses to messages.

Each listening client may supply the T R layer software with a set of callback methods or functions. These callback methods or functions may be invoked by the T R layer software when a message or response is delivered over the local node or when a message delivery cannot be accomplished. A listener method may also be called to announce the routing of a tree through a node. At each invocation the listening method may be passed a parameter specifying either a message being sent or a response being returned. As described below a listening client may perform any of various actions in response to a message or response.

In various embodiments a message and a response may be structured or implemented in any of various ways and may include any of various kinds of information. In one embodiment each message includes the following information 

As described above the T R layer may perform a tree building process. There are many situations in which a tree building process may be performed. For example tree building may be performed when 

In various embodiments any of various techniques may be utilized to build trees. In one embodiment trees may be built using local state and messages received from neighboring nodes. In one embodiment instead of using a tree building algorithm that avoids cycles cycles may instead be detected and broken. This may be more efficient than avoiding cycles. In one embodiment trees may not be immediately repaired when a link fails. If there are a large number of trees it may be too inefficient to repair all the trees. Instead each tree may be repaired as needed e.g. when a message send operation requires it.

A tree cache mechanism may be utilized to support more trees than can fit into memory at one time. Each node may maintain its own tree cache e.g. a primary or secondary routing table such as described above. The tree cache may include a list of known trees. The tree cache may be managed using a least recently used replacement policy as described above. In one embodiment the tree cache may be configured to utilize a no replacement policy if desired so that the size of the tree cache is unbounded. A tree built event may be fired to all listeners when a tree is added to a tree cache.

As shown in each node may maintain information related to the T R layer. The information may include information pertaining to local roles for all trees i.e. all roles which exist on that particular node. The information may also include tree cache information or routing information as described above. Each of the smaller rectangles illustrated within the tree cache in may represent a tree.

In various embodiments trees may be represented using any of various types of data structures. illustrates tree representation according to one embodiment. This tree representation makes it easy to get all links towards all instances of a role. It is also easy to get all links to perform a broadcast operation on a tree. It is also easy to update the tree representation in the event of a link failure described below . According to the tree representation shown in local roles may be maintained at all times while the local node is up. Routes to remote role instances however can be rebuilt.

As described above the T R layer may utilize the concept of fully built roles and fully built trees. illustrates a state machine showing state changes for the fully built status. As shown when a new node joins the network and gets on all trees all fully built trees each of the trees and all its roles may be marked as fully built. Also once a recovery operation completes for building routes to a particular role the role is marked as fully built. also illustrates that when a link fails all roles that have routes over the failed link and the trees with which the roles are associated are marked as not fully built. Also in some situations when breaking routes or reversing routes roles may be marked as not fully built. Changes in the fully built status of roles and trees are discussed in more detail below.

In one embodiment broadcast operations may be performed at various times during the tree building process. Several types of broadcast operations may be performed including a broadcast on all links a broadcast on a given tree or a broadcast on all role routes.

For the broadcast on all links operation an initial node may send a message on each of its links identifying the message with a unique message ID. Each receiving node may then recursively send the message on each of its links. In one embodiment each receiving node may be allowed to modify the message. Receiving nodes may maintain a hashmap keyed by message ID so that messages can be dropped to eliminate cycles. The message is thus effectively sent to all nodes in a tree fashion. One exemplary use of the broadcast on all links operation is to send a Got trees message i.e. a message sent during the process of a node getting on all trees at node startup time.

The broadcast on tree operation may be performed similarly to the broadcast on all links operation except a specific tree is specified. Each time a node forwards the message the specified tree is used provided that the tree is fully built for that node. If the tree is not fully built for that node then the message may be sent on all of the node s links. Cycles may be eliminated similarly as for the broadcast on all links operation.

The broadcast on role routes operation may be performed similarly to the broadcast on all links operation except a specific role on a specific tree is specified. Each receiving node may forward the message on all the links that correspond to routes to the specified role provided that the role is fully built for that node. If the role is not fully built for that node then the message may be sent on all of the node s links. Cycles may be eliminated similarly as for the broadcast on all links operation. One exemplary use of the broadcast on role routes operation is to recover routes to the role. Another exemplary use is to publish an instance of a role.

When a node joins a network the network may already have trees unless the network is new. In one embodiment the following process may be performed for a node to get on all trees. First the node may broadcast a Got trees message using the broadcast on all links operation described above. If no response is received within a given timeout interval then the process may be done since there are no trees . illustrate an exemplary tree building process when a group of nodes joins a network and a tree spanning the nodes is built. If it is determined that there are trees and the node is not on all trees then the node may request all trees from each neighbor. If not on all trees each neighbor may in turn request all trees from its neighbors in a recursive manner. Cycles may occur but only one request to each neighbor is performed. Once a node is on all trees the node may supply all the trees to each requesting neighbor. A receiver of trees may receive some trees from each neighbor to avoid getting all trees over one link.

As described above in one embodiment of the T R layer a message routing engine may manage the routing of messages. The message routing engine on a particular node may be invoked by a client application using an application programming interface API or may be invoked in response to receiving a message via a link.

Client applications which receive a message from a sender may reply to the message with one or more responses. The response s may be routed back to the sender over the same route that was used to send the message. The API for sending a response may include parameters specifying the ID of the message being responded to the response e.g. an array of bytes and size of the array as well as parameters specifying various options.

In one embodiment the concept of a session may be utilized to allow a message sender to receive multiple responses to a message. A last reply Boolean value e.g. a value included in the response header or a parameter passed when sending a response may be set to True when the last response to the message is sent. illustrates an exemplary session. As shown a sender sends a message to a receiver. The receiver sends four response messages back to the sender. In the fourth response message last reply is indicated.

The message routing API may also allow a sender to send a message to only one role instance. The send process may be complete once a first role instance receives the message. The session may continue until the last reply from that instance. In one embodiment the T R layer may support aggregate responses such that the sender receives a single response message which includes all responses from all receivers. The client application listener on the sender may not be invoked until all responses have been received. Thus the client application may synchronize with multiple responses.

In another embodiment the sender may receive each response as a separate response message. In one embodiment the T R layer may support one way messaging so that responses by receivers of a message are not allowed. In one embodiment each message may be handled using the messaging technique desired by the sender e.g. aggregated responses separate responses or no responses.

In one embodiment responses may flow back to the message sender over the original path by which the message was received. illustrates an exemplary network in which a message is sent from a sender node to a receiver node . For example the message may be addressed to a role on the receiver node . The path of the message is illustrated. As shown in a reply sent by the receiver node is sent over the same path.

As noted above the API for sending a response may include parameters specifying various options or other information related to the response. For example the receiver of the message may send the response with a parameter to give up a role and or grant a role to the sender e.g. in response to a request for the role sent by the sender. Valid combinations may include 

As another example the response may be sent with a last reply parameter indicating that the response is the last reply to the message as described above. Any given recipient of the original message may set the last reply parameter to True only once.

In one embodiment the T R layer may change the last reply parameter in some situations. For example if last reply is set to True a node forwarding the response along the route may change last reply to False if the node has an outstanding link on which it has not yet received a response with last reply set to True or if the node has not yet received a response from a local client a client application on that node which received the original message from the sender with last reply set to True. This ensures that the sender receives only one response with the last reply parameter set to True even though multiple responses may originally be sent from receivers of the message with the last reply parameter set to True. In another embodiment the sender may always receive response messages having the original last reply parameter values set by the respective recipients and the sender may keep track of which recipients it has received a last reply from and which it has not.

As noted above when a recipient node with a role instance issues a reply with a give up role parameter set to True the role instance may move to the sender node. In one embodiment this may be accomplished by performing an un publish operation to remove the role instance from the recipient node followed by a publish operation to add the role instance to the sender node. However in another embodiment a more efficient technique of moving the role instance to the sender node may be utilized. The more efficient technique is based on the observation that only routes maintained by nodes along the path of reply which is the same as the path over which the original message was sent need to change. Thus each time after the reply with the give up role True parameter is forwarded by a node the route on that node may be re pointed to point in the direction in which the reply was forwarded. Thus the next time that node receives a message addressed to the role the message may be routed in the direction of the node which now has the exclusive instance of the role i.e. in the direction of the original sender node which requested the role .

In various embodiments any of various kinds events may be generated by the T R layer in response to certain situations. Client applications may be notified of particular events through application listener ports. The following describes some exemplary events which the T R layer may utilize.

Tree Built event indicates that a tree has been constructed or a tree object has been instantiated. The Tree Built event may include information identifying the protocol e.g. client of the T R layer that caused the tree to be created. Thus applications may learn about new trees by receiving Tree Built events. As described below in one embodiment an application may create a snooper in response to a Tree Built event.

Role Not Found event indicates that a message was not delivered to any instance of the role to which it was addressed.

As shown in in one embodiment the T R layer may allow client software to act as a snooper. A snooper may intercept messages sent from a sender to a receiver and may intercept any responses sent from the receiver to the sender. The snooper client may be located on any node between and including the sender node and receiver node. In various embodiments the snooper may be able to take any of various actions in response to intercepting a message or response message. For example the snooper may simply allow the message or response to continue on its way unaffected. The snooper may also alter the contents of the message or response if desired or may replace the message or response with a completely different message or response. Response messages may be appended or replaced. The snooper may also consume or suspend the message or response if desired. The snooper may resume suspended messages or responses at a later time. The snooper may also store the message or response data before allowing the message or response to continue or may perform any of various other actions on the message or response data.

The snooper may also be able to get information regarding the message or response message. For example in one embodiment the message or response message may have an associated message information object having methods such as 

Each receiver of a message e.g. the intended client recipient or a snooper may receive information regarding where the message currently is in the message path. For example in one embodiment each receiver may receive an Endpoint Boolean and a HasRole Boolean. An Endpoint value of True indicates that the local node is an endpoint for the message no more roles to reach . An Endpoint value of False indicates that the local node is somewhere in the middle of the delivery chain. In this case the receiver may be a snooper. The HasRole Boolean indicates to the receiver whether the local node has an instance of the role to which the message is addressed.

It is noted that an Endpoint Boolean may also be used during the routing of replies back to the original sender of a message. The Endpoint Boolean for a reply is False until the reply reaches the sender.

The T R layer may track or record various types of information related to sending messages. For example the message routing engine may track or record information indicating 

A message record may be created when a message is sent or when a message is received. The message record may be used to track the incoming link for the message and or the outgoing links for the message. The message record may also be used to track outstanding replies for the message. In one embodiment the T R layer may be operable to perform a sweeping operation to clean up or discard old message records. The time period at which sweeping operations are performed may be configurable.

The T R layer may be operable to perform recovery operations in response to a link failure e.g. a condition in which messages cannot be sent over a link in the link mesh. For example routes that use the failed link may be recovered so that messages can be sent to their destinations using different links. This section describes recovery operations which may be performed according to one embodiment.

In one embodiment trees may not be immediately rebuilt at link failure time. To process the link failure the following may be performed 

For all send operations over the failed link the T R layer may return a null reply which indicates the link failure to the sender. This may be performed when the router has forwarded a send request over the failing link and the last reply over that link has not yet been received.

The actual recovery of a route which utilized the failed link may be performed later when required by a send operation. At any node along the message delivery chain the role to which the message is addressed may not be fully built. If so the message routing engine may call a method e.g. recoverRoute to rebuild routes to the role. The ID of the message being sent may be passed to the recoverRoute method. After the routes have been recovered rebuilt a method e.g. routeReady may be called to to notify the message routing engine. The ID of the message may be passed to the routeReady method to indicate that the message routing engine may resume routing the message using the recovered routes. This process is illustrated in .

In various embodiments any desired algorithm may be employed to recover or rebuild routes to role instances. This algorithm may be performed in response to the message routing engine requesting the routes to be recovered e.g. by calling a recoverRoute method as described above.

According to one embodiment of the route recovery algorithm the following may be performed. The node at which the recovery process is begun may begin by broadcasting a recovery request using the broadcast on role routes type of broadcast as described above. As described above since the role may not be fully built on this node the recovery request may initially be sent over all links corresponding to the tree. Each node which receives the recovery request may forward the recovery request on all the links used in routes to instances of the role provided that the role is fully built for that node. If the role is not fully built for that node then the recovery request may be forwarded as in broadcast on tree or broadcast on all links if the tree is not fully built operation.

Thus the recovery requests may be forwarded through the node network until they arrive at nodes that have instances of the role. When a recovery request arrives at a node that has an instance of the role the node may return a recovery response. The recovery response may be returned in the direction from which the recovery request came i.e. using the link by which the recovery request arrived. If a node that receives a recovery response does not already have a route to the role instance that generated the recovery response the node may update its routing table to indicate a route to the role instance that points in the direction from which the recovery response came.

The node may also propagate the recovery response back via a link by which the node received a recovery request so that each recovery response from each role instance continues to be propagated back until reaching the original node that initiated the recovery request broadcast.

Thus for each role instance routes may effectively be built backwards from the node that has the role instance to the original node that initiated the recovery request broadcast. Once the routes have been built this original node may forward the message being sent over the routes as described above.

In one embodiment a recovery request may not be forwarded further after reaching a node that has an instance of the role being recovered. As described above in one embodiment it is not necessary that each node have routing information for all instances of a role.

Suppose that node attempts to send a message to each instance of the role. Thus the message may be routed to node as indicated by the route arrows from node . However the role is not fully built at node . As described above the role may have been marked as not fully built in response to the failed links. Thus the route recovery algorithm may be initiated. As shown in and described above node may broadcast a recovery request on all links. The broadcast on each link is denoted by the wide arrows.

As shown in nodes that receive the recovery requests from node may forward the recovery requests. To simplify the diagram not all forwarded recovery requests are illustrated. As shown node may forward the recovery request over all of its links except the link from which it received the recovery request because the role is not fully built at node . However the role is fully built at node and . Thus nodes and may forward the recovery request only over links used in routes to instances of the role.

When node which has an instance of the role receives the recovery request from node node may respond by returning a recovery response to node as described above. The recovery response is indicated in by the curved arrow from node to node . Similarly node which also has an instance of the role may return a recovery response to node indicated by the curved arrow from node to node . As shown in nodes and may forward the recovery responses originating from the respective role instances to node since nodes and received their recovery requests from node .

As described above node may update its routing table to indicate a route to the role instance at node which points to node . Similarly node may update its routing table to indicate a route to the role instance at node which points to node . illustrates the resulting recovered routes to the respective role instances. Once the routes have been recovered node may forward the message received from node using the recovered routes.

Routes to role instances in the exclude list do not need to be recovered. Thus if a node having an instance of the role is on the exclude list then the node may not return a recovery response when the node receives a recovery request.

It is possible that a link may fail while the recovery algorithm described above is being performed. A node having an instance of the role receives the recovery request via a path over which the recovery response will be sent back. If any link on this path fails then the recovery response may not be received. Thus when a link fails on a node the node may return a link failure response for any pending recovery request. When the node that initiated the recovery request receives the link failure response the node may re issue the recovery request.

As noted above in one embodiment routes created according to the methods described above may result in a cycle when a message is propagated. In one embodiment cycles may be detected and routes may be changed to avoid or break the cycles. It may be more efficient to detect and break cycles than to avoid the creation of routes with cycles.

Routes for each role instance on the edge to be broken may be reversed. Routes for other roles may be invalidated or marked not fully built but not reversed. The routes may be reversed by pointing them in the direction of the incoming link by which the message was received. The reversal process may be continued in a backward manner toward the node which sent the message via the incoming link. Once arriving at a node that has other routes on other edges for instances of the same role the role may be invalidated marked not fully built at that node and the algorithm may be terminated. Also if the incoming link is null at a node e.g. the original sender of the message then the role may be invalidated at the node and the algorithm may be terminated.

This section describes exemplary application programming interfaces APIs which client application software may utilize to interface with the T R layer software. It is noted that these APIs are exemplary only and the method details given relate to one particular embodiment. Although the APIs and associated data types are presented as implemented in the Java programming language various other language bindings are contemplated.

Send This function passes an array of bytes from sender to all nodes holding the specified role. Inputs to this function include 

The following combinations of grant role and give up role flags are valid T T T F F x. The T T combination grants the role to the sender and also gives up its own local role. This combination is used to move an exclusive role. The T F combination grants the role but does not give the role up. This combination is used to distribute shared roles. The F x combination is used to indicate that a request role was denied. In this case the give up Boolean is ignored.

Listener ports serve as a callback registration point for those applications wishing to receive messages and replies to sent messages. Each port is associated with a protocol ID and can be bound to one or more trees and includes a list of listeners that are invoked in response to messages and replies arriving at a node. Ports are created with no listeners and without a binding to any tree. Note that it is only important to bind a port to a tree if a send is done which does not specify a protocol ID since such a send is delivered to the ports explicitly bound to the tree. Port listeners can augment the routing process by giving the following routing direction to the tree layer on a per message or reply response basis 

A port is named with a protocol ID. A single port can listen to multiple trees and all trees for sends that specify the protocol ID . A typical sequence of operations is 

CreateListenerPort This function creates a new port in the closed state. Each listening port is associated with a protocol ID that names the type of port. Inputs to this function include 

GetListenerPort This function returns the listening port that is associated with a specific protocol ID. Inputs to this function include 

GetListenerPort This function returns the listening port that is bound to a specific tree ID. Note that there may not be any listening ports bound to a tree as binding a protocol to a tree is only done when a protocol does a send without specifying the protocol ID. Inputs to this function include 

RemoveListenerPort This function closes and deactivates the listening port associated with a specific protocol ID. Inputs to this function include 

AddTree This function binds the listening port to the specified tree. This is only used by protocols that do a send without specifying a protocol ID. Inputs to this function include 

RemoveTree This function unbinds the listening port from the specified tree. Inputs to this function include 

RemoveListener This function unregisters the message callback interface with the T R layer. Inputs to this function include 

MessageReceived This function is invoked by the T R layer when a message arrives at the listening port. Inputs to this function include 

MessageReplied This function is invoked by the T R layer when a response to a sent message arrives at the listening port. Inputs to this function include 

RoleNotFound This function is invoked by the T R layer when a message could not be delivered to any role instance. Inputs to this function include 

TreeBuilt This function is invoked by the T R layer when a tree is routed through the local node. Tree built events are used for 

The following functions operate on roles assigned to the local node. Functions to operate on a single role and bulk many trees many roles versions are supported. The bulk functions may be useful when a node is booting and needs to re publish many roles even on possibly different trees .

RemoveRole This function unpublishes a role thus destroying all edges routes to the local node. Inputs to this function include 

AddRoles This function allows multiple roles on varied trees to be published in an efficient manner. The AddRoles function is passed only an array of role records. Each role record contains the arguments for an AddRole function invocation. Note that these are independent AddRole invocations and do not have to be for the same tree.

RemoveRoles This function is a bulk version of the RemoveRole function. The RemoveRoles function is passed only an array of role records. Each role record contains the arguments for a RemoveRole function invocation. Note that these are independent RemoveRole invocations and do not have to be for the same tree.

GetTreeNode This function gets all the nodes on the specified tree. Each node specifies its neighbors. Each returned item contains a node ID and its neighbor IDs.

The following sections describe internal mechanisms and data structures used to route messages according to one embodiment. It is noted that the particular internal mechanisms and data structures are intended to be exemplary only. In various embodiments message routing such as described above may be implemented in any of various ways.

In one embodiment the router may export and implement a public T R layer application programming interface API as well as an internal API. The router may be invoked using this collection of APIs whenever 

In response to being invoked through these public and internal APIs the router either satisfies the request locally or uses the link layer and or builder to invoke other nodes that may in turn satisfy the request locally or use another remote node instead.

In one embodiment the router relies upon the following components using their APIs to satisfy requests and maintain its internal state 

The router may utilize data structures to contain temporary state accumulated during the processing of messages or responses. For example this state may be held to support replies.

The router may use a data structure called a record to hold state associated with some in progress activity. Each record is identified e.g. with a unique 128 bit number that is generated by the router.

A link record may be used to track a single instance of a message being sent over exactly one link. The record includes the link on which the message was sent and a reference to the message record.

The router may use a data structure called a map to store keyed data. The key may be associated with the data when the data is inserted in the map. The key may then be used to lookup that same data. In one embodiment the router uses a number of maps to perform functions such as 

A sent messages map may be used to track each instance of a message sent over a link. For example if the message is to be sent on two links a link record may be created that references the message record and inserted twice into this map. As replies return to the sending node the link records may be removed until all are removed.

A seen messages map may be used to hold a message record of each message seen processed by the router. A message record may be created and inserted in this map whenever a new message is to be sent from the local node.

An in progress route map may be used to hold message records each denoting a message that requires a route to be recovered. The message record may be inserted in the map just before the router calls the builder requesting that a route be re built. The message record may be removed from the map by the router when the builder completes the recovery process.

A pending reply map may be used to hold message records inserted whenever a message is created or one is received off a link. The message record may be deleted when the last remaining reply arrives.

A suspended messages map may be used to hold message records that track listeners processing received messages. Just before the listener is invoked the message record may be inserted. The record may be removed from the map as the result of a resume send API function invocation or when instructed to do so via a special return value by the listener s callback routine.

A suspended replies map may be used to hold message records that track listeners processing received replies. Just before the listener is invoked the message record may be inserted. The record may be removed from the map as the result of a resume reply API function invocation or when instructed to do so via a special return value by the listener s callback routine.

A protocol map may hold listener ports. Each port may be associated keyed with a protocol ID. The router may use this map to find the appropriate listener port to handle messages and responses.

This object may be used to hold the set of send parameters associated with a particular message record. This object may encapsulate the router s message header and the sender s parameters including sender s data . In a Java implementation this object may be serialized into an array of bytes before being sent over a link. On the remote side of the link the object may be rebuilt from the serialized array of bytes. As another example in one embodiment the object may be sent as a SOAP message.

Similarly a Reply Parameter object may be used to hold the set of reply parameters associated with a particular message record. This object may encapsulate the router s reply header and the reply parameters including response data . In a Java implementation this object may be serialized into an array of bytes before being sent over a link. On the remote side of the link the object may be rebuilt from the serialized array of bytes.

The process of sending a message may begin by validating the sender s invocation parameters. The tree ID and role name are verified to be non null. If the oneInstance option is true the oneResponse option is set to false. If the one way option is set to true while at least one of the oneInstance or oneResponse options are true an error condition may be raised and the message may not be sent.

If the parameters are validated the set of send parameters may be packaged together in a common send parameter object which is then stored in a new message record.

If the one way option is false the message record may be stored into the pending replies map. The message record may then be stored in the seen messages map. The router may then forward the message. If the forward logic returns without raising an error condition e.g. an exception in a Java implementation the message record ID may be returned to the calling software.

The forward logic in the router is the logic that moves existing messages not reply responses to listeners on the local node and to remote nodes. illustrates the forward logic state machine. The forward logic may be leveraged by other router logic that 

The forward logic may begin by requesting the builder to lookup local information about the tree and role in use. If this is a new tree on the local node a new entry in the tree cache may be allocated. The information returned regarding the role may specify whether or not the role on the specified tree has been added on the local node and whether or not the role is exclusive.

If the local node has published the role and the oneInstance option is true the forward logic does not need any additional remote routes. If this is not the case routes from the local node to remote nodes that have published the role on the tree may be looked up. If the send parameter roleID is non null information about just a specific role instance may be looked up.

If a set of candidate links is found the set may be stored in the candidate links field of the message record. Otherwise a tree recovery operation may be required. A tree recovery operation may be required if the role is not fully built.

Next the link layer s link interface may be queried as to all the link destinations. If any of the original sends were invoked with the local realm option these links leading to nodes outside of the local realm may be removed from the candidate list.

If the role on the specified tree is already fully built the router may need to raise a role not found error condition. The error condition is raised if the message has never been delivered specified by delivery status field in the send parameter object to any nodes and the local node also does not have the role.

If the role is not fully built and a recovery operation has not already been started the router may request the builder to recover routes to the role. The message record may then be stored in the in progress routes map until the builder s recovery operation completes. At that time the forward logic is re activated and the process repeats itself. In one embodiment the process may be repeated for at most one more time.

If the role is fully built and a recovery operation has already completed the message has never been delivered and the local node does not have the role a role not found error condition may be raised.

If error conditions have been raised the forward logic may be terminated and control may be passed back to the invoking logic e.g. send message logic .

Otherwise if the local node has the role the message may be given to the local listener s receive interface. If the listener s receive callback does not suspend or consume the message the forward logic may then begin sending the message to remote nodes using the candidate links stored in the message record. If the remote send operation was successful the forward logic exits. Otherwise one of two situations has arisen 

For each candidate link over which to send the message to a remote node excluding the link the message was received over the following may be performed 

This logic may then return either an error indication or the actual number of messages sent over the links. This number matches the complete set of links in the message record sent links list. Error conditions caught here may cause the link record to be removed from the sent messages map.

If the one instance option is used this process may be performed only once. The choice of which link to choose can either be 

It is possible that after a node A has routed a message to another node B building initiated on node B can cause new routes to be added on node A. In one embodiment a technique may be employed to allow node A to forward the message on the new route.

In this situation since node A will be waiting for replies from node B perhaps not directly this situation is isolated to the time while node A is waiting for replies. Two internal interfaces in the builder allow the router to mark this time interval 

Whenever the builder adds a new route for a role the builder may call the following internal interface in the router 

If the router is doing a multi instance send the router may then simply send the same message that is pending replies indicated by message ID on the newly added route indicated by link and may update data structures to indicate that a reply is now pending on that link also. However if the router is doing a single instance send the new link may simply be added to the list of candidate links.

A role not found condition can be detected on any node along the sending message path e.g. when the tree is marked fully built yet no edges exist for the desired role . When this condition is detected a special role not found reply may be generated and routed back to the original sender. When the role not found reply reaches the original sending node only a role not found event may pushed to the sending application.

The router may use the protocol map to find the proper listener associated with the specified tree. If no listener is found the invocation procedure may be terminated. Otherwise before invoking the listener s receive interface the router may check to see if the local node is an endpoint along the message route. This information may be passed to the receiver. The delivery status in the send parameter object may be set to true indicating that the message has been delivered to at least one listening node. The message record may then be stored in the suspended messages map until it is resumed. The listener s receive interface may then be invoked. After the listener returns control to the router the return value may be checked for one of three values 

Continuing the message causes the router to resume the message along the route. Suspending the message leaves the message in the suspended message map awaiting a future resume or consumption operation. Consuming a message removes the message on the local node so that it can no longer be forwarded or have replies issued to it.

The process of replying to a message may begin by validating input parameters in particular the message ID that names the message for which a response should be generated. The message ID may be used to lookup the message record in the pending replies map. A failure to find the message record can occur for the following reasons 

If the message record is not located an error condition may be raised and control may be returned back to the caller. Otherwise information about the role used in the message for which the reply is being issued may be looked up. If the role is exclusive a possible error condition may be checked. That is if the exclusive role is being granted the giveUp Boolean must also be set to true. The last reply Boolean may also be checked. If true some additional processing is required. If this is a last reply the number of outstanding replies is decremented. If this is a local last reply the message record Boolean indicating such is set to true. Otherwise a remote link is removed from the sent links list in the message record. Finally if no more outstanding replies are expected local or remote the message record may be removed from the pending replies map. Otherwise the last reply Boolean may be flipped to false to indicate that some other replies are still expected from either the local node or from remote nodes.

If this reply is actually the specially generated role not found reply some additional processing is necessary. A role not found reply for this message may or may not have been seen already. When a role not found is first detected no previous instances seen the router may check to see if it has already processed a good reply a reply other than role not found . If so the role not found reply may be discarded. Otherwise the router may check to see if more replies are expected which may in fact be good replies. If so the reply parameter object for the role not found reply may be stored away in the message record for future role not found processing. A future good reply may cause this previously received role not found reply to be discarded. Finally if no more replies are expected the role not found reply is valid and may be returned to the original sender.

The reply logic may locate which role original or one named in grantedRoleName parameter is to be controlled by the role manipulation booleans. The role manipulation parameters may be false and false which conveys to the router that the role should not be granted or given up. For all other values of the role manipulation Booleans the specific role s instance ID is required. The router may use the builder to get the role s instance ID. If the role is not being given up a new instance may be created shared role . If the giveUp Boolean is true the router may instruct the builder to remove the role from the node on the specified tree.

A reply parameter object may then be created by utilizing the send parameter object in the message record and adding in the reply parameters. The reply parameters may be clustered together into a response data structure that includes the response data. The reply parameter object may be used to accumulate multiple responses at a node. The oneResponse aggregated reply option may be checked and processed. If this is not the absolute last reply expected at this node the set of responses may be appended to a message record list of responses.

If this is a role not found to a oneInstance message some special post processing may be invoked. See discussion below on single instance role not found reply processing.

If waiting for more replies to arrive or the oneInstance post processing has re sent the message the reply logic may exit. Otherwise if the local node is the original sending node the proper listener s reply interface may be invoked. If not the router may find the incoming link used to receive the original message and use this link to send the reply parameter object back towards the original sender.

As noted above when a reply to a single instance send arrives at a node some additional processing may be performed. If there are more candidates to try the message may be re sent by invoking the forward logic again. As the forward logic sends messages links are moved from the candidate list to the sent list. If the candidate list is empty when this role not found reply was processed the role not found reply is passed on towards the original sender. Since the previously used link was removed from the candidate list by the forward logic the next forward of the same message will pick another link to use for the re try send.

When a routed message arrives at another node the link layer on that node may invoke the T R layer s receive handling logic. This logic may include logic common to both sent message processing and reply processing.

The received message may first be decoded from an array of bytes back into a send or reply parameter object. In one embodiment a Java implementation may be arranged so that both send and reply objects sub class a common message object. This common message object may include a reply Boolean that is true if the message is a reply and false if it is a sent message. This object may also include the message and tree IDs common to both sends and replies.

Before dispatching to more specific processing the common logic may check to see if this node has received a sent message already. Replies do not require the same checking because multiple replies to the same message can and do arrive at nodes. If a sent message arrives at a node twice however the tree has a circular route. The check for circularity is accomplished by searching the seen messages map looking for a message with the same ID. If the node has not already received the sent message the message is added to the seen message map. If a duplicate message has arrived the router may call the builder s break route interface to remove the edge mapped to the link on which this message just arrived. If the message is not a duplicate the router may request the builder to find the tree with the tree ID in the sent message or reply. Once the tree is located the router may dispatch logic specific to sent messages or replies to messages passing the tree as a parameter.

If the reply Boolean is false indicating that the message is a sent message the send specific logic is invoked. A new message record maybe created to track this new message. If the message is not a one way message the message record may be inserted into the pending replies map. The common forward logic may then be invoked after which control returns back to the link layer.

If the reply Boolean is true indicating that the message is a reply message the reply specific logic is invoked. The reply logic may use the message ID to lookup the message record that should be in the pending replies map. If the message record is not found the reply may be discarded. This can happen if a reply took longer than a periodic sweep time assigned to a background sweeper task. Once the message record is located the last reply Boolean may be checked in the reply parameter object. If it is true additional last reply processing may be invoked. This processing may be the same regardless of whether the reply was issued locally this node or whether the reply was received over a link.

The router may next determine whether this reply has arrived at the original sending node. The original sending node will have a null value in the incoming link field of the message record. A Boolean in the reply parameter object may be set to true to indicate the arrival back where the send was issued. If the reply has arrived at its endpoint some additional role processing may be required.

At reply endpoint nodes only any roles that have been granted to the sender by the replying node must be assumed. At all nodes along the reply path middle s and the endpoint any role routes that point towards a removed role on the replying node may be removed or re pointed.

The router may also perform a check for aggregation. If this is a oneResponse send the common to local replies aggregated reply processing may be executed. Also common to local reply processing is the check for a role not found reply to a single instance send. These two checks may cause the reply to stall at this node until all outstanding replies have arrived or a single instance send does not result in a role not found reply. Finally the reply listener may be invoked.

When invoking the reply listener the router may use the protocol map to find the proper listener associated with the specified tree. If no listener is found the invocation procedure may be terminated. If this is a role not found reply the router may ensure it is delivered to the original sending node only. If this is a null reply due to a break route procedure the router may skip delivery. A break route procedure may be used to eliminate circularity in a tree. This procedure may be performed transparently so that applications do not received null replies when generated by a break route procedure.

The message record may then stored in the suspended replies map until it is resumed. The listener s reply interface may then be invoked. After the listener returns control to the router the return value may be checked for one of three values 

Continuing a reply causes the router to resume the reply s journey along the route back towards the original sender. Suspending the message leaves it in the suspended message map awaiting a future resume or consumption operation. Consuming a reply removes it on the local node so that it can no longer be resumed.

When the router detects a stale or circular route the builder may be invoked on the node that first detected the problem Builder B . Builder B eventually sends a special message back over the link in question. When Builder A the builder on the remote end of the link from builder B receives the special message Builder A may invoke a special router interface that generates a null reply.

Null replies may be generated when a link goes down or when a circular or stale route has been broken. The null reply may be generated to account for all of the outstanding replies expected by a sending node. A reply may be marked null by setting a Boolean in the reply parameter object to true.

Original senders only receive null replies that were generated because of a link down. The original sender may then re issue the send on the repaired tree. Stale routes and circular routes on the other hand may be hidden from the sender and treated as operations internal to the router builder. These null replies do not reflect the nature of ensuring that all replies have been received.

When the application performs a resend the application may take appropriate standard safeguards to ensure idempotency e.g. identify the request with a unique ID keep a map indexed by that ID of replies recently sent. When a request comes for a retry it has the same ID and the response may simply be looked up rather than re performing the operation.

The link layer may alert the T R layer of inactive down links by pushing an event to the link s listener callback. The T R layer s link down handler may subsequently be invoked. The T R layer may first remove its listener from the link. Next the T R layer may look up the set of outstanding replies over that link. The set of affected replies may be added to during the send process and subtracted from after a reply is received. For each outstanding reply a null reply may be issued. Finally the link may be removed from the set of active links used by the T R layer and placed on a special transitional list of links to indicate that this link has gone down.

When a node is taken down voluntarily the link layer may close down all active links to other nodes. The T R layer s link down processing logic may then be invoked to send any needed null replies to other nodes.

Snooping messages is the process of examining in route sends or replies. A snooping listener can consume stop suspend or continue the routing of the send or reply towards its ultimate destination. Messages or replies currently being examined by a snooping listener have already been placed in the suspended state. The suspended send or reply may be resumed by either continuing the routing triggered by special return value from listener or by using the resume APIs.

When a snooping listener consumes a message the T R layer looks up that message in the suspended message map and if found removes it. No other processing is required. Similarly when a snooping listener consumes a reply the T R layer looks up that message in the suspended replies map and if found removes it. No other processing is required.

When a snooping listener resumes a message the T R layer looks up that message in the suspended message map and if found removes it. Then the common forward logic is used to continue the message routing. Similarly when a snooping listener resumes a reply the T R layer looks up that message in the suspended replies map and if found removes it. Then the common reply logic is used to continue the reply routing.

The following sections describe internal mechanisms and data structures used to build and manage trees according to one embodiment. It is noted that the particular internal mechanisms and data structures are intended to be exemplary only. In various embodiments routing data may be built and managed in any of various ways.

The builder builds and maintains routes for the router . According to one embodiment these routes may be represented and managed using data structures referred to herein as tree layer objects. On each node the local instance of the builder may perform a distributed protocol which manipulates its local tree layer objects to manage these routes.

According to one embodiment for every tree that the local node maintains routing information there is a Tree object.

Each Tree object may maintain a list of Edge objects each of which correspond to an edge of that tree on the local node.

Each Tree object may also have a hash map hashed by role name containing each Role Route object which has local routing information for a role on the tree.

Each Tree object may also have a hash map hashed by role name containing each Local Role object which contains information about each role that the local node has on the tree.

Each Role Route object may have a hash map hashed by unique ID of role instance holding each Role Route Instance object.

That route is specified by a reference to the particular Edge object whose corresponding edge on the tree is in the direction towards that particular instance of the role.

Each Edge object also has a list containing all the Role Route Instance objects for all the role instances for one or more roles that are over this edge.

For every neighbor node in the link mesh there is a Link object managed by the Link Discovery layer which the T R layer uses to send and receive messages to from that neighbor node. Corresponding to every Link object the T R layer maintains a Shadow Link object. The T R layer may use Shadow Link objects to keep from polluting the Link Layer with T R specific code.

A hash map hashed by Link object may be used to look up the Shadow Link object that corresponds to a particular Link object.

Each Shadow Link object has a list of all the Edge objects for each tree that has an edge over the Link corresponding to that Shadow Link.

Each local role is specified by a role record including the following parameters specified when a role was added using the addRole API function 

In one embodiment each local node has a Tree Cache object that acts as a routing table such as described above. The Tree Cache object may maintain a cache of Tree objects. The size of the cache may be specified at start up time and may be controlled by a local policy. Every time the T R layer both router and builder modifies or accesses the routing information for a particular tree the corresponding Tree object may first looked up in the Tree Cache by specifying the unique ID of the tree.

The Tree Cache may consider a look up of a Tree object to be an access of that Tree object. In one embodiment the Tree Cache may keep track of the temporal order of accesses to the various Tree objects so that the cache can be managed with a least recently used LRU policy such as described above. If a unique ID for a tree not currently in the cache is specified and the size of the cache is below its limit a new Tree object may simply be allocated and added to the Tree Cache. However if the Tree Cache is already at its limit the least recently accessed Tree object may first removed from the cache before adding the new Tree object.

If a Tree object is removed from the Tree Cache and later accessed the T R layer may re compute the routing information rebuilding the tree using the same algorithms that would rebuild a tree after a link fails. The rebuilt Tree object may be re added to the Tree Cache.

In one embodiment in addition to maintaining the cache of Tree objects the Tree Cache may also maintain all the local roles on each of the trees. Unlike the cache of Tree objects the local roles may be maintained for as long as the local node is up. Therefore when a Tree object is replaced from the cache its hash map of Local Role objects may first be stored in the Tree Cache. The Tree Cache may maintain each hash map in another hash map which is indexed by tree ID. Thus a double hash map indexed by tree ID and role name effectively manages all local roles on a node. When a Tree object is added back to the Tree Cache its hash map of local Role objects is initialized using the one stored in the Tree Cache.

Both Tree and Role Route objects may have a Boolean indicating whether the object on the local node is fully built. This indicates whether or not the object has been built sufficiently to be used for routing or whether it needs for the builder first to perform recovery.

When a node sends a message to a particular role then provided the network is not partitioned that message will eventually reach all nodes that have an instance of that role provided the router does not use the routes maintained by the Role Route object until the builder has made it fully built. The reason is as follows. If a node does not have the role then it will not route the message until it either has a route to at least one node that has the role or until the recovery operation has timed out due to no node having the role role not found condition . Once the message reaches a node with the role the rules for maintaining fully built on nodes with the role ensure that all nodes with the role and fully built set can reach all other nodes with the role.

Fully built for a Role Route ensures that all nodes with the role can be reached in the whole cloud. For a cloud located throughout a WAN the timeout may be relatively large. Since it is also possible to do a send that is restricted to the local Realm recovery for that operation may have a much smaller timeout. For that reason a fully built realm Boolean may also be maintained for each Role Route object.

The router does not use the Tree object for routing message since messages are routed for a particular role on a tree not all roles on a tree . The fully built boolean for the tree is only used by the builder to determine whether it can use the current edges of the trees to publish a new role on the tree. The only time a Tree object can have fully built set to true when one of its Role Route objects has fully built set to false is when that Role Route object has just been allocated. This special case allows the newly allocated role to publish on an existing tree that has not been broken from any link failures.

The router needs a list of links over which to send a message in order to reach all instances of a role. The builder looks up the Tree object in the cache and then looks up the Role Route object in the Tree object. Once the builder has performed any needed recovery if fully built is set to false for the Role Route object then the list of links that the router should send the message on is simply determined by following the reference from each Role Route Instance object to its Edge object and then to its Shadow Link object and finally to its Link object. Once this list of links is computed it can be kept in the Role Route object and only recomputed if the Role Route object has fully built reset to false or if a new Role Route Instance is added.

When a link fails the trees that go over that link need to be rebuilt. In one embodiment the builder does not rebuild a tree until the tree needs to be used for a send. Otherwise the system could become overwhelmed repairing many trees at once. Furthermore many trees may not be needed until much later. Repairing them immediately would divert system resources from operations that currently need to be performed.

Although recovery may not be performed immediately when a link fails all the Role objects that have a route over the failing link need to have fully built set to false so that they will be marked for recovery the next time they are used. The following process may be performed 

In one embodiment basic tree building algorithms may be employed which do not use a search algorithm to locate a node with an instance of a role. In another embodiment these basic tree building algorithms may also be enhanced with a search algorithm to further improve performance and scaling. The basic tree building algorithms are described.

This section describes one embodiment of a basic publish algorithm. It is noted that in various embodiments any desired algorithm may be used to publish a role.

When a new instance of a role is added to a tree on the local node the local node initiates the forwarding of a publish message. Among other information the publish message specifies 

In one embodiment the initial sending node and each node that receives the publish message may send the publish message using the following rules. When applying these rules the incoming link is excluded.

Rule 1 If the node has already received the same publish message a simple hash map is maintained for this purpose the publish message is discarded with no processing. This rule eliminates many cycles and thus helps to form a tree not a graph in general. However not all cycles may be prevented. Cycles may be eliminated when detected by the router.

Rule 2 If the node has another instance of the same role the publish message is not forwarded any further provided that Spew Hops is 0 but it is processed. This rule prevents the publish from being forwarded unnecessarily. If the publish message were to be forwarded further it would reach nodes that already have a route along the same edge to this node just reached with the role. In other words a node only needs a route to one of the nodes with the role down a particular edge it does not need a route to roles behind that node.

Rule 3 If the local Role Route is not fully built and the local Tree is also not fully built reset Spew Hops to 3. In other embodiments other values may be used. Otherwise if the local Role Route is fully built and Spew Hops is non zero decrement Spew Hops by 1. This essentially computes the number of hops where rule 6 will apply.

Rule 4 If the local Role Route is fully built and Spew Hops is 0 the publish message is only forwarded on links that are the routes to existing instances of the role. This tends to publish towards other instances.

Rule 5 If the local Role Route is not fully built but the local Tree is fully built and Spew Hops is 0 the publish message is forwarded along edges of the tree. This tends to publish a new role on a tree already formed by a role previously published that built out the tree.

Rule 6 Otherwise the publish message is forwarded on all links. This tends to search for local repairs to the tree for a few hops.

If only Rules 1 and 6 were used the publish request would eventually reach all instances of the role. Using Rules 2 3 4 and 5 reduces the number of nodes that must receive and process the publish request.

Except in the case of Rule 1 the publish message is processed by adding a Role Route Instance with an Edge over the Link that the publish message is received.

When the router is sending or forwarding a message to a role for which the local Role Route object has fully built set to false the builder must first perform recovery.

This section describes one embodiment of a basic recovery algorithm. It is noted that in various embodiments any desired algorithm may be used to perform recovery.

To perform recovery the local node may initiate the forwarding of a recovery request message. Among other information the recovery request message specifies 

In one embodiment the initial sending node and each node that receives the recovery request message may forward the recovery request message using the following rules. When applying these rules the incoming link is excluded.

Rule 1 If the node has already received the same recovery request message a simple hash map is maintained for this purpose the recovery request message is discarded with no processing. This rule helps eliminate cycles thus forming a tree and not a graph in general.

Rule 2 If the node has another instance of the same role the recovery message is not forwarded any further provided that Spew Hops is 0 but it is processed. This rule prevents the recovery from reaching instances that need not be reached. If the recovery message were to be forwarded further it would cause routes to be recovered for nodes to which the current node i.e. the node that the recovery message just reached already has routes. In other words a node only needs a route to one of the nodes with the role down a particular edge it does not need a route to roles behind that node.

Rule 3 If the local Role Route is not fully built reset Spew Hops to 3. Otherwise if the local Role Route is fully built and Spew Hops is non zero decrement Spew Hops by 1. This essentially computes the number of hops where rule 6 will apply. Due to this rule Spew Hops may immediately get set to 3 when the algorithm is started since the role is not fully built at the node where the recovery algorithm is started. 

Rule 4 If Spew Hops is 0 and the Role Route is fully built the recovery message is only forwarded on links that are the routes to existing instances of the role. This tends to send the recovery request towards instances of the role.

Rule 5 If Spew Hops is 0 and the local Role Route is not fully built but the local Tree is fully built the recovery message is forwarded along edges of the tree. This tends to recover the role routes on a tree already formed by a role previously published that built out the tree.

Rule 6 Otherwise the recovery message is forwarded on all Links. This tends to search for local repairs to the tree for a few hops.

If only Rules 1 and 6 were used the recovery request would eventually reach all instances of the role. Using Rules 2 3 4 and 5 reduces the number of nodes that must receive and process the recovery request.

The initial sending node and each node that receives and processes the recovery request message all cases except the one in Rule 1 keep track of the recovery request and the Link over which it was received using a Recovery Record object. The initial sending node and each node that receives the recovery request and finds fully built to be set to false for the role considers a recovery operation to be in progress and starts a timer which goes off when the recovery operation is finished locally.

When a node with an instance of the role receives the recovery message the node sends a recover response message which specifies 

The recover response message is forwarded back along the path that the recovery request message came. For the purpose of routing back the response the Link over which the recovery request was received recorded in the Recovery Record is used Recovery Record is looked up in a hash map indexed by the Message ID of the recovery response which is the same as the Message ID of the recovery request .

Except in the case of Rule 1 each node that receives the recovery response adds a Role Route Instance with an Edge over the Link that the recover response message is received.

For the initial sending node and any other node that received the recovery request and found fully built to be false any one of the following conditions causes it to terminate the recovery algorithm and mark its Role Route object with fully built set to true 

Having discussed above the core of the basic publish and recovery algorithms according to one embodiment the following sections cover other mechanisms which may be utilized in performing these algorithms.

When two nodes attempt simultaneously to publish an exclusive role all nodes must reach a distributed agreement regarding which node has the exclusive role. In one embodiment this is handled simply by comparing instance IDs for the prospective role instances and letting the highest instance ID win. Thus the publish from the node with the highest role instance ID will eventually reach all nodes and replace any routes to lower numbered instances. It will also result in the exclusive role being removed from the node that has the lower numbered exclusive role instance. The algorithm works also when there are more than two nodes attempting to publish simultaneous exclusive roles on the same tree. It is also noted that publishing an exclusive role wipes out any shared role by the same name that had been published on the tree.

In one embodiment a handshake utility can be used to add exclusive roles instead of directly calling addRole . This utility provides a callback to the user when the exclusive role has been successfully added or when the exclusive role was removed. Before attempting to add the exclusive role it first does a ping to the exclusive role so that an existing holder of the exclusive role one that has already been notified of success via callback on its node does not get the exclusive role taken away from it when the new node attempts to get the role using the handshake utility. Thus in this case if there is already a node with the exclusive role the node attempting to get it will get a callback indicating it cannot get the exclusive role.

An unpublish operation may be handled by the same code that does publish. A Boolean in the Publish request message may indicate whether the request is a publish or an unpublish and the message may be propagated using the same rules as the publish. Instead of adding a Role Route Instance when the Unpublish request message is processed on each node the specified Role Route Instance is removed.

Unpublish does have one other additional capability. In most cases the node that adds an instance of a local role or removes the local instance of a role does the publish or unpublish . However for exclusive roles the unpublish can originate from any node due to the way the publish algorithm comes to a distributed agreement on all nodes regarding which instance wins when there is an attempt to publish exclusive roles simultaneously from two different nodes. A node could fail holding an exclusive role and its instance may win over an attempt to publish an exclusive role on another node when some higher level software performs recovery. Thus instead an unpublish can be done first from the node that performs recovery to clean up any routes to the old exclusive role on the failing node.

In some cases nodes may fail without first unpublishing their roles. This results in nodes having stale routes to those roles. This may be handled by an algorithm that removes stale routes.

Many builder operations involve creating and destroying tree edges. For example when a Role Route Instance object is added for a route over a link if there is not already an Edge object created over that link one is created. Since the tree needs to be bidirectional whenever an Edge object is created the local node sends an edge create request message over the link the link the edge is over . This message specifies simply the tree s unique ID. When the node on the other end of the link receives the edge create request it simply creates the edge if it does not already have one.

Since an edge may be created to ensure the tree is bi directional some edges will not have any routes to roles over them. However if node A and node B have bi directional edges to each other at least one of those nodes will have a route to the other node. Otherwise the edge may be removed. The edges mutually between two nodes may be removed once neither of the nodes has a route to the other node. The removing of the edges may be accomplished by a simple protocol where the two nodes both agree to remove their edges after checking with each other to make sure there are no routes. In another situation an edge may be removed to break a cycle. In that case the breaking of the edge may be forced even if there are routes over the edge.

According to one embodiment both the unforced and forced cases for edge removal may be handled as follows 

An addRoles API function may allow multiple roles to be added and published at the same time. The bulk publish facility may allow roles to be added on different trees in the same bulk request. A bulk message including multiple builder messages may be utilized to perform a bulk publish operation. A bulk request message for bulk publish includes multiple independent publish messages. The code that processes bulk requests may unroll the bulk request and call the routine that processes publish requests for each of the publish requests in the bulk request message.

The following changes to the publish algorithm described above may allow a bulk publish operation to be performed 

Once the bulk processing code has called the process publish request for each publish message it may simply send each bulk request message in the bulk request record on the Link that corresponds to it. In a recursive manner each node that receives a bulk request message over a link may perform a bulk publish operation for each publish message in the bulk request message similarly as described above. Thus each publish message in the received bulk message may be processed and added to a bulk request message for the particular link the individual publish message would have been forwarded on from that node and the bulk request messages may be sent over the corresponding links.

Sometimes the recovery process is not complete until the recovery timeout has occurred. In such cases the node performing recovery does not know it has all the routes it needs to ensure its routing table is fully built until the recovery timeout. However if the node forwarding a recovery request experiences a link failure on one of the links it forwarded the recovery request the node might not have received all the recovery responses. This problem may be handled by having any node that experienced such a link failure send back a recovery response indicating link failure. This response is sent back all the way to the node that originated the recovery. Each node along the way marks the role as not fully built if it has not received a response that allows it to declare otherwise that recovery is complete. Then if the node that originated recovery gets any recovery failure responses during the recovery it simply re initiates the recovery.

In one embodiment the router s send API may support restricting the send to just the roles in the local realm. This send is supposed to reach all instances of the role in the local realm. If the publish and recovery algorithms allowed a tree to be built with the nodes in any realm not all on the same fragment of the tree a send that is restricted to a local realm might have to be routed outside of that local realm to another realm and then back to the original realm in order to reach all instances of a role in the local realm. This would defeat the purpose of having realms. A send within the local realm should be considerably more efficient because nodes within the local realm should be reachable with much lower latency and without wasting WAN bandwidth. Therefore the builder may ensure that for every tree built nodes within the same realm are all on the same fragment of the tree so that any node in a realm can send a message to any other node in the same realm without leaving that realm.

Such fragments could be formed in the following unlikely but possible situation A publish or recovery request message goes from a node A in realm R to nodes outside of realm R and then returns to realm R reaching a node B in realm R before the same message goes from node A to node B without leaving realm R. This situation is not likely because the path that goes outside of realm R to go from node A to node B should have a significantly higher latency than the path that stays inside realm R. However this situation could occur for example if one or more nodes on the path that stays inside the realm are overloaded and not able to forward the messages fast enough.

With this mechanism in place the router can easily send to only the instances of a role in a local realm by excluding a send on any link that goes to a node in a remote realm. Thus the router may simply request the list of links that are routes to a role and may then exclude any of the links that goes to a remote realm.

When the router is performing a send restricted to the local realm it is not necessary to be able to reach all instances of the role just the ones in the local realm. When doing recovery for just the local realm the recovery algorithm may employ an additional restriction that recovery request messages are only forwarded over links that go to other nodes in the local realm. Also since nodes in the local realm can be reached more quickly than nodes throughout the cloud the recovery timeout for local realm recovery should be significantly smaller.

When doing a single instance send the recovery algorithm may terminate as soon as the node initiating recovery has one route to an instance of that role whether or not that instance is marked fully built.

In some cases recovery is not done until the recovery timeout has happened. The recovery timeout may be based upon a maximum reasonable time for a recovery request message to reach each instance of the role being recovered and come back in the form of a recovery response along the same path.

According to one embodiment in order to compute such a timeout the following computations may be performed 

For local Realm recovery the recovery timeout may be computed as the maximum value in List A multiplied by a multiplication factor e.g. 3 . For full recovery to reach instances throughout the cloud the recovery timeout may be computed as the maximum value in List B multiplied by a multiplication factor e.g. 3 .

In other embodiments any of various other algorithms may be used to compute timeouts. In one embodiment a local hop time may be computed as a running weighted average of local ping times. In one embodiment each ping affects 10 of the next computed local hop time and the previous local hop time affects 90 of the next computed local hop time. The ping rate may be configurable. In one embodiment pings may be performed once per minute. The local hop time may be piggybacked on every builder message.

A global hop time may be computed based on the local hop times. In one embodiment the piggybacked local hop time affects 10 of the next computed global hop time and the previous global hop time affects 90 of the next computed global hop time.

Timeouts may be computed as a function of the maximum number of expected total remaining hops and the global hop time.

In one embodiment the link layer software may use the node IDs of nodes in a realm to establish an ordering. For a certain target valency number N each node may form links with the N nodes that have the smallest node IDs larger then their node ID. Within a realm 2 hops should be sufficient to perform local repair around a failure. Thus the Spew Hops setting of 3 in the basic publish recovery algorithms should be more than sufficient.

However the link layer may form links that connect realms differently and only a few nodes within a realm may connect two realms together. To address this problem when a role route becomes not fully built due to loss of a link connecting to another realm the role route is marked so that the publish recovery algorithms keep Spew Hops set to infinite until the message leaves the realm.

In one embodiment the addRole API function may allow the user to restrict the extent that a role is published according to 

As noted above trees are built primarily via the Publish and Recovery algorithms. The following sections discuss other builder operations.

When a node grants and gives up a role in a reply to a routed message the router may initiate the re pointing of the role back to the node that will ultimately receive the reply granting the role given up. Re pointing is considerably more efficient than having the node that gives up the role initiate an unpublish operation followed by having the node that gets the role initiate a publish operation. With re pointing only the nodes on the way from the replying node to the receiving node need to change their routes.

On every node that forwards the reply the router may simply call an internal API function repointRole in the builder supplying 

The builder may simply remove any Role Route Instance that the local node had to the specified role instance and create a new Role Route Instance as specified pointing along the Link supplied.

When nodes fail along the path of the re pointed role the node that sent the request will not receive the reply granting the role. However the node will receive a null reply that it can use as an indication of the need to recover the role that was granted and lost.

The tree building algorithms described above do not guarantee that the routes have no cycles. The presence of cycles in the routing tables has no effect on the routing of messages because the router detects cycles of individual messages sent and discards extraneous messages. The prevention of cycles would require a very complex distributed building algorithm that would likely impact performance. Moreover typical use of the T R layer algorithms should not often result in cycles.

When the router detects that a message has cycled the router may call an internal breakroute API function of the builder specifying 

Reverse routes are created back to the node that sent the cycling message allowing the role that was involved in the cycle to remain fully built on all the nodes that were in the cycle. Some of these routes may not be necessary. If so they may be removed as stale routes see below .

A mechanism that prevents nodes in a realm R from being on different fragments of a given tree is discussed above. The mechanism creates a cycle that will eventually need to be broken. It is important not to break that cycle in such a way that realm R becomes fragmented on the tree. In order to ensure this the router may perform the following 

Athough avoiding breaking the cycle causes the cycle to persist eventually the right node in the cycle will receive the message and break the route. Also due to the fact that latency within a realm is significantly lower than outside a realm the cycle is more likely to occur so that it is favorable to break the route.

When nodes fail while holding roles other nodes may have stale routes to those roles. The router detects a stale route when it receives a message being routed to a role and it does not have any route even after invoking the builder if necessary to the role except over the link that the router received the message. When the router detects a stale route the router calls an internal breakroute API function of the builder specifying 

In some cases the network of nodes may become partitioned. As used herein a network is partitioned if there are at least two nodes in the network node A and node B such that there is no sequence of links starting from node A and connecting eventually to node B. In this situation the network has essentially become separated into two or more groups of nodes where nodes in one group cannot communicate with nodes in another group. Partition boundaries do not necessarily coincide with realm boundaries. However two different realms may be more likely to become partitioned than two sections within a single realm.

After becoming partitioned the network may later become un partitioned i.e. the partitioning problem may become corrected. The network may become un partitioned when a network link is added or repaired. In one embodiment the system may employ a method for determining when the network has become un partitioned i.e. for determining that partitioning of the network has been repaired. It is a necessary but not sufficient condition for a link to have been added or repaired for a network to become un partitioned. Thus logic for determining whether the network has become un partitioned may execute in response to a link being added.

If the system determines that the network has become un partitioned the system may cause at least a subset of nodes in the network to perform recovery operations to reflect the repair of the partitioning. Before the network is un partitioned a role route of a particular tree may be marked fully built on a node in one of the partitions meaning that no recovery is needed at that local node in order to eventually route to all instances of that particular role at least the instances that are reachable in the current partition . However after the network is un partitioned there may be new role instances that are now reachable on nodes that were previously inaccessible. Thus when the network becomes un partitioned or partially unpartitioned trees may need to be rebuilt on various nodes so that routes are built to the new role instances that are now reachable.

Suppose a node X with node ID Dx in realm Rx detects an un partition caused by adding a link L and that this link L connects node X to node Y with node ID Dy on the opposite end of Link L. When such an un partition occurs node X may issue an un partition event specified by to all nodes that node X can reach. The node X may send a message specifying the event to all nodes except for nodes now reachable over the newly added link.

Each node that receives an un partition event message may maintain a list of such un partition events. The order of each node s list is not particularly important. However maintaining an order may allow each node to keep track of which un partition events have been handled for any particular role. Thus each node may maintain a numbered list of the un partition events in the order they are received. For each role of a tree the local node may also keep track of the highest numbered un partition event in the list for which recovery has been performed.

If a send operation is to be performed to send a message to a particular role then even if the role is currently marked fully built the T R layer may check to determine whether there are new un partition events added to the list since the last time a recovery operation was performed for the role. If so a recovery operation may be performed for each such un partition event.

As shown in step 3 to perform recovery that is made possible by the un partition identified by a directed recovery variation of the tree recovery algorithm may be utilized in which Node A sends a tree recovery message directly to node X. As shown in step 4 the directed recovery request may be sent from Node X to Node Y. The normal recovery algorithm as described above may then take over from Node Y. Thus in one embodiment the routing of the directed recovery request may be performed as follows 

When node X receives the directed recovery request node X forwards the request message across the link that caused the un partition the link that goes to node Y . Once the directed recovery request reaches node Y the normal recovery algorithm may resume so that the recovery request message is routed to instances of the role on the opposite side of the old partition. The tree may then be rebuilt when nodes process the reply or replies to the directed recovery request message as the reply is forwarded back in the same manner as described above with reference to the recovery algorithm.

The above description refers to a realm tree and a node tree. These are referred to herein as utility trees i.e. trees which allow the T R layer to perform various functions such as handling network un partitioning .

A node tree is a tree that allows any node to send a message to all nodes that can be currently reached. The tree may be identified by a well known ID D which all nodes in the entire network know about. The tree may have a shared role named N where each node in the network adds a local instance of the shared role N .

In some cases a per node tree may also be useful. A per node tree for a given node in a given realm may enable messages to be optimally routed to the node within the realm. The per node tree may have the following characteristics 

A realm tree is a tree that allows any node to route a message to a node in any particular realm. This allows local realm routing perhaps using the per node trees once the message has been routed to the realm. The realm tree may have a well known Tree ID.

In various embodiments the system may use any technique or algorithm to determine that the network has become un partitioned. This section describes one exemplary algorithm that may be used for this purpose.

A partition coloring algorithm may operate to ensure that when partitions occur the nodes in each partition get a different value referred to herein as a color. Thus when a link is added it can easily be determined if a possible un partitioning has occurred by comparing colors on both sides of the link.

The color may be a logical color or value represented by a unique ID that is created on a node when it has a failure of a link. The use of unique IDs ensures that partitions are uniquely colored. Along with the color ID C the node may also reads its Lamport Logical Clock obtaining some value L. Then the pair may be sent to all nodes in the local partition.

When each node is booted the node may have an undefined partition color. A node with an undefined color may simply accept any proposed new color . However a node that already has some color may only accept the proposed new color if L

Assuming the above described partition coloring algorithm is utilized an un partition caused when a link is added can be detected as follows. If either of the nodes on the ends of a link has an undefined color or if both nodes have the same color there has not been an un partition. For example a node may have simply booted or re booted . Otherwise if the two nodes have different colors an un partition has been detected.

Once an un partition has been discovered the winning color based upon partition coloring may be propagated so that all nodes in the new partition converge to the same color.

Since a network may have been partitioned into more pieces than two this partition may later join with another partition when another un partition occurs.

Node failures may be manifested as link failures on their neighbor nodes. Thus the basic partition coloring algorithm described above may run on each neighbor node when a node fails. In one embodiment an assumption may be made that nodes in a local subnet remain fully connected and do not become partitioned. If this assumption is made then the partition coloring algorithm only needs to be run when links spanning subnets are lost. Also detection and handling of un partitioning only needs to run when a link spanning subnets is added. This assumption may decrease the overhead of partition un partition handling.

Layers above the T R layer may need to be able to detect when a partition has occurred e.g. to restrict access to a data object. For example a strongly coherent distributed file system may not allow a node on the side of a losing partition a side with less than a majority quorum of persistent replicas of the object to do writes and may not even allow reads depending upon how strict the coherency . Even with a loose coherency distributed file system it may be useful to detect when a partition or an un partition occurs in order to perform conflict resolution.

To support such higher layers it may be useful to have an interface which allows listeners to receive events for partitions and un partitions 

In various embodiments the system described above may be utilized to perform any of various kinds of applications. As one example the system may be utilized to perform distributed data storage such that data is distributed across various nodes in the peer to peer network . However in various embodiments any of various kinds of client application software may utilize the T R layer software to send and receive messages for any desired purpose according to the methods described above.

It is noted that various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking a carrier medium may include storage media or memory media such as magnetic or optical media e.g. disk or CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. as well as transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

Athough the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

