---

title: OpenGL to OpenGL/ES translator and OpenGL/ES simulator
abstract: To address a desire to run 3D applications based on the OpenGL standard on OpenGL|ES mobile devices such as cellular telephones, one must be able to translate function calls between OpenGL and OpenGL|ES. In supporting this translation, and so as to ensure proper data state for the continued execution of the OpenGL application, global GL states which might be changed by an OpenGL|ES function used during translation are stored. The OpenGL to OpenGL|ES translation is then effectuated by substituting appropriate OpenGL|ES commands for OpenGL commands, and passing OpenGL|ES APIs for OpenGL|ES implementation. Thereafter, the global GL states which were previously saved are restored such that the performed translation does not adversely impact continued execution of the OpenGL configured application. This translation process supports OpenGL to OpenGL|ES translation with respect to a number of OpenGL APIs as well as some known extensions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08347275&OS=08347275&RS=08347275
owner: STMicroelectronics, Inc.
number: 08347275
owner_city: Coppell
owner_country: US
publication_date: 20070419
---
This application is a translation of and claims priority from Chinese Patent Application No. 200610077518.0 of the same title filed Apr. 20 2006 the disclosure of which is hereby incorporated by reference herein for all purposes.

The present invention relates to three dimensional 3D application development for mobile devices such as G4M type devices using the OpenGL ES graphic standard and in particular to a translator which functions to allow running of an OpenGL application on top of an OpenGL ES implementation.

The 3D graphic standard OpenGL is commonly used for graphics rendering in personal computer PC environments. The graphic standard OpenGL ES is a lite version of the OpenGL standard which targets mobile devices such as mobile phones and other handsets. Although the OpenGL ES standard is established a problem exists in that the OpenGL ES standard is so new that there are very few 3D applications based on that standard which are available in the market. There do exist however a sizable number of legacy applications which were written for the personal computer in OpenGL. Until more suitable OpenGL ES standard based applications appear on the market consumers would like an opportunity to run the many OpenGL standard based applications on their mobile devices. The differences between OpenGL and OpenGL ES however preclude this from happening to any degree of consumer satisfaction especially with respect to graphically intensive applications such as 3D games.

Among all the primary OpenGL APIs Application Programming Interfaces sometimes referred as commands only about 10 are retained in OpenGL ES with no changes. About 50 of the OpenGL APIs are retained in OpenGL ES with minor changes such as allowing fewer different or new parameters. The rest of the primary OpenGL APIs are not supported in OpenGL ES at all. With respect to an OpenGL based application and an OpenGL ES rendering engine implementation for the APIs of the first category which are fully supported by OpenGL ES the related commands sent by the OpenGL application can be sent straight forward to the OpenGL ES graphic rendering implementation. However with respect to the restricted support OpenGL commands for example where only restricted parameters are supported and the not supported at all OpenGL commands some translation work is necessary to be able to run the application properly on the OpenGL ES implementation.

Dylogic provides a translator program called DOGLESS which translates OpenGL calls into OpenGL ES and forwards them to the underlying OpenGL ES implementation DLL. See http sourceforge.net projects dogless. In order to run an OpenGL application over an OpenGL ES implementation Dylogic s translator intercepts in runtime OpenGL commands not supported in OpenGL ES and tries to translate these commands by using supported commands. This functionality is depicted in the flow diagram of . With this solution some OpenGL applications and games including graphically intensive games like Quake 2 can run properly over the OpenGL ES implementation.

The Dylogic translator of however is a proof of concept product and translates only a very few number of the OpenGL APIs. Furthermore some of these translations are game dependent as will be discussed in more detail below. For example the Dylogic translator is known to work somewhat well with the game Quake 2 but not with other games.

To submit the vertex data coordinates color normal . . . of a polygon to render OpenGL supports two ways a the immediate mode where the data are sent vertex by vertex between two GL commands the glBegin glEnd paradigm an example is shown or b using vertex array for each data type. In OpenGL ES however only the vertex array method is supported. Vertex arrays are more efficient since all the primitive data is sent in a single command. The Dylogic translator tool focuses almost exclusively on the translation of the glBegin glEnd paradigm. This is shown in .

The Dylogic translator solution translates the glBegin glEnd paradigm to vertex arrays as follows in a glBegin command all vertex arrays are activated by using command glEnableClientState which enables all arrays for color normal vertex texture coordinate . This effectuates a transform of complicated primitives into triangles. Then the data for vertex arrays are prepared by assembling the data specified in commands glVertex glColor glTexCoord and glNormal. Next with the glEnd command the vertex arrays are passed to implementation and the object is rendered using API glDrawArray.

What can easily be observed from a review of the Dylogic translator solution is that the translation work is much too simplistic for a number of reasons. First given the needs of the application color normal texture coordinate the Dylogic solution enables all the client vertex data array pointers for vertex coordinates color normal and texture coordinates as well as passes the related arrays to the rendering engine. This means that useless commands and data are used in the solution which might lead to a waste of resources and a dramatic loss of performance. Second in the Dylogic solution no array states are recorded and restored in the glEnd command. This could present memory problems. Third the Dylogic solution fails to take into consideration multiple textures.

It is recognized by those skilled in the art that the OpenGL specification defines optional APIs also called extensions which are proposed by graphic companies and sometimes included as core additions in the specification. Most of the recent popular games use part of these extensions. Unfortunately the Dylogic translator solution does not treat these extensions at all.

In sum the Dylogic translator solution is an incomplete solution at best and is not optimized to be able to run substantially all if not all OpenGL applications over a compliant OpenGL ES implementation. A need accordingly exists in the art for such a translator solution.

In accordance with an embodiment a translation process between OpenGL and OpenGL ES comprises storing global GL states which might be changed by an OpenGL ES function used during translation translating to obtain OpenGL APIs by substituting OpenGL ES commands for OpenGL commands passing the OpenGL ES APIs for OpenGL ES implementation and restoring the global GL states which were previously stored.

In accordance with another embodiment a method for translating to OpenGL ES an automatic Texture Coordinate Generation using a glTexGen command in OpenGL comprises storing texture coordinate array state and data before translation of the command glTexGen using information provided in the command glTexGen deciding which texture coordinate element s t r q should be translated and which translation algorithm should be implemented implementing the chosen translation algorithm to calculate the texture coordinate element s t r q storing generated texture coordinate data passing to an OpenGL ES implementation glEnableClientState and glTexCoordPointer commands which contain the stored texture coordinate data and restoring the texture coordinate array state and data which were previously stored.

In accordance with yet another embodiment a method for translating to OpenGL ES an automatic Texture Coordinate Generation using a glTexGen command in OpenGL comprises intercepting calls of OpenGL glVertexPointer or glVertex glNormalPointer or glNormal functions which include a pointer to a vertices attribute data array saving parameter values for vertices coordinate and normal data and responsive to the glTexGen command performing a process for each vertex. That process comprises calculating vertex coordinates in an eye system using a modelview matrix computing spherical texture coordinates s t activating a texture coordinates array and sending a pointer array to OpenGL.

A process for translating a glBegin glEnd paradigm to draw geometrical objects in OpenGL into a vertex array to draw geometrical objects in OpenGL ES comprises storing GL states and array data transforming complex primitive quads and polygons in OpenGL into smaller pieces of triangles for drawing in OpenGL ES preparing necessary array data for color normal and texture coordinate with respect to the triangles rendering the triangles as objects in accordance with the array data in OpenGL ES and restoring the previously stored GL states and array data.

In accordance with another embodiment a method for translating for support by OpenGL ES an OpenGL API Display list which stores a set of gl commands and drawing commands comprises intercepting a glNewList call to create a display list creating a dynamic gl command array to store gl commands which are called between glNewList and glEndList and responsive to a glCallList call in OpenGL to call the display list executing all the gl commands stored in the dynamic gl command array.

In accordance with another embodiment a method for translating to OpenGL ES an OpenGL graphics call specifying three or more textures wherein OpenGL ES supports a graphics call specifying no more than two textures comprises rendering with OpenGL ES a geometric figure having two of the three or more textures specified by the OpenGL graphics call and for each additional texture specified by the OpenGL graphics call redrawing the geometric figure to be textured in accordance with that additional texture.

In accordance with still another embodiment a translation method comprises wrapping during runtime an OpenGL application with a configurable layer positioned for execution between the OpenGL application and an OpenGL ES rendering engine wherein the configurable layer performs an application independent translation of OpenGL APIs and extensions so as to be supported by the OpenGL ES rendering engine.

To address the deficiencies of the prior art embodiments of the solution wrap during runtime the OpenGL application with a small configurable layer between the application and the OpenGL ES rendering engine. This layer performs an optimized game independent translation of the most commonly used OpenGL APIs and extensions. With this solution visual performance in OpenGL ES should offer a similar result as with the native OpenGL graphic system or at least with a very good approximation.

The following notation is used in the drawings and in connection with the description of the embodiments 

ArrT two dimensional data array for storing the 1st layer texture coordinate data of vertex elements size is m 2 

ArrT two dimensional data array for storing the 2nd layer texture coordinate data of vertex elements size is m 2 

Reference is now made to wherein there is shown a block diagram of an OpenGL ES translator and simulator system in accordance with an embodiment. A translator module receives configuration information as well as GL commands and translates OpenGL APIs not supported in OpenGL ES to supported APIs. The translated APIs are passed on to an OpenGL ES implementation module renderer . The system further includes a simulator module . The simulator module can receive OpenGL ES commands either externally or from the output of the translator module . An OpenGL implementation module renderer receives output from the simulator module thus allowing OpenGL ES APIs to be simulated on the OpenGL implementation.

Reference is now made to which depicts the process of translation performed by the translator module . It is recognized that OpenGL is a state machine. Thus some APIs might change some GL states and thus influence the rendering result. Therefore before sending any OpenGL ES commands the translator module first stores the global GL states which might be changed by the OpenGL ES functions used during the translation. The OpenGL APIs are then translated by implementing an algorithm which uses OpenGL ES commands for those originally implemented in the OpenGL implementation. The new OpenGL ES APIs are then passed for OpenGL ES implementation. Lastly the states that were previously stored are restored in order to conform with a continued execution of the OpenGL application.

A better understanding of the operation of the translator may be obtained by reference to the following examples which explain details of this translation mechanism.

In OpenGL it is a common method to use the glBegin glEnd paradigm to draw geometrical objects. A typical piece of code example for the glBegin glEnd paradigm is shown in where a quad is drawn with specific data for each vertex color normal texture coordinate. However using the glBegin glEnd paradigm to render objects is not supported at all in OpenGL ES. If the application is written to utilize the glBegin glEnd paradigm it is necessary to translate the glBegin glEnd block into vertex array before passing the commands into OpenGL ES pipeline. This translation is performed by translator .

Vertex array commands such as glEnableClientState glVertexArrayPointer glColorPointer which are supported in OpenGL ES are used to render the objects after translation from the glBegin glEnd paradigm of OpenGL. These vertex array commands will necessarily change some GL states and array data perhaps adversely with respect to continued application execution following the translation . Thus these states and data are stored before the translation . An example of a state storage procedure is shown in . As described in colorStateEnable normalStateEnable tex0StateEnable and tex1StateEnable are used to record the current array state. The state storage procedure illustrated in is straight forward. Responsive to the glEnableClientState call color normal and texture coordinate state storage processing is handled.

The illustrated order is exemplary only. First with respect to color processing the process tests if the color array is enabled. If no the process moves on to normal processing . If so the colorStateEnable variable is set to TRUE in step and color client state is enabled in step . The process for storage may then return to the application. In the normal processing the process tests if the normal array is enabled. If no the process moves on to texture coordinate processing . If so the normalStateEnable variable is set to TRUE in step and normal client state is enabled in step . The process for storage may then return to the application. Lastly in texture coordinate processing the process tests if the normal array is enabled. If no the process for storage may then return to the application. If so the process tests if layer is texture active. If yes the tex0StateEnable variable is set to TRUE in step and texture coordinate client state is enabled in step . If no in step the process tests if layer is texture active. If yes the tex1StateEnable variable is set to TRUE in step and texture coordinate client state is enabled in step . If no in test the process for storage may then return to the application.

After state and data are stored a translation by translator of the glBegin glEnd paradigm can be implemented as shown in . At module glBegin mode complicated primitives are transformed to triangles. The details of this transformation performed by module glBegin mode is shown in . In OpenGL ES complex primitive types such as quads and polygons are not supported. Thus if quads and polygons are indicated by mode these primitive need to be broken down into smaller pieces of triangles for drawing in OpenGL ES. illustrates how the parameter of glBegin mode is changed based on the OpenGL quads and polygons identification. As shown and in response to the glBegin mode call in transform module a test is made in step as to whether the mode is a GL QUAD STRIP. If so the OpenGL mode designation of GL QUAD STRIP is changed in step to GL TRIANGLE STRIP and the process returns . If no in test the process next tests in step as to whether the mode is GL QUADS. If so the OpenGL mode designation of GL QUADS is changed in step to GL TRIANGLES and the process returns . If no in test the process next tests in step as to whether the mode is GL POLYGON. If so the OpenGL designation of GL POLYGON is changed in step to GL TRIANGLE FAN and the process returns . In this way the OpenGL complicated primitives based on quads and polygons are transformed to triangles which are supported for drawing in OpenGL ES.

With reference once again to after the transform shown in detail in the translation uses a preparation module . In module array data for color normal and texture coordinate are prepared in case they are used by the application. The preparation activities are illustrated in more detail in . These array data are collected from the commands glVertex glColor glNormal and glTexcoord and stored in arrays ArrV ArrC ArrN ArrT respectively. In the event multiple texture is used the second layer texture coordinates array data are collected from command glMultiTexCoord and stored in array ArrT. For example the preparation module responds to calls of one or more of the glMuItTexCoord function glTexCoord function glNormal function and glColor function . Responsive thereto the states for texEnable normalEnable and colorEnable are set TRUE in steps in comparison to calls respectively in order to make sure the proper data arrays are used. This assists in helping ensure that only useful commands are passed to the OpenGL ES implementation. Then the proper data arrays are prepared. For multiple textures responsive to the glMultTexCoord function call the data arrays ArrT and ArrT as discussed above are prepared in step . For single texture responsive to the glTexCoord function call the data array ArrT as discussed above is prepared in step . For normal responsive to the glNormal function call the data array ArrN as discussed above is prepared in step . Lastly for color responsive to the glColor function call the data array ArrC as discussed above is prepared in step .

Following preparation in step the translation process of module glEnd is performed. Module includes three modules a pass data array module a render objects module and a restore data and states module . In the process all useful array states are enabled and useful array data are passed to the implementation. The operation of the pass data array module is explained in detail in .

With respect to color processing a test is made in step as to whether colorEnable is TRUE. If so a test is made in step as to whether colorStateEnable is TRUE. If so then the color array ArrC step is passed in step . If no in step then the color client state is enabled in step and the color array ArrC step is passed in step . If no in step a test is made in step as to whether colorStateEnable is TRUE. If so then the color client state is disabled in step . If no in step or following steps or the process for color terminates and operation of the pass data array module continues.

With respect to normal processing a test is made in step as to whether normalEnable is TRUE. If so a test is made in step as to whether normalStateEnable is TRUE. If so then the normal array ArrN step is passed in step . If no in step then the normal client state is enabled in step and the normal array ArrN step is passed in step . If no in step a test is made in step as to whether normalStateEnable is TRUE. If so then the normal client state is disabled in step . If no in step or following steps or the process for color terminates and operation of the pass data array module continues.

With respect to texture processing a test is made in step as to whether textEnable is TRUE. If so a test is made in step as to whether tex0StateEnable is TRUE. If so then the texture coordinate array ArrT step is passed in step . If no in step then the texture coordinate client state is enabled in step and the texture coordinate array ArrT step is passed in step . If no in step a test is made in step as to whether tex0StateEnable is TRUE. If so then the texture coordinate client state is disabled in step . If no in step or following steps or the process for texture terminates and operation of the pass data array module continues.

With respect to multiple texture processing a test is made in step as to whether textEnable is TRUE. If so a test is made in step as to whether multitextEnable is TRUE. If so a test is made in step as to whether tex1StateEnable is TRUE. If so then the texture coordinate array ArrT step is passed in step . If no in step then the texture coordinate client state is enabled in step and the texture coordinate array ArrT step is passed in step . If no in step a test is made in step as to whether tex1StateEnable is TRUE. If so then the texture coordinate client state is disabled in step . If no in step or no in step or following steps or the process for texture terminates and operation of the pass data array module continues.

For a more complete understanding of the process performed by the module consider as an example how this module passes color information see color processing . Suppose that the command glColor is called by the application in module . If so then the state variable colorEnable is set TRUE see . In this case the command glEnableClientState GL COLOR ARRAY should be passed to the implementation. In order to avoid passing redundant commands it is better to check if state variable colorStateEnable is also TRUE this state variable has been recorded in . If this state is TRUE then it is not necessary to send the command glEnableClientState GL COLOR ARRAY as it has been sent before the glBegin glEnd paradigm being evaluated in . If we instead suppose that the command glColor has not been called by the application in module in which case the state variable colorEnable is set FALSE then it is not necessary to pass command glEnableClientState GL COLOR ARRAY to implementation. However if the recorded state variable colorStateEnable is TRUE then command glDisableClientState GL COLOR ARRAY should be used to prevent the color information specified for other objects from influencing the rendering result of the glBegin glEnd paradigm.

The processes and or relating to other information concerning normal and texture coordinates as shown in generally share the same translation procedure as with the color information example just provided.

With reference once again to after all the useful array state and data are enabled and passed to implementation module it is time to render the object s using the commands glDrawArray or glDrawElements. This task is carried out by the render objects module .

After rendering the objects the states and data should be restored by the restore data and states module . The operation of the module is explained in detail in .

With respect to color processing a test is made in step as to whether colorEnable is TRUE. If so a test is made in step as to whether colorStateEnable is TRUE. If so then the data for the color array ArrC is restored in step . If no in step then the color client state is disabled in step and the color array ArrC is restored in step . If no in step a test is made in step as to whether colorStateEnable is TRUE. If so then the color client state is enabled in step . If no in step or following steps or the process for color terminates and operation of the restore module continues.

With respect to normal processing a test is made in step as to whether normalEnable is TRUE. If so a test is made in step as to whether normalStateEnable is TRUE. If so then the data for normal array ArrN is restored in step . If no in step then the normal client state is disabled in step and the data for the normal array ArrN is restored in step . If no in step a test is made in step as to whether normalStateEnable is TRUE. If so then the normal client state is enabled in step . If no in step or following steps or the process for color terminates and operation of the restore module continues.

With respect to texture processing a test is made in step as to whether textEnable is TRUE. If so a test is made in step as to whether tex0StateEnable is TRUE. If so then the data for the texture coordinate array ArrT is restored in step . If no in step then the texture coordinate client state is enabled in step and the data for the texture coordinate array ArrT is restored in step . If no in step a test is made in step as to whether tex0StateEnable is TRUE. If so then the texture coordinate client state is enabled in step . If no in step or following steps or the process for texture terminates and operation of the restore module continues.

With respect to multiple texture processing a test is made in step as to whether textEnable is TRUE. If so a test is made in step as to whether multitextEnable is TRUE. If so a test is made in step as to whether tex1StateEnable is TRUE. If so then the data for the texture coordinate array ArrT is restored in step . If no in step then the texture coordinate client state is disabled in step and the data for the texture coordinate array ArrT is restored in step . If no in step a test is made in step as to whether tex1StateEnable is TRUE. If so then the texture coordinate client state is enabled in step . If no in step or no in step or following steps or the process for texture terminates and operation of the restore module continues.

A more complete understanding of the process performed by the module may be obtained by considering as an example how this module restores color information see color processing . Thus with respect to the previous example concerning color information if the state variable colorEnable is TRUE but the stored state variable colorStateEnable is FALSE then in this case glDisableClientState GL COLOR ARRAY should be used in order to keep accordance with the state specified before the glBegin glEnd paradigm.

The processes and or relating to other information concerning normal and texture coordinates as shown in generally share the same restoration procedure as with the color information example just provided.

In order to reduce the number of function calls overhead inside a glBegin End block it is possible with OpenGL to use Arrays for sending the vertices attributes to OpenGL using the function glArrayElement . Unfortunately the function glArrayElement is not supported by OpenGL ES because the immediate mode is not supported.

In OpenGL the texture coordinate can be specified by the command glTexCoord and texture coordinate arrays it can also be generated automatically by the command glTexGen. Many existing OpenGL games use this automatic Texture Coordinate Generation mechanism. However the automatic texture generation process is not supported in OpenGL ES. In accordance with an embodiment a process is provided to allow support of these texture generation algorithms in OpenGL ES.

OpenGL utilizes several algorithms such as sphere map object linear eye linear and the like in texture generation. Since OpenGL ES only supports vertex array the texture coordinate array is used to store the texture coordinate data generated by the generation algorithm. An exemplary implementation procedure is shown in .

In step the texture coordinate array state and data are stored before translation of glTexGen. More specifically this state information is stored in the manner shown in .

Next in step the process decides which element s t r q of the texture coordinate should be translated and which algorithm should be implemented. The decision is made using the information provided in the command glTexGen. In this step the process also decides which texture object is needed to generate the texture coordinate since multiple textures might be used to apply to one object.

In step the process implements the chosen algorithm and calculates the texture coordinate s t r q . The texture coordinates data is then stored into the texture coordinates array.

Next in step the process passes to the OpenGL ES implementation two commands glEnableClientState GL TEXTURE COORD ARRAY and glTexCoordPointer with the texture coordinate data prepared in step .

Lastly in step the process restores the texture coordinate states and data which were previously stored according to step .

With reference now to an illustration is provided of a mechanism to allow support of a texture generation algorithm in OpenGL ES for the case of sphere mapping. The application must first send to OpenGL the pointer to the vertices attribute data array by calling the OpenGL functions glVertexPointer or glVertex glNormalPointer or glNormal . The translator intercepts these calls reference and saves and the parameters values for the vertices coordinate and normal data respectively. Then with respect to the glTexGen command the translator performs the following process for each vertex . First the vertex coordinates are calculated in the eye system using a modelview matrix step . Next in step the spherical texture coordinates s t are computed. Lastly the texture coordinates array is activated and the pointer array is sent to OpenGL in step . The resulting OpenGL ES commands are then passed to the OpenGL ES pipe for execution.

The OpenGL API Display lists allow for the storing of a set of gl commands and drawing commands. More specifically the set of gl commands and drawing commands are pre computed and stored by OpenGL. This Display lists API thus allows for saving some computation time when rendering an object several times. Unfortunately this API is not supported by OpenGL ES.

Reference is now made to which depicts the translation mechanism of display lists in accordance with an embodiment. The translator does not aim to pre compute the gl commands in the display list as a typical OpenGL implementation would do. Instead the translator saves the commands with their parameter values in order to recall them when the display list is called by glCallList. The operation of the translation is as follows when the application calls glNewList in order to create a display list the translator creates internally a dynamic array of gl commands a link table that will be used to store the gl commands that will be called between glNewList and glEndList . It also activates an internal flag specifying that when a gl command that can be stored into a display list is called by the application the translator just stores the gl command with the value of each parameter into the internal gl command array the link table . Later each time the application calls glCallList to call the display list the translator will call i.e. execute all the gl commands stored in the associated internal gl command array link table . The resulting OpenGL ES commands are then passed to the OpenGL ES pipe for execution. Responsive to the OpenGL glDeleteList call by the application the translator deletes the link table.

Since OpenGL version 1.2 it is possible to apply several textures on the same polygon using several texture units. However OpenGL ES version 1.1 only supports the use of a maximum of two texture units. An embodiment handles the situation where the application makes use of more than two texture units which is often the case in the new OpenGL commercial games such as Quake 3 .

Reference is now made to . Suppose that OpenGL ES supports only two texture units. The translator responsive to the specified two first textures would generate the OpenGL ES commands to cause a polygon to be rendered with the two first textures in accordance with the normal operation of OpenGL ES. If however a third layer of texture is requested by the application in OpenGL the translator operates to redraw the same polygon to be textured with the third texture . The appropriate OpenGL ES commands to cause the redrawn polygon to be rendered are accordingly issued by the translator . The same operation can be repeated for any further texture layers up to layer n requested by the application in OpenGL.

It is recognized that several hundred of OpenGL APIs exist. Several examples of how the concepts herein can be used to support such APIs in the OpenGL ES environment have been provided above. The general translation procedure which may be used with respect to any of the OpenGL APIs is shown in as described above .

In comparison to those APIs which have been translated using the Dylogic solution the translator in accordance with embodiments herein provides an optimized result which is more reasonable and complete than with the prior art. In comparison for example for translation of the Begin End paradigm two new steps and are added into End command translation .

Using the process of applicants have translated about 70 of the OpenGL APIs including such APIs as Display list see above automatic texture coordinate generation see above PushAttribts and PopAttributs light family material family support for more texture internal format support for more complex data types support for complex primitives . It is noted that the remaining 30 of the OpenGL APIs are very seldom used by applications.

The translator according to embodiments herein also supports many extensions like arb multitexture ext texture compression s3tc ext compiled vertex array arb texture cube map and the like.

The translator according to embodiments herein has proven its efficiency by being able to successfully run a wide range of modern and complex 3D OpenGL games over different compliant OpenGL ES implementations. In most cases the visual results are exactly or nearly exactly the same as if they were rendered with a real OpenGL rendering engine. For some others the differences are almost imperceptible for the player during game play. For example the translator has been successfully tested with the following games Quake 1 Quake 2 Quake 3 Tread Mark and Return To Castle Wolfenstein. All of these games use begin end block and multiple texture extension and further run properly in OpenGL ES without any noticeable distracting artifacts. The translator has also been successfully tested with TuxRacer which uses texture coordinate generation and compiled vertex array extension and runs properly without any noticeable distracting artifacts. The translator has also been successfully tested with Doom3 which uses cube map extension and multiple texture extensions and can work over OpenGL ES implementation with very limited differences. The translator has also been successfully tested with No Limits Roller Coaster which uses display list and works very well. The translator has also been successfully tested with OglVillage which uses PushAttrib PopAttrib and S3TC compressed texture extension and works substantially perfectly.

By this mechanism of translation more APIs and extensions can be supported and therefore more games and applications can run over OpenGL ES implementations.

Comparing with the prior Dylogic solution a solution is presented that is a more complete OpenGL to OpenGL ES translator many more OpenGL games can work over any compliant OpenGL ES implementation through the present translator. The solution is also more optimized since the mechanisms of translation are game independent and cover all the most common cases.

Advantage 1 With this solution it is possible to port immediately an OpenGL application for PC to mobile devices by doing a runtime translation of the commands issued by the application into OpenGL ES commands. Thus it is not necessary to recompile the application.

Advantage 2 By being between the application and the rendering engine the translator can act as a configurable filter which allows a runtime reduction of the complexity of the scene to render. For example since the screen on a mobile device is much smaller than a PC screen it is possible to consider decreasing by a given percentage the number of triangles in the mesh of the models to render or the resolution of the textures and thus decrease the number of computation to be done by the graphic engine to save time and power.

Advantage 3 The OpenGL ES simulator is a powerful tool for those who want to develop OpenGL ES applications for mobile phones. Indeed since applications for mobile devices are usually developed on workstations or PCs the OpenGL ES simulator allows a very fast and convenient way to simulate the OpenGL ES rendering directly on the PC and thus accelerate the debugging phases.

Although preferred embodiments of the method and apparatus of the present invention have been illustrated in the accompanying Drawings and described in the foregoing Detailed Description it will be understood that the invention is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the spirit of the invention as set forth and defined by the following claims.

