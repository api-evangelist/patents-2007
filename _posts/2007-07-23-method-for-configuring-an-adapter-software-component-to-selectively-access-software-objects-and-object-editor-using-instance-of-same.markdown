---

title: Method for configuring an adapter software component to selectively access software objects and object editor using instance of same
abstract: An object editor capable of displaying a set of application software objects, which may include objects with a dynamic reflection capability (“reflective objects”), includes an object oriented configuration model instance (CMI), a generic adapter, and a UI framework. The CMI is particular to the set of application objects to be edited and defines a particular view of these objects to be provided by the editor. The CMI is external to the generic adapter and includes settings that control which application objects will be accessed and the manner of access. The generic adapter reads the de-serialized CMI's current settings, selectively accesses the set of application objects to be edited and their attributes as dictated by the CMI settings, and passes the accessed information to the LII framework for display.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08015545&OS=08015545&RS=08015545
owner: International Business Machines Corporation
number: 08015545
owner_city: Armonk
owner_country: US
publication_date: 20070723
---
This application is a continuation of application Ser. No. 10 314 806 filed Dec. 9 2002 now U.S. Pat. No. 7 272 819 status allowed.

The present invention relates to adapter software components and more particularly to adapter software components that are configurable with an external configuration model instance to selectively access software objects. The invention further relates to object editors which use such adapter software components.

In recent years software developers have become increasingly reliant upon computer aided software engineering CASE tools. This is due at least in part to increasing consumer demand for software of greater complexity and improved reliability. CASE tools characteristically permit software to be abstracted to a level at which architectures and designs are more apparent than in their source code form and may thus speed robust development.

In the realm of object oriented OO software design one type of CASE tool that may be of considerable benefit to a software developer is the OO model editor or simply model editor . Model editors such as the Rational Rose Unified Modeling Language UML model editor promote improved visualization and comprehensibility of object oriented designs by permitting a developer to view and edit abstract classes for a particular application graphically for example. Model editors and associated tools such as the add in extensions to the Rational Rose model editor may be capable of automatically generating object oriented programming language OOPL code corresponding to a graphically created model to facilitate the often tedious task of software implementation.

A related type of software tool is the object editor. Unlike the odel editor which edits OO models i.e. abstract classes an object editor is capable of displaying and editing software objects i.e. instances of modeled classes . Though not CASE tools object editors are nevertheless beneficial in that like model editors they promote improved visualization and comprehensibility of object oriented entities for clarity the term object editor herein should be understood to include applications which merely display objects but are not necessarily capable of updating the objects .

An object editor may be implemented in accordance with the Model View Controller MVC paradigm. As known by those skilled in the art the MVC paradigm dictates that an application s representation of real world entities its user interface and its manner of mapping the real world entity representations to the user interface shall be handled by way of a separate Model component View component and Controller component respectively. A benefit of adopting the MVC paradigm is modularity and component reusability.

In an MVC compliant object editor the objects being edited may comprise the Model component as the objects typically represent real world entities. A known UI framework such as the Java Foundation Class Swing components from SUN Microsystems Swing may be chosen to comprise the View component. A UI framework such as Swing provides the basic UI constructs e.g. windows buttons menus etc. for implementing a graphical user interface GUI and may advantageously be familiar to the user. A UI framework may further include high level constructs which facilitate such operations as displaying a set of objects in the form of a tree e.g. the javax.swing.Jtree construct of Swing or as a table. Finally the Controller component may comprise a UI framework controller module e.g. in the case of Swing javax.swing.tree.TreeModel which is designed to map certain generic methods e.g. getChildren getText or the like to logically analogous methods in application objects to be edited e.g. for a bank object getAccount and getBankName respectively . This mapping facilitates a tree like or tabular display that is logical with respect to the nature of the displayed objects. As known to those skilled in the art the UI framework s higher level constructs are segregated from the UI framework controller module for reasons of code efficiency many of the mapping functions implemented by the controller module may be needed by more than one high level construct e.g. a tree display construct and a table display construct may both need to invoke a getText method for a displayed object .

In certain implementations the Controller component of an MVC compliant object editor may further include an adapter. As known to those skilled in the art an adapter is a software component e.g. an object which converts the interface of one or more classes to an interface expected by a client which in the instant case is the UI framework controller module. Adapters are described in the text Design Patterns by Erich Gamma et al. 1995 Addison Wesley Chapter 4 . In the instant case the adapter adapts the interface of the objects to be edited i.e. the Model to the interface expected by the UI framework controller module and thus adapts the objects of interest to the UI framework.

Some object editors may be capable of use with objects which incorporate a dynamic reflection capability. As known to those skilled in the art reflection is the capacity of a software object to have its characteristics determined dynamically through examination of the object at run time. In simple terms reflection permits an object to be dynamically queried as to the attributes that it possesses and its associations with other objects which may be referred to herein as its relatives . Software objects with this capability may be interacted with even in the case where the object s attributes e.g. fields and associations with relatives e.g. children are not known at the time of implementation.

For example an object having a dynamic reflection capability referred to herein as a reflective object which comprises an instantiated OOPL class representative of say an automobile may be interrogated at run time as to its characteristics and in response may indicate that it has four attributes named make model color and year and two associations with other objects namely an owner object and a dealer object. Further this reflective object may provide the current values of these attributes and references to the associated relative objects. All of this is possible despite the interrogator s initial lack of awareness that the object under interrogation was in fact representative of an automobile.

The dynamic reflection capability of MOF objects is facilitated by MOF s reflective module through which meta objects associated with the MOF objects may be accessed. As known by those skilled in the art it is these meta objects that provide the above described object meta information regarding MOF object characteristics e.g. a meta automobile object can return information regarding the characteristics of a corresponding automobile object at run time as described above .

In the context of the above described MVC compliant object editor a benefit which arises when the objects being edited are reflective is that the adapter may in some respects be made more generic. That is rather than containing specific hard coded references to particular attributes relationships or methods of an object being edited the adapter may utilize more generic reflection tools e.g. in the case of MOF objects reflective module methods such as refMetaobject refValue refSetValue etc. to gain access to the attributes and relationships of the object s being edited by way of the associated meta objects.

Disadvantageously however the adapter component cannot be made entirely generic. This is because despite the use of the reflection within the adapter code at some level e.g. in the context of parameters to reflective module methods the adapter still hard codes which application objects attributes and associations should be accessed to effect the desired view of the displayed objects. For example if it is desired to display an automobile object s color attribute in the operative view the corresponding reflective method invocation within the adapter code is required at a minimum to specify the color attribute of the automobile object as the attribute name for which a current value reading is required. Disadvantageously if it is desired to change the way in which objects or attributes are displayed e.g. which application objects and attributes are visible or the arrangement of object data or if it becomes necessary to use the editor with a new class of objects with different attributes and associations the adapter code must be painstakingly updated and then recompiled in order to effect the desired changes. This constraint impacts negatively on the object editor s flexibility.

In applications other than object editors adapter software components may be used to conform the interface of one or more application object classes to an interface expected by a client. The role served by the adapter in such applications is similar to the aforedescribed role of the adapter in an object editor with the exception that the client in such cases is not a UI framework but rather some other software component. Here too adapters suffer from a problem similar to the one described above if it is desired to change the way in which application objects or attributes are accessed by the adapter or if it becomes necessary to use the adapter with a new class of objects with different attributes and associations the adapter code must be edited and then recompiled in order to effect the desired changes.

What is therefore needed is an object editor capable of editing reflective objects which may be configured to selectively display objects and their attributes without necessitating software recompilation. What is also needed is a method of configuring an adapter to selectively access objects including reflective objects and their attributes without necessitating adapter recompilation.

In one aspect an object editor capable of displaying a set of application software objects which may include objects with a dynamic reflection capability reflective objects includes an configuration model instance CMI a generic adapter and a UI framework. The CMI is particular to the set of application objects to be edited and defines a particular view of these objects to be provided by the editor. The CMI is external to the generic adapter and includes settings that control which application objects will be visible which of the visible objects attributes will be displayed the arrangement of displayed application objects and attributes and the appearance of the displayed objects and attributes. The CMI may be stored as an XML or XMI file. The generic adapter reads the CMI s current settings selectively accesses the set of application objects to be edited and their attributes as dictated by the CMI settings and passes the accessed information to the UI framework for display. The adapter uses reflection to access the attributes and associations of reflective objects. To access non reflective application objects a custom adapter that does not use reflection may be designated. The CMI settings may be changed between editor invocations to cause objects or their attributes to be accessed and displayed differently or not at all. The editor may be configured to edit a new set of software objects by substituting a new CMI corresponding to that set of objects.

In another aspect a configurable generic adapter intended for use in an application which may not be an object editor is configurable by way of an external CMI. The CMI is particular to the set of application objects being utilized by the application which may include reflective objects. The CMI defines a particular manner of navigating the application objects. For reflective application objects the generic adapter reads the CMI s current settings selectively accesses the set of application objects and their attributes as dictated by the CMI settings and passes the accessed information to a client software component for use. The adapter uses reflection to access the attributes and associations of reflective objects. For non reflective application objects a custom adapter that does not use reflection may be designated. The CMI settings may be changed between application invocations to cause the application to access the objects differently and thus to behave differently. The CMI may be stored as an XML or XMI file.

In a further aspect of the present invention there is provided a configuration model for configuring at least one adapter software component to selectively access set of application software objects including at least one reflective application software object the at least one adapter software component including a generic adapter software component which uses reflection to access reflective application software objects the configuration model being an object oriented implementation and being external to the at least one adapter software component.

In another aspect of the present invention there is provided a computer readable medium storing computer software that when loaded into a computing device adapts the device to in an adapter software component selectively access a reflective application software object by accessing a configuration model instance CMI external to the adapter software component to determine a manner of accessing the reflective application software object and using reflection to selectively access the reflective application software object in the manner indicated by the CMI.

In yet another aspect of the present invention there is provided a computer readable medium storing computer software that when loaded into a computing device adapts the device to in an adapter software component access at least one application software object of a set of application software objects the at least one application software object having a desired relationship with a specified reflective application software object by accessing a configuration model instance CMI external to the adapter software component to determine a manner of identifying the at least one application software object that has the desired relationship with the specified reflective application software object and using reflection to access the at least one application software object identified using the determined manner of identifying.

In another aspect of the present invention there is provided a method of configuring an adapter software component to selectively access application software objects including providing a serialized configuration model instance CMI that is external to the adapter software component and is indicative of a desired manner of accessing the application software objects de serializing the CMI and accessing the de serialized CMI from the adapter software component to determine the desired manner of accessing the application software objects.

In still another aspect of the present invention there is provided a computer readable medium storing a controller software component for mapping a client software component method to a corresponding method capable returning a desired feature of a reflective application software object the controller software component including an adapter software component having a method corresponding to the client software component method the adapter software component method being configurable to access the desired feature of an application software object using reflection and a configuration model instance external to the adapter software component for configuring the adapter software component method to selectively access the desired feature of an application software object using reflection.

In yet another aspect of the present invention there is provided an object editor including a user interface framework a controller software component for mapping at least one method of the user interface framework to a corresponding method capable of returning a desired feature of a reflective application software object the controller software component including an adapter software component having a method corresponding to the user interface framework method the adapter software component method being configurable to access the desired feature of an application software object using reflection and a configuration model instance external to the adapter software component for configuring the adapter software component method to selectively access the desired feature of an application software object using reflection.

In another aspect of the present invention there is provided in an adapter software component a method of selectively accessing a reflective application software object including accessing a configuration model instance CMI external to the adapter software component to determine a manner of accessing the reflective application software object and using reflection to selectively access the reflective application software object in the manner indicated by the CMI.

In yet another aspect of the present invention there is provided a computing device operable to cause an adapter software component to selectively access a reflective application software object by accessing a configuration model instance CMI external to the adapter software component to determine a manner of accessing the reflective application software object and using reflection to selectively access the reflective application software object in the manner indicated by the CMI.

In another aspect of the present invention there is provided in an adapter software component a method of accessing at least one application software object of a set of application software objects the at least one application software object having a desired relationship with a specified reflective application software object including accessing a configuration model instance CMI external to the adapter software component to determine a manner of identifying the at least one application software object that has the desired relationship with the specified reflective application software object and using reflection to access the at least one application software object identified using the determined manner of identifying.

In yet another aspect of the present invention there is provided a computing device operable to cause an adapter software component to access at least one application software object of a set of application software objects the at least one application software object having a desired relationship with a specified reflective application software object by accessing a configuration model instance CMI external to the adapter software component to determine a manner of identifying the at least one application software object that has the desired relationship with the specified reflective application software object and using reflection to access the at least one application software object identified using the determined manner of identifying.

Other aspects and features of the present invention will become apparent to those of ordinary skill in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.

Display is a conventional display device such as a CRT flat screen monitor or liquid crystal display capable of presenting a GUI to a user . The display may form part of the computing device comprising the computing system .

The user input mechanism is a device or devices capable of generating user input representative of commands for operating the object editor . The UIM may be a keyboard mouse or touch screen for example or a combination of these devices and may be capable of controlling a movable pointer on the display for interacting with a GUI. The UIM may form part of the computing device which comprises the editor .

The editor software contained in volatile memory facilitates the object editor s display and editing of application software objects which may include reflective objects. As will be described the software adheres to the Model View Controller MVC design paradigm. The software is comprised of six parts the core editor code the UI framework the adapter factory the generic adapter an optional custom adapter and the object oriented configuration model instance CMI . These parts will be described below in the context of the software component description of . The object editor software may be loaded into the volatile memory of the editor from any suitable computer readable medium such as a removable optical or magnetic disk or from resident non volatile memory such as a hard drive or a read only memory chip.

Volatile memory also comprises a set of application software objects to be edited. The application objects are interrelated in accordance with an operative application object model described below pertaining to a particular application. In the present embodiment the exemplary application to which the objects pertain is a banking application. The objects are instantiated from Java classes that are created by way of one or more software or tools which input the above referenced banking model and generate corresponding OOPL code. The objects of the present embodiment are all MOF compliant and thus possess a dynamic reflection capability i.e. they are reflective . The manner in which the objects are made MOF compliant in the present embodiment is by way of their inheritance of MOF implementation classes from a MOF package implemented in the Java OOPL. The MOF package upon which the MOF objects depend follows OMG s MOF standard version 1.3. The associated specification is set forth at ftp ftp.omg.org pub docs formal 01 11 02.pdf. The generation of such MOF compliant OOPL code may be facilitated using tools such as the MOF Add In to the Rational Rose Model Editor. Alternatively the software objects may be implemented manually without the use of the described software tools.

Non volatile memory contains a file comprising a saved representation of the application objects to be edited. In the present embodiment the file is a serialized XML representation of the banking objects comprising the set of objects . As known to those skilled in the art XML is a meta language which allows users to define application specific information formats. For further background information regarding XML the reader is referred to the text by Frank Boumphrey et al. 1998 Wrox Press.

As will be appreciated the saved application objects file is initially read de serialized by the editor in order to instantiate the objects prior to their display by the editor . Thereafter upon the completion of editing the objects may be saved serialized back to the file possibly with updated data values. The serialization of objects to an XML file such as file is in accordance with the metadata interchange as defined in section 2.4.3 of the above referenced MOE specification.

Non volatile memory further includes two versions of a configuration model instance file comprising saved serialized representations of a CMI . These files are also XML in the present embodiment and may be serialized in the same manner as the saved objects file . Each CMI file may be thought of as a plug in to the object editor which dictates the operative view of the application objects to be edited i.e. which objects attributes will be visible how the objects will be arranged etc. . It should be appreciated that CMI files are particular to the set of application objects to be edited. Here each of the CMI files pertains to the banking related application objects and each provides an alternative view of the same set of application objects . The CMI files may be prepared by a system configurator based on an understanding of the application software objects to be displayed the underlying motivation or purpose for the editing of the objects and the operative configuration model to be described . The view of the edited objects may be changed between editor invocations by configuring the editor to instantiate a different one of CMI files and than was previously used. It will be appreciated that additional CMI files defining further alternative views of the objects may exist in non volatile memory .

As illustrated in the View component of the object editor which provides the editor with its user interface includes the core editor code higher level UI framework constructs and basic UI framework constructs .

The core editor code comprises executable software code which serves as the main program of the object editor . The core editor code implements basic editor capabilities such as loading i.e. reading from file and de serializing a set of application objects to be edited and saving the edited objects back to file . The code further determines the general type of view e.g. tree table etc. that is to be provided of the application objects . The core editor code may be implemented by a software developer familiar with the editing task to be performed using an OOPL such as Java for example. The core editor code utilizes and interacts with basic UI framework constructs as well as high level UT framework constructs to achieve these goals.

The basic UT constructs provide fundamental tools for implementing a GUI. These may include menus button or window objects application programming interfaces APIs for common operating system interactions e.g. accessing files from secondary memory and the like. The basic UI constructs are utilized by the core editor code to implement basic editor capabilities.

The higher level UT constructs facilitate the display of sets of objects of any type or sets thereof in certain commonly utilized display formats. For example the constructs include a tree viewer construct which permits a set of related objects of any type to be displayed in the form of a tree. The constructs further include a property sheet viewer construct which permits a property sheet for a selected application software object to be displayed. Further constructs such as a table viewer construct which permits the display of object sets in table form may be included in the constructs despite not being illustrated. It should be appreciated that the tree viewer and property sheet viewer are illustrative and may have different names in different UT frameworks . As well different UT frameworks may comprise different sets of high level constructs. The high level constructs are utilized by the core editor code to implement the general type of view e.g. tree or table that is to be provided of the application objects .

The Controller component of the object editor which is responsible for mapping the Model component to the user interface provided by the View component includes the UT framework controller module the adapter factory the generic adapter the optional custom adapter and the configuration model instance .

The UI framework controller module is provided by the UI framework to support the display of objects by the high level UI framework constructs . The controller module maps generic display related methods of the UI framework e.g. getChildren or getParent invoked from within the high level constructs e.g. the tree viewer construct to adapter methods which retrieve the desired objects attributes of the application objects to permit the generic methods to provide the desired view of the objects . The controller module interacts with the adapter factory for the purpose of identifying the appropriate adapter to use for a particular class of application objects and with the generic adapter or the custom adapter whichever is returned by the adapter factory for a particular object to retrieve desired application object data. The controller module is edited by a software developer to provide the functionality described herein. It should be recognized that despite being part of the UT framework the controller module is considered to be part of the Controller component of the object editor as shown in and not the View component as it serves a Controller function.

As shown in the higher level UT framework constructs basic UI framework constructs and UI framework controller module cumulatively comprise the UI framework this framework may comprise a known object oriented UI framework such as the Java Foundation Class Swing components from SUN Microsystems.

The adapter factory is a software component which is responsible for identifying and returning the appropriate adapter to be used for a particular class of application software object . It may thus be helpful to conceive of the adapter factory as an adapter selector . Upon being invoked by the controller module the adapter factory interacts with the CMI in order to determine which adapter is appropriate for the application object class in question. The identified adapter may be either the generic adapter or a custom adapter . The identified adapter is returned to the UI framework controller module .

The generic adapter is a software component which maps the generic methods of the UI framework controller module to routines which provide a logically analogous function for the software application objects to be edited so as to effect the desired view. The adapter interacts with the CMI to determine the appropriate mapping for a particular application object class. The adapter is referred to as generic because it utilizes reflection to access attributes and associations of any reflective objects being edited and thus does not include any specific references to attributes or associations that are particular to a displayed application object type. The generic adapter is accordingly used only for reflective here MOF compliant objects.

The custom adapter is an optional software component which provides for a particular class of application objects a specialized mapping between the above noted generic UI controller module methods and specific application object methods of that class which effect the desired view. Custom adapters may be used in cases when an application object class is not reflective such that the generic method s use of reflection would not be supported or because a customized adapter behavior outside the scope of the generic adapter s functionality is desired for a particular class of application objects. The custom adapter does not interact with the CMI as its settings are hard coded. It should be appreciated that the custom adapter is specific to a particular application object class thus in the case when custom adapter behavior is desired for multiple application object classes multiple custom adapters may be provided.

Configuration model instance is a set of software objects which comprise the settings that control the manner in which the application objects being edited by the object editor are accessed and displayed. The CMI is external to the generic adapter i.e. it is separate from the code which implements the generic adapter . As a result the CMI permits configuration of the generic adapter without generic adapter recompilation. In the case of object editor the CMI controls which objects will be visible which of the visible objects attributes will be displayed the arrangement of displayed objects and attributes and the appearance of the displayed objects and attributes. The CMI achieves this in part by controlling which adapters are to be used for a particular application object class more generally the CMI achieves this by controlling which objects and attributes of the set of application objects being edited will be accessed by the adapter and in what order. As will subsequently be described in more detail in conjunction with the settings of the CMI take the form of instances of various object oriented classes defined in the operative configuration model which instances represent different aspects of a view of the application objects to be edited. The CMI is instantiated from set of OOPL e.g. Java classes which implement this operative configuration model. The CMI is created through de serialization of a CMI file or .

As illustrated the banking model comprises three concrete object classes namely a Bank class an Account class and a Client class representative of a bank branch a bank account and a bank client respectively. As will be apparent to those skilled in the art the containment relationship between the Bank class and the Account class reflects the fact that multiple accounts may be associated with a bank branch instance. Similarly the uni directional association between the Bank class and the Client class reflects the fact that multiple clients may also be associated with a bank branch instance. A bi directional association between the Account and Client classes and indicates that Account objects and Client objects are each able to access one another by way of the holder and accounts associations respectively. The indicated cardinalities 1 . . . indicate that an account may have more than one holder and that a client may have more than one account.

The Bank class includes a name field representative of the bank name and a location field representative of the bank branch location. The Account class includes a name attribute reflecting the account name e.g. Savings or Chequing a number attribute indicative of a unique bank account number and a balance attribute representing the account balance in dollars. The Client class includes only a name attribute representing a client name.

Referring now in more detail to the application objects comprise a first group and a second group . Each group is logically associated with a single bank branch and thus includes a single Bank object and contains no associations to any object of the other group.

The first group of objects represents a branch of the bank ABC Bank located at First Street which has two clients and three accounts. Accordingly the group comprises a Bank object two Client objects and three Account objects and . In Bank object the value ABC Bank of the name attribute reflects the bank s name and the value 123 First Street of the location attribute reflects the branch location. With respect to the Client objects and the value of their name attributes represents the client s names. Similarly the Account objects and are each populated with values in their name number and balance attributes to represent client accounts.

The second group of objects which includes a bank object two client objects and four account objects and is representative of a different branch of another bank XYZ Bank and is analogous in its composition to the first group.

It should be appreciated that the set of software objects could comprise a greater or lesser number of Bank objects Client objects and Account objects.

Each object and in the set of software objects of the present embodiment is MOF compliant thus include the MOF capability of reflection. This is not required however non MOF compliant application objects may be included in the set of objects .

Editor class is representative of editor level configuration settings which govern the manner in which application objects are accessed. The ID attribute is a unique identifier associated with a particular editor. The adapterFactoryClass identifies the adapter factory to be used for the present embodiment. The adapterclass attribute on the other hand identifies a generic adapter to be used for the instant editor invocation. This may reference an alternative generic adapters to the default generic adapter e.g. it if is desired to customize the view of a set of application objects in a manner that is not contemplated in the default generic adapter .

Navigator class represents the accessing of or navigation to a particular class of non reflective here non MOF objects in the set of objects by the adapter during the course of the editor s display of the software objects . Only the non MOF object classes that are referenced in an instance of the Navigator class in particular in its name attribute will be accessed or navigated to during display of the set of software objects and can thus be made visible by the object editor . It will be appreciated that Navigator objects represent accesses to non reflective objects only accesses to reflective objects are represented by instances of the Model Navigator class described below.

A Navigator object may be contained by either an Editor object by way of composition relationship or an Item object by way of composition relationship . When contained by an Editor object the Navigator object represents the accessing of a class of objects from the root level of the set of objects . When contained by an Item object described below the Navigator object represents the accessing of a class of objects from the vantage point of a particular originating class in the governing application model which class is identified by the containing Item object. The Navigator class ID attribute represents a unique identifier of an instance of Navigator class .

The itemName and itemType attributes cumulatively provide flexibility for the provision of alternative views within a single configuration model instance . These attributes are used to access a custom adapter for use with a class of application objects when a particular class of application objects are to constitute children of the former class of objects in the desired view. The itemName attribute represents the class name of an application software object existing in the application model that is to be navigated to during the display of objects . The itemType attribute identifies a the custom adapter to be used. These two attributes are considered to be an advanced feature of the configuration model and may not be necessary if it is desired to view all reflective objects of the set of application objects uniformly.

Model Navigator class represents reflective object accesses to be distinguished from non reflective object accesses which are represented by the Navigator class that shall be performed by the adapter during the display of application objects . As reflected by the inheritance relationship Model Navigator class is a subclass of Navigator class . Only the reflective object classes that are referenced in a ModelNavigator object will be accessed or navigated to during the display of software objects and can thus be made visible by the object editor .

The startType attribute and the path attribute of class represent two mechanisms for accessing objects within object set from the current vantage point in the set . The startType attribute represents the name of a MOF object class to be accessed which exists at the root level of the governing application model i.e. it is not contained by another application model class . For example the Bank class and Client class of the present embodiment are considered to exist at the root level of the model and may thus be referenced by the startType attribute. The startType attribute is commonly used to access root level application objects for display at the highest root level of a tree or table view.

The path attribute on the other hand represents a relative object association or sequence of object associations from a current or originating application object class to another application object class. The path attribute is commonly used to determine which objects within the set of application objects are to be considered the children of an application object of a particular class of the governing application model . The value of the path attribute is equivalent to a rolename e.g. acct in or sequence of rolenames e.g. clients accounts in which leads from the current originating application model class to another application model class that is to be considered the former model class child for the purposes of the instant view.

Item class is representative of a particular non MOF object class existing in the governing application model which will by virtue of an instance of the Navigator class in the CMI be accessed during the course of the editor s display of the application objects . For each class of non MOF objects that will be accessed by virtue of a Navigator object in the CMI an instance of the Item class should exist in the CMI to indicate among other things how the object once navigated to should appear when displayed.

The name attribute of class represents the class name of the non MOF object class in the governing application model . The displayName attribute represents a fixed text string or label that is displayed in conjunction with each iconic instance of the class identified by the name attribute when the instance is displayed by the object editor . Assuming that descriptive class names have been selected for the classes of the governing model the displayName attribute will typically match the value of the name attribute however this is not required. The Icon attribute is a path to an icon file e.g. icon.gif or graphics icon.jpg which shall be displayed by object editor to represent each instance of the object class represented by the Item object in the set of application objects . The adapterClass attribute represents a custom adapter to be used for objects of the identified class. This attribute permits the generic adapter to be overridden with a custom adapter for a particular class of objects defined in the application object model . It should be appreciated that such specification of a custom adapter is required for non reflective application objects as a non reflective application object is incapable of being accessed by way of the default generic adapter due to the generic adapter s use of reflection. The type attribute is analogous to the itemType attribute of the Navigator class .

Model Item class represents a particular reflective object class to be distinguished from non reflective object classes which are represented Item class existing in the governing application model that will by virtue of an instance of the ModelNavigator class in the CMI be accessed during the course of the editor s display of objects . As reflected by the inheritance relationship the Model Item class is a subclass of Item class . For each class of reflective objects that will be accessed by virtue of a Model Navigator object in the CMI an instance of the Model Item class should exist in the CMI to indicate how the reflective object once navigated to should appear when displayed. The Model Item class of the present embodiment includes no additional attributes beyond those inherited from the Item class .

Property class is representative of an attribute of an application object class whether reflective or not contained within the governing application model that may be made visible as a Property of the displayed application object instance during the course of the editor s display of the objects either in a main display area or a properties sheet as will be described . It should be appreciated that without a corresponding Property object in the CMI an attribute of a displayed application object class defined in the governing application model will not be displayed. A Property object may be contained by an Item object by way of an instance of the composition relationship this relationship associates the attribute represented by the Property object with the containing class of the governing application model .

The ID attribute of the Property class is a unique identifier that is assigned to each Property object and is used for uniquely referencing a particular Property object. The name attribute is indicative of the application object attribute name that the Property object represents. The displayName attribute represents a fixed text string comprising a label that is displayed in conjunction the attribute when the attribute is displayed by the object editor within a property sheet described below . As with the displayName attribute of Item class the displayName attribute of the Property class will typically match the value of the name attribute but this is not required. The Icon attribute is a path to an icon file which is displayed by object editor to represent each instance of this attribute when it is displayed in a property sheet by the editor .

The editorClass attribute optionally identifies an editor which is to be used to edit the current attribute within a property sheet entry or line item for example. It may be desired to specify a separate editor using the editorClass attribute when the attribute represented by a particular Property object is of a complex type which requires special processing in order to be displayed edited. Finally the is Modifiable attribute is a boolean value which reflects whether the represented attribute s value may be changed by the user of the object editor .

As reflected by the cardinality 0 . . . of the properties composition relationship an Item object may contain zero or more properties. As will be appreciated the set of properties that is contained by the Item is determinative of the set of attributes that will be displayed in the property sheet of an instance of the application object class represented by the Item. Moreover the ordering of the Property instances within the Item will determine the order of the displayed attributes in the displayed property sheet. Finally it should be recognized that a property instance may be defined outside of an Item in this case the associated attribute will not appear in the property sheet but it may be displayed by way of the label association which is described next.

A uni directional label association extends from the Item class to the Property class in the configuration model . This association permits one property from a set of properties defined in conjunction with a Item to be chosen for display whenever an instance of the object class represented by the Item is displayed. The cardinality of the association is 0 . . . 1 to reflect that the label association is optional and may at most result in the display of a single property i.e. a single attribute of a displayed object. The application object attribute associated with the property identified by the label association will be displayed by the editor in association with each displayed instance of that application object. For example by setting the label association to reference a defined Property object which pertains to the Bank object s location attribute for each Bank branch icon displayed by the editor the value of the corresponding object s location attribute will be displayed providing the location of that particular Bank object instance alternatively by setting the label association to point to a different defined Property object which pertains to the Bank object s name attribute for each displayed Bank branch icon the value of the corresponding object s ame attribute will be displayed indicating the bank name.

The OO configuration model further defines a number of routines not illustrated which simplify access to and utilization of the information stored within an instance of a configuration model. These routines are used as APIs for accessing a CMI . Included in these routines are a getRootObjects method a getAdapter method a getNavigators method and getProperties method. Other comparable routines may be provided.

The getRootObjects method takes as an input parameter a set of instantiated application objects and returns the objects from the set which should based on the settings of the CMI be considered to be the root objects for the present view. To achieve this result the getRootObjects method accesses the startType attribute and optionally path attribute of the Navigator object contained by the Editor object of the operative CMI and then uses the values of these attributes to ascertain the application model class that should act as the root of the display tree. This information is then used to access and return the objects of the application object set which are of this class.

The getAdapter method takes as an input parameter a particular object of the set of application objects and returns the adapter to be used in association with that object. To achieve this result the getAdapter method examines the Item objects including Model Item objects of the CMI until one is identified with a name attribute value which is an instance of the input object parameter s class. The adapterClass attribute of the identified Item is then examined. If a non null value exists the identified custom adapter is instantiated and returned. If the value is null the adapterclass attribute of the Editor object is examined next. If a non null value exists the identified non default generic adapter is instantiated and returned. If the value is null the default adapter class is instantiated if necessary and returned.

The getNavigators method takes as an input parameter a particular application object and returns the Navigator object to be used in association with that application object. To achieve this result the getNavigators method examines the Item Model Item objects of the CMI until one is identified with a name attribute value which is the name of the class of the input application object or the name of a class which is a parent of that object. The navigator object s associated with the identified Model Item Model Item is are then returned.

The getProperties method takes as an input parameter a particular object of the set of application objects and returns the Properties objects associated with that object. Its function is similar to that of the getNavigator s method described above.

CMI file includes declarations for a single Editor object lines of and three Model Item objects lines and . These declarations correspond with the Editor object and Model Item objects and respectively of .

The Editor object declaration contains a nested Model Navigator object declaration at line of which corresponds to the Model Navigator object of . This Model Navigator object has a startType attribute with a value Bank . This value of the Model Navigator object s startType attribute indicates that for the purposes of the present view application objects of the class Bank are to be considered the root objects. This means that in a tree display of the application objects Bank objects will be displayed at the highest level as shown in the corresponding display view of see e.g. displayed Bank object instances and whose leftmost positioning in the tree structure indicates a root position in the tree .

The first Model Item declaration at lines of determines all aspects of the display of Bank object instances on the display for the present view. For example the icon attribute at line indicates that the icon to be displayed in association with each displayed Bank object instance is the icon which is stored in the file bank.gif . As well the displayName attribute indicates that the text Bank is to be displayed in conjunction with each displayed Bank object instance .

The first Model Item declaration includes nested declarations for a Model Navigator object at line which corresponds to the Model Navigator object of . The path attribute of this Model Navigator object has a value clients . This value of the path attribute indicates that in the present view the objects that should be displayed at the next tree level below the current or originating application object class i.e. Bank objects are Client objects. In other words this setting indicates that all Client application objects associated with a Bank application object are to be considered the children of the Bank object for the purposes of the present view. The value clients is indicative of this because it is the rolename associated with the uni directional association leading from Bank class to Client class . Accordingly in the instant tree display of the application objects Client objects instances will be indented below their associated Bank object instance see e.g. Client object instances indented one level below Bank object instance .

Further included within the first Model Item declaration are two Property objects declarations at lines and respectively which determine for the purposes of the present view which attributes of a Bank object are to be displayed in a property sheet of a selected Bank object instance. The property sheet that is defined on the basis of these Property object declarations is illustrated in . The first Property object declaration corresponding to object of has name attribute with a value name a displayName attribute with a value Bank Name and an icon attribute with the value ppty.gif . These values indicate that the property sheet associated with a selected Bank object instance shall include one entry comprising a line item made up of the value of the corresponding Bank object s name attribute i.e. the bank name preceded by the text Bank Name to indicate the what the displayed value represents and including an icon from file ppty.gif . In similar fashion the second Property object declaration corresponding to Property object indicates that the property sheet shall include another entry made up of the value of the corresponding Bank object s location attribute i.e. the bank address preceded by the text Bank Location . As may be seen in the bank name property is displayed above the bank location property within the property sheet this ordering of entries in the displayed property sheet is determined by the ordering of the Property objects within the Model Item object of CMI file .

As may be seen at line of the first Model Item declaration includes a label attribute with the value Bank name . This attribute constitutes a reference to the first Property object by way of that Property object s unique ID Bank name and indicates that the attribute associated with the first Property object i.e. the bank name is to comprise the label for displayed instances of the object represented by the containing Model Item i.e. Banks . This results in the display of the bank name in conjunction with each displayed instance of a Bank object respectively after the displayName text Bank .

In a similar fashion to the first Model Item s determination of all aspects of the display of Bank object instances the second Model Item object declared at lines of associated with Model Item object of determines all aspects of the display of Client object instances for the present view. This includes determining the icon client.gif to be displayed with each Client object instance and . Second Model Item object contains a Model Navigator object . The path attribute value accounts of this Model Navigator object indicates that the application objects that should be considered to be the children of Client objects in the present view are Account objects. The value accounts which provides this indication is the rolename of the bi directional association leading from Client class to Account class . Thus in a tree display of the objects Account object instances will be indented below their associated Client object instance see e.g. Account object instances indented one level below Client object instance .

The property sheet that is displayed upon the selection of the Client object instance is shown in . This property sheet includes only a single attribute namely the client s name as dictated by the single contained Property object declared at lines of . Moreover because the label attribute references this property the client s name is also displayed for each Client object instance of the tree display see e.g. the client name John Smith 812 displayed in association with Client object instance .

Following the same pattern as the first two Model Items the third Model Item object declaration determines all aspects of the display of Account object instances for the present view. One distinction is that the path attribute of its contained Navigator object declared at line of has a value Navigator nopath . This value indicates that Account object instances are considered to be at the lowest level of the present view i.e. they are to have no children. Accordingly Account object instances and appear at the deepest level of indentation in the tree display of . The two property object declarations at lines result in the property sheet of for a selected Account object instance.

In another distinction from the first two Model Items the label attribute of the third Model Item at line references a Property object that is not contained by the third Model Item but rather is declared outside of that Model Item at line . This relationship is illustrated in in the form of label relationship leading to Property object which is not contained by third Model Item s properties containment association . The referencing by the label association of a Property object that is not contained by the Model Item object is done to permit the Account object attribute name i.e. the account name associated with the Property object to be used as a label for each displayed instance of an Account object see e.g. corresponding displayed account names and of without having that attribute appear within the Account object s property sheet . This approach is again based on the fact only Properties that are contained by a Item Model Item will be displayed in the associated property sheet.

CMI file follows the same conventions described above with respect to CMI file and will therefore not be described in detail. CMI file includes declarations for two Model Item objects at lines and which declarations correspond with Model Item objects and respectively of . It should be appreciated that the declaration of only two Model Item objects and and the associated Model Navigators and which permit the associated application objects to be accessed or navigated to results in the display of only two types of application objects in the view namely Bank objects and Account objects.

Certain other aspects of CMI file result in a view of the objects that is different from the view provided by CMI file . For example the setting of the displayName attribute to an empty string value at line results in the absence of any textual label preceding the bank name see e.g. Bank object instance of . Moreover the setting of the label association of the second Model Item object to reference the account number Property object as declared at line of has caused the account number to appear in association with each Account object instance rather than the account name see e.g. account number 12345 displayed in association with Account object instance .

Another distinction from the CMI file of is the use of a sequence of rolenames clients accounts in the path attribute of the first Model Item at line of . This value of the path attribute indicates that in this alternative view the objects that should be displayed at the next tree level below the current application object class i.e. Bank objects are Account objects see e.g. Account object instance nested below its associated Bank object instance in . It should be appreciated that this technique makes it possible to cause application objects which are only indirectly associated in the governing application model to appear to have a parent child relationship in the instant view. This is a powerful technique for controlling the appearance of the displayed objects or more generally for controlling the navigation of objects .

The operation of the object editor is illustrated in the sequence diagram of . It is assumed that prior to invocation of the editor a CMI file such as CMI file has been stored in a predetermined location in non volatile memory as expected by the core editor code .

Initially a user invokes the editor software through interaction with the UIM . Upon being invoked the editor software commences its initialization by reading the CMI file from the predetermined location and de serializes the file resulting in the CMI illustrated in . This effectively customizes the editor for use with the set of application objects stored in file . Once the editor has completed its initialization the user then further interacts with the UIM to request the application objects stored in file to be loaded into the editor for editing. As a result the file is similarly de serialized resulting in the instantiated set of application objects of . The user s request also triggers a default display of the objects in tree form on the display of the editor .

With reference to the core editor code initiates this default display of the application objects by way of the invocation of a tree viewer routine displayAsTree or logically comparable routine in the operative UI framework with the application objects being passed as an input parameter. In response the tree viewer makes a call to the getRootObjects method of the CMI which as described above returns the application objects which will serve as root objects for the present view. Given the operative CMI of in the present example this method returns the two Bank objects and of . Subsequently there is a further invocation not illustrated of the getAdapterFactory method of the CMI which returns the currently operative adapter factory to the controller module again as described above. At this stage processing enters a loop wherein each of the returned root Bank objects and and their children are processed in a recursive manner.

Starting with the first Bank object the tree viewer begins by making a call to the controller module routine getChildren or logical equivalent in the controller module of the operative UI framework to determine the children of Bank object for the present view. In response the controller module makes a call to the adapter factory method adapt passing the Bank object as a parameter to identify the proper adapter to use for this class of application object. The adapter factory in turn invokes the getAdapter method described above of the CMI at to identify the proper adapter for Bank objects. In the present case as no custom adapter or custom generic adapter is specified for Bank objects in the CMI the getAdapter method returns the default generic adapter .

Thereafter the controller module makes a call to the getChildren method of the generic adapter passing the Bank object as a parameter. In response the adapter invokes at the getNavigators method of the CMI . As noted previously this method returns the navigator s associated with the input parameter object s class. In the present case the Model Navigator object is returned. The value of the returned Model Navigator s path attribute is thereafter examined and discovered to have the value clients . The corresponding feature is then passed to the relevant MOF parent application object which in the present case is Bank object in an invocation of the MOF refyalue method. The matching associations which comprise the Bank s associated Client objects and in the present case are then returned. These objects are ultimately returned to the tree viewer .

Having obtained the children of the first root Bank object the tree viewer next seeks to determine the text to be displayed in association with the displayed instance of Bank object . The object interactions which occur to effect this result are in many ways similar to the above noted steps by which the children of Bank object were determined. More specifically the tree viewer initially makes a call to a getText method or logical equivalent of the controller module passing the Bank object as a parameter. Thereafter in a pair of calls and to the adapt and getAdapter methods the generic adapter is returned as the adapter to be used for the current Bank object. The controller module then makes a call to the getText method of the generic adapter passing the Bank object as a parameter. In response the adapter invokes at a getLabel method of the CMI which in a mechanism similar to that of the getAdapter method returns the label association for input parameter s application model class. In the present case the returned label association identifies the Property object associated with the Bank object s name attribute. The feature associated with this bank name attribute then is then passed to the Bank object in an invocation of the MOF refyalue method which examines the features of the Bank object until one is found which matches this value. The resulting value ABC Bank is then returned.

Next in an invocation of the CMI method getDisplayName the value of the displayName attribute for the Bank object i.e. Bank is returned. The mechanism of the getDisplayName method is similar to that of the getLabel method.

Finally the displayName value and the Bank name value are concatenated into a single string Bank ABC Bank and returned ultimately to the tree viewer for display. Next in processing that is similar to the series of invocations associated with the getText mechanism the tree viewer invokes a getIcon method not illustrated of the controller module to determine the appropriate icon to be displayed in association with the displayed instance of the Bank object .

Having at this stage determined the children of Bank object as well as the text and icon to be displayed for this object the tree viewer now recursively repeats the same series of steps i.e. invoking getChildren getText and getIcon for each child of the root Bank object to determine the next level of children and associated text icons to be displayed. This recursion is repeated until all of the objects designated for navigation by the CMI have been traversed. When completed the information needed by the tree viewer to compose the upper portion of the view is known and this portion may be displayed on display .

In an analogous manner the remaining application objects are traversed ultimately resulting in the display of the other portion of the view . At this point there are no further root objects left to process so the exit condition to the loop is met and processing associated with the displaying of the view is completed.

It should be appreciated that the processing described above differs slightly when a non reflective object is encountered among the application objects . In particular the adapter returned by the CMI getAdapter method call will be a custom adapter not the generic adapter . Moreover the controller module s subsequent invocation of the custom adapter s getChildren method analogous to call will result in the custom adapter invoking a method or methods of the relevant non reflective application object in place of calls and which comprise s a hard coding of the desired results. The same is true of the processing associated with the getText and getIcon methods for a non reflective application object.

When the user selects a displayed instance of a displayed application object to view its properties this selection event will cause a property sheet e.g. or of associated with the object to be displayed. The processing to effect this display is similar to the tree viewer processing described above and will therefore not be described in detail. One difference from the tree viewer processing however is the fact that the property sheet viewer construct not the tree viewer is used. Another difference is that no recursive accessing of the set of application objects occurs.

When reflective application software objects are edited the MOF reflective module method refSetValue may be invoked by the generic adapter to set the value of the objects features as necessary.

Once the user has viewed and or edited the objects as needed the user may use the GUT to trigger a save command which causes the application objects to be serialized and stored back to the file . The object editor may then be exited.

Optionally the user may now substitute a different CMI file such as CMI file into the predetermined location in non volatile memory . When the object editor is subsequently invoked it will be configured by way of the substituted CMI file to display application objects in accordance with the alternative view illustrated in . Advantageously this configuration of the generic adapter is achieved without necessitating a recompilation of the generic adapter .

As will be appreciated by those skilled in the art modifications to the above described embodiment can be made without departing from the essence of the invention. For example rather than reading a CMI file or from a predetermined location of non volatile memory to configure the editor an alternative manner of configuring the object editor with a particular CMI such as a command line parameter may be used.

As well it will be appreciated that the serialized CMI files may in fact comprise XML Metadata Interchange XMI documents in accordance with section 2.4.3 of the above referenced MOF specification. As known to those skilled in the art XMI is an extension of XML which provides a standard way for programmers and other users to exchange information about metadata which is described in XMI specification version 1.2 at http www.omg.org cqi bin doc formal 02 01 01.pdf. When expressed in the form of XMI CMI files may include many of the same object declarations as are declared in the exemplary XML version of however may further include additional XMI related tags and attributes. For example the CMI file of might appear as illustrated in when expressed in XMI. In a similar fashion the saved application objects could be represented in XMI in an alternative embodiment.

In the event that the application objects are all reflective it is possible to use a configuration model which does not define the classes e.g. Navigator or Item and attributes that are exclusively associated with non reflective objects. Rather the attributes of these classes may be promoted to the corresponding reflective object subclass e.g. Model Navigator or Model Item .

Fundamentally it is not necessary that the object editor utilize MOF to implement reflection. An alternative reflection mechanism such as Java reflection and or introspection may be used. In this case it will be recognized that the application objects will conform to the chosen reflection mechanism and that the reflective API calls made within the generic adapter e.g. refMetaObject refyalue refSetValue etc. which access application objects attributes in a generic fashion will be replaced with corresponding APIs that are appropriate for the chosen reflection mechanism.

As well it should be appreciated that the above described approach of using a generic adapter and an external CMI could be used to implement an externally configurable adapter software component for an application other than an object editor. In this case the application s main program component may replace the core editor code moreover the high level UI constructs and controller module may not exist. Depending on the application the methods of the main program to be mapped to the attributes or associations of application software objects may differ from the described getChildren qetText and getIcon methods if this is the case the generic adapter may require one time modification to implement these different methods. Moreover the CO configuration model on which the CMI is based for such embodiments may include attributes particular to the application being implemented in place of or in addition to display related model attributes e.g. icon displayName etc. . For such embodiments changing the CMI settings may cause the generic adapter to access application software objects differently and accordingly the application to behave differently without necessitating adapter recompilation.

Of course the above described embodiments are intended to be illustrative only and in no way limiting. The described embodiments of carrying out the invention are susceptible to many modifications of form arrangement of parts details and order of operation. The invention rather is intended to encompass all such modification within its scope as defined by the claims.

