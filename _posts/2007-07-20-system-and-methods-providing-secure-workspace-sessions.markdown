---

title: System and methods providing secure workspace sessions
abstract: System and methods providing secure workspace sessions is described. In one embodiment a method for providing multiple workspace sessions for securely running applications comprises steps of: initiating a first workspace session on an existing operating system instance running on the computer system, the first workspace session having a first set of privileges for running applications under that session; while the first workspace session remains active, initiating a second workspace session on the existing operating system instance running on the computer system, the second workspace session having a second set of privileges for running applications under the second workplace session; and securing the second workspace session so that applications running under the second workplace session are protected from applications running outside the second workspace session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08769268&OS=08769268&RS=08769268
owner: Check Point Software Technologies, Inc.
number: 08769268
owner_city: Redwood City
owner_country: US
publication_date: 20070720
---
The present application is related to the following commonly owned presently pending application s application Ser. No. 11 163 343 filed Oct. 14 2005 entitled System and Methodology Providing Secure Workspace Environment . The disclosure of the foregoing application is hereby incorporated by reference in its entirety including any appendices or attachments thereof for all purposes.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Computer Program Listing Appendix under Sec. 1.52 e This application includes a transmittal under 37 C.F.R. Sec. 1.52 e of a Computer Program Listing Appendix. The Appendix which comprises text file s that are IBM PC machine and Microsoft Windows Operating System compatible includes the below listed file s . All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.

Object Description SourceCode.txt size 93774 Bytes created Jul. 11 2007 12 40 42 PM Object ID File No. 1 Object Contents Source code.

The present invention relates generally to computers and data processing applications and more particularly to system and methodology providing a secure workspace environment.

Growth of Internet based remote access technologies has lead to an increasing number of users working in unprotected or untrusted environments. Home users connect to their corporate networks via different VPN clients. People on vacation check their emails via public kiosks. Sales agents connect to their databases via wireless services in airports. Large networks now are not just broadband lines that connect offices in several states or countries they are far more complicated and far less controlled at the end points e.g. at individual personal computers . As the number of mobile users grows the number of potential threats also grows. Potential threats include but are not limited to phishing attacks identity theft trade secrets theft and the like.

A network of the typical large organization can be protected with various tools. For example a firewall is installed to protect a company s gateway. Anti virus software is installed on the company s mail server to scan incoming and outgoing email. Anti virus software can be also installed on individual end user computers. For remote users SSL VPN or IPSEC VPN is available to connect to the company s network from remote sites. For managing these environments IT departments typically develop and deploy a set of security rules security policy to endpoints. Notwithstanding the availability of these foregoing tools corporate IT departments today still face difficulties in protecting managed computers within the corporations from the threats from the Internet.

Consider for instance a firm XYZ trading firm which employs a clerk named John Doe. John works with a firm owned personal computer to connect to a business client server application running on another one of the firm s computers. This business application allows him to access all important data customer information invoices and inventory availability of items. Most of the data available to John is confidential. Sometimes John stays after work to browse and download free music from web sites. Recently he downloaded and installed without permission a Tetris game for his own amusement during free time. Both of these seemingly innocent activities of John can lead to the leakage of important data however. For example many free music sites contain spyware adware or other malicious software malware . Free game downloads e.g. Tetris download in particular often conceal malware intended to steal confidential data. In this scenario corporate firewall and antivirus software installed on an employee s computer often will not help. Corporate firewalls for example are frequently configured to allow HTTP traffic i.e. port 80 is open the HTTP protocol in turn can be used to download files including unintentional or intentional downloading of malware. Importantly antivirus AV software that may be running e.g. on John s machine is not guaranteed to detect spyware programs especially those particularly developed to bypass the antivirus software.

Given the risks posed by the above some attempts have been made to address the problem. The simplest way is to apply a strict security policy prohibit Internet traffic for computers where important business applications are installed. In many cases this will not work however since Internet connectivity is a daily tool for many people. Employees need Internet access in order to get news search information visit site of competitors get email use online applications and services and so forth. The simplest approach is therefore not a practical solution for most firms.

Another approach is to use two computers one for internal business applications and one to access the Internet. This is the most secure approach but also the most expensive and inconvenient. The cost grows not only because of the hardware duplication but management of the firm s IT information technology infrastructure becomes more complex and expensive. The total cost of ownership TCO eventually grows to an unsustainable level. For example consider how an employee or clerk should send and receive email. If email client software is installed on the same computer where an important business application is installed special precautions must be taken to prevent malicious software distributed by email. Although the firm s system administrator may install antivirus to scan email on the fly malware can easily bypass such protections for example malware may be hidden in a password protected archive e.g. ZIP file. If the email client is installed on the computer with HTTP access enabled the system administrator must also worry about how data may be safely imported from the email system into the business application. Given these shortcomings the approach is reserved for situations where high costs and inconvenience can be justified for example in banking and military deployments.

Another approach involves the use of separate user profiles. When working with the business application the employee e.g. John is required to use a special OS operating system profile that is one requiring that he log in under a username with special privileges. When working with Internet he would use another profile. Microsoft Windows XP supports somewhat fast profile switching. In spite of these improvements in this area this approach is not widely used perhaps for obvious reasons interference with usability and difficulty of configuration make the approach relatively unattractive.

What is needed is a solution that protects unmanaged computers from threats posed by Internet connectivity. For example such a solution should allow a user to do online payments from his home personal computer without the worry of Internet borne threats. However such a solution should provide this protection without high costs or inconvenience. The present invention fulfills this and other needs.

System and methods providing secure workspace sessions is described. In one embodiment for example in a computer system a method of the present invention is described for providing multiple workspace sessions for securely running applications the method comprises steps of initiating a first workspace session on an existing operating system instance running on the computer system the first workspace session having a first set of privileges for running applications under that session while the first workspace session remains active initiating a second workspace session on the existing operating system instance running on the computer system the second workspace session having a second set of privileges for running applications under the second workplace session and securing the second workspace session so that applications running under the second workplace session are protected from applications running outside the second workspace session.

In another embodiment for example a system of the present invention providing that allows users to run software programs in a plurality of workspace sessions subject to separate security rules of a security policy is described that comprises a computer running under an operating system a plurality of software programs for use by users of the computer a configurable security policy specifying security rules applicable to the software programs a session manager for creating a plurality of workspace sessions under the operating system with each of the sessions subject to separate security rules of the security policy and isolated from other workspace sessions thereby allowing software programs to run in a secure manner subject to the separate security rules and a module for enforcing compliance with security rules of the security policy by software programs running in each of the workspace sessions.

The following definitions are offered for purposes of illustration not limitation in order to assist with understanding the discussion that follows.

Firewall A firewall is a set of related programs typically located at a network gateway server that protects the resources of a private network from other networks by controlling access into and out of the private network. The term also implies the security policy that is used with the programs. A firewall working closely with a router program examines each network packet to determine whether to forward it toward its destination. A firewall may also include or work with a proxy server that makes network requests on behalf of users. A firewall is often installed in a specially designated computer separate from the rest of the network so that no incoming request directly accesses private network resources.

HTTP HTTP is the acronym for HyperText Transfer Protocol which is the underlying communication protocol used by the World Wide Web on the Internet. HTTP defines how messages are formatted and transmitted and what actions Web servers and browsers should take in response to various commands. For example when a user enters a URL in his or her browser this actually sends a HTTP command to the Web server directing it to fetch and transmit the requested Web page. Further description of HTTP is available in RFC 2616 Hypertext Transfer Protocol HTTP 1.1 the disclosure of which is hereby incorporated by reference. RFC 2616 is available from the World Wide Web Consortium W3C and is available via the Internet e.g. currently at www.w3.org Protocols . Additional description of HTTP is available in the technical and trade literature see e.g. Stallings W. The Backbone of the Web BYTE October 1996 the disclosure of which is hereby incorporated by reference.

Network A network is a group of two or more systems linked together. There are many types of computer networks including local area networks LANs virtual private networks VPNs metropolitan area networks MANs campus area networks CANs and wide area networks WANs including the Internet. As used herein the term network refers broadly to any group of two or more computer systems or devices that are linked together from time to time or permanently .

Portal A portal provides an individualized or personalized view of multiple resources e.g. Web sites and services. A portal typically offers a single access point e.g. browser page providing access to a range of information and applications. A portal assembles information from a number of different sources e.g. Web sites and applications enabling a user to quickly receive information without having to navigate to a number of different Web sites. A portal also typically enables a user to obtain a personalized view of information and applications by organizing and grouping information and services for presentation to users.

TCP IP TCP IP stands for Transmission Control Protocol Internet Protocol the suite of communications protocols used to connect hosts on the Internet. TCP IP uses several protocols the two main ones being TCP and IP. TCP IP is built into the UNIX operating system and is used by the Internet making it the de facto standard for transmitting data over networks. For an introduction to TCP IP see e.g. RFC 1180 A TCP IP Tutorial the disclosure of which is hereby incorporated by reference. A copy of RFC 1180 is available via the Internet e.g. currently at www.ietf.org rfc rfc1180.txt .

Thread A thread refers to a single sequential flow of control within a program. Operating systems that support multi threading enable programmers to design programs whose threaded parts can execute concurrently. In some systems there is a one to one relationship between the task and the program but a multi threaded system allows a program to be divided into multiple tasks. Multi threaded programs may have several threads running through different code paths simultaneously.

URL URL is an abbreviation of Uniform Resource Locator the global address of documents and other resources on the World Wide Web. The first part of the address indicates what protocol to use and the second part specifies the IP address or the domain name where the resource is located.

Winsock Windows Sockets 2 Winsock is a Microsoft provided interface that enables programmers to create advanced Internet intranet and other network capable applications to transmit application data across the wire independent of the network protocol being used. With Winsock programmers are provided access to advanced Microsoft Windows networking capabilities such as multicast and Quality of Service QOS . Winsock follows the Windows Open System Architecture WOSA model it defines a standard service provider interface SPI between the application programming interface API with its exported functions and the protocol stacks. It uses the sockets paradigm that was first popularized by Berkeley Software Distribution BSD UNIX. It was later adapted for Windows in Windows Sockets 1.1 with which Windows Sockets 2 applications are backward compatible. Winsock programming was previously centered around TCP IP. Some programming practices that worked with TCP IP do not work with every protocol. As a result the Windows Sockets 2 API adds functions where necessary to handle several protocols. For further information regarding Winsock see e.g. Winsock Reference available from Microsoft Corporation the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet e.g. currently at msdn.microsoft.com library default.asp url library en us winsock winsock winsock reference.asp .

XML XML stands for Extensible Markup Language a specification developed by the World Wide Web Consortium W3C . XML is a pared down version of the Standard Generalized Markup Language SGML a system for organizing and tagging elements of a document. XML is designed especially for Web documents. It allows designers to create their own customized tags enabling the definition transmission validation and interpretation of data between applications and between organizations. For further description of XML see e.g. Extensible Markup Language XML 1.0 2nd Edition Oct. 6 2000 a recommended specification from the W3C the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet e.g. currently at www.w3.org TR REC xml .

Referring to the figures exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention which is implemented in desktop and or server software e.g. driver application or the like operating in an Internet connected environment running under an operating system such as the Microsoft Windows operating system. The present invention however is not limited to any one particular application or any particular environment. Instead those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms including Macintosh Linux Solaris UNIX FreeBSD and the like. Therefore the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation the corresponding apparatus element may be configured in hardware software firmware or combinations thereof.

The present invention may be implemented on a conventional or general purpose computer system such as an IBM compatible personal computer PC or server computer. is a very general block diagram of a computer system e.g. an IBM compatible system in which software implemented processes of the present invention may be embodied. As shown system comprises a central processing unit s CPU or processor s coupled to a random access memory RAM a read only memory ROM a keyboard a printer a pointing device a display or video adapter connected to a display device a removable mass storage device e.g. floppy disk CD ROM CD R CD RW DVD or the like a fixed mass storage device e.g. hard disk a communication COMM port s or interface s a modem and a network interface card NIC or controller e.g. Ethernet . Although not shown separately a real time system clock is included with the system in a conventional manner.

CPU comprises a processor of the Intel Pentium family of microprocessors. However any other suitable processor may be utilized for implementing the present invention. The CPU communicates with other components of the system via a bi directional system bus including any necessary input output I O controller circuitry and other glue logic . The bus which includes address lines for addressing system memory provides data transfer between and among the various components. Description of Pentium class microprocessors and their instruction set bus architecture and control lines is available from Intel Corporation of Santa Clara Calif. Random access memory serves as the working memory for the CPU . In a typical configuration RAM of sixty four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read only memory ROM contains the basic input output system code BIOS a set of low level routines in the ROM that application programs and the operating systems can use to interact with the hardware including reading characters from the keyboard outputting characters to printers and so forth.

Mass storage devices provide persistent storage on fixed and removable media such as magnetic optical or magnetic optical storage systems flash memory or any other available mass storage technology. The mass storage may be shared on a network or it may be a dedicated mass storage. As shown in fixed storage stores a body of program and data for directing operation of the computer system including an operating system user application programs driver and other support files as well as other data files of all sorts. Typically the fixed storage serves as the main hard disk for the system.

In basic operation program logic including that which implements methodology of the present invention described below is loaded from the removable storage or fixed storage into the main RAM memory for execution by the CPU . During operation of the program logic the system accepts user input from a keyboard and pointing device as well as speech based input from a voice recognition system not shown . The keyboard permits selection of application programs entry of keyboard based input or data and selection and manipulation of individual data objects displayed on the screen or display device . Likewise the pointing device such as a mouse track ball pen device or the like permits selection and manipulation of objects on the display device. In this manner these input devices support manual user input for any process running on the system.

The computer system displays text and or graphic images and other data on the display device . The video adapter which is interposed between the display and the system s bus drives the display device . The video adapter which includes video memory accessible to the CPU provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube CRT raster or liquid crystal display LCD monitor. A hard copy of the displayed information or other information within the system may be obtained from the printer or other output device. Printer may include for instance an HP Laserjet printer available from Hewlett Packard of Palo Alto Calif. for creating hard copy images of output of the system.

The system itself communicates with other devices e.g. other computers via the network interface card NIC connected to a network e.g. Ethernet network Bluetooth wireless network or the like and or modem e.g. 56K baud ISDN DSL or cable modem examples of which are available from 3Com of Santa Clara Calif. The system may also communicate with local occasionally connected devices e.g. serial cable linked devices via the communication COMM interface which may include a RS 232 serial port a Universal Serial Bus USB interface or the like. Devices that will be commonly connected locally to the interface include laptop computers handheld organizers digital cameras and the like.

IBM compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock Tex. Hewlett Packard of Palo Alto Calif. and IBM of Armonk N.Y. Other suitable computers include Apple compatible computers e.g. Macintosh which are available from Apple Computer of Cupertino Calif. and Sun Solaris workstations which are available from Sun Microsystems of Mountain View Calif.

A software system is typically provided for controlling the operation of the computer system . The software system which is usually stored in system memory RAM and on fixed storage e.g. hard disk includes a kernel or operating system OS which manages low level aspects of computer operation including managing execution of processes memory allocation file input and output I O and device I O. The OS can be provided by a conventional operating system Microsoft Windows NT Microsoft Windows 2000 Microsoft Windows XP or Microsoft Windows Vista Microsoft Corporation of Redmond Wash. or an alternative operating system such as the previously mentioned operating systems. Typically the OS operates in conjunction with device drivers e.g. Winsock driver Windows implementation of a TCP IP stack and the system BIOS microcode i.e. ROM based microcode particularly when interfacing with peripheral devices. One or more application s such as client application software or programs i.e. set of processor executable instructions may also be provided for execution by the computer system . The application s or other software intended for use on the computer system may be loaded into memory from fixed storage or may be downloaded from an Internet location e.g. Web server . A graphical user interface GUI is generally provided for receiving user commands and data in a graphical e.g. point and click fashion. These inputs in turn may be acted upon by the computer system in accordance with instructions from OS and or application s . The graphical user interface also serves to display the results of operation from the OS and application s .

The above described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion the following description will present examples in which it will be assumed that there exists at least one computer that communicates with other computers over a network such as one or more clients e.g. desktop computers that communicate with various servers e.g. Web servers over the Internet. The present invention however is not limited to any particular environment or device configuration. In particular a client server distinction is not necessary to the invention but is used to provide a framework for discussion. Instead the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.

In accordance with the present invention a fully secured environment is provided in the framework of the user s usual operating system host OS such as Microsoft Windows . The main Input Output I O functions of the host OS are hooked or intercepted so that all information including session information that applications save to disk is really stored in encrypted form to prevent unauthorized access. In this manner unauthorized or malicious users even those that have full access to the host OS are prevented from accessing the information or data created in the secured environment.

This process occurs in a fashion that is fully transparently for both applications and users. Applications think that they are working with usual OS functions and that they are storing information to usual storages. The user sees the secured environment as a virtual desktop a Secured Desktop. The user can easily switch between secured and not secured usual desktops for example by hotkeys or GUI elements. By intercepting all relevant OS functions the approach of the present invention can control all applications running on the Secured Desktop allowing or denying them the ability to do any specified action. This approach is used in conjunction with a configurable security policy that specifies behavior or actions of software programs that are or are not permitted. For example it is possible to specify what applications can be run on the virtual desktop at all. In this manner the present invention may prevent the launching of any noncompliant software i.e. computer programs that would violate the policy including banning malicious software e.g. spyware and computer viruses that can steal information or even damage the system.

In the currently preferred embodiment a Secure Workspace System SWS is provided that gives the user a secured area for web sessions with a clear visual separation from non secure areas. The workspace protects sensitive session information while a given session is active and performs total clean up after the session is finished. The workspace enables protection in user space mode without developing device drivers guest user rights are needed to run the Secure Workspace System . The workspace performs API hooking at the lowest possible level in the user space e.g. native Windows NT API NTDLL so that applications that work directly with this layer will not bypass the hooking mechanism.

The Secure Workspace System SWS works at the application level on the client side and prevents unauthorized access to a user s confidential information. The SWS creates a new secured virtual desktop which the user can work on and intercepts file registry operations for all applications started on this desktop. The system saves all sensitive user data on the user s local machine in encrypted form and deletes it when the session is terminated.

During operation the manager starts a usual Windows shell e.g. explorer.exe with an injection of the hooks engine cpsws.dll on the created desktop. The injected hooks engine in turn hooks process creation routines and automatically injects itself into all newly created processes. In this manner each application on the secure desktop receives a workspace hook . In the Microsoft Windows environment for example the injected DLL hooks API calls invocations by overwriting hooked NTDLL routines entry points with JMP instructions thus redirecting them to code inside the cpsws.dll. In this fashion the system can be assured that any kind of call to NTDLL API including from Win32 DLL and from the application itself with GetProcAddress or import table will be first intercepted by the SWS. This allows the SWS to control each application s interaction with the underlying operating system including the operating system s information storage e.g. Windows registry file system and Clipboard .

Access to different system resources are allowed or denied based on the policy cpsws.xml . The hooks engine allows applications started on the secure desktop to create files and registry keys only inside a secure user profile. These items will be encrypted on the host file system and will be deleted when the given session is terminated.

As illustrated in the diagram every loaded in process module including usual system modules such as kernel32.dll shell32.dll and the like even main application executable can communicate with the NT kernel via ntdll.dll calls. Use of the mechanism of ntdll.dll hooking allows maximum possible in user space control of all data flows between a given secured application and hardware persistent storage. In this manner the cpsws.dll can dispatch all files related functions including those used by the application. The cpsws.dll encrypts all data on the fly and stores it to the target persistent storage in encrypted form.

The cpsws.dll also controls creation of out of process COM objects. It does this by hooking the particular ole32.dll functions that are used for object creation. It intercepts creating out of process COM servers and creates their processes itself. Some user32.dll functions such as SetClipboardData and GetClipboardData also may be hooked to allow on the fly encryption of data copied to clipboard by secured applications. In the currently preferred embodiment additional kernel32.dll and shell32.dll functions are hooked to control process creation and file operations at a higher level. In this manner the SWS may for example show user alert messages about rejected operations including denied program startup denied saving files to non secured locations and the like.

 cookie server cookiename cookievalue secured cookie that will be inserted into each HTTP S request to the defined server and

 shell shell id shell identifier refers to corresponding tag in the secured workspace policy defines a shell that will be started on secure desktop explorer.exe by default .

The policy file cpsws.xml may now be loaded at step . At step the secure workspace manager cpsws.exe creates a pipe server that will listen and dispatch requests from injected applications. The pipe server uses a secure cookie as an authorization password on every client connect so only processes that started with the SWS s dll can use this pipe. Next at step the hooks engine cpsws.dll is loaded into the SWS this process is referred to herein as self injection. The hooks engine cpsws.dll hooks all necessary API for example for Windows ntdll.dll kernel32.dll ole32.dll user32.dll and the like and also injects itself into every child process that is created by an already injected process. This is illustrated at step .

As shown at step the method proceeds to create a virtual user profile according to the policy as follows 

At step the method creates a virtual desktop for example via Windows CreateDesktop WinAPI function. The method proceeds at step to create and initialize an empty Discretionary Access Control List DACL security descriptor and assign it to the new desktop. This disallows any other application from starting or installing input hooks on the secure desktop. Any additional initialization may now be performed e.g. get current wallpaper as indicated at step . The machine s shell e.g. explorer.exe is started on the created virtual desktop at step . Since injection occurred via the hooks engine cpsws.dll the shell explorer.exe will be injected by the hooks engine cpsws.dll on startup. This allows the system of the present invention to control applications that will be started on the virtual desktop. Finally at step the method switches operation of the machine to the just created desktop if all preceding operations have succeeded.

During processing of a Windows DllMain function i.e. the optional entry point into a Windows dynamic link library DLL the hooks engine cpsws.dll hooks to a list of functions of ntdll.dll kernel32.dll ole32.dll and user32.dll i.e. operating system applications programming interface API executable files . Then it waits while the parent process writes a secure cookie to its memory e.g. using WriteMemory API . This allows the system of the present invention to further distinguish pipe clients in the SWS.

The API hooks processing proceeds as follows. Every created thread of the already secured application is switched to the secure desktop. The desktop handle is retrieved from the hooks engine cpsws.dll using Windows DLL thread attachment program logic i.e. specifying the Windows DLL THREAD ATTACH flag . The process creation functions e.g. Windows CreateProcessW CreateProcessA functions are hooked to allow injection of cpsws.dll at the point when a new process is going to start. When such a new process has been created the hooks engine cpsws.dll writes a secure token to its memory. A child process may use this as an authorization password for the pipe server.

File functions are intercepted to allow virtualization and encryption of the file system as follows. When an application asks the system to create file the hooks engine cpsws.dll checks the file path in order to determine if creating a file in this directory is allowed by policy. If it is allowed the secure workspace manager cpsws.exe generates a random string that will correspond to requested file name thus allowing the file to be physically created with a secure name.

On write operation the hooks engine cpsws.dll checks the user s rights to change files in the given target directory according to the policy file. If sufficient rights exist the SWS encrypts all data on the fly and writes it to a real file in secure form. Additional information is written to file including for example encryption algorithm ID and real size of file recorded as housekeeping information for use with encryption algorithms that can encrypt data only by blocks with constant length . This additional data is not visible to the application but is instead used by the hooks engine cpsws.dll internally.

On read operation the hooks engine cpsws.dll reads information from the file header and reads a corresponding fragment of data from the file which can be larger than requests due to block encryption . The file information may now be decrypted and returned as decrypted data to the requesting application. In response to a files listing request the hooks engine cpsws.dll checks the user s rights to list the particular directory. If the user has sufficient rights the SWS reads corresponding information from the file headers and returns the real filename and size which recall was written as a field of the file header .

When an application creates a memory mapped section of a file the SWS creates a corresponding in memory section with size of file. The system may now read decrypted content of the file to this section and give the calling application caller a corresponding handle to this section. If an application specifies a section name in the call the hooks engine cpsws.dll can change the name to separate sections created on the respective secure and default desktops. Desired behavior is preferably configured in the policy file cpsws.xml . When an application calls usual ReadFile Windows API function to read data from a file or WriteFile Windows API function to write data to a file functions for files that are mapped to memory the SWS satisfies the calls with simple read write of data from section memory. When an application requests closing of the section data stored in the section is flushed to the corresponding file and the section is closed.

In response to a proper request the SWS of the present invention may be shutdown. Before closing it optionally queries all running applications for shutdown terminates all secured application s and then deletes all secured data from local storages to prevent information leaks and quits. Specific method steps for effecting de initialization are described in detail below. 

The underlying operating system OS may save memory pages of applications running on secure desktop into a global system swap file. The SWS itself does not presently solve this problem in the currently preferred embodiment. However the issue may be addressed by changes elsewhere. For example the swap file itself may be written to an OS supported volume encryption e.g. Microsoft Windows Vista Windows full volume encryption . Additionally in those deployments already employing large amounts of physical memory RAM the amount of data paged to disk for virtual memory management VMM may constitute a rather insignificant amount of application data. Further those skilled in the art will appreciate that the SWS may be designed to include kernel level logic to supplant the OS s native swap file with an encrypted one.

In the currently preferred embodiment the SWS does not encrypt registry entries created by applications on the secure desktop. These are deleted when a given session is terminated. However it is possible that during unexpected session termination sensitive data will be left in the current user file ntuser.dat . The issue may be addressed by encrypting registry items in the same way as files.

Content and names of files created on the secure desktop are encrypted on the host file system. However the corresponding encryption decryption key is stored in memory subject to swapping via the swap file similarly the directory structure is potentially visible outside the secure desktop. In embodiments contemplating use of electronic codebook ECB mode there is the potential disadvantage that identical plaintext blocks are encrypted to identical ciphertext blocks the approach does not hide data patterns. The issue may be addressed by using cipher block chaining CBC mode. In the cipher block chaining CBC mode each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way each ciphertext block is dependent on all plaintext blocks up to that point. Further use of a fully virtual file system without correlation with host PC real file system provides additional protection.

Applications running on the secure desktop can exchange sensitive data through non controlled API with non secured applications on the default desktop e.g. non hooked out of process COM servers started by main system SVCHOST.EXE service . This issue may be addressed by hooking all API calls that can exchange sensitive information. In this manner the SWS does not allow applications that can leak information to be started on the secure desktop.

The following description presents method steps program logic that may be implemented using processor executable instructions for directing operation of a device under processor control. The processor executable instructions may be stored on a computer readable medium such as CD DVD flash memory or the like. The processor executable instructions may also be stored as a set of downloadable processor executable instructions for example for downloading and installation from an Internet location e.g. Web server .

The present invention includes an additional DLL loader that provides a mechanism to start new processes with forced loading of an additional DLL in the address space of the new process. This is done by creating a new process in suspended state allocating a small memory location in its address space and writing to it the code that loads the necessary DLL and that jumps to beginning of process execution code. The context of the main thread of the created process is then changed so that the computer processor s instruction pointer register e.g. Intel x86 Extended Instruction Pointer EIP register points to this created code. The thread is now resumed. After resuming the process thread executes code that loads the necessary DLL into the process space and continues usual processing of executable code. This may be implemented as follows e.g. illustrated by the following pseudocode snippets 

Of particular interest the AddAsmInstruction helper method call at line 30 serves to push a pointer to the DLL path name onto the current stack e.g. x86 stack . Now the helper method is again invoked at line 31 for purposes of calling the LoadLibrary Windows API call with the pushed parameter thereby forcing the loading of the DLL whose name is referenced at line 30 . Then at line 32 the helper method is invoked for purposes of effecting a jump JMP instruction back to the original process code.

The hooks engine provides a generic DLL that functions as an interception mechanism in its own processes. The basic approach is to overwrite part of the DLL code in memory so that a given target function instead calls wrapper code immediately upon execution. Here the start of the target DLL function is disassembled with its old original code being saved in a newly allocated memory block. The original site of this code is overwritten with a simple jump JMP instruction that calls the wrapper function. In this manner the wrapper function gains control and can process the API call itself or call the original DLL function with optionally changed input parameters. Core functionality of the hooks engine may be implemented as follows e.g. illustrated by the following pseudocode snippets 

As shown at line 18 the code performs a memory copy memcpy operation for overwriting the original code as described above. Unused byte locations are padded out with NOP no operation instructions e.g. 0x90 bytes as shown at line 19. At line 20 the AddAsmInstruction helper function is again invoked for generating a jump instruction to the other real function code and at line 22 the helper function is invoked for generating a jump to hook code at the beginning of the DLL exported function.

A file system processing engine of the present invention provides a mechanism for serving file system calls such as files and directories enumeration creating and deleting files and reading and writing file data. When a secured application tries to read or write a user s profile files it serves I O requests allowing on the fly encryption of file names and content. When the application tries to write to any restricted location e.g. specified in policy the engine prevents any unauthorized write or even access operations returning an Access Denied error in this manner the SWS ensures that no private data is left on the system after the SWS is closed down. File content encryption is designed for use with block ciphers in ECB mode with the option of including salt i.e. additional piece of information added to the hash that can be dependent of data offset. Private user s file names are similarly secured in a manner to allow both good security and fast accessing directories tree. When a given application creates a file which must be secured the engine parses the path splits it into corresponding names components and generates a random character string corresponding to real names . The file is physically stored by path which is combined from random names components. When the application opens this file or tries to enumerate names of the secured file the engine extracts the corresponding logical file names from an internal look up table that is stored only in memory.

Memory mapped file sections support can be considered as additional sub functionality of the file system processing engine. When an application tries to create a file section in a secured file the engine creates memory stored section with corresponding attributes and decrypts the file s content to it. If the application specifies a section name during creation or opens an existing section by name the engine can optionally change the section name to divide sections opened by applications on default and secured desktops. The particular section names that should be changed can be specified in policy. On every subsequent read write request of the file the engine performs simple copy of memory data from section memory to I O buffer. Flushing of the section to physical storage occurs on closing the file s handle. The below two pseudocode samples illustrate program logic implementing file processing features.

The first sample illustrates program code from a ZwCreateFile wrapper that changes file name or analyzes requested access rights 

A synchronization objects virtualization engine is provided that can optionally change names of named synchronization objects mutexes semaphores events and the like that are created by secured applications thus allowing independent applications to function on secure and default desktops. For example Adobe Acrobat Reader acrord32.exe creates certain named objects the existence of which it uses to determine whether an instance of the Reader is already running and thus a second instance should not be started . The specification of its names in the policy XML file makes possible to ensure acrord32.exe is the only running application instance in system.

A Registry processing engine is provided that allows flexible virtualization and protection of selected registry keys which can be customized in the policy . Write protection of selected keys is done by analyzing parameters of ZwCreateKey and ZwOpenKey routines and returning Access Denied status if any modification access is requested. Virtualization is done by creating an additional registry subkey HKCU CPSecured and changing all absolute paths requested by secured applications to really point to this key. Also a Copy On Access feature is provided to allow access to registry keys and values without noticeable delays for importing values from the original keys.

For example beginning with the program logic at line 6 the function checks whether protection is enabled for current application under consideration . At line 13 the TranslateHKEY routine is invoked to check whether the specified path belongs to HKCU HKEY CURRENT USER hive. If so the routine converts it to a virtual key path and returns true. If the path is read only HKLM HKEY LOCAL MACHINE path the routine returns false and the key path remains unchanged. At line 17 if the path points to a virtualized key then the original ZwCreateKey routine is called with the path relative to the HKCU CPSecured location . At line 25 if the path is read only and the application tries to get write access to this key the program logic returns Access Denied for denying access to the key . Line 34 demonstrates a call to the original ZwCreateKey routine for providing read access.

OLE32 calls filtering is provided to intercept the OS COM server s creation requests. When an application asks OLE32 to create an out of process COM server the wrapper checks the COM server presence in the SWS. The path is extracted to an executable image of the COM server from the registry HKCR HKEY CLASSES ROOT hive. The server starts itself if the server was not already started before. Such an approach allows the starting of secured COM servers. The following program logic illustrates main aspects of this functionality 

The CheckIsServerStarted function checks whether the specified image process is already started in secured mode so that is not necessary to start it one more time . At line 14 a do while loop is established to prepare a full list of active secured processes. At line 26 a for loop compares the image path names of secured processes with the requested path. If the comparison finds a matching path the program logic returns true otherwise it returns false. If the server is already started tested at line 64 then the function does no additional work and simply returns true. Otherwise the function proceeds to start the COM server process with embedding parameter.

Exemplary ole32.dll wrappers that intercept attempts to create COM servers may be constructed as follows 

A Clipboard processing engine is provided to serve as a mechanism to intercept saving data to and retrieving data from the OS clipboard by secured application s thereby allowing on the fly encryption of private data stored to clipboard. In Windows OS for example this can be achieved by intercepting only three functions GetClipboardData SetClipboardData and CloseClipboard that are exported by Windows user32.dll. For example a GetClipboardData wrapper may be implemented as follows 

As shown this works in conjunction with a globalDecrypt function to decrypt the data for reconstituting the original Clipboard data. The globalDecrypt function itself may be constructed as follows 

A print interceptor engine is provided to hook the Windows StartDocW and StartDocA functions exported by gdi32.dll. These StartDoc functions start a print job in Windows. By intercepting these functions the SWS may deny any print operations. Additionally the feature can be configured by the policy file.

A process creation interceptor is also provided. When a secured application tries to create a new process it executes hooking engine code that hooks all necessary API calls of the created child process. It also writes some secure data secure token directly to memory of the created process that allows the SWS to further distinguish between a secured application and malicious applications which may try to use SWS functionality to access secured data . Sample pseudocode illustrating main features of process creation wrapper is as follows 

Importantly if the policy does not allow the executable then the function returns false at line 19. Otherwise the function will proceed to allow process creation at line 22 .

Encryption functionality implemented in the present invention is designed to be flexible and easy to configure. It allows for example the use of different cryptographic algorithms for encrypting objects of a given type. The particular encryption algorithm used is noted via a stored ID in the stored object via an opaque header. The header also stores other housekeeping information such as real data length. In the currently preferred embodiment encryption functionality is implemented using the following interface 

Every time engine functionality requests to encrypt or decrypt some blocks of data the engine creates an instance of implementation of the particular preferred crypto algorithm by giving the preferred algorithm ID to the encryption engine. If the engine detects that data is not encrypted yet it will proceed to use the specified algorithm. If data is already encrypted however the engine will use the algorithm ID that is specified in encrypted data header. The particular encryption key employed is currently randomly generated on session initialization.

A URL secure cookie injector is provided for injecting a variable count of secure cookies into HTTP requests. Thus the SWS can inject one or more additional secure cookies into every secured process using the Windows lnternetSetCookie API function. The SWS also creates Mozilla Firefox profile files with secure cookies during initialization. HTTP URL and corresponding secure cookie data is given to the secure workspace manager cpsws.exe by the launcher as command line parameters. The manager cpsws.exe cleans up the command line after startup to prevent leaking of this information. This allows the corresponding HTTP server of the enterprise portal to distinguish HTTP requests from secured and unsecured applications e.g. using GWLIB API .

A configuration loader with storage class is provided that loads and analyzes the policy cpsws.xml file in which configuration and policy settings are stored. The loader provides an interface for other functionality parts to access their policies and configuration. It is possible to configure in the XML file what registry keys should be initialized and what values they should have for the SWS environment.

An inter process communication IPC channel is provided to serve as a generic mechanism for low level safe and secure communication between SWS functionality parts loaded into different processes. It is implemented as a pipe server that is started in the cpsws.exe core process on the early stage of initialization given pipe clients that connect to the server from cpsws.dll instances are loaded into secured applications. The server expects a secure token as the first data sent from a given client via pipe. If it receives any other data it closes the pipe connection after waiting a prescribed period of time as an anti hacker delay . A secure token is written directly to secured process memory on its creation so no one else can use the IPC channel engine.

Desktop initialization and security uses the Windows CreateDesktop API both with NT security features to achieve maximum possible control of user space prevention and to prevent keyboard loggers and screen shooters from accessing private information. The CreateDesktop API function creates a new desktop associates it with the current window station of the calling process and assigns it to the calling thread. The virtual desktop which is created by the CreatesDesktop API function can be optionally equipped with special Security Descriptor that ensures no one can launch an application on the secured desktop or install a keyboard hook into it and even make it impossible to get a desktop handle to this desktop . During initialization the manager cpsws.exe creates a desktop and assigns to it security descriptor with an empty DACL. The security descriptor creation and initialization code may for example be implemented along the following lines 

Since the SWS performs HKCU hive and user s profile virtualization it is possible to enforce some user interface predefinitions for applications running under SWS. Examples include disabling or extending some shell features adding configuration shortcuts on Desktop or Start Menu importing some files from the original profile and the like. Also the SWS performs automatic changing of desktop background wallpaper when switching from default desktop to secured one and vice versa.

After creating a virtual desktop the SWS creates notification area tray icons both on secured and default desktops. These icons allow switching between desktops and closing of the SWS. The notification icon on the secure desktop is used also to display some user information messages and security warnings e.g. as information balloons . The SWS draws a special icon on the right side of titles for all secured applications to provide user feedback psychological conviction that he or she is working in a secure workspace.

On the exit command that can be given directly from the notification icon menu or by ExitWindowsEx API call invoked from any secured application the SWS starts the de initialization procedure or method. is a flowchart illustrating a method of the present invention for de initialization. At step the method queries all applications currently running in the SWS for shutdown by sending them WM QUERYENDSESION and WM ENDSESSION messages. This allows applications to ask the user to save any information before shutdown. Next at step all running SWS applications are terminated. The pipe server is closed at step and all encrypted files are deleted from virtual user profile at step . Finally at step the method concludes by deleting HKCU CPSecured registry key.

The present invention enhances the secure workspace system to protect web sessions on unmanaged computers. Consider for example a user who wants to do online payments from his or home personal computer. is a block diagram illustrating an unmanaged computer that has established Internet connectivity a session with a protected web resource e.g. company portal . Here unmanaged means that the computer is largely if not exclusively under control of the user without active oversight by a system administrator. The unmanaged computer is provided with a virtualized secure workspace session SWS that blocks malware threats to applications running in the SWS thereby allowing the unmanaged computer to safely and securely communicate with the protected web resource . As shown in the secure workspace secures the session from a malware threat already present on the unmanaged computer itself.

The present invention also enhances the secure workspace to protect computers typically corporate or managed computers from Internet based threats. is a block diagram illustrating a managed computer that has Internet connectivity for example to connect to a company portal . The managed computer is provided with an enhanced secure desktop that secures the computer from Internet threats such as bad or malicious websites . Significantly the enhancements to the secure workspace include the following features.

Two OS e.g. Windows sessions are created on the computer. One is a default session e.g. normal Windows desktop that user usually sees when he logins to the Windows the other session sometimes referred to herein as a secure workspace session is shown inside the normal desktop as a window running another desktop. In other words two users with different privileges are simultaneously logged into the operating system at the same time. One of the sessions hosted session is shown as a window inside another session default session . System privileges for the user in the hosted session are different from the user in default session. In addition the hosted session uses SWS virtualization technology previously described in this document so as to secure software applications running in the hosted session from other applications e.g. malware outside the hosted session.

The system administrator may create a security policy for which includes applying different rules to each of the workspace sessions e.g. the default session the hosted session and or other workspace sessions created as described herein . An example of such policy for a simple scenario involving a default session and a hosted session as described above can include 

3. All instant messaging applications peer to peer P2P software and web browsers can be started only in hosted session.

4. Hosted session required to be virtualized all changes are done not in real file system but in virtual temporary one all changes to the registry are also done in virtual temporary registry storage.

5. Hosted session optionally is required to be flushed when the user logs off all temporary data files and registry changes that happened during the hosted session are discarded.

Those skilled in the art will appreciate that the foregoing is only one example of some possible rules of a security policy. Users may implement security policies including a wide variety of rules and security measures applicable to software applications running in one of the workspace sessions. In addition although the above example references two sessions default session and hosted session it should be understood that a plurality of secure workspace sessions may be created in accordance with the methodology of the present invention. Each said secure workspace session may be subject to different privileges security rules security measures and the like and secured against access from other sessions or external threats as described herein.

As an alternative approach to the design of the user interface multiple sessions may be concurrently hosted with each secure workspace session serving a particular purpose. In that alternative design the default desktop is configured to include shortcuts to run hosted sessions for different purposes such as 

Different backgrounds or logos may be selected to distinguish each hosted secure workspace session to further improve user experience or position company brand information.

 1 Apply additional security measures on a per session basis such as anti keylogger and anti screen grabber to a particular hosted session.

 2 Apply additional file scanning and antivirus measures on a per session basis including optionally flushing any hosted session where a bad file is detected.

 3 Stream preinstall particular applications into a hosted session for example a default session need not include a web browser and instant messaging application as installed software but may make such applications available in a particular hosted session i.e. applications are streamed to the hosted session .

 5 Create a security policy based login account for a particular hosted session including streaming business applications with or without data into the hosted session pursuant to the policy.

 6 Create firewall rules that are session specific such as different rules for default and hosted sessions.

 7 Set up VPN connection to the remote site inside hosted session. In this case user experience can be further improved with created shortcut on the default desktop such as Connect to the main office network .

 8 Invoke hosted session after a special event is detected. Exemplary events may include but not limited to invoking browser software going to the web site with SSL support and clicking on the web link inside email letter or IM message.

 9 Programmatically set up encryption key for a hosted session. In this case sensitive data will be protected and can be restored by the system administrator later.

 10 Configure hosted session to save document files e.g. .PDF .DOC .XLS on the network drive. In such cases confidential files can be easily archived and audited.

 11 Configure hosted session to save executable files on the network drive. There they can be easily scanned by corporate antivirus software.

 12 Restrict access to peripheral devices from a hosted session. Such devices can include PDAs smartphones flash drives and the like. Such restrictions will provide greater protection for sensitive information.

The SecureDesktop SD system of the present invention allows one to work with several user accounts secure workspace sessions simultaneously. In the currently preferred embodiment operating on the Microsoft Windows platform this is achieved through Microsoft Windows Remote Desktop Connection RDP that is the way Microsoft Windows achieves remote control of a machine. The SD system of the present invention uses the same API as RDP does but does so in a manner that bypasses two restrictions a RDP does not allow connection to the machine where it is started and b Microsoft Windows license may prevent a user from opening more than one session at a time except on Windows Server platforms.

In order to understand how the SD system of the present invention is organized it is instructive to look at how a session is represented in Windows OS including understanding how different components interoperate. The components of interest include Subsystem Base named objects BNO Session space Raw Input Thread RIT Console Initial Command Session and Session manager. These will be explained in turn.

Subsystem refers to the part of the OS operating system providing a subset of its API. Microsoft Windows OS for example includes different subsystems Win32 user API as opposed to Win32 kernel API user part is provided by user32.dll at a higher level POSIX API more may be added. Process csrss.exe is responsible for providing this API.

Base named objects BNO collectively represents a directory kernel object not a file system directory containing all named IPC inter process communication objects.

Session space is a special range of virtual addresses in high part of memory above 0x80000000 . Windows memory manager maps them to specific physical pages based on the session currently active. The exact address limits depend on OS version used. All session specific modules and data e.g. video drivers reside in this memory area.

Raw Input Thread RIT is a thread responsible for providing user input key presses mouse movements and the like to user applications. This thread communicates directly with input device drivers.

Initial Command is a process responsible for user authentication launching all other processes managing UI objects and so forth typically this is winlogon.exe for a default Windows session. For creation of secure workspace sessions hosted sessions the initial command process operates as hereinafter described.

Session is a structure characterizing a session. It is associated with its own subsystem process initial command process unique session id numerical where initial session is id of 0 and thereafter incremented for later sessions BNO own session space and as such own video driver a Win32 subsystem specific RIT Win32 subsystem specific and console Win32 subsystem specific .

Session manager smss.exe is a process or module of the present invention which is responsible for creating and destroying sessions. For that purpose it exposes an API for managing sessions via LPC port.

Service descriptor table is an indexed array where the index is the number of an OS kernel function and the value is a pointer to the OS kernel function.

In accordance with the present invention the SD provides the user with an additional session and a virtual console represented with a window on a screen in a user s default session. To achieve this the SD starts a session provides video driver redirecting its output to a window and provides input devices that take and get input data from a window. The description which follows focuses on implementation details of this process.

Native Windows logon winlogon is not used as it requires extra authentication and the user may not be licensed to run two active sessions on non server OS es. As shown at the session request from the user program is routed through the Session Port Server CPSMSERV to the Session Manager SMSS through the SmApiPort . The Session Port Server is responsible for creating and terminating sessions by calling the Session Manager through the SmApiPort . In response to the above session request the Session Manager SMSS creates a session hosted session and starts two processes inside it Win subsystem csrss.exe and CPLogon initial command . The Session Port Server is also responsible for controlling the Win32 subsystem csrss.exe state and session devices indirectly through csrss.exe as hereinafter described. In addition the Session Port Server enables one time interception through a helper driver as discussed below.

The SD s mouse and keyboard device are implemented as a shared queue of input events vmouse.c VMouseCreateDevice vkbd.c VKbdCreateDevice . The queue is a shared memory block with two signals filled empty shared between userspace and kernel mode. The subsystem starts the Raw Input Thread RIT which connects to the SD s mouse and keyboard using handles obtained through helper driver during the previous initialization stage depicted at . The RIT reads events which results in polling the queue sharedrwqueue.c SharedRWQueueReadIntolrp . These operations are described in further detail below.

The initial command serves to login a user create required UI objects and adjust kernel object privileges for the hosted session. It also starts a shell process. If virtualization is required for the session the shell process will be suspended and its handle will be duplicated to a virtualization manager.

As subsequent operations involve Win32 user API before proceeding a check is made to make sure the subsystem process has completed initialization. When the subsystem status is subsystem initialization is complete and initial command received credentials username password for a new session as shown at at . The credentials are chosen by a user when a session is about to be started. Alternatively the credentials may comprise predefined values for a limited account when used for a virtual session Session.cpp Session Session for request SessionPortServer.cpp SessionPortServer respondWithSessionInfo for response . The credentials are used for user logon UserToken.cpp UserToken UserToken and its profile is loaded UserToken.cpp UserToken loadProfile .

The user account that has been created is now granted access to session BNO BaseNamedObjects as illustrated at at so that new processes can use named IPC inter process communication objects UserAuth.cpp UserAuth grantAccessToObjectsDirectory . A window station is created as shown at and two desktops are allocated as shown at at a limited logon desktop and a user desktop Session.cpp Session executeShell . User privileges are granted to the window station and desktop so that new processes can manipulate UI objects. A notification window is also created Session.cpp Session notificationThread and registered with the help of driver desktopui.c SetLogonNotifyWnd . This notification window will receive shutdown notification when session termination is requested. Next user profile settings are updated UserAuth.cpp UserAuth updateSystemInfoForUser and user themes are applied UserAuth.cpp UserAuth enableThemes . Finally a shell launcher userinit.exe is started with privileges provided by previously retrieved credentials as described above and illustrated at at . This involves authenticating a user creating an environment block for a user appending profile variables UserAuth.cpp UserAuth appendProfileData and starting a process UserAuth.cpp UserAuth launchProcess .

At this point a user is running in another session on another desktop. To obtain video output from the session another application is started that simply maps the video memory file created by the video driver and copies it onto a window videomemory.c VideoMemory GetSharedMemory virtualmonitor.c VirtualMonitor Update .

The same application used to display session screen handles also passes input events to another session. For these purposes low level keyboard and mouse hooks are enabled as soon as application window s becomes active appmon.c InitAllHooks appmon.c EnableInputHook . These hooks are disabled as soon as input focus leaves application window s appmon.c StopInputHook . Hook functions translate window messages to driver level input event structures and pass them to virtual keyboard mouse devices set up earlier by the driver via shared queue hookmouse.cpp MouseHook TranslateEventToInputData hookkbd.cpp KbdHook .

Termination of the session involves two general stages. The first stage involves telling the subsystem to stop. is a block diagram illustrating the first stage of session termination. Using the same external user program used to start the session i.e. as shown at an message ExitWindowsClientState.cpp ExitWindowsClientState replyToMessage is sent to the Win32 subsystem csrss.exe as shown at at . This message causes the subsystem to send shutdown notification as illustrated at to the registered window of initial command . In turn initial command calls ExitWindowsEx requesting system shutdown as shown at at . It will correctly stop all processes running inside the session except for the subsystem process and initial command . Initial command is then responsible for cleaning up all UI objects and for notification to CPSMSERV that the first stage of the shutdown process is complete Session.cpp Session disconnect as shown at at .

While the invention is described in some detail with specific reference to a single preferred embodiment and certain alternatives there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention.

