---

title: Delta operations on a large object in a database
abstract: A computer modifies data inside a database large object (LOB) of unknown structure without modifying other data in the remainder of the LOB. Insertion of new data at a specified location in the LOB does not require movement of existing data in the LOB. Instead, the computer is programmed to insert new data at a physical end of the LOB, and modify metadata based on the specified location. Similarly, deletion of existing data from a specified location in the LOB is performed without movement of other data in the LOB, by updating the metadata. The computer uses the metadata when reading from the LOB, so that the new data is automatically read whenever the specified location is accessed. The computer may optionally output a handle that is static, relative to other insertions and deletions, to identify specific data within the LOB, for use in building indexes on the LOB.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761411&OS=07761411&RS=07761411
owner: Oracle International Corporation
number: 07761411
owner_city: Redwood Shores
owner_country: US
publication_date: 20070720
---
Use of large objects LOBs in relational databases is well known. LOBs are a set of datatypes that are designed to hold very large amounts of text or binary raw data. With current technology a LOB can hold up to a maximum size ranging from 8 terabytes to 128 terabytes depending on how a database is configured. For more information on LOBs see e.g. Oracle Database Application Developer s Guide Large Objects 10 g Release 2 10.2 Part No. B14249 01 published in 2005 that is incorporated by reference herein in its entirety as background. Also see Oracle Database PL SQL Packages and Types Reference 10 g Release 2 10.2 Part No. B14258 01 published in 2005 which is also incorporated by reference herein in its entirety as background. As described in such documentation an XML document can be stored unparsed as a character or byte sequence of unknown structure in a LOB column of a database.

U.S. Pat. No. 5 999 943 is hereby incorporated by reference herein in its entirety as background. This patent teaches performing operations on large objects LOBs in a database. In such a prior art system a server computer receives from a client computer a command or query to be performed on a relational database. The command typically identifies a row of a table e.g. based on user input . The table in the database includes a column that contains LOBs. Server computer is typically programmed with software e.g. supporting PL SQL to respond by sending to client computer a first set of data from the row in the database. The first set of data includes a locator for a LOB that belongs in the LOB column of the identified row. The locator includes a LOB identifier that uniquely identifies the LOB and snapshot information that identifies a particular version of the LOB. Thereafter server may receive from client a request to perform an operation on the LOB. The request may be made in conformance with an application programming interface LOB API that requires passing the locator for the LOB to server . Server performs the requested operation on the particular version of the LOB that is identified in snapshot information contained in the locator passed to server by client .

Changes made in response to an update to a particular LOB chunk by server are illustrated on the right side of by use of an apostrophe after a reference numeral. In the illustrated example of a LOB chunk of a LOB with a lobid LOBID2 is updated by server while performing the above described operation. By traversing a LOB index built on the column that contains the LOB an appropriate index entry associated with LOBID2 is found. The index entry includes a pointer that indicates that a chunk block within LOB data storage is the most current version to be updated.

According to U.S. Pat. No. 5 999 943 to perform a LOB operation server reads a current version of data from a LOB s chunk from chunk block identified by the pointer followed by modification of the data in volatile memory and followed by storing back to a different location in LOB data storage . A pointer in index entry is modified by server to point to chunk block containing the updated version of the LOB. Because pointer is updated to be new pointer the next time index entry is used to access that particular data the updated version of the data is accessed at chunk block rather than an old version of the data that remains in chunk block .

A similar system is disclosed in U.S. Pat. No. 6 738 790 granted to Klein et al. that is directed to accessing a large object that belongs to a cell in a table. See also U.S. Pat. No. 6 836 778 that describes storing XML documents as LOBs in a database. Both these patents are incorporated by reference herein in their entirety as background.

To the inventors knowledge prior art related to LOB operations requires that everything after a portion that is modified in a LOB needs to be rewritten if the modified portion is larger than the original portion. Therefore the inventors find it desirable to improve the operations related to changing of a LOB whose structure is not known.

A computer is programmed in accordance with the invention to modify data inside a database large object LOB whose structure is not known without modifying other data in the remainder of the LOB. Hence insertion of new data at a specified location in the LOB does not require movement of any existing data in the LOB. Instead the computer is programmed to insert new data at a physical end of the LOB. The computer is further programmed to modify metadata for the LOB based on the specified location. Similarly deletion of existing data from a specified location in the LOB is performed without movement of other data in the LOB by updating the metadata. The computer uses the metadata to read from the LOB so that the new data is read whenever the specified location is accessed e.g. via a snapshot offset .

The computer may be further programmed in some embodiments to optionally output a handle e.g. a mark offset to identify data within the LOB. The handle is designed to be static relative to other insertions and deletions in the LOB. Hence the handle is used by application s in a client computer to build indexes of data in the LOB. For example such a handle uniquely identifies data of interest to the client regardless of the number and location of insertions and or deletions in the remainder of the LOB.

A server computer is programmed in accordance with the invention to perform an update at any intermediate location inside a LOB data storage without modifying any data in the remainder of LOB data storage . LOB data storage holds a large object LOB whose internal structure is not known to a relational database within which LOB is stored in a LOB column therein . Note that shows several pieces of hardware and or software that are similar or identical to corresponding pieces shown in prior art wherein the reference numerals in are obtained by adding 100 to corresponding reference numerals in .

A client computer may issue a command e.g. in response to user input to insert new data at a location within LOB that is intermediate relative to a beginning of the LOB and an end of the LOB . The intermediate location at which new data is to be inserted is typically specified by computer as an offset relative to the beginning of LOB . The offset of insertion which is issued by computer is hereinafter referred to as a snapshot offset. In addition to the snapshot offset computer also identifies the LOB itself by a LOB locator the amount of data to be inserted also called length and further supplies the raw data itself that is to be inserted. Such a command to operate on a portion of a LOB is also referred to herein as an atom. 

Depending on the embodiment computer may be programmed to also issue a delete atom when necessary for example to delete data from a specified location in the LOB. In some embodiments the just described insert and delete atoms are special cases of a replace atom that specifies a start position and length of an existing piece of data to be replaced and further specifies new data s length and the new data itself. Detailed description of several atoms and their implementation is provided below in reference to . For further detail see the Attachments A and B appended below at the end of the detailed description.

A move atom on data within a LOB can be implemented as a delete atom followed immediately by an insert atom by inserting the piece of data that is deleted from a source location in the LOB into a destination location in the LOB. Depending on the embodiment each location may be specified as an offset relative to a boundary of the LOB i.e. relative to a beginning of the LOB or relative to an end of a LOB . Hence the move atom has two offsets specified source offset and destination offset and the length of data portion to be moved. The advantage of specifying a move atom is that one doesn t need to supply the deleted data portion to an insert atom in an API call and there is also no data appended to the end of LOB as in an insert atom. Accordingly some embodiments implement a move atom as a metadata change only operation.

Referring to server computer is programmed in some embodiments of the invention to respond to an insert atom by appending the new data to be inserted at a physical end of the LOB. Specifically in database after insertion LOB data storage is shown in to be encoded with new data C immediately after a last byte within LOB i.e. at the very end which happens to still fall within block in this illustrative example . In this example LOB is an enlarged version of LOB which includes the newly inserted data C in block .

Note that new data C was not inserted at a snapshot offset e.g. 3.5 KB that was specified in the insert atom. Insertion of new data at an insert atom s specified snapshot offset is avoided deliberately in several embodiments to ensure that data already existing in the rest of LOB data storage remains unchanged even after insertion of the new data. Specifically movement of existing data in LOB data storage is eliminated when new data C is stored at any location other than an intermediate location which is preceded and followed by existing data .

Storing of new data C at the end of LOB rather than at the snapshot offset e.g. 3.5 KB specified in the insert atom requires extra work when reading the LOB. In many embodiments the extra work is done by server computer independent of client computer . Specifically server computer automatically modifies certain metadata based on one or more pieces of information in the insert atom such as the snapshot offset e.g. 3.5 KB . Moreover server computer also called simply server uses the updated metadata whenever data is read from the LOB as described next.

Before an insert atom is executed data is read from LOB data storage in the normal manner similar to that described above in reference to . Specifically metadata includes a flag not shown which does not require any special processing when accessing the data from LOB data storage . Therefore the snapshot offset specified by client is used to access the LOB in LOB data storage .

After the insert atom is executed the just described flag is set which in turn triggers operation of a translator whenever data is to be accessed from LOB data storage . Translator automatically converts a snapshot offset specified in the insert atom into a physical offset at which the data to be read is actually located within LOB data storage . For example when reading data from block sequentially the translator maps every snapshot offset to an identical physical offset until reaching the insert atom s specified snapshot offset e.g. 3.5 KB . When this value is reached the snapshot offset is translated see branch in to the physical address at the end of the LOB where the new data C is stored. The translator continues in this manner at increasing values of snapshot and physical offsets until the end of new data is reached. Thereafter the translator translates the next snapshot offset to a physical offset which is identical in value to the insert atom s specified snapshot offset e.g. 3.5 KB as illustrated by branch . Therefore reading of the LOB continues immediately following the insert atom s snapshot offset. Then the translator continues at increasing values of snapshot and physical offsets until the LOB is fully read.

Accordingly by modifying metadata during an insert atom and by using the metadata to translate a snapshot offset into a physical offset server is able to avoid movement of any existing data in the LOB during the insert atom. Similarly deletion of existing data from a specified location in the LOB is performed without movement of other data in the LOB simply by updating the metadata as shown in . Moreover after a delete atom is executed server reads data from the LOB with a translator ensuring that reading of deleted data is skipped see branch in on accessing the location s specified in the delete atom e.g. via the snapshot offset .

The identity mapping is represented in some embodiments by a flag in metadata which indicates that no translation is needed to go from a snapshot offset to a physical offset. Alternative embodiments may store in memory a single entry map with entry shown at the bottom of . A map s entry is interpreted in many embodiments as an abbreviated representation of a sequence of entries in a full map which is of the same size as the LOB and which maps every character in the LOB. The two offsets in such a sequence of entries have the same relationship to one another with both incremented by the same amount so entry denotes entries and so on up to the end of the LOB . Also the total size of a map is same which map is obtained by incrementing each offset by 1. This interpretation keeps the map itself small in size without the need to have one entry in the map for every byte in the LOB. Furthermore the map is assumed to extend to infinity which allows the map to remain unchanged in situations where new data is simply appended at the end of the LOB.

Referring back to at time T server computer receives an insert atom to insert F at snapshot offset i.e. at location which is located immediately after B. Note that C which is currently at location is not to be replaced and instead F is to be inserted between B and C. To do so server computer simply inserts F at the end of the LOB. At this stage i.e. at time T snapshot offset refers to F and snapshot offsets 4 5 6 respectively refer to C D E. So at time T the LOB contains the characters A B C D E F and their corresponding physical offset are 1 2 3 4 5 6. Accordingly the snapshot to physical map see bottom of now contains three entries namely . Such a map is stored in a b tree data structure in some embodiments with each snapshot offset in a b tree leaf or branch being stored relative to its parent. B tree storage of snapshot offsets allows fast maintenance of offsets by updating just one path from a particular entry to the root node.

The computer may be further programmed in some embodiments to automatically perform a re organization of the information within a LOB e.g. if one or more predetermined condition s indicate that the LOB is too fragmented. Note that the specific conditions indicative of over fragmentation of a LOB are implementation dependent heuristics which are not critical aspects of the invention.

During re organization all the data in the LOB that is shown by metadata to have been deleted is physically deleted from the LOB. Any holes in the LOB are removed and remaining data in the LOB is physically arranged in the same sequence as per the snapshot offset. Therefore at the end of a re organization as illustrated at time T in the LOB of this example contains the characters A B F C D E and the two offsets are both of the same value namely 1 2 3 4 5 6. At this stage the map is again as shown at time T at the bottom of .

Note that the above described reorganization at time T did not affect the snapshot offset. The reason is that the physical offset is the one that was changed during the reorganization as data was shuffled within the LOB. Accordingly client computer which uses the snapshot offset continues to operate in the normal manner independent of the reorganization of data within the LOB. For this reason in many embodiments LOB data reorganization is performed by server at any convenient time without notifying client .

The server may be further programmed in some embodiments to optionally output a handle called mark offset to identify data within the LOB. The mark offset is designed to be static relative to the identified data regardless of other insertions and deletions in the LOB. One can use a mark offset that identifies for example an XML node within the LOB to refer to the same XML node again and again regardless of changes in the rest of the LOB. Hence mark offsets to certain pieces of data of interest to a client computer remain unchanged even when snapshot offsets of these data pieces change dynamically with time as new data is added and existing data is deleted. Hence mark offsets are used by application s in a client to build indexes to the data of interest in the LOB. Accordingly a mark offset uniquely identifies data of interest to the client regardless of the number and location of insertions and or deletions in the remainder of the LOB.

A mark offset is implemented in some embodiments by use of a temporal sequence in which data enters a LOB. Accordingly the mark offset can be any monotonically changing sequence number such as a count that is incremented each time any data is added to the LOB. In one illustrative example a number indicating a sequence in which a byte character of data enters the LOB is used as a mark offset. Initially at the time of LOB creation mark offsets have the exact same value as the physical offsets as illustrated at times T and T in . As shown at the bottom of a map of the mark offset to physical offset is an identity map at times T and T. Then at time T LOB reorganization is performed and the physical location of characters C D E F changes within the LOB and hence their physical offset changes but the mark offset remains unchanged as noted above the mark offset is based on the time at which each character entered the LOB which is history and has remained unchanged . Hence the mark to physical map is no longer an identity map and instead there are three entries namely .

Although a history notion has been used to introduce the concept of mark offset note that the mark offsets can be reset so that the mark to physical map becomes same as the snapshot to physical map. When such a reset is performed all history is forgotten . The reset operation is useful in creating or rebuilding an index on the LOB. Accordingly when a reset is performed by server computer the client computer is notified. Thereafter client computer performs a scan of the entire LOB to obtain new mark offsets of all the data pieces of interest and rebuilds its indexes based on new mark offsets.

Hence a database management system within a server computer is programmed in some embodiments of the invention to execute various atoms of the type illustrated in and discussed next.

In response to a delete atom from a client the system performs a delete function which includes actions and . Based on the snapshot offset and length identified in the delete atom in action system maintains the snapshot to physical mapping of the LOB. Such maintenance may require for example splitting of a map entry into two entries to effectively omit the deleted data from the map when the deleted data is covered within a single in the mapping. For example if a single character B is being deleted from the LOB shown at time T in a single entry in the snapshot to physical mapping e.g. is replaced with two entries and thereby effectively demapping physical offset . Additionally system also maintains in act a length of the LOB in metadata e.g. by reducing the existing length by the deleted data s length. Numerous such actions that are needed to implement a delete atom will be apparent to the skilled artisan in view of this disclosure.

In response to an append atom from a client system performs an append function which includes actions and . In action system looks up the LOB s existing length e.g. from metadata . In action system simply copies the new data to the end of the LOB. Based on the snapshot length identified in the append atom in action system increases the existing length by the length of the new data being appended i.e. updates the metadata .

In response to an insert atom from a client system performs an insert function which includes actions as follows. Based on the snapshot offset and length identified in the insert atom in action system maintains the snapshot to physical mapping of the LOB. Action is implemented in a manner similar to that discussed above for the delete atom and may require for example splitting of a single map entry that covers the snapshot offset at which new data is being inserted. Note that a map entry may be split in action into three entries to effectively insert the new data into the map when the inserted data is located at the end of the LOB. An example of a single character F being inserted into the LOB has been illustrated at time T in wherein a single entry in the snapshot to physical mapping e.g. was replaced with three entries as shown in map . Additionally system also maintains in act a length of the LOB in metadata e.g. by reducing the existing length by the deleted data s length. In act the system appends the new data to the end of the LOB e.g. in a write gather cache from which the data is eventually written back to disk.

Moreover in some embodiments system may also maintain in act a file offset for use in the next call. File offset is a term used by file system API to allow a client to issue multiple read write calls without needing to specify offset in each one of them. Accordingly in some embodiments an atom is assumed to start from where the last atom left off. This implicit offset is understood as the file offset. Some implementations do not use file offset in the API which require the client to specify snapshot offset in each atom.

Finally in act system updates an internal variable which identifies the next mark offset and thereafter returns to the client a value of this internal variable before insertion of the new data as a mark offset of the newly inserted data. Note that the internal variable is increased by the length of the new data at the end of act for use in a future insert or append function. Numerous such actions that are needed to implement a delete atom will be apparent to the skilled artisan in view of this disclosure.

Several additional atoms such as read write open trim truncate flush and close are performed by their respective functions and that are implemented by system in a manner similar to that described above. Specifically in read function system initializes a B tree range scan on the snapshot to physical mapping in action to find a portion of the B tree containing snapshot addresses of interest to the client followed by translating the read call through the snapshot to physical map in action into a series of individual calls the number of calls into which a single call translates depends on the number of entries in the snapshot to physical map . The translated calls are issued directly to the write gather cache thereby to read the data from the translated address.

Similarly in write function system again initializes a B tree range scan on the snapshot to physical mapping in action to find a portion of the B tree containing snapshot addresses of interest to the client. Thereafter if the LOB is a BLOB or a CLOB of fixed width or a NCLOB system performs action wherein the write call is translated through the snapshot to physical map into a series of individual calls. The translated calls are issued directly to the physical layer of the LOB thereby to over write the data at the translated address. If the LOB is a CLOB of varying width system performs action wherein the write call is treated as a replace call. As noted above a replace atom can be implemented as a delete atom immediately followed by an insert atom.

Moreover in trim truncate function system performs the same actions as in the delete function namely action is same as action and action is same as action . The trim truncate function is maintained in some embodiments for backward compatibility.

In an open function system initializes the internal variable for the next mark offset and also initializes another variable which holds the length both are initialized to the value 0 in the metadata which is maintained for the LOB in a memory of the system . The open function is invoked at the very beginning when a LOB is first loaded into the database e.g. in response to a SQL statement from the client.

In a flush function system checks in action a flag in metadata in the memory of system which indicates whether the LOB has been subject to any update after being loaded into memory if this flag indicates no update then the snapshot to physical map is an identity map . Next in action system calls the write gather cache to flush the LOB to disk. Thereafter system performs a redo generation callback to generate a redo log for the LOB and in doing so performs an act to check if the LOB has a metadata change for a fragment component such as total length next mark offset or per LOB statistics. If so system generates the appropriate redo entries in the redo log of the database.

In a close function system performs an action to evaluate one or more predetermined conditions which trigger reorganization of the LOB s data. If the condition s is are met then system registers a post commit callback. Thereafter when performing the call back function system performs an act to schedule a background task that is to perform the reorganization. Finally in a task call back system performs an act to lock the row in the database that contains the LOB and if no lock is obtained then aborts this act . If the lock is obtained then system opens the LOB for read write operations followed by re evaluating the one or more predetermined conditions which triggered the reorganization to ensure they are still met and if so then reorganizes the data in the LOB.

Note that a mark reset is not performed in act which is limited to just reorganization of the LOB s data without informing any client. The reset of the mark to physical mapping is typically performed as a separate function in coordination with one or more client s that access the LOB typically in response to a request from the client s . Similarly system also supports translation of the mark offset to snapshot offset via function . This translation function is invoked by a client to obtain snapshot offsets for use with the above described functions e.g. delete insert append write read etc implemented by system . In function system first uses a mark to physical map in metadata to translate the received mark offset into a physical offset and then initiates a scan on the snapshot to physical map to identify the corresponding snapshot offset which is then returned to the client.

Note that a database in server computer may be implemented in some embodiments by use of a computer e.g. an IBM PC or workstation e.g. Sun Ultra 20 that is programmed with a relational database management system RDBMS called Oracle Database available from Oracle Corporation of Redwood Shores Calif. Such a computer can be implemented by use of hardware that forms a computer system as illustrated in . Specifically computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information. According such a processor is programmed in some embodiments of the invention to execute the first command by modifying data in a portion of a LOB without modifying data in a remainder of the LOB unrelated to the portion being modified.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Note that bus of some embodiments implements each of buses and illustrated in . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

As described elsewhere herein incrementing of multi session counters shared compilation for multiple sessions and execution of compiled code from shared memory are performed by computer system in response to processor executing instructions programmed to perform the above described acts and contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement an embodiment of the type illustrated in . Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable storage medium as used herein refers to any storage medium that participates in providing instructions to processor for execution. Such a storage medium may take many forms including but not limited to non volatile storage media and volatile storage media media. Non volatile storage media includes for example optical or magnetic disks such as storage device . Volatile storage media includes dynamic memory such as main memory . Any such storage media may be used in an article of manufacture.

Common forms of computer readable storage media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical storage medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge as described hereinafter or any other storage medium from which a computer can read.

Various forms of computer readable storage media may be involved in carrying the above described instructions to processor to implement an embodiment of the type illustrated in . For example such instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load such instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive such instructions on the telephone line and use an infra red transmitter to convert the received instructions to an infra red signal. An infra red detector can receive the instructions carried in the infra red signal and appropriate circuitry can place the instructions on bus . Bus carries the instructions to main memory in which processor executes the instructions contained therein. The instructions held in main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . Local network may interconnect multiple computers as described above . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a code bundle through Internet ISP local network and communication interface . In accordance with the invention one such downloaded set of instructions implements an embodiment of the type illustrated in . The received set of instructions may be executed by processor as received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain the instructions in the form of a carrier wave. Accordingly an article of manufacture may include a storage medium or alternatively may include a carrier wave as both are manufactured by humans.

Numerous modifications and adaptations of the embodiments described herein will be apparent to the skilled artisan in view of the disclosure. Accordingly numerous such modifications and adaptations are encompassed by the attached claims.

In several embodiments a computer implemented method performs operations in a structured query language SQL compliant database management system DBMS that allows storage of large objects LOBs of unknown structure. Specifically in such embodiments a server receives an SQL statement that includes a first command to update inside a large object LOB a portion that is smaller than all of the LOB and the server executes the first command by modifying data of the portion without modifying data in a remainder of the LOB unrelated to the portion. During execution of the first command the server modifies metadata to be used to read the LOB based on where the portion is located within the LOB and in response to a second command the server uses the metadata to read data from the LOB and output the read data to a client.

When the first command is to insert new data into the LOB at a location not at an end of the LOB during execution of the first command in some embodiments the server described in the previous paragraph appends the new data to the end of the LOB and the server modifies metadata based on the location. When the first command is to delete existing data from the LOB at a location not at an end of the LOB the server modifies metadata based on the location. In several embodiments the metadata includes a map that maps an offset snapshot offset in the first command to another offset physical offset in the LOB at which the portion is located and during modification of the metadata the server modifies the map.

Several embodiments of the type described herein make the cost of input output IO for changes to a LOB linear to the size of the change delta not linear to the size of the LOB. Thus the name delta update is used in some embodiments. In such embodiments at the time of update user needs to specify which LOB to update and provide the delta diff for the update. In these embodiments an API takes input size roughly the same as the delta size and the delta operation is performed by a list of change atoms of the type described above. As noted above a replace atom of these embodiments specifies these fields replace interval start position replace interval length or end position new data length new data . In these embodiments each atom specifies an operation to replace a piece of data contiguous bytes called replace interval inside the LOB with some new data. In such embodiments the insert append and delete atoms are simply special cases of the replace atom as follows insert append atom is obtained when the replace atom s interval length is 0 a delete atom is obtained when new data length is 0. Such embodiments may further support a move atom that specifies the following fields source start position source length destination position the move atom specifies an operation to move a piece of data inside the LOB. The piece of data being moved is called move interval.

In some embodiments reorganization of a LOB may occur automatically during an update operation when the server evaluates that a reorganization operation is more beneficial than a delta update operation. The reorganization operation of certain embodiments is fully transparent to the client although the update operation appears slow to the client. A heuristic used by the server of some embodiments to decide for reorganization is based on delta size both in the absolute terms and relative to the LOB size auxiliary mapping size and one or more read response time statistics for the LOB segment. The specific heuristic used to trigger LOB reorganization is not a critical aspect of the invention.

Several embodiments provide backward compatibility in usage of traditional LOB API such as append trim truncate write together with the new update API. In addition in these embodiments the new update API is allowed to be called on any LOB with the new LOCAL storage type including those stored in row. In several embodiments LOB delta update is supported for combinatorial sharing compression and for versioning. Also some embodiments support LOB delta update for various objects such as CLOB NCLOB both fixed width character sets and varying width character sets . The API for CLOB and NCLOB in several embodiments is same as BLOB except that the offset fields are interpreted as character offsets.

The following ATTACHMENT A describes an application programming interface API for the delta update operation in a package called dbms lob as used in a relational database in some illustrative embodiments. The FUNCTION fragment insert is used to insert given data limited to 32K into the LOB at the given offset when offset is not set or is set to 1 the last offset written to or the end of lob if not indicated is used as the offset. This function returns a negative value on error and throws exception. The PROCEDURE fragment delete is used to delete the data at the given offset for the given length from the LOB this procedure throws exceptions on error. The PROCEDURE fragment move is used to move the length bytes from the given offset to the new offset given this procedure throws exceptions on error. The FUNCTION fragment replace is used to replace the data at the given offset with the given data not to exceed 32 k when offset is not set or is set to 1 the last offset read from or written to is used as the offset. This function is equivalent of performing the procedure fragment delete for replace len bytes at offset and then the function fragment insert for data length bytes at the same offset. This function fragment replace returns negative value on error and throws an exception. The following ATTACHMENT B describes an illustrative example using SQL statements. Note that in some embodiments an API called Oracle Call Interface OCI for the database ORACLE is also extended in a similar manner as will be apparent to the skilled artisan in view of this disclosure.

