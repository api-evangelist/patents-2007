---

title: SIP and HTTP convergence in network computing environments
abstract: The SIP server can be comprised of an engine tier and a state tier distributed on a cluster network environment. The engine tier can send, receive and process various messages. The state tier can maintain in-memory state data associated with various SIP sessions. The SIP server can support converged HTTP and SIP modes of communication. An application session can be established for allowing the association of an HTTP session with a SIP session such that data can be exchanged between them. This association can be broken and reestablished with new application sessions such that various SIP and HTTP clients can join and leave new sessions. An API can be provided to enable various associations and method calls for the application session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08001250&OS=08001250&RS=08001250
owner: Oracle International Corporation
number: 08001250
owner_city: Redwood Shores
owner_country: US
publication_date: 20070515
---
The present application claims the benefit of U.S. Provisional Patent Application No. 60 801 091 entitled SIP AND HTTP CONVERGENCE IN NETWORK COMPUTING ENVIRONMENTS by Anno R. Langen et al. filed on May 16 2006 which is incorporated herein by reference in its entirety.

The following commonly owned co pending United States patents and Patent Applications including the present application are related to each other. Each of the other patents applications are incorporated by reference herein in their entirety 

U.S. patent application Ser. No. 11 378 188 entitled SYSTEM AND METHOD FOR MANAGING COMMUNICATIONS SESSIONS IN A NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. patent application Ser. No. 11 384 056 entitled SYSTEM AND METHOD FOR A GATEKEEPER IN A COMMUNICATIONS NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. Provisional Patent Application No. 60 800 943 titled HITLESS APPLICATION UPGRADE FOR SIP SERVER ARCHITECTURE by Anno R. Langen et al. filed on May 16 2006 

U.S. Provisional Patent Application No. 60 801 083 entitled ENGINE NEAR CACHE FOR REDUCING LATENCY IN A TELECOMMUNICATIONS ENVIRONMENT by Anno R. Langen et al. filed on May 16 2006 

U.S. patent application Ser. No. 11 434 022 entitled SYSTEM AND METHOD FOR CONTROLLING DATA FLOW BASED UPON A TEMPORAL POLICY by Narendra Vemula et al. filed on May 15 2006 

U.S. patent application Ser. No. 11 434 024 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY PUSH PROTOCOLS BASED UPON A POLICY by Bengt Inge Jakobsson et al. filed on May 15 2006 

U.S. patent application Ser. No. 11 434 010 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY MULTIMEDIA MESSAGE PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 

U.S. patent application Ser. No. 11 434 025 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY SHORT MESSAGE PEER TO PEER PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 

U.S. patent application Ser. No. 11 432 934 entitled SYSTEM AND METHOD FOR SHAPING TRAFFIC by Jan Thomas Svensson filed on May 12 2006 

U.S. patent application Ser. No. 11 748 767 entitled HITLESS APPLICATION UPGRADE FOR SIP SERVER ARCHITECTURE by Anno R. Langen et al. filed on May 15 2007 

U.S. patent application Ser. No. 11 748 791 entitled ENGINE NEAR CACHE FOR REDUCING LATENCY IN A TELECOMMUNICATIONS ENVIRONMENT by Anno R. Langen et al. filed on May 15 2006.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The current invention relates generally to managing telecommunications and web applications and more particularly to providing a convergence of SIP and HTTP protocols for a network.

Conventionally telecommunications and network infrastructure providers have relied on often decades old switching technology to providing routing for network traffic. Businesses and consumers however are driving industry transformation by demanding new converged voice data and video services. The ability to meet these demands often can be limited by existing IT and network infrastructures that are closed proprietary and too rigid to support these next generation services. As a result telecommunications companies are transitioning from traditional circuit switched Public Switched Telephone Networks PSTN the common wired telephone system used around the world to connect any one telephone to another telephone to Voice Over Internet Protocol VOIP networks. VoIP technologies enable voice communication over vanilla IP networks such as the public Internet. Additionally a steady decline in voice revenues has resulted in heightened competitive pressures as carriers vie to grow data service revenues and reduce churn through the delivery of these more sophisticated data services. Increased federal regulation security and privacy issues as well as newly emerging standards can further compound the pressure.

However delivering these more sophisticated data services has proved to be more difficult than first imagined. Existing IT and network infrastructures closed proprietary network based switching fabrics and the like have proved to be too complex and too rigid to allow the creation and deployment of new service offerings. Furthermore latency has been an important issue in addressing the processing of telecommunications as more and more users expect seemingly instantaneous access from their devices. Furthermore a need exists for applications that support communications in different protocols in order to provide converged services.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. References to embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

In the following description numerous specific details are set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail so as not to obscure the invention.

Although a diagram may depict components as logically separate such depiction is merely for illustrative purposes. It can be apparent to those skilled in the art that the components portrayed can be combined or divided into separate software firmware and or hardware components. For example one or more of the embodiments described herein can be implemented in a network accessible device appliance such as a router. Furthermore it can also be apparent to those skilled in the art that such components regardless of how they are combined or divided can execute on the same computing device or can be distributed among different computing devices connected by one or more networks or other suitable communication means.

In accordance with embodiments there is provided a system and method for providing session initiation protocol SIP and hyper text transfer protocol HTTP convergence in network computing environments. A SIP server can be maintained that is comprised of an engine tier and a state tier distributed on a cluster network environment. The engine tier can include engine nodes that send receive and process various messages. The state tier can include state replica nodes that maintain in memory state data associated with various SIP sessions. The SIP server can support converged HTTP and SIP modes of communication. An application session can be established for allowing the association of an HTTP session with a SIP session such that data can be exchanged between them. This association can be broken and reestablished with new application sessions such that various SIP and HTTP clients can join and leave new sessions. An API can be provided to enable various associations and method calls for the application session.

In one embodiment an application can be deployed on the engine tier nodes of the SIP server. This application can provide services that are both SIP and HTTP based where it may be advantageous to exchange data between the different protocols. In one embodiment a converged application session object is generated to maintain the session state for the application. The application session object can include an HTTP session and a SIP session. Each session can maintain the data associated with the state of the protocol. In this manner data can be exchanged between the HTTP session and the SIP session of the application. A single unified API can allow an application running on the engine tier to access the various session services.

A Session Initiation Protocol SIP Server and a Network Gatekeeper can comprise a portfolio of products that collectively make up the Communications Platform . The SIP Server provides the Communications Platform with a subsystem in which application components that interact with SIP based networks may be deployed. The Network Gatekeeper provides a policy driven telecommunications Web services gateway that allows granular control over access to network resources from un trusted domains.

A variety of shared and re usable software and service infrastructure components comprise the Communications Platform . For example an Application Server such as the WebLogic Application Server by BEA Systems Inc. of San Jose Calif. This Application Server may be augmented and adapted for deployment in telecommunications networks while providing many features and functionality of the WebLogic Server counterpart widely deployed in enterprise computing environments. Application Server embodiments for use in the telecommunications applications can provide a variety of additional features and functionality such as without limitation 

Analogously communications platform embodiments can provide a variety of additional features and functionality such as without limitation 

Communications platform comprises a SIP Server WLSS and a Network Gatekeeper WLNG . Tools for interacting with Web Services such as a Web Service Universal Description Discovery Interface WS UDDI a Web Service Business Process Execution Language WS BPEL may be coupled to the SIP Server and the Network Gatekeeper in embodiments. A log trace and database can assist with troubleshooting. In some deployments the Communications Platform can interface with an OSS BSS system via resource adapters . Such interfaces can provide access to billing applications Operation Administration and Maintenance OAM applications and others. A policy engine can control the activities of the above described components which can be implemented in a scalable cluster environment SCE .

A Communications Platform embodiment can provide an open high performance software based fault tolerant platform that allows operators to maximize revenue potential by shortening time to market and significantly reducing per service implementation and integration cost and complexity. The Communications Platform is suitable for use by for Network Infrastructure Vendor Network Operators and Communications Service Providers in multiple deployment scenarios ranging from fully IMS oriented network architectures to hybrid and highly heterogeneous network architectures. It is not restricted to use only in carrier networks however and may be deployed in Enterprise communications networks without restriction or extensive customization. When deployed in conjunction with an IP Multimedia Subsystem the Communications Platform can serve in the role of an IMS SIP Application Server and offers Communications Service Providers an execution environment in which to host applications such as the WebLogic Network Gatekeeper components and standard service enablers.

As illustrated the SIP server can be used as a back to back user agent B2BUA in a typical telecommunications environment. A B2BUA can take the place of an intermediary between communications between user agents including various cellular phones wireless devices laptops computers applications and other components capable of communicating with one another electronically. The B2BUA can provide multiple advantages including controlling the flow of communication between user agents enabling different user agents to communicate with one another e.g. a web application can communicate with a cellular phone as well as various security advantages. As an illustration the user agents can transmit to the SIP server instead of communicating directly to each other and thus malicious users can be prevented from sending spam and viruses hacking into other user agent devices and otherwise compromising security.

The SIP server can be implemented as a Java Enterprise Edition application server that has been extended with support for the session initiation protocol SIP as well as other operational enhancements that allow it to meet the demanding requirements of the next generation protocol based communication networks. In one embodiment the SIP server can include an Enterprise Java Beans EJB container a Hyper Text Transfer Protocol HTTP servlet container an SIP servlet container various Java 2 Enterprise Edition J2EE services and SIP and HTTP components. The SIP stack of the server can be fully integrated into the SIP servlet container and can offer much greater ease of use than a traditional protocol stack. A SIP servlet Application Programming Interface API can be provided in order to expose the full capabilities of the SIP protocol in the Java programming language. The SIP servlet API can define a higher layer of abstraction than simple protocol stacks provide and can thereby can free up the developer from concern about the mechanics of the SIP protocol itself. For example the developer can be shielded from syntactic validation of received requests handling of transaction layer timers generation of non application related responses generation of fully formed SIP requests from request objects which can involve correct preparation of system headers and generation of syntactically correct SIP messages and handling of lower layer transport protocols such as TCP UDP or SCTP.

In one embodiment the container is a server software that hosts applications i.e. contains them . In the case of a SIP container it hosts SIP applications. The container can perform a number of SIP functions as specified by the protocol thereby taking the burden off the applications. At the same time the SIP container can expose the application to SIP protocol messages via the SIP Servlet API on which applications can perform various actions. Different applications can thus be coded and deployed to the container that provides various telecommunication and multimedia services.

As illustrated a message such as a phone call request or some other transfer of data associated with SIP can come into the cluster from the internet such as over VOIP phone or some other type of network . This message can be received and handled by a load balancer which can be responsible distributing message traffic across the engines such as engine node and engine node in the cluster. The load balancer can be a standard load balancing appliance hardware device and it is not necessary that it be SIP aware there is no requirement that the load balancer support affinity between the engines and SIP dialogs or transactions. However in alternative embodiments certain advantages may be obtained by implementing a SIP aware load balancer as discussed in further detail below. Alternatively the load balancer can be implemented as software that distributes the messages to the various engines. In the various embodiments the primary goal of the load balancer can be to provide a single public address that distributes incoming SIP requests to available servers in the SIP server engine tier . Such distribution of requests can ensure that the SIP server engines are fully utilized. The load balancer can also be used for performing maintenance activities such as upgrading individual servers or applications without disrupting existing SIP clients.

In one embodiment the SIP server can provide a two tier cluster architecture model to handle the incoming messages. In this model a stateless engine tier can process all signaling traffic and can also replicate transaction and session state to the state tier and its partitions . Each partition can consist of any number of nodes replicas distributed across any number of hosts such as host and host which can be implemented as computers linked in a cluster type network environment. The state tier can be an n way peer replicated Random Access Memory RAM store that maintains various data objects which can be accessed by the engine nodes in the engine tier. In this manner engines can be provided a dual advantage of faster access to the data objects than retrieving data from a database while at the same time engines can be freed up from having to store the data onto the engine tier itself. This type of separation can offer various performance improvements. The state tier can also function as a lock manager where call state access follows a simple library book model i.e. a call state can be checked out by one SIP engine at a time .

The engine tier can be implemented as a cluster of SIP server instances that hosts the SIP servlets which provide various features to SIP clients. In one embodiment the engine tier is stateless meaning that most SIP session state information is not persisted in the engine tier but is obtained by querying the state tier which can in turn provide replication and failover services for SIP session data. In alternative embodiments the engine tier can have state maintained in a local near cache for improving latency.

The primary goal of the engine tier can be to provide maximum throughput combined with low response time to SIP clients. As the number of calls or their duration increases more server instances can be added to the engine tier to manage the additional load. It should be noted however that although the engine tier may include many such server instances it can be managed as a single logical entity. For example the SIP servlets can be deployed uniformly to all server instances by targeting the cluster itself and the load balancer need not maintain affinity between SIP clients and individual servers in the engine tier.

In various embodiments the state tier can be implemented as a cluster of SIP server instances that provides a high performance highly available in memory store for maintaining and retrieving session state data for SIP servlets. This session data may be required by SIP applications in the SIP server engine tier in order to process incoming messages. Within the state tier session data can be managed in one or more partitions where each partition manages a fixed portion of the concurrent call state. For example in a system that uses two partitions the first partition could manage one half of the concurrent call state e.g. A M and the second partition can manage the other half e.g. N Z . With three partitions each can manage a third of the call state and so on. Additional partitions can be added as needed to manage large number of concurrent calls.

In one embodiment within each partition multiple servers can be added to provide redundancy and failover should the other servers in the partition fail. When multiple servers participate in the same partition those servers can be referred to as replicas because each server maintains a duplicate copy of the partition s call state. For example nodes and of the partition can be implemented as replicas. Furthermore to increase the capacity of the state tier the data can be split evenly across a set of partitions as previously discussed. The number of replicas in the partition can be called the replication factor since it determines the level of redundancy and strength of failover that it provides. For example if one node goes down or becomes disconnected from the network any available replica can automatically provide call state data to the engine tier.

Replicas can join and leave the partition and each replica can serve as exactly one partition at a time. Thus in one embodiment the total available call state storage capacity of the cluster is a summation of the capacities of each partition .

In one embodiment each partition can peer replicated meaning that clients perform all operations reads writes to all replicas in the partition wherein the current set of replicas in the partition is called the partition view . This can provide improved latency advantages over more traditional synchronous primary secondary architecture wherein one store acts as a primary and the other nodes serve as secondaries. Latency is reduced because there is no wait for the second hop of primary secondary systems. The peer replicated scheme can provide better failover characteristics as well since there does not need to be change propagation delay.

In one embodiment the engine nodes can be responsible for executing the call processing. Each call can have a call state associated with it. This call state can contain various information associated with the call such as the ids of the caller callee where the caller is what application is running on the callee any timer objects that may need to fire in order to process the call flow as discussed below as well as any other data that may correlate to a call or a message. The state for each call can be contained in the state tier . The engine tier on the other hand could be stateless in order to achieve the maximum performance. In alternative embodiments however the engine tier can have certain amounts of state data stored thereon at various times.

In one embodiment a typical message processing flow can involve locking getting the call state processing the message and then putting unlocking the call state. The operations supported by the replicas for normal operations can include 

In various embodiments the engine tier can maintain mainly short lived objects and any long lived objects which may be needed for message processing can be stored on the state tier. This can provide improvements in latency during garbage collection. As an illustration the Java Virtual Machine JVM garbage collector can safely and quickly remove the short lived objects from memory without interfering with the execution of various other threads which may be in the process of executing. The longer lived objects on the other hand are not as easily removed by the garbage collector since they may be referenced and depended on by various entities and thus in some cases the JVM garbage collector may need to stop processing all threads in order to safely perform its garbage collection. This is due in part to the scoping of the short lived and long lived objects. Short lived objects typically exist in a different more localized memory scope than the long lived objects which may be referenced by more entities. Thus it can be more difficult for garbage collectors to ensure that every executing entity has finished using the long lived objects and various threads are usually stopped in order to perform their regular garbage collection. This can introduce latency.

In order to deal with such issues the engine tier can maintain mostly short lived objects. In cases where longer lived objects are needed by the engine tier they can be retrieved from the state tier used as short lived objects in the engine tier and subsequently pushed back to the state tier. This can be advantageous in that garbage collection can cause lesser interference with thread execution in the engine tier.

In various embodiments the state tier can maintain call state in various data objects residing in the random access memory RAM of a computer. This can provide significant access speed advantages to the engine tier over the use of a database. Alternatively if latency is not an issue call state can be maintained in a database or some other form of persistent store which can be accessed albeit slower by the engine tier. State of various applications running on the SIP server can also be maintained on the state tier. Developers can be provided an API to allow their applications to access the state tier and to store various data thereon for later access by various applications. Alternatively application state may be stored in a database.

The SIP server can support applications which use HTTP and SIP mode of communication simultaneously. In converged applications the SIP protocol can be combined with other protocols like HTTP to provide a unified communication session. There are various uses and advantages for this type of system. For example an online push to talk application may enable a customer to initiate a voice call to ask questions about products in a shopping cart. The SIP session that is initiated for the call can then be associated with the customer s HTTP session thereby enabling the employee answering the phone to view the customer s shopping cart contents or purchasing history. Such functionality can be provided by the SIP server maintaining a converged session that shares data between the two protocol sessions thereby removing the need to custom program each application in each different protocol. Many other such use cases can benefit from the convergence of SIP and HTTP protocols within the scope of the present disclosure.

As illustrated various applications can be in communication with the SIP server at any given time. For example HTTP Client A can be accessing the server via a web browser and it can have an HTTP session associated therewith which maintains appropriate state for the HTTP client. Similarly another HTTP client B can have its own HTTP session for maintaining its appropriate state . On the other hand SIP clients can also be accessing the server. For example a SIP client application A such as an application running on a mobile phone can be in communication with the SIP server and can have an appropriate SIP session for maintaining session state associated therewith. Similarly another SIP client B such as such as a landline telephone can be accessing the SIP server and it should have its own SIP session for maintaining state for it.

In various embodiments an application session can be created in order to allow relationships to be specified between various SIP and HTTP clients. In the example illustrated SIP sessions and the HTTP sessions can be associated with the application session such that various data can be exchanged between them. In one embodiment this association can be accomplished by creating appropriate pointers in memory in order to link the various HTTP and SIP session objects. For example the Application session object can be set as the parent of the HTTP sessions and the SIP sessions. The effect of this can be that any subsequent getSession method invocation on the main Application session the HTTP sessions and the SIP sessions can be returned in an iterator.

Thus HTTP and SIP sessions used in a converged application can be accessed programmatically via a common application session object. The SIP server can provide an extended application programming interface API to allow various applications access to the convergence functionality. The SIP server can extend the basic API to provide methods for creating new HTTP sessions from a SIP servlet adding and removing HTTP sessions from the Application session obtaining Application session objects using either a call id or a session id and encoding HTTP URLs with session ids from within a SIP servlet. For example the Application Session can be accessed by a call id that is specified in the SIP protocol or by session id. Furthermore an SIP application can call a createHTTPSession method and create a new HTTP session e.g. for a cellular phone from SIP scope. A setApplicationSession method can set a specified application session as the parent of various HTTP and SIP sessions as described above thereby creating relationships which allow sharing of data between them. As a nonlimiting example the following list is provided to illustrate the various methods 

As illustrated in step an HTTP session can be established for an HTTP client such as a web application running on a computer and in communication with the SIP server. This HTTP session can maintain state information e.g. in the form of a series of Java objects associated with that HTTP client. Other clients can have their own HTTP session associated therewith and maintained on the SIP server and each such HTTP session allows the SIP server to keep track of various HTTP clients accessing the server.

In step an SIP session can be created in order to maintain state information for each SIP client. This SIP session can enable the SIP server to maintain various information associated with each SIP client similarly to an HTTP Session.

In step an application session can be created by the SIP server. This application session can be a new object that contains both an HTTP and a SIP session. In one embodiment the new application session is an Java object created for an application running on the SIP server.

In step the application session can be associated with the HTTP and the SIP session objects in order to allow them to share data back and forth. As an illustration the new application session object can be implemented as a parent object of the HTTP and the SIP session objects which are all associated with each other by pointers in memory. In other embodiments other means of association may be used and the invention is by no means limited to this particular method of association.

In step the converged application can use the application session object in order to support both HTTP and SIP methods of communication. For example an SIP client can create new HTTP sessions end various HTTP sessions as well as perform a myriad of other tasks enabled by the convergence. Thus during a cellular phone call an application running on the SIP server and communicating with the cellular phone can be enabled to start a web session for the cell phone send a URL down to it end the web session or enable various other functionality.

As illustrated a back to back user agent B2BUA having a running SIP server thereon can take the place of being an intermediary between the communications sent between various users. This can be done for purposes of controlling the call and message flow between user agent and user agent and in order to prevent any unwanted behavior and messages e.g. spamming hacking viruses etc. from being sent to the user agent device. It should be noted that although user agent and user agent are illustrated as telephones in the SIP messages can come from various other sources as well. For example the user agent can also be a cell phone a wireless device a laptop an application or any other component that can initiate a SIP type of communication. Similarly while illustrates communications between two user agents there can be more such user agents taking part of a single communication session. For example during a conference call there may be 20 or 30 user agents for all attendees of the conference each of which could send SIP messages to the B2BUA and receive transmissions back therefrom.

Continuing with the illustration a telephone call can be set up between user agent and user agent via the use of the SIP server. The first message sent from user agent to the SIP server on the B2BUA can be an invite message requesting to set up a telephone call with user agent . The invite message can be received by the load balancer of the SIP server and it can be directed to an engine in the engine tier for processing.

In various embodiments the engine tier e.g. an application executing thereon can then perform logic for determining various factors associated with the call such as determining whether user agent is allowed to make the type of call attempted to be initiated determining whether the callee that will be contacted is properly identified as well as any other logic that the server may need to calculate before attempting to set up a telephone call. The engine can then generate state around the fact that a call is being set up including generating the proper long lived and short lived objects associated with the messages as previously discussed. The engine can also determine how to find the target of the call i.e. user agent and the right path to route the message to the callee. As illustrated herein user agent is an originator as well as the terminator of the call and user agent is referred to as the callee.

After receiving the invite message the SIP server can send a 100 trying message back to user agent indicating that it has received the invite message and that it is in the process of handling it. The 100 trying message is part of the SIP protocol definition and can be used by a server in order to stop the user agent from re transmitting the invite request. In cellular phone environments the user agent may have interference which might cause an interruption or loss of various messages. Therefore SIP protocol defines various re transmission schemes in order to handle such mobility and interruptions. Messages such as 100 trying ringing and 200 OK are just some of the examples of messages defined in SIP for handling communication.

Continuing with the illustration the SIP server can then send an invite message to the user agent and can receive back a 180 ringing message indicating that user agent has received the invitation and is now waiting for a user to answer. The SIP server engine tier can then transmit the 180 ringing message back to user agent . When a person finally answers the phone user agent can then send a 200 ok message to the SIP server the server can transmit that message to user agent . The user agent can send an acknowledgement Ack message to the SIP server which can be transmitted along to user agent and at this point a sound transfer conversation can be set up between the two user agents. This sound transfer can be implemented via real transfer protocol RTP on a media server. At the end of the conversation either user agent can choose to terminate the call by sending a Bye message. In this illustration user agent terminates the call by sending a Bye message to the SIP server which sends it off to user agent . After receiving back a 200 ok message from user agent the SIP server can transmit that message to user agent and the conversation can be truly ended.

In various embodiments the vertical lines such as those extending downward from the user agents and the B2BUA can each illustrate and be referred to as a single call leg. The call flow for each call leg may be time sensitive as some messages should be received or sent before others can be initiated. For example as illustrated herein the user agent A may continue to re transmit the initial invite message until it receives a 100 trying message from the B2BUA . As such in some cases certain messages may need to be processed synchronously while others may be allowed to process in parallel.

It should be noted that this illustration of a call may be overly simplified for purposes of clarity. For example there can be various other message transmissions not illustrated such as authentication messages for caller callee determining the type of user agent the SIP server is communicating with and various other handshaking messages that can be exchanged between the SIP server and the user agents. Furthermore message transmitting steps may be added changed interrupted or rearranged in case of interference or failure of various components.

As previously discussed in various embodiments there may be specific sequences of messages exchanged between the SIP server and the user agents for controlling the flow of the call. These sequences can be controlled by various timer objects residing on the SIP server. As a nonlimiting illustration after receiving the invite message from one user agent the SIP server will typically forward that invite to another user agent and wait for a response. If no response is received within a period of time e.g. a number of milliseconds then the invite message may need to be retransmitted to the second user agent because it may be assumed that the user agent did not receive the first message. This type of re transmission can be controlled by the protocol timer objects which may be residing in the state tier. In one embodiment an initial T timer value of 500 milliseconds can control the retransmission interval for the invite request and responses and can also set the value of various other timers.

In various embodiments there are also other timer objects which can be executing on the level of the entire call. For example if after a specified period of time nothing is heard back from either user agent the entire call may be purged from the system. This specified period of time can also be controlled by firing a timer object.

In one embodiment as engine tier servers add new call state data to the state tier state tier instances queue and maintain a complete list of SIP protocol timers and application timers associated with each call. Engine tier servers can periodically poll the partitions of the state tier to determine which timers have expired given the current time. In order to avoid contention on the timer tables multiple engine tier polls to the state tier can be staggered. The engine tier can then process the expired timers using threads in the sip.timer.Default execute queue. Thus the processing of the timer objects can be executed by the engine server as determined by the state tier server. For example the state tier can tell the engine A to execute the first half of all due timer objects e.g. 1 100 and tell engine B to execute the other half e.g. 101 200 . The state tier can also simultaneously push the state onto the engine since the state may need to be employed in executing the timer objects. The engines can then process the timer objects e.g. by sending appropriate messages ending appropriate calls and can later again query poll the state tier for which timers have become due.

When used with the near cache the state data may not need to be pushed onto the engine server since that data may already be available in the cache. Thus when processing timers the timers can be fetched from the state tier however upon the timer firing the engine can fetch the call state using the cache. Further performance optimization can be obtained by changing the selection of tiers to give affinity to the engine holding the cache for a particular call. Thus the timers which are going to be executed can be sent to the appropriate engines which have the proper call state in the cache thereon.

In various embodiments it may be preferable to synchronize system server clocks to a common time source e.g. within a few milliseconds in order achieve maximum performance. For example an engine tier server with a system clock that is significantly faster than other servers may process more expired timers than the other engine tier servers. In some situations this may cause retransmits to begin before their allotted time and thus care may need to be taken to ensure against it.

In various embodiments the SIP Servlet API can provide a timer service to be used by applications. There can be TimerService interface which can be retrieved from as a ServletContext attribute. The TimerService can define a createTimer SipApplicationSession appSession long delay boolean isPersistent java.io.Serializable info method to start an application level timer. The SipApplicationSession can be implicitly associated with the timer. When a timer fires an application defined TimerListener is invoked and ServletTimer object passed up through which the SipApplicationSession can be retrieved which provides the right context of the timer expiry.

In various embodiments the engine tier servers continually access the state tier replicas in order to retrieve and write call state data. In addition the engine tier nodes can also detect when a state tier server has failed or become disconnected. For example in one embodiment when an engine cannot access or write call state data for some reason e.g. the state tier node has failed or become disconnected then the engine can connect to another replica in the partition and retrieve or write data to that replica. The engine can also report that failed replica as being offline. This can be achieved by updating the view of the partition and data tier such that other engines can also be notified about the offline state tier server as they access state data.

Additional failover can also be provided by use of an echo server running on the same machine as the state tier server. The engines can periodically send heartbeat messages to the echo server which can continually send responses to each heartbeat request. If the echo server fails to respond for a specified period of time the engines can assume that the state tier server has become disabled and report that state server as previously described. In this manner even quicker failover detection is provided since the engines can notice failed servers without waiting for the time that access is needed and without relying on the TCP protocol s retransmission timers to diagnose a disconnection.

Failover can also be provided for the engine tier nodes. As previously discussed the engine tier nodes can periodically poll the state tier nodes in order to determine which timer objects it needs to execute. In turn the state tier nodes can notice whenever the engine tier node has failed to poll. If a specified period of time elapses and the engine tier has not polled the state tier the state server can then report that engine as unavailable e.g. having failed or disconnected from the network . In this manner failover can be implemented for both the state tier and the engine tier thereby providing a more reliable and secure cluster for message processing.

In other aspects the invention encompasses in some embodiments computer apparatus computing systems and machine readable media configured to carry out the foregoing methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art.

Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The present invention includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include but is not limited to any type of rotating media including floppy disks optical discs DVD CD ROMs microdrive and magneto optical disks and magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

Stored on any one of the machine readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems and user applications.

Included in the programming software of the general specialized computer or microprocessor are software modules for implementing the teachings of the present invention including but not limited to providing systems and methods for providing the SIP server architecture as discussed herein.

Various embodiments may be implemented using a conventional general purpose or specialized digital computer s and or processor s programmed according to the teachings of the present disclosure as can be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as can be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits and or by interconnecting an appropriate network of conventional component circuits as can be readily apparent to those skilled in the art.

Call logs The ability to view calls made over a given period of time online ability to associate names with phone numbers integrate call log information to other applications such as

Do not disturb The ability to specify policies around receiving calls for example all calls during office hours to be automatically forwarded to a mobile terminal all calls during the night to be directed to voice mail etc.

Locate me This is advanced call forwarding. Rather than have all calls forwarded to a single location e.g. voice mail when the caller is busy Locate me can try multiple terminals in series or in parallel. For example a user may have two office locations a mobile and a pager and it may make sense to forward a call to both office locations first then the pager and then the mobile terminal. Locate me is another example of feature interaction.

Personal conferencing A user could use an existing application e.g. IM client to schedule a Web audio conference to start at a certain time. Since the IM client already has personal profile information the conferencing system sends out the Web conference link information either through IM and or email to the participants. The phone contact information in the profile is used to automatically ring the participants at the time of the conference.

Lifetime number This is the facility where a single virtual number can travel with a customer wherever they live. Even if they move the old number continues to work and reaches them at their new location. This is really the analog of static IP addresses in a phone network.

Speed dial This is the ability to dramatically expand the list of numbers that can be dialed through short key and accelerator combinations. This is another example of a converged application since it s very likely that when a user will set up this information when they work through the call logs on the operator user portal and the updated information needs to be propagated to the network side in real time.

Depending on the service level agreement users are willing to sign up to the quality of media delivered e.g. number of frames per second will vary. The policy engine enables segmenting the customer base by revenue potential and to maximize return on investment made in the network.

A typical example here is the need for applications that have a short lifetime extremely high usage peaks within their lifetime and immediacy. For example voting on American Idol during the show or immediately afterwards has proved to be an extremely popular application.

The final class of applications is one that combines wireline and wireless terminal usage scenarios. An example of an integrated application is the following a mobile terminal user is on a conference call on their way to work. When he reaches his office he enters a special key sequence to transfer the phone call to his office phone. The transfer happens automatically without the user having to dial in the dial in information again. It s important to note hear that this capability be available without the use of any specific support from the hand set a transfer button for example .

Various embodiments include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs microdrives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs and any type of media or device suitable for storing instructions and or information.

Stored one or more of the computer readable medium media the present disclosure includes software for controlling both the hardware of general purpose specialized computer s and or processor s and for enabling the computer s and or processor s to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers user interfaces and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

