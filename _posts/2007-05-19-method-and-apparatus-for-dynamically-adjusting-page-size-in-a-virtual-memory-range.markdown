---

title: Method and apparatus for dynamically adjusting page size in a virtual memory range
abstract: The illustrative embodiments described herein provide a computer implemented method, apparatus, and computer program product for adjusting a page size for a virtual memory range. The process identifies a set of pages in the virtual memory range that reside on a primary memory to form a page occupancy. Each of the set of pages has a first page size. The process changes the first page size to a second page size in response to a comparison of the page occupancy to a threshold value indicating that the first page size should be adjusted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747838&OS=07747838&RS=07747838
owner: International Business Machines Corporation
number: 07747838
owner_city: Armonk
owner_country: US
publication_date: 20070519
---
The present invention relates generally to a data processing system and in particular to a method and system for virtual memory. More particularly the present invention is directed to a computer implemented method apparatus and computer usable program code for adjusting the page size in a virtual memory range.

Many modern operating systems use a page based virtual memory architecture in which virtual memory is mapped to primary memory such as random access memory in units of fixed page size. Primary memory may also be referred to as main memory. Page based virtual memory refers to the process of managing program access to virtual memory pages that do not currently reside in a primary memory. A virtual memory page resides on primary memory when the virtual memory page is translated to primary memory. A virtual memory page is translated to the primary memory when the virtual memory page is referenced by an application.

Some computer architectures and operating systems provide support for multiple page sizes. Larger page sizes can improve the performance of hardware translation mechanisms because they allow hardware translation caches to translate larger amounts of memory. However operating systems that support multiple different page sizes face the problem of choosing the optimal page size for a workload. Current operating systems attempt to solve this problem in a number of different ways.

Some operating systems use the largest supported page size at all times regardless of system conditions. However using the largest page size at all times can waste memory resources by creating a needlessly large memory footprint for a workload. For example an application that declares an array of data that is 64K bytes in size may only use the first 8K bytes of the array. However if an operating system maps the entire 64K byte range with a 64K byte page the range would consume a full 64K bytes of primary memory even though only 8K bytes of the data array is used. Hence memory resources are wasted by this method.

Another current method implemented by some operating systems allows a user or application developer to select a static page size via an application programming interface API or environmental variable. However allowing a user or application developer to select a static page size for an application using an API requires that the application be modified and re compiled in order to use the API. Also when a larger page size is selected using this method applications that expect a smaller page size may fail when performing some page level operations such as setting page protections using the mprotect function. Another disadvantage to this method is that the page selection is static and does not respond to changing system conditions such as whether the primary memory is over committed.

Another currently available method samples an application workload and then makes a page size decision based on the sampled workload data. In this method performance metrics such as translation cache misses are gathered. When the application is re run larger page sizes are used for the selected memory pages based on the performance metrics that were gathered during the previous run of the application. However this method has the disadvantage of having to run an application multiple times to determine an optimal page size to use for the application. Also gathering performance metrics for an application can be an inconvenient and burdensome task. Furthermore this method can only be used to select page sizes for an application at the time the application is started as opposed to dynamically selecting pages sizes during application runtime. Therefore this method represents a static approach to selecting a page size.

The illustrative embodiments described herein provide a computer implemented method apparatus and computer program product for adjusting a page size for a virtual memory range. In one embodiment the process identifies a set of pages in the virtual memory range that reside on a primary memory to form a page occupancy. The set of pages has a first page size. The process changes the first page size to a second page size in response to a comparison of the page occupancy to a threshold value indicating that the first page size should be adjusted.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In this example server and server use a page based virtual memory architecture in which virtual memory is mapped to primary memory such as random access memory in units of fixed page size.

In addition clients and connect to network . Clients and may be for example personal computers or network computers. Clients and may also support a page based virtual memory architecture. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub NB MCH and a south bridge and input output I O controller hub SB ICH . Processing unit main memory and graphics processor are coupled to north bridge and memory controller hub . Processing unit may contain one or more processors and even may be implemented using one or more heterogeneous processor systems. Graphics processor may be coupled to the NB MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB and other ports and PCI PCIe devices are coupled to south bridge and I O controller hub through bus and hard disk drive HDD and CD ROM are coupled to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to south bridge and I O controller hub .

An operating system runs on processing unit and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processing unit . The processes of the illustrative embodiments may be performed by processing unit using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

The hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is generally configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

The illustrative embodiments described herein provide a computer implemented method apparatus and computer program product for adjusting a page size for a virtual memory range. In one embodiment the process identifies a set of pages in the virtual memory range that reside on a primary memory to form a page occupancy. The set of pages is a set of one or more pages in these examples. The set of pages has a first page size. The process changes the first page size to a second page size in response to a comparison of the page occupancy to a threshold value indicating that the first page size should be adjusted.

The second page size is a different size than the first page size. In one embodiment the second page size is larger than the first page size. In another example the second page size is smaller than the first page size.

In one embodiment the page occupancy is compared to a single threshold value to determine whether the first page size should be adjusted. This determination may be made by comparing the page occupancy with the threshold value to determine if the page occupancy is equal to or greater than the threshold value.

In another embodiment multiple threshold values are supported. In such a case the page occupancy is compared to a first threshold value in a set of threshold values to determine if the first page size should be adjusted. After adjusting the first page size to the second page size the process compares the page occupancy associated with the second page size to a second threshold value. The process changes the second page size to a third page size in response to the second comparison of the page occupancy to the second threshold value in the set of threshold values if the comparison indicates that the second page size should be adjusted.

In this example the third page size is a different page size than the first page size and the second page size. This process may continued iteratively to compare the page occupancy to different threshold values in the set of threshold vales until the page size is adjusted to a maximum page size and or until the page size is adjusted to a minimum page size.

Turning now to a block diagram of a system for adjusting the page size in a virtual memory range is depicted in accordance with an illustrative embodiment. Data processing system is a data processing system such as data processing system in .

Data processing system may be implemented in any type of computing device such as server or client in or data processing system in . Data processing system includes operating system . Operating system is a software component on data processing system for managing hardware and software resources on data processing system . Operating system includes virtual memory manager .

Virtual memory manager manages the pages in virtual memory range . Virtual memory range is a set of virtual memory pages that allows non contiguous memory in primary memory to be addressed as if the memory is contiguous. Virtual memory range may have different states depending upon the page size of pages associated with virtual memory range . For example first virtual memory range second virtual memory range and third virtual memory range represent three states of virtual memory range . The transition between these three states will be discussed in further detail below.

Application makes reference to virtual memory range . Application may be any application that utilizes virtual memory such as an executable. Application may also include one or more processes that are in the process of executing. Although application is shown in as part of data processing system application may be located on a remote computing device at remote location such as clients and in . Application may be connected to operating system by a network such as network in .

Although depicts application as referencing one virtual memory range application may reference more than one virtual memory range. For example multiple processes associated with an application may each reference different virtual memory ranges.

In addition one or more memory objects that are associated with application may each reference one or more virtual memory ranges. Non limiting examples of a memory object include a shared memory region process data process stack memory mapped file.

Operating system initiates virtual memory ranges for applications processes and memory objects in a variety of ways. For example operating system may divide a memory object into equal sized ranges based on the largest page size supported by the operating system. Operating system may then sub divide each of the ranges associated with a memory object into pages that are equal to the smallest page size supported by operating system . First virtual memory range is a non limiting example of a virtual memory range that has been initiated based on the smallest page size supported by operating system .

Although depicts virtual memory range as 48 Kbytes in size virtual memory range may be any size supported by operating system . For example in an operating system in which the largest supported page size is 2 Mbytes a virtual memory range of 2 Mbytes may be initiated. The 2 Mbyte virtual memory range may then be further sub divided into smaller page sizes that are supported by the operating system.

When application is initiated virtual memory manager maps virtual memory range as first virtual memory range . Each page in first virtual memory range has a first page size . Specifically virtual memory manager maps first page size which is 4 Kbytes to virtual memory range . Mapping a page size refers to setting selecting defining or otherwise enforcing a particular page size for virtual memory pages in virtual memory range . Although depicts first virtual memory range as having 4 Kbyte pages first virtual memory range may contain pages of any size. For example first virtual memory range may contain pages that are the smallest page size supported by operating system . Furthermore although depicts first virtual memory range as having pages of uniform size each of the pages contained in first virtual memory range may have a different page size.

Each page in virtual memory range that is referenced by application is translated into primary memory . Primary memory may be any memory able to store pages that have been translated from virtual memory range . For example primary memory may be implemented in a memory such as without limitation random access memory or main memory such as main memory in .

As stated above when application is initiated virtual memory manager maps virtual memory range as first virtual memory range . Each page in first virtual memory range that is referenced by application is translated onto primary memory and therefore resides on primary memory . The set of pages in virtual memory range that resides in primary memory is called the page occupancy. Alternatively the page occupancy may be the set of pages in a subset of virtual memory range that reside in primary memory .

The page occupancy may be expressed in a variety of ways. For example the page occupancy may be expressed as a number of pages in a virtual memory range that are resident on a primary memory or a percentage or fraction that indicates the number of pages in a virtual memory range that are resident on primary memory.

Virtual memory manager identifies page occupancy of first virtual memory range . The page occupancy is identified by determining the number of pages in first virtual memory range that are resident on primary memory . The number of pages in first virtual memory range depends on the number of pages in first virtual memory range that have been referenced by application .

Virtual memory manager makes a comparison of page occupancy for first virtual memory range to threshold value . Threshold value is any threshold that indicates that first page size of first virtual memory range should be adjusted. Threshold value also referred to as a page promotion threshold may be expressed as a percentage a fraction a number or any other value or expression that indicates a threshold at which first page size should be adjusted. For example threshold value may be 0.25 50 percent 100 percent or 5.

Threshold value may be determined or identified in a variety of ways. In this embodiment threshold value is a user definable value. Specifically threshold value is received selected indicated or otherwise defined by user . User may indicate or select threshold value using a user interface to input data to data processing system . The user interface may be any type of known or available interface such as without limitation a graphical user interface GUI a menu driven interface a command line interface a touch screen an alphanumeric keyboard a speech recognition system interface or any other type of interface for a user to input data or a selection into data processing system .

In another embodiment threshold value is a pre defined or default threshold value. In this example threshold value is received or retrieved from storage . In this example storage is shown as a local storage device to data processing system . However in another embodiment storage is remote storage device such as storage in . Threshold value may also be a default value that is provided by operating system or other source.

In another illustrative embodiment the threshold value is also indicated at varying granularities. Granularity refers to the number of virtual memory ranges controlled by a threshold value. In one level of granularity a single threshold value may control all virtual memory ranges for all applications on a system. In another level of granularity a different threshold value may be used to control the virtual memory ranges for each individual application. At this level an application s threshold value would apply to all virtual memory ranges associated with the application. At another level of granularity a different threshold value may be used for each individual virtual memory range. At this level different virtual memory ranges of an application may have different threshold values.

In one embodiment all three levels of granularity may be implemented. For example a system wide tunable may be provided to allow the threshold value to be set at a system level. A tunable is a user controlled setting such as a user controlled setting for operating system . The system wide tunable applies to all processes and kernel memory on the system.

User may control threshold value at the system level via a system tunable. The system level tunable may provide a default value for threshold value that triggers a change from first page size to second page size for all processes and kernel memory. The default value for threshold value may be over written via process specific tunables. For example the default value for threshold value may be over written using process environmental variables or process application programming interfaces

The threshold value may also be indicated at the process level. For example the threshold may be set by an environment variable. An application programming interface API may also be provided that allows an application to specify the threshold value for specific memory ranges in a process.

Virtual memory manager may make the comparison of page occupancy for first virtual memory range to threshold value in a variety of different ways. For example virtual memory manager may identify that the page occupancy is equal to the threshold value greater than the threshold value and or less than the threshold value. Further examples of the comparison of page occupancy for first virtual memory range to threshold value will be shown in and below.

In response to making a comparison of page occupancy for first virtual memory range to threshold value that indicates that first page size should be adjusted virtual memory manager changes first page size for the pages in first virtual memory range to second page size . Changing first page size to second page size refers to adjusting re mapping promoting altering modifying re setting or otherwise changing first page size from one size to a different size. Hence virtual memory range changes state from first virtual memory range to second virtual memory range .

In this example second page size is larger than first page size . Although depicts second page size as 8 Kbytes second page size may be any other page size that is supported by operating system .

Virtual memory manager continues to identify the page occupancy of second virtual memory range . In one illustrative embodiment threshold value is a first threshold value in a set of threshold values. The set of threshold values includes at least one threshold value. Virtual memory manager makes a second comparison of page occupancy to a second threshold value in the set of threshold values indicating that the second page size should be adjusted. In response to making the second comparison virtual memory manager changes second page size to a different page size such as third page size .

In this example third page size is larger than second page size . Although depicts third page size as 16 Kbytes third page size may be any other page size that is supported by operating system .

Operating system also communicates with hardware virtual memory translation cache . Hardware virtual memory translation cache translates virtual memory address to physical memory address. A non limiting example of hardware virtual memory translation cache includes a translation lookaside buffer. Also hardware virtual memory translation cache may be implemented as a software component.

Hardware virtual memory translation cache includes a finite number of entries. As each page in virtual memory range is referenced by application a new entry is created in hardware virtual memory translation cache . However because hardware virtual memory translation cache has a finite number of entries existing entries in hardware virtual memory translation cache may have to be deleted to allow space for new entries.

A miss results when data processing system fails to locate a particular page in hardware virtual memory translation cache . When a miss occurs data processing system must locate the missing page in page table . Page table contains entries for all pages referenced in operating system . However locating a page on a page table can require a large amount of computing resources.

By changing the page size to a larger page size as shown above fewer entries are created in hardware virtual memory translation cache . Because fewer entries are created in hardware virtual memory translation cache fewer entries need to be deleted to make room for the new entries. Therefore a miss is less likely to occur when the page size is increased from first page size to second page size or second page size to third page size .

Although depicts changing the page size for a single virtual memory range that is being referenced by a single application the page size may be changed for all virtual memory ranges referenced by an application. In addition the page size may be changed for less than all of the virtual memory ranges associated with an application. Also as described in further detail in the page size may be changed for less than all of the pages in a virtual memory range.

For example application may be associated with more than one process that in turn references different parts of a data region. A portion of a process s data region that is highly referenced and therefore has a high page occupancy may have a larger page size for the virtual memory ranges referenced in that particular portion. Conversely a portion of a process s data region that is sparsely referenced and therefore has a low page occupancy may have a smaller page size for the virtual memory ranges referenced in that particular portion. By distinguishing between different portions of a process s data region the highly referenced portions of a process s memory area may benefit from larger page sizes without wasting memory mapping sparsely referenced portions of a process s memory area.

In order to make the adjustment of pages sizes transparent to application operating system may identify whether the pages that are being increased in size have the same virtual memory state. An example of pages that have the same virtual memory state are pages that have the same page protections. Operating system may also decrease the page size of a virtual memory range if the operating system detects virtual memory operations that function on page boundaries in the virtual memory range such as page protection functions. This ensures that application can continue to do virtual memory operations at a granularity of the minimum supported page size for data processing system .

To provide an example in a data processing system in which 4 Kbyte and 64 Kbyte page sizes are supported an operating system may provide a virtual memory range in a process s data region with 64 Kbyte pages based on the page occupancy for the virtual memory range. However if the associated application then used the mprotect system call to change the protections of a 4 Kbyte portion of the virtual memory range the operating system would change the page size to 4 Kbytes thereby honoring the page protection request at the expected 4 Kbyte granularity. The change to a smaller page size is entirely transparent to the user. Further the operating system may later provide the virtual memory range with larger pages if the page protections for the virtual memory range are changed such that the page protections across all 4 Kbyte pages are uniform.

Furthermore operating system may identify whether primary memory is over committed to provide an additional degree of adaptability to the conditions of data processing system . In response to identifying that primary memory is over committed operating system may prevent virtual memory manager from increasing the page size of virtual memory range . Operating system may also reduce the page sizes in virtual memory range .

In addition virtual memory manager may revert back to a default page size such as first page size upon receiving instructions from application user or some other source. Virtual memory manager may also revert back to a default page size if data processing system virtual memory manager or operating system is shut down or turned off.

With reference now to a block diagram of a system for adjusting the page size in a virtual memory range is depicted in accordance with an illustrative embodiment. Specifically first virtual memory range second virtual memory range and third virtual memory range represent three states of virtual memory range . Alternatively virtual memory range may represent a portion of a virtual memory range.

Similar to virtual memory range in virtual memory range may be implemented in an operating system such as operating system in . Virtual memory range may also be controlled by a virtual memory manager such as virtual memory manager in and subject to threshold values such as threshold value in .

A virtual memory manager may identify the page occupancy of either first virtual memory range or a portion of first virtual memory range . A virtual memory manager makes a comparison of the page occupancy for first virtual memory range or a portion of first virtual memory range to a threshold value. In response to the comparison indicating that first page size should be adjusted a virtual memory manager changes first page size for first page and second page to result in combined page having second page size .

The virtual memory manager may make the comparison of the page occupancy for first virtual memory range or a portion of first virtual memory range to a threshold value in a variety of different ways. In one embodiment the virtual memory manager may identify that the page occupancy for first virtual memory range or a portion of first virtual memory range is equal to a threshold value greater than a threshold value and or less than a threshold value. For example a virtual memory manager may change first page size for first page and second page to second page size of combined page in response to the page occupancy of first portion of first virtual memory range reaching 100 percent. In an alternate example a virtual memory manager may change first page size for first page and second page to second page size of combined page in response to the page occupancy of first virtual memory range reaching 50 percent

The virtual memory manager may then make a second comparison of the page occupancy for first virtual memory range or a portion of first virtual memory range to a second threshold value in a set of threshold values indicating that the pages sizes of combined page third page and fourth page should be adjusted. For example the second comparison made by the virtual memory manager may identify that the page occupancy of second virtual memory range has reached 100 percent.

In response to making the second comparison the virtual memory manager changes the pages size of combined page third page and fourth page to a different page size such as third page size to form second combined page . Although first page size second page size and third page size have pages sizes of 4 8 and 16 Kbytes respectively these pages sizes may be any page size supported by the operating system to which they are associated.

With reference now to a graphical representation of a system for adjusting the page size in a virtual memory range is depicted in accordance with an illustrative embodiment. Specifically graphical representation is a graph of page size as a function of page occupancy .

The set of pages in a virtual memory range such as virtual memory range in which resides in primary memory is called the page occupancy. In this example page occupancy is shown as a range of percentages on the x axis. Specifically page occupancy is shown as a range of zero percent to 100 percent.

Page size is depicted as having two possible values 4 and 64 Kbytes. Page size indicates the page size of pages in a virtual memory range such as virtual memory range in . In this example page size has only two page size values 4 Kbytes and 64 Kbytes. However in accordance with the illustrative embodiments page size may be any page size that is supported by an operating system such as operating system in .

Graphical representation indicates that a virtual memory range contains pages having a first page size of 4 Kbytes when the page occupancy of the virtual memory range is zero percent. The state of the virtual memory range when page occupancy equals zero percent may represent an initial state of the virtual memory range. For example the operating system may have initialized the virtual memory range to have pages of first page size because 4 Kbytes is the smallest page size supported by the operating system.

Each page that is referenced in the virtual memory range resides on a primary memory. The pages of the virtual memory range may be referenced by a process or application such as application in . The page occupancy of the virtual memory range increases as more pages in the virtual memory range are referenced and come to reside on the primary memory.

When the page occupancy of the virtual memory range equals threshold value first page size is changed to second page size . depicts threshold value as 50 percent. However threshold value may be any value between zero percent and 100 percent.

Hence in the example in which a user defined the threshold value a system administrator could set a default value for threshold value at 100 percent. Hence the pages of the affected virtual memory range will only be increased from first page size to second page size when all of the pages in the virtual memory range reside in primary memory. Thereafter when a user runs a performance sensitive operation the user may specify a more aggressive threshold value 50 percent so that the operating system increases first page size to second page size when 50 percent of the pages in the virtual memory range reside in primary memory.

With reference now to a graphical representation of a system for adjusting the page size in a virtual memory range is depicted in accordance with an illustrative embodiment. Specifically graphical representation is a graph of page size as a function of page occupancy .

As the page occupancy increases with each newly referenced page of the virtual memory range page occupancy reaches each of threshold values and . Specifically when page occupancy of the virtual memory range equals first threshold value of 25 percent first page size is changed to second page size for the virtual memory range. When page occupancy of the virtual memory range equals second threshold value of 50 percent second page size is changed to third page size for the virtual memory range. When page occupancy of the virtual memory range equals third threshold value of 75 percent third page size is changed to fourth page size for the virtual memory range. Fourth page size may also be increased to a larger page size when page occupancy equals fourth threshold value of 100 percent.

Although depicts threshold values of 25 percent 50 percent 75 percent and 100 percent the threshold values in a set of threshold values may be any value between zero percent and 100 percent. Additionally the threshold values may be expressed as a fraction or a number.

With reference now to a flowchart illustrating a process for adjusting the page size in a virtual memory range is depicted in accordance with an illustrative embodiment. The process illustrated in may be implemented by an operating system such as operating system in .

The process begins by identifying a page occupancy in a virtual memory range step . The page occupancy is a set of pages in the virtual memory range that reside on the primary memory such as primary memory in . The process identifies a threshold value step .

The process makes a comparison of the page occupancy to the threshold value indicating whether a first page size of the virtual memory range should be adjusted step . If the comparison indicates that the first page size should not be adjusted then the process determines whether the maximum page size has been reached step . An example of a maximum page size is the maximum page size supported by an operating system such as operating system in . If the maximum page size has been reached the process terminates.

Returning to step if the comparison indicates that the first page size should be adjusted the process determines whether the primary memory is over committed step . If the primary memory is over committed then the process terminates.

If the primary memory is not over committed then the process determines whether the pages in the virtual memory range are in the same memory state step . If the process determines that the pages in the virtual memory range are not in the same memory state then the process terminates.

If the process determines that the pages in the virtual memory range are in the same memory state then the process changes the page size of the pages in the virtual memory range from a first page size to a second page size step . The process then determines whether the maximum page size has been reached step . If the maximum page size has not been reached then the process proceeds to step . If the maximum page size has been reached the process terminates.

The flowcharts and block diagrams in the different depicted embodiments illustrate the architecture functionality and operation of some possible implementations of apparatus methods and computer program products. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified function or functions. In some alternative implementations the function or functions noted in the block may occur out of the order noted in the figures. For example in some cases two blocks shown in succession may be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved.

The illustrative embodiments described herein provide a computer implemented method apparatus and computer program product for adjusting a page size for a virtual memory range. In one embodiment the process identifies a set of pages in the virtual memory range that reside on a primary memory to form a page occupancy. Each of the set of pages has a first page size. The process changes the first page size to a second page size in response to a comparison of the page occupancy to a threshold value indicating that the first page size should be adjusted.

In another embodiment the second page size is larger than the first page size. In another example the comparison of the page occupancy to the threshold value indicating that the first page size should be adjusted includes identifying that the page occupancy is equal to or greater than the threshold value. In another embodiment the threshold value is a first threshold value in a set of threshold values. In this embodiment the process changes the second page size to a different page size in response to a second comparison of the page occupancy to a second threshold value in the set of threshold values indicating that the second page size should be adjusted.

In one embodiment the process for adjusting pages sizes in virtual memory is performed dynamically during runtime. Pages sizes are adjusted dynamically by adjusting page sizes in virtual memory ranges based on system conditions such as the conditions of data processing system of . The operating system selects an optimal page size while an application is executing. Hence an application does not need to be executed multiple times for a page size to be selected and the page size may be adjusted while the application is running.

In addition dynamically adjusting a page size for a virtual memory range may be implemented to adapt to system conditions. If a system s primary memory is over committed page size may be either reduced or not changed at all. By reducing the page sizes the operating system can minimize the amount of input output due to paging because paging will be performed in smaller units.

Moreover in one embodiment page sizes in virtual memory are adjusted automatically without user intervention. In other words no user input or application modification such as re compilation is necessary. The operating system automatically changes the page size of virtual memory range to a larger page size based on application memory reference patterns. In addition there are no binary compatibility impacts. The use of larger page sizes is transparent to an application and will have no functional impact on the application.

The illustrative embodiments work at the granularity of the pages sizes. Thus a process s memory range may include any combination of different sizes. Hence more granularity is provided than that provided by environmental variables or applications providing page size selection at the memory object level. In this manner a user can control the aggressiveness of page promotion by allowing a user to indicate threshold values. The user may provide the operating system with input as to how to weigh an increased memory footprint against increased performance. The input may be implemented at a fine granularity such as the process level.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

Further a computer storage medium may contain or store a computer readable program code such that when the computer readable program code is executed on a computer the execution of this computer readable program code causes the computer to transmit another computer readable program code over a communications link. This communications link may use a medium that is for example without limitation physical or wireless.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

