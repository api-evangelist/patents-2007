---

title: Scripting bridge
abstract: The present invention provides a straightforward model for controlling scriptable applications that can result in code that is significantly faster and more efficient than prior art methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08387007&OS=08387007&RS=08387007
owner: Apple Inc.
number: 08387007
owner_city: Cupertino
owner_country: US
publication_date: 20070608
---
The present invention relates to code translation and more particularly to methods and systems for accessing a scriptable application with standard method calls.

Scriptable applications provide an easy way for software developers to customize the operation of software applications. A scriptable application is an application whose operation can be automated using a script. For example many applications written for the Mac OS operating system are capable of responding to script based commands written in AppleScript . AppleScript talks to applications using the well known Apple Event Interprocess Messaging Protocol. Apple events are commonly used by an application to send and receive information from other applications.

In some cases developers wish to control the operation of scriptable applications from an application that is written in Objective C or some other compiled or interpreted language. Some application programming environments provide tools for executing scripts to control scriptable applications. For example the Cocoa application programming environment provides an NSAppleScript class that provides a mechanism for running an AppleScript script from within a Cocoa application. However in order to use NSAppleScript a developer must write the AppleScript script and then invoke the NSAppleScript class to execute the script. This technique has several disadvantages 1 it can be burdensome 2 it requires the developer to be familiar with AppleScript and the target application s Apple events model and 3 it results in slow inefficient code.

Alternatively a developer can use NSAppleEventDescriptor to manually send and receive Apple events from within the Objective C code. This class allows developers to construct Apple events or extract information from them. Again such a technique can be burdensome and inefficient.

What is needed therefore is a technique for allowing software developers to control script based applications from within a compiled object oriented programming environment such as Objective C and or from within other compiled or interpreted languages. What is further needed is a technique that does not overly burden the developer with a requirement to write script specific code manage individual events. What is further needed is a technique that results in efficient code and avoids or minimizes the disadvantages of prior art techniques.

The present invention referred to herein as a scripting bridge allows a developer to automatically build glue classes to access a scriptable application with standard method calls written in a language such as Objective C. The Objective C code sends properly formed Apple events automatically or events according to some other event protocol so that the developer is not required to have any knowledge of the scripting language of the target application. For example using the techniques of the present invention a developer could get the name of the current iTunes track with the following line of code 

In one embodiment the present invention uses native Cocoa data types such as NSString and NSArray so as to reduce the amount of code required and to improve speed.

The present invention provides a straightforward model for controlling scriptable applications that can result in code that is significantly faster and more efficient than prior art methods. Furthermore the scripting bridge of the present invention allows a developer to control scriptable applications without having detailed knowledge of the target application s scripting language.

The present invention allows the developer to use standard memory management within the Cocoa application programming environment without having to manually allocate and free space for Apple events or other script based resources. The present invention also requires less code than using NSAppleEventDescriptor or direct calls. The present invention also is able to check for syntax errors at compile time by comparing elements of an automatically generated header against the original definition and flagging any errors.

The present invention can be used for example as a framework for facilitating direct control of one Cocoa application from another. The invention further allows other applications to control scriptable applications. For example code written in Ruby via RubyCocoa or Python via PyObjC can control scriptable applications using the present invention giving those languages the same advantages enjoyed by AppleScript .

In this manner the present invention provides a mechanism for controlling scriptable applications in a seamless manner that can integrate with existing Objective C code and or with compiled or interpreted code written in other languages.

The present invention allows a developer to automatically build glue classes to access a scriptable application with standard method calls written in a language such as Objective C. The Objective C code sends properly formed Apple events automatically or events according to some other event protocol so that the developer is not required to have any knowledge of the scripting language of the target application.

In one embodiment the present invention uses a scripting bridge which is a system framework that can be included with an operating system such as Mac OS X. In one embodiment the following classes are defined 

One skilled in the art will recognize that the particular framework structure classes and arrangement thereof are merely exemplary and that many variations are possible without departing from the essential characteristics of the present invention.

Using the techniques of the present invention the developer can avoid dealing with most of these classes directly instead working with subclasses in the generated glue classes. For example for an Objective C application that is intended to control the iTunes application the developer might use classes such as iTunesApplication which inherits from SBApplication and iTunesTrack which inherits from SBObject . In one embodiment these application specific subclasses are not included in the scripting bridge framework itself but are created at run time.

Referring now to there is shown a flowchart depicting a method for implementing the present invention according to one embodiment. Referring also to there is shown a block diagram depicting an architecture for implementing the present invention according to one embodiment. Application code is the application being written by the developer for example in Objective C or another compiled or interpreted language. Target application is the scriptable application that the developer wishes to control. In one embodiment scripting bridge is a software module that implements the functionality of the present invention.

Scripting bridge generates glue classes for invoking scripts to control target application . In one embodiment such glue classes are generated by obtaining scripting interface or sdef scripting definition from dictionary of target application . Dictionary specifies the terms that are understood by target application . Referring now briefly to there is shown an example of dictionary for the iTunes application. Category list provides several categories of terms. Term list indicates dictionary terms that are available within the selected category. Definition provides explanatory text for a selected item in list .

Once scripting bridge has generated its glue classes it provides the generated glue classes to application code . These dynamically generated glue classes collectively referred to as glue code are used to facilitate access to scripting commands from directly within application code . Thus based on dictionary scripting bridge creates and provides dynamically generated glue classes that are included in the code environment such as Objective C in which the developer is working.

Once the generated glue classes have been provided application code can specify an operation to be performed by target application by issuing a method call in Objective C or whatever language is being used for application code . Based on the method call scripting bridge issues an Apple event to target application which interprets and executes the specified function as it would any scripted operation.

The generated classes include Objective C classes that can be used to control the target scriptable application. In one embodiment the classes include the full set of code for controlling the target application. In another embodiment the code is optimized so that only that code that is needed is generated and included.

In one embodiment as described above the glue classes are generated dynamically and included at run time this can result in a smaller more efficient result. Run time generation of the glue classes also facilitates the use of the present invention while coding in a third language such as Python or Ruby. In such a situation another bridge translates code from Python or Ruby into an Objective C class and the scripting bridge then provides the translation from Objective C to the scriptable application. Furthermore run time generation avoids the need to include extra code for the scripting bridge within the application being coded. Rather the developer need only invoke an Objective C method that is already present in order to invoke the scripting bridge and thereby exercise control over the target application.

Alternatively the glue classes are generated in advance for example at build time. This removes the need to generate glue classes at run time. Referring now to there is shown an alternative architecture for build time generation of glue classes. The architecture of operates substantially as described above with the addition of scripting definition processor sdp . sdp is an optional component that can create statically generated glue classes at build time so that there is no need for classes to be generated at run time. In one embodiment the sdp generated files are attached to application code since they effectively are part of the application code.

In addition sdp can generate one or more header files at build time. These header files or .h files include declarations for statically generated glue classes header files can be included in application code so as to properly declare the generated classes before they appear in the code. Header files are optional because in most implementations the Objective C compiler can assume declarations on the fly if they are not present. In such an embodiment it may be useful to provide a header file for inclusion in code files so that relevant methods are properly declared before they appear in the code.

In one embodiment header file is useful for checking for syntax errors at compile time. The generated header file for the target application specifies the API application programming interface for that application. The compiler can then use that header to check any uses of the API against the original definition and flag any errors.

Referring again to where an example of dictionary for the iTunes application is shown the following is an example of a header file that scripting definition processor might generate based on the iTunes dictionary 

In one embodiment this header file would be generated in response to the developer invoking sdef scripting definition also referred to as scripting interface and sdp scripting definition processor tools in a command such as 

This command line uses sdef to get the scripting definition from the application. If the application does not contain an actual sdef but does contain scripting information in another format such as aete or Cocoa script suite the tool translates that information into the sdef format. The command pipes the output of the sdef tool to sdp scripting definition processor to generate the corresponding header file.

This command produces header file iTunes.h in the current directory the header contains declarations for the iTunes classes. The developer can then include this header file in the project being written. The developer links the project with a framework specifically associated with scripting bridge .

Generating the header does not cause any implementations for target application classes to be generated. Rather scripting bridge generates these instances of the classes on the fly i.e. at run time.

To start communicating with the target application iTunes in this example the developer tells scripting bridge to create the application class 

This locates the target application given its bundle identifier reads its scripting dictionary and creates Objective C classes for all the classes defined there. Class and command definitions in the sdef are mapped to class and method definitions in Objective C. Given those definitions scripting bridge uses calls defined by the Objective C runtime system to synthesize actual implementations. Then the developer creates an instance 

This locates target application using the same method used to create the class in this case by bundle identifier.

Although the above description is set forth in the context of iTunes as the target application one skilled in the art will recognize that similar techniques can be used for any application that has a dictionary .

In one embodiment when sdp generates header file it automatically adds a comment to each method declaration taken from the corresponding term in the target application dictionary . For example in a header file generated for a Finder application the following declaration might appear for the FinderApplication class 

In one embodiment application specific classes return data in a form that is useful to the developer. For example the Finder s startupDisk method returns a FinderDisk object and iTunes currentTrack method returns an iTunesTrack object. When the developer requests that an object provide its name using the name method the result is returned as an instance of NSString. Similarly the developer can get and set properties of an application in the same way he or she would perform such operations for instance variables inside application code for example using methods such as ignoresPrivileges and setIgnoresPrivileges. The present invention provides this consistency and ease of operation so as to improve the process of incorporating glue classes into existing projects.

In one embodiment the scripting bridge of the present invention uses a technique called lazy evaluation in order to further increase efficiency. Because sending Apple events can be expensive the scripting bridge of the present invention is configured so that it avoids sending Apple events to target application until absolutely necessary to perform the desired function.

In one embodiment lazy evaluation is implemented by the use of references. When an object is requested from target application scripting bridge receives a reference to the object. Scripting bridge does not evaluate the reference until application code indicates that some concrete data from the requested object is needed.

For example scripting bridge does not send an Apple event when application code requests the first disk of the Finder but it does send an event when application code requests the name of the first disk of the Finder. The following code provides an illustrative example 

The developer can override this behavior and force immediate evaluation of an object by using the SBObject get method.

Lazy evaluation has the ability to dramatically reduce the number of Apple events that need to be sent and thereby allow the application to run significantly faster. In one embodiment an optimized array handling method is provided in SBElementArray arrayByApplyingSelector. This method sends a single Apple event to handle the array so as to further improve efficiency when performing functions on arrays.

In one embodiment if target application is not open when scripting bridge tries to send it an Apple event scripting bridge automatically launches target application . Since this may result in undesired behavior a check may be made to determine whether target application is running before scripting bridge tries to communicate with it.

In one embodiment dynamic method generation is used to create singleton methods that run without any branch logic so as to improve speed and efficiency. Singleton objects or first invocation initializes are a coding pattern wherein an object type has exactly one shared instance. Conventionally singleton objects are generated by creating a class with a method that creates a new instance of the class if one does not exist. If an instance already exists the method returns a reference to that object. Accordingly conventional techniques for singleton methods involve the use of conditional logic and a global variable as follows 

In this example if s does not yet exist it is allocated and stored in a global variable the global variable is then returned. This conditional logic makes singleton object generation somewhat inefficient according to prior art techniques. Use of a global variable can also add inefficiency.

Real world modern implementations often have a significantly more complex initialization pattern and also require the use of some kind of exclusion protocol such as locks to support threaded runtime environments. Thus the following structure might be used 

Alternatively some complex initialization infrastructure might be invoked prior to normal program operation. Such operations are often unreliable.

In one embodiment the present invention provides a solution by implementing such a method with full locking exception handling and any other correctness verifying measures and with one additional step wherein the method that retrieves the singleton is replaced with a new implementation that carries the singleton as a part of the implementation as follows 

During initialization any other callers will block on the lock operation until initialization is done. Once the lock is unlocked any blocked callers will short circuit out on the if s statement unlocking in the . . . finally . . . block but all future callers will execute the faster replacement implementation. The replaced code is simply 

The first time through the method allocates s and creates a new method implementation to return that object. It then replaces itself with that new method. This new method works without any conditional logic at all. This saves time and also avoids the use of the global variable access. It also allows the creation of the singleton to be fully thread safe and completely protected. A further advantage is that the retrieval of the singleton after first execution does not require any locks exception handling or concurrency constructs.

The present invention has been described in particular detail with respect to one possible embodiment. Those of skill in the art will appreciate that the invention may be practiced in other embodiments. First the particular naming of the components capitalization of terms the attributes data structures or any other programming or structural aspect is not mandatory or significant and the mechanisms that implement the invention or its features may have different names formats or protocols. Further the system may be implemented via a combination of hardware and software as described or entirely in hardware elements or entirely in software elements. Also the particular division of functionality between the various system components described herein is merely exemplary and not mandatory functions performed by a single system component may instead be performed by multiple components and functions performed by multiple components may instead be performed by a single component.

Reference herein to one embodiment an embodiment or to one or more embodiments means that a particular feature structure or characteristic described in connection with the embodiments is included in at least one embodiment of the invention. Further it is noted that instances of the phrase in one embodiment herein are not necessarily all referring to the same embodiment.

Some portions of the above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps instructions leading to a de sired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical magnetic or optical signals capable of being stored transferred combined compared and otherwise manipulated. It is convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. Furthermore it is also convenient at times to refer to certain arrangements of steps requiring physical manipulations of physical quantities as modules or code devices without loss of generality.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or displaying or determining or the like refer to the action and processes of a computer system or similar electronic computing module and or device that manipulates and transforms data represented as physical electronic quantities within the computer system memories or registers or other such information storage transmission or display devices.

Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention can be embodied in software firmware or hardware and when embodied in software can be downloaded to reside on and be operated from different platforms used by a variety of operating systems.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards application specific integrated circuits ASICs or any type of media suitable for storing electronic instructions and each coupled to a computer system bus. Further the computers referred to herein may include a single processor or may be architectures employing multiple processor designs for increased computing capability.

The algorithms and displays presented herein are not inherently related to any particular computer virtualized system or other apparatus. Various general purpose systems may also be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will be apparent from the description above. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein and any references above to specific languages are provided for disclosure of enablement and best mode of the present invention.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of the above description will appreciate that other embodiments may be devised which do not depart from the scope of the present invention as described herein. In addition it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly the disclosure of the present invention is intended to be illustrative but not limiting of the scope of the invention which is set forth in the claims.

