---

title: Method for pruning objects in a service registry and repository
abstract: Embodiments of the invention relate to a service registry and repository system, method and computer program product for accessing objects in an object repository. There is provided a method of managing an object database for objects that includes receiving an object query; querying the object database using the object query; receiving a hierarchical collection of objects including a root object; and returning only those objects that are within a specific depth of the root object and that do not represent user-defined relationships. The returning step maps the objects from a proprietary object format into a standard object format and optionally the standard object format is the Service Definition Object format (SDO).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07844612&OS=07844612&RS=07844612
owner: International Business Machines Corporation
number: 07844612
owner_city: Armonk
owner_country: US
publication_date: 20070823
---
The present application is related to a concurrently filed copending U.S. patent application Ser. No. 11 844 322 entitled SYSTEM AND PROGRAM PRODUCTS FOR PRUNING OBJECTS IN A SERVICE REGISTRY AND REPOSITORY .

This invention relates to a service registry and repository system and method. In particular this invention relates to a service registry and repository system and method for pruning objects in an object repository.

A service registry and repository registers and stores service descriptions as part of a service oriented architecture SOA promising business agility and resilience through reuse loose coupling flexibility interoperability integration and governance. These promises are addressed by separating service descriptions from their implementations and using the service descriptions across the life cycle of the service. Standards based service metadata artefacts such as Web Service Definition Language WSDL XML schema policy or Service Component Architecture SCA documents capture the technical details of what a service can do how it can be invoked or what it expects other services to do. Semantic annotations and other metadata can be associated with these artefacts to offer insight to potential users of the service on how and when it can be used and what purposes it serves.

Service descriptions are used by analysts architects and developers during a Development Phase of the SOA life cycle to locate services to reuse and to evaluate the impact of changes to service configurations. Service descriptions are used by deployers in a Change and Release Phase and by administrators in a Runtime Integration Phase. It is used in the Operation Phase of the life cycle to support policy enforcement required by Service Level Agreements SLAs and to present a more comprehensive view of the managed service environment. Service descriptions are used by various technologies for different purposes and needs to be persisted in a reliable and accessible format. Service descriptions are variously described as metadata objects documents entities and artefacts.

A service registry and repository is an application that persists service descriptions as a data objects in a relational database system. Typically a user uses a graphical tool to design classes that represent the service descriptions that need to be persisted. Java objects that represent the classes are compiled into binary files. Database schema is generated that can represent the objects and is installed into a relational database IBM DB2 Oracle etc . The objects are registered with service register and stored within the repository. The objects are persisted and retrieved directly from the object database. IBM and DB2 are registered trademarks or trademarks of International Business Machines Corporation in the United States and or other countries. Oracle is a registered trademark of Oracle Corporation.

One type of service registry and repository stores the descriptions as objects within the repository and queries the repository using an object query language. An example of this type of service registry is IBM WebSphere Registry and Repository WSRR uses an IBM object query language called XMeta Query Language XMQL for internal communication with the repository. WebSphere is a registered trademark or trademark of International Business Machines Corporation in the United States and or other countries.

XMeta Query Language XMQL is a declarative object query language designed for the efficient retrieval of objects stored in a repository such as WSRR. XMQL allows the use of the dot operator for accessing predefined properties on a given modelled object type. XMQL also allows a dereferencing operator for traversing relationships between any two given object types. The XMQL query expression is defined in the context of a given package registered with WSRR. XMQL has a SELECT FROM WHERE type of structure and returns a set of objects.

The SELECT FROM WHERE clause is the basic structure of an XMQL query. It allows the user to specify which class es should be searched to retrieve information and which parts of the information to be included in the results set. It also allows the user to specify conditions to filter out of the results set the instances that do not meet the conditions.

The SELECT clause defines the structure of the query result which can be either a collection of objects or a collection of rows with the selected attribute values. The entries in the select part of a query constitute the so called projection list of the query in that they define what is projected out of the repository and into the result set entries result objects or result rows of atomic values depending on the number and type of the entries in the projection list . When retrieved the type of the query result is a List of instances of objects or a List of arrays result rows of instances of objects result row columns .

The FROM clause introduces the primary class extent against which the query runs. A class extent is the set of all instances of a given class including instances of its sub classes . A variable needs to be declared to iterate over the instances of the class being queried the so called primary iteration variable. That variable can be used in the other parts of the query and denotes an instance of the class extent being iterated upon. The FROM clause also allows the introduction of other variables to iterate over instances that can be reached through navigation via multiplicity many references from previously introduced iteration variables. These extra variables are called secondary iteration variables. As explained above unqualified class names in a query expression are resolved relative to that package the so called query context package.

The WHERE clause introduces a predicate that filters the instances of the class being queried. This is an optional sub clause.

Example 1 SELECT e FROM e in Employee WHERE e.salary 200000. This query returns the instance s of class Employee including any of its sub classes whose salary attribute value is greater than 200000. The FROM clause gives the class whose extent the query will filter class Employee and introduces the variable e to be used to iterate over that class extent. The extent of class Employee includes all instances of all of its direct and indirect sub classes. The SELECT clause defines the type of the entities returned in the result collection to be instances of class Employee or any of its sub classes. In this example the class being queried is an abstract class and the result collection will contain instances of sub classes FullTimeEmployee and PartTimeEmployee. The WHERE clause filters the instances being iterated upon so that only those for which the value of attribute salary is greater than 200000 are returned in the result.

Example 2. SELECT e FROM e in Employee. This example retrieves all the instances of class Employee. It also illustrates the fact that the WHERE clause is optional.

Example 3. SELECT e FROM e in AnotherPackage Employee. In this example the package in the query expression takes precedence over the context package in case a class with the same name is defined in both. If the class defined in the query context package or if it is defined in a package it depends on and there is no name conflict i.e. different classes with the same name defined in different packages depended upon then there is no need to qualify the class name in the query expression.

Patent publication U.S. Pat. No. 7 028 028 Enosys Markets Inc. discloses a system for querying markup language data stored in a relational database according to markup language schema. The system translates from the input XML query language to apply corresponding query instructions to the underlying relational database using a relational database query language such as SQL.

Although a relational database query language is a useful way to access objects in a repository it does not return complex collection of objects as an object query language can. As such an object query language is a powerful way to access objects in a repository. Furthermore object query languages provide additional features such as object references and dot notation where SQL does not. However one problem for users accessing objects in the repository is that a specialized object query language can be counter intuitive if one is used to a different query language such as a path expression query language. For instance XPath is a path expression language that is more suitable for accessing content within an XML instance document than for accessing objects in an object database but many users are familiar with it and prefer to use it to locate objects.

One problem with returning a complex collection of objects is that not all the objects in the collection are required by the user.

Another problem is that a service registry and repository does not want to expose the mechanism by which it stores service entities and relationships.

According to one aspect of the invention there is provided a method of managing an object database for objects comprising receiving an database path query translating the database path query into an object query querying the object database using the object query receiving a hierarchical collection of objects including a root object and returning only those objects that are within a specific depth of the root object where intermediate objects used by the underlying persistence mechanism have been replaced with direct relationships between entities. In the preferred embodiment intermediate objects represent user defined relationships between entities.

According to another aspect of the invention there is provided a method of managing an object database for objects comprising receiving an object query querying the object database using the object query receiving a hierarchical collection of objects including a root object and returning only those objects that are within a specific depth of the root object. The solution therefore returns only a subset of the complex collection of objects as specified by the user or otherwise.

Preferably the returning step returns only objects that do not represent user defined relationships. And more preferably the returning step maps the objects from a proprietary object format into a standard object format and optionally the standard object format is the Service Definition Object format SDO . Using objects to represent user defined relationships is an internal mechanism for a service registry and repositiory. Removing the objects allows the service registry and repository not to expose the mechanism by which it stores service relationships.

IBM WebSphere Service Registry and Repository is a master metadata repository for service definitions. Such service definitions include traditional internet services that implement WSDL and XSD interfaces with SOAP HTTP simple object access protocol and hypertext transfer protocol as well as a broad range of SOA services that can be described using WSDL XSD and policy decorations. The service definitions might use a range of protocols and be implemented according to a variety of programming models. WSDL stands for web service definition language. XSD stands for XML schema definition language where XML is extensible mark up language. SOAP and HTTP stand for simple object access protocol and hypertext transfer protocol respectively. SOA stands for Service Oriented Architecture.

WebSphere Service Registry and Repository 10 WSRR is a Java 2 Platform Enterprise Edition J2EE application that runs on a WebSphere Application Server and uses a relational database as a backing store for service metadata persistence. As such it takes advantage of the role based access control provided by WebSphere Application Server so that role based views and access control can be turned on when WSRR is deployed as an enterprise wide application. Referring to the top level components of WSRR comprise a registry and repository core a governance component an administration interface a user interface a programming interface . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

The registry and repository core offers both registry function and repository function for service metadata. The repository function allows users to store manage and query service metadata artifacts holding service descriptions WSDL XSD WS Policy SCDL or XML documents . It not only takes good care of the documents containing service metadata but it also provides a fine grained representation of the content of those documents for example ports and portTypes in WSDL documents . The registry function makes provision for decorating registered service declarations and elements of the derived content models with user defined properties relationships and classifiers. The registry and repository core provides a rich query interface that makes use of those decorations when a search is performed to find entities such as a service endpoint or service interface.

Whenever a change to registry or repository content is detected by registry and repository core it invokes all validation and notification function that are registered in the validation register and the notification register . Both kinds of function are considered extension mechanisms that can be used to customize how WSRR reacts to changes. Validation function can be written and registered that the registry and repository core will execute when changes are made to the content. For example a validation function that checks for completeness of a service definition. Notification functions can be written and registered to communicate changes to the content of the repository. The registry and repository core comes with an out of the box JMS notification plug in. The registry and repository core has a subscription capability that allows your users to register their interest in consuming notifications.

Through the governance component WSRR supports a rich set of extensible governance functions including the ability to model service life cycle model for governed entities define valid transitions between service states write and plug in validators to guard the transitions between states and designate notification actions to be taken as result of the transition. It also provides interfaces to analyze the impact of changes to WSRR content and provides auditing of such changes.

The classification component allows service descriptions and parts of service definitions to be annotated with corporate vocabulary and to capture the governance state. WSRR classification systems are captured in web ontology language OWL documents that are loaded into Registry and Repository using the administrative interface. WSRR entities can be classified with values from these classification systems which allows classification based queries to be performed and access restricted based on classification.

The access controller supports a fine grained access control model that allows for the definition of which user roles can perform specific types of actions on corresponding artifacts. Visibility of services can be restricted by business area and user roles can be restricted from transitioning services to certain life cycle states. This is in addition to the role based access control provided by the WebSphere Application Server.

The administration interface support the import and export of WSRR content for exchange with other WSRR repositories and provide a JMX based API for Registry and Repository configuration and basic administration. These support interactions with the Access Controller and with the Classifier

User interface comprises a web interface and an eclipse plugin interface to enable interaction with WSRR. A servlet based web user interface UI supports is the main way for users representing different roles to interact with WSRR. The Web interface supports all user roles offering lookup browse retrieve publish and annotate capabilities as well as governance activities such as import export and impact analysis. A subset of this user interface is offered as an Eclipse plug in to meet developer needs and analyst users needs that use Eclipse based tooling. The Eclipse plug in is used primarily for lookup browse retrieve and publish capabilities. The Web based user interface can also be used for performing service metadata management and governance.

Programming interface uses Java and SOAP APIs to interact programmatically with registry and repository core . These APIs provide basic CRUD operations governance operations and a flexible query capability based on XPath. The SOAP API is used to communicate content using XML data structures. The Java API is used to communicate content using service data object SDO graphs. Using either the user interface or the programming interface documents and concepts managed by WSRR can be created retrieved updated and deleted. However logical entities in the logical model cannot be modified and these can only be changed by updating a document that contains the logical entity. Concepts can be created retrieved and deleted.

WSRR supports two application programming interfaces APIs that can be used to interact with the registry and repository core the governance component and the administration interface a Java based API and a SOAP based API. Both APIs support publishing creating and updating service metadata artifacts and metadata associated with those artifacts retrieving service metadata artifacts deleting the artifacts and their metadata and querying the content of the Registry and Repository. The programming APIs use Service Data Objects SDO to capture the data graphs inherent in the content model allowing access to physical documents logical parts of the physical documents and concepts. The SOAP API uses XML documents to similarly represent Service Data Objects to communicate content structures in both the physical and logical model.

In response to requests from customers and partners an number of organisation including IBM are collaborating on specifications for building systems that use a Service Oriented Architecture SOA which aim to provide developers with simpler and more powerful ways of constructing applications based on SOA. One of the main building blocks of SOA are Service Data Objects. Service Data Objects SDO are designed to simplify and unify the way in which applications handle data. Using SDO application programmers can uniformly access and manipulate data from heterogeneous data sources including relational databases XML data sources Web services and enterprise information systems.

SDO is based on the concept of disconnected data graphs. A data graph is a collection of tree structured or graph structured data objects. Under the disconnected data graphs architecture a client retrieves a data graph from a data source mutates the data graph and can then apply the data graph changes back to the data source. The task of connecting applications to data sources is performed by data mediator services. Client applications query a data mediator service and get a data graph in response. Client applications send an updated data graph to a data mediator service to have the updates applied to the original data source. This architecture allows applications to deal principally with data graphs and data objects. SDO enables both a static or strongly typed programming model and a dynamic or loosely typed programming model. This enables a simple programming model without sacrificing the dynamic model needed by tools and frameworks. SDO also provides a metadata API which allows applications tools and frameworks to introspect the data model for a data graph. The SDO metadata API unifies data source specific metadata APIs to enable applications to handle data from heterogeneous data sources in a uniform way. SDO is intended to be language neutral and to be available in a range of programming languages.

XPath expressions are used to perform searches with the query interface for coarse and fine grained queries. Queries can be performed using semantic annotations properties and all or parts of physical service metadata artifacts. Fragments of metadata be returned such as endpoints all metadata be returned and both metadata and documents be returned. In addition to free form XPath based queries a set of pre canned queries are available to use to address common paths through the WSRR content model. An XPath expression identifies the type of managed entity to be returned and filters that capture the managed elements related to the desired object. Extensions are provided to include classification annotations in a query. For example if the search is for all WSDLServices that have a port that refers to a binding that refers to a portType named StockQuotePortType the following query expression would be used WSRR WSDLService port binding portType name StockQuotePortType 

The governance component allows analysis of the impact of changes to specific artefacts through an API. A set of predefined impact queries is available to help you navigate through the registry and repository content according to popular patterns such as which WSDL files import or use this XSD. In addition one can use Governance operations to request life cycle transitions for a governed entity as well as the configuration of e mail notifications for users interested in specific content changes.

The administration interface provides a JMX based administration API that supports basic configuration and loading and managing of metadata in support of repository content such as classification and life cycle management. The administration API allows you to load definitions of state machines to be used to model the life cycle of governed entities and to load classification systems described in OWL. In addition the administration API supports registration of plug ins for validation functions or additional notification functions.

Referring to an informal description of the WSRR content model is provided. Broadly the content model has entities representing service description entities and service description metadata . All artifacts have a WSRR assigned URI a name and a description. Examples of each type of artefact are shown within the boxes in but are not necessarily referred to in the description.

Service Description Entities stored and managed in Registry and Repository comprise physical documents logical derivations and concepts . Physical Documents are XML documents that are known as service metadata artefacts. Logical derivations are the finer grained pieces of content that result when some types of physical document are shredded as they are loaded into Registry and Repository. Concepts are generic entities that are usually typed and represent anything that is not represented by a document in Registry and Repository. All three types of service description entities can be use in queries have service annotations applied and have relationships established from and to them.

The most elemental building blocks for the WSRR are the physical documents such as XSD WSDL SCDL or WS Policy documents. In addition any XML service metadata artifact type or binary document can be stored in WSRR and receive the benefits of broader visibility reuse management and governance. The coarse grained model made up from registry objects that represents those documents is referred to as the physical model. Documents are versionable objects in the WSRR content model which means that in addition to a URI name and description they also have a version property.

For some of the physical document types WSRR derives logical objects and stores them in logical derivations . For instance WSRR can shred a document upon receipt into a set of logical objects to enable users to explore WSRR content beyond the boundaries of the files stored. Logical objects are not versionable. For some physical document types WSRR defines a predefined properties and detects relationships to other physical documents. An XSD document for example has a target Namespace property and the relationships with other imported XSD documents other redefined XSD documents and other included XSD documents. When an entry for a certain physical document is created in WSRR it is introspected for relationships to other artifacts. If not already represented in WSRR a related artefact is also added and in either case the relationship between the artifacts is recorded.

The set of logical derivations comprises the logical model of WSRR. The logical model has entities such as portType port and message related to WSDL files and complexType or simpleType related to XSD documents. Elements of the logical model have properties and relationships reflecting a subset of their characteristics as defined in the underlying document. For example a WSDLService element has a namespace property and a relationship to the ports it contains. It is important to note that all individual results of document shredding are aggregated into one logical model that represents not only the content of individual documents but also relationships between content in different documents.

WSRR stores other types of service metadata using the XML Document a generic document type. Documents of type XMLDocument are not decomposed into the logical model.

WSRR uses a concept to represent anything that does not have a physical document. Concepts are used to represent a reference to content in some other metadata repository such as a portlet in a portlet catalogue or an asset in an asset repository. It can also be used to group physical artifacts together to govern them as a unit for example concepts can be versioned.

In addition to content directly related to entities WSRR supports a number of metadata types that are used to describe entities . These metadata types are referred to as service description metadata . WSRR supports three types of service semantic metadata types properties relationships and classifications . All three types describe physical model entities logical model entities and or concepts. For example service description metadata can be used to associate a property businessValue with a physical model entity representing a WSDL file. It might also be used to define a new relationship makesUseOf between an entity in the logical model representing a portType and an entity in the physical model representing an XML document. Furthermore one could create a classification of importantThings and associate it with a port entity in the logical model and with an entity in the physical model representing a Policy document. This enables semantic queries to target individual elements of the service metadata and meaningful dependency analyses to take place prior to making changes.

Properties are simple name value pairs that are associated with any of the Service Description Entities . Some properties are assigned by the system such as the unique id the owner and the last time the service entity was changed. These system assigned properties cannot be changed. Others are derived through the shredding of a key type service description document into its logical model. Properties of this type include name and namespace. Sometimes these system assigned values are allowed to be changed and properties can be created. Such a user defined property can be used as a simple unstructured and untyped extension mechanism. Properties can be used in queries and can be used to establish fine grained access control.

Relationships tie together one source service description entity to one or more target service description entities. Every relationship is given a name and a source is only allowed to have a single relationship with a given name. Some relationships are assigned by WSRR during the shredding of key types of documents. The relationship established between XSD documents based on the importing of one into the other is one such system assigned relationship. Relationships can also be user defined. For example a user can relate a concept that represents an external object to a service using a user defined relationship relate all of the service description documents that will be governed as a unit to a governable entity and or relate a monitoring policy to a service endpoint.

A user can load classification into WSRR where they can then be used to apply semantic meaning to service description entities . Classification systems are documents encoded using the Web Ontology Language OWL . WSRR represents OWL Classes as classifiers and interprets the subTypeOf relationship between those Classes as establishing a classifier hierarchy. Other OWL concepts such as data or relationship representing properties or other built in OWL relationships are ignored. A classification system is imported into Registry and Repository as a whole and can not be modified via WSRR. Updates are done by importing a modified version of the ontology. Any Class in the underlying ontology can be used as a classification the same classification can be used to classify multiple entities and an entity can be associated with multiple classifications.

In one embodiment the invention is provided as discrete nested logical entities within the Query manager as shown in . Referring to the Query manager comprises XMQL query engine XPath query translator object graph pruner and object graph mapper . XPath Query translator comprises XPath register node generator register and validator XPath tree node processor tracker SELECT clause generator and XMQL register and generator . The XPath tree node processor comprises node counter node search type locator search type register selector register from clause generator and where clause generator .

The XMQL query engine is a standard XMQL query engine using an XMQL query expression to access objects in WSRR.

The XPath query translator performs the translation between an input XPath expression and returns as output a XMQL expression.

The XPath register stores the XPath query expression so that it may be operated on by the node generator register and validator . The example A in shows the complete XPath expression WSRR WSDLService name GetQuote ports version 1.0 stored in the register. The example B in shows the XPath separated into the sequence nodes

The hierarchical node generator register and validator operates on the stored XPath query expression by building the node hierarchy registering the hierarchy and validating that the hierarchy and the nodes conform to what is expected by the service registry and repository. The reference in shows a simple hierarchy with two parents each with a respective child. In a more complicated hierarchy a parent node would have more than one child node.

The tracker comprises register for each of FROM clause WHERE clause and selector. The FROM clause and WHERE clause registers are appended after processing each node in the hierarchical node register. The selector may depend on the class of the node that is being processed.

The SELECT clause generator derives the SELECT clause from the last known selector if it is valid this derivation gives a reasonable approximation and is correct much of the time. However other factors may be taken into account for more complex XPath expressions where a simple approximation is not correct.

The XMQL register and generator bring the SELECT clause the FROM clause and the WHERE clause together as a complete XMQL expression. See in WHERE Selector a2 FROM register a1 in logical WSDLService a2 in a1 ports and Where register a1.name GetQuote and a2.version 1.0 in tracker C are appended to produced the complete translated query in Register SELECT a2 FROM a1 in logical WSDLService a2 in a1 ports WHERE a1.name GetQuote and a2.version 1.0 .

The XPath tree node processor controls the individual processing of the node in the hierarchical node tree and loops back to process each node of the tree. When all the nodes are processed then the XPath tree node processor hands control back to the XPath query translator .

The node search type locator acquires the XPath expression for the current node and finds the class of node and the properties associated with it. If the located search type is not the same as in the search type register then tracker selector register is incremented and the search type register is updated with the located search type.

The FROM clause generator combines the current node and the current selector into a FROM clause portion if the search type is of the FROM class. The FROM clause portion is added to the tracker .

The WHERE clause generator translates a predicate using properties associated with the particular search type into a WHERE clause portion if the search type is of the WHERE class. The WHERE clause portion is added to the tracker .

Object graph pruner comprises the method step to shown in . In step the whole graph of objects is received from the query engine .

In the example of the root node is A. shows an example graph of objects returned after a query of the object database. Object A is the root node and objects B C E are the children of A but not function children for the purposes of this embodiment. The relationship r between A and B is defined for the class to which object A belongs. The relationship r between A and C is defined for the class to which object A belongs. The relationship UR is a user defined relationship defined by the object UR which belongs to the class representing user defined relationships. UR is the direct child of A. The child of UR is E.

Object D is a child of object C and relationship r is defined for the class of which object C belongs. The relationship UR is a user defined relationship defined by the object UR which belongs to the same class as UR. UR is the direct child of E. The child of UR is F. The objects UR and UR are UDR nodes or UDR objects . The objects A through E are non UDR nodes or non UDR objects .

Referring to both and in step the node register is changed to reference the next child of the current reference node. Step opens the pruning loop. In the example of the first child of root node A is B and subsequent children are C and UR. D is a child of C E is a child of UR UR is a child of E and F is a child of UR.

In step the node register is checked to see if it references a UDR object. If it does then the process moves to step but if it does not then the depth counter i is incremented in step before moving to . The effect of this is to only increment the depth counter when a non UDR node is reached so that only one edge out of the two involved in a user defined relationship is counted against the specified depth limit in step . In the example of the children B and C of A are non UDR nodes but the child UR of A and the child UR of E are UDR nodes.

In step the depth counter is compared to a specified depth limit Depth and if less than the specified depth limit the process moves on to step and no pruning takes place. If the depth counter is equal to or more than the specified depth limit then the process cuts the children out of the returned graph in step . In the example of the specified graph depth limit is 1 and the returned objects are shown to a depth of 1 whereas in the example of the specified graph depth is 2 and the returned objects are shown to a depth of 2.

In step all children of the referenced object are cut. That is they are not returned as part of the query because the specified depth limit has been reached. The node will never be a UDR node. Following the cut the node pointer is moved back to the parent of the node and the depth counter is decremented. For instance if the graph depth is 1 and object C is referenced then object D will be cut and not returned. Likewise if the graph depth is 1 and object E is referenced then objects UR and F are cut and not returned.

In steps and the node pointer is moved back to the parent of the node if the referenced node is a UDR node. In this way step only looks at non UDR nodes.

In step the process checks whether the referenced node has a next child and if so moves back to step and to the main loop for cutting nodes that are more than the specified depth limit. Otherwise the process moves to step .

In step the process checks whether the node is the root node and if not goes back to the next parent node and decrements the depth counter at step before rejoining the main loop at step . If the reference node is the root node then the process is moved to step .

For instance shows the object graph of pruned to a depth of 1 and shows the object graph of pruned to a depth of 2.

In step all the user defined objects are removed. In the example of UR and UR would be removed if the specified depth was 2. Only UR would be removed if the specified depth was 1.

The query management system is one embodiment of the invention. In a preferred embodiment the invention is provided as a process as shown in .

In step an abstract syntax tree representation of the XPath query is generated as a set of Java objects.

In step the highest node in the syntax tree is located. This node represents a top level type in the WSRR SDO hierarchy. The node is saved as Current Search .

In step the Selector Clause is derived from the selector saved in the XMQL register as a starting expression for the XMQL query. A simple derivation for simple XPath expressions is to use the last selector value after the node processing. However for more complex XPath a more complex algorithm involving the use of the current selector the current search class and the sequence of steps from the last predicated step in the original expression is used.

In step the expression in the XMQL register corresponds to a translated XMQL expression of the XPath query. The XMQL expression is provided as input to the XMQL engine to access objects in the object repository.

The process starts step at the root of the abstract syntax tree. In this embodiment the root node is verified as WSRR this identifies the query as being targeted towards a service registry system. In the tracker the FROM register and Where register are nulled and the selector is set to the first node of the abstract syntax tree.

In step the tree is examined for a node to process and exits if all the nodes have already been processed.

In step the search type is located by lookup. Properties associated with the located search type are similarly acquired.

In step if the new search type is the same as a current search type then the process misses step and starts again at using the current search type found in the search type register.

In step the selector is incremented and the newly found search type is saved in readiness for updating of the FROM and Where clauses in step and .

In step the current node search type and the current selector are combined into a FROM clause and added to the tracker.

In step if the current node has a predicate then it is translated using properties associated with the search type into a WHERE clause and added to the tracker.

It will be clear to one of ordinary skill in the art that all or part of the method of the preferred embodiments of the present invention may suitably and usefully be embodied in a logic apparatus or a plurality of logic apparatus comprising logic elements arranged to perform the steps of the method and that such logic elements may comprise hardware components firmware components or a combination thereof.

It will be equally clear to one of skill in the art that all or part of a logic arrangement according to the preferred embodiments of the present invention may suitably be embodied in a logic apparatus comprising logic elements to perform the steps of the method and that such logic elements may comprise components such as logic gates in for example a programmable logic array or application specific integrated circuit. Such a logic arrangement may further be embodied in enabling elements for temporarily or permanently establishing logic structures in such an array or circuit using for example a virtual hardware descriptor language which may be stored and transmitted using fixed or transmittable carrier media.

It will be appreciated that the method and arrangement described above may also suitably be carried out fully or partially in software running on one or more processors not shown in the figures and that the software may be provided in the form of one or more computer program elements carried on any suitable data carrier also not shown in the figures such as a magnetic or optical disk or the like. Channels for the transmission of data may likewise comprise storage media of all descriptions as well as signal carrying media such as wired or wireless signal carrying media.

The present invention may further suitably be embodied as a computer program product for use with a computer system. Such an implementation may comprise a series of computer readable instructions either fixed on a tangible medium such as a computer readable medium for example diskette CD ROM ROM or hard disk or transmittable to a computer system using a modem or other interface device over either a tangible medium including but not limited to optical or analogue communications lines or intangibly using wireless techniques including but not limited to microwave infrared or other transmission techniques. The series of computer readable instructions embodies all or part of the functionality previously described herein.

Those skilled in the art will appreciate that such computer readable instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic or optical or transmitted using any communications technology present or future including but not limited to optical infrared or microwave. It is contemplated that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation for example shrink wrapped software pre loaded with a computer system for example on a system ROM or fixed disk or distributed from a server or electronic bulletin board over a network for example the Internet or World Wide Web.

In an alternative the preferred embodiment of the present invention may be realized in the form of a computer implemented method of deploying a service comprising steps of deploying computer program code operable to when deployed into a computer infrastructure and executed thereon cause the computer system to perform all the steps of the method.

In a further alternative the preferred embodiment of the present invention may be realized in the form of a data carrier having functional data thereon said functional data comprising functional computer data structures to when loaded into a computer system and operated upon thereby enable said computer system to perform all the steps of the method.

It will be clear to one skilled in the art that many improvements and modifications can be made to the foregoing exemplary embodiment without departing from the scope of the present invention.

