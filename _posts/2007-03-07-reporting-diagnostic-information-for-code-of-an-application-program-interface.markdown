---

title: Reporting diagnostic information for code of an application program interface
abstract: A technology for reporting diagnostic information for code of an application program interface is disclosed. In one method approach, diagnostic information for a line of code in a file associated with an application program interface is received. The diagnostic information includes a designation of the line of code. The diagnostic information is stored in a fixed sized buffer. Efficient use of memory is provided without requiring elimination of other diagnostic information previously stored in the fixed sized buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765432&OS=07765432&RS=07765432
owner: Microsoft Corporation
number: 07765432
owner_city: Redmond
owner_country: US
publication_date: 20070307
---
Computers enable people to perform many types of activities more easily than what can be performed manually. Examples of these activities include but are not limited to typing documents billing storing and correlating information in databases obtaining driving directions searching for and purchasing items of interest. Many applications have been developed to enable people to perform these activities by executing the applications on one or more computers. Problems can occur as the code associated with the applications executes. Examples of problems that can occur include an inability to obtain storage an inability for one computer to communicate with another computer and an unauthorized person modifying code associated with an application among other things.

Frequently technical people who work for the companies that sell the applications have to determine what caused the problem. Conventional applications frequently provide no information about a problem. When information about a problem is provided the provided information is frequently inadequate.

For example the application may provide a single error code when a certain type of problem occurs. One error code such as may be provided whenever storage could not be obtained and another error code such as may be provided when one computer is unable to communicate with another computer. However an application may attempt to obtain storage or to communicate with another computer in many different places.

In another example information about stack based crashes is provided. However this technique only provides information about operating system problems that resulted in a stack crash. No information is provided about problems that occurred in applications or non stack based operating system problems.

In yet another example software that executes on a computer can include invocations to a log facility. When the invocation is executed a log is written to the log facility. These invocations may be placed among other things at the entry and exit of portions of code. Invocations of a log facility for example at the entry and exit of portions of code are frequently known as full code path logging. Examples of portions of code include but are not limited to methods procedures functions and blocks of code associated with condition statements. Examples of condition statements include but are not limited to if statements else statements case statements and when clauses. However full code path logging results in a tremendous amount of information being written which requires a large amount of storage and uses a large percentage of the central processing unit s CPU s cycles. Therefore full code path logging is disabled during normal operations. Full code path logging is enabled after a problem has occurred and attempts are made to recreate the problem so that information about the execution path that resulted in the problem can be obtained.

As can be seen single error code technique provides an inadequate amount of information. Stack crash and full code path logging may result in no information for certain types of problems. Further frequently no information is provided for what is known as soft errors where an application can continue to execute after the error.

This Summary is provided to introduce concepts concerning reporting diagnostic information for code of an application program interface which are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A technology for reporting diagnostic information for code of an application program interface is disclosed. In one method approach diagnostic information for a line of code in a file associated with an application program interface is received. The diagnostic information includes a designation of the line of code. The diagnostic information is stored in a fixed sized buffer. Efficient use of memory is provided without requiring elimination of other diagnostic information previously stored in the fixed sized buffer.

Since according to one embodiment the diagnostic information includes the designation of the line of code a person can determine the exact line of code in an application that a particular problem is related to. For example one line of code may have the designation 1 and another line of code may have the designation 2 so that a person can determine that diagnostic information with the designation 1 pertains to the former line of code and diagnostic information with the designation 2 pertains to the latter line of code.

The drawings referred to in this description should be understood as not being drawn to scale except if specifically noted.

Reference will now be made in detail to embodiments of the present technology for reporting diagnostic information for code of an application program interface examples of which are illustrated in the accompanying drawings. While the technology for reporting diagnostic information for code of an application program interface will be described in conjunction with various embodiments it will be understood that they are not intended to limit the present technology for reporting diagnostic information for code of an application program interface to these embodiments. On the contrary the presented technology for reporting diagnostic information for code of an application program interface is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope the various embodiments as defined by the appended claims. Furthermore in the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the present technology for reporting diagnostic information for code of an application program interface. However the present technology for reporting diagnostic information for code of an application program interface may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present embodiments.

Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present detailed description discussions utilizing terms such as receiving storing performing communicating enabling retrieving transmitting generating or the like refer to the actions and processes of a computer system or similar electronic computing device. The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices. The present technology for reporting diagnostic information for code of an application program interface is also well suited to the use of other computer systems such as for example optical and mechanical computers.

As already stated conventional applications frequently provide no information about a problem and when information about a problem is provided it is frequently inadequate. is a block diagram of a method for reporting diagnostic information for code of an application program interface according to one embodiment. An application enables other programs to invoke it with what is commonly known as an application programming interface API . Code for an application is typically organized in a plurality of files. The application code is stored in a file one line after another. For example an if statement may be followed with a beginning bracket such as which may be followed by an assignment statement and so on. Each of the lines of code according to one embodiment has a designation. For example the first line of code LOC in a file can have the number 1 associated with it the second line of code in the file can have the number 2 associated with it and so on for all of the lines of code in a file .

A log facility can be invoked after any line of code according to one embodiment. As depicted in a log facility is invoked respectively at and after lines of code and . The log facility results in diagnostic information DI and DI being stored in a fixed sized buffer . An invocation of the log facility results in diagnostic information DI being stored and an invocation of the log facility results in diagnostic information DI being stored. The diagnostic information includes a designation of a line of code such as 1 for LOC and 2 for LOC . Since the diagnostic information includes the designation of the line of executed code a person can determine the exact line of code in an application that a particular problem is related to.

According to one embodiment a log facility can be invoked after any line of code associated with an application. The log facility causes diagnostic information to be stored. is a block diagram of diagnostic information according to one embodiment. The diagnostic information as depicted in includes a unique file identifier UFI a code line designation CLD and a diagnostic code . Diagnostic information can include the UFI the CLD and the diagnostic code in a different order than what is depicted in .

According to one embodiment the UFI uniquely identifies a particular file for an application. A UFI can be a string of characters. For example the UFI for a particular file may be D81B2E7D. Although this example of a UFI includes 8 characters the number of characters may be larger or smaller. Each file for an application can have its own UFI. A UFI can be defined in a header file that is included in any file that refers to the UFI.

The CLD is the designation of a particular line of code in a file according to one embodiment. For example assume that the file D81B2E7D has 21 lines of code. The CLD can be any type of string that can be used to identify a particular line of code in a sequence of lines of code. The string may include letters numbers or a combination thereof among other things. For example the first line may have the designation of a number the second line may have the designation of a number and so on to the last line which may have the designation of the number . In another example A Z can be used to designate the lines of code. In yet another example A . . . A B . . . B and so on can be used to designate the lines of code. In still another example A . . . A B . . . B can be used to designate the lines of code. The CLD is automatically generated according to one embodiment therefore a constant defining the CLD is not required. The CLD can designate any type of line of code such as a source line of code or an assembler line of code that may have been generated for example from 3or 4generation language source code. Although many examples of CLDs described herein are 1 3 characters long a CLD may include more than 3 characters.

The diagnostic code is a code that identifies an execution state of the line of code that preceded the invocation of the logging facility according to one embodiment. An example of an execution state is an indication of what happened when the line of code executed. The diagnostic code may be an error code a warning code or an informational code among other things. A diagnostic code may be for a hard error which for example causes execution to terminate or a soft error where execution can continue. An error code may be used for a hard error and a warning code may be used for the soft error. An informational code can be used to indicate that a portion of code has been entered or exited. In a specific example a diagnostic code such as may be used to indicate that storage could not be obtained and a diagnostic code such as may indicate that a computer could not communicate with another computer. Although many examples of diagnostic codes described herein are 3 character long numeric diagnostic codes can have fewer or more characters and can include other types of characters such as letters.

According to one embodiment diagnostic information is not stored in the event that the previous line executed successfully. For example the log facility may be invoked but may not store any diagnostic information if the line that executed prior to the invocation of the log facility executed successfully. However according to another embodiment diagnostic information can be stored for non error situations such as warnings or information about the previous line of code.

In a specific example of diagnostic information assume that the 5line of code in the file D81B2E7D fails to obtain storage. The log facility invocation that follows this line of code may result in diagnostic information that includes the string D81B2E7D5567 where the first 8 characters D81B2E7D are the file s UFI the 9character 5 designates the line of code in that file that failed and the last 3 characters 567 designate the diagnostic code.

Diagnostic information can be used to determine among other things whether code was modified by an unauthorized person. For example a particular routine may determine whether a user is authorized to call a service. Assume the authorization fails and a piece of diagnostic information is stored indicating the authorization failed. However at the end of the routine another piece of diagnostic information is stored which indicates that the authorization succeeded. These two pieces of diagnostic information are an indication that the code of the routine may have been maliciously altered. In another example pieces of diagnostic information may indicate that code has been altered because the code s execution path is not what would be expected.

Application files that include the lines of code are stored in a computer system typically using a directory. A file is stored in a particular path of the directory. For example the file state machine.exe may be stored at video server application protocols embassy suites. The full path name video server application protocols embassy suites state machine.exe is conventionally used to specify the file. As can be seen the full path can become very long and a large amount of storage space would be used to store the full path. The use of a UFI to uniquely identify a particular file provides more efficient use of storage than using conventional full paths.

Designating a file with a UFI is an example of encoding. The full path name of a file provides unauthorized people with valuable information about the behavior of an application that may enable unauthorized people to maliciously modify the application or to steal the intellectual property of the company that owns the application. Encoding prevents unauthorized people from obtaining information about the behavior of the application.

Various embodiments provide for logging a particular failure for a particular line of code with a relatively small number of characters. Therefore according to one embodiment efficient use of memory is provided in part by the compact size of the diagnostic information. Second efficient use of CPU cycles is provided in part by the compact size of the diagnostic information. Third the size of the diagnostic information provides for quick and easy communication of the diagnostic information between various entities.

The system includes an application program interface diagnostic information designating a line of code receiver referred to hereinafter as receiver and an application program interface diagnostic information designating a line of code storer referred to hereinafter as storer . For example when the log facility is invoked after a line of code has failed diagnostic information such as D81B2E7D5567 can be passed to the log facility as a parameter. The receiver can receive the diagnostic information and the storer can cause the received diagnostic information to be stored for example in a fixed sized buffer.

Referring to according to one embodiment diagnostic information DI DI is stored in a fixed sized buffer . The received pieces of diagnostic information DI DI can be stored one after another. For example the first received piece of diagnostic information DI is stored first. The second received piece of diagnostic information DI is stored next and so on.

The pieces of diagnostic information DI DI that are stored in the fixed sized buffer according to one embodiment are transmitted to a diagnostic center. The pieces of diagnostic information can be stored and retrieved in a first in first out order. For example D is transmitted to the diagnostic center then D is transmitted to the diagnostic center and so on.

According to one embodiment the fixed sized buffer can be implemented as a circular buffer where the newest diagnostic information is stored on top of the oldest diagnostic information when no more space is available in the buffer. According to one embodiment the fixed sized buffer is large enough so that the typical application can complete execution before the fixed sized buffer runs out of space. According to one embodiment efficient use of memory is provided in part by using a fixed sized buffer.

According to one embodiment efficient use of memory is provided without requiring elimination of other diagnostic information previously stored in the fixed sized buffer. For example since the buffer has a fixed sized according to one embodiment potentially the newest diagnostic information may be stored on top of the oldest diagnostic information if the size of the buffer is exceeded. Therefore according to one embodiment in conjunction with or instead of storing the diagnostic information in a fixed sized buffer the diagnostic information can be stored in another file for example for long term retention or displayed on a monitor among other things so that diagnostic information is not eliminated as will become more evident.

According to one embodiment the behavior of storing the diagnostic information in the fixed sized buffer is an example of a primary behavior and storing the diagnostic information in another file or displaying it on a monitor are examples of a secondary behavior that can occur in parallel with the primary behavior. According to one embodiment the diagnostic information is provided to what is known as a consumer which implements the secondary behavior as will become more evident.

The flowchart will be described in the context of . is a block diagram of a system for reporting diagnostic information for code of an application program interface according to another embodiment. System includes a file that includes lines of code for an application invocations of a log facility and a logger object a consumer object a buffer a diagnostic center and another file .

According to one embodiment object oriented programming is used to implement various embodiments of the present invention. However various embodiments are also well suited for being implemented with non object oriented languages.

An object is created when an object oriented class is instantiated. An object is also known as an instance of that class. As depicted in the logger object is an instance of a logger class and the consumer object is an instance of a consumer class. The logger object includes the methods Log and SetConsumer . The consumer object includes the methods constructor destructor ClearBuffer GetBufferPter and ProvideDI . Execution of the constructor results in the consumer object being created from a consumer class and the destructor results in the consumer object being destroyed. Although not depicted in the logger object also has a constructor and a destructor according to one embodiment.

Assume that the logger object and the consumer object are created. The consumer object s constructor is invoked as a part of creating the consumer object . The constructor according to one embodiment invokes the SetConsumer method in the logger object and passes it a pointer to the newly created consumer object . In so doing the logger object has a pointer to the consumer object which the logger object can use later as will become more evident. The constructor may also invoke the ClearBuffer method which can remove any old information that is in the fixed sized buffer .

A user can interact with their computer which causes an application to execute. An application programming interface is used to invoke the application. The file includes lines of code LOCs for that application. LOC and are followed by respective invocations and of the log method .

In step diagnostic information for a line of code in a file associated with an application program interface is received. The diagnostic information includes a designation of the line of code. The receiver receives control when the log invocations and invoke the log method . According to one embodiment the log method is the receiver .

The log method can be implemented to cause the diagnostic information to be stored in the fixed sized buffer and or to provide the diagnostic information to the consumer object .

In step the diagnostic information is stored in a fixed sized buffer. For example if the respective lines of code and fail the log method will cause diagnostic information to be stored in the fixed sized buffer according to one embodiment. Assume for this illustration that LOC executes successfully and therefore the log method does not store diagnostic information for LOC . However LOC fails so the log method causes diagnostic information to be stored in the fixed sized buffer when it is invoked by the log invocation . According to one embodiment the storer associated with the log method causes the diagnostic information to be stored in the fixed sized buffer .

Since the diagnostic information includes a designation of the line of code such as a number of the line of code unique diagnostic information can be reported for different lines of code associated with the application program interface. In a specific example diagnostic information DI can include the designation 1 and diagnostic information DI can include the designation 3 which enables unique diagnostic information for LOC and LOC . A person looking at DI and DI can ascertain that DI is diagnostic information for LOC and DI is diagnostic information for LOC .

The diagnostic information DI DI can be transmitted to a diagnostic center using a first in first out order as described herein. People working at the diagnostic center can analyze the diagnostic information DI DI to determine the line of code and the problem that resulted in the diagnostic information DI DI.

As already stated the constructor previously passed a pointer to the SetConsumer method when the consumer object was created. The Log method can use the pointer to the consumer object to determine if the consumer object exists. The log method can also use the pointer to the consumer object to invoke the ProvideDI method .

The ProvideDI method can implement a secondary behavior such as storing the diagnostic information DI DI in a file . The ProvideDI method can invoke the GetBufferPter method to obtain a pointer to the fixed sized buffer in order to access the diagnostic information DI DI in the fixed sized buffer and store the diagnostic information DI DI in the file .

According to one embodiment the consumer object can provide more contextual information in addition to what the diagnostic information provides. For example the constructor can communicate contextual information to the buffer to the file or a monitor or any other entity. The communicated contextual information can indicate among other things that the application is entering execution. Similarly the destructor can communicate contextual information for example to the same one or more entities indicating that the application is ending execution. Any method associated with a consumer object can provide additional contextual information.

Any one or more of compact size of diagnostic information fixed sized buffer and a UFI among other things provide for efficient use of memory according to various embodiments. According to one embodiment any one or more of a consumer a secondary behavior and the compact size of diagnostic information among other things provide for efficient use of memory without requiring elimination of other diagnostic information previously stored in the fixed sized buffer. Since memory and or CPU cycles are used efficiently various embodiments can be enabled during the normal operation of an application. Therefore sufficient information about a problem can be captured the first time it occurs thus significantly reducing the probability that the problem would need to be re created in order to diagnose it.

With reference now to portions of the technology for reporting diagnostic information for code of an application program interface are composed of computer readable and computer executable instructions that reside for example in computer usable media of a computer system. That is illustrates one example of a type of computer that can be used to implement embodiments which are discussed herein of the present technology for reporting diagnostic information for code of an application program interface. is a block diagram of an exemplary computer system used in accordance with various embodiments of the present technology for reporting diagnostic information for code of an application program interface. It is appreciated that system of is exemplary only and that the present technology for reporting diagnostic information for code of an application program interface can operate on or within a number of different computer systems including general purpose networked computer systems embedded computer systems routers switches server devices client devices various intermediate devices nodes stand alone computer systems and the like. As shown in computer system of is well adapted to having peripheral computer readable media such as for example a floppy disk a compact disc and the like coupled thereto.

System of includes an address data bus for communicating information and a processor A coupled to bus for processing information and instructions. As depicted in system is also well suited to a multi processor environment in which a plurality of processors A B and C are present. Conversely system is also well suited to having a single processor such as for example processor A. Processors A B and C may be any of various types of microprocessors. System also includes data storage features such as a computer usable volatile memory e.g. random access memory RAM coupled to bus for storing information and instructions for processors A B and C. System also includes computer usable non volatile memory e.g. read only memory ROM coupled to bus for storing static information and instructions for processors A B and C. Also present in system is a data storage unit e.g. a magnetic or optical disk and disk drive coupled to bus for storing information and instructions. System also includes an optional alphanumeric input device including alphanumeric and function keys coupled to bus for communicating information and command selections to processor A or processors A B and C. System also includes an optional cursor control device coupled to bus for communicating user input information and command selections to processor A or processors A B and C. System of the present embodiment also includes an optional display device coupled to bus for displaying information.

Referring still to optional display device of may be a liquid crystal device cathode ray tube plasma display device or other display device suitable for creating graphic images and alphanumeric characters recognizable to a user. Optional cursor control device allows the computer user to dynamically signal the movement of a visible symbol cursor on a display screen of display device . Many implementations of cursor control device are known in the art including a trackball mouse touch pad joystick or special keys on alpha numeric input device capable of signaling movement of a given direction or manner of displacement. Alternatively it will be appreciated that a cursor can be directed and or activated via input from alpha numeric input device using special keys and key sequence commands. System is also well suited to having a cursor directed by other means such as for example voice commands. System also includes an I O device for coupling system with external entities. For example in one embodiment I O device is a modem for enabling wired or wireless communications between system and an external network such as but not limited to the Internet.

Referring still to various other components are depicted for system . Specifically when present an operating system applications modules and data are shown as typically residing in one or some combination of computer usable volatile memory e.g. random access memory RAM and data storage unit . In one embodiment the present technology for reporting diagnostic information for code of an application program interface for example is stored as an application or module in memory locations within RAM and memory areas within data storage unit .

The computer readable and computer executable instructions reside for example in data storage features such as computer usable volatile memory computer usable non volatile memory and or data storage unit of . The computer readable and computer executable instructions are used to control or operate in conjunction with for example processor A and or processors A B and C of . Although specific steps are disclosed in flowchart such steps are exemplary. That is embodiments are well suited to performing various other steps or variations of the steps recited in flowchart . It is appreciated that the steps in flowchart may be performed in an order different than presented and that not all of the steps in flowchart may be performed.

Although the subject matter has been described in a language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

