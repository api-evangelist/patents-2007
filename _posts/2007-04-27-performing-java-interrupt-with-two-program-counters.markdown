---

title: Performing java interrupt with two program counters
abstract: A method and system for performing a Java interrupt. At least some of the illustrative embodiments are methods comprising executing a thread having a context on a stack based on a first program counter, detecting an interrupt while executing the thread (wherein execution of the thread is temporarily suspended), and executing a method portion to handle the interrupt (wherein the method portion is executed on the stack based on the first program counter, and wherein the context during execution of the method portion is the same as during execution of the thread).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08516502&OS=08516502&RS=08516502
owner: Texas Instruments Incorporated
number: 08516502
owner_city: Dallas
owner_country: US
publication_date: 20070427
---
The present application claims the benefit of EP Application No. 06291876.8 filed on Dec. 4 2006 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation based on a plurality of bytecodes that define specific tasks. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly. Many times a processor that directly executes Java bytecodes is paired with a general purpose processor so as to accelerate Java program execution in a general or special purpose machine.

Interrupts are often used to signify that an event has occurred and that an action should be taken. When a Java processor receives an interrupt native non Java code instructions are used to handle interrupts. However native code is not as dense i.e. compact stable secure suited to low power applications as Java thus undermining performance of the processor.

The problems noted above are solved in large part by a method and system for performing a Java interrupt. At least some of the illustrative embodiments are methods comprising executing a thread having a context on a stack using a first program counter detecting an interrupt while executing the thread wherein execution of the thread is temporarily suspended and executing a method portion to handle the interrupt wherein the method portion is executed on the stack using the first program counter and wherein the context during execution of the method portion is the same as during execution of the thread .

Other illustrative embodiments are processors comprising fetch logic that retrieves instructions from memory decode logic coupled to the fetch logic and a first program counter. The processor executes a thread having a context on a stack using the first program counter and detects an interrupt while executing the thread. Execution of the thread is temporarily suspended and the processor executes a method portion to handle the interrupt the method portion is executed on the stack using the first program counter and the context during execution of the method portion is the same as during execution of the thread .

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure including the claims unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

The subject matter disclosed herein is directed to a programmable electronic device such as a processor. The processor described herein may be particularly suited for executing Java Bytecodes or comparable code. Java is particularly suited for embedded applications and is a relatively dense language meaning that on average each instruction may perform a large number of functions compared to various other programming languages. The dense nature of Java is of particular benefit for portable battery operated devices. The reason however for executing Java code is not material to this disclosure or the claims that follow. Further the various embodiments may be described in the context of Java but should not be limited to the execution of only Java instructions. The processor described herein may be used in a wide variety of electronic systems e.g. cell phones .

Optional processor may be referred to as a Micro Processor Unit MPU . The MPU is a processor that executes non Java instructions and in some embodiments the MPU may also execute Java bytecodes through an interpreter. System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise an Application Programming Interface implementation API and a Java Virtual Processor JVP discussed more below . The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

The MPU executes non Java instructions. For example the MPU may host an operating system O S which performs various functions such as system memory management system task management and most or all other native tasks running on the system management of the display and receiving input from input devices. Java code executed on the JVP may be used to perform any one of a variety of applications such as multimedia games or web based applications in the system while non Java code which may comprise the O S and other native applications may run on the MPU .

Most Java bytecodes perform stack based operations. For example an IADD integer add Java opcode pops two integers off the top of the stack adds them together and pushes the sum back on the stack. A simple opcode is one in which the JSM may perform an immediate operation either in a single cycle e.g. an IADD opcode or in several cycles e.g. DUP2 X2 . A complex opcode is one in which several memory accesses within the JVM or JEK data structure for various verifications e.g. NULL pointer array boundaries are made.

The JSM processor in accordance with some embodiments executes in addition to the Java bytecodes a second instruction set other than Java bytecodes. In some exemplary embodiments the second instruction set may comprise register based and memory based operations rather than stack based operations. This second instruction set complements the Java instruction set and accordingly may be referred to as a complementary instruction set architecture C ISA . By complementary it is meant that some complex Java bytecodes may be replaced by a micro sequence comprising C ISA instructions. The execution of Java code may thus be made more efficient and run faster by replacing some opcodes by more efficient micro sequences of C ISA instructions. The JSM thus comprises a stack based architecture for direct execution of Java bytecodes combined with a register based architecture for direct execution of memory based micro sequences of C ISA instructions. Because various data structures may be JVM dependent and thus may change from one JVM implementation to another the software flexibility of the micro sequence provides a mechanism for various JVM optimizations now known or later developed.

As discussed above the JVP provides a layer of abstraction between the API and the JSM . In particular the JVP is a virtual hardware platform that is compatible with any Java API any real hardware software platform that may comprise a JSM processor or any JVM implementation. In some exemplary embodiments the JVP comprises a JEK core that has an execution engine a memory management component and a compiler. The execution engine may comprise a Bytecode engine a class loader a notification manager and an external method interface. The memory management component may comprise a memory allocator an object mapper for physically constrained objects a garbage collector a memory defragmentor and a swapper. The compiler may comprise a dynamic compiler and provide code buffer management. The JEK core may also comprise firmware to facilitate the execution of Java Bytecodes on the JSM processor.

The JVP also provides the API with methods to create software class loaders. A class loader loads classes used by an application at runtime. Other hardware components of the hardware platform or software components are each virtualized within the JEK as a Java Virtual Device JVD that communicates with the JEK core. A JVD comprises some combination of fields methods and notifications. The fields may comprise standard Java fields or may be mapped to a predefined or constrained physical memory space wherein the constraint may be due to hardware or software. The fields may also comprise a map to indirect memories. The methods may comprise standard bytecodes or may comprises JSM native code hardware instructions or may use any kind of native interface such as a Java Native Interface JNI or a KVM Native Interface KNI . The notifications may be initiated by an event for example a hardware interrupt or from software. Additionally the JEK core manages native interface links and the notification mechanism provides a way to implement flexible monitoring.

Java bytecodes may pop data from and push data onto the micro stack which micro stack comprises a plurality of gates in the core of the JSM . The micro stack comprises the top x entries of a larger stack i.e. an overall stack that is implemented in data storage . Although the value of x may be vary in different embodiments in accordance with at least some embodiments the size x of the micro stack may be the top eight entries in the larger memory based stack. By implementing the micro stack hardware in the core of the processor access to the data contained in the micro stack is very fast although any particular access speed is not a limitation on this disclosure.

ALU adds subtracts and shifts data. The multiplier may be used to multiply two values together in one or more cycles. The instruction fetch logic fetches instructions from instruction storage which instructions may be decoded by decode logic . Because the JSM is configured to process instructions from at least two instruction sets the decode logic comprises at least two modes of operation one mode for each instruction set. As such the decode logic unit may comprise a Java mode in which Java bytecodes may be decoded and a C ISA mode in which micro sequences of C ISA instructions may be decoded.

The data storage comprises data cache D cache and data random access memory D RAM . The stack excluding the micro stack arrays and non critical data may be stored in the D cache while local variables and data may be stored in D RAM . The instruction storage may comprise instruction RAM I RAM and instruction cache I Cache . The I RAM may be used for opcodes or micro sequences and the I Cache may be used to store other types of Java bytecode and mixed Java C ISA instructions.

Referring now to the registers of may comprise a plurality of registers designated as R R. Registers R R R R R and R R may be used as general purposes GP registers for any purpose. Other registers and some of the GP registers may be used for specific purposes. For example registers R and R may each be used to store program counters with R storing a program counter PC for a stream of bytecodes and R storing a micro program counter micro PC for executing micro sequences. In addition to use as a GP register register R may be used to store the base address of a portion of memory in which Java local variables may be stored when used by a Java method. The top of the micro stack can be referenced by the values in registers R and R and the top of the micro stack may have a matching address in external memory pointed to by register R. The values contained in the micro stack are the latest updated values while their corresponding values in external memory may or may not be up to date. Register R provides the data value stored at the top of the micro stack. Registers R and R may also be used to hold the address index AI0 and address index AI1 . Register R may also be used to hold the indirect register index IRI . Register R may be used for status and control of the JSM . At least one bit called the Micro Sequence Active bit not specifically shown in status register R is used to indicate whether the JSM is executing by way of a micro sequence. This bit controls in particular which program counter is used R PC or R micro PC to fetch the next instruction.

In accordance with embodiments of the invention interrupts asserted to the JVP are handled at least in part by way of Java based programs. Java is dense i.e. compact stable secure suited to low power applications and allows for high level programming of interrupts. However rather than executing Java code within an interrupt by way of context switching which suffers from high latency and relies on an operating system scheduler for management of the execution flow of an interrupt service routine i.e. interrupt handler in embodiments of the present invention an interrupt is handled with a small amount of C ISA code and a set of Java based code wherein the Java based code is executed without making a context switch and without relying on an operating system scheduler to manage the execution flow of the interrupt. More particularly the various embodiments rely on executing Java based interrupt handling within the same context as executing when the interrupt arrives.

A thread is defined as an independent flow of control or stream of execution of an application and multiple threads are used to give the appearance of concurrently performing different tasks within the same processor such as the JVP . A thread comprises a context e.g. a program counter a register set and a stack having a stack base address and code e.g. Java code . Each thread has its own context and code. For Java threads the stack comprises an operand stack and local variables of Java methods executed by the thread. In particular each thread is associated to and is executed on a different stack within the overall stack wherein each stack comprises a range of memory addresses such as within the data storage and wherein each stack has a different stack base address. Different threads may occupy contiguous or non contiguous locations in memory. In addition the range of memory addresses for a given stack corresponding to a given thread does not overlap any other range of memory addresses for any other stack corresponding to any other thread. When a thread is executed its corresponding stack is accessed based on the thread s context. The thread context comprises a Stack Pointer SP value R which comprises an address of the top of a stack a Top of Stack ToS value R which contains the value of the top of the stack and a Program Counter PC value R which comprises an address of a thread instruction that is executed. When a thread is just beginning its execution the PC value may comprise an address of the first thread instruction. In some cases an executing thread may be interrupted by another thread pre empted by a higher priority thread or stopped for some other reason as determined by the operating system scheduler. In a context switch the context of the originally executing thread all registers including the SP value and PC value is pushed onto its corresponding stack having a particular stack base address and the context of a new thread is popped from its corresponding stack having a different stack base address and all registers including the SP value and PC value of the new thread are loaded into the appropriate registers for execution of the new thread. The storing of a thread context corresponding to a thread having a particular stack base address and the subsequent loading of a different thread context i.e. different register values corresponding to a thread having a different stack base address as described above is what constitutes the context switch. In some instances a context switch may be performed as part of a scheduled sequence of operations as determined by the operating system scheduler. According to the hardware additional operations may be called for to save or restore the context of a thread when making a thread switch e.g. cleaning caches or cleaning the micro stack .

Threads executed within the JVP comprise one or more methods and a method comprises executable instructions and performs one or more functions. Other terms for method may include subroutines code segments and functions and the term should not be used to narrow the scope of this disclosure. One or more methods and their associated local variables may be executed in one thread and the same or different methods may be executed in a different thread.

Each stack within the overall stack as described above comprises a stack of stack frames and a new stack frame is created upon invocation of a method within the same thread i.e. within the same context . A stack frame comprises an operand stack and local variables that are used to execute the invoked method. The stack frame at the top of the stack is the active stack frame . The active stack frame is the stack frame used by the currently executing method. Upon invocation of a method within the same thread a newly created stack frame is pushed onto the stack thus becoming the active stack frame. The operand stack and local variables of the previously active stack frame are stored beneath the newly created stack frame. When the method finishes executing the active stack frame is popped from the stack and the stack frame beneath becomes the active stack frame. Thus the active stack frame i.e. the method that was executing prior to invocation of the new method once again becomes the active stack frame and the previously executing method continues. For purposes of this disclosure the process of pushing a new stack frame onto the stack and popping it from the stack after execution of its associated method is not considered a context switch inasmuch the current execution stack does not change i.e. the stack base address remains the same . While the SP value the ToS value and the PC value may change during method execution and pushing popping the constant stack base address value signifies that the same stack address space is being addressed and thus a context switch has not been completed. In addition the pushing and popping of stack frames on a stack and subsequent method execution does not involve use of the operating system scheduler since execution is confined to one context i.e. one thread .

A unique micro sequence handler may be provided for every distinct interrupt and the association between interrupts and handlers is defined by way of a table as illustrated in . The table may be implemented in the decode logic as separate logic in the JSM or as software within the JEK . Furthermore in some embodiments the JEK may dynamically overwrite associations stored in the table with new associations thus allowing any of the available micro sequence handlers to be triggered by any interrupt that is encountered. The table comprises a plurality of entries one entry for each interrupt. For example if there are a total of 10 different types of interrupts the table comprises at least 10 entries. Each entry comprises at least one field . Field may contain a reference to a micro sequence handler triggered upon receipt of a corresponding interrupt. For example an interrupt with an index value equal to 3 interrupt level 3 is associated to the micro sequence handler having an address stored in the table at offset useq it3 handler . Thus useq it3 handler is the micro sequence handler for the interrupt level 3.

The field may comprise a full starting address in instruction storage of the micro sequence handler or a part of the starting address that can be concatenated with a base address that may be programmable in the JSM. In the former case the field may provide sufficient address bits to access the full memory space in which are stored the micro sequence code. In the latter case a register within the JSM registers or within a JSM configuration register is programmed to hold the base address and the field may supply only the offset to access the start of the micro sequence handler. Additionally the JSM internal registers and any other registers accessible by the JVP or the MPU may be modified by the JVM. This latter addressing technique may be used to reduce the number of bits needed within the field .

Returning to the first micro sequence portion A makes an invocation which serves to create a new Java stack frame within the JSM that is used to execute the Java portion which handles the interrupt . As previously discussed the stack frame comprises information regarding the Java portion as called for by the JVM such as local variables an operand stack a reference to a Java object which comprises a Java method of the Java portion which is to be executed or other such information. The size of the stack frame invoked may vary based on the Java method of the Java portion to be executed. The newly invoked stack frame is then pushed onto the stack e.g. the micro stack for execution of the Java portion . The first micro sequence portion A then transfers execution of the interrupt to the Java portion wherein such a transfer consists in making the PC the active program counter and referencing the first instruction of the Java portion . Thereafter the Java portion executes utilizing Java bytecodes and Java object references rather than pointers which increases the Java platform stability and security. The Java portion ends with a return bytecode that is used to transfer execution to the second micro sequence portion B as illustrated in . Thus the micro PC once again becomes the active program counter. The second micro sequence portion B serves to pop i.e. delete the stack frame that was used for execution of the Java portion . The second micro sequence portion B then executes a return from interrupt which may comprise a predetermined instruction called RtuS return from micro sequence that indicates the end of the sequence. This C ISA instruction causes a switch from the micro PC register R to the PC register R upon completion of the micro sequence and pops the JSM context i.e. the PC and or micro PC value and the registers that was pushed onto the stack when entering the ISR . Thereafter execution within the JSM resumes with the currently running thread as indicated by arrow which in this example is thread . Specifically thread is resumed based on the context that was pushed onto the stack prior to execution of the ISR . That is the previously active stack frame i.e. prior to the invocation of the micro sequence portion A that created the new stack frame once again becomes the active stack frame and the previously executing method e.g. a method of thread continues. Specifically the PC points to the instruction following the instruction at which the interrupt was triggered. In some embodiments the PC may have been incremented or offset by some predetermined value during execution of the interrupt so that the PC may point to an alternative instruction for subsequent decoding and execution.

Since thread and the Java portion execute within a single stack corresponding to thread there is no context switch. Although the SP value and PC value may change during method execution and during the pushing and popping of the stack frame of the Java portion the value of the stack base address remains constant signifying that the same stack address space is being addressed and thus a context switch has not been completed. In addition since execution is confined to one thread the operating system scheduler is not used. Thus a Java method may be directly entered and executed as part of an efficient interrupt handling routine within the interrupt execution flow of the processor that uses a small amount of C ISA native code. Though Java has been used to describe embodiments of the invention the same methods can be applied to any other high level runtime as well.

The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

