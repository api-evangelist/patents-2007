---

title: Parameter type prediction in object relational mapping
abstract: Techniques for object relational mapping in database technologies are described herein. According to one embodiment, in response to a query statement for accessing a relational database, a syntax tree is generated to represent semantic information of the query statement, where the query statement includes a wildcard parameter and is implemented as an object of a SQL. A data type of the wildcard parameter is predicted based on the semantic information obtained from the syntax tree in view of a structure representing the syntax tree. The predicted data type of the wildcard parameter is used to access the corresponding entry of the relational database. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07996416&OS=07996416&RS=07996416
owner: Red Hat, Inc.
number: 07996416
owner_city: Raleigh
owner_country: US
publication_date: 20070831
---
The present invention relates generally to object relational mapping in database management. More particularly this invention relates to improved data type prediction in object relational mapping.

Data management tasks in object oriented programming are typically implemented by manipulating objects which are typically non scalar values. Consider the example of an address book entry which represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object oriented implementation by a person object with slots to hold the data that comprise the entry the person s name a list or array of phone numbers and a list of addresses. The list of phone numbers would itself contain phone number objects and so on. The address book entry is treated as a single value by the programming language it can be referenced by a single variable for instance . Various methods can be associated with the object such as a method to return the preferred phone number the home address and so on.

Many popular database products however such as SQL DBMS products can only store and manipulate scalar values such as integers and strings organized within tables. A programmer must either convert the object values into groups of simpler values for storage in the database and convert them back upon retrieval or only use simple scalar values within the program. Object relational mapping is used to implement the first approach.

Object relational mapping aka O RM ORM and O R mapping is a programming technique for converting data between incompatible type systems in databases and object oriented programming languages. This creates in effect a virtual object database which can be used from within the programming language.

Typically a conventional ORM system provides an application programming interface API to allow a user to specifically set a data type of a parameter during mapping an object with a database entry. If a user enters a wildcard parameter such as or the conventional ORM is not able to determine the data type. Further a boolean entry of an underlying database may be represented as a numeric value or a string. When a user sets a boolean value the user has to specifically specify whether the boolean value is in a form of a numeric value or a string value. Otherwise the conventional ORM system cannot handle the data type for the boolean parameter.

In the following description numerous details are set forth to provide a more thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to one embodiment ORM includes a query analyzer and a data type predictor . The query analyzer in response to a query performs an analysis on the query to generate a syntax tree representing semantic information with respect to the query. Based on the syntax tree the data type predictor is configured to predict or guess the data type of certain parameters of the query. This is done without the application to specifically set the data type of the parameters. In a particular embodiment data type predictor may predict the data type of a Boolean parameter either in a numeric format or a string format dependent upon the requirement of the underlying database being accessed. In one embodiment the data type predictor may predict the data type based on metadata that defines certain rules of mapping a specific object oriented programming object to a specific SQL of a particular database. An example of metadata is shown in in an XML extensible markup language format.

In one embodiment the query analyzer includes a parser or translator generated using ANTLR ANother Tool for Language Recognition technologies. ANTLR allows one to define language grammars in either ANTLR syntax or a specific AST abstract syntax tree syntax. Further detailed information concerning ANTLR project can be found at ANTLR.ORG.

Framework includes a variety of components. For example session factory is configured to provide a thread safe immutable cache of compiled mappings for a single database. Session factory is a factory for session and a client of connection provider and it may hold an optional e.g. second level cache of data that is reusable between transactions at a process or cluster level. Session is a single threaded short lived object representing a conversation between the application and the persistent store . Session wraps a JDBC connection and is a factory for transaction . Session holds a mandatory first level cache of persistent objects which are used when navigating an object graph or looking up objects based on an identifier.

Persistent objects are short lived single threaded objects containing persistent state and business function. Persistent objects may be ordinary JavaBeans POJOs plain old Java objects . Persistent objects may be associated with a session e.g. session . As soon as the associated session is closed the persistent objects will be detached and free to use in any application layer e.g. directly as data transfer objects to and from presentation . Transaction is a single threaded short lived object used by the application to specify atomic units of work. Transaction abstract applications from underlying JDBC Java database connectivity JTA Java transaction API and or CORBA common object request broker architecture transactions. A session may span several transactions in some situations.

The JDBC API is the industry standard for database independent connectivity between the Java programming language and a wide range of databases SQL databases and other tabular data sources such as spreadsheets or flat files. The JDBC API provides a call level API for SQL based database access. The JTA specifies standard Java interfaces between a transaction manager and the parties involved in a distributed transaction system such as the resource manager the application server and the transactional applications. The CORBA is a standard defined by the Object Management Group OMG that enables software components written in multiple computer languages and running on multiple computers to interoperate. CORBA wraps program code into a bundle containing information about the capabilities of the code inside and how to call it. The resulting wrapped objects can then be called from other programs or CORBA objects across a network. CORBA uses an interface definition language IDL to specify the interfaces that objects will present to the world. CORBA then specifies a mapping from IDL to a specific implementation language like C or Java.

Referring back to connection provider is a factory for and pool of JDBC connections. Connection provider abstracts application from underlying data sources or driver managers e.g. JNDI or Java naming and directory interface JDBC and JTA . Transaction factory is a factory for transaction instances. Framework supports a variety of databases including for example Oracle DB2 Sybase MS SQL server MySQL etc. In one embodiment framework further includes a query analyzer and a data type predictor as described above with respect to . Note that some or all of the components as shown in may be implemented in hardware software or a combination of both hardware and software.

According to one embodiment referring to given a query statement a query analysis is performed by a query analyzer which may be generated using ANTLR techniques. As a result a syntax tree structure is generated where the syntax tree includes semantic information about the query statement . Based on the semantic information obtained from the syntax tree the ORM unit can predict the missing data type of the parameter as shown in and fill in the necessary information before accessing the underlying database.

In this example given a query of from Person a where a.name and the syntax tree although the query statement does not provide the parameter type by only giving a wildcard the ORM unit can predict that the parameter type is most likely the same as the underlying type of Person.name property which defines the object or class of a where the predicted parameter type may be a string as shown in syntax .

In addition the above techniques may also be used in certain situations to predict the data type of a Boolean parameter. For example a Boolean value in a database technology may be represented as a numeric value such as a zero or non zero value. However a Boolean value may also be represented via a string such as true or false or other strings such as yes or no . Whether a Boolean value is represented via a numeric number of a specific string depends on a specific implementation of the underlying database.

Conventionally Boolean literals are used as an actual SQL construct which allows a user to do a query as follows 

However these are typically resolved to SQL literal values based on the dialect and are thus non contextually resolved for example using a method similar to Dialet.toBooleanValueString . Using techniques similar to those described above according to one embodiment the Boolean literals may be resolved contextually. In the above example the TRUE literal would be resolved to a SQL literal using the type associated with Animal.pregnent property.

According to one embodiment referring to given a query statement a query analysis is performed by a query analyzer which may be generated using ANTLR techniques. As a result a syntax tree structure is generated where the syntax tree includes semantic information about the query statement . Based on the semantic information obtained from the syntax tree the ORM unit can predict the missing Boolean data type of the parameter as shown in and fill in the necessary information before accessing the underlying database.

In this example given a query of from Animal a where a.pregnent true and the syntax tree the ORM unit can predict that the parameter type is most like the same as the underlying type of Animal.pregnant property which defines the object or class of a where the predicted parameter type may be a string as shown in syntax . The type e.g. either a numeric value or a string used by the underlying database may be determined from the metadata such as metadata as shown in that maps the query to the specific SQL of the underlying database.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

