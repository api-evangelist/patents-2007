---

title: System and method for designing and implementing packet processing products
abstract: A system and method for allowing a user to create instructions for building a packet processing integrated circuit. The system includes a user interface for allowing a user to define a desired packet processing algorithm () using a plurality of discrete packet processing blocks (), each of the blocks corresponding to a portion of the desired packet processing algorithm (). The system allows the user to define connections () between the plurality of packet processing blocks (). The system processes a plurality of packet processing blocks () and the connections to provide a list of instructions in a hardware description language for producing an integrated circuit capable of executing the desired packet processing algorithm (). The list of instructions can be delivered to a customer (), or the customer can receive an integrated circuit constructed using the list of instructions (), or the customer can receive a NETLIST generated using said list of instructions (). The plurality of packet processing blocks () can include a Packet Processing Unit (PPU, PPUX) , a Packet Modification Unit (PMU) , and a Decision and Forwarding Unit (DFU) 
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07724684&OS=07724684&RS=07724684
owner: Modelware, Inc.
number: 07724684
owner_city: Red Bank
owner_country: US
publication_date: 20070524
---
The present invention relates to digital component design and implementation systems and more particularly to a system and method for designing and implementing packet processing products.

Computer based communications are dominated by the transmission of packets of data. Typically a packet contains a payload i.e. a portion of an overall data message surrounded by a number of header bits or bytes that are used to insure that the payload is transmitted and received without error. The header bits or bytes can be divided into a number of fields designating commands responses packet characteristics etc. The fields can take on one or more values depending on the particular protocol used. Some protocols are custom designed while others such as asynchronous transfer mode ATM or Transmission Control Protocol Internet Protocol TCP IP are standardized. For any type of protocol there is a need to extract and examine the header bits or bytes to make decisions as to how to classify a type of packet where to route the packet and whether to drop or temporarily store queue the packet for future processing. The header must be parsed bits or bytes examined or processed and then routing decisions must be made.

Various hardware and software products have in the past been developed for designing and implementing products for processing and classifying data packets. In one approach parsing decision and routing functions are implemented in software modules executed by the host processor and memory of the receiving computer. Processing large amounts of data in real time is often slow since doing so puts a strain on processor resources. A second approach is to use a specialized microprocessor and associated hardware called a network processing unit NPU . The NPU provides a programmable interface for programming nearly any type of protocol functionality. However the ability to program nearly every aspect of a transmission packet protocol burdens an NPU with a large amount of functionality rendering an NPU both expensive and slow low data rates . Also the time needed for a developer to program an NPU may take several hours to days which can be cost prohibitive. Another approach is to design a customized application specific integrated circuit ASIC . This approach often wastes large numbers of gates to achieve only limited functionality and is thus not cost effective. As such there is a lack of an adequate system or methodology for designing and implementing packet parsing and classification products wherein such products can be designed and implemented.

Accordingly what would be desirable but has not yet been provided is a system and method for designing and implementing packet processing products which addresses the foregoing limitations.

The present invention relates to a system and method for designing and implementing packet processing products wherein a user can create instructions for building a packet processing integrated circuit. The system includes a user interface for allowing a user to define a desired packet processing algorithm by defining a plurality of discrete packet processing blocks each of the blocks corresponding to a portion of the desired packet processing algorithm as well as connections between the plurality of packet processing blocks. The system processes the plurality of packet processing blocks and the connections to provide a list of instructions in a hardware description language for producing an integrated circuit capable of executing the desired packet processing algorithm. The list of instructions can be delivered to a customer or the customer can be provided with an integrated circuit constructed using the list of instructions. The customer can also be provided with a NETLIST generated using said list of instructions.

The packet processing blocks of the present invention include a Packet Processing Unit PPU a Packet Modification Unit PMU and a Decision and Forwarding Unit DFU . The PPU includes functionality for extracting a header of a packet for pointing to a portion of the header of a predetermined width using a predetermined index of a bit location in the header for comparing the data represented by the portion of the header with at least one predetermined value and for declaring a match when the result of the comparison is true. A variation of a PPU called a PPUX includes functionality for accessing an external Content Addressable Memory CAM or Random Access Memory RAM . The PMU includes functionality for extracting a packet pointing to a portion of the packet of a predetermined width using a predetermined index of a bit location in the packet and modifying the portion of the packet. A packet can be modified in one of three ways deletion insertion or overwriting a portion of the packet. The DFU can perform one of drop queue and forwarding operations on packets coming from at least one PPU PPUX or PMU. The PPU PPUX PMU and DFU can be programmed by an external microprocessor.

Further features and advantages of the invention will appear more clearly on a reading of the detailed description of an exemplary embodiment of the invention which is given below by way of example only with reference to the accompanying drawings.

Referring to a process according to the present invention for designing packet processing products is shown. The present invention allows a user to design packet processing products using a high level programming language which generates a NETLIST for generating a hardware design specification of a digital circuit. A NETLIST describes the connectivity of an electronic design. The design process begins at step wherein a set of user requirements and specifications are received which may be in the form of a packet parsing architecture or a packet parsing and classification algorithm. Typically these requirements are in the form of a text description of the system to be generated. At step the description is translated by the user or provider into a textual or graphical design using packet processing blocks which include Packet Parsing Units PPU Packet Parsing Units with an external interface to a CAM RAM PPUX Packet Modification Units PMU and Decision and Forwarding Units DFU which will be described hereinbelow with reference to .

As an example of step if the customer needs a firewall that accepts TCP packets and rejects UDP packets then three PPUs and one DFU are required. One of the PPUs is devoted to determining a source IP address a second PPU is devoted to extracting a destination IP address and a third PPU is devoted to distinguishing between TCP and UDP packets. The three PPUs are connected in parallel since the information can be extracted simultaneously from the same packet and the match outputs of the PPUs to be described with reference to and a source packet is forwarded to a DFU. Once the source and destination addresses are extracted from the packet and the type of packet is extracted the DFU takes each match input and the packet and makes a decision If the packet is a TCP packet and the source and destination addresses are allowed then the packet is passed on otherwise the packet is to be dropped. Thus in step the user can select the required number and combination of packet processing blocks to be used in the design.

At step the packet processing block requirements including their required inputs and outputs are entered into a connection document which can be a text based EXCEL spreadsheet or a VISIO block diagram. Typical inputs to the connection document include entries for each PPU and DFU block which may include an index representing the point of entry into a packet to be processed and whether a lookup in an internal table of data in a PPU is required.

Once the connection document has been completed then at step packet processing blocks e.g. each PPU and DFU can be configured. Configuring a packet processing block involves taking a default packet processing block file such as a generic PPU or DFU file and modifying portions of it and setting variables within each file. Code for the packet processing blocks to be described in written in pseudo code can be found in Appendices A E and G L attached hereto. In particular the pseudo code for the PPU calls code found in the following appendices a file for describing a generic header extraction block called a Hardware Lookup Unit HLU see Appendices D and K and a file for describing a generic Match Lookup Unit MLU see Appendices E and L . Both the HLU and MLU will be described hereinbelow as part of the description of the PPU. The packet processing blocks are implemented in a hardware design language HDL which models digital circuits with gates flip flops counters and other logic in a C like software language. In some implementations the pruning process can be performed by manually copying and editing a maximally configured processing block file or by applying a preprocessor in the form of shell scripts to cull code from and substitute variables within a maximally configured processing block files. Preprocessing shell scripts as is known in the art can include textual or graphically based user prompts for answering questions about specific parameters desired by the user for a particular block.

The GUI code can pass the input parameters to a preprocessor such as a preprocessor called veriloop2. The pseudo code for veriloop can be found in Appendix F. Veriloop first performs substitutions into appropriate variables using the parameters passed from the GUI. Veriloop then searches for constructs such as name value pairs conditional constructs and loops having a particular syntax and then culls the maximally configured packet processing block file to produce a preprocessed header like library files each containing a function or class representing a particular PPU DFU etc. Pseudo code for types of preprocessor constructs can be found in Appendix G. Pseudo code for sample pre processed files of can be found in Appendices H L. Note that there is only one PPU MLU HLU file for all three PPUs which share the same number of inputs outputs and share the same general structure. The number of PPUs that need to be generated depends upon the degree of parallelism needed for a particular design. If all the operations for a number of PPUs can be performed in series then one PPU is needed since all that changes between instances of PPUs is the input parameters e.g. opcode mask etc. . There is one generated PPU for each parallel operation. There are separate DFU Appendices i.e. Appendices B H and I because each DFU can have a different number of inputs outputs .

The present invention distils the implementation of maximally configured processing blocks into common sub blocks which have unique names e.g. PPU  DFU  or modules which have inputs and outputs that can be interconnected in such a way as to perform all of the functions necessary for implementing a desired packet processing product. The common blocks described herein are preferably instantiations of packet processing blocks written in VHDL Verilog or System C but other suitable hardware description languages can be used. The software implementation of packet processing blocks is platform independent and can be written in a platform independent language such as JAVA. As such packet parser classifier functionality of the present invention can run both in Windows and in different versions of the Unix operating system as well as others. In a GUI the programmer designer can invoke instances of these common modules using a C like application programming interface API surrounded by other C like code for interconnecting the sub blocks.

At step integration is performed. Integration involves declaring instantiations of each processing block by name and making connections between instantiated packet parsing blocks in a top level main program file the top level main program file is similar to the file containing the main function call in C language . These connections are called wires or signals which are declared like variables and associations are made between two processing block instances which have a common wire. For example signal x in PPU ties to signal y in the top level file. Signal z of DFU also ties to signal y in the top level file. In this way signal x of PPU is tied to Signal z of DFU which may also be tied to one or more other signals. Certain input parameters can also be hard coded within the top level file.

At this point all source HDL code has been generated which together can constitute a fully designed product. At step if the customer desires only the design then at step the generated packet processing block files and the top level file can be delivered to the customer. If the customer desires to have a NETLIST then at step the generated files are run through a commercially available synthesis tool as is known in the art. Sample synthesis tools include Design Compiler from Synopsis Precision Synthesis from Mentor Graphics Sinplify from Synplicity or XST from Xilinx. The synthesis tool behaves like an optimizing compiler which produces a NETLIST for producing an electrical schematic for a custom integrated circuit which is implemented with a minimum number of logic gates flip flops counters etc. The type of NETLIST generated depends on whether the customer desires to have a foundry specific device e.g. a Xilinx FPGA or a generic virtual NETLIST which is not specific to a particular vendor s product. Customers which are EDA electronic design automation vendors desire a non specific NETLIST. The NETLIST could be a foundry specific or virtual bitstream or binary file that is delivered to customer.

At step if the customer does not desire to have a digital integrated circuit delivered to them then at step the NETLIST is delivered to the customer otherwise at step the NETLIST is run through a place and route program which physically constructs the gates defined in the NETLIST on a silicon die and interconnects them. The choice of a place and route tool depends on whether the packet parser classifier is to be implemented as an ASIC fixed logic or an FPGA programmable logic . Sample place and route programs include Quartus II from Altera and ISE from Xilinx. At step the integrated circuit is delivered to the customer.

With reference to a block diagram of a graphical design environment using packet processing blocks according to the present invention for designing a packet processing product indicated generally at is depicted. The blocks can be implemented in a text based or graphical design environment. The environment includes combinations of any number of Packet Parsing Units PPUs PPUXs which are PPUs that can access CAM RAM memory Packet Modification Units PMUs and Decision and Forwarding Units DFUs . The PPUs PPUXs PMUs and DFUs can be connected by a designer in a variety of ways to create parsing classification logic for any desired packet processing algorithm. The PPUs operate on packet headers . The packet itself can be passed through the environment intact. Alternatively only the packet header is passed through the environment which requires the creation and passing of a pointer to the packet data to be output after the DFUs . The packets are stored in memory upon arrival and retrieved from memory upon departure. A copy of the header and a pointer to the packet location is passed to the development environment . The length of the copied header is variable. It starts at a programmable position in the header and ends at the last field that must be processed. A PPU takes a header and can seek i.e. locate any field of constant or variable length. Once the field is found in the header the PPU can perform a check on that field such as whether the field is equal to or greater than a given value or matches a particular value and then output that value depending on the operation performed.

PPUXs are PPUs that can perform lookups or searches using external random access memories RAMs or CAMs a CAM is defined as a RAM like memory which can determine whether an input value is present in the memory device . A PMU is a PPU which allows fields in the header of a packet or the packet itself to be modified by means of insertions deletions or substitution of bytes. In contrast the PPUs and PPUXs only allow the fields of a packet header to be examined. Any number of PPUs PPUXs and PMUs can be chained together in series or in parallel to implement complex expressions. The DFUs combine the output of one or more PPUs and or PPUXs and or PMUs using a programmable condition and then forward the header to one of a plurality of outputs. The outputs can represent Boolean True and False values and decisions as to whether to drop forward or queue the packet. The DFUs make decisions to forward drop or enqueue packets based on the results from the PPUs . For example the output of the last DFU in the chain such as the DFU labeled A can be a queue ID i.e. of the queue implemented in an external traffic manager .

The traffic manager is a device which performs a set of actions and operations for a network to guarantee the operability of the network. Traffic Management TM is exercised in the form of traffic control and flow control. In the context of the present invention the traffic manager operates on a packet stream once the classification processing is done on a packet i.e. once it passes from PPU DFU blocks . For example PPU DFU blocks are used to figure out the priority number of a packet. The traffic manager is given that priority number and the packet to do a traffic control operation to guarantee that high priority packets pass before low priority packets.

With reference to a block diagram of the PPU is depicted. The PPU performs basic parsing of the packet header and may perform mathematical logical operations on the parsed fields of packet header . The PPU includes a plurality of inputs and outputs . The function of each input and output as well as the values that each input or output handle are described with reference to Table 1 hereinbelow.

The terms in brackets in accompanying a specific input or output represents the bit width of the input or output in standard HDL syntax. For example if the input DataIn is to be 32 bits wide then the variable DW is set to 32 such that DataIn is expressed in an HDL file as DataIn DW 1 0 DataIn 32 1 0 DataIn 31 0 where 31 represents the last bit and 0 represents the first bit.

The input Clk is supplied from external hardware such as the clock of a microprocessor. The Input Rst is used to cause the PPU to go into a pre defined state where most internal variables and outputs are set to an initial value. This condition is usually needed at power up of the hardware in logic systems to stabilize the system before execution of a packet processing algorithm. The system is initially Reset. A predetermined amount of time later when it is known that all circuits have stabilized then the circuit is put into operation by toggling Rst .

The PPU includes a Hardware Lookup Unit HLU a Delay FIFO module containing an optional Delay Line or a FIFO a Match and Lookup Unit MLU Result Generation process Sequence Generation process an Output Alignment process interconnected as shown. The sub blocks are implemented as modules or processes. A module is similar to a class or subclass in an object oriented language like C while a process is similar to a function. The PPU also contains not shown a predetermined but limited number of internal general purpose registers for storing and retrieving values for comparisons lookups etc.

A stream of data is continuously presented to the input DataIn of the HLU . No data of the input stream is stored in a memory. In such circumstances it is the job of the HLU to extract information from a packet and present that information to the other blocks of the PPU . The HLU takes a snapshot of the data stream according to the location in the data stream specified by the inputs Index and Width . The inputs SOHIn EOHIn and InVal allow for fine tuning of locating data from the output of other PPUs PPUXs PMUs or external hardware. SOHIn EOHIn and InVal tell the PPU how to delimit data a packet header. SOHIn tells the hardware where packet starts and EOHIn tells the hardware when a packet header ends. Once the packet starts then at every clock cycle the data presented at DataIn is either valid or invalid as indicated by the input InVal . The extracted header bits are present as an output CompDat and as an input to the MLU . CompDat stands for the data that needs to be compared in the MLU .

The Delay FIFO module is used to synchronize the outputs of the PPU to be presented to a subsequent block such as a DFU. The Delay FIFO module is needed because the inputs to the PPU such as DataIn along with the control input signals SOHIn EOHIn and InVal need to be aligned in time in the Output Alignment process with intermediate outputs of other sub blocks of the PPU such as the Match output of the MLU which may be delayed relative to the inputs due to delays in processing within the MLU . The MLU performs its decision making e.g. a comparison of a bit within DataIn with a user specified parameter Param without full packet storage. Therefore DataIn along with the control input signals SOHIn EOHIn and InVal are pipelined to the Result Generation process and the Output Alignment process by way of intermediate I O Val i SOH i EOH i and Data i . There are fixed delays measured in clock cycles associated with processing in the in Result Generation process and the MLU . There is a variable delay associated with the HLU depending upon value of Index . The inputs described above must be delayed in the Output Alignment process by the sum of the aforementioned individual delays. For example if Index is then CompDat is received at the MLU eight clock cycles after DataIn arrives at the PPU . If the MLU processes CompDat in three clock cycles then the PPU inputs need to be delayed by 8 3 clock cycles in the Output Alignment process . The choice of the optional Delay Line or the FIFO depends on the size of the delay needed. A FIFO always works but requires using scarce memory in the PPU . Thus if only a few clock cycles worth of delay up to about clock cycles are needed then the Delay Line is used otherwise the FIFO is used.

The MLU performs the bulk of the packet parsing and classification operation to be performed on one unit of a packet processing algorithm. The MLU is programmable i.e. it can compare the data fields extracted in the HLU with values stored in internal registers by means of the inputs Opcode Param Param and Mask and declares a match or no match which appears on the internal output Match which in turn appears as an output of the Result Generation process . The inputs QualEnb and QualCond enable or disable the MLU depending on certain conditions. The operation to be performed in the MLU are enabled if the result of the check of the QualEnb using the QualCond is true. QualEnb is a value stored in a qualEnb register not shown which is user programmable through an address map. The Qualifier Condition can be Always True Equal Less Than Less Than or Equal Greater Than Greater Than or Equal etc.

For example if the user desires only to allow IPV6 packets then QualEnb can be programmed through the qualEnb register not shown to be the value 6. QualCond is set to Equal To EQ . The packet type is retrieved from a mode register from an external CPU. If the packet type is 6 IPV6 then the MLU is enabled if the packet type is 4 IPV4 then the MLU is disabled and no comparison takes place. If it is desired to have all types of IP packets then QualCond is set to Less Than or Equal LE or Always True.

The match no match functionality of the MLU is performed on the portion of the DataIn packet header pointed to by Index and Width . Additional inputs Mask Opcode input Param and optionally Param are needed to perform the comparison match no match operation. The MLU performs a seek and operation function.

The seek function finds a data field in a packet header not shown based on an offset from the start of the packet header indicated by the input Index . If Index is 0 then the first byte of the packet header is indicated. An Index of six indicates the seventh byte from the beginning of the packet header. The interconnections that can be made to the Index input include a fixed value e.g. 4 a value stored in an internal user defined control register or the result output of another PPU PMU or DFU. If the Index input is driven from another PPU PMU or DFU the value placed on the Index input is variable depending on the condition s evaluated in the previous PPU PMU or DFU.

The operation function performs a check an extraction or a lookup on Data Field which is the contents of the packet header pointed to by the Index input of width equal to the value in bits placed on the Width input . The general expression of the operation is Op Data Field AND Mask Param1 Param2 The Data Field may be filtered AND ed with the Mask input . Op is one of the opcodes placed on the Opcode input given the Param input and optionally the Param input . The types of operations are shown in Table 2 below 

For example a single MLU can be programmed to check if an IP address less than 224.XX.XX.XX by specifying the following values 

As another example to point to the beginning of an Ethernet frame payload for both untagged and VLAN tagged frames 

The inputs MapWrRd n MapAddr and MapWrData and the output MapRdData are used as the interface between an external microprocessor and the internal registers of the PPU to allow for reading of and writing to the registers. The PPU PPUX PMU and DFU can contain a user defined number of internal registers for packet header manipulation either internally or via an external microprocessor. The opcodes LUP and SPCL can be used to directly manipulate data in internal registers.

The output Match of the MLU is fed to the input of the Result Generation process to be described hereinbelow. The Match output is True if the operation performed in the MLU is True or False otherwise. The Result Generation process takes the Match output the outputs of the Delay FIFO module and optionally a tag value present on TAG and produces the result output iResult which is fed as an input to the Output Alignment process and ultimately is the output Result of the PPU . The Result Generation process also outputs iResVal which indicates when iResult is valid. This is needed as a handshaking device since result generation can take more than a single clock cycle. iMatch is the value of Match passed along from the MLU . Assuming the MLU was enabled iResult can take on two values corresponding to the True or False evaluation of the operation performed in the MLU . The True False result values can be fixed or an arithmetic or logical function of any of the PPU inputs. The iResult output is later passed through the Output Alignment process to be described hereinbelow as Result which can be used to drive a DFU input or any input of another PPU or a PMU. Result can also be a complex expression that the user may want to program. This allows the Index QualEnb Opcode or Param inputs of a PPU to be driven with different values depending on the Result output of other PPUs.

The PPU generates or forwards a sequence number using the Sequence Generation process . The sequence number can optionally come from an external process hardware via the input SeqIn and passed along to a DFU otherwise sequence numbers are internally generated within a PPU using the Sequence Generation process . The sequence number which appears as an internal output iSeq is passed through the Output Alignment process to a DFU through the PPU output SeqOut . Sequence numbers are incremented sequentially for each use of a PPU and are used for internal synchronization of all the inputs of a DFU. Sequence numbers are needed because different PPUs can present their output packet header data match data and results at different times. For example one PPU may index at bit of an incoming packet in which case match output may appear at an input to a DFU after three clock cycles. If another PPU indexes on a VLAN type field then index is set to block or which gives its results to the same DFU after 6 3 clock cycles. The DFU takes the matches packet headers and sequence number from each of the PPUs and arranges them in correct sequence to be described hereinafter.

The Output Alignment process aligns all outputs to the start of packet SOP or the end of packet EOP . This is done in order to provide proper delineation of the output signals of one PPU to the next PPU PPUX PMU DFU. For example if PPU is connected to PPU and PPU operates either on an 802.3 Ethernet frame or an Ethernet type 2 frame then PPU examines a byte field which is either 20 bytes or 40 bytes from the beginning of a packet header. Therefore all outputs of PPU need to be aligned on SOP as a requirement for input to PPU. As another example some protocols use trailer insertion e.g. inserting a checksum at the end of a packet. Therefore outputs are aligned at EOP.

With reference to a block diagram of a PPUX is depicted. A PPUX has the same I O signals and sub blocks as the PPU except for additional I O needed to access an external CAM RAM . Elements illustrated in which correspond to the elements described above in connection with the PPU of have been identified by corresponding reference numbers increased by one hundred. Unless otherwise indicated both the PPU and the PPUX have the same construction and operation.

In a PPU as mentioned earlier there is a predetermined number of internal registers memory which can be programmed by a user. A typical need for programmed memory is for performing a lookup of values by MLU . For example if there is a need to compare Param to one hundred IP addresses then internal memory is used. However if the number of lookups and hence values to be stored in memory is on the order of thousands of bytes or more then it may be necessary to store and retrieve these values to from an external CAM RAM .

With reference to a block diagram of a Packet Modification Units PMU is depicted. A PMU allows for modification i.e. insertion deletion or replacement of bytes in a packet including both the header and payload data. The PMU includes a Delay FIFO module containing an optional Delay Line or a FIFO a Modification Unit MU a Result Generation process a Sequence Generation process and an Output Alignment process interconnected as shown. These sub blocks are implemented as software modules or processes.

The inputs InVal SOHIn EOHIn DataIn TagIn Rst and Clk have the same functionality as is found in the PPU and the PPUX . The delay FIFO module can be used to synchronize the inputs InVal SOHIn EOHIn DataIn and TagIn with the outputs of the Result Generation Process and the outputs of the Modification Unit MU as is done in the PPU but it also provides a second function to delay incoming packet data by an amount equal to the number of bytes that may be inserted into a packet in the Modification Unit . This delay is not needed for removing or overwriting data in a packet. As with the PPU the choice of the optional Delay Line or the FIFO depends on the size of the delay needed. If only a few clock cycles worth of delay a few words to be inserted are needed then the Delay Line is used otherwise the FIFO is used. As with the PPU InVal SOHIn EOHIn and DataIn are pipelined to the a Modification Unit MU as the intermediate outputs Val i SOH i EOH i and Data i .

Val i is also directed to the Result Generation Process . The Result Generation Process has a different purpose from the one found in a PPU . The intermediate outputs iResVal result valid and iResult the result are not based on a field value but reflect the number of bytes inserted. Like a PPU iResult becomes the output Result which can be used as an input to another PPU PPUX PMU DFU. It can also be a complex expression that the user may want to program. The Sequence Generation Process with the optional SeqIn input has the same functionality as in the PPU .

The Modification Unit MU inserts modifies removes data as specified by a user. The MU is specified at preprocessing time as one of an inserting type modifying type or removing type PMU. The type of operations performed by the input signals ByteOffset ByteValid and ByteData are shown in Table 4 below 

The inputs MapWrRd n MapAddr and MapWrData and the output MapRdData provide a future programming interface for an external microprocessor to allow for the reading and writing from to internal registers of the PMU to for example dynamically program an MU to either insert delete or modify a packet at run time. Val i SOH i and EOH i are passed after a delay intact from their corresponding inputs to the MU to the Output Alignment process . The modified packet represented as the intermediate input output Data i is also presented to the Output Alignment process . The Output Alignment process has the same purpose and functionality as found in the PPU or PPUX i.e. aligning all intermediate outputs iSeq iResVal iResult Vali i SOH i EOH i and Data i on either the start of packet SOP or the end of packet EOP to become the aligned outputs SeqOut OutVal SOHOut EOHOut DataOut ResVal Result and TagOut .

With reference to a block diagram of a Decision and Forwarding Unit DFU is depicted. The DFU performs drop queue or forward operations based on input from 1 to N PPUs PPUXs PMUs or other DFUs. The DFU includes a plurality of inputs and outputs . The function of each input and output as well as the values each input or output can take on are described with reference to Table 5 hereinbelow.

Referring again to the DFU includes sub blocks Latch Data Selection MUX Result Generation process and Output Alignment process . The triangles within are for blocking together intermediate outputs and do not themselves have inherent functionality. All sub blocks are processes. Latch latches the incoming results data and other output signals coming from 0 to N 1 PPUs PPUXs PMUs to be processed at a later time inside the DFU . The Latch are necessary since each PPU PPUX PMU may present packet data at different times. Four signals from each Latch namely iDValIn iSOH iEOH and iData corresponding to the latched inputs DValIn SOH EOH and Data respectively and representing together data signals from each PPU PPUX PMU belong to groups which are fed together to the Data Selection MUX . Likewise four signals from each Latch namely iRInVal iMln iRIn and iRInSeq corresponding to the latched inputs RInVal MIn RIn and RInSeq respectively and representing together control result signals from each PPU PPUX PMU belong to groups which are fed together to the Result Generation process MUX . The Data Selection MUX selects one of the sets of N 1 data groups and forwards the data group to the output group which includes iDValOut iSOHOut iEOHOut and iDOut as inputs to the Output Alignment Process . The Result Generation Process has a similar purpose to that found in the PPU PPUX namely generating a result iRout which depends on the evaluation of a programmable logical expression which may depend on the value of the inputs RIn 0 N 1 and or Min 0 N 1 . In addition the evaluation of this complex logical expression can determine an output port to which the packet is to be routed i.e. the pass along queue outputs A and B or the drop port D represented as active high enabling intermediate outputs iROutAVal iROutBVal and iROutDVal . These outputs are passed along to the Output Alignment Process which has the same purpose and function as the PPU PPUX and PMU . The intermediate outputs become the DFU outputs DValOut SOHOut EOHOut DOut SeqOut ROutAVal ROutBVal and ROutDVal and Rout respectively.

With the addition of a group of external AND gates and control outputs ROutAVal ROutBVal and ROutDVal the output DOut is routed to one of three output ports DOutA DOutB or DOutD . Typically DOutA and DOutB can be used for normal output and DOutD can be used for dropping a packet not shown . Alternatively DOutD can be used as a third routing output port. For the normal ports DOutA and DOutB the packet is either forwarded to a destination or another chain of PPUs PPUXs PMUs or sent to a queue of a traffic manager.

As an example of the operation of the Data Selection MUX and Result Generation process if the DFU has two PPU inputs DIn and DIn and two match inputs Min and Min then the following conditions exist 

The design environment of the present invention can be connected to a set of internal PPU PPUX PMU DFU registers and programmed through a microprocessor interface. The operations that the microprocessor would perform are reads and writes to from the registers. Table 6 below shows a sample interface for a microprocessor manufactured by Freescale Inc. formerly Motorola 

The possible types of interconnections between DFUs and PPUs are numerous. Depending on the application the control inputs of the PPUs or DFUs can be driven with fixed values hardwired from programmable registers or from the outputs of other PPUs or DFUs. Table 7 shows the options for control signal connections with some typical examples of standard packet processing 

With reference to a block diagram is depicted showing a sample packet processing algorithm design using the present invention. In this example the packet processing algorithm relates to extracting the precedence field of an IP packet for a VLAN Non VLAN frame from a packet header belonging to a packet . Pseudo code which implements the two DFUs and the three PMUs of can be found in Appendix H L. A top level file for the example of expressed in pseudo code can be found in Appendix M. The precedence field is used as the QID of the queue into which the packet is to be stored in a traffic manager. The packet header is fed to a DataIn input of a PPU . The PPU determines first whether the inputted packet header belongs to a virtual LAN VLAN frame or a non VLAN frame by pointing to byte of the header Index 12 with a field width of 2 bytes. The operation to be performed is Data Field byte 12 width 2 AND Mask 0 Param1 08100 Param2 0 If packet header points to a VLAN frame then the Result output of the PPU is set to point to the location or offset in the packet header of the IP address in a VLAN type frame otherwise it points to the location in the packet header of the IP address in a non VLAN frame. This IP address is fed to the Index input along with the header to a second PPU . In the PPU the most significant byte is checked and must be less than signifying that the input IP address is valid. The operation to be performed is Data Field byte of address width 1 AND Mask 0 Param1 224 Param2 0 

The packet header is then passed to the Din input of a DFU . If the DA field of the IP address is 224.0.0.0 then the packet is to be dropped by placing the header on the DOutD output of an AND gate connected to the DFU . Otherwise the packet is forwarded to a third PPU with the Index input of the PPU pointing to the type of service field ToS in the header based on whether the packet belongs to a VLAN or non VLAN frame. The ToS tells the application how a datagram should be used e.g. delay precedence reliability minimum cost throughput etc. Depending on the value of the ToS field one can change a priority assigned to a packet which is then sent to a traffic manager which processes the packet based on the set priority.

In the PPU the IP precedence field is extracted from the header with the following operation Data Field byte field location width 1 AND Mask 0 Param1 2 start Param2 3 len 

The IP precedence field is fed to the Din input of a second DFU . The DFU places the packet header on the DOutA output of an AND gate for queueing and the precedence field is placed on the DOutB output of an AND gate . The precedence field functions as the Queue Identifier QID for the packet to be queued and both inputs are fed to a traffic manager . The traffic manager outputs the classified packet on output and the QID on output .

The present invention is subject to numerous variations and modifications. For example the packet processing blocks having other types of functionality can be provided such as 

As an alternative to a textual programming interface for implementing a given packet parser classifier the programmer designer can use a graphical design program such as OrCAD or Microsoft Visio to draw and interconnect sub blocks with input windows for entering interconnecting expressions and entering program inputs.

The present invention has several advantages over prior art packet processing products. The present invention can be used to produce an inexpensive piece of digital hardware while the prior art products are limited to programs running on a microprocessor. The present invention is scalable to handle simple to complex classification tasks and software modules can be connected and configured in a variety of ways.

It will be understood that the embodiment described herein is merely exemplary and that a person skilled in the art may make many variations and modifications without departing from the spirit and scope of the invention. All such variations and modifications are intended to be included within the scope of the present invention as defined in the appended claims.

