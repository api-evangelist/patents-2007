---

title: Lightweight directory access protocol (LDAP) schema definition using extensible markup language (XML)
abstract: A computer receives a schema that lacks information required by a directory access protocol (e.g. LDAP) and automatically generates information that conforms to the directory access protocol and supplies the generated information as output in a new schema. Such automatic schema transformation allows a human who is creating the schema, to enable usage of the directory access protocol to interface with a directory implementing the schema, without knowing the directory access protocol. The computer of some embodiments receives the schema being input, in a predetermined human-readable language (e.g. XML). Hence, an XML developer who lacks knowledge of LDAP can use traditional XML tools to prepare an LDAP-incompatible schema, for use in implementing a directory (e.g. address book) that is accessed by an LDAP client (e.g. cell phone) via an LDAP server. The new schema can be output in any form (e.g. text/binary) and in any language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07873678&OS=07873678&RS=07873678
owner: Oracle International Corporation
number: 07873678
owner_city: Redwood Shores
owner_country: US
publication_date: 20070730
---
Lightweight Directory Access Protocol LDAP is a well known standard defined by Internet Engineering Task Force IETF to enable server computers to provide directory services to client computers. The client computers may contain various application programs such as an email tool which makes a TCP IP connection to an LDAP server computer to look up entries maintained in a directory by the LDAP server. Each entry in such a directory contains information such as a URL about an object such as a file . Each entry in the directory has several attributes and each attribute has a particular syntax which identifies the types of values that can be associated therewith. Syntax definition for attributes in the Lightweight Directory Access Protocol may conform to a standards document called RFC 2252 which is available at the following website wherein should be replaced by and replaced by . 

Note that this format for URLs is followed throughout this patent application. Some attribute types are defined by the International Telecommunication Union ITU T in ITU T Recommendation X.520 Information Technology Open Systems Interconnection The Directory Selected attribute types. In order to create an LDAP directory it is common for a human to design objects and attributes which form a schema. See for example an article entitled LDAP Schema Design by Andrew Findlay February 2005. Such an LDAP schema can be expressed in human readable form in a format called LDAP Data Interchange Format LDIF as described in a standards document called RFC 2849 which is available at the following website wherein should be replaced by and replaced by . 

LDIF is typically used to import and export information to from an LDAP directory. The LDIF format can also be used to describe a set of changes which are to be applied to an LDAP directory. LDIF can further be used for bulk loading of data. For additional information on using LDIF see a document available at the following website wherein should be replaced by and replaced by . 

Although the LDIF format is human readable it has a very specific syntax and grammar which cannot be directly parsed by tools that handle Extensible Markup Language XML documents such as a browser. For example LDIF uses special characters such as a hash sign a comma a plus sign a backslash and a semicolon to have a specific meaning when used an LDIF document. In order to use XML tools the information in an LDIF document can be expressed in a variant of XML defined by The Organization for the Advancement of Structured Information Standards OASIS which is called Directory Service Markup Language DSML . Currently DSML has two specifications a first specification DSMLv1 that can be used to represent the state of a directory and a second specification DSMLv2 that can be used to represent operations an LDAP directory can perform and the results of such operations. More information on DSML can be found at the following website for OASIS wherein should be replaced by and replaced by . 

Note that in the above URL the should be replaced by . The approach of DSML as defined in this OASIS standard is not to abstract the capabilities of LDAP directories but instead to faithfully represent LDAP directories in XML.

Hence even though DSML is a form of XML it appears to so closely follow LDAP that it is necessary for humans writing this variant of XML to have some knowledge of LDAP. Specifically even if a human is creating a schema for a directory using an XML editing tool and this human is hereinafter XML developer they still need to know some aspects of LDAP. For example the XML developer must know that LDAP names are fully qualified i.e. start from the root rather than relative names. As another example the XML developer must supply an identifier for each attribute and ensure that the identifier remains globally unique over the lifetime of the product. As yet another example the XML developer must identify a type for each attribute to be one of structural abstract and auxiliary as per the LDAP. Inventors of the invention described below believe that requiring the XML developer to know LDAP makes it difficult to use an LDAP server for most applications because most XML developers are not familiar with LDAP.

In accordance with the invention a computer receives as input a schema that lacks information required by a predetermined protocol for interfacing with a directory automatically generates information that conforms to the directory access protocol based on the input schema and supplies as output a new schema that includes the generated information. The predetermined protocol is hereinafter referred to as a directory access protocol and an example of such a protocol is the LDAP standard.

Depending on the embodiment of the invention automatic generation of information can be implemented by programming the computer to perform two or more of the following acts copy information from the input schema into the output schema if present in a form compatible with the directory access protocol translate the information if present in an incompatible form create any information that is missing but is required by the directory access protocol and disregard information present in the input schema that is not required by the directory access protocol.

The schemas being input to and output by a computer of the type described above can be expressed in any form depending on the embodiment e.g. binary form and or text form. In illustrative embodiments the input schema and the output schema are both expressed in a text form. Moreover the input and output schema s can be expressed in any predetermined language s . In some embodiments the input schema is expressed in XML while the output schema is expressed in one of LDIF and DSML . In some embodiments the input schema is expressed in XML while the output schema is expressed in either LDIF or DSML formats.

A computer is programmed in several embodiments of the invention to execute a process to transform an input schema prepared without knowledge of a predetermined directory access protocol into an output schema that conforms to the directory access protocol. Hence the computer allows a human who prepares the input schema to enable usage of the directory access protocol e.g. LDAP to interface with a directory implemented using the input schema even if the human is personally ignorant of the directory access protocol e.g. LDAP . Hence use of the computer eliminates a prior art need for the human to learn the directory access protocol in order to use the directory access protocol. Therefore lack of personal knowledge of the directory access protocol is no longer a deterrent to its use. Instead the human simply prepares their input schema using any tool such as a visual editor that parses the predetermined language of the input schema e.g. XML and thereafter uses the programmed computer to supply output compliant with the directory access protocol.

In an illustrative embodiment shown in a computer receives as input a file which has been prepared by an XML developer using an XML tool . Note that XML developer has no LDAP knowledge. Hence file lacks at least some LDAP required information such as fully qualified names and globally unique object identifiers. Note that file is expressed in XML which is a human readable markup language based on tags. Specifically in the illustrative embodiment of file is prepared by XML developer by editing and extending a predetermined XML file . Specifically in the illustrative embodiment of file is prepared by XML developer following the XML structure defined in the XML schema .

XML tool allows XML developer to prepare an XML file illustrated in in conformance with a number of predetermined constraints which are defined in an XML schema such as XSD file illustrated in . The XML schema may be defined in some embodiments in conformance with the W3C standard available at the following website wherein should be replaced by and replaced by . 

Referring to XSD file describes the structure content and semantics of an XML files such as file to be created by tool as follows. XSD file refers to a standard name space A which identifies with the prefix xsd a URL for definitions of various data types such as element complexType annotation etc. XSD file also refers to a custom name space B which identifies as a default name space another URL for definitions of additional data types such as ObjectClasses ObjectClass etc. XSD file also defines a target name space C which identifies the URL for XML documents that are output by the XML tool such as XML file . Note that the URL of the target name space C is included in the XML files output by tool as their default name space.

XML LDAP transform tool uses this default name space in interpreting the XML file . XML LDAP transform tool also needs the schema i.e. XSD file to interpret XML file and finds this schema in one of several ways as follows. The first way is that XML LDAP transform tool may already have the XSD file and finds it by matching the default name space URL of the XML file with the target name space URL of the XSD file . A second way is that the XML file may provide an optional schema location attribute which is a URL in this case and XML LDAP transform tool downloads the schema from this URL. A third way is that XML developer may supply the XSD file together with the XML file and specify the name of the XSD file again in the schema location attribute which is a URL followed by a file name .

XML schema element defines the XML ObjectClass which is to be created by XML tool in the XML file . The structure of XML schema element illustrated in conforms to the W3C standard available at the following website wherein should be replaced by and replaced by . 

However the values in element are specified differently in different embodiments as described below for an illustrative embodiment.

XML schema element uses a schema data type which is named for example as objectClassType. This schema data type provides a definition of various LDIF required data of the object class to be provided by the XML developer via tool such as unique name N which identifies this class itself a globally unique object identifier O a superior attribute S to identify who is the parent of the current object class a human readable description D mandatory must attribute s M which are required for creation of instances of the object class optional may attribute s Y and a type attribute T. In the illustration shown in the XSD file makes it mandatory on the XML tool to obtain from the XML developer the value of a single attribute namely unique name N. Note that all other attributes of the XML element ObjectClass are developer optional as they are not required by XML tool when operating in conformance with XSD file of . One or more such attributes may be made developer mandatory in a manner similar to the unique name attribute e.g. by replacing the keyword optional with the keyword required in the XSD file.

Attribute s M are mandatory for the end user i.e. required to be provided by an end user of the LDAP server via client when creating an instance of this object class in directory . Note that directory of some embodiments includes a database server bundled therein and supports storage of the directory information into a persistent store . Store may also hold other application data which may be placed therein by the database server accessed via path by an application in the client . Such an application typically works with user profile which is stored in the directory storage in store and also works with other data which is application specific. For example an email application in client stores user s email messages in the application data storage in store in addition to the user s profile user name phone numbers and email addresses in the directory storage in store . XML developer via tool may specify one or more user mandatory attributes M e.g. may specify at least attribute cn in one illustrative embodiment. Note that attribute cn is a predetermined attribute which is supported in every LDAP server as per the LDAP standard. In the attributes cn and Name are examples of two mandatory attributes A M required in an XML file in that has been prepared in conformance with the XSD file in .

Attribute s Y are optional on the user user optional attributes i.e. need not be provided by the end user of the LDAP server via client when creating an instance of this object class in directory . XML developer via tool may specify zero or more optional attributes Y. In the attributes DisplayName GlobalUID Manufacturer Model CreatedDate and LastModifiedDate are examples of optional attributes A Y which may be provided by the end user when creating an entry in directory in conformance with the LDIF file . Note that another objectclass I may have one or more optional attributes which are different. The attributes address Normalizedaddress Carrier Encoding DeviceID etc. are examples of other optional attributes I Y that are allowed by the XML file in that has been prepared in conformance with the XSD file in .

Schema data type includes an XML schema element which is defined in conformance with an XML schema complex type which is named for example as attributeType. This type provides definitions of several LDIF required data of the attribute type to be provided by the XML developer via tool such as a name attribute N which identifies this attribute itself which is developer mandatory an object identifier O developer optional which must be unique among all other object classes and attributes a superior attribute S developer optional which indicates if this attribute is derived from another attribute type a human readable description D syntax attribute X which is an object identifier for an existing syntax e.g. 1.3.6.1.4.1.1466.115.121.1.15 which is the object ID for the syntax of Directory String single value attribute V which identifies whether this attribute is single valued or multi valued with the default being multi valued a comparison attribute C which identifies a matching rule name e.g. caseIgnoreMatch which is the name of the rule which is predefined in the LDAP server and a usage type attribute U which defines usage of the attribute.

The value of usage type attribute U can be one of the following four predefined values 1 userApplications 2 directoryOperation 3 distributedOperation 4 dSAOperation. userApplications means the attribute values are user modifiable directoryOperation means the attribute values are not user modifiable but rather maintained by LDAP server automatically distributedOperation means the attribute value is shared across multiple LDAP server dsaOperation means the attribute values are useful for a specific LDAP server for it s own use. For more detailed information on syntax attribute X see section 4.3 entitled Syntaxes in RFC 2252 which has been incorporated by reference elsewhere herein.

In XSD file illustrated in type attribute T is of an enumerated type with precisely three LDIF values which are listed in type definition . These three enumerated values are specified in the LDAP specification for X.500. Hence each object class is required to be precisely one of these enumerated three kinds 1 abstract object class A which is used to derive other object classes defining attributes of such object classes that are identical and an entry in the LDAP directory tree must belong to one of the other object classes 2 structural object class S which is defined in the specification of the LDAP directory schema and used in the definition of the structure of object names along with an associated DIT content rule to control the content of an entry and also define the structure of the DIT 3 auxiliary object class X which may be used in the construction of entries of several types and are used to extend an object created with a specific structural objectclass 

The LDIF required data in XML file is used by XML LDAP transform to create in LDIF file with each objectclasses entry I which is one of any number of such entries A N that may be created in this manner. Each entry I includes the corresponding LDIF required data such as unique name I N of the class object identifier I O superior type I S. Note that matching suffixes preceded by a hyphen N O S etc are used in the reference numerals to illustrate correspondence of data in the XSD file of and the LDIF file of . If a globally unique object identifier O is not provided by the user then XML LDAP transform tool generates the identifier.

As noted above an XML file shown in is prepared in conformance with the XSD file in by XML tool based on information obtained from XML developer . More specifically XML file is prepared to contain a number of XML elements A . . . I . . . N corresponding to the objectclasses entries A . . . I . . . N in the LDIF file . Each XML element A is prepared by XML tool to contain a number of attributes such as attribute A N for name of the object class which correspond to the attributes in the XSD file such as name attribute N .

XML LDAP transform tool interprets XML file based on the schema defined in the XSD file . In doing so XML LDAP transform tool initially validates the XML file using XSD file . Then XML LDAP transform tool composes LDIF file based on developer specified information from XML file and default information in XSD file . In composing file XML LDAP transform tool uses two kinds of values from file namely values of developer mandatory attributes and additionally any values of developer optional attributes. To the extent that any values of developer optional attributes are not specified in file XML LDAP transform tool obtains the corresponding default values from XSD file . For example the type attribute T in XSD file is illustrated as being optional in and if developer does not provide any value i.e. no value for type attribute is provided in XML element A in file in the corresponding default value auxiliary is generated as attribute A T in LDIF file .

In the example shown in the developer has chosen to use the same attribute names CreatedDate and LastModfiedDate in each of the three ObjectClasses A N and also specified the same object identifiers i.e. the values A CD I CD and N CD are the same and also the values A LMD I LMD and N LMD are also the same . In such a case XML LDAP transform tool generates a single attribute definition in LDIF file for each identical valued attribute. In the just described example a single attribute definition CD is provided in file for the CreatedDate attribute and another single attribute definition LMD is provided for the LastModifiedDate attribute. If the attribute names are the same and the object identifiers are different or vice versa then XML LDAP transform tool generates an error message and stops generation of the LDIF file. If a value for the object identifier is not specified by the developer for an attribute name then XML LDAP transform tool automatically assigns an object identifier as follows. If the same attribute name is used previously and has been associated with an object identifier either by the developer or by tool then that previously used object identifier is also associated with the later occurrence of the attribute name. If the attribute name is not previously used then XML LDAP transform tool generates a globally unique object identifier which is then associated with the attribute name.

XML LDAP transform tool initially starts generation of LDIF file with three statements A and B illustrated in as specified in the Internet Standard defined in RFC 2849 namely The LDAP Data Interchange Format LDIF Technical Specification available from the Internet Society. RFC 2849 is incorporated by reference herein in its entirety. First statement contains the specification of dn spec which identifies a distinguishedName. The value of distinguishedName is a configuration parameter for XML LDAP transform tool which is supplied on startup of tool . Second statement A contains a specification of changerecord which identifies a constant as the value for the parameter changetype namely the value modify note that the other values for this parameter are not used by tool . Third statement B continues the specification in statement A with an instruction to add attribute types. XML LDAP transform tool of this embodiment uses only the add instruction as shown in although other embodiments may use other instructions such as delete or replace.

XML LDAP transform tool thereafter generates a number of statements one for each new attribute to be added to directory as follows. For example statement includes a number of tokens A K as follows. Token A is the word attributetypes which is a constant for all statements for addition of attributes. Token A is followed by a colon followed by a space and followed by open parenthesis and followed by a space. This format is in conformance with section 4.2 in RFC 2252 which is strictly followed in this embodiment i.e. the location of colon and spaces and parenthesis is important . Next token B is the globally unique object identifier of the current attribute which is being defined. As noted above this identifier is obtained from attribute ObjectIdentifier labeled as item A O in the XML file wherein it was defined by the developer or alternatively if the identifier is not explicitly defined in file then the identifier is automatically generated by tool . Next a space is inserted after token B by XML LDAP transform tool .

Next a number of pairs of tokens are generated each token pair containing a term and a term value. The sequence of pairs relative to one another can be different depending on the embodiment although a specific sequence is illustrated in and described next.

Specifically in the illustrated embodiment token C is the constant NAME which is a term as specified in section 4.2 of the Internet Standard RFC 2252. RFC 2252 is entitled Lightweight Directory Access Protocol v3 Attribute Syntax Definitions and this document is also incorporated by reference herein in its entirety. Next a space is inserted after token C by XML LDAP transform tool . Then token D is generated as term value DisplayName surrounded by quotes which is obtained from by XML LDAP transform tool as the value of the Name attribute D of the corresponding attribute element in XML file . Next a space is inserted after token D by XML LDAP transform tool .

Then a second pair is generated by XML LDAP transform tool as follows token E is generated as the term DESC which is another constant also a term as specified in RFC 2252. Next a space is inserted after token E by XML LDAP transform tool . Then token F is generated as term value the display name surrounded by quotes which is obtained from by XML LDAP transform tool as the value F of the Description attribute F of the corresponding attribute element in XML file . Next a space is inserted after token D by XML LDAP transform tool . As noted above the order of the first pair relative to the second pair can be reversed in different embodiments.

Then a third pair is generated by XML LDAP transform tool as follows token G is generated as the term EQUALITY which is another constant also a term as specified in RFC 2252. Next a space is inserted after token G by XML LDAP transform tool . Then token H is generated as term value caseIgnoreMatch which is obtained from by XML LDAP transform tool as the default value C of Comparison attribute in XSD file . Next a space is inserted after token H by XML LDAP transform tool . As noted above the order of the third pair relative to the first and second pair can be different depending on the embodiment.

Then one or more additional pairs are generated by XML LDAP transform tool in a similar manner for the term s SYNTAX and or USAGE and or SINGLE VALUED as illustrated in . Implying the data type of attribute values and if an attribute can hold multiple values or not. Note that the just described pairs are generated while traversing a tree of Attribute elements constructed from file with each pair being generated only if it was not previously generated. On completion of traversal of the just described tree XML LDAP transform tool completes the generation of attribute types in LDIF file . Thereafter XML LDAP transform tool generates object types in LDIF file as discussed next.

XML LDAP transform tool generates three additional statements A and B in a manner similar to that described above for statements A and B as specified in the Internet Standard defined in RFC 2849. Statements and A are identical to statements and A. Statement B is similar to statement B with one difference as follows attributetypes is replaced with objectclasses . XML LDAP transform tool then generates a number of tokens in a manner similar to that described above for tokens A K with the first token here namely token A being objectclasses . Token A is followed by a colon followed by a space and followed by open parenthesis and followed by a space. This format for the objectclasses is in conformance with the attribute syntax definitions in section 4.4 of RFC 2252 which is also strictly followed in this embodiment i.e. the location of colon and spaces and parenthesis is important .

Next XML LDAP transform tool generates token A O as the globally unique object identifier of the current objectClass which is being defined. As noted above this identifier is obtained from attribute ObjectIdentifier as the value in the XML file wherein it was defined by the developer or alternatively if the identifier is not explicitly defined in file then the identifier is once again automatically generated by tool . Next a space is inserted after token A O by XML LDAP transform tool . Thereafter XML LDAP transform tool generates a number of pairs of tokens each token pair containing a term and a term value in the above described manner but this time for an objectClass. Here as well the sequence of pairs relative to one another can be different depending on the embodiment although a specific sequence is illustrated in and described next.

Specifically in the illustrated embodiment token B is the constant NAME which is a term as specified in section 4.4 of the Internet Standard RFC 2252. Next a space is inserted after token B by XML LDAP transform tool . Then token A N is generated as term value UserDevice surrounded by quotes which is obtained from by XML LDAP transform tool as the value of the Name attribute A N of the corresponding attribute element in XML file . Next a space is inserted after token A N by XML LDAP transform tool . Note that several such pairs of tokens are generated for the current objectClass with the term and term value in each token pair conforming to section 4.4 of the Internet Standard RFC 2252. After completion of token pair generation for the current objectClass the just described acts for the current objectClass are repeated for any number of such objectClasses depending on the corresponding definitions in the XML file .

XML file can be prepared using any traditional XML tools such as visual editors validators and document generators. Although the illustrative embodiment is described and shown for XML file expressed in the extensible markup language XML as will be apparent to the skilled artisan any other language can be used. For example any markup language in conformance with the Standard Generalized Markup Language SGML can be used instead of XML. XML and SGML are industry standards described at for example the website obtained by replacing dashes with dots in the following www w3 org. Moreover depending on the embodiment XML file can be expressed in any text based language and or XML file may even exist in binary form in some embodiments.

Note that XML file that is generated by tool is not compatible with LDAP and hence it cannot be directly input into any LDAP server program known to the inventors of this patent application such as Oracle Internet Directory OID available from Oracle Corporation of Redwood Shores Calif. Note that other commercially available LDAP servers that can be used in place of server described herein are as follows OpenLDAP IBM Tivoli Directory Server Sun Java System Directory Server Novell eDirectory and Microsoft Windows Server 2003 Active Directory.

LDAP incompatible XML file from tool is provided as input to a process in computer for transformation into an LDAP schema. Process also called XML LDAP transform process supplies an LDAP schema as output in a form appropriate for use in the normal manner e.g. to build a directory that is accessible to an LDAP client via an LDAP server process executing in server computer . XML LDAP transform process is implemented in some embodiments of computer by a processor performing at least three operations A C illustrated in . Specifically in operation A computer receives LDAP incompatible XML file and uses an XML parser illustrated in to generate an XML tree in memory . Referring back to in operation B computer traverses the XML tree and uses the XML information in each node to generate information for an LDAP node by using one or more of logics and or data .

Typically logic and or data are designed to generate LDAP information from XML information that has been prepared using the metadata in XML file . For example certain keywords in such metadata identify a logic and or a data to be used in generate operation B. Referring to in operation C computer supplies as an output of the XML LDAP transform process an LDAP schema obtained by serializing LDAP tree . The LDAP schema supplied by operation C is in the LDIF format or alternatively in the DSML format depending on the embodiment .

Although one specific embodiment is shown in and has been described above numerous modifications and adaptations will be apparent to the skilled artisan in view of this disclosure. Hence although a specific configuration with two computers and is shown in other embodiments may use more computers or fewer computers. For example a first alternative embodiment uses the computers for each executing a respective one of three processes and . In a second alternative embodiment all three processes and execute inside a single computer. In the second alternative embodiment in one variation thereof processes and are three separate and distinct processes whereas in another variation the individual operations of processes and are combined and executed in a single process. The just described single process of the second alternative embodiment interfaces directly with an XML developer in a manner similar to a prior art editor for XML documents and concurrently generates directory and either or both of XML file and LDAP schema depending on the embodiment. The just described concurrent operation illustrates lack of requirement to perform such operations in a specific sequence even though illustrative sequences are shown and described for a few embodiments in C A B and C.

In a third alternative embodiment two computers are used wherein process executes in one computer and processes and execute in the other computer. In the third alternative embodiment in one variation thereof LDAP server process and XML LDAP transform process are two separate and distinct processes whereas in another variation the individual operations of processes and are combined and executed in a single process. The just described single process of the third alternative embodiment accepts an XML file that is LDAP incompatible and directly builds directory as specified therein. For example the just described single process uses LDAP tree in its binary form i.e. without writing a file of LDAP schema in text form.

In some embodiments computer is programmed to perform one or more of acts illustrated in to implement the respective operations A C of . Specifically in act the computer reads an XML document and performs lexical analysis thereon to identify tokens. Next in act the computer parses the XML document that has just been read and creates in memory a tree hereinafter XML tree . The computer stores at each node of XML tree an XML object that was read in act . Therefore acts and implement operation A. Note that in some embodiments each node of XML tree contains an XML object that was read in act from file .

Next in act computer traverses XML tree i.e. visits each node therein called XML node one at a time. The traversal of tree may be performed in any order although some embodiments use a depth first method whereas other embodiments use a breadth first method. Then in act computer checks if the current XML node the node being visited is one of attribute type and object class or not. If yes then the computer proceeds to perform acts following which computer goes to act . If the answer was no in act the computer also goes to act . In act computer checks to see if all XML nodes have been visited in tree and if not then it returns to act and alternatively performs operation C i.e. tree has been completely traversed .

In act computer copies certain LDAP required information if such information is present in the current XML node. The information to be copied may be present in the current XML node depending on metadata in file according to which the current XML node was populated and or validated. The information to be copied is predetermined in some embodiments based on typical values that are used by XML developers. As illustrated by the XSD schema an example of which is shown in the attribute for Comparison is assigned a default value of caseIgnoreMatch . Note that the XSD statement identifies this attribute as being optional by the use tag in the XSD file. Hence the XML tool does not force the XML developer to specify the value for this attribute . If this value is not specified by the XML developer then the value is used by the XML LDAP transformer in the conversion process as illustrated in . Specifically the attribute is automatically translated to the LDIF attribute of value Equality followed by automatic insertion of the value of caseIgnoreMatch .

In act the computer translates any information in the current XML node which is required by LDAP but which is present in a different form. Examples of automatic translation in act include 1 lookup of templates store using a data type identifier as an index therein 2 string concatenation of a relative name with a path to form a fully qualified name and 3 syntax conversion to account for differences in grammar and or special characters. shows a typical syntax conversion scheme between XML attribute name in the first column and the corresponding LDAP attribute name in the middle column with comments in the third column indicating how the conversion is implemented. In the symbol in the middle column indicates that the conversion process ignores this attribute because the attribute is not required to be present in the LDAP tree. For example the XML attribute Comparison is mapped to the LDAP attribute EQUALITY as shown by the 5row in the table of .

Additionally in act computer creates any information that is missing from the current XML node and which is required by LDAP such as an object identifier OID that is globally unique. Such missing information which is needed by LDAP may be obtained from a default value in the XSD file as illustrated in . In act computer disregards any information in the current XML node that cannot be used by LDAP such as an upper limit and a lower limit on a value of an attribute .

After acts have been performed in any order relative to one another although one illustrative sequence is shown in computer performs act . Specifically in act the computer stores information generated by these acts in a node of an LDAP tree . As noted above after act the computer goes to act described above . If the answer in act is no then operation B is completed. Next in act computer serializes the LDAP tree resulting from operation B. The LDAP schema which results from such serialization can be supplied by computer in any predetermined form depending on the embodiment.

In some embodiments computer performs act to write this information to a file in a text form. File can be expressed in any predetermined language including a variant of XML called DSML or a text based language specific to LDAP called LDIF depending on the embodiment. File can be transmitted by computer to LDAP server process which executes in another computer e.g. by use of the HTTP protocol. Note that file can be expressed in a variant of LDIF which depends on the vendor and version number of LDAP server process e.g. customized for Microsoft or IBM LDAP server due to variations therebetween . In an alternative embodiment computer does not perform act and instead performs act to pass the LDAP schema in a binary form of tree to an LDAP server that is internal to computer .

A method for implementing acts of in some embodiments is illustrated in . Specifically in act computer uses the type information from the current XML node to identify a template in a library of templates. illustrates two templates one for the Attribute transformation and another for the Object Class transformation. Such transformations are used by XML LDAP process to create nodes in the LDAP tree from the nodes in the XML tree see . In the words that are surrounded by i.e. located between the signs are variables whose values are obtained from data in an XML node. Hence during the creation of the LDAP tree the value for the string Name is obtained from the value of the Name attribute in the corresponding XML node of the XML tree . For example the value of string Name in the LDAP tree is obtained from the object class called UserDevice see name A N in object class A in .

Next in act computer uses the identified template to create a node in the LDAP tree. Then in act computer copies the following information from the current XML node into the created node in the LDAP tree namely 1 name 2 superior description 3 single value 4 comparison and 5 usage type. During such copying as noted above the value in the XML node is transformed if necessary using the table in in some embodiments. Next in act computer checks to see if the current XML node contains an object identifier required by LDAP and if so goes to act and otherwise goes to act wherein the identifier is created and thereafter goes to act . Note that act may be implemented by some embodiments of the invention to generate a unique LDAP schema identifier which is based at least on current time for example in accordance with methods described in a specification available at the following website wherein should be replaced by 

In act computer stores the object identifier into the current LDAP node that was created in act . Next in act computer obtains the value of the syntax attribute from the current XML node and uses it to lookup a table see table in which yields an LDAP data type identifier. Next in act computer obtains the value of a length attribute in the current XML node and uses it with the LDAP data type identifier from table to add an LDAP data type to the current LDAP node. The length is used by LDAP server to enforce safety constraints in the use of LDAP data by client e.g. to prevent client from causing a buffer overrun by inserting data that is longer than the length as per RFC 2252.

Usage of computer which is programmed with XML LDAP transform process in one illustrative embodiment is now described in reference to . Note that items shown in have reference numbers which are identical to reference numbers shown in for corresponding items which are similar or identical. In this embodiment a client device executes a process to store data in and retrieve data from directory . Note that directory of this embodiment is implemented in a database that is accessed via a database server process . For this reason LDAP server process includes database client software for issuing a database query to a database server process which in turn performs an operation on directory and returns the results of the operation in a database response . Such a database query may be generated by the database client in LDAP server process in response to a directory search request from LDAP client and process eventually supplies the data from directory in the search results .

Although LDAP server process database server process and directory are shown in as being implemented in a single server computer in this embodiment they can be implemented in more computers as will be apparent to the skilled artisan in view of this disclosure. Furthermore although the description above refers to a single client device other embodiments can use one or more additional client devices such as device .

In the embodiment illustrated in LDAP client process executes software which contains business logic and software that provides an application programming interface API to the LDAP server process . Business logic software may be implemented in some embodiments in Java bytecodes. Business logic software is produced by a software editor which may optionally include a debugger that in turn receives instructions in a high level programming language from a human being called software developer . Note that in software developer and XML developer are shown to be two different persons although a single person who is knowledgeable about both programming and XML may perform these two roles as will be apparent to the skilled artisan.

In the embodiment shown in API software is automatically produced from the same XML schema that is output by the XML tool . Specifically in this embodiment a copy A of LDAP incompatible XML file is supplied to a process called XML API generation which automatically generates API software for interfacing with LDAP server . Also in this embodiment a copy A of API software is supplied to software editor which ensures at the direction of person that the API is appropriately invoked by business logic software . Although in the embodiment shown in software editor and XML tool are shown as two separate softwares in other embodiments a single software not shown may be used to perform the both functions i.e. preparation of XML file and preparation of business logic software . For example Oracle JDeveloper 10.1.3.3 can be used as an XML editor and software editor.

In the embodiment of business logic software and API software are separately compiled by a compiler in computer which compiler is not shown in and the resulting separate files are transferred to client device for use in execution process . In this embodiment client device is a computer such as a PC and API software is installed as a shared library e.g. a DLL in the operating system called WINDOWS and software may be installed as an application program an example of which is an email tool called OUTLOOK . In another embodiment the two softwares and are compiled and linked together to form a single executable file which is transferred to client device an example of which is a cell phone .

XML API generation process is implemented in some embodiments of computer by a processor performing at least three operations A C illustrated in . Specifically in operation A computer receives XML file A and uses an XML parser to generate an XML tree in memory. This operation to create the XML tree is very similar to the above described operation A of except that the output is Java source code representing the newly defined objects in the XML file. The second operation is very similar to that described in Java Specification Request 222 JSR 222 developed by the Java Community Process and entitled Java Architecture for XML Binding JAXB 2.0 which is available on the Internet.

Referring back to in operation B computer traverses the XML tree and for each node uses a type s value in the node to identify a template of software source code from a library of such templates. The identified template is then customized using for example a name s value in the node. Note that in this operation any information that was disregarded for generating the LDAP information for an LDAP node by operation A is used to further customize the identified template. For example if values for an upper limit and a lower limit are present in the current XML node these values are used to customize the identified template to perform range checking e.g. if the upper limit is 100 and the lower limit is 0 then software in the identified template is customized to check for these limits on a value of the variable being accessed in the directory which variable may be for example percentage of CPU utilization .

Operation B is designed to generate logic in the API software from XML information that has been prepared using the metadata in XML file . For example certain keywords in such metadata identify the range check to be performed by the API software . In an illustrative example the Length XML attribute which defines the length constraint of the String attribute value. Referring to in operation C computer supplies as an output of the XML API generation process an API software that is obtained by placing in a single file each of the identified templates after appropriate customization as per operation B.

In an illustration of embodiment business logic software is prepared by editor in the Java programming language and API software which interfaces to LDAP server is automatically prepared by process in the form of Java classes which conform to the Java Naming and Directory Interface JNDI standard extension to Java.

A method for implementing XML API generation process in some embodiments that use Java is illustrated in . Specifically in act an XML parser in computer uses the XML file A to construct an internal in memory tree see of objects and attributes defined in XML file A also known as a document object model DOM tree which is a first tree that is created in computer . Next in act an XML LDAP transform process in computer scans all business objects in the XML DOM tree and generates an in memory tree which is a second tree that is created in computer . This second tree is of Java objects that are needed to prepare the generated Java API. In preparing this second tree process ignores duplicate XML objects that may be present in the DOM tree i.e. the first tree . Additionally process resolves dependencies among objects in the DOM tree for example if a single attribute is redundantly defined in each of two objects in the DOM tree then the second tree of Java objects is prepared with just a single attribute and both objects refer to the single attribute.

Then in act computer identifies all cross references between business objects in the list and creates a list of references to be formed between the java objects i.e. reference attributes . For example as shown in the CreatedDate attribute is used three times see attributes A CD I CD and N CD in the respective three objects A I and N. Hence in the first tree i.e. in the XML DOM tree there are three nodes representing this single attribute three times once for each object. During the creation of the second tree comparison of the two values specifically the Name value and the ObjectIdentifier value of the attributes A CD I CD and N CD identifies them as being redundant. Hence when preparing the second tree i.e. the tree of Java objects the process inserts just one node for this attribute and inserts three nodes for the three objects to point to this single node. Note that if process finds during comparison that one of the two values is identical but the other value is different then process flags an error in the input XML file .

Next in act computer identifies all attributes e.g. built in data types supported by the Java Runtime Environment JRE as well as any user defined data types which were defined in XML file for all entities in the second tree of objects which can be mapped to the individual data types in java. In act computer generates accessor methods by customizing templates for Java objects using attributes identified in act and any reference attributes identified in act . Reference attributes are any attributes of user defined data types that reference one or more built in data types and or other user defined data types.

Examples of templates that are used in some embodiments are shown in . Specifically for object A process generates the software source code shown in FIG. D from the second tree described above and illustrated in . In this example an instance of the Java type ObjectClass with name UserDevice shown at the top of is used to create the new Java type class UserDevice in . Also in this example as shown in the ObjectClass with name UserDevice has an attribute with name Model and process generates the source code for getModel and setModel in the Java class UserDevice. The resulting Java source code is then supplied in act as an output of XML API generation process for use as an API. The source code is compiled to create Jar file s and or Java docs in act . Note that illustrates the result of performing the just described process for built in data types whereas the corresponding result for user defined data types is shown in . In addition shows the source code for a collection of attributes such as a list in this example.

The method of is used in some embodiments to program a computer system of the type illustrated in which is discussed next. Specifically computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information. Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor .

Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

As described elsewhere herein XML LDAP transformation is performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein and illustrated in . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications. Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . Local network may interconnect multiple computers as described above . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network commonly referred to as the Internet . Local network and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example computer might transmit and or receive an LDAP schema through Internet ISP local network and communication interface . The instructions for performing the method of may be executed by processor as they are received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain the just described instructions and any related data in the form of a carrier wave.

Note that is a very low level representation of many hardware components of a computer system. Several embodiments have one or more additional software components in main memory as shown in Operating System e.g. Microsoft WINDOWS XP or Linux in each of the three computers and Database Server e.g. Oracle Server v11g for the server computer Java Development Kit e.g. JDK v6 in each of the three computers and Java XMLParser e.g. xmlparser available from Oracle Corporation in computer LDAP server e.g. Oracle Identity Management 10g version 10.1.4.0.1 in computer and XML text editor e.g. Oracle JDeveloper version 10.1.3.3 in computer .

Numerous modifications and adaptations of the embodiments described herein will become apparent to the skilled artisan in view of this disclosure.

A computer implemented method of transforming schema to ensure compliance with a directory access protocol comprises 1 receiving a first schema incompatible with the directory access protocol 2 parsing the first schema to create a first tree in memory 3 traversing the first tree to create a second tree 4 storing in a second node in the second tree second information conforming to the directory access protocol 5 wherein the second information in the second node is generated based at least partially on first information in a first node in the first tree and a definition of the directory access protocol and 6 preparing a second schema compatible with the directory access protocol based on a plurality of second nodes in the second tree including said second node.

In certain embodiments a method of the type described in the previous paragraph is used by a web service running in a web server on a first server computer which communicates with a second server computer running the LDAP server . Depending on the embodiment the first server and the second server may be both implemented in the same computer or on two different computers. In such embodiments the web service permits client applications in client computer to add new LDAP data types to the LDAP server at run time i.e. after the LDAP server is configured and has started normal operation .

Numerous modifications and adaptations of the embodiments described herein are encompassed by the scope of the invention.

