---

title: Enhanced security and performance of web applications
abstract: A client-side enforcement mechanism may allow application security policies to be specified at a server in a programmatic manner. Servers may specify security policies as JavaScript functions included in a page returned by the server and run before other scripts. At runtime, and during initial loading, the functions are invoked by the client on each page modification to ensure the page conforms to the security policy. As such, before a mutation takes effect, the policy may transform that mutation and the code and data of the page. Replicated code execution may take place at both the client and the server where the server runs its own shadow copy of a client-side application in a trusted execution environment so that the server may check that the method calls coming from the client correspond to a correct execution of the client-side application The redundant execution at the client can be untrusted, but serves to improve the responsiveness and performance of the Web application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08677141&OS=08677141&RS=08677141
owner: Microsoft Corporation
number: 08677141
owner_city: Redmond
owner_country: US
publication_date: 20071123
---
Web applications provide end users with client access to server functionality through a set of Web pages. These pages often contain script code to be executed dynamically within the client Web browser. Most Web applications aim to enforce security policies such as for Web based e mail disallowing any scripts in untrusted e mail messages. However Web applications are subject to attacks such as cross site scripting cookie theft session riding browser hijacking and self propagating worms.

Of the current attacks on Web applications those based on script injection are by far the most common. For example script injection is used in cross site scripting and Web application worms. A script injection vulnerability may be present whenever a Web application includes data of uncertain origin in its Web pages e.g. a third party comment on a blog page is an example of such untrusted data. In a typical attack malicious data with surreptitiously embedded scripts is included in requests to a benign Web application server. Later the server may include that data and scripts in Web pages it returns to unsuspecting users. Since Web browsers execute scripts on a page with Web application authority these returned scripts can give attackers control over the users Web application activities and or client devices.

A client side enforcement mechanism may allow application security policies to be specified at a server in a programmatic manner. Servers may specify security policies as JavaScript functions included in a page returned by the server to a client and run before other scripts. At runtime and during initial loading the functions may be invoked by the client on each page modification to ensure the page conforms to the security policy. As such before a mutation defined as any modification to the structure including data and code of the page takes effect the policy may transform that mutation and the code and data of the page.

Replicated code execution may be used on both the client and the server where the server runs its own shadow copy of a client side application in a trusted execution environment so that the server may check that the method calls coming from the client correspond to a correct execution of the client side application. If the server receives a call from the client that is not issued by its trusted shadow copy the server may ignore this call or raise a security alert.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Although the implementation is described with respect to documents that are pages it should be understood that the environment can include any data and or objects having content and connectivity that can be characterized.

The technology infrastructure of the Web may include server software content syndication messaging protocols standards based browsers with plugins and extensions and various client applications. These differing yet complementary approaches provide the Web with a growing set of information storage creation and dissemination capabilities.

The servers may provide rich Internet application techniques including but not limited to Ajax based semantically valid XHTML and HTML markup microformats enriching pages with additional semantics Cascading Style Sheets CSS to separate presentation from content and REST and or XML and or JSON based APIs. In addition the servers may provide RSS or Atom feeds merged content from different sources e.g. mashups weblog publishing tools Wiki or forum software etc.

In some implementations Web based applications and desktops may be provided. Ajax may provide applications that mimic personal computer applications such as word processing the spreadsheet and slide show presentation. In other implementations browser based operating systems or online desktops may be provided that act as application platforms. These services mimic the user experience of desktop operating systems offering features and applications similar to a PC environment. They have as their distinguishing characteristic the ability to run within any modern browser.

In some implementations client applications may interact with data stored on servers . This may be accomplished through forms in an HTML page through a scripting language such as JavaScript or through Flash Silverlight or Java. These methods make use of the client to reduce server workloads and to increase the responsiveness of the application.

In some implementations client applications may include a security mechanism e.g. policy enforcement engine to enforce security policies based on monitored client application behavior. The security mechanism may support policies that range from disallowing use of certain Web client features e.g. IFRAMEs or OBJECTs to fine grained application specific invariants such as taint based policies that regulate the flow of credit card information input by the user.

In some implementations the security mechanism may utilize Mutation Event Transforms METs that allow Web application security policies to be specified at the server in a programmatic manner using a per control policy definition framework such that the specifications may be used directly for enforcement at the client . In an implementation a security policy mechanism which may implement METs may be coded as follows 

Using METs servers may specify security policies as JavaScript functions included in a page returned by the server to the client and run before other scripts. At runtime and during initial loading the MET functions are invoked by the client on each Web page modification to ensure the page conforms to the security policy. As such before a mutation takes effect METs may transform that mutation and the code and data of the page. Such monitoring and transformation gives METs great flexibility in enforcement. METs may be used to implement inlined reference monitors and edit automata for security relevant client events which enable METs to be used to specify and enforce any security policy based on monitoring client behavior.

In an implementation METs may be an extension to the Document Object Model DOM level 2 mutation events caused by an action that modifies the document structure. METs may operate on extended data that include both the standard DOM tree model and the abstract syntax trees ASTs of executable scripts. METs may provide mutation events for nodes as follows an event when the script node is inserted in the DOM and another event when that inserted node is populated with the AST for its script code. This separation allows METs to enforce security policies that limit network access caused by SRC host URL attributes in script nodes. Other nodes such as may also be handled in this manner.

In an implementation the script and target are DOM nodes in the document tree. The script refers to the node containing the script that is attempting the document mutation e.g. by writing to an innerHTML field . The target refers to the parent node where newValue is about to be inserted to replace oldValue. Both oldValue and the newValue are well formed properly nested subtrees of our extended DOM that includes ASTs either may be null to denote empty subtrees. Each callback function returns an extended DOM subtree to be used instead of newValue .

In the above policy would be invoked whenever a DOM element of type nodeType is affected i.e. inserted replaced or deleted . This may happen at runtime before the mutation but after the client application has parsed the new proposed extended DOM values.

In an implementation programmatic security policy variables and functions and MET callback registration may be placed in the first tag of a Web page . To prevent subversion of security enforcement the script language scoping rules may prevent access to security policy code and further MET callback registration might be disabled e.g. by setting document.prototype.add MET callback to null in the code. In other implementations client applications may allow other scripts to register MET callback functions.

In an implementation security policies may use programmatic MET callback functions written in JavaScript. At runtime MET callback functions operate on each new or updated Web page and ensure that it conforms to the security policy either through validation or transformation of the code or data within the Web page. In other implementations code for METs may be provided as pre packaged libraries or be determined at the server.

In an implementation METs may be used for client side enforcement of application specific dynamic security policies determined automatically at the server from the natural constraints imposed by the structured composition of client pages e.g. using frameworks such as ASP.NET AJAX GWT etc. . METs may also enforce other rich policies such as those that apply to Web 2.0 cross domain mashups where application pages are composed outside the server enforcement.

In an implementation user interface widgets such as drop down lists trees rich text content panes etc. act as a principal. The code associated with the widget may be associated with the principal so that it can only access DOM elements within the widget itself. The client application may walk the DOM tree to determine the origin of a document containing a portion of embedded script. However in this case the DOM traversal within the Web client may stop at the most deeply nested element that is annotated with a principal.

The same origin policy of JavaScript limits access to DOM and other Web client resources such as cookies by tracking the origin of a particular piece of code. The principal in the default same origin scheme is a triple e.g. host protocol port and the origin of a piece of JavaScript is determined by where it is embedded in the HTML DOM. In some implementations the origins of a DOM element and a piece of script may be determined by walking to the top of the DOM tree. Accordingly JavaScript access to DOM may be allowed if the origin as encoded by the triple above is the same.

In some implementations application specific principals that can be attached to an arbitrary DOM element may be allowed in addition to the default same origin scheme. As the client application walks up the DOM tree the principal list may be collected.

The principals may also represent DOM elements and events code identity and the client user input actions. An object of the access control system may include the entire DOM tree all script code and variables and external activity such as file access and network requests. Objects may be extended to include resources such as screen real estate to prevent spoofing memory and CPU resources to prevent denial of service.

In an implementation general security policies may be applied to a Web page its script code and the nodes and attributes of document data. Such policies may include but are not limited to 

 nodes may be disallowed and nodes only permitted when instantiating the Flash player with known content.

The Web page document may be subject to invariants even when modified dynamically at the client e.g. blog comments must be a well formed list of nodes.

 3 Disallow scripts in certain parts of a Web page. Disallow use of nodes in untrusted blog comments.

New client defined scripts may be allowed but for example the on Hover script code for a dynamically inserted list item may be required to match highlight identifier .

Prevent unexpected introduction of new code by cross domain client mashup applications for instance any script returned into a cross domain node may have a syntax tree that matches ajaxCallback jsonDataValue .

URLs are subject to access control both node attribute URLs e.g. on and the URLs used programmatically in scripts e.g. in an XML request .

Scripts may only modify certain document subtrees thus a gadget or client side mashup for Web search might only be allowed to mutate a for search results.

Scripts are not executed directly but through a special security enhanced interpreter or even more fine grained policies such as variants of stack inspection or data tainting.

It is noted that additional or fewer policies may be specified and that policies 1 through 10 are not exhaustive. In the above policies 1 3 and 6 may restrict potentially dangerous types of document nodes while allowing scripts only in certain portions of the document or may limit scripts to a whitelist of trusted scripts. Policies 2 4 and 5 may validate the structure of certain data structures and scripts in Web pages which may prevent many types of attacks e.g. attacks that use malformed SQL queries . Without such validation malicious attacks may exploit benign client side code by presenting it with malformed data. For instance without enforcement of policy 5 the client application may execute new unexpected code where only a data return value was expected. Client side data validation may also reduce the number of round trips to the server.

Policies 7 through 9 demonstrate that policies supported by METs may include constraints on network access or access to security critical client variables such as the Web client browser history and enforce containment scopes between client side gadgets and modules. Policy 10 demonstrates that security policies based on METs may include the code for a security enhanced JavaScript interpreter and ensure that it is used to execute all script code. Such a customized interpreter may implement dynamic taint propagation or other complex security policies.

In an implementation the above security policies may be readily instantiated using MET callback functions. Such callback functions may include but are not limited to 

In some implementations METs may support callback routines defined by a security policy code. For example the matchURLDomain function in 8 may match string URLs in a policy specific manner while the outmostAttr function in 9 may recursively walk up the document tree to find an attribute definition closest to the root. Similarly policy specific variables may encode security relevant state such as in 1 for allowed ActiveX GUIDs e.g. the Flash player and in 2 the identity of a particular node in the document structure of a Web page.

In an implementation the security policies may be application specific and perform access control within a page . is an exemplary document tree within a Web page and shows an example of a DOM tree containing data from two RSS sources rss 1 and rss 2. Here rss2 code should not modify the first element to prevent a rogue RSS feed from changing the contents of another one. The code associated with rss1 should not modify the second element . Likewise neither rss1 code nor rss2 code should be able to modify the third element that will display e mail. By implementing security policy 9 the code may be restricted to modifying only DOM elements declared within the same scope. This policy provides for isolation of code and data on a single page . also illustrates that a security policy may be directed by inline attributes on document nodes. In this case a no script attribute is used to direct MET enforcement of a policy such as 3 .

In another implementation a developer may write an application in Java that is subsequently compiled into two parts a Java part that resides on the server and a JavaScript part that resides on the client. In a client side attack the assumptions of the original Java application may not hold for the scripts at the client. To prevent this the server may generate policies that enforce consistency properties of the client code. For example the server may ensure that access control properties such as a private method may only be invoked by methods in the same Java class present in the original Java source code are preserved in the JavaScript code on the client side. Instantiation of such a policy may be application dependent and could be obtained through static analysis of the original Java code.

In another implementation server generated content templates may provide for dynamic policy generation in e.g. ASP.NET or JSP pages. These technologies allow servers to mix static HTML and dynamic content. Using static analysis the computed parts of a Web page may be approximated and thereby the structure and contents of generated pages. For example the analysis may be directed to assume no permitted scripts in application inputs. Such page templates are highly suitable for client side enforcement.

Referring to in an implementation individual frameworks may define a system of principals associated with GUI widgets that they provide. In an implementation the per control policy definition framework may implement AJAX.NET which provides an ajaxToolkit TabContainer element which may be used for creating tabbed user interfaces. AJAX.NET may generate unique principals for each tab ensuring that neither can access each other. When the final HTML code is produced either on the server or the client side these principals may be injected in to the code. The isolation may then be accomplished through the changes to the same origin policy as described above in the policy enforcement engine .

In some implementations principals may also be manipulated programmatically through changing the attributes of the surrounding DOM element by calls to getAttribute and setAttribute. As such a defined principal may be functionally equivalent to one that was assigned programmatically and only JavaScript that has the permission to access a DOM element will be able to call setAttribute on it. This prevents malicious JavaScript from re assigning principals.

Programmatic access to principals may be used for principal delegation i.e. a piece of JavaScript code that has access to a DOM element may enable another piece of JavaScript code with the same principal to access the DOM element. Similarly principals on a piece of JavaScript code such as a function may be changed as well by assigning to the field principal such as for instance 

Referring to this is illustrated as an operational flow of an implementation of a method of enforcing a security policy. At stage a security policy is received by the client. The client may receive a Web page from the server containing JavaScript functions defining the security policy. At stage a client side script execution process is monitored. The client may monitor operations performed by the client application . At stage it is determined if the client side script execution process complies with the security policy. The security policies noted above may be instantiated using callback functions when the web page is modified by the client application or a user input. If the execution conforms to the security policy execution continues at stage . If the execution does not conform to the security policy then a mutation is transformed. The code or data that does not comply with the security policy may be rewritten to conform to the security policy at the client . Execution of the code continues at stage .

Referring to distributed applications provided by the server may be partitioned into a server side application and a client side application . The client side application may run e.g. user interfaces and other functionalities on the client thereby allowing richer more reactive interfaces. As a result a stream of messages may be communicated between the client side application and server side application representing method calls between these two parts of the distributed application.

However the server cannot trust that the client will actually run the client side application that the server is providing. By running a modified application the client may break server security by calling methods of the server side application that do not correspond to any normal execution of the client side application e.g. delete server database entries access other client s data etc. 

In an implementation integrity mechanisms make use of replicated code execution on both the client and the server . The integrity mechanisms may include the server running its own shadow copy of the client side application in a trusted execution environment so that it can check that the methods calls coming from the client correspond to a normal application of the client side application . If the server receives a call e.g. a method call from the client that is not issued by its trusted shadow copy the server may ignore this call or raise some security alert. Thus the server need only review the security of its server side application using traditional techniques.

For the shadow copy being replayed at the server to be able to accurately replay the execution of the client side application the shadow copy may receive the same series of input events as those received at the client e.g. mouse clicks cookies keyboard entries . In an implementation the shadow copy is rewritten before the client side application is transmitted to the client to include additional code that collects all client side inputs. This may generate a stream of client to server method calls that includes the client inputs that can be checked against those coming from the client . In the other direction the stream of server to client messages is then replicated and sent both to the client and to the shadow copy . In some implementations the client may collect client side inputs and stream them to the server interleaved with the series of methods calls. It is also possible to omit sending the actual client to server method calls as they may be reconstructed by the server . In some implementations to keep the client side application and the server side application in sync a queue is maintained. A block of event stream is communicated to the server side application and the sequence of events is replayed from the queue.

In some implementations the client inputs may be batched and sent to the server only when the client makes an actual method call e.g. waiting until the user moves away from an input value before sending it over to the client so as to avoid sending every key click allowing allow certain events from certain places such as keyboard events from the keyboard and not keyboard events generated by another server . Also the shadow copy may be simplified by not producing outputs that are not passed to the server side application . As such events from the event stream sent to the server for applications that are irrelevant may be removed e.g. graphical code may be removed to improve performance . It is possible to apply this approach selectively to some secure sub part of the client side application . The selection of code and events may be performed systematically at compile time using type systems or static analyses.

In some implementations shadow copy may perform additional security policy checks or run the code in another language e.g. IL instead of JavaScript for performance reasons or to remove a security dependence on the compiler that generates client side code. In some implementations the client side application that is running at the client is different from the shadow copy that is running at the server . In other words the program is the same but the code is different. JavaScript may run on the client where ASP.NET runs on the server .

Numerous other general purpose or special purpose computing system environments or configurations may be used. Examples of well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems network personal computers PCs minicomputers mainframe computers embedded systems distributed computing environments that include any of the above systems or devices and the like.

Computer executable instructions such as program modules being executed by a computer may be used. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Distributed computing environments may be used where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules and other data may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing aspects described herein includes a computing device such as computing device . In its most basic configuration computing device typically includes at least one processing unit and memory . Depending on the exact configuration and type of computing device memory may be volatile such as random access memory RAM non volatile such as read only memory ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line .

Computing device may have additional features functionality. For example computing device may include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage .

Computing device typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by device and includes both volatile and non volatile media removable and non removable media.

Computer storage media include volatile and non volatile and removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media include but are not limited to RAM ROM electrically erasable program read only memory EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of computing device .

Computing device may contain communications connection s that allow the device to communicate with other devices. Computing device may also have input device s such as a keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. All these devices are well known in the art and need not be discussed at length here.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the presently disclosed subject matter or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium where when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the presently disclosed subject matter.

Although exemplary implementations may refer to utilizing aspects of the presently disclosed subject matter in the context of one or more stand alone computer systems the subject matter is not so limited but rather may be implemented in connection with any computing environment such as a network or distributed computing environment. Still further aspects of the presently disclosed subject matter may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Such devices might include personal computers network servers and handheld devices for example.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

