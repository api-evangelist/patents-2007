---

title: Method for enforcing change policy based on project state
abstract: A set of tools and other mechanisms automatically enforce software development change policies by providing a way to map physical source control system codelines to projects and by providing a way to maintain current project and codeline state information. The set of tools and other mechanisms also provide ways to define change management rules and policies, as well as, ways to evaluate and allow or deny each proposed change against the defined change policy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08645906&OS=08645906&RS=08645906
owner: 
number: 08645906
owner_city: 
owner_country: 
publication_date: 20070910
---
This application claims the benefit of the provisional patent application Ser. No. 60 844 309 filed Sep. 12 2006 the contents of which are incorporated herein by this reference.

This invention relates to the enforcement of change policies in software development and related disciplines such as Computer Aided Design CAD .

As part of the software development process organizations define many policies to govern all aspects of the process. This is typically done to protect code quality and the organization s intellectual property. These policies commonly include items such as 1 who can check in merge branch or check out code from what codelines at various stages of the development process 2 what kinds of changes new features critical bug fixes etc. are allowed at various stages of the development process and 3 what level of review is required for changes into codelines in the various stages of the development process.

Conventionally these processes are enforced through management oversight. Management oversight usually involves systems that include only very basic access controls to source control systems. In other words these systems are typically all or nothing in nature either allowing all authorized users to make changes at a given time or preventing all changes by any user. These simple measures do not allow organizations to automatically enforce more complicated change policies. This lack of enforcement can lead to unauthorized changes being made to sensitive work products. These unauthorized changes can and often do lead to system failures which can have large negative economic consequences.

Note that the approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring embodiments of the present invention.

In one embodiment mechanisms provide a simple but highly effective way to automatically enforce policies that control access to code based on the status of a project. These mechanisms allows users to define and enforce those policies at any time during the software development process. The software development process can also be referred to in terms of a lifecycle. Virtually every software development project goes through a project lifecycle. While different organizations use different terms and different numbers of states to define a project lifecycle most organizations define a lifecycle that begins with formal specification requirements and ends when the software project is decommissioned. A simple but not atypical lifecycle of a software project might consist of the following 7 stages 1 requirements gathering 2 active development 3 code complete 4 code freeze 5 beta testing 6 production and 7 end of life. Depending on the organization a project lifecycle may also include other or different stages.

In one embodiment at each stage in this process software development organizations define different policies for what kinds of changes are allowed and by whom. For example developers assigned to a project may be able to check in changes at any time during the active development phase. While developers not assigned to the project are restricted from checking in any changes to the project. As another example during a code complete phase a policy may be enforced that only allows changes that are meant to fix bugs. As a third example during a code freeze phase a policy may be implemented so that only changes to bugs of a certain priority level are allowed and even then all changes may need to be reviewed by a technical lead before being submitted.

While the above examples are representative of the types of policies used during software development the actual policies can be much more complex. Moreover it can be common for these policies to vary significantly at each state in the project lifecycle. Unfortunately current change management systems do not allow for automatic policy enforcement based on project state. Hence in one embodiment mechanisms automatically enforce policies by providing a way to map physical source control system codelines to projects and a way to maintain current project and codeline state information. In an additional embodiment mechanisms provide a way to define change management rules and policies as well as ways to evaluate and allow or deny each proposed change against the defined change policy.

In one embodiment system includes Policy Enforcement tool that works with Source Control Management SCM system and Issue Tracking system . An SCM system such as SCM system can also be referred to as software change management systems. Popular examples of SCM systems include but are not limited to CVS PVCS and Perforce.

SCM system in one embodiment is designed to capture store and manage access to and provide version control for software source files designs and similar files. This information can be stored by SCM system in a repository such as SCM Store . Note that SCM Store can be a standard database that maintains information and files related to a software development project. Alternatively it may be some other type of repository. In addition to a store SCM system also may include the basic facilities to allow or deny changes to files during the software development process.

Policy Enforcement tool can extends the facilities of SCM system to enforce more sophisticated change policies for example those based on codeline state . In one embodiment Policy Enforcement tool can include a variety of components. Those components can include Change Capture component Policy Evaluation and Enforcement component Policy Database and a set of Policy Definition and Administration components . In other embodiments Policy Enforcement tool may include a different set of tools and components. In addition note that Policy Enforcement tool and its components may be implemented in a variety of ways. For example Policy Enforcement tool may be a stand alone program that includes application programming interface files to implement the various component tasks. Alternatively Policy Enforcement tool and or its components may be implemented as dynamic link library files as separate applications or as integrated components for example of an SCM system.

According to one embodiment Change Capture component interacts with SCM system . Change Capture component in one embodiment intercepts proposed changes submitted by users to SCM system . From the intercepted data Change Capture component can capture any required information related to the proposed change e.g. issue ID or feature Id or enhancement ID and can in one embodiment send a request to Policy Evaluation and Enforcement component to approve the proposed change e.g. by passing along all relevant details of the proposed change . Eventually Change Capture component receives a response from Policy Evaluation and Enforcement component either accepting or rejecting the request. Depending on the response Change Capture component can either accept the proposed change or allow it to proceed into the SCM system or Change Capture component can reject it and provide the user with an appropriate error message.

When Policy Evaluation and Enforcement component receives a proposed change in one embodiment it evaluates the proposed change against defined policy enforcement rules. Generally a proposed change comes as input from Change Capture component but in other embodiments the proposed change may come from an alternative source. After receiving a proposed change Policy Evaluation and Enforcement component in one embodiment retrieves the relevant rule set and other information from Policy Database in order to determine if the proposed change should be accepted. In addition Policy Evaluation and Enforcement component can also communicate with the Issue Tracking System to validate information gathered by Capture Change component e.g. issue IDs and retrieve other relevant information needed to evaluate a rule such as issue priority . In addition Policy Evaluation and Enforcement component may use well known and widely implemented methods for the real time evaluation of multiple rules. For example Policy Evaluation and Enforcement component may include a rules engine which has the capability to process and evaluate rules defined in a standard format.

The set of Policy Definition and Rule Administration components include those components that allow a software development process administrator to define and manage policies codelines and user related information. According to one embodiment the information defined by these components is stored in a Policy Database . These components are discussed in more detail below.

In one embodiment Policy Database stores policy rules codeline mappings as well as user group and role information. Policy Database may be implemented using an industry standard relational database management system RDBMS although other implementations e.g. tables arrays text files etc. would work as well.

As with SCM systems Policy Enforcement Tool is designed to work with existing Issue Tracking Systems . Issue Tracking System can include Issue Tracking Databases which can be a repository that stores known issues related to the software being developed. In one embodiment Issue Tracking System is used to record and track both tasks that need to be completed for a project as well as open bugs and issues. Common examples of these systems include but need not be limited to Bugzilla and Team Track.

To enforce policies by project state in one embodiment the system maps a physical source system codeline to projects as well as defines and maintains the state of these projects and what users or groups are assigned to these projects.

For example suppose two projects are actively being developed. One project is an application called Sample App1 V3 which is made up of three modules module1 module2 and module3 . The other project is Sample App2 V6.1 which consists of four modules module4 module5 module6 and module7 . In this example Sample App1 V3 is in the development phase and Sample App2 V6.1 is in the Code Freeze phase. Team 1 is assigned to Sample App1 V3 and Team 2 is assigned to Sample App2 V6.1. To map physical source control system codeline to projects the SCM system is organized by module with each module also having its own path in the system and each project having its own branch in the system. Table 1 below shows data that might be stored in the system for each project in this example 

In Table 1 State is a foreign key reference to a table of valid states and Assigned Users is a foreign key reference to a table of valid users and groups. For simplicity and clarity other likely variables such as a unique project identifier a project description a project owner and other project metadata have been omitted since they are not referred to in this example.

Based on the information stored in Table 1 when a change is submitted to the system in one embodiment the system determines what release project this particular file belongs to and then checks the current state for that codeline. Based on that determination system as described herein can invoke the appropriate set of policies to accept or reject submitted changes.

In one embodiment in addition to mapping codelines to projects to control when and how changes are made to a project an administrator uses tools to define change management policies. According to one embodiment a change management policy consists of the following types of information 1 a specified type of change that is being requested e.g. check in of a particular file or merge of two codelines 2 a set of variables about the proposed change e.g. what codeline is being changed its state who is making the change etc. 3 a set of actions that can be taken for each type of change e.g. accept reject notify etc. and 4 a set of rules that combine the above 3 items to evaluate and process changes.

Accordingly defining a change management policy in one embodiment includes first defining what types of changes trigger a rule. According to one embodiment the changes that could trigger a rule include but are not limited to the following types of changes 1 check ins to an SCM system 2 codeline merges in the SCM system 3 branching in the SCM system 4 check outs from the SCM system 5 downgrading or deferring of bugs in the bug system and 6 closing of bugs in the bug system.

Then in one embodiment for each of type of proposed change a wide range of variables can be used to help evaluate the proposed change. These variables can include but are not limited to 1 the user the user s role e.g. manager tech lead junior programmer etc. or the group membership of the person attempting to take the action 2 the product or release the user is attempting to modify 3 the state of the product or release the user is attempting to modify 4 a valid work item ID in the issue bug tracking system 5 the priority of the work item bug ID in the issue tracking system 6 a valid reviewer ID 7 a valid effort level entry 8 information about whether a proposed change has passed automated quality assessment tests 9 arbitrary Boolean operations on any data captured from the source SCM bug tracking or other system 10 the size of the proposed change measured in terms of the of lines of code changed 11 the complexity of the code changes as measured by a code analysis tool and 12 attributes on the particular module changes such as whether it is a critical or performance sensitive module Note that these are examples of the types of variables that may be used to help define a change management policy. Moreover a proposed change may not need to include every single variable listed above. In fact in many cases a proposed change utilizes fewer variables. In some cases a proposed change may include no variables at all.

Finally a change management policy might include a wide range of output actions. In one embodiment the output actions may need to be defined by the administrator so that proposed changes can occur. These actions can include but are not limited to 1 allow the change to proceed 2 reject the change 3 notify one or more people of the change and 4 trigger an action on an external system such as the execution of a automated test suite or automated code analysis. In this way the administrator can control how and when proposed changes occur. In other embodiments a different set of supported actions may be defined.

By defining the changes that may occur as well as the variables and actions that may trigger a change administrators can define change policy rules.

In one embodiment the change policy rules can be expressed using a variety of well known methods ranging from Boolean expressions to XML based rules definition languages. Below is Example Rule 1 expressed as a simple Boolean expression that says that check ins the change to development state codelines must have a valid taskID the variables or they will be rejected the action 

In other embodiments a change policy definition may include other or different information and or be in another or different format.

According to one embodiment once codelines are mapped and policies defined then a change management policy can be enforced in a system. is a flowchart that outlines process that illustrates how a change policy is evaluated and enforced. Process begins at step with a developer submitting one or more proposed changes to an SCM system such as SCM system illustrated in .

When the proposed change is submitted information is captured from the proposed request in order to evaluate whether the change can proceed or not. In one embodiment the information necessary to evaluate the proposed change includes determining an action e.g. check in merge etc. in addition to a set of variables e.g. files changed user taskID etc. . This information and other information is captured as part of the evaluation process. The determination can as to what type of action is being made can be determined in one embodiment by the SCM system or alternatively by a Policy Enforcement tool. The type of change being requested is generally implicit in the action the user is requesting be taken by the SCM system. Thus the type of change being requested can be automatically captured by the system based on the request of the user.

Other information can be captured as well. For example a user submitting a change may have to be authenticated by the SCM system before a change can be submitted. Accordingly the userID of the requesting user can be automatically captured by the system. This information as well as other variables such as the names of files being changed can also be automatically captured by the system as part of the normal change process.

In some cases variable data such as the taskID or reviewerID may be input directly by the user or the user might be prompted to input the data. In one embodiment some variables such as codeline state can be retrieved from the Policy User and Group DB. Note that other variables and how those variables are obtained can vary from one implementation to the next.

At step in one embodiment once the developer has submitted the proposed change and information from the proposed change captured then the system sends the captured information e.g. what files were changed the userID the issue ID to a policy enforcement module. The proposed change in one embodiment is not committed to the SCM system at this time but is held in an in process state. The in process state indicates that the proposed change is being evaluated.

At step the policy enforcement module receives the proposed changes. Here according to one embodiment the system retrieves information in order to be able to evaluate the proposed change and determine if it will be allowed. For example as discussed above in connection with the following types of information may be retrieved to evaluate a proposed change 1 the codeline in which the files with proposed changes reside this information may be retrieved from a Policy User and Codeline database 2 the current status for this codeline e.g. whether the codeline is in development code freeze production etc. 3 the project assignments for the developer requesting the change from the Policy User and Codeline DB and 4 the priority of the issueID from the Issue Tracking system.

At step once that information has been gathered e.g. from a Policy Codeline and User DB the policy enforcement tool identifies policy rules which have been defined for the current state of the codeline the developer is attempting to modify. In this example assume that the codeline is in a code freeze state. Accordingly the following rules may be retrieved from the DB 1 only developers assigned to this project are allowed to check in changes 2 only changes for high priority issues are allowed and 3 all other changes are rejected.

At step the system evaluates whether the proposed change should be accepted. It does so by comparing the information it retrieved to the rules defined for the current codeline and codeline state. If the change violates any of the rules specified the change is rejected. In addition the process can terminate and or an error message may be displayed to the user. If the change does not violate any rules the system accepts the change and commits it to the system.

In one embodiment at step the details e.g. the time date user bugID files changed etc. of the change are recorded for example in a Policy Codeline and User and DB to track all changes made to the project.

As described above policy rules help define how when and by whom proposed changes can be committed to a system. According to one embodiment policy rules are defined by a user administrator developer etc. is a flowchart that outlines process for defining a set of policy rules. This process can be performed through a user interface that provides selectable controls that correspond to various rules options or the administrator may define the rules using text markup text a template or some other means.

In one embodiment process begins with an administrator specifying the list or at least a partial list of release components that might be included in the next release or update of a project. In one embodiment the list of release components can be a table in an SCM system a record in a database a text file or some other mechanism that can be used to identify release components. The manner of the administrator uses to identify these components varies for example version numbers file names file metadata header information and other such mechanisms may all be used to identify the components.

Once an administrator has identified the set of release components at step for each component in the set the administrator provides metadata such as the name and description of each component as well as a branch in the SCM system where the files for this component can be located. In this way the administrator can customize what information is searched for by the various systems and components described herein.

At step for each codeline the administrator chooses the appropriate state the release is in from a set of defined choices. For example the release may be in a code freeze state development state etc. By doing so in one embodiment the administrator is defining when a proposed change may be submitted to an SCM system.

Then in one embodiment at step the administrator defines which users or groups of users are assigned to this release. In this way the administrator can control who accesses release files at the various stages of a project s lifecycle.

Note that steps discussed above are described as occurring in a particular order. These steps may occur in any order. They may also occur independently of any other steps. In alternative embodiment defining rules properly may include performing more or less than the steps enumerated above.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one implementation of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative implementations hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus implementations of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing data that causes a machine to operation in a specific fashion. In an implementation implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications. All such media must be tangible to enable the instructions carried by the media to be detected by a physical mechanism that reads the instructions into a machine.

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave. In the foregoing specification implementations of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

