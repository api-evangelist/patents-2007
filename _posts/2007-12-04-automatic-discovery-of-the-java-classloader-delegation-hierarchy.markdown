---

title: Automatic discovery of the java classloader delegation hierarchy
abstract: A computer implemented method, data processing system, and computer program product for automatic discovery of the Java classloader delegation hierarchy. One or more classloaders are instrumented with byte code instrumentation code such that a delegation event is received each time a classloader delegates a resource finding method to a parent classloader of the classloader. From each delegation event received, the classloader that generated the delegation event and a parent classloader to which the classloader directly delegates the resource finding method is determined. Based on the delegation events received, the classloaders to which a current classloader in the one or more classloaders can directly delegate are determined. The order of delegation to the classloaders may then be determined.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08276125&OS=08276125&RS=08276125
owner: International Business Machines Corporation
number: 08276125
owner_city: Armonk
owner_country: US
publication_date: 20071204
---
The present invention relates generally to byte code instrumentation BCI in a data processing system and in particular to a computer implemented method data processing system and computer program product for automatic discovery of the Java classloader delegation hierarchy.

Java is an object oriented programming language and environment focusing on defining data as objects and the methods that may be applied to those objects. Java is designed to solve a number of problems in modern programming practice. Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating system architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format so that the compiled code is executable on many processors given the presence of the Java runtime system. The Java compiler generates byte code instructions that are non specific to any particular computer architecture. A byte code is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is a module that alternately decodes and executes a byte code. The decoding of the byte code places the instruction into an executable form for the computer on which the code is to be executed. Then the instruction is executed by the computer. These byte code instructions are designed to be easy to interpret on any machine and easily translated on the fly into native machine code.

The Java Virtual Machine JVM is a virtual computer component. A virtual computer component is an abstract computer component that only resides in memory. A JVM includes components necessary to run a program on a computer including an interpreter. The JVM allows Java programs to be executed on different platforms as opposed to only a single platform. Typically computer programs are originally written in a human readable format called source code which is then compiled by a computer program called a compiler into a format that can be directly implemented by a computer system. Conventionally programs must be compiled for one specific platform i.e. processing unit and operating system combination such that a program that has been compiled for one platform will often not run on a different platform. Java programs are compiled for the JVM rather than for any particular platform although there are typically different versions of the JVM adapted to different platforms . In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating system architectures.

There are a number of approaches to dynamically loading interdependent components of executable code such as plug ins bundles etc. in modern programming languages. Dynamically loading means to load one or more components of an application after the application has begun execution. In the Java programming language classes are dynamically loaded using a classloader as an application program executes.

The classloader is responsible for searching for a particular class and making that class available to the run time system if found. In object oriented programming a class consists of a collection of types of encapsulated instance variables and types of methods possibly with implementation of those types together with a constructor function that can be used to create objects of the class. Java class loading is based on a delegation model wherein a classloader first delegates the class loading responsibility to its immediate parent classloader.

Byte Code Instrumentation BCI is a widely adopted technique used to alter Java virtual machine byte code instructions. Byte code instrumentation typically introduces additional Java classes into the byte code instructions to profile Java applications. For load time and dynamic byte code instrumentation deployment of the newly added classes in the byte code instructions is a time consuming and non trivial process. However this deployment is the key to successful loading execution of the altered byte code. Although some application vendors provide dedicated locations for inserting BCI code there is currently no mechanism in the existing art which enables the added Java classes BCI code to be deployed automatically.

With the existing manual methods for BCI code deployment there are several drawbacks. One drawback is that the Java class deployment is a static process. Whenever there is a change in the product being instrumented there is a possibility that the BCI code will not work in the new environment. BCI code deployment locations are also limited to the configurations supported by a product. In some circumstances even if a deployment location is identified deployment to that location is not possible. In addition discovering the correct classloader to use to load the new classes can be a protracted process. Without a standard and systematic method for discovering the correct classloader to use programmers can only rely on product documentation product implementation details if available and experimenting with multiple possibilities by actually loading the BCI code.

The illustrative embodiments provide a computer implemented method data processing system and computer program product for automatic discovery of the Java classloader delegation hierarchy. One or more classloaders are instrumented with byte code instrumentation code such that a delegation event is received each time a classloader delegates a resource finding method to a parent classloader of the classloader. From each delegation event received the classloader that generated the delegation event and a parent classloader to which the classloader directly delegates the resource finding method is determined. Based on the delegation events received the classloaders to which a current classloader in the one or more classloaders can directly delegate are determined. The order of delegation to the classloaders may then be determined.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . Clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments. In this illustrative example data processing system includes communications fabric which provides communications between processor unit memory persistent storage communications unit input output I O unit and display .

Processor unit serves to execute instructions for software that may be loaded into memory . Processor unit may be a set of one or more processors or may be a multi processor core depending on the particular implementation. Further processor unit may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another illustrative example processor unit may be a symmetric multi processor system containing multiple processors of the same type.

Memory in these examples may be for example a random access memory or any other suitable volatile or non volatile storage device. Persistent storage may take various forms depending on the particular implementation. For example persistent storage may contain one or more components or devices. For example persistent storage may be a hard drive a flash memory a rewritable optical disk a rewritable magnetic tape or some combination of the above. The media used by persistent storage also may be removable. For example a removable hard drive may be used for persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit is a network interface card. Communications unit may provide communications through the use of either or both physical and wireless communications links.

Input output unit allows for input and output of data with other devices that may be connected to data processing system . For example input output unit may provide a connection for user input through a keyboard and mouse. Further input output unit may send output to a printer. Display provides a mechanism to display information to a user.

Instructions for the operating system and applications or programs are located on persistent storage . These instructions may be loaded into memory for execution by processor unit . The processes of the different embodiments may be performed by processor unit using computer implemented instructions which may be located in a memory such as memory . These instructions are referred to as program code computer usable program code or computer readable program code that may be read and executed by a processor in processor unit . The program code in the different embodiments may be embodied on different physical or tangible computer readable media such as memory or persistent storage .

Program code is located in a functional form on computer readable media that is selectively removable and may be loaded onto or transferred to data processing system for execution by processor unit . Program code and computer readable media form computer program product in these examples. In one example computer readable media may be in a tangible form such as for example an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage for transfer onto a storage device such as a hard drive that is part of persistent storage . In a tangible form computer readable media also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that is connected to data processing system . The tangible form of computer readable media x18 is also referred to as computer recordable storage media. In some instances computer recordable media may not be removable.

Alternatively program code may be transferred to data processing system from computer readable media through a communications link to communications unit and or through a connection to input output unit . The communications link and or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non tangible media such as communications links or wireless transmissions containing the program code.

The different components illustrated for data processing system are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system . Other components shown in can be varied from the illustrative examples shown.

As one example a storage device in data processing system is any hardware apparatus that may store data. Memory persistent storage and computer readable media are examples of storage devices in a tangible form.

In another example a bus system may be used to implement communications fabric and may be comprised of one or more buses such as a system bus or an input output bus. Of course the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example memory or a cache such as found in an interface and memory controller hub that may be present in communications fabric .

The illustrative embodiments provide a mechanism for automatically discovering the classloader delegation hierarchy of a JVM using BCI technology to instrument the classloaders in the JVM. The Java language has traditionally supported classloader objects that are responsible for loading classes. The classloaders are usually organized in a hierarchical tree structure i.e. in a parent child relationship. The classloaders use a delegation mechanism to find and load classes and resources across the hierarchy. Most commonly the delegation pattern is a parent first delegation pattern which requires a child classloader to delegate a request to load a class to its parent before looking for the requested class within its own scope.

The delegation hierarchy of a classloader in a JVM can be automatically discovered according to the illustrative embodiments by calculating the properties of each and every node classloader in the classloader s delegation hierarchy using BCI technology. Each classloader has two properties the first property comprises a list of all possible classloaders to which the current classloader can directly delegate and the second property comprises the delegation order of the classloaders in the list. Once these two properties have been calculated for a classloader the delegation hierarchy of the classloader is known.

The illustrative embodiments also provide a mechanism for automatically deploying BCI code at class load time. The mechanism comprises a class automatic deployment solution which uses BCI technology to instrument the classloaders in the JVM. The class automatic deployment solution also adds another extended classpath to the classloaders using BCI technology to enable the classloaders to change paths dynamically. The classloaders are instrumented using BCI technology to generate a class loading event notification to a monitoring class when a class is loaded. When the monitoring class receives the notification the monitoring class determines if new BCI code needs to be loaded with the loaded class. If so the monitoring class initiates auto deployment code to determine the correct classloader to load the new BCI code. In environments where a class loader is used to load a class i.e. Java an application must determine which classloader to use to initiate the loading of classes. To determine the correct classloader to use the auto deployment code uses the previously mentioned classloader delegation hierarchy of each classloader in the JVM to determine which classloaders in each delegation hierarchy are dependent on the new BCI code and then calculates the correct classloader in the JVM to use to load the new BCI code. The auto deployment code then dynamically inserts the new BCI code into the added extended classpath of the correct classloader thereby providing on demand deployment of the new BCI code.

As the dynamic deployment in the illustrative embodiments is based on BCI technology as long as a correct classloader deployment location is identified by the auto deployment code the actual deployment is not limited to the particular configuration supported by the specific vendor product in use. Thus the BCI code deployment in the illustrative embodiments is ensured to work with the current deployment configuration supported by the product in use. In addition the discovery of the correct classloader according to the illustrative embodiments is a programmatic process rather than a manual process.

With reference now to a block diagram that illustrates the relationship of software components operating within a computer system that may implement the illustrative embodiments is depicted. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. Java Virtual Machine JVM is one software application that may execute in conjunction with the operating system. JVM provides a Java run time environment with the ability to execute Java application or applet which is a program servlet or software component written in the Java programming language. The computer system in which JVM operates may be similar to data processing system described above with reference to . However JVM may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the JVM which supports all aspects of the Java environment including its architecture security features mobility across networks and platform independence.

The JVM is a virtual computer i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAS.

A JVM loads class files and executes the bytecodes within them. The class files are loaded by a classloader in the JVM. The classloader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes but JVMs may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a JVM is depicted in accordance with the illustrative embodiments. JVM includes classloader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a JVM method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined. Native method stacks store the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap each of which are shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into the method area . Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

As shown in classloader architecture comprises a hierarchical tree architecture in which classloaders are organized in a parent child relationship. In the exemplary embodiment illustrated in hierarchical architecture includes classloaders and . Classloaders include in order from the bottom to the top of hierarchical tree Application Classloader Runtime Framework Classloader and System Bootstrap Classloader . Although only one Application Classloader is shown in other Application Classloaders can be included in the hierarchy as well. As additionally shown in a plurality of Application Module classloaders for example Application Module classloaders and may be included for modules that might be included in an application. It should be understood however that the classloaders and their order are intended to be exemplary only as hierarchical architecture can include any number of classloaders arranged in any desired hierarchical manner.

In hierarchical architecture classloader at the bottom of the hierarchical tree is a child of classloader . Classloader is both a parent of classloader and a child of classloader . Classloader is a parent of classloader and is at the top of the hierarchy.

Classloader architecture typically uses a delegation mechanism to find and load classes and resources across the hierarchy. Usually the delegation mechanism is a parent first delegation pattern that requires a child classloader to delegate a request to load a class to its parent classloader before looking for the class within its own scope. Thus in the hierarchy illustrated in when a request to load a class is received by Application classloader from an application or by one of module classloaders from an application module if present it will forward the request up the hierarchy to the topmost classloader . Each classloader will look for the requested class and either load the class if it is found or return the request to its child classloader down to the Application module classloaders. If none of the classloaders are able to return the requested class an error will be returned.

to obtain the list of all possible classloaders to which a classloader such as classloader can directly delegate the illustrative embodiments employ BCI technology to instrument a classloader at runtime with a resource finding method to collect the classloader s delegation information. One resource finding method that may be used for collecting delegation information is the loadClass method. As the current classloader delegates the loadClass method to its parent classloaders the delegation information of the current classloader may be obtained. However the loadClass method is a synchronized method. If BCI code invokes the loadClass method to collect the delegation information the BCI code will lock the current classloader. A deadlock may also occur if another thread attempts to load a class using the current classloader.

Instead of using the resource finding of the loadClass method the illustrative embodiments employ the standard API of resource finding classloader.getResource method. The getResource method is used to trace the delegation relationships among the classloader and the classloaders to which the current classloader can directly delegate. A non existent resource is used as the resource in the getResource method to allow the getResource method to traverse the entire delegation path of the current classloader as none of the classloaders in the path will be able to locate the resource. The default implementation of the getResource method will first search the parent classloader for the resource. Each classloader.getResource method is instrumented to insert a delegation event generator using BCI technology. The delegation event comprises the classloader instance name and the non existent resource name.

In some situations however user defined classloaders may bypass the default implementation above. To address these situations user defined classloaders need to employ a user defined method to delegate the resource finding instead of getResource method. One way to implement a user defined resource finding method is to instrument the user defined resource finding methods which are under the control flow of the getResource method wherein the control flow of the getResource method comprises all code which is executed between entering the method and exiting the method e.g. methodA calls methodB then the code in methodB is under the control flow of methodA . Another way to implement a user defined resource finding method is to instrument the user defined resource finding methods having a signature of which matches javax.net.URL java.lang.Classloader. where is the resource finding method.

As shown a getResource method to a non existent resource is initiated on classloader . When the getResource method is invoked on classloader classloader delegates the method to its parent classloaders classloader and classloader according to normal delegation procedure. Classloader also sends a delegation event to monitoring class in the JVM. Although only the getResource path to parent classloader is depicted in it should be noted that the getResource method is delegated to all other parent classloaders of classloader including classloader in order to determine the complete delegation hierarchy of the current classloader. The path to parent classloader is merely shown as one example.

When the delegated getResource method is received at the parent classloader e.g. classloader classloader also delegates the method to its parent classloader classloader according to normal delegation procedure. Classloader also sends a delegation event to monitoring class .

When the delegated getResource method is received at parent classloader classloader sends a delegation event to monitoring class . Since classloader is the root classloader in the hierarchy classloader returns the getResource method to classloader to find the resource which in turn returns the getResource method to classloader to find the resource.

Monitoring class comprises an event handling function which receives and processes each event received from the classloaders. Event handling function uses this delegation information in each event to determine the classloaders to which classloader has delegated the getResource method. Event handling function also determines the order in which the method was delegated to those classloaders.

The process begins when the event handling function receives a delegation event notification from the getResource method of a classloader step . Upon receiving the notification event the event handling function determines the classloader that sent the delegation event from the classloader instance name in the event and the classloader to which the getResource method was delegated related classloader step . The event handling function then determines if the related classloader is a next node step . A next node is a classloader which is a directly delegated classloader of the classloader which sent the delegation event.

If the related classloader is not a next node no output of step the process continues to step . If the related classloader is a next node yes output of step the event handling function adds the related classloader to a next node list step . The next node list comprises the classloaders to which the current classloader can delegate and the placement of the classloaders in the list indicates the delegation order of the classloaders. At step the event handling function is completed and returns to the monitoring class.

The process begins when a class loading event notification generated by an instrumented classloader is received at the monitoring class in the JVM in response to a class being loaded step . In response the monitoring class makes a determination as to whether new BCI code needs to be loaded with the loaded class step . This new BCI code comprises byte code instrumentation code which modifies the existing byte code instructions in the loaded class. If the monitoring class determines that no new BCI code needs to be loaded i.e. no modification of the existing byte code is needed no output of step the process continues to step .

If the monitoring class determines that new BCI code needs to be loaded yes output of step the monitoring class initiates the class auto deployment code step . The class auto deployment code first determines which classloaders in the JVM are dependent on the new BCI to be loaded step . To ensure that BCI code can be initialized successfully it is required that a classloader of the new BCI code can visit all classes dependent on the new BCI code or import classes. In other words the classloaders of the import classes have a delegation relationship with the classloader of the new BCI code. The auto deployment code may use the classloader delegation hierarchy of a classloader to determine those classloaders that load import classes of the new BCI code. This step is described in further detail in .

Next the auto deployment code calculates the correct classloader in the JVM to use to load the new BCI code step . This calculation of the correct classloader is made based on the classloaders of the imported classes as determined in step and the classloader delegation hierarchies of the classloaders. This step is described in further detail in .

Once the correct classloader is known the auto deployment code dynamically inserts the new BCI code classpath into an extended classpath of the correct classloader step . This new extended classpath field is inserted into the class declaration using BCI technology to instrument the classloader. This extended classpath field can be changed dynamically. The class is then loaded with new BCI code from the extended classpath and the original classpath step . The auto deployment code then ends step .

Thus to implement the auto deployment code in the illustrative embodiments the beginning of the loadClass method of each classloader is instrumented to add a callback method using BCI code to notify the monitoring class when class is loaded and thus initiate the auto deployment code if new BCI code is needed. Each classloader is also instrumented to insert a new extended classpath field into the class declaration. This new extended classpath field may be dynamically changed by the classloader which enables new BCI code to be auto deployed as needed.

The process begins with the auto deployment code initiating the findLoaderOfImportClass method step . The findLoaderOfImportClass method is used to return the most suitable candidate classloader for loading an import class to the class auto deployment process in step in . As there may be multiple import classes for the needed BCI code the candidateClassloader of each import class will be determined by invoking the findLoaderOfImportClass method.

A determination is made by the findLoaderOfImportClass method as to whether the current candidate classloader candidateClassloader can load an imported class importClass step . The importClass is the name of the imported class BCI code that the classloader which needs to be determined can load. The candidateClassloader is the current classloader loading the importClass. The default value of candidateClassloader is the classloader that attempts to load the new BCI code.

If the candidateClassloader cannot load an imported class no output of step the process generates a result comprising a null value step with the process continuing to step . If the candidateClassloader can load an imported class yes output of step the findLoaderOfImportClass method iterates through each classloader tryLoader in the sortedClassloaderSet step . The sortedClassloaderSet is the list of sorted directly delegated classloaders of the specific candidate classloader which can be determined using the classloader delegation hierarchy discovery method previously described in . The classloaders in the sortedClassloaderSet are iterated through based on sorted priority.

The findLoaderOfImportClass method then determines if a classloader tryLoader in the iteration of sortedClassLoaderSet can load importClass step . If the classloader tryLoader in the iteration cannot load importClass no output of step the process continues for the next iteration of the sortedClassloaderSet step and loops back to step . However if there are no more classloaders in the sortedClassloaderSet the findLoaderOfImportClass method determines the most suitable classloader for loading the import class is the candidate classloader step . The findLoaderofImportClass method then returns the candidate classloader step to the auto deployment code in step of .

Turning back to step if a classloader tryLoader in the iteration can load importClass yes output of step that classloader tryLoader in the iteration is determined to be the candidate classloader i.e. the most suitable classloader for loading the particular import class . Thus the candidate classloader is set to be the particular tryLoader step . The findLoaderofImportClass method is called again using the current candidate classloader step since the candidate classloader is changed in step .

At step the findLoaderofImportClass method returns the candidateClassLoader to the auto deployment code in step of .

The process begins with initiating the CalculateCorrectClassloader method using the importClassloaderList comprising the candidate classloaders determined in step . The process then sets the tryLoader to be the candidate classloader step . The CalculateCorrectClassloader method then sets the default value of the result as NULL and the default value of the canDelegated method to FALSE for the tryLoader step .

For each item in the list of import classloaders importClassLoaderList for the needed BCI code step the CalculateCorrectClassloader method sets canDelegated as the return value from the canDelegateTo method described in step . Tryloader and importClassloader are input values for the canDelegateTo method. The CalculateCorrectClassloader method then determines if the canDelegated result value is TRUE step . This step if true enables the process to jump out of the iteration loop. If the canDelegated result value is TRUE yes output of step the process loops step back to step to process the next item in the importClassLoaderList.

If the canDelegated value is not TRUE no output of step the CalculateCorrectClassLoader method determines if the canDelegated value is equal to TRUE step . If the canDelegated value is equal to TRUE the process sets the candidate classloader as the tryLoader step . The CalculateCorrectClassloader method then generates a result with a value of the candidateClassLoader step . The CalculateCorrectClassloader method obtains the sortedClassloaderSet of the new candidate classloader step since the candidate classloader is reset with the tryLoader in step . The CalculateCorrectClassloader method then sets the tryLoader to the next item in the sortedClassloaderSet step . The process then loops back to step .

Turning back to step if the canDelegated value is not equal to TRUE no output of step the CalculateCorrectClassloader method determines if the next item obtained in the sortedClassloaderSet has value of NULL step . If the next item in the sortedClassloaderSet has a value of NULL yes output of step the process continues to step . If the next item in the sortedClassloaderSet does not have a value of NULL no output of step the CalculateCorrectClassloader method has determined the correct classloader to load the new BCI code and returns the correct classloader to the auto deployment code in step in .

The process begins with initiating the canDelegateTo method using the source classloader and destination classloader step . The source classloader comprises the current tryLoader from step in . The destination classloader comprises the current importClassloader from the importClassloader list in step in . The canDelegateTo method obtains the sortedClassloaderSet of the sourceLoader step . The canDelegateTo method iterates through each classloader tryLoader in the sortedClassloaderSet of the source classloader step . The canDelegateTo method determines if the classloader can delegate to a particular destination loader based on input parameters comprising the tryLoader and the destination loader step .

If the classloader in the iteration cannot delegate to the destination loader no output of step the process continues for the next iteration of the sortedClassloaderSet step and loops back to step . However if there are no more classloaders in the sortedClassloaderSet the canDelegateTo method generates a canDelegateTo result comprising a value of FALSE step . The canDelegateTo method then returns the result value step to the CalculateCorrectClassloader method in step of .

If the classloader in the iteration can delegate to the destination loader yes output of step the canDelegateTo method generates a canDelegateTo result comprising a value of TRUE step . The canDelegateTo method then returns the result value step to the CalculateCorrectClassloader method in step of .

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

