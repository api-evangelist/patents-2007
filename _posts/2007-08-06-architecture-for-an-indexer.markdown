---

title: Architecture for an indexer
abstract: Disclosed is a technique for indexing data. For each token in a set of documents, a sort key is generated that includes a document identifier that indicates whether a section of a document associated with the sort key is an anchor text section or a context section, wherein the anchor text section and the context text section have a same document identifier; it is determined whether a data field associated with the token is a fixed width; when the data field is a fixed width, the token is designated as one for which fixed width sort is to be performed; and, when the data field is a variable length, the token is designated as one for which a variable width sort is to be performed. The fixed width sort and the variable width sort are performed. For each document, the sort keys are used to bring together the anchor text section and the context section of that document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743060&OS=07743060&RS=07743060
owner: International Business Machines Corporation
number: 07743060
owner_city: Armonk
owner_country: US
publication_date: 20070806
---
This application is a continuation of and claims the benefit of U.S. Pat. No. 7 424 467 with application Ser. No. 10 764 800 filed on Jan. 26 2004 the disclosure of which is incorporated herein by reference in its entirety.

The present invention is related generally to an architecture for an indexer and more particularly to an architecture for an indexer that indexes tokens that may be variable length where variable length data may be attached to at least one token occurrence.

The World Wide Web also known as WWW or the Web is a collection of some Internet servers that support Web pages that may include links to other Web pages. A Uniform Resource Locator URL indicates a location of a Web page. Also each Web page may contain for example text graphics audio and or video content. For example a first Web page may contain a link to a second Web page.

A Web browser is a software application that is used to locate and display Web pages. Currently there are billions of Web pages on the Web.

Web search engines are used to retrieve Web pages on the Web based on some criteria e.g. entered via the Web browser . That is Web search engines are designed to return relevant Web pages given a keyword query. For example the query HR issued against a company intranet search engine is expected to return relevant pages in the intranet that are related to Human Resources HR . The Web search engine uses indexing techniques that relate search terms e.g. keywords to Web pages.

An important problem today is searching large data sets such as the Web large collections of text genomic information and databases. The underlying operation that is needed for searching is the creation of large indices of tokens quickly and efficiently. These indices also called inverted files contain a mapping of tokens which may be terms in text or more abstract objects to their locations where a location may be a document a page number or some other more abstract notion of location. The indexing problems is well known and nearly all solutions are based on sorting all tokens in the data set. However many conventional sorting techniques are inefficient.

Provided are a method system and program for indexing data. A token is received. It is determined whether a data field associated with the token is a fixed width. When the data field is a fixed width the token is designated as one for which fixed width sort is to be performed. When the data field is a variable length the token is designated as one for which a variable width sort is to be performed.

Also for each token in a set of documents a sort key is generated that includes a document identifier that indicates whether a section of a document associated with the sort key is an anchor text section or a context section wherein the anchor text section and the context text section have a same document identifier it is determined whether a data field associated with the token is a fixed width when the data field is a fixed width the token is designated as one for which fixed width sort is to be performed and when the data field is a variable length the token is designated as one for which a variable width sort is to be performed. The fixed width sort and the variable width sort are performed. For each document the sort keys are used to bring together the anchor text section and the context section of that document.

In the following description reference is made to the accompanying drawings which form a part hereof and which illustrate several implementations of the present invention. It is understood that other implementations may be utilized and structural and operational changes may be made without departing from the scope of the present invention.

Implementations of the invention provide a fast technique for creating indices by using a dual path approach in which the task of sorting indexing is broken into two separate sort processes for fixed width and variable width data.

The server computer includes system memory which may be implemented in volatile and or non volatile devices. A search engine executes in the system memory . In certain implementations the search engine includes a crawler component a static rank component a duplicate detection component an anchor text component an indexing component and a tokenizer . Although components and are illustrated as separate components the functionality of components and may be implemented in fewer or more or different components than illustrated. Additionally the functionality of the components and may be implemented at a Web application server computer or other server computer that is connected to the server computer . Additionally one or more server applications execute in system memory . System memory also includes one or more in memory sort buffers .

The server computer provides the client computer with access to data in at least one data store e.g. a database . Although a single data store is illustrated for ease of understanding data in data store may be stored in data stores at other computers connected to server computer .

Also an operator console executes one or more applications and is used to access the server computer and the data store .

The data store may comprise an array of storage devices such as Direct Access Storage Devices DASDs Just a Bunch of Disks JBOD Redundant Array of Independent Disks RAID virtualization device etc. The data store includes data that is used with certain implementations of the invention.

The goal of text indexing is to take an input document collection a document centric view and produce a term centric view of the same data. In the term centric view data is organized by term and for each term there is a list of occurrences also referred to as postings . A posting for a term consists of a list of the documents and offsets within the document that contain the term. In addition it is useful e.g. for ranking to attach some extra attributes to each term occurrence. Some example attributes include whether the term occurs in a title occurs in anchor text or is capitalized.

Indexing is equivalent to a sorting problem where a primary sort key is a term and a secondary sort key is an offset in the document. For example document D contains This is a test document D contains Is this a test and document D contains This is not a test . Table A illustrates term information in tabular form ordered as the terms would be read in from documents D D and D in that order in accordance with certain implementations of the invention.

The first column in Table A is the term the second column is the document identifier and the third column is the offset in the document fourth column is a data field and in this example the data field indicates whether a term is case folded capitalized where 1 is used to indicate that the term is case folded and a 0 indicates that the term is not case folded.

Sorting is also accompanied by a compression where the final index is written in a compact easily searchable form. Table B illustrates sorted terms from Table A in accordance with certain implementations of the invention.

Posting lists may be represented more compactly by grouping together occurrences of a term in a list as illustrated in Table C 

The documents are bundled in files in data store . That is when documents are retrieved by the crawler component one or more documents are stored into a file called a bundle. The bundle includes as many documents as fit into the bundle based on the size allocated for a bundle. In certain implementations the bundle size defaults to 8 MB megabytes . Having bundles improves performance by allowing large batches of documents to be fetched at once using sequential I O. Otherwise if each of the documents was retrieved as a separate file the seeks times would impact performance.

Doing a scan of the document store is I O bound. Each document in the data store contains a tokenized document content e.g. stored in data vectors and includes both an original token and a stemmed token. A tokenized document content may be described as breaking a document into individual terms with tokens determining word boundaries. An original token refers to an original term in a document e.g. running that includes case folding while a stemmed token refers to a root for the original token e g. run .

An arbitrary binary data field may be attached with each token occurrence. In certain implementations this data field is a one byte attribute field for document text tokens. In certain implementations the data field may be of varying width e.g. for document metadata tokens . For instance some metadata tokens include the document keyword count document unique keyword count document path e.g. URL or hash site path e.g. URL or hash and document rank.

The tokenized content is stored in the data store for performance reasons. That is tokenization and parsing are slow and CPU intensive. Once the bulk of documents have been crawled there are typically small incremental updates to the data store . Thus rather than re running the tokenizer each time an index is to be built e.g. once a day the stored tokenized document content is used to build the index.

In block the static rank component reviews the stored documents and assigns a rank to the documents. The rank may be described as the importance of the source document relative to other documents that have been stored by the crawler component . Any type of ranking technique may be used. For example documents that are accessed more frequently may receive a higher rank.

Thus document ranks are computed prior to indexing and the rank value is available at indexing time as part of a document. In certain implementations the rank is an ordinal document rank e.g. 1 2 3 4 etc. so as the documents come in the document rank may be used as the document identifier. The ordinal document ranks are monotonically increasing though they are not necessarily sequential e.g. there may be gaps as documents are being scanned . Documents need not be fed to the indexing component in rank order instead documents may be fed in using an arbitrary ordering.

In block an anchor text component extracts anchor text and builds a virtual document with the anchor text. In block optionally the duplicate detection component may perform duplication detection to remove duplicate documents from data store . The duplicate detection processing may also occur as documents are being stored.

There are many variations on indexing and on compressing posting lists. One approach is a sort merge approach in which sets of data are read into memory each set sorted and each set copied to storage e.g. disk producing a series of sorted runs. The index is generated by merging the sorted runs.

In certain implementations the indexing component implements a sort merge approach. The sort merge approach provides good performance and is suitable for batch style indexing in which data is indexed at once. Internally the indexing component has two phases index build runs and index merge.

Although any hash function may be used with various implementations of the invention one that is fast and that works well on large amounts of text tokens that have many common prefixes and suffixes is useful. In certain implementations Pearson s hash function is used which is described further in Fast Hashing of Variable Length Text Strings by Peter K. Pearson Communications of the ACM 33 6 677 680 June 1990. Pearson s hash function is scalable.

The location includes a 32 bit unique document identifier a bit that indicates whether the section associated with the sort key is content or anchor text and a 31 bit offset that identifies the offset of the term within the document. When a document is read from the data store the location of the document is generated using the document rank and the token offset within the document. Since a full sort is later done on the location documents may arrive in any order and the indexing component is able to reorder them properly in rank order. Also multiple terms may occur at a same location e.g. which is useful for adding metadata to mark terms or sequences of terms .

Thus rather than having separate document identifier ID fields and offset fields certain implementations of the invention use a global 64 bit location to identify the locations of terms. With the use of this 64 bit location up to 4 billion documents are supported in one index with 4 billion locations in each document. In alternative implementations other bit sizes may be used for the global location. Also each posting occurrence may have arbitrary binary data attached to it e.g. for ranking .

Looking at the bit encoding of the sort key by sorting on the sort key implementations of the invention simultaneously order the index by the token identifier. Additionally the encoding of the sort key allows the content tokens to come before the metadata tokens allowing the two paths for the content fixed width and metadata variable width tokens to be sorted independently and brought together in the merge phase . The encoding of the sort key for each unique token identifier allows occurrences to be ordered by document identifier and if the document identifier is also the document rank then the tokens are in document rank order. Anchor text and content portions of a document may be processed separately and brought together because both portions have the same document identifier. For document occurrences of each token the offsets of the occurrences within the document are in occurrence order due to the sorting technique used e.g. due to the stable sort property of a radix sort . Tokens within a document may be fed in order while anchor documents may be fed in after the content documents.

In block the indexing component determines whether a sort key is for a fixed width sort. If so processing continues to block otherwise precessing continues to block .

In block the indexing component forwards the sort key to a fixed width sort via the second in memory sort buffer and processing loops back to block . In block the indexing component forwards the sort key to a variable width sort via the third in memory sort buffer and processing loops back to block . If all documents in the first in memory sort buffer have been processed the indexing component scans a new set of documents into the in memory sort buffer for processing until all documents have been processed.

In in block the indexing component determines whether the second in memory sort buffer is full. If so processing continues to block otherwise processing loops back to block . In certain implementations in block the indexing component treats a sort buffer as full if all tokens in all documents have been processed and so additional sort keys will not be added to the sort buffer. In block the indexing component performs a fixed width sort on the sort keys in the second in memory sort buffer. In block the indexing component writes the sorted run to temporary storage. In block the indexing component resets the second in memory sort buffer which allows additional sort keys to be stored in the second in memory sort buffer.

In in block the indexing component determines whether the third in memory sort buffer is full. If so processing continues to block otherwise processing loops back to block . In certain implementations in block the indexing component treats a sort buffer as full if all tokens in all documents have been processed and so additional sort keys will not be added to the sort buffer. In block the indexing component performs a variable width sort on the sort keys in the third in memory sort buffer. In block the indexing component writes the sorted run to temporary storage. In block the indexing component resets the third in memory sort buffer which allows additional sort keys to be stored in the third in memory sort buffer.

The in memory sort buffer controls the size of the sorted runs which in turn is related to the total number of sorted runs generated. In certain implementations each in memory sort buffer is as large as possible as some systems have low limits on the number of file descriptors that may be opened at once. In particular in certain implementations each sort run is written to disk as a separate file and at merge time all of these files are opened in order to perform the merging. In certain operating systems each file that is currently open uses up a file descriptor and in some cases there is a limit to the number of file descriptors and thus files that can be open at one time by a process. Additionally the indexing component uses a linear time in memory sort technique so that performance does not change as the in memory sort buffer size increases. In certain implementations the in memory sort buffer size defaults to 1.5 GB gigabytes .

With reference to in a pipelined approach to indexing pipelining speeds up indexing by allowing I O and computation work to overlap. There are several places where the sort may be pipelined in implementations of the invention. First prefetching read threads may be used to read in data from the data store and store the data in a queue . An indexer thread scans tokens in the documents hashes the tokens generates sort keys and accumulates sort keys in a sort buffer. The indexer thread forwards a sort key that is for content i.e. fixed width data to an indexer sort and forwards a sort key that is for metadata i.e. variable width data to a disk sort . The indexer sort performs some processing and stores the sort keys in queue and when queue is full a radix sort thread performs a fixed width sort of the sort keys and stores the sorted keys as a sorted run in a temporary data store . The disk sort performs some processing and stores the sort keys in queue and when queue is full a radix sort thread performs a variable width sort of the sort keys and stores the sorted keys as a sorted run in a temporary data store .

The indexing component takes advantage of the fact that when inserting tokens of a document into an in memory sort buffer the locations of the tokens are being inserted in order. Since radix sort is a stable sort that preserves the inserted order of elements when there are ties a 96 bit radix sort may be used since the tokens within a document are inserted in order these are the lower 32 bits of the sort key . Additionally if there were no document location remapping a 64 bit radix sort may be used. Because documents are inserted in arbitrary rank and thus arbitrary document identifier order a 96 bit radix sort is used.

Thus when a sort buffer is full the sort buffer is handed off to an appropriate sort thread that performs radix sort and writes the sorted run to storage.

In order to use the pipelined parallel processing technique of the indexing component replaces variable width tokens with a fixed width token identifier e.g. by assigning a unique sequentially generated identifier number or using a hashing function . That is the variable width tokens are transformed into fixed width tokens. When a uniquely generated identifier is used a mapping of terms to identifiers is maintained so that as terms are indexed the terms are replaced with their identifiers. A hash function using a large hash space is unlikely to have collisions. In certain implementations a 63 bit hash reserving the upper for marking special meta tokens may be used. In addition with use of the 63 bit hash certain testing indicated that there were no collisions among 260 million terms. In certain alternative implementations a hash function approach using a minimal perfect hash function that ensures that there are no collisions may be used.

In practice a large percent e.g. 99.9 of the data fields are one byte long while the remaining data fields are of variable width. Thus the sorting may be separated into two sorts one where the data fields are one byte and one where the data fields are variable width. This results in an optimizable fixed width field sorting problem in which a 128 bit sort key is composed of the term identifier in the upper 8 bytes and the location in the lower 8 bytes along with a fixed width data field e.g. one byte that is carried along with the sort key. Additionally the variable width data field case may be handled by a slower more general radix sort that works with variable width fields.

In block the indexing component performs remapping. It is possible that documents fed into the indexing component have gaps in their rank value e.g. documents etc. are received leaving a gap between ranks and . The indexing component remaps the rank locations to close up the gaps ensuring that they are in sequence. In certain implementations this is done by keeping a bit vector of the document identifiers that were put in the indexing component . In certain implementations the bit vector is defined to be of the size of MaximumDocumentRank 50 000 000 bits so that the bit vector takes up about 48 MB. At the start of the multi way merge phase a remapping table is built that maps each document identifier to a new value. MaximumDocumentRank may be described as a value for a maximum document rank. In certain implementation this table is MaximumDocumentRank 4 bytes 191 MB in size. During the multi way merge phase each token document identifier is remapped to remove the gaps. In certain implementations the remap table is not allocated until after the sort buffer e.g. the second or third in memory sort buffer referenced in blocks and respectively has been deallocated.

In block the indexing component associates anchor text with corresponding content. That is the indexing component also brings together multiple pieces of a document if they are read from the data store at different times. In certain implementations two document pieces are supported a content section and an anchor text section. In certain implementations the content section arrives and then the anchor text section arrives at a later time. This feature of the indexing component is used to append anchor text to a document by giving anchor text locations in which the upper bit of the offset is set. Prior to indexing the anchor text is extracted and a virtual document is built with the anchor text. This allows for sending the content of a document separately from the anchor text that points to the document. The content section and anchor text section may be correlated using a common document identifier.

In block the indexing component generates a final index with a dictionary a block descriptor and postings. illustrates output of the indexing component in accordance with certain implementations of the invention. In certain implementations the indexing component writes three types of output files a dictionary file a block descriptor file and a postings file . The dictionary file contains the terms certain statistics for each term and a pointer to the blocks that contain the term. The block descriptor file contains pointers into blocks of the postings file and certain additional information that is useful for random access. The blocks in the postings file may be the smallest unit of I O performed on the postings file e.g. one block may be 4096 bytes . The postings file contains raw posting list information for the terms and includes the location and data field along with a fast access lookup table. The intra block lookup table may be used to increase query performance. Without the lookup table if an average random posting is in the middle of a block then accessing that posting would require starting from the first element in the block and decompressing and scanning each element prior to the desired posting. The lookup table allows accessing the location nearer to the block which saves a large amount of unnecessary decompression work.

In the numbers in parenthesis are the number of bytes used to encode a particular field. For example for fields labeled VInt32 a compressed variable width byte encoding of a 32 bit number is used and for fields labeled VInt64 a compressed variable width byte encoding of a 65 bit number is used. In certain implementations because the final files may grow large there may be file splitting of final files.

Reordering posting lists in document rank order is useful so that documents with higher rank occur earlier in the posting list to allow for early termination of a search for terms using the index.

In during the merge phase prefetching threads read data from the sorted runs in temporary storage into a queue . A heap merge thread is a multi way merge thread that implements a heap merge with results being stored in queue . A final index thread outputs compressed index files to storage .

In certain implementations 2 way Symmetric Multiprocessors SMPs may be utilized for the parallel processing of .

In certain alternative implementations rather than using a sort merge approach the indexing component uses a Move To Front MTF hash table to accumulate posting lists for terms in memory. The MTF hash table allows a sort to be performed on the unique tokens which are the hash keys rather than on all occurrences. When an MTF hash table is used dynamically resizable vectors are maintained to hold the occurrences of each term which requires CPU and memory resources.

Thus the implementations of the invention provide a high performance general purpose indexer designed for doing fast and high quality information retrieval. Certain implementations of the invention make use of a dual path approach to indexing using a high performance pipelined radix sort. Additionally implementations of the invention enable document rank ordering of posting lists per occurrence attribute information positional token information and the bringing together of documents in pieces e.g. content and anchor text .

Thus the sort for index creation takes as input a set of token occurrences called postings that include a token the document the token occurs in the offset within the document and some associated attribute data. Postings are sorted by token document and offset in that order so the token is the primary sort key the document is the secondary sort key and the offset is the tertiary sort key. The data field is carried along through the sort process.

Implementations of the invention provide a high performance sort based on the fact that for many postings the data field is of constant size. Using a fixed width token ID to represent the token the postings may be represented by a fixed width binary data structure. Also the data field is a fixed width in many cases by construction. Therefore a fast fixed width sort may be used to sort the fixed width postings.

The postings that can not be handled by a fixed width sort are ones that have a variable width data field. These postings are sorted by a variable width sort. The results of both sorts are combined during a multi way merge phase. In alternative implementations the merge may be avoided and the two sets of sorted postings may be maintained separately.

The sort keys are encoded so that during the sorting process the index is simultaneously ordered by term terms are ordered by document ID and offsets within documents are also ordered.

The offsets are encoded within a document so that multiple parts of a document are brought together automatically by the sort. Thus the parts of a document may be fed into the index build separately. Conventional indexers require that documents be fed in as a whole.

In certain implementations a radix sort may be used because the radix sort sorts in linear time for fixed width sort keys and is stable i.e. preserves the original ordering of sort element when there are ties in a sort key . The stable sort property of radix sort is used to further improve indexing performance. In particular if tokens in each part of a document are already in location order sort is performed on the portion of the sort key that is needed to generate correct sort results.

If all tokens within a document are fed in order the sort key need not use the offset portion but can sort on token type token document identifier and document section. If the document sections arrive in order then the sort can be on token type token and document identifier. If the documents are in document rank order the sort can be on token type and token.

Thus the indexing component may have different implementations based on the order in which tokens document sections and documents arrive. For example in certain implementations the indexing component recognizes that tokens of a given document are fed in order of appearance. In certain implementations the indexing component recognizes that for document sections the content sections arrive before the anchortext sections. Also in certain implementations the indexing component recognizes that the documents are fed in document rank order. Furthermore in additional implementations the indexing component recognizes the order for two or more of tokens document sections and documents.

The described techniques for an architecture for an indexer may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. The term article of manufacture as used herein refers to code or logic implemented in hardware logic e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. or a computer readable medium such as magnetic storage medium e.g. hard disk drives floppy disks tape etc. optical storage CD ROMs optical disks etc. volatile and non volatile memory devices e.g. EEPROMs ROMs PROMs RAMs DRAMs SRAMs firmware programmable logic etc. . Code in the computer readable medium is accessed and executed by a processor. The code in which various implementations are implemented may further be accessible through a transmission media or from a file server over a network. In such cases the article of manufacture in which the code is implemented may comprise a transmission media such as a network transmission line wireless transmission media signals propagating through space radio waves infrared signals etc. Thus the article of manufacture may comprise the medium in which the code is embodied. Additionally the article of manufacture may comprise a combination of hardware and software components in which the code is embodied processed and executed. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention and that the article of manufacture may comprise any information bearing medium known in the art.

The logic of A B C and A describes specific operations occurring in a particular order. In alternative implementations certain of the logic operations may be performed in a different order modified or removed. Moreover operations may be added to the above described logic and still conform to the described implementations. Further operations described herein may occur sequentially or certain operations may be processed in parallel or operations described as performed by a single process may be performed by distributed processes.

The illustrated logic of A B C and A may be implemented in software hardware programmable and non programmable gate array logic or in some combination of hardware software or gate array logic.

The computer architecture may comprise any computing device known in the art such as a mainframe server personal computer workstation laptop handheld computer telephony device network appliance virtualization device storage controller etc. Any processor and operating system known in the art may be used.

The foregoing description of implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many implementations of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

