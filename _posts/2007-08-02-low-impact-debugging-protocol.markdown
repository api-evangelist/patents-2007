---

title: Low impact debugging protocol
abstract: Methods and apparatus, including computer program products, are provided for debugging using dynamic compilers. The method may include receiving a first indication to grant access to a set of variables and to allow access to be inhibited to a set of remaining variables. The dynamic compiler may be allowed to optimize the set of remaining variables, while the set of granted variables is preserved. A second indication may be provided to acknowledge access to the set of granted variables and allow access to be inhibited to the set of remaining variables. In some variations, the set of granted variables is implemented as a set of live variables and the set of remaining variables is implemented as a set of dead variables. Related apparatus, systems, methods, and articles are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08312438&OS=08312438&RS=08312438
owner: SAP AG
number: 08312438
owner_city: Walldorf
owner_country: DE
publication_date: 20070802
---
The present disclosure generally relates to compilers and and more particularly debugging protocols for use with dynamic compilers.

A Java Virtual Machine JVM also referred to as a Java Runtime is a program that can execute other programs application programs provided as Java bytecode. Java bytecode usually but not exclusively is generated from programs written in the Java programming language. Java program code may be executed in an interpreted mode in compiled mode or using a mixture of the two modes. In addition to governing the execution of an application s bytecodes the JVM handles related tasks such as managing memory providing security and managing multiple threads of program execution. The JVM is a so called layer on top of the operating system of the host i.e. the physical machine . The JVM thus provides portability of applications across various operating systems and corresponding physical machines i.e. hardware .

A dynamic compiler refers to a compiler built into a virtual machine such as a JVM. For example a dynamic compiler may compile procedures of the target program immediately before their first invocation or concurrently with execution. Dynamic compilers may provide accelerated execution of Java bytecode in JVMs. Moreover a virtual machine with a dynamic compiler may execute a program code in an interpreted mode in a dynamically compiled mode or a combination of the two modes. A dynamic compiler may generate optimized code sequences corresponding to the code sequences of an application as the application is being executed by an interpreter. The generated code sequence may be stored in cache and subsequent invocations of the same code sequence prompt an interpreter to query cache for the existence of a compiled version of the same code. If such a compiled version exists then it is executed else the incoming code sequence is interpreted by the interpreter. Concurrent with the execution of a procedure the compiler may compile or recompile a procedure several times to further optimize it. The dynamic compiler is considered dynamic since it generates optimized code for applications while these applications are running and the dynamic compiler may generate new more optimized code while the original code is being executed interpreted or compiled. In contrast a static compiler completely compiles the program e.g. into machine specific binary code or into portable bytecode before it is executed and compilation and optimization are not performed dynamically as the application is being executed.

To debug a program refers to inspection and manipulation of the operations of the program while the program is being executed e.g. by a virtual machine . This may include setting breakpoints single stepping observing the program s variables changing the program state e.g. the state of the virtual machine and registering for events that might occur during execution.

Any compiler static or dynamic needs to know in advance whether it must produce code that can be debugged is debuggable or not. Producing debuggable code restricts the compiler in the amount of optimization that may be applied to the original program. A larger degree of debuggability means a lesser degree of possible optimization and vice versa. While it may be the case that the performance of a debuggable program need not be optimized e.g. since debuggability might play a role only during development enhanced supportability of running server application programs may be needed to balance the achievable performance of the application programs with the desired degree of debuggability.

A live variable refers to a local variable that is being used in the current execution path of a program. Specifically a local variable X is called live or live out at some point P in a program if there is a path in the program from that point P to another point Q such that the value of the variable X is read at point Q but X does not get written to i.e. overwritten on this path otherwise the variable X is considered to be a dead variable at point P in the program. A dead variable cannot have any impact on the future behavior of the program. The only reason dead variables may have to be maintained in a compiled program e.g. by saving their values from processor registers to memory is for extended debugging purposes.

The Java Virtual Machine Tools Interface JVMTI is an application programming interface API that allows a program called the JVMTI client to inspect the state and to control the execution of application programs running in a JVM in this context referred to as a JVMTI server. As such JVMTI is used to implement debuggers profilers and other tools accessing the state of the JVM and the application programs running within the JVM. Since the JVMTI is a native interface of the JVM a JVMTI client is implemented as a library that is loaded during JVM initialization. When loaded the JVMTI client may gain access to and manipulate the JVMTI server i.e. the JVM via procedure calls also referred to as in process messages . These procedure calls may be directed from the JVMTI client to the JVMTI server but may also occur in the other direction.

The Java Debug Wire Protocol JDWP is a communication protocol between a JDWP client and a JDWP server that is associated with a JVM. A protocol generally refers to allowed exchanges of messages between two communicating parties. The part that initiates the communication is called the client while the so called server operates on behalf of the client. In particular a debugging protocol specifies the way a debugger client may communicate with a debug server such as a JVM. A JDWP client typically includes an interactively used debugger that allows the user to debug a running Java program in the remote JVM associated with the JDWP server. The message exchange between the JDWP client and the JDWP server typically takes place across a network as opposed to the in process message exchange in JVMTI. The JDWP server typically is implemented as a JVMTI client hosted by a JVMTI capable JVM.

The subject matter disclosed herein provides methods and apparatus including computer program products for a debugging protocol for use with a dynamic compiler.

In one aspect there is provided a computer implemented method for dynamic compilers. The method may include receiving an indication at the virtual machine which lets the virtual machine grant access to a set of live variables in subsequent requests of the client e.g. for debugging purposes . This grant does not imply that the virtual machine also allows access to a set of dead variables. The live variables and dead variables referred to are associated with a program that may undergo compilation by a dynamic compiler. The virtual machine may inhibit access to the set of dead variables based on the received indication to enable the dynamic compiler to compile the program without having to preserve the set of dead variables. The virtual machine may provide an indication acknowledging that the virtual machine grants access to the set of live variables. Otherwise the virtual machine may provide an error indication that the virtual machine does not provide the grant of access to the set of live variables. For example if a client receives an acknowledgement then the client may assume that subsequent accesses to live variables will be successful but the client may not assume that accesses to dead variables will be successful as well. If the client receives the error indication then the client must not assume that any access to live variables will be successful.

The subject matter described herein may be implemented to realize the advantage of improved compilation e.g. dynamic compilation of programs e.g. in a virtual machine such as a JVM by enabling compilation to optimize on dead variables but not on live variables. Compiling to optimize on dead variables but not live variables may maintain a higher degree of debuggability of the generated code when compared to optimizing on all variables. Moreover compiling to optimize on dead variables but not live variables may maintain a higher degree of possible optimizations than if all variables are required to be preserved by the compiler.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive. Further features and or variations may be provided in addition to those set forth herein. For example the implementations described herein may be directed to various combinations and subcombinations of the disclosed features and or combinations and subcombinations of several further features disclosed below in the detailed description.

When a program is to be debugged a compiler is restricted when optimizing the program. For example a debugger may attempt to access local variables of the program being debugged. As such the compiler must preserve all variables of the original uncompiled program at any point in the compiled program to enable the debugger to access those variables. The preservation of all variables at any point in the compiled program restricts optimization of the performance of the program. In some instances preserving all local variables may be unnecessary since many debugging operations may be performed using only the live variables. To that end the subject matter described herein provides a protocol for debugging that allows a debugging client to control or inspect the degree of accessibility of variables i.e. to control whether access to any variables needs to be granted at all whether the access may be restricted to live variables or whether all variables must be kept accessible. In some implementations the debugging protocol described herein may be implemented as a client server debugging protocol such as a protocol incorporated into e.g. as a modification to or an extension of the Java Virtual Machine Tool Interface JVMTI and the Java Debugger Wire Protocol JDWP . For example JVMTI and JDWP may be modified to include the features described herein to enable a debugging client to indicate that debugging needs access to live variables and not dead variables. Therefore the dynamic compiler e.g. the compiler of the JVM has the freedom to optimize without regard to dead variables.

Java is a dynamically compiled language. The subject matter described herein may achieve the greatest benefit in terms of optimization if the program code is dynamically compiled and the compiler supports deoptimization. Deoptimization refers to dynamic compilers of JVMs capable of deoptimization by interrupting the execution of a running procedure at certain deoptimization points and continuing to run the procedure in interpreted e.g. unoptimized mode. Deoptimization enables adaptation of the compiled procedures by deoptimizing and then possibly recompiling in order to adapt to changed conditions during the execution of the program. Supporting deoptimization requires that the JVM reconstruct the unoptimized interpreter state at the deoptimization points. In particular the values of live variables of the unoptimized program must be known even in the optimized code. As a consequence granting live variables access to a debugging client does not additionally restrict the achievable optimization. Although a JVM is described other types of virtual machines may be used as well.

The following refers to implementations incorporated into a JVM and debugging protocols JVMTI and JDWP although other compilers and debugging protocols may include the features described herein.

JDWP client provides an interface for debugging of program code e.g. running within a JVM at JVMTI server . The JDWP client defines the communication protocol e.g. format between the debugger i.e. client debugger and the program being debugged e.g. executed by JVM . Moreover in some implementations the JDWP client may also provide information regarding the state of the JVM to debuggers and other systems. For example JDWP client may provide access to a running JVM s state class array interface primitive types and instances of those types. The JDWP client may also provide explicit control over execution of the JVM including suspension and resumption of threads setting breakpoints setting watchpoints setting notification of exceptions class loading thread creation inspection of suspended thread state inspection of local variables inspection of stack backtrace and the like.

JDWP client may send and or receive one or more messages to from JDWP server as part of the debugging of the JVM . Messages may include command and reply messages. For example JDWP client may send a command message and receive a reply message from JDWP server . A command message also referred to as a command packet may be sent by JDWP client JDWP server and JVMTI client to request information from the JVM or to control program execution of the JVM . In some cases command packets are sent by JDWP server to notify JDWP client of some event in the JVM e.g. a breakpoint or an exception . A reply message may be sent only in response to a command packet and provides information regarding the success or failure of a command. Reply packets may also carry any data requested by a command e.g. the value of a field or variable .

The JDWP server receives messages e.g. commands from JDWP client and includes a JVMTI client . The JDWP server including JVMTI client exchanges on one or more procedure call s with JVMTI server which is hosted by the JVM . The JVM runs the program which may be compiled that is being debugged. The procedure calls enable JDWP server to interact with JVMTI server to process the commands and replies associated with JDWP client during debugging of the JVM.

The Java Virtual Machine Tool Interface JVMTI is a protocol for in process communication between a JVMTI client e.g. JVMTI client and a JVMTI server e.g. JVMTI server . The JVMTI client includes a dynamic library for loading into a JVMTI capable JVM e.g. JVM . The JVMTI client provides the client side JVMTI procedures. The JVMTI is a programming interface used by development and monitoring tools to provide both a way to inspect the state and to control the execution of applications running in the JVM . Specifically JVMTI provides a virtual machine interface to access the state of JVM including one or more of the following profiling debugging monitoring thread analysis and coverage analysis tools. JVMTI is a so called two way interface including a client of JVMTI such as JVMTI client which may be notified of events at JVM . JVMTI enables query and control of JVM either in response to events or independent of them. The JVMTI client runs in the same process with and communicate directly with the virtual machine executing the application being examined e.g. the application in JVM . Moreover the JVMTI client may be the backend that supports remote debugging via JDWP messages while the JVMTI server is a JVM implementation that provides the JVMTI server side procedures and provides functionality for loading the JVMTI client library .

Table 2 depicts a machine code fragment showing how full debuggability of the procedure diagonal of Table 1 has to preserve dead variables.

Table 3 depicts a machine code fragment showing how optimization of the procedure diagonal of Table 1 may remove dead variables.

The subject matter described herein thus provides a protocol which may be used to obtain access to live variables but not necessarily to dead variables. In some implementations JVMTI client may use a can access live variables request message to demand access to live variables but not to dead variables and JVMTI server will respond with a can access live variables reply message e.g. a confirmation as described further below.

In some implementations negotiating the desired debugging capabilities takes place in the early on load phase since the compiler might need to know the desired features in advance as depicted for example in . When JVMTI server does not grant access to local variables and does not grant access to live variables e.g. in the can access live variables request has been denied by message and a can access local variables request has not been granted by JVMTI server or JVM then JVMTI client may nevertheless attempt to access a local variable including dead variables or live variables by a message . In this case JVMTI server may reply an error message such as JVMTI ERROR MUST POSSESS CAPABILITY. 

Compared to the can access local variables state being in the can access live variables state allows the dynamic compiler of JVM to enhance optimizations in generated code. The dynamic compiler may eliminate some or all of the dead variables and hence enjoy less register pressure less spilling code and more opportunities for dead code removal all of which contribute to better optimization of the application program executed by JVM .

In some implementations a dynamic compiler of JVM may support deoptimization of dynamically compiled program code. With deoptimization support the dynamic compiler of the JVM must preserve all of the live variables so the JVMTI client may request the can access live variables state e.g. message at any time e.g. in the on load and in the live phase of JVM execution and may be subsequently confirmed e.g. by message .

In some implementations where the compiler of JVM does not support deoptimization JVM may still offer the can access live variables state during the on load phase. For example the JVMTI client may request the can access live variables state at startup i.e. on load of JVM . If this is granted by confirmation message the compiler optimization is thus restricted to require the compiler to preserve the live variables while possibly not preserving the dead variables. Without having confirmed the can access live variables state the JVM s dynamic compiler can perform a full optimization that does not preserve live or dead variables.

Although depict specific messages the messages e.g. commands replies error messages and the like associated with JVMTI and JDWP include a variety of other messages as well.

The JVMTI client includes an Agent OnLoad procedure. The Agent OnLoad procedure must be called by JVM and or JVMTI server on startup i.e. on load when loading the JVMTI client library. The Agent OnLoad procedure enables JVMTI client to configure the desired features of the JVMTI server . At startup the JDWP server if implemented as a JVMTI client may request can access live variables but not can access local variables from the JVMTI server . When this is the case the JVMTI server does not have to restrict the dynamic compiler of JVM with regard to the dead variables. When the JDWP server and or JVMTI client requests both can access live variables state and can access local variables state but only obtains can access live variables confirmation then JDWP server may still startup properly. This is because JDWP server is allowed to merely grant access to live variables at the JVM to the JDWP client . When JDWP server as well as JVMTI client does not obtain at least the can access live variables confirmation at startup then JDWP server and with it JVMTI server and JVM may choose to terminate with an error since JDWP server and JVMTI server cannot satisfy JDWP client requests for the minimum useful subset of variables namely live variables.

Table 4 below includes a sample implementation of the Agent OnLoad procedure in the form of pseudo code in Scheme syntax of a JDWP server making use of JVMTI services described above.

The JDWP server may refuse to deliver or manipulate values of dead variables when it has only obtained as a JVMTI client the can access live variables confirmation without having obtained the can access local variables confirmation . In this state JDWP server may still choose to deliver or manipulate dead variables if the dead variables reside within frames of interpreted rather than compiled methods.

Table 5 lists pseudo code demonstrating how JDWP server may interact with JDWP client . For simplicity it is assumed that the incoming requests only access a single variable although access to a set of variables may be implemented as well.

In some implementations system may be interoperable with a command line debugger known as jdb commercially available from Sun Microsystems Inc. . The jdb debugger is a prior JDWP client. Table 6 depicts a sample session protocol of how jdb handles the behavior of the JDWP of when a dead variable is accessed. The debugged program rests at a breakpoint in the jdb break here procedure and the calling procedure check live among dead locals is compiled.

Referring to Table 6 the value of the live variable ilive may be read properly. Attempting to read the value of the dead variable idead yields the error code which corresponds to INVALID SLOT. The locals command of jdb tries to access all the variables of the frame at once via a single JDWP command GetValues. Since among the variables there are dead ones this will lead to an error and no variable will be obtained at all. An improved jdb client might avoid this error condition by using GetLiveValues instead of GetValues. 

The systems and methods disclosed herein may be embodied in various forms including for example a data processor such as a computer that also includes a database digital electronic circuitry firmware software or in combinations of them. Moreover the above noted features and other aspects and principles of the present disclosed embodiments may be implemented in various environments. Such environments and related applications may be specially constructed for performing the various processes and operations according to the disclosed embodiments or they may include a general purpose computer or computing platform selectively activated or reconfigured by code to provide the necessary functionality. The processes disclosed herein are not inherently related to any particular computer network architecture environment or other apparatus and may be implemented by a suitable combination of hardware software and or firmware. For example various general purpose machines may be used with programs written in accordance with teachings of the disclosed embodiments or it may be more convenient to construct a specialized apparatus or system to perform the required methods and techniques.

The systems and methods disclosed herein may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

The foregoing description is intended to illustrate but not to limit the scope of the invention which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims.

