---

title: Computer memory addressing mode employing memory segmenting and masking
abstract: A computer addressing mode and memory access method rely on a memory segment identifier and a memory segment mask for indicating memory locations. In this addressing mode, a processor receives an instruction comprising the memory segment identifier and memory segment mask. The processor employs a two-level address decoding scheme to access individual memory locations. Under this decoding scheme, the processor decodes the memory segment identifier to select a particular memory segment. Each memory segment includes a predefined number of memory locations. The processor selects memory locations within the memory segment based on mask bits set in the memory segment mask. The disclosed addressing mode is advantageous because it allows non-consecutive memory locations to be efficiently accessed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07921274&OS=07921274&RS=07921274
owner: QUALCOMM Incorporated
number: 07921274
owner_city: San Diego
owner_country: US
publication_date: 20070419
---
The invention relates generally to computers and more specifically to memory addressing schemes used in computers.

In some computing environments system size and power consumption are key design constraints. For example in mobile systems such as laptops personal digital assistants PDAs cellular phones and other wireless mobile devices the physical space and power available for computing resources is relatively limited. In these systems power is generally limited to available battery capacity and size is generally limited by consumer tastes.

Despite environmental constraints the market demand for increased functionality has consistently challenged the limits of mobile computing technology. Users seemingly have an insatiable desire for new and enhanced features on their mobile devices. Examples of enhanced mobile features include cameras both video and still video players music players email texting web browsing games and the like. All of these features can be integrated into a single mobile device with wireless phone and data services. Some of these features particularly advanced 3 D gaming and other graphics applications are computationally and memory intensive. To support such demanding applications on resource limited platforms it is desirable to have a relatively small computing unit that is capable of providing the necessary performance at reduced levels of power consumption.

It is an advantage of the present invention to provide a computer system that reduces power consumption and increases bus efficiency by reducing bus traffic in certain operational circumstances. In modern computers power consumption is related to the number of information bits being transferred over internal buses. To reduce bus traffic the computer system disclosed herein includes a novel memory addressing mode that significantly reduces the number address bits used in making certain bus transfers.

In accordance with an exemplary embodiment of the invention a computer processor addressing mode relies on a memory segment identifier and a memory segment mask for indicating memory locations. In this addressing mode the processor receives an instruction comprising the memory segment identifier and memory segment mask. The processor decodes the memory segment identifier to select a particular memory segment. Each memory segment includes a predefined number of memory locations. The processor selects memory locations within the memory segment based on mask bits set in the memory segment mask. The disclosed addressing mode is advantageous because it allows both consecutive and non consecutive memory locations to be efficiently accessed.

Other aspects features embodiments methods and advantages of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional features embodiments processes and advantages be included within this description be within the scope of the invention and be protected by the accompanying claims.

The following detailed description which references to and incorporates the drawings describes and illustrates one or more specific embodiments of the invention. These embodiments offered not to limit but only to exemplify and teach the invention are shown and described in sufficient detail to enable those skilled in the art to practice the invention. Thus where appropriate to avoid obscuring the invention the description may omit certain information known to those of skill in the art.

Turning now to the drawings and in particular to there is illustrated a block diagram of a computer system in accordance with an exemplary embodiment of the present invention. The computer system is not limited to any particular operational environment or application however it is preferably incorporated in a wireless mobile device such as a cellular phone PDA laptop computer or the like. Furthermore the computer system can be implemented using any suitable computing technology. For example the system may be built using any suitable combination of hardware and software components and may be implemented as a system on a chip or alternatively it may be implemented using multiple chips and components.

The system includes a co processor in communication with a central processing unit CPU by way of a system bus . A system memory is also connected to the system bus and is accessible to the CPU and co processor .

The co processor employs a two level address decoding scheme that decodes a register segment identifier ID and a register segment mask to access individual registers. In the first level of decoding the register segment ID is decoded by digital circuitry to indicate a register segment. In the second level of decoding the register segment mask is decoded by digital circuitry to select individual registers in the register segment. The two level address decoding scheme generally uses fewer addressing bits when compared to conventional global address schemes. In addition the scheme simplifies the address decoding logic contained in the co processor .

The co processor supplements the functions of the CPU by offloading certain processor intensive tasks from the CPU to accelerate the overall system performance. Preferably the co processor is a graphic processing unit GPU that accelerates the processing of 3 D graphics.

In most GPUs including co processor there are internal configuration registers see Reg Reg N that need to be loaded with data or control values before the GPU begins its rendering operations. To accomplish this rendering configuration a driver sends a set of register data units to the co processor through the system bus which is preferably 32 bits and or 8 bit aligned. These internal configuration registers can be periodically updated by the driver based the operational state of the rendering.

Conventional GPUs use global addressing to locate their internal configuration registers. Thus if a conventional GPU has n internal registers the register address bits will require m bits where 2 n. With conventional global addressing there are typically three ways for a driver to send registers to a GPU co processor pack mode pair mode and consecutive mode. Using pack mode the register address is included with register data in a single bus wide word so only one system bus transaction is needed to load each internal register. With pair mode each register data unit is transferred with its destination register address both of which are bus width words. Thus using this mode two system bus transactions are needed to load a single internal register. Using consecutive mode internal registers consecutive in address are updated sequentially by a single instruction. The instruction includes a header packet which contains a base address of the first register and a count of the total number of registers to be updated followed by the register data units.

Because the system bus width is typically 32 bits or 8 bits aligned the following problems may occur with the above conventional addressing modes. For pair mode the register address itself consumes one entire system bus cycle. Thus the overhead for loading co processor registers using this mode is relatively large. For pack mode the register data is limited to the remaining bits after the bits for the register address. The number data bits that are allowed in pack mode are insufficient for some applications. Also to send a group of register data units using pack mode still requires a multi bit register address for each bus transfer. Where a co processor has numerous internal registers the bus bandwidth consumed by address bits can become unsuitably large. The consecutive mode is efficient for loading internal registers consecutive in address. However there are situations where registers to be loaded are not consecutively located non consecutive in address . In these situations therefore multiple short consecutive register batches have to be used in which the header packet overhead will outweigh the savings normally achieved by consecutive mode addressing.

The segment mask addressing mode disclosed herein overcomes the shortcomings of the pair pack and consecutive addressing modes described above. More particularly the segment mask addressing mode effectively reduces the address bits of registers which means that the bus traffic is reduced and that the data payload becomes greater relative to the number of bits used for addressing. This significantly reduces system power consumption in certain operational scenarios such as 3 D graphics processing. Furthermore as bus interfaces become wider e.g. 64 or 128 bits the efficiencies of the segment mask address mode increases.

The segment mask addressing mode entails two aspects that differentiate it from conventional global addressing register segmenting and register segment masking. The co processors described herein employ two level address decoding to access registers addressed by the segment mask addressing mode.

Register segmenting divides registers into plural predefined groups segments . The segments are addressed by the register segment identifier ID . Preferably each segment of registers is dedicated to a corresponding functional unit in the co processor because individual functional units are usually programmed for the same rendering function. Each functional unit can include a different number of registers in its register segment. It is also contemplated that multiple register segments can be included in a single functional unit.

Register segment masking provides that each register in a register segment has a local index number preferably starting from 0 so that it can be indexed by a register segment mask. The mask indicates the offset locally within register segment the functional unit if needed. There is one mask bit per register in the register segment mask and mask bit value of 1 means the corresponding register will be accessed i.e. either written to or read from. The mask index can start from either the least significant bit LSB or the most significant bit MSB although starting from the LSB is preferred.

Unlike global addressing the segment mask address mode uses the register segment ID to differentiate among register segments. There are fewer register segments than registers so addressing bits are conserved. Furthermore instead of using a conventional binary address to address each individual register the register segment mask uses one bit to index each register in a register segment. This indexing supports updating multiple registers at non consecutive addresses in addition to updating registers at consecutive locations.

By supporting registers in both consecutive and non consecutive addresses the segment mask mode provides an efficient and easy way to program and pass data to the registers. It also simplifies design because the segment mask mode addressing does not always require an address comparator and it makes driver encoding easier by focusing on registers in organized into groups segments .

Returning now to the co processor utilizes the segment mask addressing mode to efficiently access configuration registers Reg Reg N in each of the functional units . The co processor includes a command engine a plurality of pipelined functional units and an internal bus connecting the command engine and the functional units . Graphics data being processed internally by the co processor pipeline can be transferred between the functional units by a data pipeline not shown .

The command engine is the primary functional unit in the co processor and includes a bus interface for receiving instructions and configuration register data from the driver through the system bus . The command engine decodes the instructions and passes the configuration data to the different functional units for storage in the internal register segments over the internal bus . The internal bus is preferably 64 data bits in width. The configuration data is directed to specific registers in the segments based on the register segment ID and register segment mask using the segment mask address mode.

The command engine includes register addressing logic RAL and a first in first out FIFO memory for processing instructions having the segment mask address mode. Details of an exemplary segment mask instruction format are described below in connection with and details of the FIFO and RAL are described below in connection with .

Each of the functional units performs one or more specific operations on data that it receives. Preferably the operations are those involved in rendering 3 D graphics output. The operation of the functional units is controlled by the command engine . To control the functional units the command engine issues control signals and configuration data to the functional units respectively over the internal bus . Each of the functional units includes a register decoder and a register segment . The register decoder decodes individual register addresses that it receives over the internal bus . Each register segment includes a predefined number of registers Reg Reg N. The registers can be any suitable size and are preferably 64 bits.

The CPU is the primary processor in the system and executes instructions stored in the system memory . Although the CPU may be any suitable processor it is preferably a commercially available microprocessor core such as an ARM9 processor core from ARM Inc or a digital signal processor DSP .

The system memory stores data and executable instructions used by the CPU and co processor . The system memory may be implemented using any suitable storage technology and it is preferably a solid state memory device such as RAM or flash memory. The memory may also use other memory technologies such as optical or magnetic memory disk drives.

A software application requiring services provided by the co processor may be stored in the memory . The application can be a software program such as a 3 D game. The memory also stores an operating system OS software program and the driver for permitting the OS to call the services of the co processor . A commercially available operating system such as BREW SYMBIAN WINDOWS MOBILE can be used by the system . The application can also use industry standard application programming interfaces APIs such as those specified by OPENGL ES 1.x or 2.x for graphics applications or DIRECTX 9.0.

The system bus is the interface through which the co processor receives instructions. It is preferably implemented using an industry standard bus protocol such as the Advanced Microprocessor Bus Architecture AMBA AXI Bus.

The instruction includes an instruction word and a data block comprising a plurality of data units . The instruction word has bit fields defining respectively an instruction type a register count a register segment ID and a register segment mask . Each of the bit fields includes a predefined number of bits sufficient to support the numbers of instructions register segments and registers per segment for the computer system . The instruction has a predefined bit width of M bits where M is an integer. The bit width M is preferably the same as the width of the internal bus which is 64 bits.

The instruction type is essentially an opcode that tells the command engine what the instruction is. In this case the instruction type is a predefined bit code indicating that the instruction is a segment mask write instruction. The instruction type can alternatively indicate that the instruction is a segment mask read instruction or some other instruction using the segment mask addressing mode.

Only registers needing to be updated are loaded by the segment mask write instruction. The number of registers to be updated is indicated by the register count . The register count also indicates the number of data units included in the instruction .

The register segment mask indicates which registers are to be updated by the instruction. The register segment mask includes a plurality of mask bits each corresponding to an individual register in a segment. The mask LSB points to the first register of the register segment specified by the register segment ID . Alternatively the mask MBS can point to the first register of the register segment.

The data block includes one or more data units . The data units can be data configuration settings instructions constants or any other information that is usable by the co processor . The data units can be any suitable size and are preferably the same size as the registers which is preferably 64 bits.

The number of registers in a functional unit and thus the number of register segment mask bits can vary depending upon the requirements of each functional unit. The register segment mask includes enough bits to cover the register segment with the greatest number of registers.

The segment address indicates a specific register segment in one of the functional units . Within a recipient function unit logic hardware receives the segment address and enables the register decoder when there is a matching segment address.

The register address indicates a specific register in the addressed register segment. When the register decoder within the recipient functional unit is indicated by the register segment ID it decodes the register address on the internal bus causing the data unit currently present on the internal bus which is output from the FIFO to be latched into the specific register being addressed within the selected register segment.

The RAL and FIFO operate together as follows. Initially the register segment mask is loaded into the mask register and latched onto the inputs of the and gates . The counter is loaded with the register count and the data block is loaded into the FIFO . After the RAL and FIFO are initialized the RAL sequentially detects each set bit in the stored register segment mask and together the RAL and FIFO sequentially output bus addresses and corresponding data units onto the internal bus one pair during each clock period until all of the data units are loaded into the destination registers.

The priority decoder logic and the null selector cooperate together to read each of the set bits in the register segment mask stored in the mask register . Preferably the stored register segment mask is read by the priority decoder logic and null selector from the LSB to the MSB however these devices can be alternatively configured to detect set mask bits from the MSB to LSB of the register segment mask.

The priority decoder logic is combinational logic responsive to the output of the mask register . The priority decoder logic detects a leading one bit in the register segment mask and generates a register address corresponding to the position of the leading one in the register segment mask. Preferably the leading one bit is the least significant bit in the stored register segment mask that is set to one.

The null selector is combinational logic that nulls previously read set mask bits by setting them to zero after they have been input to the priority decoder logic . The null selector does this by decoding an output from the priority decoder logic to output logical zeros to and gate inputs corresponding to register segment mask bits that have already been processed by the RAL . For set mask bits that have not been processed the null selector outputs logical ones to the corresponding and gates so that the corresponding latched mask bits persist in the mask register .

A clock signal CLK is applied to the FIFO mask register and counter . One set mask bit and corresponding data unit stored in the FIFO are consumed per clock cycle and output to the register segments .

The counter decrements the stored register count by one each clock cycle. The RAL and FIFO conclude processing of the register segment mask and the data block when the stored register count reaches zero.

Although illustrates a write operation being performed by the RAL and FIFO one of ordinary skill in the art will recognize that the RAL and FIFO can be readily configured to read data from the register segments or perform address decoding for other instructions incorporating the segment mask addressing mode.

In step the functional units decode the register segment ID which is sent over the internal bus as the segment address to select the destination register segment. This step selects the register decoder within the recipient functional unit.

In step the RAL decodes the register segment mask as discussed above in connection with to generate the bus address which selects individual registers within the identified register segment. The bus address is broadcast over the internal bus and decoded by the register decoder in the recipient functional unit so that the data unit output by the FIFO can be stored in the register indicated by the register address step .

The consecutively ordered data units of the data block are transferred into registers indexed by the register segment mask from the least significant mask bit to the most significant mask bit. That is the first data unit Data Unit is stored in first register indicated by the lowest bit set in the register segments mask the second data unit Data Unit is stored in the next lowest bit set in the mask and so forth. Alternatively the data block transfer can occur from the most significant bit to the least significant bit.

In step the RAL determines whether the register count has been decremented to zero. If so the processing of the segment mask write instruction terminates. If not the method returns to step and the next register segment mask bit and data unit are processed.

In this embodiment the command engine includes a segment decoder and each functional unit includes register masking logic . Instead of a common internal bus dedicated buses connect the functional units and the command engine . The command engine decodes incoming instructions such as instruction shown in and passes configuration data to the different functional units for storage in the internal register segments over the dedicated buses .

The command engine performs the first level decoding and the functional units perform the second level decoding. In the first level of decoding the command engine decodes the register segment ID using the segment decoder . The register segment ID indicates which one of the functional units is to receive the data units contained in the data block associated with the instruction . Upon decoding the register segment ID the command engine routes the data block register count and register segment mask to the recipient functional unit containing the selected register segment. The output of the segment decoder is used to enable the dedicated bus corresponding to the identified functional unit.

In the second level of decoding the recipient functional unit interprets the register segment mask to determine which of its registers are to receive the individual data units contained in the data block . This interpretation is performed by the register masking logic . Essentially the register masking logic includes the RAL and FIFO as shown in . However the RAL used in the register masking logic is configured differently. Unlike RAL the RAL in the register masking logic does not receive the register segment ID or output the segment address. In addition the priority decoder in the register masking logic does not output a register address. Instead it outputs individual register enable signals corresponding to each register in the register segment . In other respects the register masking logic functions similarly to the functions of the RAL and FIFO as described above in connection with .

In the co processor the register segment mask greatly simplifies the second level decoding because the register masking logic can use the mask to directly select the addressed registers instead of using address comparison which is typically used in global addressing schemes. The register segment mask also permits linear addressing time for the local registers and simplifies address decoding logic.

Register segmenting reduces the burden of first level decoding on command engine because the register segment ID generally uses fewer addressing bits when compared to conventional global address schemes. In addition the command engine is only concerned with the register segment ID and does not need to consider either the data block or register segment mask . This simplifies the decoding logic of the command engine .

In an alternative architecture the co processor includes a common internal bus such as internal bus between the command engine and the functional units instead of the dedicated buses . The command engine is configured to broadcast the instruction word over the common internal bus to the functional units followed by data units . The common internal bus includes a signal bit that is set only when the instruction word is broadcast on the bus by the command engine . In bus cycles when the signal bit is set the functional units decode the register segment ID currently on the common internal bus to determine which functional unit is to receive the data units contained in the instruction . Each functional unit includes a segment address decoder for this purpose. If the signal bit is not set the functional units do not attempt to decode incoming data units presently on the common internal bus.

If the register segment in a functional unit is to receive the data units as indicated by the register segment ID the recipient functional unit latches the register segment mask internally. The recipient functional unit then uses the register masking logic to apply the register segment mask to select individual registers in the register segment to receive the incoming data units that are subsequently received from the command engine over the common internal bus.

The data block contains the five data units Data Data in order. The logic hardware takes as input the register segment mask value 0 . . . 01010011010 and the register segment ID value 0 . . . 01 . In response to these inputs the logic hardware loads Data into register of Reg Seg Data into register of Reg Seg Data into register of Reg Seg Data into register of Reg Seg and Data into register of Reg Seg .

The logic hardware is digital circuitry that includes any suitable combination and number of logic gates and or logic devices required to perform the functionality as described herein for the disclosed embodiments. The logic hardware can include the register decoder FIFO RAL or alternatively the segment decoder and register masking logic as well as other logic hardware or any suitable combination of the foregoing.

Although the foregoing detailed description illustrates the segment mask mode addressing scheme in the context of co processors and it will readily occur to one of ordinary skill in art that segment mask mode addressing can be employed in any suitable computing architecture including stand alone CPUs networked computers multi processor systems or the like. In addition the segment mask mode addressing scheme can also be implemented in software code. A computer program stored on a computer readable medium may include a first code segment for receiving an instruction comprising a memory segment identifier and a memory segment mask a second code segment for selecting a memory segment based on the memory segment identifier and a third code segment for selecting one or more of memory locations in the memory segment based on the memory segment mask. The computer program may include additional code segments for performing the other functions described herein. The program code may be any suitable programming language or code including firmware or microcode and the computer readable medium may be any suitable computer memory for storing the program code.

Other embodiments and modifications of this invention will occur readily to those of ordinary skill in the art in view of these teachings. The above summary and description is illustrative and not restrictive. The invention is to be limited only by the following claims which include all such embodiments and modifications when viewed in conjunction with the above specification and accompanying drawings. The scope of the invention should therefore not be limited to the above summary and description but should instead be determined by the appended claims along with their full scope of equivalents.

