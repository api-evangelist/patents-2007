---

title: Compositional application programming interface and literal syntax
abstract: A compositional application programming interface (API) permits non-sequential construct declaration independent of other API calls. A wrapper is applied to an imperative API to provide a compositional interface that enables arbitrary and autonomous construct declaration. Additionally, a literal syntax (e.g., code literals, graphic literals . . . ) affords a convenient declaration mechanism for such constructs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08387004&OS=08387004&RS=08387004
owner: Microsoft Corporation
number: 08387004
owner_city: Redmond
owner_country: US
publication_date: 20070209
---
Computer programs are groups of instructions and organizational constructs that govern actions to be performed by a computer or other processor based device. When a computer program is executed on computer hardware the computer will behave in a predetermined manner by following the instructions of the computer program. Accordingly the computer becomes a specialized machine that performs the tasks prescribed by the instructions. Computer programs can be generated by programmers manually and or with assistance of development tools. Alternatively programs can be created automatically by other programs.

A significant class of programs include programs that create other programs. Everyday programmers employ compilers form designers and or database application generators which are examples of this class of programs. Further games and other graphic intensive applications dynamically create miniature programs that run concurrently inside graphics co processors. In addition business analysis reporting and visualization tools often create other programs for specialized purposes as a side effect. Still further yet a web server application that embeds scripts in HTML HyperText Markup Language pages is a program that creates a program HTML page that creates another program scripts .

Generally speaking the technology for creating programs is code generation. The input information for code generation can come from any number of sources. For instance input information can be embedded statically in a code generator housed in files or databases or provided by direct user input such as mouse actions in a designer tool. The output of code generation can be designed to execute immediately after being created under control of the program that created it or alternatively saved for later execution independent of the code generator.

Whether a standard program or a program that creates programs application programming interfaces APIs can be utilized to aid development. APIs are source code tools that provide a set of services routines functions or the like employable by a computer program. These tools provide a convenient mechanism to extend program functionality and or provide fundamental program building blocks. For example code generation APIs can be employed to facilitate generation of programs that create programs.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to APIs modifications that facilitate computer programming. APIs can be generated in a manner that enables independent calls thereto. Stated differently users need not be forced to call APIs in a particular manner dictated by a creator of the API. APIs can be constructed to support increased modularity independence and composability. In addition an abbreviated syntax is supported to further aid program development.

In accordance with one aspect of the subject disclosure a wrapper is provided for imperative style APIs. The wrapper can provide a unique interface to or view for an imperative API. For example the wrapper component can provide a compositional interface or view that enables users to compose or declare programmatic constructs in an independent fashion free from restrictions imposed by an associated imperative API.

In accordance with another aspect of the disclosure a literal syntax is supported. For instance constructs can be declared or define utilizing code and or graphic literals. This provides users with an easy way to define programmatic constructs that can be translated behind the scenes to an alternate representation if necessary.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods are disclosed with respect to APIs that support independent and or arbitrarily ordered calls. Wrappers can be applied to imperative APIs that require adherence to a rigid sequential order of calls to provide a compositional interface or view. More particularly API concerns can be separated or decoupled for example such that imperative API constructs can be declared arbitrarily and or autonomously. Furthermore literal syntax such as code literals and or graphic literals can be employed to facilitate construct declaration.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a block diagram of an application programming interface system is depicted in accordance with an aspect of the claimed subject matter. System includes an existing imperative API component that requires adherence to a rigid sequential order of calls among other things. In other words although the imperative API includes a number of seemingly independent functions routines or the like in fact it is necessary to call such functionality in a certain order. For example consider construction of a nested structure. In this case a container needs to be created before anything can be added to the container. If calls are not made in the proper order such as by creating an expression to be added to a container e.g. ExpressionContainer before creation of the container then nothing will work.

Often the rigidity associated with the imperative API component is not strictly necessary but rather stems from a creator of the API. In general there are two groups of people associated with APIs those that create APIs and those that use them. The users are thus the client or customer of the creators. The creators of imperative style APIs implement them in a manner that is most easy and logical for them. For example authors of APIs such as those associated with code generation need to ensure a required structure is generated regardless of user actions. The easiest way to accomplish that is to force users into a particular sequence of calls. For instance if element B is dependent on element A then an API author will compel creation of element A prior to element B in accordance with a top down approach. This enables the context for every element to be known upon creation. However such a sequence is not logically required. Element B could be created first and element A created second and subsequently elements A and B could be linked together in accordance with a bottom up approach. In most instances however the required sequence is tailored to the convenience of the creators or authors of the APIs rather than to its users.

Wrapper component can be coupled to the imperative API component to afford a different interface or view thereto. In one embodiment the wrapper component can provide functionality to reduce the rigidity associated with direct interaction with the imperative API component . More specifically imperative functionality can be analyzed and the wrapper component can provide less constrained interaction with respect to some or all functionality provided by the imperative API . In some instances this can lead to decoupling of mixed API functionality.

In accordance with one particular aspect of the claimed subject matter the wrapper component can provide a compositional interface view thereto or alternatively convert the imperative API component to a compositional API. Compositional APIs support independent and or arbitrarily ordered calls. Accordingly clients or customers of such APIs are not forced into any sequence of calls to the API.

The benefits associated of such an approach are at least twofold. First compositional APIs allow more flexibility to be able to mix and match things at will. More specifically such APIs provide for increased modularity independence and composability. Second they support the way programmers think. Programmers tend not to build programs from the inside out. They tend to be much more organic in the way they generate code.

The degree of independence and or composability provided by the wrapper component can vary in accordance with the type and function of a particular API among other things. More particularly API concerns can be decoupled into those concerns that actually require a strict sequence of calls e.g. third party restrictions architecture . . . and those that do not. The wrapper component can facilitate arbitrary interaction for some if not all concerns that do not require a strict sequence. For example with respect to APIs relating to code generation concerns relating to declaration of constructs objects elements or the like can be separated from those pertaining to building objects wherein the wrapper component provides functionality associated with construct declaration.

Rather than interacting directly with the imperative API component users of the API can interact with the wrapper component . The wrapper component can provide additional methods services routines or the like associated with independent and or arbitrary construct declaration among other things. Users can call such mechanisms when generating constructs in this manner. The wrapper component can interact with the imperative API component to provide constructs to the API in the manner and or order it expects them. The wrapper can also allow pass through of other calls such as those related to building objects directly to the imperative API component . Accordingly the wrapper component can provide a compositional view on an imperative API component .

The constructor component provides mechanism to facilitate independent context free specification of programmatic elements constructs or the like. For example the constructor component can correspond to a library API factory or the like that enables creation of an instance of a particular programmatic element independent of any contextual information. For example there can be type factories method factories expression factories with respect to a code generation API. In accordance with one embodiment constructor component can save instances of programmatic elements as objects or functions that expect and accept a context.

The context component facilitates provisioning of context information to programmatic constructs concurrently with and or subsequent to their creation via constructor component . This enables all cross references dependencies and other contextual information to be associated with programmatic constructs or more particularly instances thereof. Similar to the constructor component such functionality can be embodied in one or more libraries APIs or the like. API users can utilize such functionality to specify context for a plurality of initially declared constructs.

By way of example consider the simple expression x y. In essence this is an add expression that contains to two parameters expressions that in this instance correspond to variables x and y. An imperative API can force a user to specify parameters sequentially for example from the top down as follows 

A compositional approach can allow such expressions to be generated without a required ordering. Accordingly the expressions can each be declared separately without initial specification of context information associated relations or cross references between expressions. As depicted in each expression container a b c d and e can be declared separately. For illustrative purposes each container includes a dangling wire that can be connected to another container to provide context. As a result the containers representative of programmatic constructs can be generated in any order specified by a user. For example a user can construct the same expression x y in accordance with a bottom up approach. In particular first the variable expressions d and e are created followed by the parameter expressions b and c and finally the larger add expression container a. This could be denoted programmatically as follows 

Turning attention to a system that facilitates program specification is illustrated in accordance with an aspect of the claimed subject matter. As previously described with respect to the constructor component can provide one or more mechanisms to facilitate generation of instances of programmatic constructs. For example one or more libraries APIs factories or the like can provide callable functionality related to such generation.

System provides an extension to the manner in which constructs like expressions can be declared. More specifically code literal component is operable to identify and provision code literals to the constructor component . Code literals pertain to literal expressions of code desired to be inserted. Once again one or more libraries APIs factories or the like can be provided to support such functionality. Among other things this is extremely useful with respect code generation applications as particular segments of code to be produced can be explicitly specified. Recall the previous x y example specified as follows 

The code literal component and construct component can also interact with type inference component to allow specification to be even simpler. The type inference component is a mechanism that can infer or otherwise determine types as a function of context. Accordingly this can allow code literals to be expressed without associated types such as Dim Expression Based on the code literal specification of x y the type inference component can infer that the type of Expression is ExpressionFactory. This information can then be provided to one or more of code literal component and constructor component to enable the appropriate code to be generated.

It is also to be noted that code literal component supports code literals with unquoted or de referenced values. Unquoted portions of a code literal can be retrieved from the ambient environment. Consider the following code literal x d . Here the d is unquoted. Accordingly its value will be retrieved by code literal component from the environment. If d is assigned the value y for example denoted as d y then the expression will be equivalent to the previous expression namely x y . Similarly this expression is equivalent to the following longer version perhaps supported by the constructor component .

Referring to a system is provided to facilitate programmatic specification in accordance with an aspect of the claimed subject matter. Similar to system of the system includes the constructor component and type inference component as previously described. In addition the system includes a graphical code literal component communicatively coupled with the constructor component and the inference component . The graphical code literal component provides support for another embodiment of code literals or a specific instance thereof namely graphical literals. Graphical literals enable variables or other programmatic constructs to be assigned a value as a function of a graphical depiction. The graphical code literal component can identify a graphical literal and produce or otherwise identify code associated with the literal. For example the component can translate an instance of a graphical literal directly to code supported by the constructor component and provided it thereto. Still further yet the type inference component can be employed to infer types associated with assigned constructs among other things to further simplify what a user needs to specify.

In accordance with one embodiment graphical literals can be provided to a user for use in code specification. Each provided literal can include or be linked to code needed for its generation. Where multiple graphical literals are specified the graphical interpreter component can facilitate generating the connecting code. Further yet graphical literals can also support both quoting and unquoting or the like similar to the functionality with respect to code literals. This can facilitate reuse of graphical literals among other things.

Referring to a number of graphical literal examples are provided to aid understanding. More specifically each figure provides an example of variable assignment utilizing graphical literals. Note that variable types are not specified as they can be inferred from each graphical literal and or other context information.

Multiple graphical literals can be combined to specify a variable. illustrates use of multiple literals wherein the graphical literals of and are combined and assigned to variable Y. depicts an equivalent assignment with respect to variable Z. However here the variable X is inside the graphical window in an unquoted form. This indicates that the value of X should be specified within the window. Since the value of X is a button the values of variables Y and Z are the same.

It is to be appreciated that other mechanisms can be employed to facilitated code specification including the foregoing aspects among other things. For example intelligent assistance can be afforded to provide code suggestions to users or auto fill portions of code. Furthermore syntax coloring can be utilized to aid program specification and comprehension. In general programming utilizing APIs and literal syntax associated therewith can be accomplished in a manner similar an integrated development environment IDE including like mechanisms.

Turning to a programming system is illustrated in accordance with yet another aspect of the claimed subject matter. Similar to system system includes the constructor component code literal component and type inference component as previously shown and described. In addition the system includes a serialization component .

The serialization component is operable to serialize and or deserialize literals among other programmatic constructs to and from a data store . In this manner literals can be specified with respect to references to databases or storage mechanisms. More particularly initially generated literals can be serialized to the data store . Subsequently code can employ these literals via reference thereto. For example a calculator program could have code that implements calculator buttons persisted in a database. When the calculator initializes it can read code in from a database as code literals interpret and bind it to user interface buttons such that when the buttons are pressed or otherwise selected the code is executed.

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art. It is also to be noted that although APIs can related to code generation applications including compilers other compilers can be employed to perform functionality associated with the above described components. For example a compiler can facilitate transformation of code specified in a compositional manner to an imperative manner associated with a particular API. Additionally or alternatively a compiler can be employed to aid translation of literal syntax to more conventional code. Further yet a compiler can determine a value associated with an unquoted element from an ambient environment and replace the unquoted element with the value. As will be appreciated from a more detailed example provided infra compiler can also utilized and benefit from the same functionality it helps implement. For example the compiler can take advantage of a compositional API to weave code generation code together in sophisticated ways.

Furthermore as will be appreciated various portions of the disclosed systems and methods may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation such mechanisms can be employed to facilitate optimal decoupling of API functionality and or type inference related to literals.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a method of providing compositional functionality with respect to an imperative API is depicted in accordance with an aspect of this disclosure. In particular an imperative API can be identified at reference numeral . For example such an API can provide functionality with respect to code generation. At reference numeral a wrapper can be applied to the imperative API. The wrapper can provide a compositional interface or view to the imperative API. More specifically code can be provided with respect to at least a portion of functionality provided by the imperative API to enable calls to be made independent of other calls thereby increasing code modularity and composability as well as independence.

The following is a detailed example relating to portions of the claimed subject matter to further facilitate clarity and understanding. What follows is purely exemplary and is not meant to limit the claimed subject matter. In particular the example illustrates application of a few of the aforementioned aspects of the disclosure with respect to a conventional imperative API for code generation.

Referring to a graphical illustration of a code generation API is provided. As shown the code generation includes three distinct groups of calls and . Group supplies calls for creating code in methods types modules and an assembly. Group provides calls for saving an assembly to a file for later execution and group affords calls for executing methods dynamically. As shown the API is imperative in that it requires a rigid sequence of calls. In other words an author of a code generator must call the API in a top down manner that creates an assembly before calling an API that creates modules before calling an API that creates types and so on. However since any bottom level statement or expression can refer to any other type or member whether nested or not the sequence required by the API is not logically necessary. In fact it is tailored to the convenience of the author of the API rather than to its user who authors a code generator.

The author of the code generation API must ensure that whatever a user does the generated assembly has the required nested structure. The easiest way to do this is to force the user to create things in sequence. However the final assembly is both a network of cross references and a nested structure of containers. The user of the API the author of a code generator must specify both the network of references and the nested structure of containers. Specifying the network of cross references or declarations does not logically require sequential calls but is done most naturally in a bottom up fashion.

The following code snippet provides an example of usage of API to generate another program that prints hello world 

What follows is a functionally identical rewrite of the code above in a more functional style avoiding the With statement and introducing temporary variables at every level of the sequence. This makes the required sequence crystal clear at the expense of reflecting the implied nesting structure 

The above code is now discussed line by line for purposes of clarity. First a name is created for the assembly about to be created 

Although there are few options concerns can be separated into concerns of declaring things which does not logically require a sequence and building things which does. For the first part of the job a factory pattern can be employed. Generally factories are objects that hold declaration information and wait for one more required input before constructing a builder. The builders actually generate code and need to be called in the required sequence. The factories are new things the builders e.g. module type method expression . . . are the existing things associated with the API. Consider the following where new types and constructors are italicized 

Notice above that while emphasizing decoupling improvement was added to the conventional API . Instead of writing intermediate language code an ExpressionFactory and ExpressionBuilder were created to express generated code. Instead of generating intermediate language code that calls Console.WriteLine which is 

This can be improved further if a compiler or like component can identify a desired expression. This is easy since that is exactly what it does with code users write. Still further improvement can be made if the compiler or like component can be directed to look at code desired to be generated. This can be accomplished via quasiquote unquote type technique which transforms specially quoted code into calls of the factory constructors. For example the following can be written to mean exactly the same thing as above 

This is the highest abstraction that should be employed with quote syntax since the subject language used in this example e.g. Visual Basic has no intrinsic syntax for modules and assemblies. Accordingly it makes little sense to try to define a quoted syntax for them. However given a different language this is possible and within the scope of the subject innovation.

One sub feature remains for quoted code namely unquoting or splicing. Suppose one did not want to commit to the name of the method rather allowing a user to input it when running the code generator. In this scenario the code could be written as follows 

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers . For example programmers on client s can request and receive APIs or the like from server s or vice versa. Additionally or alternatively generated code can be distributed across both client s and server s .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

