---

title: Storing log data efficiently while supporting querying to assist in computer network security
abstract: A logging system includes an event receiver and a storage manager. The receiver receives log data, processes it, and outputs a data “chunk.” The manager receives data chunks and stores them so that they can be queried. The receiver includes buffers that store events and a metadata structure that stores metadata about the contents of the buffers. The metadata includes a unique identifier associated with the receiver, the number of events in the buffers, and, for each “field of interest,” a minimum value and a maximum value that reflect the range of values of that field over all of the events in the buffers. A chunk includes the metadata structure and a compressed version of the contents of the buffers. The metadata structure acts as a search index when querying event data. The logging system can be used in conjunction with a security information/event management (SIEM) system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09031916&OS=09031916&RS=09031916
owner: Hewlett-Packard Development Company, L.P.
number: 09031916
owner_city: Houston
owner_country: US
publication_date: 20071228
---
This application claims the benefit of U.S. Provisional Application No. 60 882 289 filed Dec. 28 2006 which is hereby incorporated by reference herein in its entirety.

This invention pertains in general to security information event management SIM or SIEM and in particular to storing security information events efficiently while supporting querying.

The field of security information event management SIM or SIEM is generally concerned with 1 collecting data from networks and networked devices that reflects network activity and or operation of the devices and 2 analyzing the data to enhance security. For example the data can be analyzed to identify an attack on the network or a networked device and determine which user or machine is responsible. If the attack is ongoing a countermeasure can be performed to thwart the attack or mitigate the damage caused by the attack. The data that is collected usually originates in a message such as an event alert or alarm or an entry in a log file which is generated by a networked device. Exemplary networked devices include firewalls intrusion detection systems and servers.

Each message or log file entry event is stored for future use. Stored events can be organized in a variety of ways. Each organizational method has its own advantages and disadvantages when it comes to writing event data searching event data and deleting event data.

Consider the following scenario Each event includes an attribute called event receipt time. Since the value of the event receipt time attribute is frequently used for searching store events based on their event receipt times. For example create one file for each minute of the day. In order to store an event determine that event s event receipt time. Append the event to the file that corresponds to that minute of event receipt time.

When subsequent events arrive their event receipt times will always increase monotonically. This means that writing the subsequent event data will require only append operations. No seeking of the storage medium is necessary. This makes for good efficiency in writing the event data. In order to search the event data based on event receipt times once the first event has been identified the subsequent events are available by reading the storage medium in order. Again no seeking is necessary. This makes for good efficiency in searching the event data based on event receipt time. In order to delete the oldest event data the oldest files are deleted. If the oldest file is always deleted first then the storage medium will not become fragmented. This makes for good efficiency in deleting the event data.

The problem with this approach is that searching the event data based on any attribute other than the event receipt time is very time consuming. For example assume that each event also includes an attribute that indicates the device or application that generated the event event source . In order to search the event data for events that indicate a particular event source i.e. events that include a particular value for the event source attribute the entire storage medium will have to be reviewed. This is very inefficient.

What is needed is a way to store security information events efficiently while supporting querying for different event attributes e.g. by supporting multi dimensional indexing .

A logging system stores security information events efficiently while supporting querying for different event attributes. The logging system can be used in conjunction with a security information event management SIEM system. Log data which can be generated by various sources including devices and applications can be in any format. Log data is comprised of one or more data instances called events. An event can be for example an entry in a log file an entry in a syslog server an alert an alarm a network packet an email or a notification page. In general an event is generated once and does not change afterwards.

In one embodiment the logging system includes an event receiver a storage manager and a communication mechanism. The event receiver receives log data processes the log data and outputs a data chunk. The event receiver includes a control system a set of buffers and a metadata structure. The control system controls operation of the event receiver. The set of buffers stores one or more events. The metadata structure stores metadata about the contents of the set of buffers. In one embodiment the metadata includes a unique identifier associated with the event receiver the number of events in the set of buffers and for each of one or more fields of interest a minimum value and a maximum value that reflect the range of values of that field over all of the events in the set of buffers. The metadata structure acts as a search index when querying event data.

The storage manager receives data chunks and stores them so that they can be queried. The storage manager includes a control system a datafiles table a chunks table and one or more datafiles. The control system controls operation of the storage manager. The datafiles table stores information about the one or more datafiles. In one embodiment this information includes for each datafile a unique identifier associated with the datafile and the location of the datafile. The chunks table stores information about the one or more chunks that are stored in the storage manager specifically stored in the one or more datafiles . In one embodiment this information includes for each chunk the metadata stored in the chunk and the location of the chunk. A datafile stores multiple chunks. The communication mechanism communicatively couples the event receiver and the storage manager.

The event receiver and the storage manager jointly perform a method for storing log data. Before the method begins the set of buffers and the metadata structure are initialized. The event receiver receives log data. The event receiver control system separates the log data into one or more events and determines when each event was received by the event receiver. The control system stores in the set of buffers the events and for each event a time date stamp that reflects when the event was received. The control system also updates the metadata structure. At some point in time the control system generates a data chunk based on the metadata structure and the contents of the set of buffers. In one embodiment a chunk includes the metadata structure and a compressed version of the contents of the set of buffers. The set of buffers and the metadata structure are re initialized thereby flushing the set of buffers. The control system sends the chunk to the storage manager. The storage manager receives the chunk stores the chunk in a datafile and updates the chunks table.

The storage manager performs a method for reclaiming storage. The oldest datafile associated with a particular retention policy is identified. Information regarding all of the chunks contained in the identified datafile is removed from the chunks table. The entry in the datafiles tables that represents the identified datafile is deleted. A new entry is created in the datafiles table. The newly reclaimed datafile is added to the list of available pre allocated datafiles and is ready to receive new chunks.

After a chunk has been stored in a datafile the events within the chunk can be queried. A query is represented as an expression that can be evaluated against an event. The expression includes one or more search terms. In order to perform a query data chunks are identified that could contain an event that satisfies the query. Specifically search terms within the query are identified that contain information that was contained in the metadata structure. The metadata search terms are used to search the chunks table. In this way a search can be constrained based on particular values for information that was stored in the metadata. The identified chunks are disassembled into their constituent events. Events that satisfy the query are identified.

The figures depict an embodiment for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein.

Described herein is a computer based system for collecting data from disparate devices across a computer network normalizing the data to a common schema and consolidating the normalized data. The data events can then be monitored analyzed and used for investigation and remediation in a centralized view. Events can be cross correlated with rules to create meta events. Correlation includes for example discovering the relationships between events inferring the significance of those relationships e.g. by generating meta events prioritizing the events and meta events and providing a framework for taking action. The system one embodiment of which is manifest as computer software enables aggregation correlation detection and investigative tracking of suspicious network activities. The system also supports response management ad hoc query resolution reporting and replay for forensic analysis and graphical visualization of network threats and activity.

Although the present system will be discussed with reference to various illustrated examples these examples should not be read to limit the broader spirit and scope of the present invention. For example the examples presented herein describe distributed agents managers and consoles which are but one embodiment of the present invention. The general concepts and reach of the present invention are much broader and may extend to any computer based or network based security system. Also examples of the messages that may be passed to and from the components of the system and the data schemas that may be used by components of the system are given in an attempt to further describe the present invention but are not meant to be all inclusive examples and should not be regarded as such.

Some portions of the detailed description that follows are presented in terms of algorithms and symbolic representations of operations on data within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the computer science arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise it will be appreciated that throughout the description of the present invention use of terms such as processing computing calculating determining displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

As indicated above one embodiment of the present invention is instantiated in computer software that is computer readable instructions which when executed by one or more computer processors systems instruct the processors systems to perform the designated actions. Such computer software may be resident in one or more computer readable media such as hard drives CD ROMs DVD ROMs read only memory read write memory and so on. Such software may be distributed on one or more of these media or may be made available for download across one or more computer networks e.g. the Internet . Regardless of the format the computer programming rendering and processing techniques discussed herein are simply examples of the types of programming rendering and processing techniques that may be used to implement aspects of the present invention. These examples should in no way limit the present invention which is best understood with reference to the claims that follow this description.

Types of data sources include security detection and proxy systems access and policy controls core service logs and log consolidators network hardware encryption devices and physical security. Exemplary security detection and proxy systems include IDSs IPSs multipurpose security appliances vulnerability assessment and management anti virus honeypots threat response technology and network monitoring. Exemplary access and policy control systems include access and identity management virtual private networks VPNs caching engines firewalls and security policy management. Exemplary core service logs and log consolidators include operating system logs database audit logs application logs log consolidators web server logs and management consoles. Exemplary network hardware includes routers and switches. Exemplary encryption devices include data security and integrity. Exemplary physical security systems include card key readers biometrics burglar alarms and fire alarms.

In the illustrated embodiment the SIEM system includes one or more agents one or more managers one or more databases one or more online archives one or more user interfaces and one or more logging systems . In some embodiments these modules are combined in a single platform or distributed in two three or more platforms such as in . The use of this multi tier architecture supports scalability as a computer network or system grows. The SIEM system is further described in U.S. application Ser. No. 10 308 415 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety.

An agent provides an interface to a data source . Specifically the agent collects data raw events from a data source processes the data and sends the processed data events to a manager . The agent can operate anywhere such as at a separate device communicating via a protocol such as simple network management protocol SNMP traps at a consolidation point within the network or at the data source . For example if the data source is a software application the agent can be co hosted on the device that hosts the data source. In one embodiment the agent is the Connector product from ArcSight Inc. of Cupertino Calif.

Processing can include normalization aggregation and filtering. For example individual raw events are parsed and normalized for use by the manager . Normalization can involve normalizing values such as severity priority and time zone into a common format and or normalizing a data structure into a common schema. Events can be categorized using a common human readable format. This format makes it easier for users to understand the events and makes it easier to analyze the events using filters rules reports and data monitors. In one embodiment the common format is the Common Event Format CEF log management standard from ArcSight Inc. Normalization is further described in U.S. application Ser. No. 10 308 941 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety.

Aggregation and filtering reduce the volume of events sent to the manager which saves network bandwidth and storage space increases the manager s efficiency and accuracy and reduces event processing time. Aggregation is further described in U.S. application Ser. No. 10 308 584 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety. The agent sends events to the manager in batches based on the expiration of a time period or based on a threshold number of events being reached. Batching events for transmission to the manager is further described in U.S. Pat. No. 7 219 239 issued May 15 2007 which is hereby incorporated by reference herein in its entirety.

The agent can also send commands to the data source and or execute commands on the local host such as instructing a scanner to run a scan. These actions can be executed manually or through automated actions from rules and data monitors. Command support is further described in U.S. application Ser. No. 10 308 417 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety. The agent can also add information to the data that it has collected such as by looking up an Internet Protocol IP address and or hostname in order to resolve IP hostname lookup at the manager .

The agent is configured via an associated configuration file not shown . The agent can include one or more software modules including a normalizing component a time correction component an aggregation component a batching component a resolver component a transport component and or additional components. These components can be activated and or deactivated through appropriate commands in the configuration file. During configuration the agent is registered to a manager and configured with characteristics based on its data source and desired behavior. The agent is further configurable through both manual and automated processes. For example the manager can send to the agent a command or configuration update. Agent components are further described in U.S. application Ser. No. 10 308 548 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety.

A manager provides analysis capabilities case management workflow capabilities and services capabilities. Communications between the manager and an agent can be bi directional e.g. to enable the manager to transmit a command to the platform hosting the agent and encrypted. In some installations the manager can act as a concentrator for multiple agents and can forward information to other managers e.g. managers deployed at a corporate headquarters . To perform its tasks the manager uses a variety of filters rules reports data monitors dashboards and network models. In one embodiment the manager is a Java based server such as the Enterprise Security Manager ESM product from ArcSight Inc.

Analysis can include detection correlation and escalation. For example the manager cross correlates the events received from the agents using a rules engine not shown which evaluates each event with network model and vulnerability information to develop real time threat summaries. Correlation is further described in U.S. application Ser. No. 10 308 767 filed Dec. 2 2002 which is hereby incorporated by reference herein in its entirety. Regarding case management the manager can maintain reports regarding the status of security incidents and their resolution. Incident reports are further described in U.S. application Ser. No. 10 713 471 filed Nov. 14 2003 which is hereby incorporated by reference herein in its entirety. Services can include administration notification and reporting. The manager can also provide access to a knowledge base.

As events are received by the manager they are stored in a database . Storing the events enables them to be used later for analysis and reference. In one embodiment the database is a relational database management system such as a database from Oracle Corporation of Redwood Shores Calif.

In one embodiment the database stores data in partitions which are chronological slices of the database. For example one new partition is created each day to store that day s events. A partition can be compressed and stored in an online archive for later retrieval. Partition management is further described in U.S. application Ser. No. 10 839 563 filed May 4 2004 which is hereby incorporated by reference herein in its entirety. In one embodiment partition management is provided by the SmartStorage archiving and retrieval component of the Security Lifecycle Information Management SLIM product from ArcSight Inc.

A user interacts with the manager via a user interface . The user interface enables the user to navigate the features and functions of the manager . A single manager can support multiple user interface instances. The features and functions that are available to the user available can depend on the user s role and permissions and or the manager s configuration. In one embodiment access control lists enable multiple security professionals to use the same manager and database but each professional has his own views correlation rules alerts reports and knowledge bases appropriate to his responsibilities. Communication between the manager and the user interface is bi directional and can be encrypted.

In one embodiment there are two types of user interfaces a workstation based interface and a web browser based interface. The workstation interface is a standalone software application that is intended for use by full time security staff in a Security Operations Center SOC or similar security monitoring environment. The workstation interface includes an authoring tool for creating and modifying filters rules reports pattern discovery dashboards and data monitors. The workstation interface also enables a user to administer users database partitions and workflow e.g. incident investigation and reporting . For example the workstation interface enables a user to perform routine monitoring build complex correlation and long sequence rules and perform routine administrative functions. In one embodiment the workstation interface is the ESM Console product from ArcSight Inc.

The web interface is an independent and remotely installable web server that provides a secure interface with the manager for web browser clients. The web interface is intended for use as a streamlined interface for customers of Managed Service Security Providers MSSPs SOC operators and users who need to access the manager from outside the protected network. Because the web server can be installed at a location remote from the manager the web server can operate outside the firewall that protects the manager . The web interface provides event monitoring and drill down capabilities. In one embodiment as a security feature the web interface does not enable authoring or administrative functions. In one embodiment the web interface is the ArcSight Web product from ArcSight Inc.

In one embodiment a logging system is an event data storage appliance that is optimized for extremely high event throughput. The logging system stores security events sometimes referred to as log data . In one embodiment the security events are stored in compressed form. However the logging system can retrieve these events on demand unmodified for forensics quality data. Multiple logging systems can work together to scale up to support high sustained input rates when storing events. Event queries can be distributed across a peer network of logging systems . A user can configure the logging system via a user interface not shown . In one embodiment the logging system is the Logger product from ArcSight Inc.

The logging system can receive both processed events e.g. events adhering to the Common Event Format and raw events. In one embodiment raw events are received directly from data sources such as syslog messages and log files and processed events are received from agents or managers . The logging system can also send both raw events and processed events. In one embodiment raw events are sent as syslog messages to any device not shown and processed events are sent to the manager . The logging system will be further described below.

Through the above described architecture the SIEM system can support a centralized or decentralized environment. This is useful because an organization may want to implement a single instance of the SIEM system and use an access control list to partition users. Alternatively the organization may choose to deploy separate SIEM systems for each of a number of groups and consolidate the results at a master level. Such a deployment can also achieve a follow the sun arrangement where geographically dispersed peer groups collaborate with each other by passing primary oversight responsibility to the group currently working standard business hours. SIEM systems can also be deployed in a corporate hierarchy where business divisions work separately and support a rollup to a centralized management function.

Described herein are systems and methods for storing log data efficiently while supporting querying. Log data as used herein can be generated by various sources including both devices and applications. These sources include for example the data sources described above as well as network systems computers operating systems anti virus systems databases physical infrastructure identity management systems directory services system health information systems web traffic legacy systems proprietary systems mainframes mainframe applications security systems physical devices and SIEM sources such as agents and managers .

A system can obtain log data in many ways. For example log data can be received e.g. according to the syslog protocol . Alternatively log data can be accessed e.g. by reading a file that is stored locally or remotely . Other methods include for example Open Database Connectivity ODBC Simple Network Management Protocol SNMP traps NetFlow and proprietary Application Programming Interfaces APIs . Log data can also be input by a user e.g. using a command line interface CLI .

Log data can be in any format. One such format is for example Common Event Format described above . Other formats are for example specific to the data sources that generated the log data.

Log data is comprised of one or more data instances called events. An event can be for example an entry in a log file an entry in a syslog server an alert an alarm a network packet an email or a notification page. In general an event is generated once and does not change afterwards.

In one embodiment an event includes implicit meta data and a message. Implicit meta data can include information about for example the device or application that generated the event event source and when the event was received from the event source receipt time . In one embodiment the receipt time is a date time stamp and the event source is a network endpoint identifier e.g. an IP address or Media Access Control MAC address and or a description of the source possibly including information about the product s vendor and version.

The message represents what was received from the event source and can be in any form binary data alphanumeric data etc. . In one embodiment the message is free form text that describes a noteworthy scenario or change. In another embodiment the message also includes explicit meta data. Explicit meta data is obtained for example by parsing the message. When an event source generates an event the event usually includes information that indicates when the event occurred event occurrence time . The event occurrence time which is usually a date time stamp is an example of explicit meta data and is frequently used for analysis. Different event sources often produce non uniform explicit meta data e.g. priority or criticality of event devices applications users affected by event and which user triggered event .

In one embodiment if an event does not include an occurrence time an implicit timestamp generated by an event receiver when it received the event described below is treated as the original occurrence timestamp. As an event is processed and potentially forwarded through various systems each system usually has an implicit notation of event receipt time.

In one embodiment an event represents a data structure that includes one or more fields where each field can contain a value. The size of this data structure usually falls within the range of 100 bytes to 10 kilobytes.

The storage device is any device capable of holding data like a hard drive compact disk read only memory CD ROM DVD or a solid state memory device. The memory holds instructions and data used by the processor . The pointing device may be a mouse track ball or other type of pointing device and is used in combination with the keyboard to input data into the computer . The graphics adapter displays images and other information on the display . The network adapter couples the computer to a local or wide area network.

As is known in the art a computer can have different and or other components than those shown in . In addition the computer can lack certain illustrated components. For example a computer acting as a logging system can lack a keyboard pointing device graphics adapter and or display . Moreover the storage device can be local and or remote from the computer such as embodied within a storage area network SAN .

The event receiver receives log data processes the log data and outputs a data chunk . The event receiver includes a control system a set of one or more buffers and a metadata structure . The control system is communicatively coupled to the set of one or more buffers and the metadata structure .

The control system controls operation of the event receiver and is further described below with reference to .

The set of one or more buffers stores one or more events. The set of buffers also stores for each event a time date stamp that reflects when the event was received by the event receiver . For example the set of buffers appends to each event this time date stamp value thereby adding a ReceiptTime field .

The metadata structure stores metadata about the contents of the set of buffers . In one embodiment this metadata includes the unique identifier associated with the event receiver that received the events the number of events in the set of buffers and for each of one or more fields of interest a minimum value and a maximum value that reflect the range of values of that field over all of the events in the set of buffers. The metadata structure acts as a search index when querying event data described below .

For example assume that an event includes a field called OccurrenceTime whose value reflects the time that the event occurred. If OccurrenceTime were a field of interest the metadata structure would include a minimum value for OccurrenceTime and a maximum value for OccurrenceTime. The minimum value of OccurrenceTime would be the OccurrenceTime for the event in the set of buffers that occurred first. The maximum value of OccurrenceTime would be the OccurrenceTime for the event in the set of buffers that occurred last.

In one embodiment ReceiptTime is also a field of interest. In this embodiment therefore the metadata structure also stores a minimum value and a maximum value that reflect the range of values of receipt times over all of the events in the set of buffers. The minimum value of ReceiptTime would be the ReceiptTime for the event in the set of buffers that was received first. The maximum value of ReceiptTime would be the ReceiptTime for the event in the set of buffers that was received last. In one embodiment only the minimum value of ReceiptTime is stored. In this embodiment the maximum value of ReceiptTime is not stored this decreases storage requirements. If a buffer is flushed often which happens when a chunk is generated described below the maximum value of ReceiptTime will be close to the minimum value of ReceiptTime e.g. one second later .

In one embodiment a field of interest is not an event field per se. Instead it is a derived value that is determined based on the values stored in one or more fields of an event.

The storage manager receives data chunks and stores them so that they can be queried. The storage manager includes a control system a datafiles table a chunks table and one or more datafiles . The control system is communicatively coupled to the datafiles table the chunks table and the one or more datafiles .

The control system controls operation of the storage manager and is further described below with reference to .

The datafiles table stores information about the one or more datafiles . In one embodiment each entry in the datafiles table represents one datafile for which space has been allocated and the entry includes a unique identifier associated with the datafile and the location of the datafile e.g. a file system a path therein and a file name . A datafile listed in the datafiles table may or may not contain data e.g. chunks . The datafiles table is stored for example in a database not shown . In one embodiment datafiles are allocated before they are needed. In this embodiment a list of these pre allocated datafiles called a free list is maintained.

The chunks table stores information about the one or more chunks that are stored in the storage manager specifically stored in the one or more datafiles . In one embodiment this information includes for each chunk the metadata stored in the chunk described below and the location of the chunk e.g. the unique identifier associated with the datafile that stores the chunk and the location within the datafile where the chunk is stored e.g. as an offset . The chunks table is stored for example in a database not shown .

A datafile stores multiple chunks . In one embodiment all datafiles are the same size e.g. 1 gigabyte and are organized in time order. The datafile is stored for example on a raw disk or in a data storage system such as a file system not shown . If the datafile is stored on a raw disk data can be accessed faster since additional layers of indirection are not required. Also security can be increased.

The communication mechanism communicatively couples the event receiver and the storage manager . In one embodiment the communication mechanism includes a partially public or wholly public network such as the Internet. In other embodiments the communication mechanism includes a private network or one or more distinct or logical private networks e.g. virtual private networks or local area networks . Communication links to and from the communication mechanism can be wired or wireless e.g. terrestrial or satellite based transceivers . In one embodiment the communication mechanism is a packet switched network such as an IP based wide or metropolitan area network that uses the Ethernet protocol.

In another embodiment the communication mechanism is local to a single computer system e.g. if a portion of the event receiver and a portion of the storage manager are executing on the same device . In this embodiment the communication mechanism is implemented for example through a local software only loopback device. For example the data is copied to various locations in memory and communication occurs via an API.

In yet another embodiment the communication mechanism is local to a single process e.g. if a portion of the event receiver and a portion of the storage manager are executing on the same device and in the same process . In this embodiment the communication mechanism is implemented for example through shared memory and or pointers thereto.

In one embodiment before the method begins the set of buffers and the metadata structure are initialized. For example the control system stores in the metadata structure the unique identifier associated with the event receiver .

The method begins when the event receiver receives log data . In one embodiment the log data is received in the form of a stream.

The control system separates the log data into one or more events and determines when each event was received by the event receiver .

The control system stores in the buffer the events and for each event a time date stamp that reflects when the event was received. The control system also updates the metadata structure . For example the number of events in the buffer will have increased. The minimum and maximum values for the field s of interest may also need to be updated. In one embodiment data write operations and metadata write operations are synchronized in order to avoid possible inconsistency if a system crash occurs. For example a transactional database system is used so that if an event is stored in the buffer the metadata structure is guaranteed to be updated accordingly even if the underlying system crashes in between the two steps.

At some point in time see below the control system generates a data chunk based on the metadata structure and the contents of the buffer . In one embodiment a chunk includes the metadata structure and a compressed version of the contents of the buffer . The compressed version can be generated using any data compression algorithm e.g. a lossless compression algorithm such as that used by GNU zip gzip . Compressing the buffer contents makes this approach a cost effective choice for long term storage of data. In one embodiment different chunks can have different sizes and a maximum size can be specified.

In one embodiment the chunk also includes a magic number and a version identifier. The magic number sometimes called a file signature is a short sequence of bytes that identifies the data type of the chunk. For example the magic number is reasonably unique i.e. unique with a high probability across other data and file formats including other chunks. Thus when a chunk is read it is easy to determine whether the chunk is in the expected format. If the chunk s actual magic number differs from the expected magic number then the chunk is wrong e.g. corrupted . If the actual magic number matches the expected magic number then data that occurs later in the chunk might still be wrong. However the matching magic number excludes this possibility for the majority of common situations. The version identifier enables the accommodation of data and file formats that have changed. For example when a chunk is read the version identifier can be used in conjunction with the magic number to indicate additional information about the data or file format.

In another embodiment also not shown the control system also generates a message digest of the contents of the buffer . For example the control system applies a cryptographic hash function to a string that represents the contents of the buffer . Any cryptographic hash function can be used such as Message Digest algorithm 5 MD5 or an algorithm in the Secure Hash Algorithm family e.g. SHA 256 . In one embodiment the digest value is stored in the metadata structure before the chunk is created. This value can later be used to determine whether the buffer data that is stored in the chunk in compressed form has been changed or tampered with. This helps guarantee the integrity of stored events by making it noticeable when events have been changed.

The buffer and the metadata structure are then re initialized thereby flushing the buffer . In one embodiment the set of buffers includes multiple buffers. This embodiment enables one buffer to be used to store incoming events while another buffer is full or is being flushed.

In one embodiment step is performed when the buffer is full. In another embodiment step is performed when a particular period of time a timeout window has elapsed during which no events were received by the buffer .

The storage manager receives the chunk . The control system stores the chunk in a datafile see below . In one embodiment the chunk is encrypted before it is stored for security purposes. The control system also updates the chunks table . For example the control system adds to the table information regarding the chunk that it just stored in the datafile .

The control system writes chunks in appending order inside each datafile . This is sometimes referred to as write once journaled. In one embodiment the control system maintains a write pointer that indicates a location within a datafile where a chunk can be written. After a chunk has been written to a datafile the write pointer is modified to indicate a location within the same datafile specifically at the end of the chunk that was just written . If writing a chunk fills a datafile the write pointer is modified to indicate a location within a different datafile specifically at the beginning that can be used to store chunks. In one embodiment not shown chunk writes are deferred by first caching chunks in memory. Multiple continuous chunks are then combined into one write operation in order to optimize full stripe writes on RAID 5 disk storage systems. By using large sequential input operations such as writes the hardware is driven at a high speed throughput and concurrency.

If a pre allocated datafile exists e.g. as listed in the free list described above the control system uses the datafile and removes that datafile s unique identifier from the free list since that datafile is no longer available . If no pre allocated datafile exists the control system creates a new one by locating available space and updating the datafiles table . For example the control system adds to the table information regarding the new datafile that it just created. In one embodiment the unique identifier assigned to the new datafile is equal to the sum of 1 and the unique identifier associated with the datafile that was most recently allocated.

The method has many desirable characteristics. For example it is highly scalable since it can support receiving a very high number of events per second EPS . Multiple event receivers can be used and the writing of event data is fast because it involves only append operations not seek operations. The method also features high availability since it provides continuous access to data. Deleting old events does not fragment the storage medium which means that no defragmentation process is required and therefore no maintenance window is required either. Implicit downtime for cleanup tasks is not required. Also since disk write operations are efficient they avoid overhead in order to leave room for handling queries.

At some point in time discussed below storage being used by one or more datafiles is reclaimed for future use. is a flowchart illustrating a method for reclaiming storage according to one embodiment. In one embodiment the method of is performed by the storage manager e.g. its control system .

The oldest datafile associated with a particular retention policy described below is identified . Since datafiles have unique identifiers based on monotonically increasing numbers it is easy to query the datafiles table to find the oldest datafile i.e. the datafile that has the lowest unique identifier associated with the retention policy.

Information regarding all of the chunks contained in the identified datafile is removed from the chunks table .

A new entry is created in the datafiles table with a a new unique identifier that is one higher than the highest used datafile identifier and b a path attribute referring to the physical location of the previously oldest datafile i.e. the datafile that was identified in step .

The newly reclaimed datafile is added to the list of available pre allocated datafiles and is ready to receive new chunks.

In the illustrated embodiment when a datafile s storage is reclaimed that datafile is recycled e.g. reused or written over instead of deleted.

The details of the storage reclamation algorithm including for example when to execute it and how much storage to reclaim depend on a retention policy associated with a datafile . A retention policy limits the retention of a chunk based on for example a disk space usage threshold or a maximum time to retain the chunk. Examples of when to execute the storage reclamation algorithm are when all of the datafiles associated with that policy are full and no more datafiles can be allocated e.g. because there is no storage space left when a particular threshold has been reached e.g. in terms of the amount of free storage space left for datafiles associated with that retention policy when a particular period of time has elapsed when a particular number of datafiles exist that are associated with that policy and when the oldest chunk in a datafile associated with that policy has reached a threshold age. In one embodiment a datafile is backed up onto another system before its space is reclaimed. In this way more storage can be made available while still maintaining existing data.

In one embodiment all datafiles are associated with the same retention policy. In another embodiment multiple retention policies exist and each datafile is associated with any one of the multiple retention policies. Multiple datafiles can be associated with the same retention policy. A retention policy can be created and modified by a user. In one embodiment the storage manager logically maintains one instance of the storage reclamation algorithm described above for each retention policy. For example each datafile includes metadata that indicates the retention policy that applies to that datafile and a chunk is stored in the datafile that corresponds to that chunk s retention policy.

If multiple retention policies exist the system shown in is modified slightly not shown . Specifically the event receiver includes one set of buffers and one metadata structure for each retention policy. Before an event is stored in the set of buffers and the metadata structure is updated step the control system determines which retention policy should be applied to the event. This determination is based on for example a static mapping or an attribute of the particular event. Any attribute can be used such as priority or event source. Based on this determination the control system stores the event in the appropriate set of buffers and updates the appropriate metadata structure. Thus all events in a particular set of buffers will be associated with the same retention policy.

It follows that a chunk generated based on that set of buffers will be associated with the same retention policy. Before the chunk is stored in a datafile step the control system determines the chunk s retention policy and stores the chunk in a datafile associated with that policy. Thus all chunks in a particular datafile will be associated with the same retention policy.

In one embodiment each retention policy has its own group of datafiles . Each datafile is marked with a unique number. The number decides the order of the files within one group. The data files are written in appending order. Files are not updated and files are writ en once and operated in append only mode which prevents log data tampering. As all files within one retention group are filled up storage is reclaimed from the first i.e. oldest file in the group. In one embodiment a separate datafiles table is maintained for each retention policy which contains entries for datafiles that have been allocated to that retention policy. If a free list is maintained only one free list is used for the entire storage manager regardless of how many retention policies exist.

After a chunk has been stored in a datafile the events within the chunk can be queried. A query is represented as an expression that can be evaluated against an event. The expression includes one or more search terms. In one embodiment the query process occurs in multiple phases. The first phase identifies which data chunks if any could contain an event that satisfies the query. The second phase disassembles the identified chunks into their constituent events. The third phase identifies which of these events if any satisfy the query. The first phase thereby acts as a rough cut for identifying which data chunks and their events should be investigated further and which data chunks and their events should be ignored. In most cases the retention policy assigned to a chunk is not considered when events are queried or retrieved because it is not interesting which retention policy applies to a chunk that contains an event.

In the first phase search terms within the query are identified that concern information that was contained in the metadata structure back when the event was stored as an event in the buffer rather than as part of a data chunk in a datafile . This metadata information includes the unique identifier of the associated event receiver and for each field of interest a minimum value and a maximum value that together reflect the range of values of that field over multiple events initially events in the same buffer later events in the same data chunk . Recall that the metadata information was transmitted to the storage manager as part of a chunk . Then the metadata information was stored in the chunks table . Thus in order to search the events based on this metadata the metadata search terms are used to search the chunks table . This will yield which chunks if any could contain an event that satisfies the metadata search terms. In this way a search can be constrained based on particular values or ranges of values for event receiver and or fields of interest since these values are stored in the metadata in the chunks table .

Because field of interest metadata is expressed as a range of values the fact that a chunk satisfies a metadata search term does not necessarily mean that the chunk contains an event that satisfies the metadata search term. For example if the metadata search term is a field value of 10 and the chunk contains events whose field values are 5 and 15 respectively then 10 will fall within the range and the chunk will be identified as satisfying the metadata search term. However the chunk may not contain an event with a field value of 10. That is why the query occurs in two phases. What is always true however is that if a chunk could contain an event that satisfied the search term then that chunk will be identified as satisfying the search term.

In the second phase the identified chunks are disassembled into their constituent events. If the event portion of a chunk includes a compressed version of the events then the event portion is decompressed before it is divided into its constituent events.

In the third phase each event is compared with the complete set of search terms in order to determine whether the event satisfies the search terms. In one embodiment not shown the events are analyzed in a particular order. For example the events are analyzed based on their event receipt time. Analyzing the events in a particular order and appending matching events to the search results means that the events in the search results will already be in that particular order. No sorting of the events is required.

In the first phase it is possible that none of the search terms concerns information that was contained in the metadata structure . If this happens all chunks will be identified as possibly containing an event that satisfies the metadata search terms since no metadata search terms exist . The query process thereby degenerates to simply searching each stored event using all of the search terms. This is similar to the na ve inefficient organizational method that was discussed above.

The above algorithm searches for events that are stored in chunks . However the logging system may contain additional events in the event receiver e.g. within the set of buffers that have not yet been stored in a chunk. The algorithm above will not search these events. In one embodiment before the algorithm is executed the set of buffers are flushed so that the events will be sent to the storage manager and stored in a chunk. This way when the algorithm is executed the events that were formerly in the set of buffers will be searched also. In another embodiment a separate search is executed on the event receiver using the contents of the metadata structure and the set of buffers similar to the algorithm described above. This way all events will be searched whether they are stored in the storage manager or in the event receiver .

The identified metadata search terms are used to search the chunks table . Recall that each entry in the chunks table corresponds to a chunk and an entry includes the metadata stored in the chunk and the location of the chunk. The identified metadata search terms are used to search the metadata portion of the chunks table .

Each chunk whose metadata satisfies the metadata search terms is retrieved using the location of the chunk which was stored in the chunks table .

Each event is evaluated against the search query in order to determine whether the event satisfies the query. If an event satisfies the query it is included in the search results.

In one embodiment the logging system supports archiving functionality for datafiles . For example a datafile can be imported into and exported out of the logging system . As another example a datafile can be backed up onto another system and later restored into the logging system . Since events are stored in chunks and chunks are stored in datafiles events are easily transferable to nearline or offline storage. Archival criteria can be similar to the criteria that are used for querying e.g. values of information stored in metadata structures .

The above description is included to illustrate the operation of the preferred embodiments and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention.

