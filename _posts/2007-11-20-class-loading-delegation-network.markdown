---

title: Class loading delegation network
abstract: A method for a first software component in a class loading delegation network to obtain a class definition for a serialized software object, the software object implementing a software interface defined by a second software component and having associated a class defined by a third software component, the method comprising the steps of: obtaining a reference to the third software component from the class loading delegation network using an identifier of the software interface and requesting the class from the third software component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239849&OS=08239849&RS=08239849
owner: International Business Machines Corporation
number: 08239849
owner_city: Armonk
owner_country: US
publication_date: 20071120
---
This application claims the benefit of British Patent Application No. 0623426.4 filed on Nov. 24 2006 which is incorporated by reference herein in its entirety.

The present invention relates to a class loading delegation network and more particularly to deserializing objects in a class loading delegation network.

In an object oriented software runtime environment such as a Java environment Java is a registered trademark of Sun Microsystems Inc. software objects can be serialized from a runtime state to a serialized state. Such serialization involves recording a serialized form of an object to a storage medium. Such a serialized form can include a serial binary representation of an object. Serialization is useful since it provides a mechanism for recording instantiated software objects in such a way that the objects can be communicated between or within applications between runtime environments or between physical devices such as computer systems. Such serialized objects can be deserialized to a runtime state. In order to achieve deserialization a definition is required of an implementing class of which a serialized object is an instance. In a standard runtime environment such implementing class definitions are normally available to facilitate deserialization and can be loaded by a class loader as required. In some other environments however access to such class definitions can be problematic.

One such other environment is a class loading delegation network such as that found in a module system such as the Open Services Gateway initiative OSGi framework OSGi is a registered trademark of the OSGi Alliance . OSGi is a Java module system providing for the componentization of Java applications into software components. In OSGi such software components are known as bundles and can be implemented in Java archive files known as JAR files. Software components in such a class loading delegation network interoperate by exporting and respectively importing resources such as classes interfaces and packages. For example a first software component in such a system can export an interface definition for use by classes defined in a second software component in the system. Each software component has associated a class loader which is operable to load a class for use by the software component. A software component deserializing an object in such a class loading delegation network will require access to the implementing class for the object. In the event that the implementing class is not available within the software component the component may be unable to successfully deserialize the object.

One solution to overcome this problem is to make the definition of serializable classes specifically available to software components in such a class loading delegation network. For example in OSGi it is possible for a software component to provide a service such as access to objects to other software components. In this way a class definition for an implementing class can be made available to software components for the purpose of deserializing objects. However this approach has the significant drawback that software component code is required to change to support the use of such services as part of the deserialization process.

It would therefore be advantageous to provide for the deserialization of a serialized software object in a class loading delegation network such as a module system without requiring changes to software component code for the deserialization.

The present invention accordingly provides in a first aspect a method for a first software component in a class loading delegation network to obtain a class definition for a serialized software object the software object implementing a software interface defined by a second software component and having associated a class defined by a third software component. The method can include the steps of obtaining a reference to the third software component from the class loading delegation network using an identifier of the software interface and requesting the class from the third software component. Thus in this way the first software component is able to access the class definition for the serializaed software object from the third software component.

The method can further include the step of requesting the class from the second software component the second software component providing feedback to the request wherein the steps of obtaining a reference to the third software component and requesting the class from the third software component are in response to the feedback from the second software component.

The feedback can comprise an indication that the second software component is unable to provide the class the steps of obtaining a reference to the third software component and requesting the class from the third software component being performed in response to the indication that the second software component is unable to provide the class.

The third software component can store an entry for the class in a data structure accessible by each of the first and third software components the entry having associated an identifier of the software interface. The class loading delegation network can be an Open Services Gateway initiative OSGi framework and the first second and third software components are bundles executable in the OSGi framework. The method can further comprise in response to a determination that the third software component is unable to provide the class the step of in response to a determination that the third software component re exports a set of exported software packages of the second software component undertaking the following steps a obtaining a reference to a fourth software component from the class loading delegation network the fourth software component importing software packages from the third software component and b requesting the class from the third software component.

The present invention accordingly provides in a second aspect an apparatus for a first software component in a class loading delegation network to obtain a class definition for a serialized software object the software object implementing a software interface defined by a second software component and having associated a class defined by a third software component. The apparatus can include means for obtaining a reference to the third software component from the class loading delegation network using an identifier of the software interface and means for requesting the class from the third software component.

The present invention accordingly provides in a third aspect an apparatus comprising a central processing unit a memory subsystem an input output subsystem a bus subsystem interconnecting the central processing unit the memory subsystem the input output subsystem and an apparatus for a first software component in a class loading delegation network to obtain a class definition for a serialized software object as described above.

The present invention accordingly provides in a fourth aspect a computer program element such as a computer readable medium comprising computer program code embedded therein such that when loaded into a computer system and executed thereon causes the computer to perform the steps of a method for a first software component in a class loading delegation network to obtain a class definition for a serialized software object as described above.

Class loaders and are functional components operable to locate and load an identified class definition from a repository of classes. Notably the class loader is local to the first software component and so is operable to load classes associated with the first software component . Class loader is local to the second software component and so is operable to load classes associated with the second software component . Similarly class loader is local to the third software component and so is operable to load classes associated with the third software component .

The first software component comprises a serialized object . The serialized object is a serial representation of an instantiated software object such as a Java object. The serialized object is an instance of a serializable software class identified by a class identifier . The class is a definition of the structure and content of a class data structure such as a Java class and can include a definition of fields and methods. The class includes an indicator that it is serializable such as by implementing a serializable interface such that instances of the class can be serialised and deserialized. The class is not defined within the first software component and so is not readily loadable by the class loader . Instead a definition for the class is provided in a third software component as a class which implements a software interface such as a Java interface. A software interface is an abstract definition of software methods which are supported by instances of classes which implement the software interface. The class implements the interface and so provides the software methods defined in the interface . Further the serialized object which is an instance of the class is also an instance of the interface . For this reason the serialized object farther comprises an identifier of the software interface .

The software components and can include a definition of resources which they require from other of the software components known as imports. Similarly software components and can include a definition of resources which they make available to other of the software components known as exports. In the exemplary arrangement of second software component exports the interface definition for import by the first and third software components . These imports are resolved at runtime by the class loading delegation network by the creation of linkages and such as linkages in OSGi known as wires between the software components. The linkage corresponds to the importation of the interface definition by the first software component . Similarly the linkage corresponds to the importation of the interface definition by the third software component .

The class loading delegation network further includes application programming interface API functions . For example the OSGi framework provides an API function for the provision of a list of software components which import a specified interface.

In use the first software component deserializes the serialized object . The deserialization requires access to the class definition as identified in the serialized object . If the first software component attempts to load the identified class using its local class loader this will fail since the local class loader has no access to a definition of the class . Accordingly the first software component obtains a reference to the third software component from the class loading delegation network using the identifier of the software interface . This can be achieved by invoking an API function of the class loading delegation network for providing the software components which import the identified interface . Such an API function will provide a reference to the third software component since the third software component imports the interface . Subsequently using this reference to the third software component the first software component can request the third software component to load the class identified by the class identifier . The third software component will successfully load the class definition using its local class loader since the class definition is included in the third software component . The third software component subsequently provides the loaded class definition to the first software component . Thus in this way the first software component is able to access the class definition for the identified class in order to deserialize the serialized object .

In an alternative embodiment the first software component requests the software component supplying the definition of the interface to load the class identified by the class identifier . The first software component initially requests the second software component to attempt to load the class definition . In this alternative embodiment the first software component only obtains a reference to the third software component if the second software component is unable to load the class definition . This has the advantage that the steps of obtaining a reference to the third software component are avoided in the event that the software component supplying the interface definition also includes the class definition which in the exemplary arrangement it does not .

The third software component will successfully load the class definition using its local class loader since the class definition is included in the third software component . The third software component subsequently provides the loaded class definition to the first software component . Thus in this way the first software component is able to access the class definition for the identified class in order to deserialize the serialized object .

The arrangement of will now be considered in use with reference to the state diagram of . A software component including a serializable class definition will add an entry to the data structure . Thus in the exemplary arrangement of the third software component adds an entry to the data structure for the serializable class at step . An identifier of the class is stored in the data structure along with an identifier of the interface implemented by the class at step . The data structure is accessible to the third software component by way of the class loader since the data structure is a static field in the class loader class of which the class loader is an instance. In one embodiment an entry for a class is added to the data structure when the serializable class is first loaded by a software component. Alternatively an entry for a class can be added to the data structure at a specific point in the lifecycle of a software component which includes the class. For example the entry for the class can be added to the data structure when the software component is resolved i.e. when the linkages between the software component and other software components in the OSGi framework are resolved such as by the creation of wires . In a further alternative the entry for the class can be added to the data structure when the software component is started which is a recognized state for a software component such as a bundle in an OSGi framework.

Subsequently a software component deserializing a serialized object which is an instance of a class listed in the data structure can seek to load the class using the interface information stored in the data structure for the class. Thus at step for the exemplary arrangement of the first software component seeks to deserialize the serialized object which is an instance of the class as identified by the class identifier . Initially the first software component attempts to load the class using its own class loader at step . Since a definition for the class is not available to the first software component it is unable to load the class in this way. Subsequently at step the first software component locates an entry in the data structure corresponding to the class identifier for the serialized object . The data structure is accessible to the first software component by way of the class loader since the data structure is a static field in the class loader class of which the class loader is an instance. The third software component previously added an entry for the class to the data structure at step and so the first software component is able to locate an entry for the class in the data structure . The entry in the data structure for the class includes a list of the interfaces implemented by the class .

The first software component subsequently iterates through each interface implemented by the class . In the exemplary embodiment of only one interface is implemented by the class . For each interface the first software component requests at step that the software component supplying the definition of the interface load the class identified by the class identifier . This is a logical first step in attempting to load the class since the first software component is aware that the class implements the interface and so it is reasonable to request that the software component supplying the interface i.e. the second software component attempts to load the class at step . In the exemplary arrangement of however the second software component which supplies the definition of the interface is unable to load the class since it is not available to the class loader of the second software component . The second software component provides feedback to the first software component to indicate whether it was able to load the class .

If as is the case in the arrangement of the second software component supplying the interface definition is unable to load the class the first software component obtains a reference to each software component importing the interface definition at step . Such a reference can be obtained using the framework API which provides such facilities in an OSGi environment. The framework API provides at step the first software component with a reference to the third software component which also imports the interface definition . Subsequently the first software component requests that the third software component load the class at step . The third software component is able to load the class at step using the class loader since the class definition is accessible to the third software component. The third software component subsequently provides the loaded class to the first software component to facilitate the deserialization of the serialized object .

In some embodiments of the present invention not illustrated the third software component may not include the definition of the class but instead it may re export the definition of the interface which is imported from the second software component to another fourth software component which itself includes the class definition . For example in OSGi such re exportation of imported resources can be implemented using metadata associated with the third software component such as visibility reexport as will be familiar to those skilled in the art. In such a case the method described above will not be able to locate a definition of the class . To overcome this obstacle the method can be supplemented by a determination as to whether the third software component re exports a set of exported resources such as software packages including classes and interfaces . For example this determination can be made in the OSGi environment by analyzing metadata associated with the third software component to locate a visibility reexport item. Such metadata can be included in a manifest of a JAR file for the software component. If the method determines that the third software component does re export the set of exported resources the method can obtain a reference to the fourth software component which imports resources from the third software component . The framework API is operable to provide such reference to the fourth software component. Subsequently the fourth software component can be requested to load the class definition . Such an approach can be recursive where multiple software components re export resources in a chain.

In an alternative embodiment the third software component includes metadata such as a manifest for a JAR file associated with the third software component. The metadata includes an indication of which classes in the JAR file for the third software component are serializable and for which it is desired to create an entry in the data structure . In this way it is possible for the third software component to include a serializable class which is not included in the data structure in the event that the class is determined to be private to the third software component.

Insofar as embodiments of the invention described are implementable at least in part using a software controlled programmable processing device such as a microprocessor digital signal processor or other processing device data processing apparatus or system it will be appreciated that a computer program for configuring a programmable device apparatus or system to implement the foregoing described methods is envisaged as an aspect of the present invention. The computer program may be embodied as source code or undergo compilation for implementation on a processing device apparatus or system or may be embodied as object code for example.

Suitably the computer program is stored on a carrier medium in machine or device readable form for example in solid state memory magnetic memory such as disk or tape optically or magneto optically readable memory such as compact disk or digital versatile disk or the like and the processing device utilizes the program or a part thereof to configure it for operation. The computer program may be supplied from a remote source embodied in a communications medium such as an electronic signal radio frequency carrier wave or optical carrier wave. Such carrier media are also envisaged as aspects of the present invention.

It will be understood by those skilled in the art that although the present invention has been described in relation to the above described example embodiments the invention is not limited thereto and that there are many possible variations and modifications which fall within the scope of the invention.

The scope of the present invention includes any novel features or combination of features disclosed herein. The applicant hereby gives notice that new claims may be formulated to such features or combination of features during prosecution of this application or of any such further applications derived therefrom. In particular with reference to the appended claims features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the claims.

