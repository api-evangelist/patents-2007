---

title: Technique for controlling selection of a peek adapter or a read adapter from multiple adapters of a high speed switch
abstract: A technique is provided for facilitating peeking and reading of messages from multiple adapters connected, for example, to a high speed switch in a distributed computing environment. The technique employs a first, relatively quick filter to initially test whether a previously used adapter of the multiple adapters should be used to peek or read a new message. If the first filter fails to select the previously used adapter, then the technique includes employing a second, more complicated filter to determine which adapter of the multiple adapters should be used to peek or read the next message. The first filter includes a first set of tests, and the second filter includes a second set of tests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07792146&OS=07792146&RS=07792146
owner: International Business Machines Corporation
number: 07792146
owner_city: Armonk
owner_country: US
publication_date: 20071018
---
This application is a continuation of U.S. patent application Ser. No. 11 457 583 filed Jul. 14 2006 and issued Oct. 23 2007 as U.S. Pat. No. 7 286 559 entitled Technique for Controlling Selection of a Peek Adapter or a Read Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden which application is a continuation of U.S. patent application Ser. No. 10 156 377 filed May 28 2002 and issued Feb. 13 2007 as U.S. Pat. No. 7 177 322 B2 entitled Technique for Controlling Selection of a Peek Adapter or a Read Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden the entirety of each of which is hereby incorporated herein by reference. Further this application contains subject matter which is related to the subject matter of the following patent which is assigned to the same assignee as this application and which is hereby incorporated herein by reference in its entirety 

 Technique for Controlling Selection of a Write Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden U.S. Pat. No. 7 161 954 and issued Jan. 9 2007.

This invention relates in general to a distributed computer system having a plurality of data processing nodes and one or more switch units which establish links between the plurality of processing nodes and more particularly to a technique for controlling selection of an adapter from multiple adapters for viewing or reading a message in an associated buffer in order to enhance overall message processing performance.

In certain parallel processing systems containing a plurality of data processing nodes one or more switch units are provided for transferring data between the data processing nodes. A switch unit receives a connection request from one of a plurality of nodes and establishes a link between the data processing node which sends the connection request and another of the plurality of data processing nodes which is requested by the connection request. As used herein a switch node means any node of the plurality of data processing nodes which is capable of connecting to such a switch unit. A switch node includes a device driver and at least one adapter.

More particularly described herein is a control technique for a switch node having multiple adapters. Advantageously multiple adapters are assumed to receive data for reading at a faster rate than a single adapter. However it is recognized herein that a need exists in the art for a control technique for enhancing the process of switching between adapters during the peeking and reading of messages. The present invention provides such a selection control technique.

Although multiple adapters are assumed to facilitate the reading of data faster than a single adapter it has been discovered by applicants that this is not always the case. If the speed at which the data can be read is limited by the path length of the computer program multiple adapters can actually slow down the reading of data i.e. the increased path length for switching between adapters slows down the application. This can create a situation where applications actually run slower on multiple adapters than on one adapter. Thus it has been discovered that a need exists for an effective technique for controlling switching between adapters. This control technique should benefit applications that read more data than one adapter can provide by allowing those applications to use multiple adapters while at the same time not penalizing applications that do not read data faster than one adapter can provide.

In view of the above provided herein in one aspect is a method of selecting an adapter of multiple adapters of a switch node for peeking or reading of a new message. The method includes employing a first filter to initially test whether a previously used adapter of the multiple adapters should be used to read a next message and if the first filter fails to select the previously used adapter then employing a second filter to determine which adapter of the multiple adapters should be used to read the next message. In one embodiment the second filter is more complicated and time consuming than the first filter.

The first filter may comprise a first test set including at least one of determining whether a read is pending indicative that the next message in the previously used adapter has been peeked at or determining that each of the following conditions is true a message is available in the previously used adapter a switch count indicates that the next message should be received from the previously used adapter and the previously used adapter is currently operational.

Systems and computer program products corresponding to the above summarized methods are also described and claimed herein.

In one aspect presented herein is a technique for facilitating reading of messages from multiple adapters connected to a high speed switch in a distributed computing environment. The technique which employs minimizing overhead in switching between adapters in order to enhance performance can be utilized in a program interface that allows application programs to read from multiple adapters with the same interface used to read from one adapter.

Disclosed herein is an effective technique for switching between adapters which benefits applications that read more data than one adapter can handle by allowing those applications to use multiple adapters while at the same time not penalizing applications that do not read faster than one adapter can handle. This is accomplished by limiting the path lengths for switching between adapters to the point where no application suffers by using multiple adapters and many applications benefit. Using the technique presented herein applications can use multiple adapters expecting to perform at the same or greater speed than possible using a single adapter.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention.

All of the nodes in a frame of the SP computer are included in a LAN segment which is joined by the other LAN segments through LAN gates . As examples each LAN gate includes either a RISC 6000 computer any computer network connected to the LAN or a network router. However these are only examples. It will be apparent to those skilled in the art that there are other types of LAN gates and that other mechanisms can be used to couple the frames to one another.

Also connected to the LAN is a control workstation CWS which controls operation of the SP computer . The control workstation has a direct access storage device DASD referred to as the System Shared Disk on which is stored the system data repository SDR files. The SDR files include such information as a list of nodes that are in the system and their configuration and includes resources and object definitions for each of the nodes . Each node also includes a DASD device for storing data processed by the SP computer .

In one embodiment the nodes in each frame are also connected to an IBM Scalable POWERparallel switch SPS . Each of the SPS switches of each frame is connected to neighboring SPS switches of other frames by a bus .

As is well understood in the art the CWS node sends system data and control signals to the frames of the SP computer by means of the LAN while messages and data may be sent from one to another of the nodes by means of the high performance switches .

The distributed computing environment of is only one example. It is possible to have more or less than 8 frames or more or less than 16 nodes per frame. Further the processing nodes do not have to be RISC 6000 computers running AIX. Some or all of the processing nodes can include different types of computers and or different operating systems. Further aspects of the invention are usable with other types of communications environments. All of these variations are considered a part of the claimed invention.

A node includes an operating system such as AIX. Operating system includes for instance at least one communication device driver . The device driver is based on the type of adapter in the environment such as SP switch 2 and it may manage one or more adapters .

Each network adapter is used to couple its associated node to a particular network which corresponds to that adapter type. Network includes any IP capable network such as the Ethernet Token Ring FDDI ATM SP Switch Fiber Channel etc.

Before discussing particular adapter processing embodiments in accordance with the present invention various concepts thereof are explained below.

The present invention works with adapters e.g. adapter of that connect computer hardware to for example a high speed network or switch. The configuration may have the following qualities.

The adapter can be on a high performance connection to other machines for example a connection on a high speed switch. In one aspect the present invention can be used to insure that the high performance of the connection is not lost through the path length of switching between adapters.

The adapters are assumed to have a method of storing messages that are going to be read for example in a first in first out queue referred to as the FIFO . For simplicity in describing certain concepts of the present invention the example of a FIFO with a head of FIFO pointer and tail of FIFO pointer is used.

Obtaining information from an adapter may be a slower operation than obtaining information from main computer storage. For example obtaining the head of FIFO and tail of FIFO pointers from the adapter may be a slow operation.

It is possible to peek at a next message in the FIFO. When a peek operation is performed a certain amount of data is read from the message but the message remains in the FIFO.

An adapter may go down at any point while reading from it. When an adapter goes down an interrupt is assumed to be generated for the application indicating that the adapter has gone down. When the adapter is down if a message has been peeked at as noted above that message can still be read from the FIFO. This is necessary because once the application peeks at a message it must be able to read the same message. The adapter may then come up again at any point generating another interrupt.

In order to read from a single adapter a check is made that the adapter is up and that there is a message in its associated FIFO. If both conditions are true the message can be peeked at or read from the adapter. Pseudocode for this operation is shown below.

There are other times when a switch will be made between adapters. If there are no messages available on one adapter then a switch is made to another ever if switch count messages have not been read. In addition if an adapter goes down a switch is made to an adapter that is up.

When a message is peeked at provision is made to ensure that the next message that is read is the one that was peeked at. Once a peek has taken place a switch to another adapter cannot be made until the message has been read.

The concept of a significant difference number is also employed representative of the difference between the number of messages in one adapter FIFO versus other adapter FIFOs. The significant difference number can be set to be any number desired and it indicates that if some adapter FIFO has more than significant difference number of messages than other adapter FIFOs messages should be read from the FIFO with the greater number of messages. For example if the significant difference number is 512 and certain FIFOs have 600 messages while others have 12 messages most messages should be read from the FIFOs with 600 messages. It is assumed that the FIFOs with greater number of messages are receiving messages faster than the other FIFOs and thus should be read from more rapidly.

However the FIFOs with less messages are not ignored altogether. If only the FIFOs with the greater number of messages were read it would be possible to end up with a situation where FIFOs containing a great deal of entries are constantly read while the less full FIFOs are completely ignored. Thus when certain FIFOs contain significantly more messages than others a few messages are read from the less full FIFOs and then a switch back is made to the more full FIFOs where many messages may be read.

When a message is read from an adapter there are generally two steps. A first is to peek at the message in order to extract header information. The header information lets the program know why the message is being received and where it should be stored. Using the header information the program then knows how to handle the second step which is to read the message.

As shown above there can be quite a few steps to execute when doing a peek into a message and then reading from it using multiple adapters. These steps are executed along critical performance paths and can cause an unacceptable performance slow down compared with the single adapter case. The problem becomes even worse when more than two adapters are used.

The invention presented herein avoids long path lengths by saving state information from previous tests by taking advantage of the fact that the program is notified in an interrupt or signal handler when the adapter goes down and by combining several tests into one. The processing discussed below takes advantage of the fact that in most cases the next message is read from the same adapter from which the previous message was read from. This adapter is referred to herein as the previous adapter or the previously used adapter . Those skilled in the art will understand that as used herein the reading of a message from an adapter refers to the reading of the message from a buffer associated with the adapter as explained further below. For example if the switch count is 32 then as long as there are enough messages in the associated FIFO we will prefer to read 32 messages from the previous adapter before a message is read from another adapter. Thus one aspect of the present invention is to make the path length of reading from the previous adapter as short as possible even if that makes the path length for switching between adapters a little longer. The shorter path length will be executed for the large majority of cases and the longer infrequently. Test processing to determine when the previous adapter is to be employed is referred to herein as the simple set of tests or first set of tests while test processing employed to select a potentially new adapter is referred to as the more complicated set of tests or second set of tests .

Before describing the test processing in detail the environment of the invention is described in greater detail with reference to the distributed computing environment depicted in . As shown multiple computing nodes A B . . . each include a portion of an application A B . . . . The respective applications employ application programming interfaces APIs A B . . . to call particular functions such as the peek and read functions discussed herein as well as the write function described in the above incorporated co filed application . The multinode network is connected by multiple high speed switches such as the RS6000 SP switch marketed by International Business Machines Corporation. The multiple high speed switches define multiple switch planes e.g. switch plane switch plane . Each computer is connected to the several switches using separate adapters A B . . . Device drivers A B . . . facilitate the reading and writing of messages through the respective adapters.

In the example shown adapter of each node is connected to switch plane and adapter of each node is connected to switch plane . When a message is written from one node to another node the adapter that the message is sent through determines which adapter the data is received at. A message is received on the same adapter number that the message was sent on. So if a message is sent through adapter on a first computing node it will travel through switch plane to adapter on a second computing node.

In operation the portion of the application and program running on a particular computing node writes messages through its respective API to other parts of the application running on other computing nodes. Similarly the portion of the application on a receiving node reads messages from other parts of the application running on other computer nodes through its API.

Each adapter of each computing node has associated therewith a write FIFO and a read FIFO A B . . . . These FIFOs are employed when writing and reading messages through the adapters. When an application writes a message it calls its associated API to place the message into the write FIFO associated with the selected adapter. This FIFO has a fixed number of slots that can be filled by the API. When the adapter associated with the FIFO ascertains that a message is in the FIFO the adapter sends the message over the switch plane in a first in first out order. If the write FIFO is full the API detects this and tells the application. The application then waits until the adapter transfers a message out of the FIFO onto the switch before placing a new message into the FIFO. The adapter transfers a message from its associated FIFO onto the switch and the message travels across the switch to other computing nodes. An adapter on another computing node connected to the particular switch plane receives the message and places it into its associated read FIFO.

The receiving application may then call the API peek function to see a part of the contents of the message in the read FIFO. As noted a peek operation returns a part of a message without removing the message from the read FIFO. The receiving application may read the rest of the message using the API read function which then removes the data from the read FIFO. Once the data is removed the space on the read FIFO is available for a new message.

Within this environment presented herein are various processing enhancements to facilitate enhanced processing performance of the multiple nodes using multiple adapters and their associated FIFOs. Unless otherwise specified the adapter FIFO discussed herein refers to an adapter s read FIFO.

One piece of state information which can be saved is the count of how many messages are in the adapter FIFO. From the point of view of the peek and read operations it does not matter if there is one or many messages in the FIFO. If there is at least one message the message can be peeked at or read. To avoid reading information from the adapter with every message peek or read a message count is saved in local storage representative of how many messages are in the FIFO every time this is determined by checking the adapter. This count could be decremented each time the FIFO is read and indicate that there are at least message count messages in the FIFO. There may be more but there are at least that many. The exact number of messages need only be calculated when the message count is decremented to zero. This improves performance because determining the exact number of messages in the adapter FIFO is a considerably slower operation than decrementing the message count. Since the exact number of messages does not need to be known but only whether one or more messages are in the FIFO time is saved using the message count variable.

Part of the simple set of tests is to determine if the switch count or the message count has reached 0. If either has we must perform the more complicated set of tests to determine if it is time to switch adapters. In the actual implementation we do not need to decrement both the switch count and the message count every time a message is read. A combined count is employed called recv test that is initialized to the smaller of the switch count and the message count. Recv test is decremented every time a message is read. When it reaches 0 it indicates that either the switch count or the message count would have reached 0 if they had been decremented. Using recv test allows processing to decrement and test only 1 variable instead of two thus shortening the pathlength of the shorter set of tests.

Another aspect of the present invention is to employ a test pointer to the previous adapter. If the pointer is NULL it indicates that we may not want to read from the previous adapter and the more complicated set of tests is to be used to determine which adapter to select. If the pointer is not NULL it indicates that the next message should be read from the previous adapter. This being the case when the test pointer is not NULL we can determine which adapter to read from using only one test in each of the peek and read operations.

There are two times when the test pointer is set to NULL. The first is when an indication comes in that the status of one of the adapters has changed that is an adapter has gone up or down . This is detected in an interrupt handler and the pointer is set to NULL from that interrupt handler so that the next time a peek or read operation is called the more complicated set of tests will be used. By setting the test pointer from an interrupt handler we do not add any path length to the main line path of processing messages from the FIFO. If the interrupt occurs between a peek and a read operation the test pointer can not be set to NULL because the next read must come from the previous adapter. In this case the pointer is set to NULL after the next read. In order to make sure that this is accomplished recv test is set to 0 so that after the next read operation it will have a value of 0 or less. Recv test can be used to signal this because it is already tested after each read operation and thus we are not adding anything to the simple set of tests in order to check for this condition.

The setting of the test pointer and recv test in an interrupt handler does cause a timing problem that should be addressed. It is possible for the test pointer and recv test to be set in the interrupt handler at the same time that they are set in the complicated set of tests. When this occurs we can not be sure whether the value from the interrupt handler or the value from the more complicated set of tests is the one that remains. The interrupt handler could set the test pointer to NULL only to have the more complicated set of tests set it to another value an instant later. In this case the indication that the more complicated set of tests should be done the next time that peek or read is called would be lost. In order to handle this timing issue the interrupt handler also sets a flag that indicates the test pointer and recv test have been set from an interrupt handler. The more complicated set of tests will examine this flag to see if an interrupt occurred while it was setting the test pointer and recv test and if it has the test pointer and recv test will be set to NULL and 0 respectively. This will cause the more complicated set of tests to be used the next time that peek or read is called and any effects of the interrupt will be handled.

The second time the test pointer may be set to NULL is immediately after a message has been read. At this point recv test is decremented. If it is 0 the test pointer is set to NULL indicating that the more complicated set of tests is to be performed.

Notice that if the previous adapter should be used for the next peek or read is determined with only the additional path length of testing the test pointer decrementing recv test and testing the recv test.

One embodiment of psuedocode for the more complicated set of tests when two adapters are used is shown below.

If more than two adapters are used then the more complicated set of tests could be implemented as follows 

Beginning with the first or simple filter for a peek operation initially inquires whether the test pointer is set to NULL . If so then the more complicated set of tests of is employed as explained further below. Inquiry represents a quick analysis that is performed with each message peek operation to determine whether the read FIFO associated with the previously used adapter can continue to be used for the new peek operation. As a default the test pointer could be set to use the previous adapter. The test pointer is set to NULL if any of a group of conditions arises as explained hereinbelow. In such a case the more complicated set of tests would be employed.

Assuming that the test pointer is set to other than NULL then processing sets up to peek from the FIFO associated with the previously used adapter . Processing then peeks from the specified adapter s FIFO which completes the peek operation .

As noted depicts one embodiment of processing comprising a first filter of a read operation in accordance with an aspect of the present invention. Similar to the peek operation this read operation begins by determining whether a test pointer is set to NULL . If so then the more complicated set of tests of is called . As with the peek operation this test is performed as a quick analysis to determine whether the read operation can read a message from a FIFO associated with the previously used adapter. As a default the test pointer could be set to the previously used adapter. The test pointer is set to NULL if any of a group of conditions arises as explained below.

Assuming that the test pointer is set to other than NULL then processing sets up to read from the previously used adapter . Upon completion of processing or processing a message is read from the specified adapter s FIFO and a recv test variable is decremented . This variable is used as a single point of reference to determine whether a next read operation can continue from the FIFO associated with the previously used adapter. Processing then inquires whether recv test is less than or equal to zero . If no then additional messages can be read from the FIFO associated with the previously used adapter and the read operation is complete . Otherwise processing sets the test pointer to NULL so that the more complicated set of tests of will be employed the next time there is a peek or read operation after which processing is complete .

As noted the more complicated set of tests represented in one example by the processing of can be called from the processings of when the initial inquiry determines that the test pointer is set to NULL. Beginning with the more detailed processing initially calculates a new value for switch count based on how much recv test has been decremented . Processing then determines whether there has been a previous peek operation without the packet having been correspondingly read as yet . As noted above a peek operation precedes a read operation in many implementations. Thus inquiry ensures that a read operation refers to the same message as a preceding peek operation. There is no switching of a FIFO between a peek operation and a read operation. If there has been a previous peek operation without a corresponding read operation then processing sets up to peek or read from the previously used adapter s FIFO after which the processing of is employed as explained further below.

Assuming that the answer from inquiry is no then processing determines whether the previously used adapter is down . If so then the processing of is employed. Otherwise the message count is determined for the previously used adapter and an inquiry is made whether the message count for the previously used adapter is greater than zero and the switch count is greater than zero . If so then processing sets up to peek or read from the FIFO associated with the previously used adapter before following the processing of .

If either message count or switch count is equal or less than zero then processing searches a list of adapters to find a next adapter that is up and has messages in its associated read FIFO . The list of adapters could be any list or ordering of adapters desired for example a simple listing of adapters from zero to N where N is the number of possible adapters.

Continuing with the flowchart embodiment of processing next determines whether an adapter was found . If so an inquiry is made whether there is an adapter that has significantly more messages than the selected adapter . If no processing sets up to peek or read from the selected adapter and the switch count variable is set to the number of messages that should be read or peeked before switching to another adapter after which processing continues with the flowchart of . If there is an adapter that has significantly more messages than the selected adapter then processing sets up to peek or read from the selected adapter and sets switch count to a small value so that the more complicated set of tests will be employed relatively soon in order to effectuate a switch to reading of messages from the more full adapter . Again once switch count is set processing continues with the flowchart of .

If no adapter was found then from inquiry processing determines whether the message count for the previous adapter is zero . If so a signal is returned indicating that no messages are currently available after which processing is done. If message count for the previous adapter is other than zero then processing sets up to peek or read from the previously used adapter and the switch count is set to the defined number of messages that should be read before switching to another adapter . Once switch count is set processing continues with the flowchart of .

As noted the process of is followed from the processing of when it is determined that the previously used adapter is down. processing flow begins by searching the list of adapters to find a next adapter which is up and has messages in its associated FIFO . Processing then determines whether an adapter was found . If no an indication is returned that no messages are currently available and processing is finished. If an adapter was found then processing sets up to peek or read a message from the selected adapter s FIFO after which the switch count is set to the defined number of messages that should be read before switching to another adapter and the processing of is performed.

Processing next determines whether an interrupt occurred such that what the interrupt handler did may have been overwritten . If a concurrent interrupt has occurred the test pointer is set to NULL and recv test is set to zero . A valid pointer is returned however for the current peek or read operation i.e. resetting of the test pointer to NULL only affects the next peek or read operation. Thereafter peek or read processing is complete using the more complicated set of tests and return is made to the peek operation flow of or read operation flow of depending upon the operation initially calling the more complicated set of tests.

The present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The article of manufacture can be included as a part of a computer system or sold separately.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

Although preferred embodiments have been depicted and described in detail herein it will be apparent to those skilled in the relevant art that various modifications additions substitutions and the like can be made without departing from the spirit of the invention and these are therefore considered to be within the scope of the invention as defined in the following claims.

