---

title: Methods and apparatus for providing data transfer control
abstract: A variety of advantageous mechanisms for improved data transfer control within a data processing system are described. A DMA controller is described which is implemented as a multiprocessing transfer engine supporting multiple transfer controllers which may work independently or in cooperation to carry out data transfers, with each transfer controller acting as an autonomous processor, fetching and dispatching DMA instructions to multiple execution units. In particular, mechanisms for initiating and controlling the sequence of data transfers are provided, as are processes for autonomously fetching DMA instructions which are decoded sequentially but executed in parallel. Dual transfer execution units within each transfer controller, together with independent transfer counters, are employed to allow decoupling of source and destination address generation and to allow multiple transfer instructions in one transfer execution unit to operate in parallel with a single transfer instruction in the other transfer unit. Improved flow control of data between a source and destination is provided through the use of special semaphore operations, signals and message synchronization which may be invoked explicitly using SIGNAL and WAIT type instructions or implicitly through the use of special “event-action” registers. Transfer controllers are also described which can cooperate to perform “DMA-to-DMA” transfers. Message-level synchronization can be used by transfer controllers to synchronize with each other.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07627698&OS=07627698&RS=07627698
owner: Altera Corporation
number: 07627698
owner_city: San Jose
owner_country: US
publication_date: 20070730
---
The present application is a continuation of U.S. Ser. No. 11 533 897 filed Sep. 21 2006 now U.S. Pat. No. 7 302 504 which is a continuation of U.S. Ser. No. 11 100 697 filed Apr. 7 2005 now U.S. Pat. No. 7 130 934 which is a divisional of U.S. Ser. No. 10 782 201 filed Feb. 19 2004 now U.S. Pat. No. 6 944 683 which is a continuation of U.S. Ser. No. 10 254 105 filed Sep. 24 2002 now U.S. Pat. No. 6 721 822 which is a continuation of U.S. Ser. No. 09 896 687 filed Jun. 29 2001 now U.S. Pat. No. 6 457 073 which is a divisional of U.S. Ser. No. 09 471 217 filed Dec. 23 1999 now U.S. Pat. No. 6 260 082 which claims the benefit of U.S. Provisional Application Ser. No. 60 113 555 filed Dec. 23 1998.

The present invention relates generally to improvements in array processing and more particularly to advantageous techniques for providing improved data transfer control.

Various prior art techniques exist for the transfer of data between system memories or between system memories and input output I O devices. shows a conventional data processing system comprising a host uniprocessor processor local memory I O devices and a system memory which is usually a larger memory store than the processor local memory and having longer access latency and a direct memory access DMA controller .

The DMA controller provides a means for transferring data between processor local memory and system memory or I O devices concurrent with uniprocessor execution. DMA controllers are sometimes referred to as I O processors or transfer processors in the literature. System performance is improved since the Host uniprocessor can perform computations while the DMA controller is transferring new input data to the processor local memory and transferring result data to output devices or the system memory. A data transfer is typically specified with the following minimum set of parameters source address destination address and number of data elements to transfer. Addresses are interpreted by the system hardware and uniquely specify I O devices or memory locations from which data must be read or to which data must be written. Sometimes additional parameters are provided such as element size. In addition some means of initiating the data transfer are provided and also provided is a means for the DMA controller to notify the host uniprocessor when the transfer is complete. In some conventional DMA controllers transfer initiation may be carried out by programming specific registers within the DMA controller. Others are designed to fetch their own transfer descriptors which might be stored in one of the system memories. These descriptors contain the information required to carry out a specific transfer. In the latter case the DMA controller is provided a starting address from which to fetch transfer descriptors and there must be some means for controlling the fetch operation. End of transfer EOT notification in conventional DMA controllers may take the form of signaling the host uniprocessor so that it generates an interrupt which may then be handled by an interrupt service routine. In other notification approaches the DMA controller writes a notification value to a specified memory location which is accessible by the host uniprocessor. One of the limitations of conventional DMA controllers is that address generation capabilities for the data source and data destination are often constrained to be the same. For example when only a source address destination address and a transfer count are specified the implied data access pattern is block oriented that is a sequence of data words from contiguous addresses starting with the source address is copied to a sequence of contiguous addresses starting at the destination address. Another limitation of conventional DMA controllers is the overhead required to manage the DMA controller in terms of transfer initiation data flow control during a transfer and handling EOT notification.

With the advent of the ManArray architecture it has been recognized that it will be advantageous to have improved techniques for carrying out such functions tailored to this new architecture.

As described in detail below the present invention addresses a variety of advantageous methods and apparatus for improved data transfer control within a data processing system. In particular improved mechanisms are provided for initiating and controlling the sequence of data transfers decoupling source and destination address generation through the use of independent specification of source and destination transfer descriptors hereafter referred to as DMA instructions to distinguish them from a specific type of instruction called a transfer instruction which performs the data movement operation executing multiple source transfer instructions for each destination transfer instruction or multiple destination transfer instructions for each source transfer instruction intra transfer control of the flow of data control that occurs while a transfer is in progress EOT notification and synchronizing of data flow with a compute processor and with one or more control processors through the use of SIGNAL and WAIT operations on semaphores.

Additionally the present invention provides a DMA controller implemented as a multiprocessor consisting of multiple transfer controllers each supporting its own instruction thread. It allows cooperation between transfer controllers seen in the DMA to DMA method addressed further below. It addresses single thread of control of dual transfer units or execution units. Execution control of a transfer instruction may advantageously be based on a flag in the instruction itself. Multiple instructions may execute in one unit while a single instruction executes in the other. Independent transfer counters for CTU and STU are provided. Conditional SIGNAL instructions which can send messages on control bus interrupts or update semaphores are advantageously provided as is a conditional WAIT instruction which is executed based on the state of a semaphore. When a wait condition becomes false this semaphore is updated according to instruction. Further aspects include the use of transfer conditions in branch SIGNAL and WAIT instructions STUEOT CTUEOT notSTUEOT notCTUEOT . Further the use of semaphores is addressed as the basis for conditional execution. A generalization of these techniques allows dual CTU or dual STU transfer controllers. A dual CTU transfer controller might be used to perform DMA transfers from one cluster s DMA bus to another cluster s DMA bus. Further a restart capability based on RESTART commands Load transfer count and restart commands or a semaphore update from an SCB master is addressed.

These and other advantages of the present invention will be apparent from the drawings and the Detailed Description which follow.

Further details of a presently preferred ManArray core architecture and instructions for use in conjunction with the present invention are found in U.S. patent application Ser. No. 08 885 310 filed Jun. 30 1997 U.S. patent application Ser. No. 08 949 122 filed Oct. 10 1997 U.S. patent application Ser. No. 09 169 255 filed Oct. 9 1998 U.S. patent application Ser. No. 09 169 256 filed Oct. 9 1998 U.S. patent application Ser. No. 09 169 072 filed Oct. 9 1998 U.S. patent application Ser. No. 09 187 539 filed Nov. 6 1998 U.S. patent application Ser. No. 09 205 558 filed Dec. 4 1998 U.S. patent application Ser. No. 09 215 081 filed Dec. 18 1998 U.S. patent application Ser. No. 09 228 374 filed Jan. 12 1999 and entitled Methods and Apparatus to Dynamically Reconfigure the Instruction Pipeline of an Indirect Very Long Instruction Word Scalable Processor U.S. patent application Ser. No. 09 238 446 filed Jan. 28 1999 U.S. patent application Ser. No. 09 267 570 filed Mar. 12 1999 U.S. patent application Ser. No. 09 337 839 filed Jun. 22 1999 U.S. patent application Ser. No. 09 350 191 filed Jul. 9 1999 U.S. patent application Ser. No. 09 422 015 filed Oct. 21 1999 entitled Methods and Apparatus for Abbreviated Instruction and Configurable Processor Architecture U.S. patent application Ser. No. 09 432 705 filed Nov. 2 1999 entitled Methods and Apparatus for Improved Motion Estimation for Video Encoding U.S. patent application Ser. No. 09 482 372 entitled Methods and Apparatus for Providing Direct Memory Access Control filed Dec. 23 1999 as well as Provisional Application Ser. No. 60 113 637 entitled Methods and Apparatus for Providing Direct Memory Access DMA Engine filed Dec. 23 1998 Provisional Application Ser. No. 60 113 555 entitled Methods and Apparatus Providing Transfer Control filed Dec. 23 1998 Provisional Application Ser. No. 60 139 946 entitled Methods and Apparatus for Data Dependent Address Operations and Efficient Variable Length Code Decoding in a VLIW Processor filed Jun. 18 1999 Provisional Application Ser. No. 60 140 245 entitled Methods and Apparatus for Generalized Event Detection and Action Specification in a Processor filed Jun. 21 1999 Provisional Application Ser. No. 60 140 163 entitled Methods and Apparatus for Improved Efficiency in Pipeline Simulation and Emulation filed Jun. 21 1999 Provisional Application Ser. No. 60 140 162 entitled Methods and Apparatus for Initiating and Re Synchronizing Multi Cycle SIMD Instructions filed Jun. 21 1999 Provisional Application Ser. No. 60 140 244 entitled Methods and Apparatus for Providing One By One Manifold Array 1 1 ManArray Program Context Control filed Jun. 21 1999 Provisional Application Ser. No. 60 140 325 entitled Methods and Apparatus for Establishing Port Priority Function in a VLIW Processor filed Jun. 21 1999 Provisional Application Ser. No. 60 140 425 entitled Methods and Apparatus for Parallel Processing Utilizing a Manifold Array ManArray Architecture and Instruction Syntax filed Jun. 22 1999 Provisional Application Ser. No. 60 165 337 entitled Efficient Cosine Transform Implementations on the ManArray Architecture filed Nov. 12 1999 and Provisional Application Ser. No. 60 171 911 entitled Methods and Apparatus for DMA Loading of Very Long Instruction Word Memory filed Dec. 23 1999 respectively all of which are assigned to the assignee of the present invention and incorporated by reference herein in their entirety.

The following definitions of terms are provided as background for the discussion of the invention which follows below 

A transfer refers to the movement of one or more units of data from a source device either I O or memory to a destination device I O or memory .

A data source or destination refers to a device from which data may be read or to which data may be written which is characterized by a contiguous sequence of one or more addresses each of which is associated with a data storage element of some unit size. For some data sources and destinations there is a many to one mapping of addresses to data element storage locations. For example an I O device may be accessed using one of many addresses in a range of addresses yet for any of them it will perform the same read write operation.

A data access pattern is a sequence of data source or destination addresses whose relationship to each other is periodic. For example the sequence of addresses 0 1 2 4 5 6 8 9 10 . . . etc. is a data access pattern. If we look at the differences between successive addresses we find 1 1 2 1 12 1 1 2 . . . etc. Every three elements the pattern repeats.

 EOT means end of transfer and refers to the state when a transfer execution unit described in the following text has completed its most recent transfer instruction by transferring the number of elements specified by the instruction s transfer count field.

As used herein an overrun at the source of a transfer occurs when the producer of data over writes data that the DMA controller has not yet read. An overrun at the destination of a transfer occurs when the DMA controller overwrites data that has not yet been processed by a consumer of data. An underrun at the source occurs when the DMA controller attempts to read data that has not yet been written by the producer and an underrun at the destination occurs when the consumer task attempts to read and process data that the DMA controller has not yet written.

The term host processor as used in the following discussion refers to any processor or device that can write control commands and read status from the DMA controller and or that can respond to DMA controller messages and signals. In general a host processor interacts with the DMA controller to control and synchronize the flow of data between devices and memories in the system in such a way as to avoid overrun and underrun conditions at the sources and destinations of data transfers.

In the representative system the DMA controller also connects to two system busses a system control bus SCB and a system data bus SDB . The DMA controller is designed to transfer data between devices on the SDB such as system memory and the DSP local memories . The SCB is used by an SCB master such as DSP or a host control processor HCP to program the DMA controller read and write addresses and registers to initiate control operations and read status . The SCB is also used by the DMA Controller to send synchronization messages to other SCB bus slaves such as the DSP control registers and the Host I O block . Some registers in these slaves can be polled by the DSP and HCP to receive status from the DMA. Alternatively DMA writes to some of these slave addresses can be programmed to cause interrupts to the DSP and or HCP allowing DMA controller messages to be handled by interrupt service routines.

Each transfer controller within a ManArray DMA controller is designed to fetch its own stream of DMA instructions. DMA instructions may be fetched from memories located on any of the busses which are connected to the transfer controller DMA busses SDB or SCB. shows a system illustrating data paths from which instructions may be fetched. A transfer controller can fetch DMA instructions from memories on the DMA Bus and provide them on a path to the ICU under the control of the CTU . A second path allows DMA instructions to be fetched from the SDB under the control of the STU through the IDQ under the control of the CTU and then forwarded to the ICU . A third path allows instructions to be fetched from memories or devices on the SCB on a data path through the ECU which controls the SCB master interface and then forwarded to the ICU . After receiving instructions the ICU decodes the first instruction word of each instruction determines the number of remaining instruction words and forwards the control signals and additional instruction words to the execution units CTU STU and ECU via an internal instruction bus . The ODQ is not used for instruction fetch purposes.

DMA instructions are of five basic types transfer branch load synchronization and state control. The branch load synchronization and state control types of instructions are collectively referred to as control instructions and distinguished from the transfer instructions which actually perform data transfers. DMA instructions are typically of multi word length and require a variable number of cycles to execute although several control instructions require only a single word to specify. DMA instructions will be described in greater detail below. is a table which shows a set of instruction types list their operations and briefly describes their functions in a presently preferred embodiment of the invention. In table cc indicates that instruction execution depends on a condition specified in the instruction.

Two registers are used to support the fetching of instructions a transfer program counter TPC register of and a wait program counter WAITPC of . In a preferred embodiment these registers have a sufficient number of bits e.g. 32 to address all memories which may contain instructions. The TPC contains the address of the next instruction word to be fetched and decoded. After fetching a complete instruction and updating the TPC the control logic compares the value of TPC with the value stored in WAITPC. If TPC and WAITPC are equal then the fetching and decoding of instructions is suspended. In the preferred embodiment a block of instruction words is fetched into a local cache from which they are read and decoded but this is only one of many methods to decrease instruction fetch latency for subsequent instructions. At powerup or after a reset command or signal is received by a transfer controller TPC and WAITPC are set to the same value. A command address is provided called the INITPC address which when written with a DMA instruction address value updates both the TPC and WAITPC registers with the value allowing an instruction start address to be specified without initiating the fetching of instructions. Writing a new value to either TPC or WAITPC and thereby making the two different will cause instruction fetching to proceed.

If there are multiple host processors which wish to update or add instructions to the DMA instruction list then it is necessary that some form of mutual exclusive access to the WAITPC register be maintained. A hardware support means for this mutual exclusion is provided through the use of a LOCK register illustrated in and a set of LOCKID read only addresses of which are recognized by the transfer controller s SCB slave logic. The 8 read addresses or LOCKID addresses are set aside in the transfer controller s command address space and are visible to SCB bus masters. They are used in the following manner 

Each host processor which needs to update the transfer controller s DMA instruction list is assigned one of the 8 unique LOCKID addresses.

When a host processor wishes to add instructions ahead of the current WAITPC value it reads from its own LOCKID address. The transfer controller returns the value of the locked bit of the LOCK register of .

If the value returned is 0 then no other host processor currently owns the lock. The processor becomes the new owner of the lock on the WAITPC register and may now append instructions freely starting at the current WAITPC address. When a host processor becomes owner of the lock the locked bit of the LOCK register is set to 1 and the lower 3 bits of the host processor s LOCKID address are written to bits of the LOCK register .

If the value returned is 1 then another host processor currently owns the lock on WAITPC and the requesting host processor must continue polling its LOCKID address until a value of 0 is returned indicating that it has received ownership of the lock on WAITPC.

When a host processor which owns the lock has finished updating the instruction list it writes a new value to WAITPC pointing to the next instruction location immediately after the last instruction added. The act of writing to the WAITPC clears the locked flag in the LOCK register making it available to another processor.

The hardware does not prevent write access to the WAITPC register but only provides a semaphore mechanism to facilitate software scheduling of the WAITPC i.e. DMA instruction list resource.

The LOCK register is a read only register that returns the identity of the last or current owner of the lock and the status of the locked bit of .

It will be evident that the choice of the number of lock addresses to be assigned is arbitrary and the method and apparatus can be extended or reduced to support more or fewer SCB masters.

Instruction sequencing can also be controlled by executing branch type instructions. The transfer controller supports five types of branch instructions as shown in jump relative jump absolute call relative call absolute and return. Jump relative loads the TPC with the sum of TPC and an immediate offset value contained in the instruction. Jump absolute loads TPC with an immediate value contained in the instruction. Call relative operates the same as jump relative except that before loading TPC with the new value the old value which points to the address immediately following the CALL instruction is copied to a link counter register called LINKPC shown in . Call absolute operates the same as jump absolute except a copy of the old TPC is stored in TPC prior to updating TPC. The return instruction RET copies the value of LINKPC to TPC. Instruction fetch then resumes from the updated TPC address as long as TPC is not equal to WAITPC.

All branch instructions are conditional. shows a list of the condition specifiers which may be tested to determine whether a branch should be taken or not. One of the condition specifiers is Always meaning that the branch is always taken making it conditional. Condition specifiers are both arithmetic Equal NotEqual Higher HigherOrEqual Lower LowerOrEqual GreaterOrEqual Greater LessOrEqual Less and non arithmetic CTUeot STUeot NotCTUeot NotSTUeot Always as shown in . In order to determine the truth value of an arithmetic condition a semaphore register such as one of registers S S S or S shown in which illustrates the presently preferred embodiment specified in the instruction is compared with zero. If the relationship between the semaphore value and zero is the same as that specified by the condition specifier e.g. Greater or Equal then the branch condition is TRUE. Otherwise it is FALSE. If the condition is TRUE the branch is taken and an optional update to the semaphore is made increment decrement clear to zero or no change . If the branch is FALSE the branch instruction is treated as an NOP no operation . It is ignored and no update to the semaphore is performed.

For example the instruction jmp.GT S newlocation compares semaphore register S to zero. If it is greater than zero GT then the branch to newlocation occurs the address of newlocation is loaded into TPC and the next instruction is fetched from there . In addition the semaphore S is decremented by 1 as a side effect S . If the register S is less than or equal to zero S is treated as a signed two s complement number then the branch is not taken and no decrement of S occurs.

Four of the five non arithmetic conditions CTUeot STUeot NotCTUeot and NotSTUeot allow branches to be taken or not depending on transfer unit status. These conditions are useful for controlling the instruction sequence when instructions are fetched after a transfer has completed. Since either the STU or the CTU can finish processing an instruction before the other if their transfer counts differ it is sometimes useful to conditionally branch based on which unit completes first.

Referring again to system of transfer type instructions are dispatched by the ICU for further decode execution by the STU and the CTU . Transfer instructions have the property that they are fetched and decoded sequentially in order to load transfer parameters into the appropriate execution unit but are executed concurrently. The control mechanism for initiating execution of transfer instructions is a flag bit contained in the instruction itself and is described below.

A transfer system inbound or TSI instruction moves data from the SUB to the IDQ and is executed by the STU. A transfer core inbound or TCI instruction moves data from the IDQ to the DMA Bus and is executed by the CTU. A transfer core outbound or TCO instruction moves data from the DMA Bus to the ODQ and is executed by the CTU. A transfer system outbound or TSO instruction moves data from the ODQ to the SDB and is executed by the STU. Two transfer instructions are required to move data between an SDB system memory and one or more SP or PE local memories on the DMA Bus and both instructions are executed concurrently a TSI TCI pair or a TSO TCO pair. The address parameter of STU transfer instructions TSI and TSO refers to addresses on the SDB while the address parameter of CTU transfer instructions refers to addresses on the DMA Bus to PE and SP local memories.

Executing a WAIT type instruction with a TRUE condition discussed further below causes the transfer controller to take transition T to WAIT state . When the wait condition becomes FALSE transition T returning to EXEC CONTROL occurs to complete the WAIT instruction execution followed by a transition T back to CHECKTPC . When in the DECODE state and a transfer type instruction has been decoded and a start transfer event is detected X field in the instruction is 1 the transition T to EXEC TRANSFER occurs. The transfer continues until an EOT end of transfer condition is detected at which time a transition T back to CHECKTPC occurs. Transitions T and T occur when a restart transfer event is detected in the WAIT state and CHECKTPC state respectively. When a restart event is detected while in the WAIT state and transition T occurs to the EXEC TRANSFER state when the transfer is complete either STU or CTU reaches EOT then transition T back to the WAIT state occurs. Restart transfer events are further described below.

While the transfer controller operates in one of the global states of shows the sub states in which the transfer units STU and CTU operate. The transfer units are driven by the ICU instruction dispatcher and by event monitoring logic in the ECU of . After a RESET event transition T places the transfer unit into the INACTIVE state . In this state neither a start transfer event nor a restart transfer event can cause the transfer unit to begin a transfer sequence since transfer parameters are considered invalid. When a transfer unit detects new transfer parameters are being loaded transition T takes the unit to the DECODE state . After loading all transfer instruction parameters if the execute X flag of the instruction is not 1 then transition T takes the transfer unit to the IDLE state . If the X flag is 1 start transfer then transition T places the unit into the TRANSFER state . When the unit detects its EOT condition transition T places the unit back into the IDLE state . If a restart transfer event is detected while in the IDLE state transition T places the unit back into the TRANSFER state . If a CLEAR command from an SCB bus master is received in any state the transfer units parameters are invalidated and the logic makes the transition T to the INACTIVE state .

As addressed previously for most transfers two transfer instructions are required to move data from a source memory or device to a destination memory or device one executing in the CTU and one in the STU. shows an instruction sequence to perform a simple block transfer. The .x on the tci.block.x instruction indicates immediate initiation of the transfer after decoding both instructions. shows an instruction sequence for a second instruction is the same as sequence only without the .x execute directive. In this case the transfer is not started but the following WAIT instruction is fetched and executed. In other words the logic waits for an external start event to occur either a RESTART command or a RESUME which will cause instruction fetching to continue. These commands are shown in . Note that in this example both transfer counts are the same. One of the features of the present invention is that the STU and CTU operate with independent transfer counters making it possible to execute multiple transfer instructions in one transfer unit while the other is processing a single transfer instruction. This result is achieved by specifying a sequence of instructions in which the transfer counts are different in each transfer unit.

The transfer engine cannot be allowed to overtake the producer of data underrun and the data must be transferred before the producer overwrites a region with valid but un transferred data with new data overrun . In other words underrun and overrun conditions at the source must be avoided.

Data transferred to the destination cannot overwrite unprocessed data overrun and the consumer of data can t be allowed to process invalid data i.e. a region of data that has not been updated by the transfer engine . In other words overrun and underrun at the destination must be avoided.

The control necessary to prevent underflow and overflow at the source and destination respectively should incur minimal overhead in the source and destination processors and to a lesser extent the transfer engine whose function is to hide transfer latency.

There are several synchronization mechanisms available which allow these requirements to be met for each transfer controller. These mechanisms will be described by the direction of control flow either host processor to transfer controller or transfer controller to host processor where for example host processor may refer to either the DSP or host control processor of or both.

Once a transfer has been started there must be some means for the host processor to know when the transfer has completed or reached some point of interest . These points of interest correspond to internal transfer conditions which may be checked and which may then be used to generate signaling actions back to the host processor or processors. Each transfer controller tracks the following internal conditions 

The TPC WAITPC condition is checked during the CHECKTPC state of and causes fetching to pause while the condition is true. As previously stated while in the EXEC TRANSFER state a transfer controller uses two transfer counters the system transfer count STC and the core transfer count CTC . The STC contains the number of data elements to be transferred from inbound or to outbound the SDB. The CTC contains the number of data elements to be transferred from outbound or to inbound the DMA Bus.

The main criteria for determining when an end of transfer EOT condition has occurred is that one of the transfer counters has reached zero AND all data in the transfer path has been flushed to the destination FIFOs are empty etc. . When an EOT condition is detected the transfer controller transitions to the CHECKTPC state and proceeds to fetch and decode more instructions if TPC and WAITPC are not equal. The manner in which STC and CTC are decremented and EOT is determined depends on whether the transfer is inbound or outbound.

For outbound transfers an EOT condition occurs when STC reaches zero OR CTC reaches zero AND the ODQ FIFO is empty AND the SDB bus master is idle.

For inbound transfers an EOT condition occurs when STC reaches zero OR CTC reaches zero AND the IDQ FIFO is empty AND the all data has been written to the DSP local memory.

These conditions ensure that when the transfer controller signals that a transfer is complete the data is actually valid for a host processor and data coherence is maintained.

Host processors can communicate with the transfer controller using either commands writes to special addresses register updates writes with specific data or discrete signals usually from an I O block . In addition host processors can update the transfer controllers instruction flow by using the WAITPC register to break transfer programs into blocks of transfers. Multiple hosts can use the same DMA transfer controller updating its instruction stream by using the LOCKID register and associated command addresses to implement mutually exclusive access to the WAITPC. Semaphore commands may be used to both signal and wait on a semaphore see command INCSO in table of exemplary commands associated addresses and read write characteristics of for example. Particular access addresses are used to allow these operations to be performed in one bus transfer either a read or a write . Specific register updates such as writing to the transfer count registers can be used to restart a transfer. A list of operations that a host processor can perform follows 

Execute a signal operation on a semaphore write the INCSx or DECSx address or assert one of the SIGNALSEMx input wires 

The SIGNALSEMx wires provide a set of input signal shown in to the transfer controller. These signals are associated with a transfer controller s semaphore registers shown in . The EXTSIG register shown in is used to configure which of the input signals is used to update each semaphore and to provide an enable bit. A one cycle pulse on a selected SIGNALSEM signal will cause the associated semaphore register semaphore to be incremented by 1. If this signal is asserted on exactly the same cycle that a transfer controller is executing a WAIT operation on the same semaphore then the semaphore is not updated by either operation and both operations complete as if their respective updates occurred sequentially.

An exemplary table of commands and addresses for a presently preferred embodiment is shown in . Two of these commands will be discussed further CLEAR and RESTART . The CLEAR command may be targeted at both transfer units CLEAR or either transfer unit individually CLEARSTU CLEARCTI and causes a transfer unit to invalidate its current transfer parameters and enter an INACTIVE state illustrated in . When a transfer unit is in the INACTIVE state the only means for getting it back into operation is to fetch a transfer instruction targeted for that unit. The STU has special purpose behavior in this regard however. When the STU is issued a CLEARSTU command and placed in the INACTIVE state then it becomes a visible slave on the SDB. This approach means that any data placed into the IDQ by an SDB bus master may be distributed to DSP local memories by a CTU transfer instruction and any data placed into the ODQ by the CTU can be read from the ODQ by accessing the correct slave address range for that transfer controller. This behavior is useful for implementing DMA to DMA transfers as will be discussed further below.

The RESTART command may also be targeted at one or both transfer units RESTART RESTARTCTU RESTARTSTU . When a restart command is received by a particular unit if the unit is not in the INACTIVE state shown in then the following events occur 

 1 If the transfer count is non zero then the transfer unit is restarted beginning from where it left off using its current transfer count.

 2 If the transfer count is zero then the current transfer count is reloaded from the initial transfer count and the transfer is continued from the address at which it left off.

 3 The unit that is not the target of the restart operation will continue transferring from where it left off if its transfer count is nonzero. If its transfer count is zero then the global CRECKTPC state of will be reentered or the WAIT state if the restart was received while in that state .

A further feature of the RESTART command is the ability to write a new initial and or a new current transfer count to a transfer unit together with a RESTART command. Referring to writing a count value to INITSTC START address causes the value to be copied to both the STC and the ISTC initial STC registers and a RESTARTSTU is performed also. Writing a count value to the WRITESTC address will update the current STC but no restart operation occurs. Using these commands it is possible to update either or both transfer counts for each transfer unit while also initiating an optional restart operation for the unit.

As stated earlier restart actions can occur either by instruction RESTART instruction by command written to a RESTART address on the SCB or by signal wire indirectly by updating a semaphore via the STGSEMx signals. The transfer restart based on semaphores will be discussed below.

Transfer controllers can communicate events to host processors using any of three basic mechanisms interrupt signals messages or semaphores. Each of these mechanisms may be operated in an explicit or an implicit fashion. Explicit operation refers to the operation being carried out by a DMA instruction. Implicit operation refers to the operation being carried out in response to an internal event after being programmed to do so. The following sections discuss explicit and implicit synchronization actions and the instructions or commands associated with them.

Whenever one of the four internal events TPC equal to WAITPC TPC WAITPC STU end of transfer STUEOT CTU end of transfer CTUEOT STU end of transfer and CTU end of transfer STUEOT CTUEOT becomes TRUE an associated action can be performed if is enabled. The selection and enabling of these actions is carried out by programming two registers called event action registers. In a presently preferred embodiment these registers are designated EAR and EAR are shown in tables and of respectively. These registers may be written directly by an SCB bus master or loaded using the LIMEAR instruction.

The EAR contains flags which enable E and E event detection and actions. The E flags specify conditions that when they become TRUE on each transition from FALSE TRUE trigger the corresponding E actions specified in the EAR and EAR registers. The E flags specify conditions which when they become TRUE trigger the corresponding E actions specified in the EAR and EAR registers. The E and E conditions are the same so that up to two independent sets of actions may be specified for the same event.

This EAR register also contains restart event fields which allow transfer restart actions to be triggered automatically when a specified semaphore is non zero and an EOT condition is reached CTURestartCC CTURestartSem STURestartCC and STURestartSem. Events are 

If RestartCTU is enabled AND CTUeot is active AND the specified semaphore value is not zero then the CTU restarts its current transfer automatically reloading its current transfer count CTC from its initial transfer count ICTC and decrements the semaphore atomically.

If RestartSTU is enabled AND STUeot is active AND the specified semaphore value is not zero then the STU restarts its current transfer automatically reloading its current transfer count STC from its initial transfer count ISTC and decrements the semaphore atomically.

Using the above signaling methods a transfer controller can alert one or more processors when a specified condition occurs

In a presently preferred embodiment there are two interrupt signals available to each transfer controller. These may be used as inputs to processor interrupt controllers. Explicit assertion of these signals may be carried out using the SIGNAL instruction of . Implicit assertion of these signals may be carried out when one of the specified internal events occur by programming the EAR registers shown in appropriately either with a host command or through the LIMEAR instruction of . This latter instruction simply loads the EAR registers with immediate values specified in the instruction.

In the presently preferred embodiment a message is simply a single 32 bit write to an address mapped to the SCB carried out by the transfer controller. A message requires specification of address and data. Explicit message generation may be carried out using the SIGNAL instruction with the address and data may supplied as immediate values in the instruction or with either one or both of address and data values coming from transfer controller registers. The GR registers of see also for additional details may be used for storing both addresses and data for messages. Data values may also come from other selected registers such as the TPC WAITPC SEM and TSR registers of . Implicit message actions are specified in the EAR registers of and based on the occurrence of one or more of the four internal events and use a specified GR register for the address and another register as data not limited to GR registers . Whenever a specified event becomes TRUE the programmed message is sent. Several other features of message synchronization are the following.

Since all transfer controllers reside on the SCB one transfer controller can synchronize with another through messages to semaphore update addresses together with WAIT instructions.

A message may not only be a command to another transfer controller but may also be an instruction which can be placed into a processor s instruction memory. This approach provides a mechanism for synchronizing with a host processor s execution which does not require either interrupts or polling in the usual sense.

Message capability allows a transfer controller to interact with other hardware devices on the SCB for simple configuration or control operation.

In the presently preferred embodiment there are four 8 bit hardware semaphores as illustrated in . Aspects of these semaphores are also shown in . The semaphores may be updated and monitored by both the transfer controller and host processors in an atomic fashion.

The semaphore registers SEM provide a flexible means for synchronization of transfers at the intra transfer during a transfer level and at the inter transfer level while processing instructions . In addition semaphores are used as the basis for most conditional operations. Semaphores are located in the SEM registers as seen in and may be updated and monitored by both the transfer controller and other bus masters on the SCB in an atomic fashion. The SIGNAL and WAIT instructions and may be conditionally executed based on a semaphore value. The SIGNAL instruction may also specify another semaphore to update. When a WAIT instruction is executed and the specified semaphore condition is TRUE the transfer controller halts the fetch and decode of instructions. When the condition becomes FALSE the ECU decrements the semaphore specified by the WAIT instruction and then allows the transfer controller to continue processing instructions.

Another mechanism for semaphore based synchronization makes it possible for two host processors to control the data flow during a transfer without having to communicate directly with each other about data availability on the source side or memory availability on the destination side. A further feature provided by the EAR registers allows for each transfer unit a semaphore to be specified which will cause a transfer to automatically restart if the transfer controller is in the WAIT or CHECKTPC states and of respectively and the transfer unit STU or CTU is not INACTIVE as illustrated in . An exemplary transfer instruction sequence is shown in . A host control processor such as processor of produces data into a 1K word region of memory in 256 word blocks. Each of the 4 blocks is written with new data in sequence in a circular fashion block block block block block . . . etc. . A producer block is 256 words. A consumer task running on the DSP of has only a 256 word region of memory in which to receive data split into four 64 word blocks. The DSP processes each of the four 64 word blocks in sequence also in a circular fashion. A consumer block is 64 words. Every time the producer task finishes filling a buffer it signals semaphore S by writing to the appropriate command address on the SCB INCS . Whenever the consumer task on the DSP finishes processing a buffer it writes to a command address which increments S INCS . The LIMEAR instruction configures the transfer controller to restart the STU anytime it is IDLE and S is non zero and to restart the CTU any time it is IDLE and S is non zero. When the producer task signals S the first time a restart to the STU is initiated. Since the CTU has a non zero transfer count then the overall transfer is restarted and 64 words of data are moved to one of the consumer task s data block regions the minimum of 256 and 64 . Every time STU EOT occurs 256 words moved the transfer controller asserts the signal interrupt to the producer task on the host processor and every time CTU EOT occurs 64 words moved a message is sent to an mbox1 address for DSP notification. It is assumed that the producer and consumer tasks each keep track of the data that has been moved using local semaphores that are updated based on the signal interrupt to the producer task and the message to the consumer task. Using the code of the producer task is able to generate data at its own rate and the consumer task processes the data at its own rate. There is no additional communication overhead required between the two tasks.

Each transfer controller supports an SDB slave address range which may be used to directly read and write from and to the corresponding ODQ or IDQ when the lane s STU is in an inactive state. For example a DMA transfer from SP data memory to PE data memories may be carried out by the following instruction sequences executed by transfer controller and transfer controller 

Transfer instruction Transfer System Outbound to SDB slave addressees of Lane transfer count words. Lane STU will write data to its IDQ.

Note that two transfer controllers are used to carry out DMA DMA transfers or one Transfer Controller and another SDB master .

This same mechanism can be used by any device on the SDB to read write to a lane s data queues allowing one DMA controller or I O device to read write data to another. The discussion shows how general pull and push model DMA DMA transfers can be implemented.

A push model DMA DMA transfer means that the transfer controller which is reading the data source acts as the SDB master and writes data to the SDB slave address range of another transfer controller which is writing data to a destination memory. In this case the source transfer controller is executing a TCO TSO pair of instructions and the destination transfer controller is executing only a TCI instruction with the STU inactive operating as a slave for SDB write access .

A pull model DMA DMA transfer means that the transfer controller which is writing the data to its destination memory acts as the SDB master and reads data from the SDB slave address range of another transfer controller which is reading data from a source memory. In this case the destination transfer controller is executing a TSI TCI pair of instructions and the source transfer controller is executing only a TCO instruction with the STU inactive operating as a slave for SDB write access .

Program source CTU with an instruction which gathers data from the desired memories and starts the transfer. This causes the FIFO to be filled but the STU is inactive so that the FIFO will only respond to reads from the source transfer controller s SDB slave port.

Program the destination STU with a TSI.IO instruction using the source DMA s SDB slave address as the I O transfer address to read from. Program the destination CTU with the desired transfer type for distributing data to destination memories and start the transfer.

The destination DMA Transfer Controller will Pull data from the source DMA transfer controller until either the source or the destination transfer unit reaches an end of transfer EOT condition the number of items transferred is equal to transfer count requested . Semaphores may be used to make the setup and execution of the transfer almost entirely occur in the background.

Program destination CTU with an instruction which distributes data to the desired memories and start the transfer. This causes the CTU to wait for data to arrive in the inbound FIFO. The STU is inactive so that the FIFO will only respond to writes from the source transfer controller s STU.

Program the source STU with a TSO.IO instruction using the destination DMA s SDB slave address as the I O transfer address to write to. Program the source CTU with the desired transfer type for gathering data from source memories and start the transfer.

The source DMA transfer controller will push data into the destination DMA transfer controller s inbound FIFO until either the source or the destination transfer unit reaches an end of transfer EOT condition items transferred is equal to transfer count requested . Semaphores may be used to make the setup and execution of the transfer almost entirely occur in the background.

Update transfers are special instructions that allow an already loaded transfer to be updated with a new direction transfer count or new target address or all three without affecting other parameters or state. These types of transfers are useful for minimizing DMA instruction space when processing transfers that are similar to each other. An update type instruction is specified as a variation of a TCI TSI TCO or TSO instruction for example 

The above instruction will update the direction transfer count and starting address of a transfer instruction that is already loaded into the CTU. No other parameters are affected.

The instruction tso.update tc 10 will update only the transfer count of the instruction currently loaded into the STU affecting no other parameters.

While the present invention is disclosed in a presently preferred context it will be recognized that the teachings of the present invention may be variously embodied consistent with the disclosure and claims. By way of example the present invention is disclosed in connection with specific aspects of the ManArray architecture. It will be recognized that the present teachings may be adapted to other present and future architectures to which they may be beneficial.

