---

title: Method and system for storing large data files
abstract: An enhanced file format to store large quantities of variable-sized data records on a storage medium and to permit efficient access and control over data stored in the enhanced file format. A file format is the structure of a file that defines the way it is stored and laid out on a disk. In a preferred embodiment of the present invention, a file format includes a model directory containing models. Models include element lists comprising element chunks. The element chunks include elements, where elements are variable-sized data records.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743080&OS=07743080&RS=07743080
owner: Bentley System, Inc.
number: 07743080
owner_city: Exton
owner_country: US
publication_date: 20070109
---
This application is a divisional application of U.S. patent application Ser. No. 09 929 277 and is related to co pending U.S. patent application Ser. No. 09 929 278 the contents of both are incorporated herein.

The present invention relates to a system and method for storing large data files on a computer or computer network. More specifically the present invention is related to the formatting of large data files to promote efficient data storage and transmission.

Data is typically maintained for storage and retrieval in computer file systems wherein a file comprises a collection of data or a set of records. A file system provides a collection of files and file management structures on a physical or logical storage device such as a disk or other memory device. A file system stores data in files and provides an application programming interface API to facilitate accessing data stored on a storage medium such as a disk or other memory medium. A file system API provides various functions that are invoked by an application program to access data. Application programs control the internal format of a file and determine which data to store in which files. A file system typically allows files to be grouped into directories. Each directory may contain many files and sub directories. A file system that groups files into directories and sub directories is referred to as a hierarchical file system.

There is a continuing need to improve the access and control over file systems storing large quantities of variable sized data records used in a large variety of applications. Applications involving accessing and controlling large quantities of stored data are found in the public sector E commerce financial insurance industry travel industry publishing industry graphic arts industry advertising industry and any other industry which requires managing large data files.

Examples where large amounts of data are stored in files in a hierarchical file system include database logistics and enterprise solutions software used by the financial health and distribution industries among others. Database logistics and enterprise solutions software include an API to access large quantities of data.

In another example computer aided design CAD drawings prepared by architects engineers designers planners and the like require large amounts of data to be stored in files in a hierarchical file system. CAD software includes an API to access the large quantities of data. Applications such as e.g. MicroStation products which are developed by Bentley Systems Inc. Exton Pa. U.S.A. and AutoCAD products which are developed by Autodesk Inc. San Rafael Calif. U.S.A. are typical of such CAD software which may be used in the Engineering Construction and Operations ECO marketplace. U.S. Pat. No. 6 063 128 provides an example of a CAD system.

A typical CAD project employed in the engineering context is stored in numerous files. Each file typically contains one or more engineering models each of which represents an engineering domain e.g. structural electrical mechanical plumbing . Moreover each engineering model requires numerous items represented by a series of elements to support the complex and precise nature of each design. In this context the term element is used to mean a record containing a variable number of bytes of data arranged in a format that can be interpreted by a program. The term element differs from the common notion of an object in that each element can have a variable number of bytes whereas the size of an object is typically defined by it s class. It is the variable sized nature of elements that causes their persistent storage to be complicated because they cannot be written in fixed sized records and arranged in tables as is typically done in relational databases for example.

Each item in a model is represented by at least one element or an aggregation of elements. For example a structural drawing can hold the column and beam layout for a floor plan which are internally represented by lines squares and rectangles and additional properties. In this example an individual beam may be a collection of lines squares and rectangle elements. The structure of the floor plan may be more complex and require many nested levels of elements to accurately provide a structural representation.

Accordingly as the complexity of the project increases the size of the CAD files also increases. As a result CAD files become very large and efficient access and control of these large files is important. Conventionally there are two approaches to storing these large data files.

In the first approach the elements are stored and accessed as a sequential list each element having a fixed header containing the element s size. Storing data in this manner requires that the file be read sequentially from the beginning to the end. Typically a program will read the elements from the file into memory and at the same time also store the file position of each element in memory.

This approach is well suited for the common scenario where a large number of elements are read from the disk while only a small minority of them are modified during a single editing session. In this case modified elements can often be rewritten to the file by a simple seek and write to the appropriate file position on an element by element basis. Unfortunately this only works for elements whose contents change but whose size in bytes remains the same or becomes smaller. When elements become larger during an editing session they must be deleted from their original file position and moved to the end of the file. This tends to leave holes deleted elements occupying file space in the file that can only be removed by rewriting the entire file. Further the size of disk file can grow quite large because it is not possible to remove deleted entries from the file without rewriting the entire file and invalidating all in memory element positions.

The second approach is to apply a compression algorithm to the element data before it is written to the file. This can often result in substantial savings in the resultant file size because many applications have element data typically containing a great deal of redundancy. However with this approach element data cannot be saved incrementally because a change to a single element can result in an entirely different compressed file.

Another consideration for the file storage approach is the typical requirement to allow multiple users to simultaneously access models when collaborating on a project. Typically a first user creates an original model which multiple users may view and or edit depending on the level of access granted to the user. Since communication between users typically occurs over a computer network the CAD system must ensure that changes to the model or items in the model are properly coordinated and the models are kept in a consistent state at all times. It is understood that a computer network refers to any type of computer network including but not limited to a local area network wide area network e.g. Intranet and the Internet. The Internet includes but is not limited to the World Wide Web.

Since computer systems used in many industries such as ECO demand efficient use of network resources and have the further requirement that the file system must perform in a multi user environment existing file storage approaches require substantial improvement in order to enhance the efficiency of the file system to support the increasing data storage requirements. Therefore there is a continuing need for an enhanced file storage approach which efficiently accesses and controls large quantities of data in a single user and multi user environment. Moreover there is a continuing need for an enhanced file format permitting access and control to large quantities of data to improve the efficient transfer and storage of large quantities of data.

In preferred embodiments of the present invention such problems are generally avoided by use of a method in a computer system for storing element chunks of elements in a storage area comprising the steps of 1 storing at least one root storage in a storage area 2 storing a model directory in the at least one root storage 3 storing at least one model in the model directory 4 storing a graphic element list and a control element list in the at least one model the graphic element list having element chunks containing graphic elements and the control element list having element chunks containing control elements 5 assigning a preselected number of elements to each element chunk and 6 allocating each element to an element chunk in one of the control element list and the graphic element list.

According to a second embodiment of the present invention a method in a computer system for storing element chunks of elements in a storage area comprises the steps of 1 storing at least one root storage in a storage area 2 storing at least one model directory in each root storage 3 storing a control model in each root storage 4 storing at least one model in the model directory 5 storing a graphic element list and a control element list in each model and each control model directory the graphic element list having element chunks containing graphic elements and the control element list having element chunks containing control elements 6 assigning a preselected number of elements to each element chunk and 7 allocating each element to an element chunk in one of the control element list and the graphic element list.

A method in a computer system for modifying at least one compressed element chunk in a main storage area in accordance with a third embodiment of the present invention comprises the steps of 1 storing at least one root storage in the main storage area 2 storing a model directory in the at least one root storage 3 storing at least one model including a graphic element list and a control element list in each model directory 4 storing at least one compressed element chunk in each graphic element list and control element list wherein each the compressed element chunk comprises compressed elements 5 storing the at least one root storage in a temporary memory 6 decompressing the compressed element chunks and compressed elements in the graphic element list and the control element list 7 modifying elements in the temporary memory 8 flagging the decompressed element chunks having the modified elements in the temporary memory with a dirty flag 9 compressing the flagged element chunks to provide modified compressed element chunks after a predetermined idle time has passed and 10 replacing the compressed element chunks in the main storage area with the modified compressed element chunks.

According to a fourth embodiment of the present invention a method in a computer system for modifying at least one encrypted element chunk stored in a main storage area comprises the steps of 1 storing at least one root storage in the main storage area 2 storing a model directory in each root storage 3 storing at least one model including a graphic element list and a control element list in each model directory 4 storing at least one encrypted element chunk in each graphic element list and control element list wherein each element chunk comprises compressed elements 5 storing the at least one root storage in a temporary memory 6 decrypting the element chunks and the elements in the graphic element list and control element list 7 modifying elements in the temporary memory 8 flagging the element chunks having the modified elements in the temporary memory with a dirty flag 9 encrypting the element chunks having the modified elements in temporary memory to provide modified encrypted element chunks after a predetermined idle time has passed and 10 replacing the encrypted element chunks in the main storage area with the modified encrypted element chunks.

A method in a computer system for modifying at least one compressed encrypted element chunk in a main storage area in accordance with a fifth embodiment of the present invention comprises the steps of 1 storing at least one root storage in the main storage area 2 storing a model directory in each root storage 3 storing at least one model including a graphic element list and a control element list in each model directory 4 storing at least one compressed and encrypted element chunk in each graphic element list and control element list wherein each element chunk comprises compressed elements 5 storing the at least one root storage in a temporary memory 6 decrypting the element chunks and elements in the graphic element list and control element list 7 decompressing the element chunks and elements in the graphic element list and control element list 8 modifying elements in the temporary memory 9 flagging the element chunks having the modified elements in the temporary memory with a dirty flag 10 compressing and encrypting the element chunks having the modified elements in temporary memory to provide modified compressed encrypted element chunks after a predetermined idle time has passed and 11 replacing the compressed encrypted element chunks in the main storage area with the modified compressed encrypted element chunks.

According to a sixth embodiment of the present invention a computer system for modifying at least one compressed chunk of elements stored in a main storage area comprises a a temporary memory b a root storage stored in the main storage area and the temporary memory c a model directory stored in the root storage d at least one model stored in the model directory e at least one graphic element list stored in each model f at least one control element list stored in each model g at least one compressed element chunk stored in each graphic element list and control element list wherein each element chunk comprises compressed elements h means for decompressing the element chunks and elements in the graphic element list and control element list in the temporary memory i means for modifying elements in the temporary memory j means for lagging the element chunks having the modified elements in the temporary memory k means for compressing the element chunks having the modified elements in temporary memory to provide modified compressed element chunks after a predetermined idle time has passed and l means for replacing the compressed element chunks in the main storage area with the modified compressed element chunks.

A computer system for modifying at least one encrypted element chunk stored in a main storage area in accordance with a seventh embodiment of the present invention comprises a a temporary memory b a root storage stored in the main storage area and the temporary memory c a model directory stored in the root storage d at least one model stored in the model directory e at least one graphic element list stored in each model f at least one control element list stored in each model g at least one encrypted element chunk stored in each graphic element list and control element list wherein each element chunk comprises encrypted elements h means for decrypting the element chunks and elements in the graphic element list and control element list in the temporary memory i means for modifying elements in the temporary memory j means for flagging the element chunks having the modified elements in the temporary memory with a dirty flag k means for encrypting the element chunks having the modified elements in temporary memory to provide modified encrypted element chunks after a predetermined idle time has passed and l means for replacing the encrypted element chunks in the main storage area with the modified encrypted element chunks.

According to an eighth embodiment of the present invention a computer system for modifying at least one encrypted compressed element chunk stored in a main storage area comprises a a temporary memory b a root storage stored in the main storage area and the temporary memory c a model directory stored in the root storage d at least one model stored in the model directory e at least one graphic element list stored in each model directory f at least one control element list stored in each model directory g at least one encrypted compressed element chunk stored in each graphic element list and control element list wherein each element chunk comprises encrypted compressed elements h means for decrypting the element chunks and elements in the graphic element list and control element list in the temporary memory i means for decompressing the element chunks and elements in the graphic element list and control element list in the temporary memory j means for modifying elements in the temporary memory k means for flagging the element chunks having the modified elements in the temporary memory with dirty flags l means for compressing and encrypting the element chunks having the modified elements in temporary memory to provide modified encrypted compressed element chunks after a predetermined idle time has passed and m means for replacing the encrypted compressed element chunks in the main storage area with the modified encrypted compressed element chunks.

Other objects advantages and novel features of the present invention will become readily apparent from the following detailed description thereof when considered in conjunction with the accompanying drawings wherein 

The present invention relates to providing an enhanced file format to store large quantities of variable sized data records on a storage medium and to permit efficient access and control over data stored in the enhanced file format. A file format is the structure of a file that defines the way it is stored and laid out on a disk. In a preferred embodiment of the present invention a file format includes a model directory containing models. Models include element lists comprising element chunks. The element chunks include elements where elements are variable sized data records.

Referring now to the drawings wherein like reference characters and numerals designate like or corresponding parts throughout each of the several views there is shown in a diagram illustrating a high level exemplary network environment for handling large data files in accordance with the file system and file format of the present invention. The file format of the present invention is intended to be utilized in any network environment such as the Internet Intranet local area network etc. for any application but may also be utilized on stand alone computer workstations and or processing units. By use of the term Internet it should be understood that the foregoing is not intended to limit the present invention to a network also known as the World Wide Web.

The network is a computer system adapted to be accessed by a plurality of clients. Such clients in turn suitably comprise one or more conventional workstations wireless computing devices or other end user devices operating as a fat or a thin client. It should be understood nevertheless that wireless computing devices include computing devices such as Web enabled hand held devices such as e.g. a Palm V type devices manufactured by Palm Inc. Santa Clara Calif. U.S.A. Windows CE devices pagers and smart phones which can use a wireless access protocol Internet appliances and other computing and end user devices which operate via satellite infrared remote sensor or other means not requiring a physical connection or coupling to another computing device appliance or network also fall within the spirit and scope of the present invention.

Clients of all of the above types can suitably access the network and the main storage area through the network . The network may be directly coupled to the main storage area or the network may access the main storage area through firewall load balancer network servers load balancer and application servers . The load balancer and load balancer may be the same type of unit. These load balancers and route traffic to and from the main storage area . It is understood that the present invention is not limited to this arrangement. However the network must access a main storage area which is either internal to the network or external to the network . The main storage area is a computer readable medium.

Within files created using the file format of the present invention information is organized hierarchically utilizing a Storage and Stream approach. A Stream is a variable sized sequence of bytes that is assigned an identifier such as a name and can be saved persistently. In this respect a Stream can be analogous to a file in a disk file system. A Storage can be analogous to a file system directory it has an identifier such as a name and can contain Streams or other Storages.

In the present invention the starting point for reading or creating files is the root storage . The root storage contains other storages and streams including but not limited to those defined by the current invention. It should be obvious that since the root storage is created using well known programming interfaces other applications can create other storages and streams within a file created by the present invention without corrupting the other items in the file. However programs creating or reading files having the file format of the present invention may store one or more streams of a known format such as the following 

An important purpose of the present invention is to provide a system and method to store large sets of variable sized elements. For convenience related elements are grouped together in a model . Models may group elements for any purpose relevant to an application but are frequently intended to reflect some real world structure. It is often desirable to store multiple models in the same file. To accomplish this a storage of the root storage called the model directory is created. The model directory holds a list of models each with a unique name . Alternatively if only a single model per file is desired the model can be stored directly in the root storage without creating a model directory .

In many cases it may be necessary to designate one model as having special significance versus all other models in a file. For example certain elements may contain resources that are shared among all models in the file. In this case a specially named model is stored directly in the root storage called the control model . The control model is in the same format as all other models other than its special name and location in the root storage . When referring to the control model the term global may be placed before the terms graphic element list control element list element chunk graphic element control element etc. to indicate that the item refers to a resource which is shared among all of the models. In an alternate embodiment according to the present invention control model includes only one element stream having neither a graphic element stream nor a control element stream.

The number of models which may be stored in a model directory is only constrained by the amount of memory in the main storage area . Therefore if there was an infinite amount of memory in the main storage area then there could be an infinite number of models in the model directory .

As shown in every model contains a specially named stream called a model header stream to hold information that is specific to the model . For example the model header stream can contain the model name the units e.g. metric English the geometric range of the model etc. or any other information that may be relevant to know about the model without actually having to load the model into a memory.

Within a specific model elements can be further classified according to their meaning in the model. Each such category of elements is stored in a sub storage of the model called an element list storage . For example in CAD applications elements are often classified into two types graphic and control. Graphic elements have a physical representation that occupies geometric space and can be drawn on a computer screen or a plotter. Control elements hold information pertinent to the model but that does not on it s own have a physical representation. As shown in the graphic elements can be stored in a graphic element list and the control elements can be stored in the control element list . Further categories of elements can be stored in additional element lists .

Within an element list storage e.g. graphic element list and control element list individual elements are stored in groupings or element chunks as shown in . Each element chunk is given a unique name preferably derived from its chunk number e.g. chunk001 chunk002 etc. so that the number of such chunks can be determined merely by iterating over the names in the element list storage . Alternatively an element list header stream could be created to hold the stream names of the element chunks but that would require the element header to be updated as element chunks are added and removed.

One purpose for dividing the elements stored in an element list storage among a series of element chunks is to permit compression and encryption of the element chunks without requiring that the entire element list held in the model be rewritten when any individual element is modified. This can be particularly important in certain types of applications such as CAD applications where the element data tends to be large but sparse. In this case many well known compression algorithms can yield significant ratios of the original size of the data to the compressed size of the data. Compressing element data can be a significant factor in the performance of the applications in terms of disk space file I O requirements and network transfer times. Similarly encryption algorithms are designed to accept original data and create encrypted data. However in many applications such as CAD applications small subsets of elements can be modified frequently and must be written to the disk often both for reliability concerns and for real time sharing of element data with other users on a network. In this case it would be impractical and unacceptable to have to re compress re encrypt and rewrite an entire element list every time any element changes.

Several approaches can be used to determine how to sub divide an element list into a series of element chunks . One approach is to fill element chunks with elements until the chunk size reaches a pre determined limit. This will tend to make the pre compressed size of each element chunk approximately the same. In the preferred embodiment of the present invention the size of an element chunk is determined by choosing a fixed number of elements. This approach makes the maintenance of element chunks straightforward. However certain applications may require that certain groups of elements be considered atomic and be stored and retrieved as a single unit. In this case the entire group should preferably be stored in a single element chunk . For example in a CAD application where the size of an element varies but tends to approximate 100 200 bytes a chunk size of 1000 elements has been demonstrated to work well. As should be obvious the number of elements in any given element chunk within an element list need not be the same as all other element chunks in the same element list . This can often be the case either due to application grouping of elements that must all reside in the same element chunk or due to element deletions after their original insertion into an element chunk .

Each element chunk preferably has a fixed header element chunk header that can contain information necessary to read the elements from the chunk into memory. For example the fixed header should contain the number of elements in the element chunk so that value can be known before reading the element data from the element chunk . The fixed header can also contain additional information such as the compression and encryption scheme used for the element data in the case where it is desirable to allow such compression and encryption scheme to vary from element chunk to element chunk within an element list .

In each element chunk immediately following the fixed header at the offset equal to the size of the fixed header is the element data . Depending on the values of the compression and encryption flags in the fixed header the element data can be either in raw uncompressed and unencrypted form or in compressed and or encrypted form.

As shown in each model preferably contains at least one element list . However each model is not required to contain an element list . For example each model may contain a graphic element list and a control element list . Each element chunk contains a predetermined or preselected number of elements wherein the actual number of elements in each element chunk does not have to be the same as discussed previously . The preselected number can be a maximum number of elements. As each element associated with a file format is created each element is allocated to an element chunk in an element list . Subsequently the element chunk is preferably compressed . However compression is not necessary . Each compressed element chunk may also be encrypted . However encryption is not necessary . Subsequently the element chunk is stored in the storage area . The element chunk stored in the storage area may or may not be encrypted compressed or both encrypted and compressed . If additional elements require storage then steps are repeated until all of the elements are allocated to element chunks and the element chunks are stored in the storage area.

Alternatively shows a block diagram for automatically storing element chunks having modified elements in accordance with another embodiment of the present invention steps . The process begins by accessing a file having a file format of the present invention in a storage area such as main storage area and storing the file in temporary memory . The temporary memory is preferably located in a workstation . A user who is granted permission to edit the contents of the file in temporary memory modifies the elements in the temporary memory . Each time a user modifies an element a dirty flag is set to indicate the element chunk containing the element that has been modified. If there is a period of idle use during which time the user has not made additional changes to the elements the computer network determines whether any dirty flags have been set. If a modification has been made the computer network identifies all of the element chunks containing modified elements . The modified element chunks containing the modified elements are encrypted and stored in the main storage area by overwriting the unmodified element chunk in the storage area .

Alternatively shows a block diagram for storing element chunks having modified elements in accordance with another embodiment of the present invention steps . In this embodiment the element data are encrypted and compressed in the main storage area . Therefore in order to access a file from the main storage area and store the file in the temporary memory the element data must be decrypted and decompressed . The compression operation preferably precedes the encryption operation. However these operations may be reversed .

Regardless of how the second user is notified of modifications of elements in element chunks in models of model directories in a file the second user requests by way of the second workstation the modified element chunks . The modified element chunks are accessed based on the request from the second workstation and the modified element chunks are decompressed by the second workstation. The modified elements are viewed on the second workstation . Alternatively if the modified element chunks are encrypted instead of compressed the modified element chunks are decrypted by the second workstation as shown in so that they be viewed on the second workstation .

Regardless of how the second user is notified of modifications to elements in element chunks of element lists the second user requests by way of the second workstation the modified element chunks . The modified element chunks are accessed based on the request from the second workstation and the modified element chunks are decrypted and or decompressed by the second workstation . The modified streams are viewed on the second workstation .

While the invention has been described in detail with reference to specific and preferred embodiments it will be appreciated that various modifications and variations will be apparent to the artisan. All such modifications and embodiments as may occur to one skilled in the art are intended to be within the scope of the appended claims.

