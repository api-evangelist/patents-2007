---

title: Peer-to-portal media broadcasting
abstract: A system for peer-to-portal broadcasting, including a portal web server serving a portal web page that includes source code received from and generated by a broadcast server, to a web browser, in response to a request received from the web browser, a broadcast server, including a source code generator for generating the source code that is included in the portal web page, in response to a request received from the portal web server, a web client computer for requesting the portal web page from the portal web server and for executing the source code included in the portal web page, and a publisher computer that enables a publisher to broadcast media files from the publisher computer to the web client computer via the broadcast server, in response to the web client computer executing the source code included in the portal web page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370732&OS=08370732&RS=08370732
owner: Mixpo Portfolio Broadcasting, Inc.
number: 08370732
owner_city: Seattle
owner_country: US
publication_date: 20070228
---
The present application is a continuation in part of assignee s pending application U.S. Ser. No. 11 584 405 now U.S. Pat. No. 7 827 298 filed on Oct. 20 2006 entitled Peer to Web Broadcasting which is hereby incorporated by reference in its entirety.

Traditionally two architectures have been introduced to enable publishing or broadcasting video content referred to as video clips over the worldwide web namely a server based architecture and a peer to peer architecture.

The server based architecture requires that a creator of a video clip referred to as a content owner upload his video clip to an Internet server. The Internet server maintains a directory of content and allows users to view the content and download or stream the content. The disadvantages of this approach are 1 it is time consuming to upload large video files and 2 the content owner must maintain his content on his own computer system and also on the Internet server which is cumbersome. To speed up the upload process the content owner generally reduces the size and quality of the video clips that are broadcast. Video normally seen in full screen size when played locally from the owner s hard drive becomes confined to small windows one fifth the size of the original when streamed from a remote server over the Internet.

The peer to peer P2P computing architecture which relies less upon dedicated servers provides an alternative approach. Peer to peer computing involves sharing of computer resources and services through direct communication between peer computer systems. Conventional P2P computing enables peer computers to exchange files and to communicate directly between one another. As such a peer computer may act as a client device or a server device depending on the computing process and the needs of the network of peer computers.

The peer to peer architecture was initially introduced to enable interactive person to person communication on the Internet. Early Internet Relay Chat IRC systems enabled people all over the world to participate in real time text based conversations. Using an IRC client a user can exchange text messages interactively with other users. When logged into a chat session a user converses by typing messages that are instantly sent to other chat participants. In recent years instant messaging IM systems such as AOL s Instant Messenger Microsoft s MSN Instant Messenger and Yahoo s Pager have added the capability to transmit files including video sound and image rich media files between peer computers. However transmitting rich media files using IRC or IM systems has the disadvantage that the entire media file must be transmitted which is cumbersome for the content owner and the disadvantage that the content owner loses control over his media.

Some recent popular forms of P2P computing include the file sharing services provided by Napster Gnutella Freenet and Groove. These file sharing services allow peer computers to identify and share data files with other peer computers over the Internet. Napster for example utilizes a centralized directory service that is provided on one or more dedicated server computers connected to the Internet. To search for and discover a file such as an MP3 song to download from another peer computer a Napster client queries the dedicated server computers and central directory therein which responds with a list of other Napster configured peer computers that have the requested file. The requesting Napster client then connects directly with one of the identified other peer computers to access and download the requested file. The other peer computer acts as a server to support the downloading process. A disadvantage of this approach is that the Napster server may not have up to date information about the Napster clients and thus some content may be unavailable or out of date. Another disadvantage is that the central directory may indicate that certain content is available from a peer but that peer may not be online and so a requesting peer would not be able to make a connection.

Unlike Napster Gnutella does not rely on a centralized directory service and thus does not require dedicated server devices. Instead files are discovered by having peer computers directly communicate and pass queries from peer computers to other neighboring peer computers. Upon receiving a query a Gnutella peer computer may for example decide to do nothing respond back to the requesting peer computer such as by notifying the requester that the requested file has been found or forward the query on to one or more other peer computers thus widening the search for a given file. If the requested file is available for access and downloading from at least one of the other peer computers then the requesting Gnutella peer computer acting as a client device connects to that peer computer and begins accessing and downloading the requested file. Here again the other peer computer acts as a server during the accessing or downloading process.

A general disadvantage of peer to peer file sharing is that if a client receives several requests simultaneously then these requests compete for the relatively limited resources of bandwidth and disk access. Therefore either the system degrades with each additional simultaneous requester or the receiving client must refuse service to additional requestors. By contrast with server based approaches the provider of the service can add additional servers and load balance among them and they can store multiple copies and cache often requested media.

Disadvantageously most P2P file sharing services require a user to download an entire file. Although the downloading of a file gives a user certain advantages the transfer of the file and subsequent viewing and or listening can be undesirable from the perspective of a content owner. The relative ease with which a copy of a file can be obtained can lead to copyright violation. Further the transfer of files can be in non real time which permits a user to transfer a substantial quantity of data from other users in a short period of time. This can undesirably occupy a large amount of network bandwidth for both the user who is copying the files and the users who are providing the files.

Music and video streaming was introduced to eliminate the disadvantages associated with downloading or uploading rich media files. Streaming enables a user to view a video clip as it is being received on their computer without having to wait for the video file to be received in its entirety before playback can begin and without saving a copy of the video file.

Thus it would be of advantage to have a service that streams music and video does not require that a content owner upload his media files to a server provides up to date information about available media clips caches often requested media files on a server computer and does not require special media playing software to view streamed videos music and images.

The subject invention concerns a third architecture for video broadcasting namely a peer to web broadcasting architecture. Using the subject invention a user of a client peer computer can broadcast his media from his computer over the web. The user s media can be viewed within conventional web browsers that use conventional media players such as a Windows Media Player or a Macromedia Flash player control. Such media players are generally available on most platforms and web browsers. As such the subject invention does not require additional viewing software. The broadcaster also referred to as a publisher can organize his media into multiple broadcast channels which viewers can then select from for viewing.

The subject invention overcomes drawbacks of conventional video broadcasting technology that uses a central server. Using the subject invention an owner of video clips has complete control over the broadcast of his clips and the people who have viewing privileges. No upload to a central hosting server is required. No coordination of instructions with a hosting server is required. No time is wasted uploading videos to a central server. The subject invention does not copy source files or upload source files to a central server. Media is prepared on a local client computer for web delivery and original video clips are protected against copyright piracy.

The subject invention is particularly advantageous for independent filmmakers artists and musicians who can use peer to web broadcasting to show their media to potential employers licensees and other such business leads. Broadcasters can set their broadcast channels as public in which case they can be searched and found by the general public. Alternatively broadcasters can set their broadcast channels as unlisted in which case they can be viewed by invitation only.

The subject invention is also particularly advantageous for consumers who wish to share their personal recorded video clips with friends and family. The invention enables them to establish private channels.

The subject invention also enables peer to portal broadcasting where publishers can broadcast their media to a third party portal for viewing by a general portal audience. The broadcast media appears to the audience as if it is being sourced from the portal s web server whereas in fact it is being sourced from the publishers peer computers.

There is thus provided in accordance with an embodiment of the subject invention a method for peer to portal broadcasting including providing a web page for a portal the web page including an inline frame iFrame receiving meta data for media files selected by a user for broadcast to the portal and dynamically generating source code for the iFrame upon request the source code including instructions for a web browser i to request an XML document that includes meta data for user selected media files ii to transform the XML document to an HTML document using an XSLT transformation and iii to insert the resulting HTML document into the web page for the portal.

There is further provided in accordance with an embodiment of the subject invention a system a system for peer to portal broadcasting including a portal web server for a web portal the portal web server storing a web page for a portal the portal web page including an inline frame iFrame with a source originating at a broadcast server a publisher computer communicatively coupled with the portal web server including a broadcast tool that enables a publisher to broadcast media files from the publisher computer to the web portal a broadcast server communicatively coupled with the portal web server and with the publisher computer including an iFrame source generator for generating source code for the iFrame included in the portal web page the source code instructing a web browser to transform at least one XML data container document for broadcast media files into at least one HTML page that assembles a plurality of web objects and an XML document generator for generating XML data container documents for broadcast media files and a web client computer communicatively coupled with the portal web server including a web browser including a dynamic web page generator and assembler for executing the iFrame source code generated by the broadcast server.

There is yet further provided in accordance with an embodiment of the subject invention a computer readable storage medium storing program code for causing a computing device to provide a web page for a portal the web page including an inline frame iFrame to receive meta data for media files selected by a user for broadcast to the portal and to dynamically generate source code for the iFrame upon request the source code including function calls i to request an XML document that includes meta data for user selected media files ii to transform the XML document to an HTML document using an XSLT transformation and iii to insert the resulting HTML document into the web page for the portal.

There is moreover provided in accordance with an embodiment of the subject invention a broadcaster for publishing media content including a video transcoder for transcoding video content from a source format to a target format at at least one target bit rate an image processor communicatively coupled with the video transcoder for generating at least one thumbnail image representation of the video content a database manager for managing a table of broadcast channels a table of media files within channels and a table of cached media files a command sequencer communicatively coupled with the video transcoder the image processor and the database manager for queuing and sequencing commands issued to the video transcoder the image processor and the database manager and a network engine for sending the video content to a proxy server for streamed delivery to at least one web client on demand.

The subject invention concerns peer to web broadcasting. Using the subject invention a publisher can broadcast his media to the web from his peer computer without uploading the media to a central server. As such the publisher retains complete control over his media assets and who is able to view them.

Reference is now made to which is a simplified block diagram of a peer to broadcast system in accordance with an embodiment of the subject invention. Shown in is a broadcasting system that enables peer computers referred to as publishers to broadcast their media over the web. The publishers stores their media and web clients can view the broadcast media using conventional web browsers without requiring additional client software. The broadcast media can be live video pre recorded video music pictures presentations slideshows and other forms of media.

Media can be published on a mobile phone a video camera a wireless device a home computer and other such computing devices. Published media can be viewed on a television a mobile phone a portable player a home computer and other such computing devices that run a web browser.

The present invention is readily implemented within the Asynchronous JavaScript and XML AJAX architecture used for dynamic HTML generation.

Reference is now made to which shows a sample web page for viewing media on a web client computer the media being broadcast from a peer computer in accordance with an embodiment of the subject invention. As can be seen in web page is displayed by a conventional web browser such as Microsoft s Internet Explorer browser.

Shown in the upper left of web page is a list of broadcast channels each channel corresponding to a set of media related by a common theme that is generally the name of the channel. Channel is named Best Videos and is currently the channel being displayed in web page . Channel is named Music and channel is named Staff Pics . To the right of the list of channels is the set of media for the currently selected channel. Each piece of media is represented by a thumbnail which is a small image that designates the media. Thus thumbnails and correspond to videos from the Best Videos channel. By clicking on one of these thumbnails a user can view the selected video within his web browser. The thumbnail images and the corresponding videos are generally stored on a peer computer of the publisher who created the channels.

Reference is now made to which shows a sample video viewing area overlaid on a sample web page in accordance with an embodiment of the subject invention. When a user clicks on one of the video icons such as icons or of the corresponding video is streamed to the user and played within a viewing area . Viewing area includes typical video controls for play pause stop fast forward fast reverse and volume control.

Generally the web page for viewing published media is assembled from multiple sources including inter alia 

A first source denoted by is local broadcast content. A local host server denoted by is treated as part of the domain for system by including a DNS entry for localhost.pixpo.com which is mapped to 127.0.0.1 where pixpo is a web server name for system . It will be appreciated by those skilled in the art that effectively this DNS entry enables an Internet browser to treat the local host server as part of the domain for system . This is significant since web browser security policies generally require that dynamic content such as iFrames and scripts have a single domain of origin. The DNS entry thus enables web pages to be assembled from both local and remote endpoints without violating security policies enforced by the browser.

It will thus be appreciated by those skilled in the art that the subject invention bridges multiple domain hosts to a single domain and facilitates communication between a local host and main page data through JavaScript. The subject invention enables access to information from any IP address via a sub domain of an origin server. For example if an HTML page is sent from www.mixpo.com then that HTML page via the subject invention s JavaScript bridge can access any .mixpo.com URL. Thus a DNS entry for amazon.mixpo.com can be mapped so that it resolves to Amazon s search API servers. JavaScript on a www.mixpo.com HTML page can then make remote data requests to Amazon s servers directly. Generally such multiple calls to services from multiple domains are blocked by a browser s single origin security policy. Using the subject invention however a browser makes multiple connections to multiple services because of the JavaScript bridge which maps an external domain such as amazon.com to an internal domain such as amazon.mixpo.com. The browser then allows these connections even though they connect to external domains.

In distinction prior art technology such as Google s IG pages assembles multiple components into a page by assembling the page completely on central servers before sending it to a browser.

A second source denoted by is content from a broadcasting system . A third source denoted by A B and C is content from multiple remote broadcasters John George and Ringo desktop computers or other computing devices. The third source also includes data content D.

Shown at the bottom right of is a web page denoted by for a broadcaster. Web page also includes components assembled from multiple sources. A first source denoted by is local broadcast content. A second source denoted by is content from broadcasting system .

As shown in source for local content uses a Representational State Transfer REST application programming interface API for communicating with web page A and web page . Information about REST is available on the Internet at http en.wikipedia.org wiki Representational State Transfer.

Reference is now made to which shows a sample web page for publishing media on a peer computer for web broadcast in accordance with an embodiment of the subject invention. Web page enables a publisher to create broadcast channels such as the channels listed in and to populate the channels with his media. As shown in a publisher has created a new channel temporarily named New Channel and an explorer type window enables the publisher to select media files from his file system to broadcast within the new channel. Channels can be designated as public in which case they are made publicly available or as unlisted in which case they are only made available to friends that the publisher invites to see his media.

In accordance with an embodiment of the subject invention information about publishers and their broadcast channels is stored in a central database which can be queried by web clients in order to conduct searches for content.

Reference is now made to which is a simplified block diagram of a two tier communication system for publishing media within the peer to broadcast system of in accordance with an embodiment of the subject invention. As described hereinabove with respect to the peer to broadcast system enables HTTP web clients and to view channels of media content broadcast by publishers and .

The system shown in includes two tiers of servers namely a first tier of reverse proxy servers and and a second tier of switchboard servers and . Each server has its own local cache and caches responses generally in accordance with the HTTP standard which enable it to serve many clients while making only a small number of requests to another server.

When a publisher logs on to a switchboard server the switchboard server writes a file to a master Andrew File System AFS directory. The file is named according to the username of the publisher and the file contains the switchboard server s host name. Reverse proxy servers search the AFS directory for that file to determine which switchboard server to contact for a designated publisher. It will be appreciated by those skilled in the art that the AFS directory is essentially being used here as a database. Because multiple switchboard servers are able to write to the same file cooperative locking is used. It will further be appreciated by those skilled in the art that the subject invention may use an actual database instead of a master AFS directory for this purpose of maintaining a switchboard directory.

A distinction between the first tier servers and the second tier servers lies in the request to the next server. Specifically the first tier reverse proxy servers extract a username from an HTTP request and search the master directory for a file with that name. The file contains the name of a switchboard server. The second tier switchboard servers extract a username from an HTTP request find a connected publisher with that username and forward a request to the connected publisher. If a switchboard server receives a request for a publisher who is not connected the switchboard server returns a 503 HTTP response code. JavaScript in the web client browser receives this response and handles it appropriately e.g. redirecting to a user not connected page.

Each proxy server accepts regular HTTP connections on port 80 and forwards HTTP requests to an upstream server. The origin server is a publisher computer which returns either data or an error code.

As shown in each server has its own local cache. Cached items are indexed by URL and each item has an expiration time and a cache validator. The cache validator is a last modified date or an opaque identifier string set by the origin server. If the URL is requested before it expires its cached item is served right away from cache. Otherwise if the URL has expired a conditional request is made to the next server i.e. to the switchboard server or to the origin server. The conditional request sends the cache validator to the next server. In turn the next server uses the validator to determine whether the cached item for the URL is current. If the cached item is current the next server returns an HTTP validation code such as 304 Not Modified. Otherwise if the cached data for the URL is not current then the next server sends the updated data with an appropriate HTTP code such as 200 OK.

In accordance with an embodiment of the subject invention the servers aggregate requests. When a server receives three client requests for the same file the file is fetched from the next server once and served to all three clients. Aggregation occurs at each tier. Thus the reverse proxy servers aggregate many web clients and the switchboard servers aggregate many reverse proxy servers. A proxy server does not invoke a second request for a specific URL while it is receiving a response for that URL. Instead it adds a new client to the response being received. This mechanism protects publishers from receiving an excessive number of requests.

The servers are indifferent as to content type. All requests are processed through the aggregation and caching mechanisms and all responses are treated as data streams. HTTP supports keep alive connections and reuses connections for different web clients.

A system server is used i to authenticate publishers ii to manage the database of publishers their broadcast channels and their channel media content and iii to serve up web content such as HTML XML and static graphic assets to web clients and publishers such as the web pages illustrated in hereinabove. The video streams themselves are transmitted via the two tiers and . Thus referring to the content in web pages and and the broadcast channel information is transmitted from server to web clients and and the video stream that is played in viewing area is transmitted from the two tiers and .

It will thus be appreciated by those skilled in the art that web page synthesizes live content static assets and hosted content in the same context. Specifically content data via XML documents and media objects are transmitted to web clients and and in turn the web clients transform and assemble the content based on template pages served by server . Transformations and page display are performed using XSLT JavaScript and HTML code as described hereinbelow in SOURCE CODE III V. The subject invention s web page assembly technology enables displaying live content from multiple remote sources into a single web page. Multiple publisher content is assembled and presented in what appears to a user as a single coherent entity whereas in fact it is a composite entity built from multiple live broadcast sources.

It will also be appreciated by those skilled in the art that the architecture of enables broadcast of multiple media streams from a single peer source i.e. one to many broadcast from a single peer machine to multiple simultaneous viewers.

Reverse proxy servers and enable connections to publishers with dynamically assigned IP addresses. Specifically these servers enable broadcasters to be connected to web clients using browsers that point to standard URLs. For example if a publisher broadcasts from his home computer that has an internal IP address of 192.168.1.100 and a dynamically assigned IP address of 24.66.77.88 then HTTP servers enable the publisher to appear as http liveweb.pixpo.com john and to serve content to a standard web client. The publisher does not have to run an HTTP server and does not have to create a port for forwarding configurations for his NAT devices.

In accordance with an embodiment of the subject invention reverse proxy servers and operate as a cluster with automatic dynamic failover in the event of a proxy failure. Reverse proxy servers and run their proxies as a service. Proxy services have configurable options including inter alia the options listed in TABLE I.

Firewalls and NAT routers are used in over 50 of home broadband users today. Nearly all firewalls and NAT routers block unsolicited inbound network traffic which creates an obstacle for systems that involve peers on the Internet. One solution to overcoming this obstacle uses an intermediate Internet host to proxy network traffic. Firewalls and NAT routers generally block inbound traffic but outbound traffic is allowed. Since TCP IP is bi directional once a peer computer behind a firewall or NAT router establishes a connection to another host that host can then send data back to the peer through the TCP IP connection. Switchboard servers and function as intermediate hosts.

Switchboard servers and maintain connection tables with records of connections between HTTP web clients and publishers.

A load balancing algorithm based on least loaded switchboard is used to designate a switchboard server for each publisher. As such generally any given publisher can connect to any switchboard server.

The architecture in does not rely on a thread per connection approach for publishers and . It has been found that a low commodity switchboard server can handle up to 20 000 simultaneous connections.

Switchboard servers and run their switchboards as a service. Switchboard services have configurable options including inter alia the options listed in TABLE II.

Use of cache within the subject invention provides many advantages including improved quality of service for web clients and decreased load on publisher computers. In accordance with an embodiment of the subject invention cache is a large Andrew File System AFS volume which all servers have access to although it may be appreciated by those skilled in the art that other cache volumes may be used instead. It has been found that a cache size of 200 GB suffices to hold several weeks worth of data.

As shown in each switchboard server and reverse proxy server features its own local cache. These caches reduce the amount of forwarded network requests necessary and also support streaming incomplete portions of media files. In addition the system includes the larger global cache which stores complete media files. Switchboard servers and write to cache and reverse proxy servers and read from cache .

In accordance with an embodiment of the subject invention when a switchboard server receives a complete media file it copies the media file to cache asynchronously from the HTTP request from the reverse proxy server. Cache stores completely received media items from all switchboard servers. In general dynamically generated items are not stored in cache . Whether a file is dynamic or static is determined by the HTTP compliant cache policy specified by the response from a publisher. Cache stores complete media items and generally is not used for streaming.

In accordance with an embodiment of the subject invention cache is a size limited file system based most recently used MRU cache. Each item of content in the cache has a last used timestamp. When a new data item is pulled from a publisher it is added to the cache. When a requested item is found in the cache the requested item is promoted to the top of the cache by resetting its last used timestamp to the current time.

Further in accordance with an embodiment of the subject invention a cache utility program monitors the space occupied by contents of cache . The cache utility program accepts as parameters a path to a cache directory and a pre specified size. If the space occupied by the cache contents exceeds the pre specified size the cache utility program deletes least recently accessed items until the occupied space is sufficiently reduced. The cache utility program may be scheduled to run on a timer such as once every minutes.

Reference is now made to which is a simplified flow chart of a sequence of events within a peer to broadcast system in accordance with an embodiment of the subject invention. The flowchart of is divided into three columns. The leftmost column includes steps performed by a web client computer such as web client or the middle column includes steps performed by a caching web proxy such as HTTP server or and the rightmost column includes steps performed by a publisher computer such as publisher or .

At step the publisher requests to log on to an application server using HTTPS XML messaging and the publisher is directed to a switchboard proxy server such as switchboard server and . At step the publisher logs into the appropriate switchboard server and registers an endpoint such as username .

At step a web client requests a publisher URL such as http live.pixpo.com username . At step the caching web proxy receives the request and checks its cache for the requested media item. If it is determined at step that the media item is present in the cache then at step the item is delivered to the web client from the cache and at step the web client receives the data it requested. Otherwise if it is determined at step that the media item is not present in the cache then a determination is made at step whether or not the publisher is currently connected.

If the publisher is not connected then at step the caching web proxy returns a not found error and at step the web client receives the error message instead of the requested data. If the publisher is connected then at step the caching web proxy proxies the request to the publisher. At step the publisher receives the request from the caching web proxy and at step the publisher streams a response back to the caching web proxy.

At step the caching web proxy writes the response received from the publisher into its cache and at step the caching web proxy sends the response back to the web client. Finally at step the web client receives from the caching web proxy the data it requested.

In accordance with an embodiment of the subject invention cached partially streamed files can be accessed from cache. I.e. a file does not have to be streamed to completion in cache and stored in its entirety as a file before it can be accessed from cache. If a viewer A starts watching a broadcast from publisher B the proxy server begins streaming content to viewer A and caching it to file. If viewer C then starts watching the same content from publisher B the proxy server detects this condition and begins streaming content to viewer C from the partially completed stream in the cache. It will be appreciated that this mechanism enables a multi cast from a single source broadcast to a plurality of viewers.

Referring back to load balancer forwards requests to HTTP servers and based on a segmenting algorithm.

Server is responsible for orchestrating the entire delivery of static and live content from publisher to web client. Application server is responsible for authenticating publisher logins. Web server is responsible for transmitting HTML pages to publishers and and to web clients and . Database management system is responsible for managing a database that stores publisher broadcast channels channel meta data and the meta data for individual files published within those channels.

Reference is now made to which is a simplified block diagram of a publisher system for publishing media within the peer to broadcast system of in accordance with an embodiment of the subject invention. System generally resides on publisher computers and although in an alternate embodiment system may reside within web application . As shown in publisher system includes a video transcoder for generating bit rate targeted data streams an image processor a network engine a database manager and a widget engine . These components are described in detail hereinbelow.

In accordance with an embodiment of the subject invention components are accessed via an application programming interface API . One such API is a Representational State Transfer REST interface. Information about REST is available on the Internet at http en.wikipedia.org wiki Representational State Transfer. It will be appreciated by those skilled in the art that other APIs may also be used to interface components .

Video transcoder includes a transcoder that generates bit rate targeted data streams in one or more formats including inter alia Microsoft Advanced Streaming Format WMV Macromedia Flash VP6 FLV and DivX Networks v5.x AVI . Video transcoder transcodes any source video which can be viewed on the publisher s computer from a source format to a target format. Since the target format is generally chosen to be a format with ubiquitous implementations on all viewing platforms viewers can play the video without the need to download additional decoders on their computers. Thus a typical viewer using a web browser is able to view video for which he has no local decoder.

Further and in conjunction with database manager the transcoding engine is able to generate multiple forms of an original source video stream e.g. multiple bit rate target forms of the video can be produced and stored as individual files on the local file system with the quality size and bit rate targets and other parameters being stored in the database. This allows the viewing component to request and select an appropriate bit rate target. It also allows the system to create clips from source video e.g. the original source may an hour long video at high definition but following processing by video transcoder can exist i as a short three minute sample clip at a quality and resolution suitable for delivery to a mobile phone and ii as a full length but lower quality and resolution version suitable for delivery to a web browser across the Internet.

Video transcoder generally operates within an environment where multiple simultaneous and asynchronous requests may occur e.g. requests from image processor for still image representations of a video stream. As such video transcoder relies on the command queue mechanism and dynamic thread pool mechanism provided by widget engine which is used across all components to sequence and manage the processing of asynchronous demands that are typical in a network environment where multiple viewers may be connected to a single broadcaster.

Image processor includes graphic effects such as alpha channels for transparency gradients and shadows. Image processor also includes decoders for conventional image formats including the recently established RAW camera format.

Image processor interacts with video transcoder whereby video transcoder can be requested to seek to and render one or more still image frames from a video stream. These still frames can then be further manipulated by image processor e.g. to provide small size thumbnail representations of the video. In addition multiple frames extracted from relative time offsets in the video can be assembled into a multi frame preview image similar to a contact sheet view of the video. These thumbnails and multi frame views can be used as user interface elements to present video content in static image formats allowing a viewer to select which video he wants to view. Image processor also cooperates with database manager . Similar to the multiple representations of a video stream described hereinabove image processor can produce multiple representations of a still image in varying degrees of size and quality where the representations are stored in a file pool on the disk and are tracked via database manager .

Image processor generally operates within an environment where multiple simultaneous and asynchronous requests such as requests to image processor for still thumbnail representations of multiple files in a channel are possible. As such image processor relies on the command queue mechanism and dynamic thread pool mechanism provided by widget engine which is used across all components to sequence and manage the processing of asynchronous demands typical in a network environment where multiple viewers may be connected to a single broadcaster.

Network engine includes messaging engines for client to client and client to server connections. Network engine provides bi directional communication for sending and responding to messages from broadcaster client engines to a server and from the server to the broadcaster client engines.

It will be appreciated by those skilled in the art that in a network where i there are multiple viewing clients each of whom may be viewing different channels and or requesting different video streams from a single publisher and ii at the same time the publisher may be actively updating the contents of his broadcast coupled with the fact that some operations are more time consuming than others the goal of achieving a perception that the publisher is performing those multiple operations in a non blocking way i.e. both viewer A and viewer B can request the contents of different channels at exactly the same moment in time and neither should perceive that they are waiting for the other s operation to complete requires a mechanism that efficiently queues incoming network requests and at the same time fits those queued requests into other activities which may materially affect the result of those requests. Network engine relies on specific technologies provided by widget engine that provide multiple simultaneous connections for inbound and outbound messages while placing them in a context where the result of one inbound message may affect the result of the next message.

As an example a broadcaster may be updating a channel with new content while multiple viewers are actively browsing the contents of different channels including the one being updated. The broadcaster s activities affect the database as new content is added as well as invoke video transcoder and image processor when thumbnails and bit rate targeted streams are generated in preparation for subsequent broadcast. Requests from viewers for channel content must be responded to which may require processing by database manager transcoder and image processor . Multiple viewers will establish multiple asynchronous connections with network engine and data e.g. textual content like channel information and meta data or video streams will be streamed by network engine to requesting viewers. Moreover those viewers requesting information about the newly created channel must get up to date information which means that network engine must cooperate with database manager transcoder and image processor command request queue managers. Thus while there may be multiple simultaneous connections held open on a particular publisher each of those connections may result in one or more commands being queued to the database transcoder or imaging command queues.

Database manager includes an implementation of SQL. Database manager also includes a command generator and sequencer. Database manager is the core of the data management system for the publisher client. The database manages several key tables including inter alia channel tables files in channel tables and cache tables. In general all persistent data for a publisher is stored in the database and the database also exists in a context where there are multiple layers of volatile and non volatile caching.

Database manager satisfies two requirements of the overall system design namely i that requests and events throughout the publisher ecosystem are effectively simultaneous and asynchronous and ii that requests must at times be handled in strict sequence. For example a broadcaster may be updating a channel at the same time the channel content is being viewed by multiple viewers. The broadcaster s activities change the database including inter alia the channels table and the files in channel table. At the same time a viewer s activities may cause requests for thumbnails in the channel in turn invoking image processor for content not yet decoded which in turn results in a request for a video frame transcode which in turn results in a database update for the newly produced thumbnail all of which must be correctly sequenced yet fit into a framework where a second viewer s request for the same thumbnails will deliver them from the cache and or database layers where the in memory cache itself is unpredictably volatile.

In order to accomplish this degree of simultaneous transaction handling in an on demand just in time environment database manager relies on the command queue mechanism and dynamic thread pool mechanism provided by widget engine which is used across all components to sequence and manage the processing of asynchronous demands typical in a network environment where multiple viewers may be connected to a single broadcaster causing multiple and simultaneous asynchronous read write commands to the database. Each write for example may be a multiple faceted operation as when a channel is updated with new files causing several tables to be updated while still allowing multiple reads to be simultaneously in progress. This requires multiple threads and command queues to manage those threads in order to achieve dynamic responsiveness required of the database in an environment subject to multiple simultaneous transaction requests. Conventional native transaction handling found in database implementations is insufficient for this.

Widget engine supports widget layers such as vectors strings and maps. Widget engine also includes MAPI support. Optionally widget engine may also include support for third party widgets. Widget engine includes two components i a dynamic thread pool management sub system and ii generic command queue processors.

In accordance with an embodiment of the subject invention multiple thread pool managers are created. Threads are pooled so that they can be re used without the processor overhead that typically results from thread setup and tear down. However in order to avoid proliferation of too many threads which also results in processor overhead each pool has a preset upper limit of running threads. A request for a thread to perform an operation will either be allocated to a dormant thread from the pool or if all of the threads in the pool are currently active be queued for later processing when one of the currently active threads is released. Threads are also subject to time based automatic destruction. Specifically threads which have been dormant for a preset length of time will exit releasing system resources used by the thread.

Thread pools are used in the creation of command processing queues. A command queue is a series of generic commands which are executed in sequence under control of a thread which in turn is managed by a thread pool manager. In order to enable multiple simultaneous event handling across multiple components which may need each other as resources command queues are used to sequence transactions for all contexts while still allowing multiple non blocking event handling to exist across components.

For example a request for a thumbnail representation of a video frame may be the result of an inbound message from network engine . Network engine has multiple threads from a managed thread pool available for handling inbound message requests. If one of those requests is for a video stream network engine will queue a request command for the stream location to database manager and the thread for that command will be blocked until the database command processing queue processes that command.

At the same time network engine may receive a request for a thumbnail and will queue a get thumbnail command to the imaging processor queue. Another thread from another pool manages the sequential execution of requests to image processor . This second thread will also be blocked waiting for the thumbnail to be returned. In the meantime the database command queue will receive execution priority retrieve the file location of the requested video stream and the command will complete. The network thread for that connection will then unblock and start streaming the requested video. The image processor queue may then receive execution priority and the thumbnail request command will execute. As a result of this execution the video transcoder thread may be activated and once it returns an extracted thumbnail image processor will queue a store command for the database command thread to store the thumbnail but since the thumbnail will be returned from in memory cache image processor can immediately return the requested thumbnail without first waiting for the database command to complete. However a subsequent request for the same thumbnail from the database will of necessity be queued behind the first store command. When the thread managing the database command queue executes it will do so in the queued order and thus the store and retrieve commands will be executed in the correct sequence while still allowing the initial request to be satisfied immediately without waiting for the database queue.

The command queuing architecture described hereinabove is dictated by the fact that there are potentially many hundreds of requests that may be being processed for a single web page view such as a page full of thumbnails where some of the thumbnails are cached some are in the database and some have not even been decoded yet. Additionally the same page of thumbnails may be requested by many other viewers at the same time. It is essential that image decodes video transcodes and database accesses which are processor intensive operations do not get repeated over and over. Without the above command queuing process across multiple threads there are cases where the same decode could be requested over and over and in a worst case multiple threads activated directly from network engine to get the same thumbnail when in fact it only need be decoded once and placed into the database and or cache once.

The combination of multiple managed threads each responsible for command sequencing queues for multiple components is important to the success of the overall architecture in an asynchronous and on demand environment which must deal with unpredictable and un sequenced requests from an essentially unbounded and unpredictable viewer base. All components of system exist within a cooperative on demand framework. A goal of the command queuing architecture approach is to provide a processing workflow that is as little as possible as late as possible as few times as possible . Intensive processing such as extracting a thumbnail from a video stream or scaling a representation of a still image is postponed until such time as it is necessary. Having undertaken the processing the result is stored in multiple levels of volatile and non volatile cache.

For example an image may be added to a channel but has not yet been viewed in any context. When a viewer subsequently requests the contents of the channel which can be minutes days or weeks later the system first checks to see if the image thumbnails for the content are in a volatile cache typically a bounded in memory cache. If the images are in the memory cache they are delivered from there directly. If the images are not in the memory cache the framework determines if the images are in the database. If the images are in the database the images are delivered from the database and placed in the in memory cache. If the images are in neither the cache nor the database image processor is invoked and the thumbnails are decoded. Following decode the thumbnail images are placed into the database and into the in memory cache. Subsequent requests for the images possibly from other viewers at a later time are delivered directly from the in memory cache. Should the memory version be purged the next delivery is from the database at the same time placing it into the in memory cache.

The above general workflow applies to video thumbnail extraction to database inquiries and to other such operations. There are multiple levels of cache involved in many common operations that are processor intensive. Database manager image processor and network engine are subject to multiple simultaneous requests from both local publisher and remote server and viewer activities. The same command queue mechanism with support from the dynamic thread pool mechanism in widget engine is used across all of these components to sequence and manage the processing of asynchronous demands typical in a network environment.

In reading the above description persons skilled in the art will realize that there are many apparent variations that can be applied to the methods and systems described. An important such variation is the ability for a publisher to broadcast his media to a web portal. Reference is now made to which show a sample portal web page including an embedded portion broadcast from a publisher in accordance with an embodiment of the subject invention. The portal site in is a foreign site i.e. a site that is not hosted within domains of broadcasting system . In general the portal site in belongs to a third party. The style of the portal page including inter alia headers and banners designated by numeral comes from a portal owner s URL designated by numeral . The bulk of the content in the portal page designated by numeral also comes from the portal owner s URL

The portal page illustrated in contains mixed elements such as the navigation element designated by numeral which contains both portal specific entities Site and About and entities from broadcasting system including channel buttons Tech Classics Machinima Twitch Culture Cartoons Movies and Fast Cars designated by numeral .

The portal page includes an inline frame iFrame sourced from broadcasting system designated by numeral . Area is owned by broadcasting system which provides content in area . The content provided by broadcasting system is dynamically updated. An iFrame is an HTML construct that enables external objects to be included such as an external HTML page. The source

Shown in are thumbnails designated by numeral that represent content sourced from system by peer publishers on the edge of a network. Area is dynamically generated whenever the portal page is constructed by system which has access to the group of publishers who are authorized to broadcast into the portal. System determines which publisher content to include and assembles the visible set of content for the specific channel among the channels that is chosen. Determination of which publisher content to include by system may be random or based on most recent or most popular or such other criteria.

The portal page also includes a search control element designated by numeral which communicates with system . As such the portal owner does not have to provide search engine support instead the search is performed by system and the results delivered into iFrame . When a viewer selects a channel such as the Fast Cars channel a view of the selected channel is displayed in iFrame .

In accordance with an embodiment of the subject invention a publisher is able to broadcast his own content directly into the portal. Specifically a My Broadcast control designated by numeral enables the publisher to add content into the portal. The content that the publisher adds appears as if it is coming from the portal whereas in fact it is coming from the publisher s computer. Shown in is a publisher s view of his own broadcast channel content displaying media files designated by numeral which the publisher has added to his channel.

Shown in is a user interface for the publisher to select media content designated by numeral to add to his channel. In accordance with an embodiment of the subject invention the in page iFrame communicates with the publisher computer which decodes the publisher s media and presents a preview thumbnail. Having selected a media file and added relevant meta data such as a title and a description the publisher makes his content available to the entire portal audience by pushing an Add to Channel button designated by numeral . This event is communicated to the publisher computer which transcodes the publisher s media into a bit rate targeted form stores meta data and communicates with system that the publisher s media is ready for broadcast into the portal.

Shown in is a user interface for the publisher to preview his local content. The publisher clicks on a Preview button designated by numeral and the publisher computer then generates a preview window designated by numeral and plays the publisher s media into the preview window. After adding the publisher s content into the portal the publisher s transcoded media file is available directly to viewers from the portal page as shown in and designated by A. The set of media designated by numeral is dynamically updated to reflect the publisher s newly added content. Viewers can play the newly added media files. The video being played in designated by numeral appears to be integrated into the portal but in fact it is actually being sourced from system and not from the portal s web site. Similarly other publishers content designated by numeral also appears as part of the channel and can be viewed and played.

Reference is now made to which is a simplified diagram of a peer to portal broadcasting system in accordance with an embodiment of the subject invention. includes four components namely a portal web server that serves web pages to a third party portal a publisher peer computer that is operated by one or more individuals who wish to publish media to the portal a broadcast server that feeds broadcast content into the portal and a viewer computer that is operated by a user browsing the web portal. It will be appreciated by those skilled in the art that viewer computer and publisher computer may be the same computer when the publisher is browsing the portal. Whereas addresses the three components publisher peer computer broadcast server and web client peer computer has the additional portal web server . Whereas in the web client views the publisher s media content while browsing a web page on the broadcast server in the web client is browsing a web page on the third party web portal server. In both figures the publisher computer is proxied through the broadcast server.

The main web page for the web portal stored on portal web server includes an iFrame with an embedded SRC that points to broadcast server . Generally while viewing a portal web page a publisher initiates a broadcast to the portal by clicking on a control such as the My Broadcast link shown in . In turn a broadcast application residing on publisher computer receives the portal IP address and enables the publisher to select media files to broadcast. Broadcast application sends meta data about the selected media files to broadcast server and broadcast server stores the meta data in a database for later access.

Viewer computer includes a web browser through which a user browses the Internet and in particular the web portal. When web browser navigates to the web portal URL it requests the main portal page from portal server .

In order to serve the portal web page portal server requests the SRC for the iFrame from broadcast server . Broadcast server includes an iFrame source code generator which dynamically generates iFrame source code for the SRC in response to the request from portal server . Broadcast server sends the iFrame source code thus generated to portal server . Portal server embeds the iFrame source code within the portal web page and sends the updated portal web page with the embedded iFrame source code to web browser .

The iFrame source code includes JavaScript which web browser executes when it renders the portal web page. The JavaScript requests an XML document from broadcast server . Upon receipt of the request broadcast server retrieves the appropriate meta data from database and dynamically generates an XML data container document on the fly. Broadcast server then sends the generated XML document to web browser .

After receiving the XML document web browser continues executing the JavaScript which loads an XSLT transformation and applies the transformation to the XML document. The result of the XSLT transformation on the XML document is an HTML snippet that is embedded into the iFrame following completion of the transformation. The HTML snippet includes code to support clickable thumbnail images that reference endpoints represented by proxy endpoints for the publisher s broadcast media on publisher computer .

After web browser renders the HTML snippet a viewer of the portal can then click on a thumbnail image and the portal launches a media player for playing the media associated with the thumbnail image as shown in . The media content itself is streamed from publisher computer via broadcast server acting as a proxy.

It will be appreciated by those skilled in the art that the functions of broadcast server may be distributed among a plurality of broadcast servers. In particular a first group of broadcast servers may be dedicated to serving the iFrame source code the XML documents and the XSLT transforms and a second group of broadcast servers may be dedicated as a proxy to stream media from publisher computer . The second group of broadcast servers corresponds to servers and in .

Reference is now made to which is a simplified flowchart of a method for peer to portal broadcasting in accordance with an embodiment of the subject invention. is divided into four columns corresponding to the four components of . The leftmost column includes steps performed by publisher peer computer . The second from leftmost column includes steps performed by broadcast server the second from rightmost column includes steps performed by portal web server and the rightmost column includes steps performed by viewer web browser .

At step the publisher computer initiates preparation of a broadcast by clicking on a control within a portal web page such as the My Broadcast link shown in . The portal web page includes an iFrame with a SRC that points to the broadcast server. At step the publisher computer prompts the publisher to select specific media files for broadcast to the portal. At step the publisher computer sends meta data about the selected media files to the broadcast server.

At step the broadcast server receives the meta data from the publisher computer. At step the broadcast server stores this meta data in a database for later retrieval when required at step to generate an XML container document for the meta data.

At step the web browser navigates to the portal URL and requests the portal web page from the portal server. In response at step the portal server requests the iFrame source code from the broadcast server. At step the portal server receives the iFrame source code from the broadcast server. At step the portal server embeds the iFrame source code in the portal page and passes it to the viewer web browser.

At step the viewer web browser in rendering the portal web page encounters the code in the iFrame and executes the code. At step the code executing in the web browser requests an XML document from the broadcast server. At step the broadcast server retrieves the meta data that was stored in the database previously at step and generates an XML data container document therefrom. At step the viewer web browser receives the XML document from the broadcast server and requests an XSLT transformation to transform the XML data container into an HTML document.

At step the broadcast server generates the XSLT transformation which it sends to the viewer browser. At step the viewer browser receives the XSLT transformation from the broadcast server. At step the viewer browser transforms the XML document according to the XSLT transformation. The result of the transformation is a portion of HTML referred to as a snippet . At step the viewer browser embeds the HTML snippet into the iFrame following completion of the transformation. The viewer browser then renders the portal web page at step which now includes clickable thumbnail images that activate a media player to view streamed broadcast media which originates at the publisher computer.

Provided below are five portions of detailed sample source code with line numbering for reference for generating the portal web page shown in in accordance with an embodiment of the present invention. The five source code portions are as follows 

Referring to SOURCE CODE I the portal main page includes many kinds of elements as desired by the portal owners. Lines 98 106 define an iFrame named pixpo corresponding to area in . This iFrame area is set aside by the portal owner and includes code necessary to instantiate a network container used by broadcast server . The iFrame references the URL

Referring to SOURCE CODE II the iFrame includes dynamically generated content i.e. iFrame source code generator on broadcast server generates SOURCE CODE II. In turn the generated SOURCE CODE II contains calls to JavaScript in order to transform XML documents that are sourced from broadcast server .

Lines 241 252 define a framework for the iFrame. Lines 253 and 254 reference style sheets that allow the iFrame to have the look and feel of the framing portal. Lines 255 257 reference style sheets provided by the portal owners and sourced from the owners servers. Lines 258 259 and 278 283 correspond to the bridge code described hereinabove with reference to that allows 127.0.0.1 to be mapped to localhost.mixpo.com. Line 285 corresponds to channel specific generated code.

Lines 289 297 define a My Broadcast control that initiates an application for publishing media to the portal.

Lines 334 358 form a block of dynamically generated code to manage media elements in a channel. For each media item in the iFrame one such block of code is dynamically generated. Within this block of code lines 336 and 337 generate executable code which contains calls to an interface that returns an XML document. The XML document returned from the interface is listed in SOURCE CODE III hereinbelow. The XML document contains meta data and endpoints related to the actual live publisher s content. At lines 352 354 the XML document is transformed this.transform to HTML that contains the source code for placing clickable thumbnails onto the portal page and the HTML is inserted dynamically box.insertBefore into the portal web page. The XSLT transformation used to transform the XML document to HTML is listed in SOURCE CODE IV hereinbelow. The HTML output from the transformation which is inserted into the portal page is listed in SOURCE CODE V hereinbelow.

Blocks 359 383 and 384 408 are similar to the block at lines 337 362 and are repeated for all items in the iFrame.

Referring to SOURCE CODE III the XML document returned by the request at lines 336 and 337 is listed.

Referring to SOURCE CODE IV the XSLT used to transform the XML to HTML when invoked at lines 353 and 354 is listed. SOURCE CODE IV includes multiple transforms. The transforms for the publisher content are provided in lines 473 475 and 629 643. UGC below stands for user generated content. Lines 502 508 show the insertion of clickable thumbnail images for playing video content.

Referring to SOURCE CODE V the HTML output from applying the XSTL transformation in SOURCE CODE IV to the XML document in SOURCE CODE III is listed. It is noted that the HTML output corresponds to the section of code in the XSLT transformation at lines 629 643. The variable ID at line 631 is set to the media identifier 51e2312b ab79 491e ba3d 634f0ea4402 according to line 419 of XML document. Parameters such as user container and page at lines 447 448 and 450 respectively are calling parameters from lines 353 and 354.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made to the specific exemplary embodiments without departing from the broader spirit and scope of the invention as set forth in the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

