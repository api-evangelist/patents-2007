---

title: Method and apparatus for intercommunications amongst device drivers
abstract: Techniques for intercommunication amongst device drivers are described herein. In one embodiment, an application programming interface (API) is provided by a kernel of an operating system (OS) running within a data processing system. The API is accessible by device drivers associated with multiple devices installed in the system. In response to a request from a first instance of a driver via the API, information indicating whether another instance of the same driver is currently started is returned via the API. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07979868&OS=07979868&RS=07979868
owner: Apple Inc.
number: 07979868
owner_city: Cupertino
owner_country: US
publication_date: 20070107
---
The present invention relates generally to data processing systems. More particularly this invention relates to intercommunications amongst multiple device drivers in a data processing system.

Data processing systems such as computer systems are composed of a variety of different components or devices that operate together to form the resultant system. Typically some of the devices are supplied with the computer system initially such as a central processing unit and a communication bus and some devices can be installed into the computer system after the initial configuration of the system. In any event in the general case each device has an associated driver that among other functions configures the device and allows the device to be operable within the overall system. Drivers are typically software instructions that can be loaded into the computer system s memory and when executed will communicate with the device to properly configure the device for operation. The driver may initialize the device so that the device can function and the driver may also allow the device to communicate normally within the overall system.

In certain system configurations a device driver may support multiple devices. During the initialization of a computer system the system may enumerate the devices installed within the system. As a result multiple instances of a driver may be loaded to support multiple devices. In order to avoid loading multiple instances of the same driver in the past a driver developer had to know how to determine whether another instance of the same driver is loaded. For example when an instance of a driver is initialized the driver has to acquire a lock to a device dictionary maintained by a kernel of an operating system to prevent others from accessing the same. Once the driver acquires the lock the driver accesses the dictionary to determine whether another instance of the device driver has already registered its driver handle. If not the current instance of driver registers with the dictionary by inserting its driver handle. If there is a previous driver registered with the dictionary the current instance of the driver may unload itself. Thus this is a first come first serve situation where multiple instances of the same driver race to acquire the lock and register with the dictionary. In addition a driver has to maintain the dictionary. Such a mechanism is relatively complicated and inconvenient and an author of a device driver must write this software each time they write a driver.

Further in certain situations a driver may have to invoke another driver to perform certain functionalities that the driver is not capable of doing so. In the past one driver has to call another driver via a communication protocol such as those described in IEEE 1275 firmware standard IEEE Standard for Boot Initialization Configuration Firmware Core Requirements and Practices IEEE Std 1275 1994 Oct. 28 1994 pp. 1 262 which requires a driver developer to fully understand such a protocol and the system software has to fully support it.

In one embodiment an application programming interface API is provided and accessible by device drivers of a data processing system. In one embodiment such an API is provided by a kernel of an operating system OS running within a data processing system. The API is accessible by device drivers associated with multiple devices installed in the system. During an initialization period of an instance of a driver the instance of the driver invokes the API to determine whether there is another instance of driver that has been initialized. In response to a request from a first instance of a driver via the API information indicating whether another instance of the same driver is currently started is returned via the API.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

In the following description numerous details are set forth to provide a more thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

Referring to according to one embodiment system configuration includes an operating system environment having a user space also referred to as user mode and a kernel space also referred to as kernel mode to allow certain software components to communicate with certain hardware components e.g. devices installed in hardware space . For example client process makes use of operating system services to perform I O requests. This is typically achieved by client process making a call to an application program interface API function provided by the operating system. Calling the appropriate API function ultimately results in a call to operating system services .

Client process is illustrated as operating in user mode and the operating system surfaces are illustrated as operating in kernel mode. Modern operating systems typically provide a robust environment for various application programs and intuitive user interfaces. Such operating systems normally have different operating levels or modes depending on the level of sophistication of the operating system and the security features that are implemented by the operating system. Normal application programs typically run at the lowest priority and have a full complement of security devices in place to prohibit interference with other applications or with other layers of the operating system.

Hardware and other services provided by the operating system are accessed through controlled interfaces or mechanisms which limit the ability of a user application or other process in the user mode to crash the system. This lowest priority mode is typically referred to as a user mode and is the mode that most computer users are familiar with. Because of the close integration of drivers with their associated hardware and because of the time critical nature of the tasks that many drivers perform drivers typically run in an operating system mode that has a much higher priority and a much lower security protection. This mode is generally referred to as a kernel mode. Placing the drivers and other operating system services in the kernel mode allows the operating system to run at a higher priority and perform many functions that would not be possible from user mode.

Referring back to when client process makes a call to OS services the call is routed to one of the device drivers via Device Manager also referred to as an I O manager . In addition device manager maintains a device information base . Device information base is used to store any information regarding device drivers and the associated devices . For example device information base may include a data structure such as for example a device tree having multiple nodes in a hierarchical structure where each node represents a device e.g. devices installed within the system . Each node may be associated with a device driver e.g. device drivers that supports the associated device.

In one embodiment the information stored in device information base may be initially stored in a storage such as for example ROM of the system . When system is initialized e.g. boot the information is read from the storage to construct a data structure loaded in a memory e.g. main memory or RAM also referred to as a device tree plane. In addition during the initialization each node of the data structure is processed to identify a proper device driver to be associated with the respective node. The data structure having each node matched with a proper device driver is referred to as a service plane. Note that throughout this application a device tree is used as an example of a data structure for storing relationship amongst the devices installed in the system. However it is not so limited other types of data structures may also be utilized.

The device tree begins as a single root node that may represent the CPU s memory bus. All I O buses and attached devices are assumed to descend from this single root or node . Layers descending the device tree are dependent on the operation of devices associated with nodes above them. Buses are parent nodes and devices for the leaf nodes of the device tree . A complete device tree represents the device topology of the computer system A bus node in the device tree represents an I O address space. Each device on a bus operates within the address space supported by its parent bus. Buses also contain information regarding interrupts so that a device can request service from a driver. It is appreciated that drivers of embodiments of the present invention are matched to devices but not to buses. In the device tree buses can lead to other buses. A node of the device tree that corresponds to a device is called a device node. Devices added to the computer system will be added to the device tree upon initialization of the computer system.

Embodiments of the invention use information described above in a service plane which is essentially a copy of pertinent information obtained from the device tree with an associated driver associated with each device.

Referring to an exemplary device tree may be generated by firmware upon the initialization of the computer system of . While a portion of the information contained in the device tree is utilized by the embodiments of the invention the actual complete copy of the device tree as generated by the firmware needs to be used. At system initialization devices communicate their presence to firmware which cooperates with the operating system to construct the device tree also referred to as a device tree plane . Information of the device tree used by the present invention can be constructed under the IEEE 1275 standard which is well known in the art and is not described herein. The device tree can be modified by the computer system s operating system from time to time as required or instructed. Note that device tree is shown for the purposes of illustration only. Other formats or architectures may also be utilized.

Each device includes a device name for identifying a corresponding device in a device name space and one or more properties specifying information associated with the respective device. For example device includes a device name and a property attribute having a property field having one or more properties. Each property is identified by a property name e.g. property names and property data e.g. data fields similar to a key value pair configuration.

Data structure may be presented to the operating system and drivers by associated descriptive pieces of data e.g. properties that are within each node. A device name may be used as a primary basis for matching a driver to a device. A name property may be implemented as a null terminated string of characters or alternatively by a UUID universally unique identifier or GUID global unique identifier . Device nodes may also contain a property that indicates compatible devices not shown to the corresponding device name.

Referring to root device may further include an optional dictionary for storing relationship between a device and a handle of the associated device driver. An example of a dictionary is shown in . Alternatively dictionary may be implemented as a separate data structure or table accessible by the root device . Further each device such as device may further include an optional driver field to store a handle of a corresponding driver supporting the respective device. Alternatively the driver handle may be specified via dictionary as shown in . Note that the data structure is shown for the purposes of illustration only. Other formats or architectures may also be utilized.

According to one embodiment dictionary may be constructed during initialization of a computer system or operating system. In a particular embodiment when the system is initialized e.g. boot a device tree stored in a storage e.g. ROM is fetched to form a device tree plane. For each device identified in the device tree plane the identified device is checked against each entry of the dictionary. An identifier of the device e.g. device name or UUID GUID may be inserted into the first field . In addition a matched device driver is identified loaded and its driver handle is inserted into the second field . Note that the data structure is shown for the purposes of illustration only. Other formats or architectures may also be utilized.

According to one embodiment root device may maintain an API to allow any of the child devices to inquire whether there is another driver or another instance of a driver supporting the same device. As described above certain devices may be supported by the same driver. However under certain circumstances only one instance of the same driver is allowed to load. In one embodiment when a first instance of a device driver is initialized in preparing to be loaded the first instance of the driver calls the API in this example the root device to determine whether a second instance of the same driver has already been loaded.

In response a function providing the API performs a lookup operation into the dictionary to determine whether a second instance of the same driver has been loaded. In one embodiment such a function may be part of a kernel function. Alternatively such a functionality may be provided by a dedicated component of an operating system. For example the kernel may look up based on a device name provided by the first instance and based on the device name to determine whether a driver handle exist in the corresponding second field . If the corresponding second field is empty it means that no driver has been loaded for this device. The kernel may insert the driver handle of the first instance into the corresponding second field indicating the first instance of driver has been loaded. Otherwise according to one embodiment the kernel may return a driver handle from the corresponding second field indicating another instance of the same driver has been loaded. Based on a result of calling the API the first instance driver may act properly such as for example unload itself. Other configurations may exist.

For example for illustration purposes only a first instance of a driver may invoke API to communicate with component in an attempt to determining whether there is another instance of the same driver existing or already started. When instance calls the API it passes its device identifier e.g. device name or UUID GUID associated with the device to the driver coordinator . In one embodiment the first instance may retrieve its device identifier from a corresponding device node of device tree which may be implemented in a data structure representing at least a portion of a device tree such as device tree of . In response to the calling of the API driver coordinator may perform a lookup operation into data structure to determine whether another instance of the same driver has been loaded or started. If there is another instance of a driver has been started driver coordinator may return a driver identifier e.g. driver handle of the existing driver to the caller. Otherwise driver coordinator may insert caller s driver identifier into the data structure .

According to certain embodiments of the invention API may also be used by drivers or instances of drivers to communicate with each other based on information stored within a device tree e.g. data structure . For example one driver or driver instance may communicate with another driver or driver instance based on the information stored within a device tree or data structure.

Referring to at block data representing a device tree is retrieved from a storage such as for example ROM read only memory of a data processing system. The device tree includes multiple device nodes and each node represents a device installed in the system. The data may be retrieved by a kernel component of an operating system such as for example IO manager or device manager. The data may be retrieved via IEEE 1275 protocol. Note that the retrieved data may not necessarily in a tree style structure. Other configurations may also be utilized.

In response to the data representing a device tree at block the kernel forms a device tree plane based on the data retrieved from the storage and loads the device tree plane in memory e.g. main memory or RAM . At block the kernel creates a dictionary or data structure having entries each entry corresponding to a device. Each entry includes a first field to store an identifier of a device e.g. device name or UUID GUID and a second field to store an identifier of a driver e.g. driver handle or pointer associated with the device. At block the kernel maintains an API to allow an instance of a driver to call in order to determine whether another instance of the driver has been loaded or started based on information obtained from the device tree plane and or dictionary. At block the kernel also provides a mechanism based on the device tree plane and or dictionary to allow a driver to communicate e.g. invocation with another driver at runtime. Other operations may also be performed.

In this example audio control device is responsible for handling audio control signals while audio data device is responsible for handling audio data signals. Although audio control device and audio data device are considered as two devices they may be supported or serviced by the same audio driver . is a diagram illustrating a data structure representing device of . As shown in both audio control device and audio data device have a name property e.g. properties of Audio0 to indicate they are associated with the same device driver. is a block diagram illustrating the corresponding dictionary maintained by the kernel. As shown in there is only one entry corresponding to the name of Audio0 .

During initialization of the system for the illustration purposes as the kernel of an operating system walks through the device tree a driver or an instance of a driver associated each device node is launched and initialized. For example when audio control device is initialized a first instance of audio driver associated with audio control device is launched. The first instance may invoke the API e.g. FindCo provider provided by the kernel to determine whether there is another instance of the same driver in this example a second instance of driver associated with audio data device . In this example if the second instance of the audio driver has already been launched the corresponding entry of the dictionary as shown in should have already included a driver handle of the second instance. As a result the invocation of the API may return the driver handle of the second instance.

On the other hand if there is no existing driver instance registered with the dictionary the kernel may insert the driver handle of the first instance into the corresponding entry of the dictionary. Based on the result of the invocation of the API the first instance can decide whether the respective instance should continue to start. In one embodiment when the first instance of the audio driver determines that based on calling the API e.g. FindCo provider the second instance of the audio driver has already been loaded the first instance may unload itself. As a result only instance of the same driver will be loaded in the memory.

According to certain embodiments of the invention certain properties of a device node in a device tree may be used to encode information regarding another device node and or a device driver of that device node. As a result a driver of a first device node may invoke or communicate with a driver of a second device node using property information retrieved from the device tree. For example based on the information retrieved from a device tree a first driver may communicate with the kernel to receive a driver handle of a second driver and call the second driver via the driver handle of the second driver. Alternatively the first driver may instruct the kernel to directly call the second driver based on the information retrieved from the device tree. In these examples the second driver being called may not need to know who is calling and the first driver does not need to know where to call the second driver. That is the first driver may know that someone else can help on certain functionality but it does not know who has the capability of performing such functionality.

In one embodiment for example data structure of device node includes information encoded as part of property regarding another device node and or a device driver associated with device node . Based on the encoded information retrieved from property a driver associated with device node may locate a driver associated with device node and invoke the driver associated with device node . This is typically useful when one driver of a device is responsible of certain functionality e.g. control and data signal communications while another driver is responsible for other functionality of the same device e.g. power management or clock signal control .

For example based on information extracted from property a first driver of first device node may communicate with the root device or kernel to locate a second driver of device node . In a particularly embodiment property may include an identifier regarding device node such as for example a device name. When the first driver needs to invoke the second driver although the first driver does not know who and where the second driver is the first driver or its parent retrieves the encoded information from the device tree. The first driver then communicates with the kernel with the retrieved information. Based on the information provided by the first driver the kernel e.g. root device performs a lookup operation in dictionary to determine a driver identifier e.g. driver handle of the second device node . The kernel returns the driver handle of device node back to the first driver and thereafter the first driver may invoke the second driver via the associated driver handle. Alternatively the kernel may directly invoke the second driver. Other configurations may exist.

Note that in this example C C is used as an example of object oriented programming OOP language however other OOP languages may also be applied. It will be appreciated that an OOP language is not required to practice embodiments of the invention. Other non OOP programming languages e.g. assembly may also be utilized. Other programming languages e.g. assembly may also be utilized. Referring to when device node needs to invoke a driver of device node to control clock signals of a device associated with device node such as for example turning off the clock its corresponding function member invokes its parent e.g. provider function . Within the function the encoded information is retrieved from the device tree e.g. getProperty . In this example data of a property of clock gates under device node is retrieved. Thereafter the parent function of function is invoked which in turn communicates with function of root device node . Based on the encoded information retrieved from the device tree function determines e.g. via dictionary a driver handle of driver associated with and the corresponding function member . Thereafter function is called. As a result a driver associated with device node can invoke a driver associated with device node based on information extracted from the device tree.

As shown in the system which is a form of a data processing system includes a bus or interconnect which is coupled to one or more microprocessors and a ROM a volatile RAM and a non volatile memory . The microprocessor which may be for example a PowerPC G4 or PowerPC G5 microprocessor from Motorola Inc. or IBM is coupled to cache memory as shown in the example of . The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required.

While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals. Alternatively I O controller may include an IEEE 1394 adapter also known as FireWire adapter for controlling FireWire devices.

This digital interface may include a graphical user interface which is similar to that shown on a typical computer such as for example a Macintosh computer when running OS X operating system software. The system also includes a communication interface e.g. wired or wireless communication interface such as for example one or more wireless transceivers to communicate with another system or device. A wireless transceiver may be a WiFi transceiver an infrared IR transceiver a Bluetooth transceiver and or a wireless cellular telephony transceiver. It will be appreciated that additional components not shown may also be part of the system in certain embodiments and in certain embodiments fewer components than shown in may also be used in a data processing system.

The data processing system also includes one or more input devices which are provided to allow a user to provide input to the system. These input devices may be a keypad or a keyboard or a touch panel or a multi touch panel. Alternatively input devices may include a voice interactive interface that can receive and interact with a voice command. The data processing system also includes an optional input output device which may be a connector for a dock. It will be appreciated that one or more buses not shown may be used to interconnect the various components as is well known in the art. The data processing system shown in may be a handheld computer or a personal digital assistant PDA or a cellular telephone with PDA like functionality or a handheld computer which includes a cellular telephone or a media player such as an iPod or devices which combine aspects or functions of these devices such as a media player combined with a PDA and a cellular telephone in one device. In other embodiments the data processing system may be a network computer or an embedded processing device within another device or other types of data processing systems which have fewer components or perhaps more components than that shown in .

At least certain embodiments of the inventions may be part of a digital media player such as a portable music and or video media player which may include a media processing system to present the media a storage device to store the media and may further include a radio frequency RF transceiver e.g. an RF transceiver for a cellular telephone coupled with an antenna system and the media processing system. In certain embodiments media stored on a remote storage device may be transmitted to the media player through the RF transceiver. The media may be for example one or more of music or other audio still pictures or motion pictures.

The portable media player may include a media selection device such as a click wheel input device on an iPod or iPod Nano media player from Apple Computer Inc. of Cupertino Calif. a touch screen input device pushbutton device movable pointing input device or other input device. The media selection device may be used to select the media stored on the storage device and or the remote storage device. The portable media player may in at least certain embodiments include a display device which is coupled to the media processing system to display titles or other indicators of media being selected through the input device and being presented either through a speaker or earphone s or on the display device or on both display device and a speaker or earphone s . Examples of a portable media player are described in published U.S. patent application Nos. 2003 0095096 and 2004 0224638 both of which are incorporated herein by reference. Other configurations may exist.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

