---

title: Anti-debugging protection of binaries with proxy code execution
abstract: A first process operating on a computer comprises code to be executed in connection therewith, where the code includes at least one triggering device. A digital license corresponds to the first process and sets forth terms and conditions for operating the first process. A second process operating on the computer proxy-executes code corresponding to each triggering device of the first process on behalf of such first process. The second process includes a selection of options to thwart reverse engineering by a debugger if a debugger is detected. The options include execution by a proxy engine of a re-routed call, crashing the first process, detection ad elimination of a debugger related interrupt a call to an arbitrary function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08271803&OS=08271803&RS=08271803
owner: Microsoft Corporation
number: 08271803
owner_city: Redmond
owner_country: US
publication_date: 20070525
---
The present application is a continuation in part of U.S. application Ser. No. 10 681 017 filed Oct. 8 2003 entitled First Computer process and second Computer Process Proxy executing Code on Behalf Thereof which is incorporated herein by reference in its entirety.

A computer application distributor wishes to distribute such computer application to each of many users or recipients in exchange for a license fee or some other consideration. However such distributor typically also wishes to restrict what each user or recipient can do with such distributed computer application. For example the distributor would like to restrict the user from copying and re distributing such application to a second user at least in a manner that denies the distributor a license fee from such second user.

In addition the distributor may wish to provide the user with the flexibility to purchase different types of use licenses at different license fees while at the same time holding the user to the terms of whatever type of license is in fact purchased. For example the distributor may wish to allow the application to be executed only a limited number of times only for a certain total time only on a certain type of machine only on a certain type of rendering platform only by a certain type of user etc. Likewise the distributor may wish to allow one user to pay a smaller license fee and access a smaller set of application functions and also to allow another user to pay a larger license fee and access a larger set of application functions and the like.

However after distribution has occurred such distributor has very little if any control over the distributed application. This is especially problematic in view of the fact that the application may be copied and re distributed to most any personal computer presuming that the application is not otherwise protected in some manner from such copying and re distribution. As should be appreciated most any such personal computer includes the software and hardware necessary to make an exact digital copy of such application and to download such exact digital copy to a write able magnetic or optical disk or to send such exact digital copy over a network such as the Internet to any destination.

Of course as part of a transaction wherein the application is distributed the distributor may require the user recipient of the application to promise not to re distribute such application in an unwelcome manner. However such a promise is easily made and easily broken. A distributor may therefore attempt to prevent such re distribution through any of several known security measures.

One such security measure is product activation. In such product activation a customer acquiring a software application is provided with a product activation key corresponding thereto which is a unique serial number and product identifier that acts as a proof of purchase or the like. The provided product key is then entered during installation of the application on a particular computer device to act as a proffer that the application was acquired legally and or otherwise properly. The product activation key need not be and typically is not cryptographic in nature although a digital signature which is cryptographic in nature may be included to act as a guarantee that the product key is genuine.

The entered product key and an ID representative of the computer device are then sent to a product activation service as part of the installation process. As may be appreciated the product activation service determines whether the entered product key is valid whether the product key has been employed before and if so in connection with what computer device. Typically each product key enables an installation or re installation of the application on a single computing device as is set forth in a corresponding license agreement although a product key may also enable a set number of installations re installations on multiple computer devices also.

Accordingly if the product activation service determines that the entered product key has already been employed to install the application on another computer device or has been employed a maximum number of times for example such activation service will not allow the installation of the application on the computer device to proceed will not allow a complete installation of the application on the computer device will not allow the installed application to be used on the computer device or the like as the case maybe. Thus activation as used herein may entail permission to install the application permission to perform some level of installation of the application permission to completely install the application some level of permission to use the application complete permission to use the application or the like.

If the activation service declines to activate the application for the customer based on an entered product key already being used in connection with another computing device or based on the entered product key not supporting the level of activation desired the customer must acquire another appropriate product key to install completely install use the application on the computing device in the manner desired. Thus the product key and the product activation service act to ensure that the application is not nefariously or wantonly installed activated used on multiple computing devices such as may be in violation of any software license agreement associated with the software product.

Note that as part of the activation process the activation service may return a digital version of the license to the computing device on which the application is associated. Such license may be tied to the computing device such that the license is not usable with any other computing device and may express a level of activation as well as license terms such as application functions that are to be made available functions that are to be made non available a period of activation or a number of times the application may be executed on the computing device and the like. In general such license may express any limitations and or rights and also may express any policies that should be honored in connection with the execution of the application on the computing device all as set forth by the distributor of the application or another entity.

With such license then a rights client controller with a license evaluator or the like may be employed on the computer along with the distributed application to control operation and use of the application based on an evaluation of whether the license so permits. However a need exists for an actual method and mechanism by which such rights client with such license evaluator may in fact control operation and use of the application based on the license. In particular a need exists for such a rights client with such a license evaluator that executes certain portions of code on behalf of and as a proxy for the application but only if the license evaluator determines that the license allows such execution.

Another threat to the security of a binary object is unauthorized reverse engineering. It is well known that a debugger is crucial to the successful reverse engineering of an executable binary. The ability to prevent debugging is a critical part of a successful protection strategy of an IP sensitive binary. While many anti debugging techniques have been implemented in the past they typically rely on two approaches. The first is by leveraging all of the various programmatic interfaces provided by the operating system to detect a debugger. The second is by sprinkling these queries throughout the binary. This approach was limited by the fact that attackers could defeat this by either shimming the OS interfaces to return compromised results or find and remove the sprinkled checks from the binary. The combination of these techniques only slows down the use of debuggers and does not stop a debugging process.

The aforementioned needs are satisfied at least in part by the present invention in which a computer has thereon a first process operating on the computer comprising code to be executed in connection therewith where the code includes at least one triggering device and a digital license corresponding to the first process where the license sets forth terms and conditions for operating the first process. A second process operating on the computer proxy executes code corresponding to each triggering device of the first process on behalf of such first process. The second process includes a license evaluator for evaluating the license to determine whether the first process is to be operated in accordance with the terms and conditions set forth in such license and the second process chooses whether to in fact proxy execute the code corresponding to each triggering device of the first process on behalf of such first process based at least in part on whether the license evaluator has determined that the first process is to be operated in accordance with the terms and conditions of the license. Thus the first process is dependent upon the second process for operation thereof.

The second process monitors for when the first process executes a triggering device thereof. Upon such occurrence the second process responds thereto by determining an address of the triggering device within the first process locating in a table the code section corresponding to the triggering device based on the determined address and proxy executing the located code section on behalf of the first process.

To develop the first process source code is developed in an appropriate programming language and within such source code each of one or more code sections that is to be proxy executed by the second process is identified. The source code is compiled into machine code such that an identification of each identified code section is maintained and the machine code is post compiled with each identified code section therein into final code representative of the first process based on the identification of each identified code section by for each identified code section converting same into a form accessible only by the second process and not by the first process.

In one embodiment the proxy process is used to detect and provide anti debugger techniques to avoid reverse engineering. The proxy engine selects from one or more options that thwart reverse engineering attempts after a debugger is detected.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Although not required the invention can be implemented via an application programming interface API for use by a developer and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of non transitory computer readable media including any available media that can be accessed by computer and including both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media including nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transitory medium which can be used to store the desired information and which can be accessed by computer . Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory . GPUs however are but one example of a coprocessor and thus a variety of co processing devices may be included in computer . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

Distributed computing facilitates sharing of computer resources and services by direct exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may interact to implicate authentication techniques of the present invention for trusted graphics pipeline s .

It can also be appreciated that an object such as may be hosted on another computing device or . Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wireline or wireless systems by local networks or widely distributed networks. Currently many of the networks are coupled to the Internet which provides the infrastructure for widely distributed computing and encompasses many different networks.

In home networking environments there are at least four disparate network transport media that may each support a unique protocol such as Power line data both wireless and wired voice e.g. telephone and entertainment media. Most home control devices such as light switches and appliances may use power line for connectivity. Data Services may enter the home as broadband e.g. either DSL or Cable modem and are accessible within the home using either wireless e.g. HomeRF or 802.11b or wired e.g. Home PNA Cat 5 even power line connectivity. Voice traffic may enter the home either as wired e.g. Cat 3 or wireless e.g. cell phones and may be distributed within the home using Cat 3 wiring. Entertainment media may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also emerging as digital interconnects for clusters of media devices. All of these network environments and others that may emerge as protocol standards may be interconnected to form an intranet that may be connected to the outside world by way of the Internet. In short a variety of disparate sources exist for the storage and transmission of data and consequently moving forward computing devices will require ways of protecting content at all portions of the data processing pipeline.

The Internet commonly refers to the collection of networks and gateways that utilize the TCP IP suite of protocols which are well known in the art of computer networking. TCP IP is an acronym for Transport Control Protocol interface Program. The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the networks. Because of such wide spread information sharing remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services essentially without restriction.

Thus the network infrastructure enables a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. Thus in computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of computers etc. can be thought of as clients and computer etc. can be thought of as the server where server etc. maintains the data that is then replicated in the client computers etc.

A server is typically a remote computer system accessible over a remote network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server.

Client and server communicate with one another utilizing the functionality provided by a protocol layer. For example Hypertext Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW . Typically a computer network address such as a Universal Resource Locator URL or an Internet Protocol IP address is used to identify the server or client computers to each other. The network address can be referred to as a Universal Resource Locator address. For example communication can be provided over a communications medium. In particular the client and server may be coupled to one another via TCP IP connections for high capacity communication.

Thus illustrates an exemplary networked or distributed environment with a server in communication with client computers via a network bus in which the present invention may be employed. In more detail a number of servers etc. are interconnected via a communications network bus which may be a LAN WAN intranet the Internet etc. with a number of client or remote computing devices etc. such as a portable computer handheld computer thin client networked appliance or other device such as a VCR TV oven light heater and the like in accordance with the present invention. It is thus contemplated that the present invention may apply to any computing device in connection with which it is desirable to process store or render secure content from a trusted source.

In a network environment in which the communications network bus is the Internet for example the servers can be Web servers with which the clients etc. communicate via any of a number of known protocols such as HTTP. Servers may also serve as clients as may be characteristic of a distributed computing environment. Communications may be wired or wireless where appropriate. Client devices may or may not communicate via communications network bus and may have independent communications associated therewith. For example in the case of a TV or VCR there may or may not be a networked aspect to the control thereof. Each client computer and server computer may be equipped with various application program modules or objects and with connections or access to various types of storage elements or objects across which files may be stored or to which portion s of files may be downloaded or migrated. Thus the present invention can be utilized in a computer network environment having client computers etc. that can access and interact with a computer network bus and server computers etc. that may interact with client computers etc. and other devices and databases .

In the present invention a rights client with a license evaluator and in connection with a product activation service controls operation and use of an application based on a corresponding license by executing code on behalf of and as a proxy for an application but only if the license evaluator determines that the license allows such execution. Thus the rights client with the license evaluator enforces the license as against a user of the application.

As may be appreciated although the present invention is disclosed primarily in terms of the rights client with the license evaluator the application the license and the product activation service such present invention may also be employed in connection with alternate elements without departing from the spirit and scope of the present invention. For example the application may instead be any application or type of process running on a computer including a program an operating system and the like or even a piece of digital content such as an audio recording or multimedia presentation. Similarly the license may instead be any sort of permission token with or without specific permission parameters and the license evaluator may instead be any kind of device for evaluating such a permission token. Likewise the product activation service may instead be any variety of permission granting authority and the rights client may instead be any variety of controlling authority that can also proxy execute code. Accordingly and more generally in the present invention a second process on a computer controls the operation and use of a first process on a computer by executing code on behalf of and as a proxy for the first process.

Turning now to it is seen that in one embodiment of the present invention a first process such as an application is dependent upon a second process such as a rights client to proxy execute at least some portion of code for the application where the rights client includes a license evaluator or the like. Accordingly the rights client may choose whether to in fact proxy execute the code for the application based among other things on whether the license evaluator has access to a license corresponding to the application and on whether the license has permissions or rights that allow or at least do not prohibit the action corresponding to the code to be executed. Note that such a license and the license evaluation of the rights client are known or should be apparent to the relevant public and therefore need not be disclosed herein in any detail.

In one embodiment of the present invention and referring now to the application rights client and license evaluator are constructed to operate on a computer or the like as follows. Typically either a user or another process on the computer instantiates the application on such computer as the aforementioned first process step and as part of an initializing process such application ensures that the rights client with the license evaluator hereinafter rights client is instantiated on the computer as the aforementioned second process step . Thereafter the application establishes a connection with the rights client step . Note that it may be the case that the rights client is already instantiated or it may be the case the rights client must be newly instantiated either by the application another process the user or the like.

Once step is performed and presuming that a license corresponding to the application is available to the rights client and the license evaluator thereof the application can query the rights client to have the license evaluator thereof determine based on the license the rights the application has based on such license and the application can then operate based on such rights. However it is to be appreciated that a nefarious entity wishing to subvert the license might choose to attack the application by re directing the query to a stub rights client that would in effect grant all rights to the application without regard to any license present or otherwise. Alternatively such a nefarious entity might choose to spoof communications between the application and the rights client or may wish to attack the rights client itself if the application cannot be attacked. Note though that the latter case is less likely inasmuch as the rights client should be highly secure and protected from such an attack.

Accordingly and in one embodiment of the present invention the rights client is required to proxy execute at least some portions of code on behalf of the application so that the application is dependent on the rights client . Put another way by requiring the rights client to proxy execute at least some portion of code on behalf of the application the aforementioned nefarious entity cannot subvert the license by somehow removing the rights client from participating in the method of . Instead the rights client must participate to proxy execute code on behalf of the application and while doing so the license evaluator of the rights client can also perform evaluation functions with regard to the license . Thus the rights client does not merely provide the application with a true or false type of response that could be spoofed.

In one embodiment of the present invention the license includes encoded information regarding the code that the rights client is to proxy execute. Thus the license must be available to the rights client for same to proxy execute on behalf of the application . For example the encoded information may include the code a reference to a location of the code a decryption key for decrypting an encrypted version of the code or the like.

As should now be appreciated in order to effectuate proxy execution the application must be pre processed to define the code that is to be proxy executed to remove same from such application and to appropriately store such removed code in a form proxy executable by the rights client . In one embodiment of the present invention then and turning now to a method of pre processing the application to effectuate proxy execution is shown.

Preliminarily and as may be appreciated a developer develops source code for the application in an appropriate programming language such as for example a C type programming language step . In doing so and significantly the developer identifies within such source code for the application each of one or more code sections that is to be proxy executed step . As may be appreciated each such proxy executed code section identification may comprise any appropriate mark tag command or the like without departing from the spirit and scope of the present invention. Thereafter the developer compiles the source code with a compiler into machine code step .

Note that the developer may identify each code section within the source code based on any particular criteria without departing from the spirit and scope of the present invention. For example if the developer merely wishes to trigger proxy execution from time to time so as to ensure the rights client is present and is allowing the application to operate based on a corresponding license each such identified code section may be decided upon in a fairly random manner. However if the developer wishes to trigger proxy execution at specific times and or with regard to specific sections of code each such identified code section must be decided upon in a more targeted manner. Note with regard to the latter that it may be the case that an identified code section specifies a particular license right. In such a situation it may also be the case that the rights client will proxy execute such identified code section only if the specified license right in the license is met.

As may be appreciated the compiler may be any appropriate compiler without departing from the spirit and scope of the present invention. Significantly the compiler is constructed to maintain each code section identification in the machine code so that post compile processing may be performed on the code section identified thereby. Such maintaining maybe performed in any appropriate manner without departing from the spirit and scope of the present invention. For example the compiler may pass the identification from the source code to the machine code in a recognizable form or may create a scratch table not shown with such information therein.

Thus and in one embodiment of the present invention after such compiling the developer post compiles the machine code with each recognizable code section identification therein with a post compiler into the final code representative of the application where the post compiler converts each identified code section into a form accessible only by the rights client and not by the application such as for example by removing each identified code section in the machine code from such application or otherwise makes such identified code section inaccessible step . As may be appreciated such post compiler is constructed to retrieve each code section identification either from the machine code the aforementioned scratch table or elsewhere and operate based thereon.

In one embodiment of the present invention for each identified code section in the machine code the post compiler removes the identified code section from the machine code step replaces the removed code section with a triggering device step notes an address of the triggering device within the application step and stores the removed code section and the noted address in a table or the like step . If necessary or advisable each removed code section may stored in the table in an encrypted form decryptable by the rights client step . As was set forth above such table may be made available to the rights client by being set forth in the license or by being set forth in another location. Note that the table may be signed or otherwise protected from alteration by a verifying device such as a hash.

As may be appreciated by replacing the removed code section with the triggering device and presuming that the triggering device is shorter than the removed code section the post compiler shortens the machine code . Note that the triggering device may be any appropriate triggering device without departing from the spirit and scope of the present invention as long as the triggering device is recognizable as a signal that the rights client is needed to proxy execute the corresponding removed code section. For example the triggering device may be a particular exception that would get the attention of the rights client .

After the post compiler is finished and as should now be appreciated such post compiler outputs final code representative of the application hereinafter the application and the table step . As was set forth above such table may be made available to the rights client by being set forth in the license or by being set forth in another location separate from the application . It may for example be the case that the table with encrypted removed code sections therein is placed in the license along with a decryption key for decrypting each encrypted code section where the decryption key is itself encrypted in a manner decryptable by the rights client . Note that by separating the table from the application the application has no innate access to the table or the removed code sections therein.

Thus and returning now to during runtime and after the application and rights client have been instantiated the rights client attaches itself to the application in the manner of a debugger or the like so that the rights client can monitor the application for when each triggering device exception therein is executed step . As may be appreciated the rights client monitors the application for the particular triggering device exception hereinafter exception that signals that the rights client is to proxy execute on behalf of the application . Thus on every breakpoint exception the rights client determines whether the exception source is a removed code section and if so the rights client proxy executes the removed code section presuming the license so allows.

In an alternate embodiment of the present invention the rights client does not attach itself to the application to monitor for an exception but instead receives the exception from an operating system operating the computer . However such an arrangement is indirect and therefore slower. Another alternative would be to have each triggering device be a call to the rights client although such a strategy is slightly more complex as compared to an exception and is more prone to attack by a nefarious entity.

At some point the application may explicitly request permission to operate from the rights client based on the license . In response the rights client searches for the license the license evaluator evaluates such license and the rights client returns such requested permission if the evaluation of the license evaluator is positive. Note though that such explicit request for permission and response are ancillary to the present invention. Rather in the present invention the rights client is actuated based on an exception or the like from the application and not based on an explicit request from the application . Thus in the present invention the rights client can withhold performance of a function on behalf of the application even when the application never requested permission to perform such function.

At any rate in the course of operating the application at some point executes an exception in the code thereof where such exception was placed in the application by the post compiler in place of a removed identified code portion step . As should be understood upon executing the exception the application halts until receiving notice that the exception has been dealt with step . Inasmuch as the rights client is attached to the operating application and is listening for such exception from such application such rights client notes the exception step and responds thereto step .

In particular to respond to the exception the rights client first determines the address of the exception within the application step locates the corresponding code section in the table based on such address step proxy executes such corresponding code section on behalf of the application step and then signals to the application that the exception has been dealt with step . As may be appreciated the application may then proceed step . Note that if the corresponding code section is encrypted the rights client must decrypt the located corresponding code section before proxy executing same step . Note too that a particular code section may require that the license evaluator of the rights client first verify that the license grants the rights necessary to proxy execute such code section on behalf of the application step . As may be appreciated the rights client proxy executes such code section only if the license grants the right to do so. Otherwise the rights client declines to do so. In the latter case it may be that the rights client returns an appropriate message to the application .

It is to be appreciated that a rights client should not be proxy executing any arbitrary code section especially inasmuch as the rights client should be especially secure and therefore could have a relatively large amount of operating rights with respect to the computer . Put another way the rights client should not be performing actions that the application would not have operating rights to perform such as altering certain system registers accessing memory areas of other applications and the operating system and the like. Accordingly in one embodiment of the present invention the post compiler during operation thereof ensures that each code section removed and stored thereby is not of a sensitive nature. For example it may be the case that the post compiler during operation thereof ensures that each such code section does not affect system memory. Of course other bases for filtering code sections may be employed without departing from the spirit and scope of the present invention. Note that if a code section includes sensitive code it may be that the post compiler isolates such sensitive code and removes only sub portions of code on either side of the sensitive code.

In one embodiment of the present invention the rights client proxy executes on behalf of the application only if a valid license corresponding to such application is available to the rights client . In such a case it may be that the purpose of each exception and proxy execution based thereon is merely to occasionally check that the license is still present and still valid. In an alternate embodiment the rights client proxy executes on behalf of the application without regard to any corresponding valid license . In such a case it may be that the purpose of each exception and proxy execution based thereon is merely to tie the application to the rights client which presumably is tied to the computer thus tying the application to the computer .

In one embodiment of the present invention the application as produced by the post compiler may include multiple types of exceptions each triggering the rights client . However each different type of exception is handled differently. For one example one type of exception may require the rights client to check the license while another type may not. For another example different types of exceptions could require access to different tables or could require different decryption keys and or methods.

As disclosed herein the application the rights client and the license are separate constructs. Nevertheless it should be appreciated that such items may be combined in any manner without departing from the spirit and scope of the present invention. For example the application could include the rights client or the rights client could include the license . Note though that in at least some instances combined items may be more susceptible to an attack from a nefarious entity.

As also disclosed herein the rights client proxy executes code on behalf of the application . Alternatively the rights client may operate to modify the application to include the to be executed code allow such application to execute such code and then again modify the application to remove such code. Note though that such an arrangement may be more susceptible to attack by a nefarious entity especially in the moments when the application is modified to include the to be executed code.

As may be appreciated one especially useful aspect of the present invention is that the rights client may now perform especially secure functions on behalf of the application such that a nefarious entity is thwarted from affecting such functions. For example it may be the case that a term in a license affects how many times the application can perform a specific action. Although the application could obtain such term from such license having the application do so could allow a nefarious entity to intervene in the process to subvert same. Instead in one embodiment of the present invention the rights client is employed to proxy execute code for the application relating to such term in such license including obtaining the term and employing same.

As mentioned above one threat to an executable binary is the use of a debugger to reverse engineer the binary. The current proxy execution technique may be used in conjunction with other methods to thwart the efforts to reverse engineer a binary.

During execution of the anti debugging protected binary an exception may be generated which calls into action the exception handler . The execution handler along with the proxy execution engine employs resources such as user mode debugging resources and kernel mode debugger resources to check for the presence of an active debugger. If no debugger is detected the proxy execution engine executes the removed code section . It does this by decrypting the encrypted section if necessary and processing the code sequence that is indicated as being part of the main binary . After the proxy execution by the engine the exception handler informs the anti debugging protected binary that the exception was properly dispatched and the execution of the anti debugging binary may proceed.

However if the exception handler detects the presence of a debugger then execution of the proper code in section does not take place. Here the presence of a debugger modifies the expected execution of section by the proxy engine . According to an aspect of the invention during runtime the removed sections can only be executed by the proxy execution engine when the presence of a debugger debugging the protected code is not detected.

Detection of a debugger may be accomplished many ways. In one method the presence of a debugger is detected by the utilization of commonly employed debugger registers in either the user mode debugger resources or by the kernel mode debugger resources. Another method to detect a debugger is the detection of the use of a communication port that is commonly used by debuggers. Another method to detect the presence of a debugger is the use of a specific interrupt i.e. and determining that a debugger is requesting system resources. Yet another technique for detecting the use of a debugger is to identify vectored exceptions and handlers that are operating outside of the software process. Vectored exceptions of this character may indicate that a debugger is present. Other techniques for debugger detection may be used as is known by those of skill in the art. Once a debugger is detected then the proxy engine has options on how to respond. In implementation the selection of debugger resources to query are those that are also required for the debugger to function. This selection was made in order to prevent the attacker from falsifying this data.

The proxy engine is in a unique situation that makes it ideal for hosting anti debugging techniques. In one aspect the proxy engine design can cause unexpected errors in the process when a debugger is attached. In another aspect of the response of a debugger the proxy engine can cause the anti debugging protected binary to execute an alternate code path. One aspect of this response is that the alternate code path is invisible to the debugger. Accordingly the debugger is unaware of the change in code path. The debugger is unaware because the choice of code path is performed in the kernel and not the application binary or the debugger itself. This may be termed call re routing because the call to execute the appropriate functional portion of code in section is changed. The changed or re routed call can be a call to a dummy function which essentially leads the debugger observer to either non functional or a false result. Using this re routing response the logical functionality of the binary may be twisted because calling any incorrect function will mislead the debugger and cause the expected functionality of the protected binary to be adversely disturbed. In implementation the addresses of both the real and the dummy functions are contained within the encrypted section making it difficult for the attacker to extract this call flow. During execution the proxy engine will call the appropriate function based on the presence of a debugger.

Another proxy execution engine response to the presence of a debugger is to crash the process. Essentially this option if taken by the proxy engine would permanently stop the execution of the anti debugging protected binary and thus prevent any debugger from performing reverse engineering on the protected binary . In implementation when anti debugging protected code executes and the exception is handled the proxy engine queries some system information to detect the existence of a debugger. If there is a debugger attached then instead of the proxy engine executing the proper instruction it will execute the dummy code and pass back the context. This will cause the process of the protected binary to exhibit unexpected behavior and will eventually crash the process in such a way that it is difficult to directly determine that proxy engine was the cause of the crash. If no debugger is attached execution will continue as normal. The crash results in an unexpected end to the protected process being performed by the binary.

Yet another response to the presence of a debugger is that the proxy engine can filter out any software breakpoints it handles. Thus for example if an interrupt such as the interrupt or other equivalent break is detected the proxy can simply negate the interrupt and ignore the debugger request. It should be noted that all of these protections leverage the same core functionality. In all cases the binary is instrumented in the same way as with a traditional proxy as explained herein except that it contains meta data for the anti debugging settings. In implementation the proxy engine due to its integration with the memory manager can filter any software breakpoints added to the binary prior to those breakpoints reaching first chance exception handlers. Filtering those debugger breakpoints out frustrates the purpose of the debugger.

Step in indicates that the application with the separated code such as in items and a rights client and a license evaluator are instantiated. The rights client attaches to the application in step . The application executes a triggering mechanism in step . the triggering mechanism typically being an interrupt a breakpoint or the like. As a result the application halts in step and the rights client notices the exception in step . Steps through are similar to steps through of .

Returning to the rights client using a proxy engine checks for the presence of a debugger in step by analyzing user mode and kernel mode debugger resources the use of interrupts the use of debugger communication ports and the like. Based on the analysis a decision is made as to the presence of a debugger in step . If no debugger is present the proxy execution engine executes the section of code associated with the exception at step . If the section of code to be executed by the proxy engine is encrypted then the engine first decrypts the code and processes the relevant code section. After processing is completed a signal is sent to the application at step that the exception was handled fully and that the application may proceed. It is noted that steps are similar to steps A F of where a license if present is checked to verify that the terms of the license are met before the proxy engine executes that relevant portion of code.

If at decision it is determined that a debugger is present then the method takes step and selects from a list of options designed to thwart the debugger. For instance one option as discussed above is to select to re route a call statement so that the process will eventually execute a dummy function. This selection may eventually lead to an address call to an incorrect section of code that leads the application to an undesired direction when the proxy engine eventually executes the dummy function. Another option is to select to crash the application binary. Another selection can be to intercept the interrupt or other breakpoint. Another selection may be to call any arbitrary function and redirect the application to that function

At step the selection made at step is executed. This involves performing the selected anti debugging operation such that reverse engineering of the application binary is prevented. As a result the would be recipient of the reverse engineering information is misled or otherwise stopped from gaining knowledge of the functionality of the protected application binary. In some instances as will be appreciated by those in the art a perception that the application binary is misbehaved may be present. In other instances it may be invisible to the would be recipient of the reverse engineering information that the proxy execution engine has misled the application binary. In either instance reverse engineering of the application binary is tangibly avoided. An operator of the debugger will likely observe that reverse engineering of the application binary has been halted or is incomplete. For example the result of an application crash is observable as a stalled application. The result of a re routed exception call is an unexpected operation that may be visible on a display. The result of an intercepted interrupt is a failure of the debugger to halt the application. These results are tangible evidence that the anti debugging protection if the application binary is working.

The programming necessary to effectuate the processes performed in connection with the present invention is relatively straight forward and should be apparent to the relevant programming public. Accordingly such programming is not attached hereto. Any particular programming then may be employed to effectuate the present invention without departing from the spirit and scope thereof.

In the present invention a method and mechanism are provided by which a rights client with a license evaluator control operation and use of an application based on a license corresponding thereto. The rights client with the license evaluator executes certain portions of code on behalf of and as a proxy for the application where the license evaluator can determine if the license allows such execution.

In the present invention a method and mechanism to detect the presence of a debugger utilizes a proxy execution engine. If a debugger is not present execution of an application binary proceeds as previously described. If a debugger is present then several options may be undertaken by the proxy engine to circumvent the possibility of reverse engineering the application binary. Each option relies on a pre established protected binary having code segments which are executed by a proxy engine.

It should be appreciated that changes could be made to the embodiments described above without departing from the inventive concepts thereof. It should be understood therefore that this invention is not limited to the particular embodiments disclosed but it is intended to cover modifications within the spirit and scope of the present invention as defined by the appended claims.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

