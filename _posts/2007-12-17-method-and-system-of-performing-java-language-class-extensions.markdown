---

title: Method and system of performing Java language class extensions
abstract: A method and system of performing Java language class extensions. At least some of the illustrative embodiments are computer-readable mediums storing a program that, when executed by a processor of a host system, causes the processor to identify a first class having a first name, and create a second class based on the first class (the second class is an abstract view of the first class, and the second class has a second name equal to a third name of a third class).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08381177&OS=08381177&RS=08381177
owner: Texas Instruments Incorporated
number: 08381177
owner_city: Dallas
owner_country: US
publication_date: 20071217
---
The present application claims priority to EP Application No. 07291168.8 filed on Sep. 28 2007 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation based on a plurality of bytecodes that define specific actions. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly. Many times a processor that directly executes Java bytecodes is paired with a general purpose processor to accelerate Java program execution.

To aid in the programming of Java groups of related classes are bundled into class libraries which are also referred to as a packages. Among other uses packages enable efficient code reusability. A Java Application Programming Interface API comprises a plurality of such packages. One exemplary package the Java language package java.lang comprises Java classes such as the object class java.lang.object that correspond to a set of classes that enable the execution of Java bytecodes. The Java language classes are provided by the Java API and are unique within any given Java platform. Stated otherwise each Java API is targeted to only one configuration of a Java Virtual Machine JVM . It would be desirable to define a methodology that would allow at least some JVM compatibility to any API configuration.

The problems noted above are solved in large part by a method and system of performing Java language class extensions. At least some of the illustrative embodiments are computer readable mediums storing a program that when executed by a processor of a host system causes the processor to identify a first class having a first name and create a second class based on the first class the second class is an abstract view of the first class and the second class has a second name equal to a third name of a third class .

Other illustrative embodiments are computer systems comprising a processor that executes bytecodes and a memory coupled to the processor. The processor identifies a first class having a first name. The processor creates a second class based on the first class the second class is an abstract view of the first class and the second class has a second name equal to a third name of a third class .

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

Optional processor may be referred to as a Micro Processor Unit MPU . System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise an Application Programming Interface implementation API and a Java Virtual Processor JVP discussed more below . The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

The MPU also may execute non Java instructions. For example the MPU may host an operating system O S which performs various functions such as system memory management system task management and most or all other native tasks running on the system management of the display and receiving input from input devices. Java code executed on the JVP may be used to perform any one of a variety of applications such as multimedia games or web based applications in the system while non Java code which may comprise the O S and other native applications may run on the MPU .

As discussed above the JVP provides a layer of abstraction. In particular the JVP is a virtual hardware platform that is compatible with any Java API any real hardware software platform that may comprise a JSM processor or any JVM implementation. In some exemplary embodiments the JVP comprises a JEK core that has an execution engine a memory management component and a compiler. The execution engine may comprise a Bytecode engine a class loader a notification manager and an external method interface. The memory management component may comprise a memory allocator an object mapper for physically constrained objects a garbage collector a memory defragmentor and a swapper. The compiler may comprise a dynamic compiler and provide code buffer management. The JEK core may also comprise firmware to facilitate the execution of Java Bytecodes on the JSM processor.

The JVP also provides the API with methods to create software class loaders. A class loader loads classes used by an application at runtime. Other hardware components of the hardware platform or software components are virtualized within the JEK as Java Virtual Devices JVD that communicate with the JEK core. Each JVD comprises some combination of fields methods and notifications. The fields may comprise standard Java fields or may be mapped to a predefined or constrained physical memory space wherein the constraint may be due to hardware or software. The fields may also comprise a map to indirect memories. The methods may comprise standard bytecodes or may comprises JSM native code hardware instructions or may use any kind of native interface such as a Java Native Interface JNI or a KVM Native Interface KNI . The notifications may be initiated by an event for example a hardware interrupt or from software. Additionally the JEK core manages native interface links and the notification mechanism provides a way to implement flexible monitoring.

To aid in the programming of Java groups of related classes are bundled into class libraries which are also referred to as a packages. Among other uses packages enable efficient code reusability. The Java API comprises a plurality of such packages. One exemplary package the Java language package java.lang comprises Java classes such as the object class java.lang.object that correspond to a set of classes that enable the execution of Java bytecodes. Classes may define attributes and behaviors. Behaviors are referred to as methods and classes may comprise one or more methods that define all the behaviors available within a given class. For example methods may request performing of an action such as setting a value returning a value or writing to a file. The object class java.lang.object is at the top of the class hierarchy and every other class inherits either directly or indirectly attributes and methods from the object class. In other words the object class is a superclass for all other classes in a given Java system.

Through the process of filtering a class loader may abstract the view of an existing class where the view is defined as the manner in which a Java application sees or handles a particular Java class. illustrates a method of filtering a class by way of a class loader. In particular the class loader may define a new filtered class as a filtered view of another already defined class. In some exemplary embodiments the class loader performing the filtering is implemented by the JVP. As shown in a class loader retrieves a class and passes it through a filter resulting in a filtered class . The area indicated by arrows may be referred to as the view and the area indicated by arrows may be referred to as the filtered view . Thus the filtering of a class creates a filtered class which is a filtered view of the unfiltered class . In some embodiments the filtering may be accomplished by a set of Java annotations i.e. a set of modifiers where the annotations may be applied to a class a class member or a method parameter in order to modify its top level view. An example of an annotation is a name annotation which allows for the renaming of a class field or a method. Thus a filtered class may be a renamed version of an unfiltered class where the filtered class has a filtered name . Classes fields or methods that do not have a name annotation keep their original name. Another example of an annotation is a visibility annotation which allows changing the visibility of a class field or a method. For example in embodiments of the present invention only classes that have an appropriate visibility annotation will be available to Java applications during runtime. Classes fields or methods that do not have a visibility annotation are by default considered to be invisible with respect to the Java applications and to the filtered classes. In other words only classes within the filtered view are accessible i.e. visible to the Java applications and to other filtered classes. The filtering process in not restricted to renaming or changing the visibility of an individual or group of classes fields or methods. In some embodiments other distinct modifiers can be applied to any individual or group of classes fields or methods. In addition the filtering process is not restricted to Java annotations. For instance in alternative embodiments filtering may be accomplished by way of extensible markup language XML files or a dedicated JVP API. illustrates a method similar to that of where the class loader retrieves and filters the class resulting in a filtered class . However in the filter is comprised within the class loader .

The view abstraction method carried out by the system of may be implemented according to various embodiments. In some exemplary embodiments the object class is programmed with a name such as myconf.lang.object prior to runtime. As described with reference to the class loader of the JVP retrieves and filters the class myconf.lang.object i.e. the object class such that a new filtered class is created where the filtered class is a filtered view i.e. an abstract view of myconf.lang.object i.e. the object class of the API . The filtering process may also perform a renaming such that the filtered class has a different name than the object class from which it was derived. In the present example the filtered class is named java.lang.object while the unfiltered object class retains its original name of myconf.lang.object . Moreover the filtering process may change the visibility of a class. For example the applications may access i.e. view the renamed filtered class java.lang.object based on appropriate visibility annotations that have been applied during the filtering process. Java.lang.object object class remains as the only real language class however the object class remains invisible to the Java applications since classes that do not have a visibility annotation are by default considered to be invisible with respect to the Java applications as well as to the filtered class as discussed above . In addition the object class remains invisible to the Java applications since it remains within the unfiltered view i.e. view of . Thus by this filtering method the object class myconf.lang.object that the API intended to provide to the applications is still provided by way of the filtered class . Additionally potential conflicts with the object class java.lang.object are avoided. In some exemplary embodiments following a similar view abstraction method as described with respect to the object class of the JVP may be provided to the applications by way of the filtered class . For purposes of this disclosure the filtered class may be referred to as a global class. The term global here does not mean that the filtered class may be accessed across an entire Java system such as system in fact the filtered class is only visible to the applications . Rather the term global is used to describe the fact that the abstract filtered class can be used to provide to the applications any of a plurality of classes from the API or from the JVP while avoiding potential conflicts e.g. with the object class .

The filtered class is not a new class. Rather the filtered class is an abstract view of the object class as discussed above. Consequently an instance of the object class is compatible with an instance of the filtered class where compatible is defined as having the same structure in memory e.g. the same fields at the same offset . For example in an instance of the object class is viewed in the API as an instance of the object class and the same instance of the object class is viewed in the Java applications as an instance of the filtered class . Thus an instance of the object class created in API could be passed to the Java applications or an instance of the filtered class created in the Java applications could be passed to the API . There is no overhead at runtime to access fields or invoke methods of an instance of the object class in the API nor in the Java applications . The filtered class remains a pure abstract view of the object class which describes the instance and remains as a real class.

System may be implemented as a mobile cell phone such as that shown in . As shown the mobile communication device has an outer enclosure and includes an integrated keypad and display . The JSM processor and MPU processor and other components may be included in electronics package connected to the keypad display and radio frequency RF circuitry . The RF circuitry may be connected to an antenna .

From the description provided herein those skilled in the art are readily able to combine software created as described with appropriate general purpose or a special purpose computer hardware to create a computer system and or computer subcomponents embodying aspects of the invention to create a computer system and or computer subcomponents for carrying out the method embodiments of the invention and or to create a computer readable medium storing a software program to implement method aspects of the various embodiments. Moreover the embodiments of the illustrative methods could be implemented together in a single program with various subroutines or split up into two or more programs executed on the processor.

While various embodiments of the invention have been shown and described modifications thereof can be made by one skilled in the art without departing from the spirit and teachings of the invention. The embodiments described herein are illustrative only and are not intended to be limiting. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

