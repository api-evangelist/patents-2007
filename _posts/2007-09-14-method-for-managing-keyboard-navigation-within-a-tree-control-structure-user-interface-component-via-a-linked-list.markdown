---

title: Method for managing keyboard navigation within a tree control structure user interface component via a linked list
abstract: A method, data processing system and computer program product for maintaining/updating managing keyboard navigation using a linked list. In particular, a Dynamic Tree Control Linkage (DTCL) utility creates a doubly linked list with list nodes having assigned values based on a tree control structure UI component. Each list node of the doubly linked list corresponds to a visible tree item of the tree structure UI component. Responding to a keyboard event signal, the DTCL utility finds a current list node corresponding to a first current tree item. The DTCL utility finds a next (i.e. previous or subsequent) list node corresponding to a next tree item. The DTCL utility detects a list node exists. The DTCL utility detects whether the next list node is associated with a null value. When the next list node is associated with a non-null value, the next tree item is identified. The DTCL utility returns an identification of the next tree item representing a second current tree item. The DTCL utility also updates the doubly linked list in response to the expansion/collapsion of the current list item. The DTCL utility avoids the need to number all tree items (both visible and hidden tree items) sequentially by adding list node(s) to or removing list node(s) from the linked list to represent the visible tree items.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07844637&OS=07844637&RS=07844637
owner: International Business Machines Corporation
number: 07844637
owner_city: Armonk
owner_country: US
publication_date: 20070914
---
The present invention generally relates to computer systems and in particular to a method and system for managing keyboard navigation within a tree control structure user interface UI .

Navigating through a Dynamic HyperText Markup Language HTML based tree control structure UI component can present challenges to users who require assistive technologies. Conventional HTML based implementations of a tree control operation have generally utilized mouse navigation. Mouse navigation obviates the problem of determining the next i.e. previous or subsequent node to navigate to since the user controls mouse navigation by directly clicking on a tree item to set focus to the tree item. However in the case of users requiring assistive technologies keyboard navigation as opposed to mouse navigation is the preferred tool with which the user can navigate through a tree control structure.

Implementing keyboard navigation of a tree control structure does present some challenges. In a Dynamic HTML based tree control structure UI component providing keyboard navigation to a tree control structure is difficult because of the varying expanded and collapsed states of tree nodes. In contrast to mouse navigation keyboard navigation requires arrowing up and down within a tree control structure until the desired item is reached. For example when arrowing down in a tree control structure all of the expanded or visible intermediate tree items of a particular branch are navigated to before navigating to the next desired tree item.

In keyboard navigation of a tree control structure determining the subsequent and previous nodes when traversing the tree control structure depends upon the expanded and collapsed state of the tree items of the tree control structure. One possible way to determine the next tree item to traverse when navigating through the tree control structure is to identify each tree item in the tree control structure based on the tree item s order within the tree control structure when all of the tree items are expanded and to mark each tree item as visible or hidden. Thus to navigate down the tree control structure the current tree item would be queried for the current tree item s identification ID which is usually associated with a numeral such that the next item in the tree would be identified as ID 1. The ID 1 tree item would be obtained and queried to determine if the ID 1 tree item is expanded ID 1 s children are visible. If the ID 1 tree item is visible ID 1 would become the next navigable tree item. However if ID 1 is not visible the search would continue for the next visible tree item by adding 1 again and querying the next tree item i.e. ID 2 . Thus in order to traverse downwards in the tree each subsequent tree item after the current tree item would have to be queried to determine whether each subsequent tree item is visible or not.

Continuing with the method described above when a particular tree item is collapsed all of the children of that particular tree item would need to be updated to reflect that the children are no longer visible. Likewise when a particular tree item is expanded all of the children of that particular tree item would need to be updated to reflect that the children are now visible. Notably the updating of collapsed or expanded tree items requires a recursive search since tree items may themselves contain additional branch tree items each branch tree item having its own collapsed or expanded state. This method of i ordering nodes in sequential order ii keeping track of the expanded and collapsed state of each branch tree item and iii keeping track of the visible and hidden state of all the tree items is deemed too complex for conventional keyboard navigation of a tree control structure.

Another method for keyboard navigation of a tree control structure is to number the tree items sequentially based on their respective level within the tree control structure s hierarchy. The level in the hierarchy would be used as the ID of the tree item. At each subsequent level in the hierarchy the numbering would begin again. In addition each tree item would be labeled as expanded or collapsed. Under such an implementation when arrowing down the current tree item would be identified and checked to see if the current tree item has children. If the tree item has children and is expanded first child of the tree item would be deemed the next tree item. If the tree item either does not have children as in the case of a leaf tree item or is not expanded the next tree item would be the current tree item number 1. Similar to the first method disclosed above this second method also represents a complex scheme because the second method relies on the numbering of tree items in a specific sequence for determining the next tree item to which to navigate. Moreover neither of the above methods can be implemented if tree items have been added or removed from the tree control structure after the tree structure has been created and the IDs of the tree items have been assigned.

Disclosed are a method system and computer program product for managing keyboard navigation within a tree control structure UI component. In particular a Dynamic Tree Control Linkage DTCL utility creates a doubly linked list with list nodes having assigned values based on a tree control structure UI component. Each list node of the doubly linked list corresponds to a visible tree item of the tree structure UI component. Responding to a keyboard event signal e.g. keyboard upward arrow signal keyboard downward arrow signal keyboard side arrow signal previous subsequent button key the DTCL utility finds a current list node corresponding to a first current tree item. The DTCL utility finds a next i.e. previous or subsequent list node corresponding to a next tree item. The DTCL utility detects a list node exists. The DTCL utility detects whether the next list node is associated with a null value. When the next list node is associated with a non null value the next tree item is identified. The DTCL utility returns an identification of the next tree item representing a second current tree item. The DTCL utility also updates the doubly linked list in response to the expansion collapsion of the current list item. The DTCL utility avoids the need to number all tree items both visible and hidden tree items sequentially by adding list node s to or removing list node s from the linked list to represent the visible tree items.

The above as well as additional objectives features and advantages of the present invention will become apparent in the following detailed written description.

The illustrative embodiments provide a method system and computer program product for managing keyboard navigation within a tree control structure user interface UI component using a linked list. As utilized herein a tree control structure is a hierarchical structure that represents branch and leaf items. Branch items are tree items that contain children such as other branch items and leaf items. A leaf item is at the end of the branch item and has no children. As utilized herein a linked list is a fundamental data structure that consists of a sequence of nodes. Each node contains arbitrary data fields and one or two references i.e. links pointing to the next i.e. subsequent or previous list node. The principal benefit of a linked list over a conventional array is that the order of the linked items may be different from the order that the data items are stored in memory or on disk allowing the list of items to be traversed in a different order. A linked list is a self referential datatype because the linked list contains a pointer or link to another datum of the same type. Linked lists permit insertion and removal of nodes at any point in the list in constant time but do not allow random access. Several different types of linked lists exist singly linked lists doubly linked lists and circularly linked lists. In particular a dynamic tree control linkage DTCL utility obviates the need to number branch and leaf tree items sequentially by adding list node s to or removing list node s from the linked list to represent the visible tree items.

In the following detailed description of exemplary embodiments of the invention specific exemplary embodiments in which the invention may be practiced are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that logical architectural programmatic mechanical electrical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

It is understood that the use of specific component device and or parameter names are for example only and not meant to imply any limitations on the invention. The invention may thus be implemented with different nomenclature terminology utilized to describe the components devices parameters herein without limitation. Each term utilized herein is to be given its broadest interpretation given the context in which that term is utilized.

With reference now to depicted is a block diagram representation of a data processing system DPS and connected network . DPS comprises at least one processor or central processing unit CPU connected to system memory via system interconnect bus . Also connected to system bus is I O controller which provides connectivity and control for input devices of which pointing device or mouse and keyboard are illustrated and output devices of which display is illustrated. Additionally a multimedia drive e.g. CDRW or DVDRW drive and Universal Serial Bus USB hub are illustrated coupled to I O controller . Multimedia drive and USB hub may operate as both input and output storage mechanisms. DPS also comprises storage within which data instructions code may be stored. DPS is also illustrated with a network interface device NID coupled to system bus . NID enables DPS to connect to one or more servers via an access network such as the Internet.

In the described embodiments when access network is the Internet access network represents a worldwide collection of networks and gateways that utilize the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. Of course network access may also be provided via a number of different types of networks such as an intranet an Ethernet a Local Area Network LAN a Virtual Private Network VPN or other Wide Area Network WAN other than the Internet for example.

Notably in addition to the above described hardware components of DPS various features of the invention are completed via software or firmware code or logic stored within system memory or other storage e.g. storage and executed by CPU . In one embodiment data instructions code from storage populates the system memory which is also coupled to system bus . System memory is defined as a lowest level of volatile memory not shown including but not limited to cache memory registers and buffers. Thus illustrated within system memory are a number of software firmware components including operating system OS e.g. Microsoft Windows a trademark of Microsoft Corp or GNU Linux registered trademarks of the Free Software Foundation and The Linux Mark Institute or Advanced Interactive eXecutive AIX registered trademark of International Business Machines IBM applications APP and Dynamic Tree Control Linkage DTCL utility . In actual implementation components or code of OS may be combined with those of DTCL utility collectively providing the various functional features of the invention when the corresponding code is executed by the CPU . For simplicity DTCL utility is illustrated and described as a stand alone or separate software firmware component which is added to an existing OS to provide support the specific novel functions described herein.

CPU executes DTCL utility as well as OS which supports the UI features of DTCL utility . In the illustrative embodiment DTCL utility manages keyboard navigation within a tree control structure UI through the creation and use of a linked list. Among the software code instructions provided by DTCL utility and which are specific to the invention are a code for creating a linked list b code for receiving a keyboard event signal c code for finding a current list node in the linked list d code for finding a next list node i.e. subsequent list node or previous list node in the linked list e code for determining whether a next list node contains a null value f responsive to receipt of a non null value for the next list node code for identifying next tree item of next list node and returning the identification ID of the next tree item. For simplicity of the description the collective body of code that enables these various features is referred to herein as DTCL utility . As used herein the term next refers to either i a previous or subsequent tree item or ii a previous or subsequent list node. According to the illustrative embodiment when CPU executes DTCL utility DPS initiates a series of functional processes that enable the above functional features as well as additional features functionality which are described below within the description of .

Those of ordinary skill in the art will appreciate that the hardware and basic configuration depicted in may vary. For example other devices components may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention. The data processing system depicted in may be for example an IBM eServer pSeries system a product of International Business Machines Corporation in Armonk N.Y. running the AIX operating system or LINUX operating system.

Within the descriptions of the figures similar elements are provided similar names and reference numerals as those of the previous figure s . Where a later figure utilizes the element in a different context or with different functionality the element is provided a different leading numeral representative of the figure number e.g. for for or B . The specific numerals assigned to the elements are provided solely to aid in the description and not meant to imply any limitations structural or functional on the invention.

With reference now to and A an exemplary initial tree control structure and a doubly linked list are illustrated according to one embodiment of the invention. The initial tree control structure contains one or more tree items e.g. Items . . and in a hierarchical order. Using the example illustrated in the tree control structure includes root item parent branch item which in turn contains sibling leaf items . and .. Moreover Items and of tree control structure are also leaf tree items since neither one has children.

Each tree item of tree control structure is represented by an object not shown . The process of representing tree items using objects is well known in the art of standard programming techniques. Each tree item object is identified by a unique ID which for exemplary purposes is labeled itemID where ID is represented by a numeral. Using JavaScript scripting language for example the tree item object can be obtained via a standard application programming interface API document.getObjectById itemID . Obtaining an object via a unique ID is standard in most programming languages. Note that although the exemplary embodiment of the invention is described using JavaScript scripting language the invention should not be limited in this regard and any number of scripting languages may be used to perform the same function.

Each tree item object maintains a list of its children. JavaScript maintains child information in an array. In addition each tree item object maintains the state of the tree item. As utilized herein the state of a tree item is defined as either expanded or collapsed. When a tree item is expanded the item s immediate children are visible. When a tree item is collapsed the item s immediate children are not visible. For example tree control structure in FIGS. A shows how ITEM has already been expanded to reveal its children ITEMS . and .. Conversely collapsing tree ITEM would remove tree ITEMS . and . from view leaving a visible tree hierarchy composed exclusively of sibling ITEMS as illustrated in .

Typical keyboard navigation through tree control structure would require one or more keyboard events i.e. the press of a key . Keyboard navigation usually requires arrowing up and down within the tree control structure until the desired item is reached. When arrowing up down in a tree control all of the expanded tree items of a particular branch are traversed before navigating to the next tree item. For example if a user starts with focus at the root item in tree control structure and arrows down with keyboard FIG. 1 the tree items would be traversed in the following order item item . item . item item . In like fashion traversing up from item of tree control structure would follow the reverse order item item . item . item . In addition the expansion or collapse of a tree item would similarly require one or more keyboard events i.e. the press of a key . For example typical expansion of a tree item using keyboard navigation requires the arrowing right on a keyboard when a current tree item within a tree control structure is selected. Similarly typical collapse of a tree item using keyboard navigation requires the arrowing left on a keyboard when a current tree item within a tree control structure is selected. However it should be understood that the invention is not limited to the particular. keyboard events described in the embodiment. In this regard keyboard keys other than arrow keys may be configured for navigating and updating i.e. expanding collapsing a tree control structure .

According to one embodiment of the invention doubly linked list is created based on initial tree control structure . As used herein doubly linked list is a type of linked list whereby each node has two links i a first link points to the previous node or points to a null value or empty list if the node is the first node and ii a second link points to the subsequent node or points to a null value or empty list if the node is the final node. As illustrated in doubly linked list includes multiple list nodes . Each list node references a particular tree item e.g. list node corresponds to list item of tree control structure i.e. ITEM . Note that the root item of tree control structure is not included in linked list . Notably the linked list and in particular each list node of the linked list maintains references to each of the visible tree items of tree control structure respectively via the unique itemIDs associated with each tree item object. For example and shows how visible tree items . . and are represented respectively by list nodes . . and . However when tree item of is collapsed as shown in the linked list is modified by the removal of list nodes to reflect only the remaining visible tree items and .

DTCL utility initiates a process to create a ListNode class using scripting language. DTCL utility creates linked list when the tree control structure is first created. The head of linked list i.e. list node is stored as a variable in a TreeControl object. A determination is made as to whether one of the tree items illustrated in A or B is expanded. Responsive to the expansion of a tree item the list node containing the itemID of the expanded node is found in the linked list. Responsive to the rendering of one or more children in HTML a new node is created for each child and inserted into the linked list. Conversely when a tree item is collapsed the child nodes of the collapsed parent node are removed from the navigation linked list. The subseq and prey variables in ListNode store references to the subsequent and previous nodes in linked list . This mechanism is effective because the information is stored by reference. As a result the mechanism avoids storing multiple copies of list nodes in system memory .

Depending upon where the expansion collapsion occurs on the tree control structure the subseq and prey variables in list nodes may be updated when a list node is added to or removed from the linked list . For example when tree item of is collapsed as shown in only list nodes and are updated and list node remains unchanged. Specifically the linked list is updated by i the removal of list nodes ii by changing the value of the subseq variable of list node to point to list node and iii by changing the value of the prey variable of list node to point to list node as illustrated in . Moreover the linked list implementation contains additional functions to find add and remove list nodes from the linked list .

The process of begins at initiator block and proceeds to block at which DTCL utility creates a linked list based on an initial tree control structure . To achieve initial creation of linked list a ListNode class is created employing a scripting language such as JavaScript . Given that tree items have a unique itemID the itemID is stored in the item variable of the ListNode class when the corresponding ListNode class is created.

The process continues with decision block in which a determination is made as to whether DTCL utility has received a keyboard event i.e. the arrowing up down of button on keyboard . If no keyboard event takes place the process returns to decision block and awaits a keyboard event. Responsive to a keyboard event a current list node in linked list is searched given the starting list node as depicted in block . A determination is made as to whether the next list node exists as depicted in block . The above determination in block is based on whether the next ListNode contains a null value i.e. indicating that next list node is empty next list node does not exist . If the next ListNode contains a null value the process returns an error as depicted in block because the current list node is not found on the linked list . If next ListNode contains a non null value i.e. the next list node exists another determination is then made as to whether the list node containing the current tree item is found as depicted in block . To determine whether the list node corresponding to the current tree item is found the itemID value referenced by listNode must be equal to the ID value of the current tree item i.e. treeItemID . If the treeItemID value of the current tree item is the same as the itemID value referenced by listNode the process returns the value of listNode i.e. indicating that list node containing current tree item is found and then a reference to the next list node is found as depicted in block . However if the current tree item is not the same as the itemID referenced by listNode a command is executed to retrieve the next list node in the linked list as depicted in block . This search process continues until the list node corresponding to the current tree item is retrieved.

Having retrieved the list node corresponding to the current tree item a find command is executed to find the next list node previous or subsequent list node relative to list node of current tree item in the linked list as depicted in block . A determination is made as to whether the next list node contains a non null value as depicted in block . If the next list node has a null value an error is returned indicating that there is no next list node to navigate to as depicted in block . However if the next list node has a non null value a command is executed to identify the next tree item of the next list node as depicted in block . Once identified a command to retrieve the tree itemID of the next tree item is executed as depicted in block and the process terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary method of updating linked list when a current tree item object having hidden children is expanded i.e. children are made visible . For exemplary purposes only it is assumed that ITEM of tree control structure contains children ITEMS . and . which are currently hidden i.e. not currently visible in tree control structure . The process begins at block in response to an updating command signal to expand a current tree item object. Beginning at the start of linked list a search for the list node containing the itemID for current tree item e.g. ITEM of tree control structure is undertaken as depicted in block . If the list node for the current tree is not found the process returns as though the expansion of the linked list has been completed as depicted in block . However if the list node for the current tree item is found as depicted in decision block the first child i.e. ITEM . of current tree item ITEM is retrieved . Beginning at the corresponding current parent node node of linked list a search is executed for the corresponding list node for current child tree item ITEM . as depicted in block .

At decision block a determination is made as to whether the corresponding list node for current child tree item has been found. If the corresponding list node for the current child tree item is not found a new linked list node for the current child tree item is created and added to linked list after the parent list node in this instance the parent list node is node FIG. A as depicted in block . If either i the corresponding list node for the child tree item is found from decision block or ii the new linked list node for the current child tree item is created and added at block a determination is made as to whether the current child tree item has its own visible children as depicted in block . If the current child ITEM . has visible children of its own which in the current example ITEM . does not the current child i.e. ITEM . would then become the current tree item as depicted in block and the process would return to block . However if the current child i.e. ITEM . does not have visible children the next determination that is made is whether the current child i.e. ITEM . has a visible sibling as depicted in decision block . In this example ITEM . has a visible sibling i.e. ITEM . . Thus the next sibling ITEM . would become the current child tree item as depicted in block and the process would return to block . Once it is determined that the current child tree item does not have a next visible sibling the process returns to the parent tree list node and the aforementioned steps are repeated in a recursive manner until all progeny i.e. all children and children s children of parent tree items i.e. ITEM ITEM ITEM have been added to the linked list . Once all visible progeny have been added to the linked list the expansion of the linked list is completed as depicted in block . The process terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary method of updating linked list when a current branch tree item object is collapsed i.e. children are made hidden . For exemplary purposes only it is assumed that branch ITEM of tree control structure containing child leaf ITEMS . and . i.e. currently visible in tree control structure . The process begins at block in response to an updating command signal to collapse a current tree item object i.e. ITEM of tree control structure . Beginning at the start of linked list a search for the list node containing the itemID for current tree item e.g. ITEM of tree control structure is undertaken as depicted in block . If the list node for current tree item is not found the process returns as though the update of the linked list has been completed as depicted in block . However if the list node for the current tree item is found as depicted in decision block the first child i.e. ITEM . of current tree item ITEM is retrieved .

In decision block a determination is made as to whether the current child tree item i.e. ITEM . of the current parent tree item has visible children. If the current child tree item of the current parent tree does not have visible children the list node for the current child tree item is retrieved as depicted in block . Turning now to block the list node i.e. list node corresponding to the current child tree item ITEM . after the current parent list node i.e. list node is removed. The removal of the list node for the child tree item occurs after the current parent list node from the linked list.

A determination is then made as to whether the current child tree item has a next visible sibling as depicted in decision block . According to the example shown in ITEM . has a next visible sibling ITEM . . As a result sibling ITEM . becomes the current child tree item and the process loops back to block as depicted in block . According to tree control structure there appears that ITEM . does not contain any visible children.

If the current child tree item has visible children the process continues on to block in which all visible children are processed via recursion. As used herein the phrase process via recursion means the process returns to the parent list node and the previous steps are repeated until all progeny of the parent tree item are removed from linked list as illustrated in and depicted in block . Once it is determined that the current child tree item does not have a next visible sibling the process returns an indication that the update of linked list is now complete and list node ITEMs . and . have been removed from the linked list as depicted in block . The process terminates at block .

In the flow charts above one or more of the methods are embodied in a computer readable medium containing computer readable code such that a series of steps are performed when the computer readable code is executed on a computing device. In some implementations certain steps of the methods are combined performed simultaneously or in a different order or perhaps omitted without deviating from the spirit and scope of the invention. Thus while the method steps are described and illustrated in a particular sequence use of a specific sequence of steps is not meant to imply any limitations on the invention. Changes may be made with regards to the sequence of steps without departing from the spirit or scope of the present invention. Use of a particular sequence is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

As will be further appreciated the processes in embodiments of the present invention may be implemented using any combination of software firmware or hardware. As a preparatory step to practicing the invention in software the programming code whether software or firmware will typically be stored in one or more machine readable storage mediums such as fixed hard drives diskettes optical disks magnetic tape semiconductor memories such as ROMs PROMs etc. thereby making an article of manufacture in accordance with the invention. The article of manufacture containing the programming code is used by either executing the code directly from the storage device by copying the code from the storage device into another storage device such as a hard disk RAM etc. or by transmitting the code for remote execution using transmission type media such as digital and analog communication links. The methods of the invention may be practiced by combining one or more machine readable storage devices containing the code according to the present invention with appropriate processing hardware to execute the code contained therein. An apparatus for practicing the invention could be one or more processing devices and storage systems containing or having network access to program s coded in accordance with the invention.

Thus it is important that while an illustrative embodiment of the present invention is described in the context of a fully functional computer server system with installed or executed software those skilled in the art will appreciate that the software aspects of an illustrative embodiment of the present invention are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the present invention applies equally regardless of the particular type of media used to actually carry out the distribution. By way of example a non exclusive list of types of media includes recordable type tangible media such as floppy disks thumb drives hard disk drives CD ROMs DVD ROMs and transmission type media such as digital and analog communication links.

While the invention has been described with reference to exemplary embodiments it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition many modifications may be made to adapt a particular system device or component thereof to the teachings of the invention without departing from the essential scope thereof. Therefore it is intended that the invention not be limited to the particular embodiments disclosed for carrying out this invention but that the invention will include all embodiments falling within the scope of the appended claims. Moreover the use of the terms first second etc. do not denote any order or importance but rather the terms first second etc. are used to distinguish one element from another.

