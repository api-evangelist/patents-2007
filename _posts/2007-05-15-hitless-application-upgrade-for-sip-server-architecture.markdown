---

title: Hitless application upgrade for SIP server architecture
abstract: The Session Initiation Protocol (SIP) server can be comprised of an engine tier and a state tier distributed on a cluster network environment. The engine tier can send, receive and process various messages. The state tier can maintain in-memory state data associated with various SIP sessions. Various applications can be running on the engine tier. A new version of an application can be deployed alongside the old version, simultaneously running on the SIP server. Incoming messages for new calls can be directed by the SIP server to the new version of the application. Incoming messages for previously established calls can be directed to the old version of the application. Once the old version is finished processing calls, it can be undeployed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08171466&OS=08171466&RS=08171466
owner: Oracle International Corporation
number: 08171466
owner_city: Redwood Shores
owner_country: US
publication_date: 20070515
---
The present application claims the benefit of U.S. Provisional Patent Application No. 60 800 943 entitled HITLESS APPLICATION UPGRADE FOR SIP SERVER ARCHITECTURE by Anno R. Langen et al. filed on May 16 2006 which is incorporated herein by reference in its entirety.

The following commonly owned co pending U.S. patents and patent applications including the present application are related to each other. Each of the other patents applications are incorporated by reference herein in their entirety 

U.S. patent application Ser. No. 11 378 188 entitled SYSTEM AND METHOD FOR MANAGING COMMUNICATIONS SESSIONS IN A NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. patent application Ser. No. 11 384 056 entitled SYSTEM AND METHOD FOR A GATEKEEPER IN A COMMUNICATIONS NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. Provisional Patent Application No. 60 801 091 entitled SIP AND HTTP CONVERGENCE IN NETWORK COMPUTING ENVIRONMENTS by Anno R. Langen et al. filed on May 16 2006 

U.S. Provisional Patent Application No. 60 801 083 entitled ENGINE NEAR CACHE FOR REDUCING LATENCY IN A TELEOMMUNICATIONS ENVIRONMENT by Anno R. Langen et al. filed on May 16 2006 

U.S. Patent Application No. 11 434 022 entitled SYSTEM AND METHOD FOR CONTROLLING DATA FLOW BASED UPON A TEMPORAL POLICY by Narendra Vemula et al. filed on May 15 2006 

U.S. patent application No. 11 434 024 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY PUSH PROTOCOLS BASED UPON A POLICY by Bengt Inge Jakobsson et al. filed on May 15 2006 

U.S. patent application No. 11 434 010 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY MULTIMEDIA MESSAGE PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 

U.S. patent application No. 11 434 025 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY SHORT MESSAGE PEER TO PEER PROTOCOLS BASED UPON A POLICY by Andreas E. Jansson filed on May 15 2006 

U.S. patent application No. 11 432 934 entitled SYSTEM AND METHOD FOR SHAPING TRAFFIC by Jan Thomas Svensson filed on May 12 2006.

A portion of this disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyrights whatsoever.

The current invention relates generally to managing telecommunications and more particularly to upgrading applications within a network environment.

Conventionally telecommunications and network infrastructure providers have relied on often decades old switching technology to providing routing for network traffic. Businesses and consumers however are driving industry transformation by demanding new converged voice data and video services. The ability to meet these demands often can be limited by existing IT and network infrastructures that are closed proprietary and too rigid to support these next generation services. As a result telecommunications companies are transitioning from traditional circuit switched Public Switched Telephone Networks PSTN the common wired telephone system used around the world to connect any one telephone to another telephone to Voice Over Internet Protocol VoIP networks. VoIP technologies enable voice communication over vanilla IP networks such as the public Internet. Additionally a steady decline in voice revenues has resulted in heightened competitive pressures as carriers vie to grow data service revenues and reduce churn through the delivery of these more sophisticated data services. Increased federal regulation security and privacy issues as well as newly emerging standards can further compound the pressure.

However delivering these more sophisticated data services has proved to be more difficult than first imagined. Existing IT and network infrastructures closed proprietary network based switching fabrics and the like have proved to be too complex and too rigid to allow the creation and deployment of new service offerings. Furthermore latency and migration of services have become important issues in addressing the processing of telecommunications as more and more users expect seemingly instantaneous and uninterrupted access to their devices.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. References to embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

In the following description numerous specific details are set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail so as not to obscure the invention.

Although a diagram may depict components as logically separate such depiction is merely for illustrative purposes. It can be apparent to those skilled in the art that the components portrayed can be combined or divided into separate software firmware and or hardware components. For example one or more of the embodiments described herein can be implemented in a network accessible device appliance such as a router. Furthermore it can also be apparent to those skilled in the art that such components regardless of how they are combined or divided can execute on the same computing device or can be distributed among different computing devices connected by one or more networks or other suitable communication means.

In accordance with embodiments there is provided a hitless application upgrade for a session initiation protocol SIP server architecture. A SIP server can be comprised of an engine tier and a state tier distributed on a cluster network environment. The engine tier can include a set of engine nodes that send receive and process various messages. The state tier can include a set of state tier replica nodes that maintain in memory state data associated with various SIP sessions. Applications can be deployed and executed on the engine tier. These applications can be adapted to process telecommunication sessions data and calls such as via the SIP protocol. In certain embodiments an application may need to be upgraded or modified such as by re compiling and re deploying the application onto the engine tier.

In one embodiment a new version of an application can be deployed alongside an old version which is simultaneously running on the SIP server. Subsequently incoming messages for new calls can be directed by the SIP server to the new version of the application. Incoming messages for previously established calls can be directed to the old version of the application. In one embodiment once the old version has completed processing all of its calls it can be un deployed. In this manner an application can be upgraded to a new version without affecting any existing call processing.

A Session Initiation Protocol SIP Server and a Network Gatekeeper can comprise a portfolio of products that collectively make up the Communications Platform . The SIP Server provides the Communications Platform with a subsystem in which application components that interact with SIP based networks may be deployed. The Network Gatekeeper provides a policy driven telecommunications Web services gateway that allows granular control over access to network resources from un trusted domains.

A variety of shared and re usable software and service infrastructure components comprise the Communications Platform . For example an Application Server such as the WebLogic Application Server by BEA Systems Inc. of San Jose Calif. This Application Server may be augmented and adapted for deployment in telecommunications networks while providing many features and functionality of the WebLogic Server counterpart widely deployed in enterprise computing environments. Application Server embodiments for use in the telecommunications applications can provide a variety of additional features and functionality such as without limitation 

Analogously communications platform embodiments can provide a variety of additional features and functionality such as without limitation 

Communications platform comprises a SIP Server WLSS and a Network Gatekeeper WLNG . Tools for interacting with Web Services such as a Web Service Universal Description Discovery Interface WS UDDI a Web Service Business Process Execution Language WS BPEL may be coupled to the SIP Server and the Network Gatekeeper in embodiments. A log trace and database can assist with troubleshooting. In some deployments the Communications Platform can interface with an OSS BSS system via resource adapters . Such interfaces can provide access to billing applications Operation Administration and Maintenance OAM applications and others. A policy engine can control the activities of the above described components which can be implemented in a scalable cluster environment SCE .

A Communications Platform embodiment can provide an open high performance software based fault tolerant platform that allows operators to maximize revenue potential by shortening time to market and significantly reducing per service implementation and integration cost and complexity. The Communications Platform is suitable for use by for Network Infrastructure Vendor Network Operators and Communications Service Providers in multiple deployment scenarios ranging from fully IMS oriented network architectures to hybrid and highly heterogeneous network architectures. It is not restricted to use only in carrier networks however and may be deployed in Enterprise communications networks without restriction or extensive customization. When deployed in conjunction with an IP Multimedia Subsystem the Communications Platform can serve in the role of an IMS SIP Application Server and offers Communications Service Providers an execution environment in which to host applications such as the WebLogic Network Gatekeeper components and standard service enablers.

As illustrated the SIP server can be used as a back to back user agent B2BUA in a typical telecommunications environment. A B2BUA can take the place of an intermediary between communications between user agents including various cellular phones wireless devices laptops computers applications and other components capable of communicating with one another electronically. The B2BUA can provide multiple advantages including controlling the flow of communication between user agents enabling different user agents to communicate with one another e.g. a web application can communicate with a cellular phone as well as various security advantages. As an illustration the user agents can transmit to the SIP server instead of communicating directly to each other and thus malicious users can be prevented from sending spam and viruses hacking into other user agent devices and otherwise compromising security.

The SIP server can be implemented as a Java Enterprise Edition application server that has been extended with support for the session initiation protocol SIP as well as other operational enhancements that allow it to meet the demanding requirements of the next generation protocol based communication networks. In one embodiment the SIP server can include an Enterprise Java Beans EJB container a Hyper Text Transfer Protocol HTTP servlet container an SIP servlet container various Java 2 Enterprise Edition J2EE services and SIP and HTTP components. The SIP stack of the server can be fully integrated into the SIP servlet container and can offer much greater ease of use than a traditional protocol stack. A SIP servlet Application Programming Interface API can be provided in order to expose the full capabilities of the SIP protocol in the Java programming language. The SIP servlet API can define a higher layer of abstraction than simple protocol stacks provide and can thereby can free up the developer from concern about the mechanics of the SIP protocol itself. For example the developer can be shielded from syntactic validation of received requests handling of transaction layer timers generation of non application related responses generation of fully formed SIP requests from request objects which can involve correct preparation of system headers and generation of syntactically correct SIP messages and handling of lower layer transport protocols such as TCP UDP or SCTP.

In one embodiment the container is a server software that hosts applications i.e. contains them . In the case of a SIP container it hosts SIP applications. The container can perform a number of SIP functions as specified by the protocol thereby taking the burden off the applications. At the same time the SIP container can expose the application to SIP protocol messages via the SIP Servlet API on which applications can perform various actions. Different applications can thus be coded and deployed to the container that provides various telecommunication and multimedia services.

As illustrated a message such as a phone call request or some other transfer of data associated with SIP can come into the cluster from the internet such as over VoIP phone or some other type of network . This message can be received and handled by a load balancer which can be responsible distributing message traffic across the engines such as engine node and engine node in the cluster. The load balancer can be a standard load balancing appliance hardware device and it is not necessary that it be SIP aware there is no requirement that the load balancer support affinity between the engines and SIP dialogs or transactions. However in alternative embodiments certain advantages may be obtained by implementing a SIP aware load balancer as discussed in further detail below. Alternatively the load balancer can be implemented as software that distributes the messages to the various engines. In the various embodiments the primary goal of the load balancer can be to provide a single public address that distributes incoming SIP requests to available servers in the SIP server engine tier . Such distribution of requests can ensure that the SIP server engines are fully utilized. The load balancer can also be used for performing maintenance activities such as upgrading individual servers or applications without disrupting existing SIP clients.

In one embodiment the SIP server can provide a two tier cluster architecture model to handle the incoming messages. In this model a stateless engine tier can process all signaling traffic and can also replicate transaction and session state to the state tier and its partitions . Each partition can consist of any number of nodes replicas distributed across any number of hosts such as host and host which can be implemented as computers linked in a cluster type network environment. The state tier can be an n way peer replicated Random Access Memory RAM store that maintains various data objects which can be accessed by the engine nodes in the engine tier. In this manner engines can be provided a dual advantage of faster access to the data objects than retrieving data from a database while at the same time engines can be freed up from having to store the data onto the engine tier itself. This type of separation can offer various performance improvements. The state tier can also function as a lock manager where call state access follows a simple library book model i.e. a call state can be checked out by one SIP engine at a time .

The engine tier can be implemented as a cluster of SIP server instances that hosts the SIP servlets which provide various features to SIP clients. In one embodiment the engine tier is stateless meaning that most SIP session state information is not persisted in the engine tier but is obtained by querying the state tier which can in turn provide replication and failover services for SIP session data. In alternative embodiments the engine tier can have state maintained in a local near cache for improving latency.

The primary goal of the engine tier can be to provide maximum throughput combined with low response time to SIP clients. As the number of calls or their duration increases more server instances can be added to the engine tier to manage the additional load. It should be noted however that although the engine tier may include many such server instances it can be managed as a single logical entity. For example the SIP servlets can be deployed uniformly to all server instances by targeting the cluster itself and the load balancer need not maintain affinity between SIP clients and individual servers in the engine tier.

In various embodiments the state tier can be implemented as a cluster of SIP server instances that provides a high performance highly available in memory store for maintaining and retrieving session state data for SIP servlets. This session data may be required by SIP applications in the SIP server engine tier in order to process incoming messages. Within the state tier session data can be managed in one or more partitions where each partition manages a fixed portion of the concurrent call state. For example in a system that uses two partitions the first partition could manage one half of the concurrent call state e.g. A M and the second partition can manage the other half e.g. N Z . With three partitions each can manage a third of the call state and so on. Additional partitions can be added as needed to manage large number of concurrent calls.

In one embodiment within each partition multiple servers can be added to provide redundancy and failover should the other servers in the partition fail. When multiple servers participate in the same partition those servers can be referred to as replicas because each server maintains a duplicate copy of the partition s call state. For example nodes and of the partition can be implemented as replicas. Furthermore to increase the capacity of the state tier the data can be split evenly across a set of partitions as previously discussed. The number of replicas in the partition can be called the replication factor since it determines the level of redundancy and strength of failover that it provides. For example if one node goes down or becomes disconnected from the network any available replica can automatically provide call state data to the engine tier.

Replicas can join and leave the partition and each replica can serve as exactly one partition at a time. Thus in one embodiment the total available call state storage capacity of the cluster is a summation of the capacities of each partition .

In one embodiment each partition can peer replicated meaning that clients perform all operations reads writes to all replicas in the partition wherein the current set of replicas in the partition is called the partition view . This can provide improved latency advantages over more traditional synchronous primary secondary architecture wherein one store acts as a primary and the other nodes serve as secondaries. Latency is reduced because there is no wait for the second hop of primary secondary systems. The peer replicated scheme can provide better failover characteristics as well since there does not need to be change propagation delay.

In one embodiment the engine nodes can be responsible for executing the call processing. Each call can have a call state associated with it. This call state can contain various information associated with the call such as the ids of the caller callee where the caller is what application is running on the callee any timer objects that may need to fire in order to process the call flow as discussed below as well as any other data that may correlate to a call or a message. The state for each call can be contained in the state tier . The engine tier on the other hand could be stateless in order to achieve the maximum performance. In alternative embodiments however the engine tier can have certain amounts of state data stored thereon at various times.

In one embodiment a typical message processing flow can involve locking getting the call state processing the message and then putting unlocking the call state. The operations supported by the replicas for normal operations can include 

In various embodiments the engine tier can maintain mainly short lived objects and any long lived objects which may be needed for message processing can be stored on the state tier. This can provide improvements in latency during garbage collection. As an illustration the Java Virtual Machine JVM garbage collector can safely and quickly remove the short lived objects from memory without interfering with the execution of various other threads which may be in the process of executing. The longer lived objects on the other hand are not as easily removed by the garbage collector since they may be referenced and depended on by various entities and thus in some cases the JVM garbage collector may need to stop processing all threads in order to safely perform its garbage collection. This is due in part to the scoping of the short lived and long lived objects. Short lived objects typically exist in a different more localized memory scope than the long lived objects which may be referenced by more entities. Thus it can be more difficult for garbage collectors to ensure that every executing entity has finished using the long lived objects and various threads are usually stopped in order to perform their regular garbage collection. This can introduce latency.

In order to deal with such issues the engine tier can maintain mostly short lived objects. In cases where longer lived objects are needed by the engine tier they can be retrieved from the state tier used as short lived objects in the engine tier and subsequently pushed back to the state tier. This can be advantageous in that garbage collection can cause lesser interference with thread execution in the engine tier.

In various embodiments the state tier can maintain call state in various data objects residing in the random access memory RAM of a computer. This can provide significant access speed advantages to the engine tier over the use of a database. Alternatively if latency is not an issue call state can be maintained in a database or some other form of persistent store which can be accessed albeit slower by the engine tier. State of various applications running on the SIP server can also be maintained on the state tier. Developers can be provided an API to allow their applications to access the state tier and to store various data thereon for later access by various applications. Alternatively application state may be stored in a database.

The SIP server can deploy and host a multitude of applications that provide various services to SIP clients. For example a webex application can be deployed on the SIP server and provide web conferencing and video conferencing features to numerous customers. Other such applications can also be running on the SIP server at various times.

In many cases a user may wish to upgrade the SIP server or the applications running thereon with corresponding new versions in order to add desired functionality and improve performance. However for most large corporations or telecommunication providers which are hosting high numbers of SIP applications with very large numbers of users it may be impractical or even impossible to find a period of time when no customers are using the system during which time such upgrades can be added. Therefore it may be desirable to provide the SIP server with a more dynamic approach to upgrading applications and services without interrupting the current calls or services and without disrupting the business flow of the organization.

The hitless application upgrade can enable the SIP server to upgrade a deployed SIP application to a newer version without losing the existing calls being processed by the application. This type of upgrade can be accomplished by deploying a newer application version alongside the older version which is already running on the engine tier. The SIP server can then automatically manage the calls and messages such that new calls are routed to the new version of the application while the old established calls continue to be processed by the older version. Once all established calls are completed the older version of the application can be undeployed. The hitless application upgrade can also enable the user to commit or roll back the changes caused by the new versions of the applications. In this manner a smoother and more dynamic transition is provided for upgrading the various services of a corporation.

As illustrated in a SIP server including a SIP servlet container can be running on various engine nodes and having a deployed SIP application thereon such SIP App v . A load balancer can be receiving incoming SIP message traffic and distributing that traffic to the various engine nodes for processing in the engine tier . Some or all of the messages and requests received by the engine nodes can then be directed to be handled by the SIP App v .

In various embodiments a system administrator of the SIP server may wish to upgrade or substitute a new version of SIP App V without disrupting the existing calls being handled thereby. The hitless application upgrade can take enable such features as illustrated in .

In one embodiment a new version of the SIP application such as SIP App v version two can be deployed on the engine node A alongside the old version SIP App v . The SIP server can then manage the SIP servlet mapping such that new requests are directed to the new version while subsequent messages for older established dialogues are directed to the older application version until the calls complete. When all of the older dialogues have completed and the SIP App v is no longer processing calls it can be safely undeployed. This type of a system can ensure that no calls are dropped during the upgrades of various production applications. In alternative embodiments all old calls can be ended and new calls can be directed to the new application version.

Version information can be assigned to each updated application in order to distinguish it from the older application versions. For example whenever a SIP application is deployed a version number can be associated therewith. Alternatively only new updated applications may be assigned a version number and other applications that are already deployed may be assumed to be older versions by the SIP server. In cases where the application hard codes the use of an application name e.g. in composed applications where multiple SIP servlets process a given call the application name can be replaced with calls to a helper method that obtains the base application name. For example the SIP server can provide SipApplicationRuntimeMBean methods for obtaining the base application name and version identifiers as well as for determining whether the current application version is active or retiring.

The SIP server can use a version identifier such as a string value appended to the application name in order to distinguish between multiple versions of a given application. For example the version can be appended to the context root or to the archive name when the application is packaged for deployment. The SIP server can subsequently strip the version string specified from the application s deployment name so that it can recognize when several versions of the same application are deployed. If two versions are indeed deployed the server can begin routing new requests to the most recently deployed application. The server can allow the other deployed application to complete in flight calls while directing no new calls to it. This process can be referred to as retiring because eventually the older version will process no SIP messages. The server can also distinguish between a deployment that has no version identifier and a subsequent version that does specify a version identifier. This can enable upgrades of applications that were packaged before version information was used on the SIP server.

As illustrated in after deploying the new version of the existing application it can be activated to process new calls. This can be done by the SIP server replacing existing servlet mappings for the application being upgraded with new servlet mappings specified in the SIP deployment descriptor of the new version. The original deployment SIP App v can then process messages only for established or in flight calls e.g. calls that were initiated with the original deployment . After these in flight calls are completed the original deployment version can be removed as no longer being necessary. In order to determine whether a deployed application is processing messages an active session count can be obtained from the application s runtime bean instance or a script prepared by a system administrator. When the count of active sessions for that version of the application reaches zero the hitless application upgrade can be gracefully committed by removing the old version. For example a method getActiveVersionState can return an integer value that describes the state of a selected application version. A returned value of zero can indicate that the particular version of the application is inactive meaning that the application is being retired. Alternatively it can mean that this version has not yet been activated.

A graceful commit may involve letting the old version application finish routing messages to established calls before it is undeployed. In alternative embodiments an ungraceful commit may also be implemented by terminating all existing calls and forcing all new calls to be directed to the new version. While less customer friendly this option may still be useful for dealing with unwanted calls security compromises or other undesirables within an organization.

Each host or engine node can be hitlessly upgraded one at a time in order to test the performance of the new application version without disrupting the entire system. Alternatively all engine nodes can be upgraded in parallel sequentially or some may be left with older application versions. Furthermore rollback functionality can also be implemented for the SIP server. For example if after deploying the new version of the application the system is not performing as expected the new version can be undeployed and new calls can be routed to the old version that was previously handling only established in flight calls. Upon such undeployment of the new application version the SIP server can restore the previous servlet mappings as previously discussed.

In various embodiments a configured load balancer can be used to perform a live upgrade of the SIP server software or a deployed SIP application on a production installation. When updating the SIP server or when upgrading a SIP servlet where the servlet s session data is incompatible with the older version a new engine tier can be created in order to host newly upgraded engine tier instances or new versions of SIP servlets. Subsequently servers in the engine tier can be shut down upgraded and then restarted in the new target cluster. In some cases it may be preferable to shut down each server one at a time so as to maintain current call processing. Similarly it may be preferable to target all deployed SIP servlets to the engine tier cluster rather than to individual managed server instances within the cluster. After all servers have been upgraded the older cluster can be removed and no longer used. When the engine tier cluster is finished upgrading servers in the state tier can be upgraded similarly one at a time.

As illustrated in step a SIP server can be distributed over a cluster type network in order to provide services to various SIP clients. An application deployed on the SIP server can process incoming message traffic from the SIP clients as illustrated in step . A new version of the application can be deployed on the SIP server alongside the existing version of the application in step . The new version can be activated in order to begin processing calls as illustrated in step . As shown in step the SIP server or the SIP servlet container therein can direct the incoming messages for new calls to the new version of the application. Meanwhile as illustrated in step the container can direct incoming messages for previously established calls to the old version of the application. Thus for at least some period of time the two versions can be running simultaneously.

As illustrated in step an incoming message can be received from a SIP client by a load balancer of the cluster network. In step the load balancer can then distribute the message to a SIP server having two versions of the application running as previously discussed. In step the container can then determine whether the message is for an already established SIP session or whether the message is a request that would establish a new SIP session between the client and the SIP server.

As illustrated in step the SIP server can route messages for previously established SIP sessions to the old version of the application that is executing alongside the new version on the SIP server. The messages for new SIP sessions on the other hand can be routed to the new version as illustrated in step . This can be achieved by the SIP server replacing the existing servlet mappings for the application being upgraded with new servlet mappings specified in the SIP deployment descriptor of the new version upon deployment of the new application version.

In step an active session count can be maintained such as by the SIP server itself or via scripts implemented by a system administrator. The count is likely to decrement as existing calls that are being handled by the old version of the application are ended by various SIP clients. Whenever this active session count reaches zero the new version deployment can be gracefully committed as illustrated in step by undeploying the old version of the application. All incoming traffic is then directed to the new version of the application. In this manner no interruption in calls need be experienced by the SIP server.

As illustrated in step a new version is deployed in the SIP server for processing incoming messages as previously discussed. New messages which are associated with new calls can be directed to this newly deployed version as illustrated in step . However as shown in step the new version of the application may not be functioning as previously expected. For example new functionality added to the new version may cause an increase in latency or simply may not process messages as intended. In this scenario a rollback can be performed.

As illustrated in step the rollback can be initiated by undeploying the new version of the application. Subsequently the incoming messages for all calls established and new can be routed back to the old version of the application as illustrated in step . This can be achieved by restoring the previous servlet mappings that were changed by the SIP server. Furthermore since the deployment and undeployment of the new version can be done on a single engine tier node impact on performance of the entire SIP server can be minimal. In this manner hitless application upgrade can improve performance of the SIP server and various call processing as discussed below.

As illustrated a back to back user agent B2BUA having a running SIP server thereon can take the place of being an intermediary between the communications sent between various users. This can be done for purposes of controlling the call and message flow between user agent and user agent and in order to prevent any unwanted behavior and messages e.g. spamming hacking viruses etc. from being sent to the user agent device. It should be noted that although user agent and user agent are illustrated as telephones in the SIP messages can come from various other sources as well. For example the user agent can also be a cell phone a wireless device a laptop an application or any other component that can initiate a SIP type of communication. Similarly while illustrates communications between two user agents there can be more such user agents taking part of a single communication session. For example during a conference call there may be 20 or 30 user agents for all attendees of the conference each of which could send SIP messages to the B2BUA and receive transmissions back therefrom.

Continuing with the illustration a telephone call can be set up between user agent and user agent via the use of the SIP server. The first message sent from user agent to the SIP server on the B2BUA can be an invite message requesting to set up a telephone call with user agent . The invite message can be received by the load balancer of the SIP server and it can be directed to an engine in the engine tier for processing.

In various embodiments the engine tier e.g. an application executing thereon can then perform logic for determining various factors associated with the call such as determining whether user agent is allowed to make the type of call attempted to be initiated determining whether the callee that will be contacted is properly identified as well as any other logic that the server may need to calculate before attempting to set up a telephone call. The engine can then generate state around the fact that a call is being set up including generating the proper long lived and short lived objects associated with the messages as previously discussed. The engine can also determine how to find the target of the call i.e. user agent and the right path to route the message to the callee. As illustrated herein user agent is an originator as well as the terminator of the call and user agent is referred to as the callee.

After receiving the invite message the SIP server can send a 100 trying message back to user agent indicating that it has received the invite message and that it is in the process of handling it. The 100 trying message is part of the SIP protocol definition and can be used by a server in order to stop the user agent from re transmitting the invite request. In cellular phone environments the user agent may have interference which might cause an interruption or loss of various messages. Therefore SIP protocol defines various re transmission schemes in order to handle such mobility and interruptions. Messages such as 100 trying 180 ringing and 200 OK are just some of the examples of messages defined in SIP for handling communication.

Continuing with the illustration the SIP server can then send an invite message to the user agent and can receive back a 180 ringing message indicating that user agent has received the invitation and is now waiting for a user to answer. The SIP server engine tier can then transmit the 180 ringing message back to user agent . When a person finally answers the phone user agent can then send a 200 ok message to the SIP server the server can transmit that message to user agent . The user agent can send an acknowledgement Ack message to the SIP server which can be transmitted along to user agent and at this point a sound transfer conversation can be set up between the two user agents. This sound transfer can be implemented via real transfer protocol RTP on a media server. At the end of the conversation either user agent can choose to terminate the call by sending a Bye message. In this illustration user agent terminates the call by sending a Bye message to the SIP server which sends it off to user agent . After receiving back a 200 ok message from user agent the SIP server can transmit that message to user agent and the conversation can be truly ended.

In various embodiments the vertical lines such as those extending downward from the user agents and the B2BUA can each illustrate and be referred to as a single call leg. The call flow for each call leg may be time sensitive as some messages should be received or sent before others can be initiated. For example as illustrated herein the user agent A may continue to re transmit the initial invite message until it receives a 100 trying message from the B2BUA . As such in some cases certain messages may need to be processed synchronously while others may be allowed to process in parallel.

It should be noted that this illustration of a call may be overly simplified for purposes of clarity. For example there can be various other message transmissions not illustrated such as authentication messages for caller callee determining the type of user agent the SIP server is communicating with and various other handshaking messages that can be exchanged between the SIP server and the user agents. Furthermore message transmitting steps may be added changed interrupted or rearranged in case of interference or failure of various components.

As previously discussed in various embodiments there may be specific sequences of messages exchanged between the SIP server and the user agents for controlling the flow of the call. These sequences can be controlled by various timer objects residing on the SIP server. As a nonlimiting illustration after receiving the invite message from one user agent the SIP server will typically forward that invite to another user agent and wait for a response. If no response is received within a period of time e.g. a number of milliseconds then the invite message may need to be retransmitted to the second user agent because it may be assumed that the user agent did not receive the first message. This type of re transmission can be controlled by the protocol timer objects which may be residing in the state tier. In one embodiment an initial T1 timer value of 500 milliseconds can control the retransmission interval for the invite request and responses and can also set the value of various other timers.

In various embodiments there are also other timer objects which can be executing on the level of the entire call. For example if after a specified period of time nothing is heard back from either user agent the entire call may be purged from the system. This specified period of time can also be controlled by firing a timer object.

In one embodiment as engine tier servers add new call state data to the state tier state tier instances queue and maintain a complete list of SIP protocol timers and application timers associated with each call. Engine tier servers can periodically poll the partitions of the state tier to determine which timers have expired given the current time. In order to avoid contention on the timer tables multiple engine tier polls to the state tier can be staggered. The engine tier can then process the expired timers using threads in the sip.timer.Default execute queue. Thus the processing of the timer objects can be executed by the engine server as determined by the state tier server. For example the state tier can tell the engine A to execute the first half of all due timer objects e.g. and tell engine B to execute the other half e.g. . The state tier can also simultaneously push the state onto the engine since the state may need to be employed in executing the timer objects. The engines can then process the timer objects e.g. by sending appropriate messages ending appropriate calls and can later again query poll the state tier for which timers have become due.

When used with the near cache the state data may not need to be pushed onto the engine server since that data may already be available in the cache. Thus when processing timers the timers can be fetched from the state tier however upon the timer firing the engine can fetch the call state using the cache. Further performance optimization can be obtained by changing the selection of tiers to give affinity to the engine holding the cache for a particular call. Thus the timers which are going to be executed can be sent to the appropriate engines which have the proper call state in the cache thereon.

In various embodiments it may be preferable to synchronize system server clocks to a common time source e.g. within a few milliseconds in order achieve maximum performance. For example an engine tier server with a system clock that is significantly faster than other servers may process more expired timers than the other engine tier servers. In some situations this may cause retransmits to begin before their allotted time and thus care may need to be taken to ensure against it.

In various embodiments the SIP Servlet API can provide a timer service to be used by applications. There can be TimerService interface which can be retrieved from as a ServletContext attribute. The TimerService can define a createTimer SipApplicationSession appSession long delay boolean is Persistent java.io.Serializable info method to start an application level timer. The SipApplicationSession can be implicitly associated with the timer. When a timer fires an application defined TimerListener is invoked and ServletTimer object passed up through which the SipApplicationSession can be retrieved which provides the right context of the timer expiry.

In various embodiments the engine tier servers continually access the state tier replicas in order to retrieve and write call state data. In addition the engine tier nodes can also detect when a state tier server has failed or become disconnected. For example in one embodiment when an engine cannot access or write call state data for some reason e.g. the state tier node has failed or become disconnected then the engine can connect to another replica in the partition and retrieve or write data to that replica. The engine can also report that failed replica as being offline. This can be achieved by updating the view of the partition and data tier such that other engines can also be notified about the offline state tier server as they access state data.

Additional failover can also be provided by use of an echo server running on the same machine as the state tier server. The engines can periodically send heartbeat messages to the echo server which can continually send responses to each heartbeat request. If the echo server fails to respond for a specified period of time the engines can assume that the state tier server has become disabled and report that state server as previously described. In this manner even quicker failover detection is provided since the engines can notice failed servers without waiting for the time that access is needed and without relying on the TCP protocol s retransmission timers to diagnose a disconnection.

Failover can also be provided for the engine tier nodes. As previously discussed the engine tier nodes can periodically poll the state tier nodes in order to determine which timer objects it needs to execute. In turn the state tier nodes can notice whenever the engine tier node has failed to poll. If a specified period of time elapses and the engine tier has not polled the state tier the state server can then report that engine as unavailable e.g. having failed or disconnected from the network . In this manner failover can be implemented for both the state tier and the engine tier thereby providing a more reliable and secure cluster for message processing.

In other aspects the invention encompasses in some embodiments computer apparatus computing systems and machine readable media configured to carry out the foregoing methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art.

Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The present invention includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include but is not limited to any type of rotating media including floppy disks optical discs DVD CD ROMs microdrive and magneto optical disks and magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

Stored on any one of the machine readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems and user applications.

Included in the programming software of the general specialized computer or microprocessor are software modules for implementing the teachings of the present invention including but not limited to providing systems and methods for providing the SIP server architecture as discussed herein.

Various embodiments may be implemented using a conventional general purpose or specialized digital computer s and or processor s programmed according to the teachings of the present disclosure as can be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as can be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits and or by interconnecting an appropriate network of conventional component circuits as can be readily apparent to those skilled in the art.

Basic features. These include standards services such as Voice mail Caller ID Call waiting and call forwarding the ability to forward a call to a different number .

Call logs The ability to view calls made over a given period of time online ability to associate names with phone numbers integrate call log information to other applications such as IM.

Do not disturb The ability to specify policies around receiving calls for example all calls during office hours to be automatically forwarded to a mobile terminal all calls during the night to be directed to voice mail etc.

Locate me This is advanced call forwarding. Rather than have all calls forwarded to a single location e.g. voice mail when the caller is busy Locate me can try multiple terminals in series or in parallel. For example a user may have two office locations a mobile and a pager and it may make sense to forward a call to both office locations first then the pager and then the mobile terminal. Locate me is another example of feature interaction.

Personal conferencing A user could use an existing application e.g. IM client to schedule a Web audio conference to start at a certain time. Since the IM client already has personal profile information the conferencing system sends out the Web conference link information either through IM and or email to the participants. The phone contact information in the profile is used to automatically ring the participants at the time of the conference.

Lifetime number This is the facility where a single virtual number can travel with a customer wherever they live. Even if they move the old number continues to work and reaches them at their new location. This is really the analog of static IP addresses in a phone network.

Speed dial This is the ability to dramatically expand the list of numbers that can be dialed through short key and accelerator combinations. This is another example of a converged application since it s very likely that when a user will set up this information when they work through the call logs on the operator user portal and the updated information needs to be propagated to the network side in real time.

Depending on the service level agreement users are willing to sign up to the quality of media delivered e.g. number of frames per second will vary. The policy engine enables segmenting the customer base by revenue potential and to maximize return on investment made in the network.

A typical example here is the need for applications that have a short lifetime extremely high usage peaks within their lifetime and immediacy. For example voting on American Idol during the show or immediately afterwards has proved to be an extremely popular application.

The final class of applications is one that combines wireline and wireless terminal usage scenarios. An example of an integrated application is the following a mobile terminal user is on a conference call on their way to work. When he reaches his office he enters a special key sequence to transfer the phone call to his office phone. The transfer happens automatically without the user having to dial in the dial in information again. It s important to note hear that this capability be available without the use of any specific support from the hand set a transfer button for example .

Various embodiments include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs microdrives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs paper or paper based media and any type of media or device suitable for storing instructions and or information. Various embodiments include a computer program product that can be transmitted in whole or in parts and over one or more public and or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. In various embodiments the transmission may include a plurality of separate transmissions.

Stored one or more of the computer readable medium media the present disclosure includes software for controlling both the hardware of general purpose specialized computer s and or processor s and for enabling the computer s and or processor s to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers user interfaces and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

