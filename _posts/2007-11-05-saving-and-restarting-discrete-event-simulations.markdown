---

title: Saving and restarting discrete event simulations
abstract: Method, system, and computer program product for saving and restarting discrete event simulations are provided. A discrete event simulation of a scenario is performed via a process executing on a system. The process includes one or more application threads. A checkpoint of the process is created at a point in time when a command to save the discrete event simulation of the scenario is received. The checkpoint includes data elements of the process and the one or more application threads of the process that are stored in components of the system at the point in time. These data elements reflect a state of the process and the one or more application threads of the process at the point in time. The checkpoint is saved to one or more files in the system that are usable to later restart the discrete event simulation of the scenario from the point in time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08296119&OS=08296119&RS=08296119
owner: Cadence Design Systems, Inc.
number: 08296119
owner_city: San Jose
owner_country: US
publication_date: 20071105
---
It is sometimes desirable to save performances of discrete event simulations up to particular points in time and then later restart the performances of the discrete event simulations from the particular points in time. Performance of a discrete event simulation up to a particular point in time can be saved by saving every simulation variable value of a simulator performing the discrete event simulation at the particular point in time. Collectively the value assigned to each simulation variable at the particular point in time reflects a state of the simulator at the particular point in time.

Saving every simulation variable value of a simulator however requires complete implementation details regarding the simulator and any application thread employed by the simulator. This type of information however is usually not available. Without such information it will not be possible to save a state of the simulator at a particular point in time during performance of a discrete event simulation. As a result it will be impossible to restart performance of the discrete event simulation from the particular point in time.

Method system and computer program product for saving and restarting discrete event simulations are provided. In one implementation a discrete event simulation of a scenario is performed via a process executing on a system the process including one or more application threads responsive to a command to save the discrete event simulation of the scenario up to a point in time a checkpoint of the process at the point in time is created to capture the discrete event simulation of the scenario up to the point in time the checkpoint including data elements of the process and the one or more application threads of the process that are stored in components of the system at the point in time which reflect a state of the process and the one or more application threads of the process at the point in time and the checkpoint is saved to one or more files in the system the one or more files being usable to later restart the discrete event simulation of the scenario from the point in time.

This disclosure generally relates to discrete event simulations and more particularly to saving and restarting discrete event simulations. The following description is provided in the context of a patent application and its requirements. Accordingly this disclosure is not intended to be limited to the implementations shown but is to be accorded the widest scope consistent with the principles and features described herein.

Discrete event simulation DES is a way to simulate scenarios to determine what could happen if the scenarios were to occur in real life. A scenario includes a collection of entities such as components of a computer roads and highways in a city tellers and customer queues in a bank trees and other plant life in a forest or the like. A scenario also includes a set of events involving one or more entities in the scenario. The set of events usually includes events likely to alter an outcome of the scenario.

For example suppose a forest fire is the scenario being simulated. Entities in the scenario could include trees one or more fires firefighters firefighting aircrafts and so forth. Events in the scenario could include for instance temperature increasing wind speed increasing to wind direction changing humidity decreasing increasing the number of firefighters etc. Thus discrete event simulation has a wide application from simulating performance of a microprocessor and operation of a computer to simulating traffic flow through a city and wait time at a drive through.

Simulation can be used to obtain information or to validate invalidate a hypothesis about scenarios being simulated. Discrete event simulation is generally iterative in nature. For example a common sequence of events may be simulated multiple times during a simulation session. Time is central to the concept of DES. A state of a simulation may be investigated periodically. Individual simulations can run on systems such as computers and other data processing devices for long periods of time e.g. days weeks or months .

Parallelism is important when simulating certain scenarios. For example when simulating a complex scenario such as a computer system with many components that run in parallel it is important to emulate the behavior of these components. Simulation is usually a single process comprising one or more executable files. The single process runs on a system that can only simulate one event at a time even though in reality multiple events may occur in the complex scenario simultaneously.

There are several approaches to emulating parallelism in a simulation. One approach is to use threads of control within a single process. A thread is a semi process that has its own stack e.g. a section of memory that executes code. Threads typically run on a processor for an amount of time before yielding to another thread which in turn runs on the processor for a period of time. Some programming languages used for simulation such as Verilog and SystemC have the notion of threads built into the syntax.

Simulators can implement threads in several ways. One way is to use a private schema. Another way is to use an application thread package that is commercially distributed or available as open source. Application threads differ from system threads in that an application running on an operating system has privileges to create and use application threads available from software libraries but not system threads. System threads are reserved for the operating system itself.

Implementation details of application threads are usually hidden in software libraries. Function calls through application programming interfaces APIs can be used to control the application threads. POSIX Portable Operating System Interface based on Unix threads is one example of a standard set of APIs used for portable multithreaded programming. Other examples of application threading packages include for instance FastThreads QuickThreads NewThreads and so forth.

Being able to save and restart discrete event simulations is often desirable. To give an example suppose a discrete event simulation involves a microprocessor. In the real world booting a microprocessor may take several minutes while running an application on the microprocessor after it has booted may take less than a second. In a discrete event simulation it may take more than one day to simulate the microprocessor booting and only a few minutes to simulate the application running on the microprocessor.

If the state of the discrete event simulation is saved immediately after simulation of the microprocessor booting is completed then instead of spending a day or more to re simulate booting of the microprocessor in order to simulate running of the application on the microprocessor the discrete event simulation can be restarted from the saved state. Restarting a simulation from a saved point should take less time than re performing the simulation up to the saved point.

A programmatic approach can be used to save and restart a simulation. For example functions can be written to exhaustively save the value of each simulation variable in a simulator when a save is desired and to restore the values of the simulation variables in the simulator that were saved when a restart is desired. The approach is programmatic in the sense that the actual act of saving and restarting is made possible by writing functions that save simulation variable values and assign values to simulation variables in order to return a simulator to its previous state.

Functions to save simulation variable values and to assign values to simulation variables however cannot be written without a complete understanding of the simulator and any application thread that may be used by the simulator. The implementation details that are necessary to gain a complete understanding of the simulator and any application thread that may be used by the simulator are rarely available.

To give an example when application threads are used each application thread has a local storage that is not accessible from the simulator or other threads. Oftentimes threads are blocked while waiting on events and cannot be unblocked to access their internal state without changing the simulation results. Hence it may be impossible to use a programmatic approach to save a discrete event simulation for a later restart.

Depicted in is a method for saving and restarting event simulations according to an implementation. At a discrete event simulation of a scenario is performed via a process executing on a system. The process may be the result of one or more executable files running on the system. The process includes one or more application threads which may be used to emulate parallelism.

The scenario may include a plurality of entities and a plurality of events. Each event may involve one or more of the plurality of entities. In one implementation each entity in the scenario is a part of an integrated circuit design. The system may be a computer or any other data processing device.

A determination is made at as to whether a command to save the discrete event simulation of the scenario up to a point in time has been processed. The command may be a command that is inputted by a user during the discrete event simulation. In one implementation the command to save the discrete event simulation of the scenario is read from a file. The file may include one or more other commands such as a command to perform the discrete event simulation.

If a save command has not been processed then method returns to process block to check again. There may be a preset waiting period before checking again for a save command. If a save command has been processed a checkpoint of the process at the point in time is created at to capture the discrete event simulation of the scenario up to the point in time.

The checkpoint of the process comprises data elements of the process and the one or more application threads of the process that are stored in components of the system at the point in time which reflect a state of the process and the one or more application threads of the process at the point in time. For example the checkpoint may include data elements of the process and the one or more application threads of the process that are stored in registers memories file handles sockets buffers seeks and the like of the system. Thus a checkpoint of a process running on a system includes complete information describing the process and its application threads.

The checkpoint is saved to one or more files in the system at . In one implementation the one or more files are executable files. The one or more files may simply be data files that can be read by a program to carry out discrete event simulation of the scenario from the point in time. The one or more files may be stored in for instance a disk of the system.

Although a checkpoint of the process is created and saved at the point in time the discrete event simulation of the scenario may continue on past the point in time. Thus the one or more files are usable to later restart the discrete event simulation of the scenario from the point in time regardless of whether the discrete event simulation of the scenario from which the checkpoint was created continued past the point in time.

Different operating systems have different executable file formats for executables object code shared objects core dumps and so forth. Depending on which operating system is running on the system and which architecture is employed by the system the executable file may be in ELF Executable and Linking Format COFF Common Object File Format PE COFF Portable Executable COFF a.out or the like.

By conceptualizing performance of a discrete event simulation as a single process running on a system a state of the process and any application threads that are part of the process can be saved by creating a checkpoint of the process. The checkpoint of the process includes data elements of the process and its application threads which are stored in components of the system such as registers memories file handles or the like. These data elements comprise the state of the process and its application threads. As a result complete knowledge of the implementation details concerning the process and its application threads is no longer necessary in order to save and restart the discrete event simulation.

Simulator is performing a discrete event simulation of a scenario . When performing the discrete event simulation of scenario simulator may utilize one or more application threads not shown to emulate parallelism. Performance of the discrete event simulation may be in response to a command . Command may be inputted by a user read from a file or the like. In one implementation scenario comprises a plurality of entities and a plurality of events. Each event may involve one or more of the plurality of entities.

Each entity and each event may include one or more parameters. For example suppose scenario is a microprocessor. One of the entities in scenario could be a level 1 cache. Hence a parameter of the entity could be an amount of cache e.g. 2 MB . One of the events of scenario could be changing the operating temperature of the microprocessor. Thus parameters of the event could be an amount of change e.g. 1 F. and whether the change is a plus or a minus. As a result when simulator performs the discrete event simulation of scenario one or more parameter values may be inputted such as through a command line interface read from a file or the like.

In response to a command to save the discrete event simulation of scenario up to a point in time checkpoint creator creates a checkpoint of the first process at the point in time to capture the discrete event simulation of scenario up to the point in time and saves checkpoint to one or more files stored in system . Files may be executable files data files or the like. As noted above command may be inputted through a command interface read from a file or something else.

Checkpoint of the first process includes data elements of the first process and the one or more application threads of the first process that are stored in components of system at the point in time. For example if system is a computer then data elements of the first process and the one or more application threads of the first process may be stored in memories registers file handles buffers sockets etc. of the computer. Data elements included in checkpoint reflect a state of simulator at the point in time because they reflect a state of the first process and the one or more application threads of the first process at the point in time.

The discrete event simulation of scenario may continue even after checkpoint is created. Once the discrete event simulation is finished terminated or the like the first process associated with simulator will stop running on system . To restart the discrete event simulation of scenario from the point in time the one or more files stored on system may be executed. In one implementation execution of the one or more files results in a new process executing on system that includes one or more application threads. The new process and the one or more application threads replicate the state of the first process and the one or more application threads of the first process at the point in time.

When restarting the discrete event simulation of scenario from the point in time at least one of the parameter values may be changed from the one used during the discrete event simulation of scenario up to the point in time. For instance different parameters values may be inputted a different file with different parameter values may be used one or more parameter values in a file previously used may be changed or the like.

Checkpoint creator may be incorporated into simulator i.e. the first process and the second process may be combined into a single process executing on system . Shown in is an example of a simulator saving and restarting a discrete event simulation over simulation sessions and . Simulation session starts at time zero. At time n a save command is processed. In response to save command a checkpoint of simulator is created. After a restart command is processed simulation session restarts the discrete event simulation at time n.

After reading the first command the simulator will perform a discrete event simulation for 1000 nanoseconds. In response to the second command the simulator will save its state at that time. The simulator will then run the discrete event simulation for another 20 nanoseconds in a second simulation session and then exit responsive to the third and fourth commands. A new simulation session may be started thereafter from the point at which the discrete event simulation was saved.

In the new simulation session it is possible to allow the simulator to start with parameter values that are different from the parameter values that were used previously. If parameter values are read from a file previously then contents of the file can be changed before the file is used for the new simulation session. Therefore the simulator is not limited to merely being suspended and then later resumed.

The simulator can be expressed as a collection of executable files that run on a computer in a process. All application threads utilized by the simulator run in that process. Hence a checkpoint of the process includes complete information about the process and its application threads. This may include information about registers memories file handles seeks sockets and so forth.

Since the values assigned to the variables of the simulation process and its application threads at a point in time represents a state of the simulation process at the point in time creating checkpoint from data elements at the point in time captures the state of the simulation process and its application threads at the point in time. Accordingly complete information about the simulation process and any application thread employed by the simulation process can be captured without details regarding how the simulation process and its application threads are implemented.

Illustrated in is a method for saving and restarting discrete event simulations according to an implementation. At a discrete event simulation of a scenario is performed via a process executing on a system. A determination is made at as to whether a command to save the discrete event simulation of the scenario up to a point in time has been processed. If such a command has not been processed the method waits a predetermined period of time before checking again.

However if such a command has been processed then at a checkpoint of the process at the point in time is created to capture the discrete event simulation of the scenario up to the point in time. At the checkpoint is saved as one or more executable files. A determination is made at as to whether a command to restart the discrete event simulation of the scenario from the point in time has been processed.

If no such command has been processed then method waits a predetermined period of time before checking again. If such a command has been processed then at the one or more executable files are executed to restart the discrete event simulation of the scenario from the point in time. In one implementation execution of the one or more executable files results in a new process that replicates a state of the process at the point in time when the checkpoint of the process was created.

Commands to create the checkpoint and execute the one or more executable files may both be saved in a file but not necessarily the same file. The discrete event simulation of the scenario may be restarted with at least one parameter of the scenario having a value that is different from a value assigned to the at least one parameter during the discrete event simulation of the scenario from which the checkpoint was created.

This disclosure can take the form of an entirely hardware implementation an entirely software implementation or an implementation containing both hardware and software elements. In one implementation this disclosure is implemented in software which includes but is not limited to application software firmware resident software microcode etc.

Furthermore this disclosure can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include DVD compact disk read only memory CD ROM and compact disk read write CD R W .

Memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories that provide temporary storage of at least some program code in order to reduce the number of times the code must be retrieved from bulk storage during execution. As shown input output or I O devices including but not limited to keyboards displays pointing devices etc. are coupled to system . I O devices may be coupled to system directly or indirectly through intervening I O controllers not shown .

In the implementation a network adapter is coupled to system to enable system to become coupled to other data processing systems or remote printers or storage devices through communication link . Communication link can be a private or public network. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

While various implementations for saving and restarting discrete event simulations have been described the technical scope of this disclosure is not limited thereto. For example this disclosure is described in terms of particular systems having certain components and particular methods having certain steps in a certain order. One of ordinary skill in the art however will readily recognize that the methods described herein can for instance include additional steps and or be in a different order and that the systems described herein can for instance include additional or substitute components. Hence various modifications or improvements can be added to the above implementations and those modifications or improvements fall within the technical scope of this disclosure.

