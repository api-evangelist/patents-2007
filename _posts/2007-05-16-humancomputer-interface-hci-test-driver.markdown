---

title: Human-computer interface (HCI) test driver
abstract: A method and a system for driving a computer interface for a user is provided. The system includes an interface client having a computer platform, a test driver having software on the computer platform; a window displayed to the interface client, the window providing an interface between the computer platform and the user; and a command file that provides an instruction to the computer interface for executing by the driver software, such that the instruction mimics a user input. The method includes providing instructions through a command file having an instruction for execution on the computer interface, providing driver software to the computer interface, and executing the instruction on the computer interface using the driver software, such that the instruction mimics a user input.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=H0002264&OS=H0002264&RS=H0002264
owner: The United States of America as represented by the Secretary of the Navy
number: H0002264
owner_city: Washington
owner_country: US
publication_date: 20070516
---
Pursuant to 35 U.S.C. 119 the benefit of priority from Provisional Application No. 60 835 966 with a filing date of Jul. 24 2006 is claimed for this non provisional application.

The invention described was made in the performance of official duties by one or more employees of the Department of the Navy and thus the invention herein may be manufactured used or licensed by or for the Government of the United States of America for governmental purposes without the payment of any royalties thereon or therefor.

The invention relates generally to software integration verification. In particular the invention relates to using a command file and optionally user interaction to represent the inputs from an operator and or external subsystems. The effects of the inputs on the HCI software are validated against expected responses.

Modern operational control such as for a ship board combat platform typically requires an integrated computer system to receive data select appropriate options and transmit instructions to and from components for instrumentation and execution. Construction of such a system can require integration of many separate processes each receiving and transmitting data in co peration with other related processes.

In addition to creation and assembly of hardware electronic components for receiving information and transmitting commands software code must be prepared and compiled to interpret and execute instructions that perform the system operations. Prior to complete integration verification of separate components is performed by a testing operator in combination with simulation software processes. The development alone of the simulation software itself is immense and may become necessary at an early stage in the development cycle. The time and effort required of the testing operator to completely verify the software component is extensive to cover the plethora of different input combinations. This represents a time consuming and error prone process.

Such component operation testing typically involves executing the component s instruction software and simulating its external subsystems from which to receive anticipated input and submit appropriate output. Such code must be sufficiently robust to not only properly execute the intended functions on command but also recover gracefully from inappropriate inputs and other faulty conditions without undue and potentially catastrophic interruption. The simulation procedure involves preparing a test driver to be executed under sets of conditions and selections.

The production software as well as the simulation software requires a graphical user interface GUI . The program renders its GUI to respond to user interaction e.g. weapon selection while concurrently operating another device e.g. tracking a target . Execution of a software application involves kernel scheduling such as by an operating system process or by a thread of execution. A process is used to instantiate i.e. run an instance of a program.

Processors typically operate independently and carry extensive state information regarding operation status e.g. running blocked ready . By contrast threads share the state information of a single process memory address space and other resources with each other. A process switches between threads whereas multiple threads switch by time slicing. Multi threading between threads is generally faster than context switching between processes providing a speed advantage on a cluster of machines. Implementing threads may require careful scheduling to rendezvous properly for processing data in the correct order.

Conventional methods of testing software components require a separate test driver for each component. Each test driver is unique to the software component under test and is neither reusable nor applicable to other components to be tested. Each software developer has a different method or style of testing software and thus the test drivers are usually not transferable to other developers or even other software components. Regression testing or comparing actual results with expected results must be conducted manually by observing the actual results or the test driver has to be modified to perform the comparison.

For a test of software an operator may interact with a GUI equipped client platform referred to as a Human Computer Interface HCI as one component in a control system. One or more data servers may communicate with the HCI to simulate an associated device in the control system. The data servers may interact with one or more server threads in the HCI. The operator may interact through an interface thread that displays a GUI window for each instantiated executable program. The server and interface threads may exchange information between each other with each window responding to condition changes caused by the exchanges.

Conventional software testing yields disadvantages addressed by various exemplary embodiments of the present invention. In particular capabilities are needed to comprehensively test all option selections. Other various embodiments alternatively or additionally provide for obviating the necessity for providing simulators prior to software development and testing.

Various exemplary embodiments provide a method and a system for driving a computer interface for a user. The system includes a computer platform a test driver having software on the computer platform a window providing an interface between the computer platform and the user and a command file that provides instructions to the computer interface for execution by the driver software as well as verification of the production software. The instructions mimic user and external subsystem input. The method includes providing instructions and verification via a command file providing driver software to the computer interface and executing the instruction on the computer interface using the driver software. The instructions mimic user and external subsystem input.

In various exemplary embodiments the system includes a remote server in which the method provides for exchanging information with the client and executing a server command from the server in response to the information. In alternate embodiments a window is provided to display the instruction and thereby enable the instruction to be edited and re executed.

In other exemplary embodiments the instruction in the command file verifies attributes of the information by one of confirming conformity and identifying discrepancy. Additional embodiments enable the user input to be selected from a list of menu options. The instructions may be incorporated using human readable symbology such as alpha numeric characters. In addition the driver software may incorporate a software library. The computer interface represents a Human Computer Interface HCI . Preferably an HCI Test Driver associated with the client platform represents a simulator for testing and verifying combat operations capabilities.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and logical mechanical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

The Advanced Tomahawk Weapons Control System ATWCS represents an example combat weapons platform. ATWCS GUI software was based on the Motif widget set using the Ada programming language. ATWCS software was designed using an Object Oriented paradigm. A window within the software was considered an object. Unit testing each routine within the window package lacks the same effectiveness as testing the window package as a whole object. The HCI Test Driver concept was conceived based on the need to thoroughly test the window as an object.

The next software version for Tactical Tomahawk Weapons Control System TTWCS used C as the language for GUI development. HCI Test Driver as provided in exemplary embodiments enabled conversion from Ada to C with that capability subsequently extended to run on multiple platforms HP UX Linux .

Original methods of testing these GUI windows required separate test drivers for each window. Each test driver was unique to the window under test and was neither reusable nor applicable to other windows to be tested. Each software developer had a different method or style of testing software and thus the test drivers were usually not transferable to other developers or even other software components. Regression testing or comparing actual results with expected results had to be done manually by observing the actual results or the test driver had to be modified to perform the comparison. Continuing to write individual test drivers for each window in subsequent projects would have been costly time consuming and tedious.

An example commercial tool for software testing and development is X window GUI testing product XRunner from Mercury Interactive Corporation. See http www.mercury.com us products application delivery xrunner . This tool enables user interaction such as button clicks and data entry to be recorded. However the software development industry requires more extensive capabilities as provided by various exemplary embodiments described herein.

The design of the HCI Test Driver coupled with the HCI design for ATWCS TTWCS has been widely used within the Tomahawk cruise missile program. This has enhanced the productivity of Navy GUI developers and significantly improved the quality of the GUI software. The flexibility and extensibility of the design enables conversion to a different Widget set of wxWidgets. This will facilitate development on more platforms than conventionally available HP UX Linux Microsoft with the same productivity and high quality.

General Architecture By contrast with the conventional arrangement illustrates an exemplary software test system as a block diagram. A text command file provides a list of instructions to emulate server data user inputs window validation and response confirmation. The operator interacts with an HCI client having an HCI Test Driver software library that interprets the command file . The HCI client may have a server thread as well as an internal thread that are not replaced by the HCI Test Driver .

The operator reviews the GUI information content in an HCI window associated with the internal thread . Instructions in the command file may be written in American Standard Code for Information Interchange ASCII . The HCI windows may be composed of widgets such as push buttons toggle buttons pull down menus labels and images.

A data server can either be the actual production data server or else a simulator independent of the command file . The server communicates via the server thread to provide condition data to which the internal thread reacts. Communication between the operator and the server with the HCI client is shown by interaction connectors .

The operator can communicate with the HCI Window by a first link to issue a command receive an updated view of that window by the GUI imagery. The HCI Test Driver can communicate by a second link with the HCI Window and by a third link with the HCI Application to send instruction messages and receive return messages.

The HCI Window can communicate by a fourth link with the HCI Application to provide the GUI update. For example the HCI Window may submit a user request to the HCI Application . This procedure can then update the window by changing the characteristic by an update view command.

For example the command file may direct the HCI Test Driver to send a GUI update message to the HCI Application to update the characteristic of a button described later. The HCI Test Driver issues a request for window attributes and or attributes of user inputs. Upon receipt of the attributes the HCI Test Driver compares these against expected parameters for confirmation that the attributes changed appropriately.

Every HCI window can be tested extensively with the HCI Test Driver before being integrated with the tactical interfaces and software systems. In this manner every aspect of the window can be exercised to discover and subsequently repair all the software bugs and to make sure the software behaves correctly. The HCI Test Driver can simulate multiple application servers and their interfaces to the HCI client . The HCI Test Driver may send and receive the same messages that application servers send and receive. The HCI Test Driver can also simulate keypunch input from the operator such as pressing buttons and moving a mouse or other cursor manipulator. The HCI Test Driver may also check the HCI Window to determine if attributes have changed as expected.

Example Windows An exemplary window and associated commands is described and explained in the following paragraphs. This simple window is named Test Window see in and may be created with a Push Button see . An icon represents the Push Button that includes a label Hello for example. The Push Button is named helloPB in this example. In response to the operator clicking the icon representing the Push Button its label changes to Goodbye for example. Then in response to the operator clicking the icon again the label changes back to Hello and so forth.

The particular X Motif code and header files written to generate the Test Window are respectively in TestMW.cc and TestMW.hh and written in C . In this example the header file in a Header Window is located in TestWindowCb.hh shown in FIG. . The application code is located in Code Window is located in TestWindowCb.cc with upper and lower portions shown respectively in .

The Header Window contains procedures in lines of instructions to chose create open and close the Test Window . In addition the header file handles the clicking of the Hello Push Button by a call back procedure . The HCI client represents the GUI software that the operator for the computer platform views on the monitor screen and through which applications can be interacted with or sequenced by the HCI Test Driver .

The code file handles the display and processing of the Test Window . The code file includes procedures to create FIG. A open FIG. B and close the Test Window . Also the code file has a procedure named helloCallback that handles i.e. emulates the operator s clicking of the Hello Push Button called helloPB on the Test Window . This handling procedure contains the instructions that change the Push Button s label to Goodbye and Hello and so forth. A dashed oval denotes a discrepant portion of code for the procedure to be described later provides an example of code verification.

Exemplary embodiments of the Test Window as described in further detail are shown in B and C each featuring a Push Button . shows the Push Button as including a first label with Hello as text. shows the Push Button as including a second label with Goodbye as text. shows the Push Button as including a third label with Hello as text. The first and third labels of the Push Button differ in the number of exclamation points therein representing an instruction discrepancy denoted by an envelope dashed oval in the third label corresponding to the discrepant code .

Testing the Window without the HCI Test Driver In a first operational embodiment the operator exercises the Test Window without the HCI Test Driver . A makefile may be written to compile and bind the Test Window s files to produce an executable file in this case named testMain. A short script named run driver in a command line may be created to run the testMain executable labeled xdev as shown in FIG. . The executable incorporates a command line to receive and process an instruction from the operator . The software for an HCI Application represents the code behind the HCI window that handles the operator s actions. The operator may make a selection by pressing or clicking the Push Button .

Typing run driver in the command line causes the Test Window to open in FIG. A. Then in response to the operator clicking on the Push Button labeled Hello in changes the label to Goodbye in FIG. B. The operator visually verifies that this was performed correctly. Next in response to the operator clicking on the Push Button labeled Goodbye in changes the label back to Hello in FIG. A. The operator visually checks that this was done correctly. However in this example the label instead changes to Hello in FIG. C.

Notice that there is an extra exclamation point shown in the dashed oval . This is due to a bug i.e. coding flaw in the helloCallback code . Examination of the code in the TestWindowCb.cc file may reveal the bug. On the other hand the operator that visually verifies the correct working of the Test Window may easily overlook this subtle defect. In contrast the operator testing this Test Window with the HCI Test Driver receives explicit notice of this bug that causes the display flaw in as is explained later.

If the operator clicks the Push Button again the label will change back to Goodbye in and then back to Hello in FIG. C. Once again the Push Button s label reveals the flaw in the envelope that the operator may have visually neglected and the rather obscure software bug may continue unnoticed.

Testing the Window with the HCI Test Driver To use the HCI Test Driver for testing the Test Window a makefile in is written that includes test tool libraries at arrow Itesttool ItesttoolBase and testtoolXrt being added to the makefile . The same previously described Test Window files TestMW.cc TestMW.hh TestWindowCb.cc and TestWindowCb.hh mentioned above may be used.

The test tool libraries are added to the makefile . The HCI Test Driver provides a custom file named SpecialAction.cc shown in that provides commonly used functions to be used in the command file . The SpecialAction.cc includes operations for creating opening and closing the command file . The operator merely inserts in the window s class name TestWindowCb . After accomplishing this the operator will be able to create open and close the Test Window from the command file as described subsequently.

The command file named test.cmd as a Test Command Window is written as shown in to create and open the Test Window . Then test.cmd runs the same test performed as described above while verifying that the correct label Hello or Goodbye of the Push Button is displayed each time the Push Button is clicked. To finish the command file as test.cmd closes the Test Window and pauses for the operator to observe completion of the testing.

The makefile is used to compile and bind the files thereby producing an executable named testMain. The same script for run driver in as in the previous testMain script may then be used to run testMain. The HCI Test Driver s main routine named testMain.cc may be used instead of the application s main routine to create the HCI Test Driver s windows Command File Window in and HCI Test Driver Window in and and open the Command File Window to read in the command file .

Upon opening the Command File Window in a list of command file options is displayed. These include an Open Command File button highlighted in Start Command File button highlighted in FIG. B. Additional buttons for Command Display and Generate Commands are provided.

The operator may click the Open Command File button to choose the command file desired and the HCI Test Driver to use. This opens a Select Command File Window shown in that includes a filter dialog box for listing command file name candidates among a directories list with a highlighted directory name testWindow . together with a file list having a highlighted file name test.cmd . The chosen file may be displayed in a selection dialog box . After verifying that the test.cmd command file name corresponds to the chosen file the operator may click the OK i.e. okay button .

The operator may then click the Start Command File button so the HCI Test Driver can begin reading in and executing test.cmd . The HCI Test Driver Window opens as FIG. . The HCI Test Driver Window includes a list of upper display buttons including Command Lines To HCI Messages From HCI Messages and Check Log . In this example the Command Lines button is highlighted. The Check Log tab displays test results and other summary information.

The contents from these display buttons may be displayed in a text box while a status box may provide instructional options. In this example the HCI Test Driver Window enables the operator to observe each line of test.cmd appear in the text box as that line is executed. The file name test.cmd for the command file that was previously selected is identified in a Command File Name dialog box . The HCI Test Driver can be arranged to automatically start the command file in response to a particular command file being specified on the command line .

In this example a down arrow icon that may be colored red for emphasis is shown below the dialog box and adjacent to a progress bar. The down arrow means that at least one of the tests failed i.e. that there is a bug in the Test Window code. A prompt section below the arrow and the progress bar includes buttons for Yes No Continue Options and Close .

The operator may click on the Check Log button at the top of the HCI Test Driver Window to see which test s failed. The HCI Test Driver Window changes to highlight the Check Log button and adjusts the information displayed in the text box as shown in FIG. . In particular the text box shows by respective arrows and that the second and fourth test cases failed due to non matching strings.

In this manner the HCI Test Driver informs the operator which tests failed and why they failed. The Test Driver Window tells the operator that the label for the Push Button should display Hello with two exclamation points while the label actually displayed Hello with three exclamation points . This discrepancy corresponds to the code portion within the dashed oval in the TestWindowCb.cc code file .

Now the operator can return to TestWindowCb.cc in FIG. and find the bug. The portion of TestWindowCb.cc displayed in is approximately midway between views and . The operator can immediately observe that the wrong number of exclamation points is in the code. The fix appears as shown in the helloCallback procedure at the line pointed to by arrow . The string Hello within dashed oval provides the correct instruction in the code.

The operator can readily test the Test Window again with the HCI Test Driver by running a script shown in with run driver and test.cmd as concatenated instructions . The operator can enter the command file as test.cmd on the same command line with the script run driver so the HCI Test Driver will immediately begin execution .

In response the HCI Test Driver Window opens as FIG. and starts running the test.cmd command file. This time the HCI Test Driver returns an up arrow that may be colored green for emphasis because all the tests passed. The operator can also examine the text box to verify that all the tests passed. Selecting the Check Log button replaces the information displayed in the text box as shown in in the HCI Test Driver Window . The operator can examine the information that summarizes the test results denoted by arrow in the text box verifying that all the tests passed.

Supplemental Features When executing a command file Prompt and Pause commands may be used to control the testing process with appropriately selectable buttons. When a Prompt command is encountered e.g. FIG. the Yes and No buttons are sensitive and the operator responds either Yes or No to the prompt. For example the operator may be prompted to verify that actual results matched expected results. When a Pause command is encountered the Continue button is sensitive. Selection of the Options button displays an HCI Test Driver Options Window as shown in to the operator .

The HCI Test Driver Options Window includes several toggle buttons for setting test options. The Demo Mode toggle button is used to simulate mouse movement when widget activation commands are used in the command file . When such an instruction is used the mouse moves to the referenced widget before activating that widget. To accelerate the test process the Pause toggle button may turn off pauses in the command file . The Prompt toggle button may turn off prompt commands. When these buttons are toggled off the commands are ignored. The Test Window Visible option is used to hide the Test Window .

A slider bar is used to slow down or speed up mouse movements when the Demo Mode button is selected. Log option toggle buttons are used to save the contents of the tabs on the HCI Test Driver Window . The operator may enter a file name in an appropriate dialog box line to enable toggling the associated one of the toggle buttons .

An Enter Commands function not shown in the HCI Test Driver displays an Enter Commands Window shown in FIG. . The Enter Commands Window enables commands to be entered manually in a text editing box . The Enter Commands window also has an associated pop up menu also shown in FIG. . The menu includes editing command selections such as Copy Paste and Clear erase text in box . Beneath the text editing box are window operation buttons such as Execute commands Clear and Close window .

A View Command File function not shown in the HCI Test Driver displays a View Command File Window shown in containing the command filename with a pointer at a Pause command to the current command being executed in FIG. . The command lines are listed in a Commands pane . This window also has options to step through the command file and to execute selected commands by directing the pointer . The commands in the Commands pane can be selected in non contiguous order. The View Command File Window also includes window operation buttons such as Stop Execute Selected command and Close window . In addition to the button a double click action on a command line will result in that command being executed.

A Generate Commands Window in provides a mechanism for automatically generating commands that can be inserted in a command file for testing window components. The Generate Commands option in displays the Generate Commands Window to assist in the creation of command files used for testing. This window allows the operator to specify Source User Interface Language UIL and or App Defaults files associated with the window being tested. The window includes four pull down menu tab for generating commands. These include a File tab an Edit tab a Search tab and an Options tab . The menu details are shown in .

The Generate Commands Window has three panes shown in used to build command files the Command File pane the Generated Commands pane and the Generated Messages pane . The Command File pane contains the command file specified when the HCI Test Driver starts or one that was opened from the File pull down menu in FIG. B. The Generated Commands pane contains instructions generated from information extracted from the UIL and App Defaults files.

The command filenames can be provided in the Command File pane . The Generates Commands Window extracts information from these files and inserts in the instructions produced therefrom in the Generated Commands pane . Messages processed by the window may be extracted from the source code of the command file in the Generated Messages pane . This window also includes a Close button for the window s termination.

The File Selection group includes Select UIL File Select AppDefaults File Select Source File and Select By Widget . The Category Selection group includes Select By Command Select By Template and Select By Message . Additional selections include generation and display options for the Generated Commands pane and the Generated Messages pane . The Generation group includes options inter alia Generate Commands Refresh Comments Execute Selected Commands and Generate Messages . The Display group includes options for providing or erasing commands and or messages.

Widget names and classes are extracted from the UIL file and context sensitive help information is extracted from the App Defaults file. Once the files are specified instructions can be generated and inserted into a command file . The File Edit and Search pull down menus apply to the pane that currently has focus i.e. not grayed out and hence inactive . For example if Save As in is selected and the Generated Commands pane has focus then the information therein would be saved in the specified file having a given filename . The Options pull down menu in contains several options that are available depending on which files or options have been selected.

For example when a UIL file has been specified via Select by UIL in the Generate Commands button becomes available. When this button is selected commands are generated and inserted in the Generated Commands pane and the following options become available Select by Widget Select by Commands Refresh Commands and Execute Selected Commands .

The Select By options display the selected commands in the Generated Commands pane . Selection of the Select By Widget option displays a Widget List Window as shown in FIG. . The window includes an Item List in Items pane a selection box to identify the highlighted item and a selection of buttons including an OK button . When a widget from the Items pane and the OK button are selected those commands specifically associated with the selected widget are then displayed.

Likewise selection of the Select By Command option displays a first Command Class List Window as shown in FIG. . The window includes a Command Class List in Items pane a selection box to identify the highlighted class and a selection of buttons including an OK button . When a command class from the Class pane and the OK button are selected those commands specifically associated with the command class are displayed. Similarly the Select By Template option displays a second Command Class List Window as shown in so that a single command can be created such as a verification check on a particular parameter.

A Build Command Window as shown in displays a command and all of its parameters enabling the operator to edit the parameters and add the command to the command file . In this example a Check Button Color command is displayed with a Parameter Selection pane a Parameter Value field and a series of buttons including an Add To Cmd File button and an OK button .

Items listed under Parameter Name field column in the Parameter pane can be edited under Parameter Value field column accompanied by a Select column . The Select column contains two types of arrows a down arrow and a left arrow .

The down arrow indicates that the parameter is a list of values displayed in a Parameter Selection Window as shown in when that arrow is selected. An Items pane provides a list of Parameters from which to select thereby including the item name in a Selection box beneath which are a series of buttons including an OK button . When a value from the Items pane and the OK button are selected the value is automatically inserted in the Parameter Value field column and that value is updated. The left arrow indicates that the operator enters a value to the left in the Parameter pane under the Parameter Value field column . Once a command line has been created that instruction can be added to the command file by selecting the Add To Cmd File button .

Exemplary Lists There are several different types of commands supported by the HCI Test Driver . Check commands shown in are used to check expected results versus actual results. Control commands shown in control the flow of testing. File commands shown in provide access to user files log files and command files. Message commands for sending and receiving messages may be limited to a Send To Hci Message command although an additional Set Send To Hci Command Alias command can be used to define send commands for each necessary interface. Set commands shown in allow the operator to set the behavior the HCI Test Driver and Widget commands shown in permit the operator to activate widgets in the window under test.

This may be useful when using Xrt Tables and verification of the sort order becomes necessary. The Check Xrt Sort Order under item kk. verifies a column in an Xrt Table to verify the values in each row. When generating this command the current contents of the Xrt Table may be used in this command. In particular a Check Xrt Sort Order command may be generated for each column. If another sort button is selected then the Refresh Commands button can be selected again and new commands can be generated with the new sort order and added to a command file .

Command Formats for the HCI Test Driver Window include formats for files controls messages sets and widgets. Check commands shown in B C and D provide examples regarding type of data entry and characteristics of the information content. Control commands shown in provide operational procedures such as for interruption initiation and flag settings. File commands shown in provide formats for opening saving and closing files. Message commands shown provide for a message sent to the HCI client . Set commands shown in address interface modes. Widget commands shown in provide for characteristics of buttons and menu items. Parameter commands shown in B and C describe parameters and their logical values.

The HCI Test Driver reads command lines from a user specified text file and executes those commands. The HCI Test Driver strips all leading blanks from a command line as well as empty command lines and any command line beginning with a sharp symbol that is thereby interpreted as a comment. If the command line contains a that is not enclosed in quotes the and remainder of the line is considered to be a comment. A command line may extend over several text lines. A carriage return indicates that the command line is continued on the next line. The command line consists of a directive and one or more parameters. Parameters are delimited by blanks. A string surrounded by double quotes is considered to be a single parameter. Parameters containing the character must be enclosed in quotes.

Conclusion This is an example of how to test a very simple window with the HCI Test Driver . The techniques provided herein can reduce workload and save enormous man hour resources for larger and more intricate codes. As the developer fixes software bugs and adds functionality the entire HCI Window can be quickly tested versus only testing the changes and total branch coverage can be achieved. The HCI Test Driver provides an environment for testing HCI Windows independently without using server sockets for the receipt and transmission of messages. The HCI Test Driver enhances GUI development and productivity significantly thereby providing an invaluable tool for software integration and validation.

Advantages of using the HCI Test Driver include a providing a quick start for HCI development by reducing lead time of simulation components b providing scalability portability and ease of use c ensuring commonality of core classes templates tools and libraries for development of any HCI Window d containing a set of common classes used by most HCI Applications to shorten development time e containing a set of classes that can be customized for each application f containing a set of classes to interface with the HCI Test Driver for standalone testing of the application g providing the structure for adding multiple client server interfaces such as pipes and sockets from the HCI client to application servers and h providing abstract classes for applications to use to derive other classes in order to implement application specific requirements.

In addition the HCI Test Driver a enables the HCI Window to be tested without using sockets for the receipt and transmission of messages b simulates sending messages to the HCI client from multiple interfaces c can fully test the HCI Window before integration with other software systems d runs using ASCII command files that are easily modifiable for new test cases and e can be run in automation mode to simulate the operator pushing buttons and using the HCI Window .

While certain features of the embodiments of the invention have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the true spirit of the embodiments.

