---

title: Signature search architecture for programmable intelligent search memory
abstract: Memory architecture provides capabilities for high performance content search. The architecture creates an innovative memory that can be programmed with content search rules which are used by the memory to evaluate presented content for matching with the programmed rules. Content search rules include of regular expressions which are compiled to finite state automata (FSA) and further include of patterns of strings a first set of which are compiled to a compressed signature database and a second set of which are compiled into FSAs. The finite state automata are then programmed in Programmable Intelligent Search Memory (PRISM) programmable FSA rule blocks and the compressed signature database is programmed in the PRISM signature search engines for evaluating content with the content search rules. A compiler compiles the content search rules for evaluation by PRISM memory. When the content being searched matches any of the rules programmed in the Programmable Intelligent Search Memory (PRISM), action(s) associated with the matched rule(s) are taken.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07831606&OS=07831606&RS=07831606
owner: 
number: 07831606
owner_city: 
owner_country: 
publication_date: 20071206
---
Priority is claimed to Provisional Application Ser. No. 60 965 267 filed on Aug. 17 2007 entitled Embedded programmable intelligent search memory Provisional Application Ser. No. 60 965 170 filed on Aug. 17 2007 entitled 100 Gbps security and search architecture using programmable intelligent search memory Provisional Application Ser. No. 60 963 059 filed on Aug. 1 2007 entitled Signature search architecture for programmable intelligent search memory Provisional Application Ser. No. 60 961 596 filed on Jul. 23 2007 entitled Interval symbol architecture for programmable intelligent search memory Provisional Application Ser. No. 60 933 313 filed on Jun. 6 2007 entitled FSA context switch architecture for programmable intelligent search memory Provisional Application Ser. No. 60 933 332 filed on Jun. 6 2007 entitled FSA extension architecture for programmable intelligent search memory Provisional Application Ser. No. 60 930 607 filed on May 17 2007 entitled Compiler for programmable intelligent search memory Provisional Application Ser. No. 60 928 883 filed on May 10 2007 entitled Complex symbol evaluation for programmable intelligent search memory Provisional Application Ser. No. 60 873 632 filed on Dec. 8 2006 entitled Programmable intelligent search memory Provisional Application Ser. No. 60 873 889 filed on Dec. 8 2006 entitled Dynamic programmable intelligent search memory which are all incorporated herein by reference in their entirety as if fully set forth herein.

Priority is also claimed to U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Embedded programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled 100 Gbps security and search architecture using programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Interval symbol architecture for programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled FSA context switch architecture for programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled FSA extension architecture for programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Compiler for programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Complex symbol evaluation for programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Programmable intelligent search memory U.S. Patent Application number not yet assigned filed on Dec. 6 2007 entitled Dynamic programmable intelligent search memory which are all co pending U.S. patent applications of common ownership.

This invention relates generally to memory technology and in particular to a new high performance intelligent content search memories for signature search regular expression search and a compiler for it.

Many modern applications depend on fast information search and retrieval. With the advent of the world wide web and the phenomenal growth in its usage content search has become a critical capability. A large number of servers get deployed in web search applications due to the performance limitations of the state of the art microprocessors for regular expression driven search.

There have been significant research and development resources devoted to the topic of searching of lexical information or patterns in strings. Regular expressions have been used extensively since the mid 1950s to describe the patterns in strings for content search lexical analysis information retrieval systems and the like. Regular expressions were first studied by S. C. Kleene in mid 1950s to describe the events of nervous activity. It is well understood in the industry that regular expression RE can also be represented using finite state automata FSA . Non deterministic FSA NFA and deterministic FSA DFA are two types of FSAs that have been used extensively over the history of computing. Rabin and Scott were the first to show the equivalence of DFA and NFA as far as their ability to recognize languages in 1959. In general a significant body of research exists on regular expressions. Theory of regular expressions can be found in Introduction to Automata Theory Languages and Computation by Hopcroft and Ullman and a significant discussion of the topics can also be found in book Compilers Principles Techniques and Tools by Aho Sethi and Ullman.

Computers are increasingly networked within enterprises and around the world. These networked computers are changing the paradigm of information management and security. Vast amount of information including highly confidential personal and sensitive information is now being generated accessed and stored over the network. This information needs to be protected from unauthorized access. Further there is a continuous onslaught of spam viruses and other inappropriate content on the users through email web access instant messaging web download and other means resulting in significant loss of productivity and resources.

Enterprise and service provider networks are rapidly evolving from 10 100 Mbps line rates to 1 Gbps 10 Gbps and higher line rates. Traditional model of perimeter security to protect information systems pose many issues due to the blurring boundary of an organization s perimeter. Today as employees contractors remote users partners and customers require access to enterprise networks from outside a perimeter security model is inadequate. This usage model poses serious security vulnerabilities to critical information and computing resources for these organizations. Thus the traditional model of perimeter security has to be bolstered with security at the core of the network. Further the convergence of new sources of threats and high line rate networks is making software based perimeter security to stop the external and internal attacks inadequate. There is a clear need for enabling security processing in hardware inside core or end systems beside a perimeter security as one of the prominent means of security to thwart ever increasing security breaches and attacks.

FBI and other leading research institutions have reported in recent years that over 70 of intrusions in organizations have been internal. Hence a perimeter defense relying on protecting an organization from external attacks is not sufficient as discussed above. Organizations are also required to screen outbound traffic to prevent accidental or malicious disclosure of proprietary and confidential information as well as to prevent its network resources from being used to proliferate spam viruses worms and other malware. There is a clear need to inspect the data payloads of the network traffic to protect and secure an organization s network for inbound and outbound security.

Data transported using TCP IP or other protocols is processed at the source the destination or intermediate systems in the network or a combination thereof to provide data security or other services like secure sockets layer SSL for socket layer security Transport layer security encryption decryption RDMA RDMA security application layer security virtualization or higher application layer processing which may further involve application level protocol processing for example protocol processing for HTTP HTTPS XML SGML Secure XML other XML derivatives Telnet FTP IP Storage NFS CIFS DAFS and the like . Many of these processing tasks put a significant burden on the host processor that can have a direct impact on the performance of applications and the hardware system. Hence some of these tasks need to be accelerated using dedicated hardware for example SSL or TLS acceleration. As the usage of XML increases for web applications it is creating a significant performance burden on the host processor and can also benefit significantly from hardware acceleration. Detection of spam viruses and other inappropriate content require deep packet inspection and analysis. Such tasks can put huge processing burden on the host processor and can substantially lower network line rate. Hence deep packet content search and analysis hardware is also required.

Internet has become an essential tool for doing business at small to large organizations. HTML based static web is being transformed into a dynamic environment over last several years with deployment of XML based services. XML is becoming the lingua franca of the web and its usage is expected to increase substantially. XML is a descriptive language that offers many advantages by making the documents self describing for automated processing but is also known to cause huge performance overhead for best of class server processors. Decisions can be made by processing the intelligence embedded in XML documents to enable business to business transactions as well as other information exchange. However due to the performance overload on the best of class server processors from analyzing XML documents they cannot be used in systems that require network line rate XML processing to provide intelligent networking. There is a clear need for acceleration solutions for XML document parsing and content inspection at network line rates which are approaching 1 Gbps and 10 Gbps to realize the benefits of a dynamic web based on XML services.

Regular expressions can be used to represent the content search strings for a variety of applications like those discussed above. A set of regular expressions can then form a rule set for searching for a specific application and can be applied to any document file message packet or stream of data for examination of the same. Regular expressions are used in describing anti spam rules anti virus rules anti spyware rules anti phishing rules intrusion detection rules extrusion detection rules digital rights management rules legal compliance rules worm detection rules instant message inspection rules VOIP security rules XML document security and search constructs genetics proteomics XML based protocols like XMPP web search database search bioinformatics signature recognition speech recognition web indexing and the like. These expressions get converted into NFAs or DFAs for evaluation on a general purpose processor. However significant performance and storage limitations arise for each type of the representation. For example an N character regular expression can take up to the order of 2memory for the states of a DFA while the same for an NFA is in the order of N. On the other hand the performance for the DFA evaluation for an M byte input data stream is in the order of M memory accesses and the order of N M processor cycles for the NFA representation on modern microprocessors.

When the number of regular expressions increases the impact on the performance deteriorates as well. For example in an application like anti spam there may be hundreds of regular expression rules. These regular expressions can be evaluated on the server processors using individual NFAs or DFAs. It may also be possible to create a composite DFA to represent the rules. Assuming that there are X REs for an application then a DFA based representation of each individual RE would result up to the order of X 2 states however the evaluation time would grow up to the order of X N memory cycles. Generally due to the potential expansion in the number of states for a DFA they would need to be stored in off chip memories. Using a typical access time latency of main memory systems of 60 ns it would require about X 60 ns N M time to process an X RE DFA with N states over an M byte data stream. This can result in tens of Mbps performance for modest size of X N M. Such performance is obviously significantly below the needs of today s network line rates of 1 Gbps to 10 Gbps and beyond. On the other hand if a composite DFA is created it can result in an upper bound of storage in the order of 2which may not be within physical limits of memory size for typical commercial computing systems even for a few hundred REs. Thus the upper bound in memory expansion for DFAs can be a significant issue. Then on the other hand NFAs are non deterministic in nature and can result in multiple state transitions that can happen simultaneously. NFAs can only be processed on a state of the art microprocessor in a scalar fashion resulting in multiple executions of the NFA for each of the enabled paths. X REs with N characters on average can be represented in the upper bound of X N states as NFAs. However each NFA would require M iterations for an M byte stream causing an upper bound of X N M processor cycles per loop . Assuming the number of processing cycles are in the order of 10 cycles then for a best of class processor at 4 GHz the processing time can be around X N M 2.5 ns which for a nominal N of 8 and X in tens can result in below 100 Mbps performance. There is a clear need to create high performance regular expression based content search acceleration which can provide the performance in line with the network rates which are going to 1 Gbps and 10 Gbps.

The methods for converting a regular expression to Thompson s NFA and DFA are well known. The resulting automata are able to distinguish whether a string belongs to the language defined by the regular expression however it is not very efficient to figure out if a specific sub expression of a regular expression is in a matching string or the extent of the string. Tagged NFAs enable such queries to be conducted efficiently without having to scan the matching string again. For a discussion on Tagged NFA refer to the paper NFAs with Tagged Transitions their Conversion to Deterministic Automata and Application to Regular Expressions by Ville Laurikari Helsinki University of Technology Finland.

A programmable intelligent search memory PRISM of my invention is a memory technology that supports orders of magnitude larger number of regular expressions in a single chip for current and emerging content search applications. PRISM memory supports FSAs of a number of states n which may be any integer like 8 16 32 and the like. However at times there may be a need to support regular expressions with number of states which are more than that represented in a single PRISM FSA. For such cases it may be necessary to allow multiple PRISM FSAs to be coupled together to support the bigger REs. Further there are certain applications where the rules are specified as a group of rules that are evaluated together and there may be nesting amongst the rule groups. Such applications may have groups of rules that may be evaluated simultaneously or one after the other and need a means of communicating from one FSA to another. My invention describes an architecture that enables creation of extensible FSAs to support needs such as the ones described above and the like. Modern programming languages and Operating systems like Perl and POSIX allow for regular expressions with an interval or a range. For example if in a regular expression the symbol a appears 5 consecutive times then it is possible to represent that as a 5 . In general such expressions can be a x y which means symbol a must appear in the expression from x to y times or a x which means the symbol a must appear at least x times for this expression to be valid or a x which means the symbol a must appear exactly x times for this expression to be valid. My invention also describes an architecture that enables the creation of such complex regular expressions with interval representation in an efficient way without using up a large number of states depending on the interval range x and y in the expressions like a x y or a x or a x or the like. There is a need for creating a compiler flow that can target converting regular expression rules in to a form that PRISM based search engines can use to process input data for content specified by the regular expression rules. My invention describes a compiler for regular expressions that can be used for PRISM.

Many applications also represent content search rules as a set of signature patterns like those used for anti virus application. Modern anti virus solutions have in the order of 100 000 or more signatures. A big portion of these signatures are typically represented as a string of characters.

However a smaller portion of the signatures may also comprise of regular expressions. Bloom filters have been suggested in literature as a way to test set membership of any content within a list of large fixed patterns or signatures. Bloom filters cannot handle regular expressions and hence for applications like anti virus other solutions have to be used for those signatures with regular expressions which may be a relatively large number from a composite DFA based realization for high performance. My invention describes a way to evaluate a large number of signature patterns comprising fixed patterns and regular expression based patterns like those in anti virus applications in a compact and efficient way.

I describe a FSA extension architecture a complex regular expressions with interval architecture signature recognition architecture and a high performance Programmable Intelligent Search Memory for searching content with regular expressions as well as other pattern searches like signatures. Programmable intelligent search memory of this patent can have many uses wherever any type of content needs to be searched for example in networking storage security web search applications XML processing bio informatics signature recognition genetics proteomics speech recognition database search enterprise search and the like. The programmable intelligent search memory of my invention may be embodied as independent PRISM memory integrated circuits working with or may also be embodied within microprocessors multi core processors network processors TCP Offload Engines network packet classification engines protocol processors regular expression processors content search processors network search engines content addressable memories mainframe computers grid computers servers workstations personal computers laptops notebook computers PDAs handheld devices cellular phones wired or wireless networked devices switches routers gateways unified threat management devices firewalls VPNs intrusion detection and prevention systems extrusion detection systems compliance management systems wearable computers data warehouses storage area network devices storage systems data vaults chipsets and the like or their derivatives or any combination thereof.

The regular expressions may optionally be tagged to detect sub expression matches beside the full regular expression match. The regular expressions are converted into equivalent NFAs and optionally into tagged NFAs. The PRISM memory also optionally provides ternary content addressable memory functionality. So fixed string searches may optionally be programmed into the PRISM memory of my invention. PRISM memory of this invention enables a very efficient and compact realization of intelligent content search using FSA to meet the needs of current and emerging content search applications. For clarity as used in this patent the terms programmable intelligent search memory search memory content search memory or PRISM memory are used interchangeably and have the same meaning unless specifically noted. Further for clarity as used in this patent the term memory when used independently is used to refer to random access memory or RAM or Dynamic RAM DRAM or DDR or QDR or RLDRAM or RDRAM or FCRAM or Static RAM SRAM or read only memory ROM or FLASH or cache memory or the like or any future derivatives of such memories.

The PRISM memory performs simultaneous search of regular expressions and other patterns also referred to as rules or regular expression rules or pattern search rules or patterns or regular expressions in this patent against the content being examined. The content may be presented to the search memory by a companion processor or PRISM controller or content stream logic or a master processor or the like which may be on the same integrated circuit chip as the PRISM memory or may be on a separate device. The content to be searched may be streaming content or network packets or data from a master processor or data from a disk or a file or reside in on chip memory or off chip memory or buffers or the like from which a controller may present it to the search memory arrays for examination. The content search memory arrays may initially be configured with the regular expression rules converted into NFAs or tagged NFAs and optionally other pattern search rules. I describe a compiler for converting regular expressions into rules supported by PRISM. I also describe architecture for compact efficient and high speed implementation for programming compiling and searching a large number of signature patterns for applications like anti virus. PRISM memory may optionally comprise of configuration control logic which may be distributed or central or a combination thereof. The configuration control logic may optionally address PRISM memory cells to read and or write FSA rules or other patterns to be searched. Once the PRISM memory is setup with all the related information about the NFAs and other rules the content to be examined can be presented to the PRISM memory. PRISM memory provides capabilities to update rules or program new rules or additional rules in line with the content examination within a few clock cycles unlike the current regular expression processors which require the content evaluation to stop for long periods of time until large tables of composite DFAs are updated in an external or internal memory. Typically the content is presented as a stream of characters or symbols which get examined against the rules in the PRISM memory simultaneously and whenever a rule is matched the PRISM memory array provides that indication as a rule match signal which is interpreted by the control logic of the PRISM. There may be multiple rule matches simultaneously in which case a priority encoder which may also be programmable is used to select one or more matches as the winner s . The priority encoder may then provide a tag or an address or an action or a combination that may have already been programmed in the priority encoder which may be used to look up related data from associated on chip or off chip memory that may optionally determine the next set of actions that may need to be taken on the content being examined. For example in case of a security application if a set of regular expressions are defined and programmed for spam detection then if one or more of these rules when matched can have action s associated with them that the message or content may need to quarantined for future examination by a user or it can have an action that says the content should be dropped or enable a group of regular expressions in the PRISM memory to be applied to the content or the like depending on the specific application. The PRISM memory architecture comprises of means or circuits or the like for programming and reprogramming of the FSA rules and optionally CAM signatures and masks. It further comprises of means or circuits or the like to stream the content to be searched to the PRISM memory arrays. It may further comprise of priority encoder which may optionally be programmable. The PRISM memory may optionally comprise of random access memory on chip or off chip which is used to store actions associated with specific rule matches. The PRISM memory may optionally comprise of database extension ports which may be optionally used when the number of rules is larger than those that may fit in a single integrated circuit chip. The PRISM memory may optionally comprise of clusters of PRISM memory cells that enable a group of FSA rules to be programmed per cluster. The PRISM memory clusters may optionally comprise of context memory for fast storage and retrieval of FSA states for examination of content that belongs to different streams or contexts or flows or sessions or the like as described below referred to as context memory. For clarity context memory or global context memory or local context memory or cluster context memory all comprise of memory like random access memory or RAM or Dynamic RAM DRAM or DDR or QDR or RLDRAM or RDRAM or FCRAM or Static RAM SRAM or read only memory ROM or FLASH or cache memory or the like or any future derivatives of such memories as discussed above. The PRISM memory may optionally comprise of global context memory beside the local cluster context memory for storage and retrieval of FSA states of different contexts and enable supporting a large number of contexts. The cluster context memory may optionally cache a certain number of active contexts while the other contexts may be stored in the global context memory. There may optionally be off chip context memory as well which can be used to store and retrieve FSA states for much larger number of contexts. The PRISM memory may optionally comprise of cache or context control logic also referred as context controller that manages the cluster global or external context memory cache or a combination thereof. The cache or context control logic may optionally be distributed per cluster or may be central for the PRISM memory or any combination thereof. The PRISM controller or the content stream logic that streams the content to be searched may be provided with an indication of the context of the content being searched or it may detect the context of the content or a combination thereof and may optionally direct the context memory and associated control logic i.e. the context controller to get the appropriate context ready. Once the context memory has the required context available an indication may be provided to PRISM configuration control logic that it may program or load the context states in the PRISM memory. The PRISM configuration control logic also referred as configuration controller in this patent may optionally first save the current context loaded in the set of active FSA blocks before loading the new context. The configuration controller s and the context controller s may thus optionally store and retrieve appropriate contexts of the FSAs and start searching the content against the programmed rules with appropriate context states of the FSAs restored. Thus PRISM memory may optionally dynamically reconfigure itself at run time based on the context of the content or the type of the application or the like or a combination thereof enabling run time adaptable PRISM memory architecture. The contexts as referred to in this patent may as examples without limitation be related to specific streams or documents or network connections or message streams or sessions or the like. The PRISM memory may process content from multiple contexts arriving in data groups or packets or the like. For content search in applications where the content belonging to one context may arrive interspersed with content from other contexts it may be important to maintain the state of the content searched for a context up to the time when content from a different context gets searched by PRISM memory. The context memory or cache with the associated controllers as described in this patent enable handling of multiple contexts.

For clarification the description in this patent application uses term NFA to describe the NFAs and optionally when tagging is used in regular expressions to describe tagged NFA unless tagged NFA is specifically indicated. All NFAs may optionally be tagged to form tagged NFAs hence the description is not to be used as a limiter to apply only to tagged NFAs. The descriptions of this patent are applicable for non tagged NFAs as well and tagging is an optional function which may or may not be implemented or used and thus non tagged NFAs are covered by the teachings of this patent as will be appreciated by one skilled in the art. At various places in this patent application the term content search memory content search memory search memory and the like are used interchangeably for programmable intelligent search memory or PRISM memory. These usages are meant to indicate the content search memory or PRISM memory of this invention without limitation.

Berry and Sethi in their paper From Regular Expressions to Deterministic Automata Published in Theoretical Computer Science in 1986 showed that regular expressions REs can be represented by NFAs such that a given state in the state machine is entered by one symbol unlike the Thompson NFA. Further the Berry Sethi NFAs are free. A V term RE can be represented using V 1 states NFA using Berry Sethi like NFA realization method. The duality of Berry Sethi method also exists where all transitions that lead the machine out of a state are dependent on the same symbol. This is shown in the paper A Taxonomy of finite automata construction algorithms by Bruce Watson published in 1994 in section 4.3. I show a method of creating NFA search architecture in a memory leveraging the principles of Berry Sethi s NFA realization and the dual of their construct. The NFA search memory is programmable to realize an arbitrary regular expression using the compiler flow of this invention to convert a regular expression to that usable by PRISM. The compiler of this invention follows the principles of Berry Sethi FSA construction to convert regular expressions into an FSAs and creates various data structures that are required for PRISM to operate as a programmable regular expressions engine.

This PRISM memory and the compiler for PRISM of this patent may be used for many applications like those for detecting intrusions extrusions and confidential information disclosure accidental or malicious or intended regulatory compliance search using hardware for regulations like HIPAA Sarbanes Oxley Graham Leach Bliley act California security bills security bills of various states and or countries and the like deep packet inspection detecting spam detecting viruses detecting worms detecting spyware detecting digital rights management information instant message inspection URL matching application detection detection of malicious content and other content policy based access control as well as other policy processing content based switching load balancing virtualization or other application layer content inspection for application level protocol analysis and processing for web applications based on HTTP XML and the like and applying specific rules which may enable anti spam anti virus other security capabilities like anti spyware anti phishing and the like capabilities. The content inspection memory may be used for detecting and enforcing digital rights management rules for the content. The content inspection memory may also be used for URL matching string searches genetic database searches proteomics bio informatics web indexing content based load balancing sensitive information search like credit card numbers or social security numbers or health information or the like.

Classification of network traffic is another task that consumes up to half of the processing cycles available on packet processors leaving few cycles for deep packet inspection and processing at high line rates. The described content search memory can significantly reduce the classification overhead when deployed as companion search memory to packet processors or network processors or TOE or storage network processors or the like.

I describe a FSA extension architecture a complex regular expressions with interval architecture signature recognition architecture and a regular expression compiler for a high performance Programmable Intelligent Search Memory for searching content with regular expressions as well as other pattern searches like signatures. The regular expressions may optionally be tagged to detect sub expression matches beside the full regular expression match. The regular expressions are converted into equivalent FSAs that may optionally be NFAs and may optionally be converted into tagged NFAs. The PRISM memory also optionally supports ternary content addressable memory functionality. So fixed string searches may optionally be programmed into the PRISM memory. PRISM memory enables a very efficient and compact realization of intelligent content search using FSA to meet the needs of current and emerging content search applications. Unlike a regular expression processor based approach the PRISM memory can support tens of thousands to hundreds of thousands of content search rules defined as regular expressions as well as patterns of strings of characters. A compiler for compiling these regular expression rules into PRISM compatible data structure is described in this invention to enable PRISM to perform the content inspection using the compiled rules. The PRISM memory performs simultaneous search of regular expressions and other patterns. The content search memory can perform high speed content search at line rates from 1 Gbps to 10 Gbps and higher when the best of class server microprocessor can only perform the same tasks at well below 100 Mbps. The content search memory can be used not only to perform layer through layer searches that may be used for classification and security applications it can also be used to perform deep packet inspection and layer through layer content analysis.

The PRISM memory may be embodied inside network interface cards of servers workstations client PCs notebook computers handheld devices switches routers and other networked devices. The servers may be web servers remote access servers file servers departmental servers storage servers network attached storage servers database servers blade servers clustering servers application servers content media servers VOIP servers and systems grid computers servers and the like. The PRISM memory may also be used inside an I O chipset of one of the end systems or network core systems like a switch or router or appliance or the like.

The PRISM memory may also be embodied on dedicated content search acceleration cards that may be used inside various systems described in this patent. Alternatively PRISM memory may also be embodied as a content search memory inside a variety of hardware and or integrated circuits like ASSPs ASICs FPGA microprocessors multi core processors network processors TCP Offload Engines network packet classification engines protocol processors regular expression processors content search processors mainframe computers grid computers servers workstations personal computers laptops handheld devices cellular phones wired or wireless networked devices switches routers gateways XML accelerators VOIP servers Speech recognition systems bio informatics systems genetic and proteomics search systems web search servers electronic vault application networks and systems Data Warehousing systems Storage area network systems content indexing appliances like web indexing email indexing and the like chipsets and the like or any combination thereof. Alternatively PRISM memory blocks may be embedded inside other memory technologies like DRAM SDRAM DDR DRAM DDR II DRAM RLDRAM SRAM RDRAM FCRAM QDR SRAM DDR SRAM CAMs Boundary Addressable Memories Magnetic memories Flash or other special purpose memories or a combination thereof or future derivates of such memory technologies to enable memory based content search.

One preferred embodiment of the invention is in an integrated circuit memory chip that may support around 128 000 8 symbol regular expression rules in current process technologies. A second preferred embodiment of the PRISM technology is an integrated circuit memory chip that may support around 8 000 regular expression rules in current process technologies to support applications where a lower content search memory cost is required. Each process generation may provide ability to store around twice as many PRISM memory bits as the previous generation. Thus in one preferred embodiment the PRISM memory would be able to support tens of thousands of eight state FSA and can potentially support over 100 000 FSAs. There are many variations of the PRISM memory architecture can be created that can support more or less FSAs depending upon various factors like the number of states per FSA the chip die area cost manufacturability expectations and the like which will be appreciated by a person with ordinary skill in the art

I describe a FSA extension architecture a complex regular expressions with interval architecture signature recognition architecture and a regular expression compiler for a high performance Programmable Intelligent Search Memory for searching content with regular expressions as well as other pattern searches like signatures. The regular expressions may optionally be tagged to detect sub expression matches beside the full regular expression match. The regular expressions are converted into equivalent NFAs or FSAs and optionally into tagged NFAs. The PRISM memory also optionally supports ternary content addressable memory functionality. So fixed string searches may optionally be programmed into the PRISM memory of my invention. PRISM memory of this invention enables a very efficient and compact realization of intelligent content search using FSA to meet the needs of current and emerging content search applications. Unlike a regular expression processor based approach the PRISM memory can support tens of thousands to hundreds of thousands of content search rules defined as regular expressions as well as patterns of strings of characters. The PRISM memory performs simultaneous search of regular expressions and other patterns. The content search memory can perform high speed content search at line rates from 1 Gbps to 10 Gbps and higher using current process technologies. The description here is with respect to one preferred embodiment of this invention in an integrated circuit IC chip it will be appreciated by those with ordinary skill in the art that changes in these embodiments may be made without departing from the principles and spirit of the invention. The illustrations are made to point out salient aspects of the invention and do not illustrate well understood IC design elements components and the like implementation of the invention in integrated circuits so as not to obscure the invention.

Ability to perform content search has become a critical capability in the networked world. As the network line rates go up to 1 Gbps 10 Gbps and higher it is important to be able to perform deep packet inspection for many applications at line rate. Several security issues like viruses worms confidential information leaks and the like can be detected and prevented from causing damage if the network traffic can be inspected at high line rates. In general content search rules can be represented using regular expressions. Regular expression rules can be represented and computed using FSAs. NFAs and DFAs are the two types of FSAs that are used for evaluation of regular expressions. For high line rate applications a composite DFA can be used where each character of the input stream can be processed per cycle of memory access. However this does have a limit on how fast the search can be performed dictated by the memory access speed. Another limiter of such approach is the amount of memory required to search even a modest number of regular expression rules. As discussed above NFAs also have their limitations to achieve high performance on general purpose processors. In general today s best of class microprocessors can only achieve less than 100 Mbps performance using NFAs or DFAs for a small number of regular expressions. Hence there is a clear need to create targeted content search acceleration hardware to raise the performance of the search to the line rates of 1 Gbps and 10 Gbps. PRISM memory is such a high performance content search hardware that can be targeted for high line rates. The invention of this patent describes a compiler to make PRISM memory structures useful for processing content against a large number of regular expressions compiled to leverage PRISM capabilities.

As described earlier regular expression can be represented using FSA like NFA or DFA. illustrates Thompson s construction for the regular expression xy y yx. Thompson s construction proceeds in a step by step manner where each step introduces two new states so the resulting NFA has at most twice as many states as the symbols or characters and operators in the regular expression. An FSA is comprised of states state transitions and symbols that cause the FSA to transition from one state to another. An FSA comprises at least one start state and at least one accept state where the start state is where the FSA evaluation begins and the accept state is a state which is reached when the FSA recognizes a string. Block represent the start state of the FSA while block is an accept state. Block represents state and represents state . The transition from state to state is triggered on the symbol x and is represented as a directed edge between the two states. Thompson s NFA comprises of transitions which are transitions among states which may be taken without any input symbol.

Finite State Automaton can evaluate incoming symbols or characters against the regular expression language of the automaton and detect when an input string is one of the strings recognized by it. However it is advantageous in certain conditions to know if a certain sub expression of the regular expression is also matched. That may be enabled by tagging the NFA as described in the paper by Ville Laurikari referred earlier. Following description illustrates how the inventions of this patent enable tagged NFA realization in PRISM memory. The tagging for sub expression checking may involve further processing of the FSA to uniquely identify sub expression matching. However for illustration purpose if in the regular expression xy y yx if one desires to detect if the sub expression xy is in the recognized string one can tag the state as a tagged state. Thus whenever the regular expression transitions through state the sub expression match or tag match may be indicated. There may also be need to detect if a specific transition leads the regular expression through a desired sub expression. In such a case a tag start state and a tag end state may be marked. For instance if it is desired to detect if the transition from state to state is taken then the state may be marked as a tag start state and state may be marked as a tag end state. The tagged FSA implementation may then indicate the beginning of the tag transition when the FSA reaches the tag start state and then indicate the end of the tag transition when the FSA reaches the tag end state. If the FSA moves from the tag start state immediately followed by transitioning into tag end state then the tagged FSA can indicate the match of a tagged transition. The illustrations in the description below do not illustrate this aspect of tagged NFA though it may optionally be supported in PRISM and may be easily implemented as follows or other means for example by adding a tag start and tag end state flags as memory bits or flip flops and the logic for the tag transition detection to follow the steps described above as can be appreciated by those with ordinary skill in the art. The patent of this disclosure enables detection of sub expressions using tagging.

The and illustrate generic four state NFAs where all the transitions from each state to the other are shown based on the left biased or right biased construct characteristics. However not all four state NFAs would need all the transitions to be present. Thus if a symbol is received which would require the FSA to transition from the present state to the next state when such transition on the received input symbol is not present the NFA is said to not recognize the input string. At such time the NFA may be restarted in the start state to recognize the next string. In general one can use these example four state NFAs to represent any four state RE in a left biased LB or right biased RB form provided there is a mechanism to enable or disable a given transition based on the resulting four states NFA for the RE.

Similarly also illustrates states and transitions for a right biased NFA. The figure illustrates a right biased NFA with a state A which has incoming transitions from state B state C and state D on receiving input symbols S S and S respectively. However the transitions from each of the states B C and D to state A occur only if the appropriate state dependent control is set besides receiving the appropriate input symbol. The state dependent control for transition from state B to state A is Vwhile those from states C and D to state A is Vand Vrespectively. Transition to the next state A is dependent on present state A through the state dependent control V. Thus transition into a state A occurs based on the received input symbol and if the state dependent control for the appropriate transition is set. Thus one can represent any arbitrary four states right biased NFA by setting or clearing the state dependent control for a specific transition. All state transition controls for a given state form a state dependent vector SDV which is comprised of V V V and Vfor the illustration in for the left biased and the right biased NFAs.

If there are n states supported per FSA rule then each SLB needs n bit SDV which can be stored as a n bit memory location 3 bits allocated to start tag and accept flags 1 bit for LB RB m bit action storage. Thus if n 16 and m 6 then the total storage used per SLB would be a 26 bit register equivalent which is a little less than 4 bytes per state. If tag start flag and tag end flags are supported not illustrated then the number of memory bits would be 28 bits. If multiple tagged expressions need to be enabled then the number of bits for tagging may be appropriately increased. When the number of states in a resulting FSA of a RE is more than n supported by the FSA of PRISM a mechanism is required that would allow the PRISM memory to support such rules. The patent of this application describes such a mechanism and an architecture for that as described below.

PRISM memory allows various elements of the FSA blocks to be programmable such that the compiler of this invention can accept a regular expression and compile it with information for various PRISM state elements to make the general purpose programmable state machine of PRISM FSA to implement the specific regular expression rule. The compiler can compile other rules and later replace the current rule with another rule in the same PRISM FSA or may use another PRISM FSA or a combination of the like.

PRISM memory may comprise of left biased NFAs right biased NFAs or a combination of them or may be comprised as selectable left biased or right biased NFAs with logic similar to . All such variations are within the scope of this invention as may be appreciated by one with ordinary skill in the art.

Rules distribution engine block then communicates the rules to specific system or systems that comprise of PRISM memory. The search rules targeted to specific systems may be distributed to a host processor or a control processor or other processor of the system that comprises PRISM memory. A software or hardware on the receiving processor may then optionally communicate the rules to the PRISM memory by communicating with the external interface block and the PRISM controller block described below to configure and or program the PRISM memory with the FSA rules and signature search engines with signature rules. The Rules distribution engine may optionally communicate directly with the PRISM controller through the external interface block if the external interface and PRISM controller optionally support such functionality. The rules may be distributed using a secure link or insecure link using proprietary or standard protocols as appropriate per the specific node s capability over a network.

The PRISM controller receives incoming data for examination using regular expression rules or for examination using patterns to be matched and may optionally store them into data buffer memory block before presenting it to the PRISM memory cluster arrays and signature search engines . The PRISM memory may optionally directly stream the content to be examined to the content stream logic block which may stage the content for examination by the PRISM memory cluster arrays block and signature search engines . The PRISM controller maintains the record of the content being processed and once the content is processed it informs the master processor. The PRISM memory cluster arrays inform the global priority encoder and evaluation processor block of the results of the search. When a match to a rule is found the priority encoder and evaluation processor may retrieve an action associated with the rule from the global action memory block depending on programmable policies and may optionally provide this to the PRISM controller. The PRISM controller may optionally inform the master processor about the search results. The PRISM controller may execute the specific action or policy defined for the rule match. The actions may optionally comprise to stop further content evaluation enable a certain set of rules to be examined by enabling appropriate cluster array and pass the content through that PRISM memory cluster array for further examination or inform the master processor of the result and continue further examination or hold the match result in on chip or off chip memory or buffers for the master processor to request this information later or any combination thereof or the like. If the PRISM memory is configured to examine network traffic in a flow through configuration not illustrated it may also be programmed to drop the offending packet or stop the specific TCP connection or the session or the like. Optionally the master processor may receive the match information and may take specific actions on the content stream.

The address decode and control logic block is coupled to the PRISM controller the external interface the PRISM memory cluster arrays the global priority encoder and evaluation processor the database expansion port as well as other blocks through a coupling interface . The PRISM memory may support a large number of regular expressions in some preferred embodiments as discussed above however if there are applications that need more rules then there may optionally be a database expansion port which would enable the expansion of the rules by adding additional PRISM memory ies to the database expansion port. The database expansion port may provide a seamless extension of the number of rules and may use additional memory space in the host or master processor. There are multiple ways of enabling the database expansion as may be appreciated by those with ordinary skill in the art. The address decode and control logic is also coupled to optional cluster address decode and FSA controller block and decodes addresses for the PRISM memory locations which are used to hold FSA rule block programming information as well as the FSA state information. It may perform the address decode memory read memory write and other PRISM memory management control functions by itself or working in conjunction with cluster address decode and FSA controller. The blocks and optionally may be programmed to provide configuration information for the clusters. The configuration information may optionally comprise of size of the NFAs e.g. 8 state or 16 state or the like CAM functionality enabling tagged NFA related configuration context addresses if appropriate for local cluster context addressing and or global context addresses clusters specific configurations that may support a mixed CAM and Regular Expression functionality at the PRISM memory level action memory association for specific FSA rules or clusters or a combination thereof and the like. The PRISM memory cluster arrays and other blocks like global and local priority encoder and evaluation processor blocks and local not illustrated and global action memories block and the like may get configured and programmed with information before the content inspection begins. Further since PRISM memory supports dynamic reconfiguration of rules its programming and configuration may be updated during the content inspection as well for example when a new security threat has been discovered and a new rule to catch that security violation needs to be programmed. The PRISM memory may provide multiple content streams to be processed through the PRISM memory cluster arrays using context mechanism which associates each content stream with a specific context which may optionally be assigned a specific context ID.

The cluster address decode and FSA controller block may decode incoming addresses for configuring reading or writing from PRISM memory locations or the like of the cluster PRISM array block which is comprised of an array of PRISM NFA rule blocks illustrated above in and and also referred to as PRISM Search Engines PSE block in this patent and activates memory location s word line and or bit lines or other word lines or content lines or mask lines or the like or a combination thereof described below to read write and or access the specific PRISM memory location. There may optionally be cluster specific bit line drivers and sense amplifiers block and bit line control logic block which may be used to read or write specific bits in the PRISM cluster memory array block . These circuits are well understood by memory designers with ordinary skill in the art. The sense amplifiers and drivers may optionally be present at the global PRISM memory level illustrated in depending on the tradeoffs of die area performance cost power and the like which one with ordinary skill in the art can easily appreciate. The benefit of having local sense amps and drivers is potentially creating lower interconnect load for individual memory bits which in turn can help improve the performance. Typically the block may be operating during the configuration context switching or other maintenance operations like storing and retrieving specific NFA state information or refreshing specific PRISM FSA memory bits if appropriate and the like. Generally during content processing the block may be dormant unless there is a match or an error or the like when it may start performing the necessary tasks like communicating the match action policy error or the like to the PRISM controller initiating context switching and the like. The PRISM controller block coupled with the content stream logic block content staging buffer address decode and control logic block and the cluster FSA controllers block may present the content to be examined to the PRISM NFA rule blocks. The content to be examined may be streamed by the block from the data buffer or memory or from external memory or a combination into the content staging buffer. The content staging buffer is coupled to cluster search buffer and cluster search control to align the appropriate content to the clusters for searching. The content staging buffer may hold content from the same context or multiple contexts depending on the configuration of the clusters and the like. The content is presented to the cluster PRISM array that comprises of the PRISM NFA rule blocks for examination in a sequence timed using a control signal like a clock or enable or a combination. The NFA rule blocks perform their inspection and indicate whether there is any rule match or optionally if there is any CAM pattern match or optionally any tag match and the like. The match signals are looked at by cluster level local priority encoder and evaluation processor block which may determine if there is a match and if there are multiple matches which match should be used or all matches should be used or the like depending on the configuration. This block may be coupled to global priority encoder and evaluation processor block which may perform a similar operation by examining match signals from multiple clusters. The local and global evaluation processors of these blocks may optionally generate address es for the winning match es to the global action memory or external memory or a combination that may store appropriate action information that needs to be retrieved and processed to determine action s that need to be taken as a result of specific rule match es . There may be optional cluster level action memory not illustrated for fast retrieval of action information. This cluster level action memory may act as a cache of the global and or external memory based action storage. As described earlier the FSA controller block coupled with local context memory block its memory controller block along with the local and global evaluation processor and priority encoders coupled to global action and context memories may be used to store and retrieve context information from and to configure the PRISM cluster arrays with appropriate FSA states.

Each PSE of a PRISM memory cluster may be addressed using one PRISM Memory location or a set of PRISM memory locations or a combination thereof. All internal memory elements of a PSE like the each state dependent symbol memory mask vector memory SDV memory or the initialization vector memory and the like may each be mapped as individual memory locations in the PRISM memory address space or may each be addressable in a PSE address space once the PSE is selected from a PRISM memory address or the like as may be appreciated by one with ordinary skill in the art. One preferred embodiment may comprise of 22 PRISM Memory address bits where in the upper 17 address bits are used to select a specific PSE in an embodiment with 128 000 PSEs and the lower 5 address bits are used to select a specific memory element of the selected PSE as described above. Other variations of such an arrangement are within the scope and spirit of this invention as may be appreciated by one with ordinary skill in the art. The number of address bits allocated to select PSEs depends on the number of PSEs and the number of address bits allocated to select memory elements of a PSE depend on the number of memory elements in one PSE which may in turn depend on the number of states per PSE FSA extension mechanisms per PSE symbol size and the like as may be appreciated by one with ordinary skill in the art. Further a specific PSE within a duster may be addressed or selected by PRISM memory cluster row address and a column address which would be derived from the PSE address bits. One preferred embodiment of PRISM memory with 128 000 PSEs may use 128 rows and 8 columns of PSEs per PRISM memory cluster there by supporting 1024 PSEs per PRISM memory cluster. In such a PRISM memory embodiment upper 7 bits of the 22 bits for PSE address may be allocated to select a specific PRISM memory cluster and the next 10 bits of the PSE address may optionally be used to select a specific PSE in a PRISM memory cluster while the lower 5 bits may optionally be used to select a specific memory element of the selected PSE of the selected PRISM memory cluster. The 10 bit address for selecting a specific PSE of a PRISM memory cluster may further be allocated such that upper 7 bits of that may be used as a PSE row address selection and the remaining 3 bits of the address used as a PSE column address selection. There are multiple other ways to perform the addressing of PRISM memory as may be appreciated by one with ordinary skill in the art and all such variations are within the spirit and scope of the teachings of this invention.

Although the description here and elsewhere within this patent may be with regards to precharge circuits it will be appreciated by those with ordinary skill in the art that other non precharge circuits or logic may be used to realize the same functionality and all such variations are within the scope and spirit of the teachings of this patent.

Blocks and illustrate the programming of RE abc defghi jkL RE abcdefghijkLmnop RE xyz defghi jkL and RE xyzdefghijklmnop respectively using the Row wise and Column wise FSA extension mechanisms of this patent. The block column Row FSA programs the terms abc and jkL of RE where as the term defghi is programmed in the column Row FSA. The Row wise extension architecture and mechanisms described above and illustrated in is used here except that the width of each FSA is 8 states. In an exemplary 8 state FSA based FSA extension there may be eight precharge lines like and the like which may each be activated by the corresponding state bit of the coupled FSAs which may provide a greater freedom for coupling various state terms of a large FSA. The transitions and take the FSA from one FSA to the next FSA as per the regular expression state transitions. Local state transitions within an FSA are not illustrated as described above. Thus when the FSA reaches state c it may enable local transitions into states a and j and enable an inter FSA transition into state d . Similarly the state i may enable a local transition within that FSA to state d and enable an inter FSA transition to states a and j of Column Row FSA. When the accept state L is reached the match signal for the associated FSA is asserted and the cluster priority encoder and evaluation processor block takes the appropriate action that is programmed.

The compiler may assign various FSA states to appropriate state bit slices like depending on the row wise coupling architecture which may be different than that illustrated in as may be appreciated by one with ordinary skill in the art and such variations are within the scope this invention. For instance instead of coupling precharge line to line another scheme could couple it to a signal like or or the like and any such variations are covered within the scope of this invention.

Block illustrates RE to be programmed using the column wise FSA extension. The compiler may assign different terms of the RE to appropriate state bit slices of the FSAs to enable the transitions required to complete the correct RE state transitions between various terms of the RE and may optionally do it based on the available FSA state bits and the like. For instance in this assignment the term defghi is assigned to Row Column FSA where the state d is assigned to B which aligns directly below state z of the term xyz assigned to Row Column FSA. This enables the column wise state transition between these two terms of the regular expression when state z is reached and the RE needs to transition to state d based on the next received input symbol. One salient point to notice is that the state i of Row Column is aligned with the accept state L in B of Row. This would prevent a required transition from state i to states x or state j of the RE using column wise transition. This is avoided by creating a duplicate state i in FSA in Row Column B which is entered from state h in Row Column. Thus the column wise FSA extension architecture enables the state i to be reached in FSA in Row B. Both states i in both FSAs would be active simultaneously when a symbol i is received following a string defgh . The state i in Row is then locally enabled to cause transitions into states x or states j of the follow states as per the RE where as the state i in Row is enabled to cause a local transition to state d in Row which is also required to be taken as per the regular expression. Thus the PRISM compiler has freedom to align various RE terms to effect the proper transitions by duplicating the same state in multiple FSA bits and FSAs. When the accept state L is reached the match signal for the associated FSA is asserted and the cluster priority encoder and evaluation processor block takes the appropriate action that is programmed.

Block illustrates RE to be programmed using column wise FSA extension as well where the freedom of assignments of various states to the compiler are illustrated using assignments between two rows of the Column FSAs where multiple transitions are illustrated between various state bits distributed between the two FSAs.

In one exemplary embodiment there may be column wise FSA extension enabled between each group of four PRISM Memory cluster PSE rows and the row wise extension may be enabled between each of those rows and eight columns of PSEs. If a regular expression needs more states than the states enabled by such a large group of FSAs such an RE may optionally be split into multiple FSAs or may optionally use rule group FSA extension architecture and mechanisms illustrated in and described above. Thus by using the column wise and row wise FSA extensions of this patent any arbitrary FSA may be represented within PRISM even when the individual PSE may support lot fewer FSA states as illustrated above.

As discussed above modern programming languages and operating systems support a range or interval mechanism for regular expression symbols. For example if in a regular expression the symbol a appears 5 consecutive times then it may be possible to represent that as a 5 instead of aaaaa . In general such expressions can be a x y which means symbol a must appear in the expression from x to y times or a x which means the symbol a must appear at least x times for this expression to be valid or a x which means the symbol a must appear exactly x times for this expression to be valid or the like. Such symbols represented with the interval for example a x y where x and y are integers and x is equal to or less than y are referred to as the interval symbol in this patent. One way to support regular expressions with interval symbols is by fully expanding the interval and repeating the symbol to which the interval applies. This can be a very inefficient way of implementing such an expression in hardware. There is a need to represent such regular expressions in a compact manner to better utilize the integrated circuit chip area. My invention also describes an architecture that enables the creation of such complex regular expressions with interval representation in an efficient way without using up a large number of states for the interval range from x to y .

Such an FSA when implemented in PRISM search engines can use up precious resources for the same symbol in this case a to facilitate the state transitions. This would be a very inefficient utilization of PRISM search engine resources particularly if the interval is wider or the number of symbol repetitions being expected is big. For example if the expression is ba 3 17 c or ba 25 c or the like then PRISM FSA representation using the fully expanded regular expression as illustrated in will be very inefficient.

The state transition circuits of the PRISM FSA are augmented to account for the interval symbol state as illustrated in . The figure illustrates an n bit interval symbol control vector ISCV C through Cn . This ISCV control vector can be of a different width as well as may be appreciated by one with ordinary skill in the art if the number of states that the interval symbol state can transition to is different than n . The interval symbol control vector bits C through Cn are programmable and may be realized as a location in PRISM FSA memory space. The ISCV vector may also be realized as a register or any other storage mechanism. The state that depends on the interval symbol state to be valid before it is entered would have its appropriate interval symbol control vector bit set. The NAND gates through couple the interval symbol state valid signal CntV to the appropriate state when the corresponding interval symbol vector bit C through Cn is active and the received symbol is the one associated with the state. For instance if the regular expression a 3 5 c needs to be represented using the Interval Symbol State logic illustrated in the the compiler for the PRISM FSA may assign symbol a to RS assign 3 to CSL assign 5 to CSH set state dependent vector bit V to 1 assign symbol c to RSn assign the appropriate range selection in the count memory and transition detection block and assign interval symbol control vector bit Cn to 1 along with all the other programmable state dependent vector bits and other PRISM symbol bits and the like are also setup appropriately. When the state Q is entered on the receipt of the symbol a assuming that the previous FSA state from which this transition occurs is valid or this is a start state or the like the counter starts counting the number of times the symbol a has been received in a sequence. When symbol a is received 3 to 5 times the output signals and are both asserted which is then detected by the block to indicate that the interval symbol state has matched the symbol a in a sequence of 3 to 5 times by asserting the signal CntV . When the next symbol received is a c the gate has all its inputs Cn CntV and RSn asserted which then couples a 1 to the state Qn which corresponds to the state for the symbol c of the regular expression a 3 5 c . If this state is an accept state and the appropriate accept state vector is set for the PRISM FSA as described above then a regular expression match is flagged.

All the memory blocks like count low evaluation memory the count high evaluation memory or the ICSV memory and the like described above comprise of typical memory architecture as all the other memory or storage elements of PRISM. The implementation details of such memory elements and storage are not illustrated so as not to obscure the invention as may be appreciated by one with ordinary skill in the art.

There are many variations of implementing PRISM Search engine with interval symbol as may be appreciated by one with ordinary skill in the art. Even though the above description of the interval symbol state and the PRISM Search engine is illustrated to be implemented in a specific way one with ordinary skill in the art may appreciate that there are multiple ways to accomplish the interval symbol state representation and all such variations or mechanisms are considered to be within the scope of this invention.

The PRISM compiler flow then creates the state transition list per state from the follow states above which essentially form the state transition list from each state. The PRISM compiler flow then extracts terminal or accept states of the regular expression. For the example expression above the accept states are d a and f. Once all the processing of the FSA states is done the marked symbols are converted back to their unmarked form and the appropriate PRISM programmable FSA data structures generated block for example SDV per state FSA state symbols symbol mask if any initial or first states accept states as well as optional tag states if the regular expression is tagged a left biased or right biased control if PRISM implements such option any associated action to be taken the FSA ID that will hold this RE and the like. If the regular expression needs to use more states than those supported in a single PSE the compiler assigns the RE to multiple FSAs and couples them together using row wise column wise or rule group FSA extensions or a combination there of or may split the RE into multiple rules to fit the specific embodiment of PRISM its characteristics and the like. Further if the regular expression being represented has an interval symbol and the PRISM search engine with support for interval symbol is present the compiler sets up the appropriate memory values in the interval symbol logic like the CSL CSH ICSV and the like to realize the regular expression with interval symbol in PRISM using the methods described above. If the PRISM search engines with interval symbol do not exist then the compiler may expand the interval symbol and then program the expanded regular expression in appropriate PRISM search engine. The interval symbol programming in PRISM may also be coupled with the FSA extension mechanisms of PRISM described above. This RE in the PRISM compiled form may either be kept in memory or storage or the like and once all such REs are processed they may all be stored compiled rules database block . Each compiled RE may be deposited individually in the database or all rules may be deposited once they are all processed or a combination. The compiled rules database may be an actual database or a file or a storage element or the like that records the compiled rules data that may then be programmed into an appropriate PRISM device by the rules distribution engine working with the PRISM controller of the corresponding PRISM device.

The signature search on a large number of fixed signatures has been suggested in literature using a technique called bloom filters. Bloom filters compress a large number of fixed signatures for clarity fixed signatures mean signatures without regular expressions in this patent using multiple e.g. k where k is an integer uncorrelated hash functions applied on each signature and set a memory bit corresponding to each hash index generated by each hash function. When looking for content belonging to the set of signatures the same hash functions are applied to the content and hash indices generated. These hash indices are used to extract the memory bit values at those locations. If each memory bit value is set then there is a chance that the processed content stream may be part of the signatures being searched. Once such a determination is made an exact match function is applied on the content stream and the fully expanded signature or signatures associated with the bloom filter match to ascertain that the content being processed indeed matches one of the signatures in the set of signatures. If all the bytes of the signature match the appropriate number of bytes of the content a signature match is flagged which may then be used to take appropriate actions associated with such a signature match. For example in an anti virus application such a match indicates presence of a virus and hence the content may be quarantined or removed or cleaned or if it is streaming content the stream dropped or the like based on the anti virus policy.

PRISM uses bloom filters with modifications to support regular expression signatures and variable length signatures to overcome some of the key limitations of bloom filters. When implementing signature search rules in hardware using bloom filters for high performance like from multi 100 Mbps through 10 Gbps and higher a number of bytes of content have to be processed simultaneously. For example if operating frequency of a hardware processor implementing bloom filter is 125 MHz and it processes one byte per clock cycle one search engine can process up to 1 Gbps and hence to process incoming stream of content at 10 Gbps 10 simultaneous search engines are required where each search engine s search is at one byte offset from the other. Thus if there are 10 search engines then the first search engine may process the stream at byte number while fifth search engine may process the stream at byte number and the like with each search engine skipping 10 bytes from one cycle to the next to achieve 10 Gbps. Multiple complexities arise in such an implementation. First each search engine requires a dedicated memory with the bloom filter database to check membership of the content being processed in the set of signatures. Second typically the signature rules are variable length and hence each signature length needs to be processed separately which causes additional search engines and memories. For instance anti virus signatures may be from couple of bytes to over a hundred bytes with majority of them being over 12 to 15 bytes. Since bloom filters are essentially hash functions that have to operate fast a fixed number of content bytes are processed by each hash engine. Hence the signature database is separated in same length signature sets up to a certain length for example from 2 bytes to 15 bytes and then all signatures longer than 15 bytes are truncated at 15 bytes and placed in the same set. Then each signature set is processed by a set of hash functions to generate a bloom filter for each length of signature bytes. There are search engines implemented to process each signature length of bytes from the content. Thus if there are 14 sets of signature lengths then 14 sets of search engines are implemented with their dedicated bloom filter database memory.

As indicated above if the line rate to be processed is 10 Gbps and each search engine only operates at 1 Gbps then for each set search engines are required and for all 14 sets a total of 140 search engines are required. Thus the requirement of the number of search engines can explode depending on the type of the signatures.

One preferred embodiment of PRISM signature search engines avoid the explosion in the number of search engines driven by the signature length sets by picking a number N as the length of the signatures that get implemented using the signature search engines. Any signatures that are less than N bytes get realized using the PRISM FSA Search Engines PSE described above. This may save significant integrated circuit chip area and resources.

PRISM signature compiler flow illustrated in reads signatures and processes them until all the signatures presented to it by the rules parser are processed . It retrieves each signature and checks the length of the signature by comparing it to a length N where N is an integer. Typically for an anti virus application N may be 12 13 14 or 15 or like. If the number of bytes in the signature is less than N then that signature is presented to PRISM FSA compiler flow illustrated in which treats the signature as a simple regular expression of character string and compiles it for evaluation by PRISM FSA search engines. However if the length of the signature is equal to or more than N then N bytes of the signature are extracted and k different hash functions are applied to those bytes which then generate k hash indices H through Hk . These hash indices are then used to create a compressed signature database table which gets implemented in PRISM as a memory array. The compressed signature database table entries which translates to associated memory locations of PRISM memory corresponding to the indices are set to 1 . The width of the hash indices depends on the number of the signatures in the rules. For one embodiment if the number of signatures is 128 000 k may be 4 and the number of memory locations or compressed signature database table entries may be 512 000. For another embodiment for 128 000 signatures k may be 4 and the number of memory locations or compressed signature database table entries may be 1 024 000. There may be multiple signatures that may result in some of the Hash indices H through Hk to be the same. Also different signatures may set the memory locations H through Hk to 1 which can cause a false positive when content search is being performed. During content search k hash indices H through Hk are generated from N bytes of content using the same hash functions used to generate the compressed signature database and then the values at the memory locations H through Hk are looked up. If all the locations have a value 1 then that means the content is likely to contain a signature from the signature set used to generate the compressed signature database. However due to the reasons outlined above multiple different signatures could have set the memory locations H through Hk for the content being examined to 1 . To ensure that there indeed is a match an exact match of the content has to be performed with the signatures that could set one of the index like H to a 1 when all the memory locations H through Hk return a value 1 . To perform this exact match each signature is also stored with all its bytes in a PRISM memory or an external memory coupled to PRISM. Each signature is associated with one index location where for example hash index H computed for each signature can always be used as a memory address or index to store the corresponding signature. However since multiple signatures can map to the same hash index those signatures are used in PRISM to form a deterministic Finite State Automaton DFA or an Aho Corasick AC Finite State Automaton or the like to perform exact match. Thus when a match is found through the compressed signature database lookup using hash indices one of the hash index for example H is used as a reference to point to the root of the automaton in an internal or external memory location where the DFA or Aho Corasick AC FSA for all signatures that map to this hash index are stored. Then content bytes are used to traverse the DFA or AC FSA or the like to see if there is a match with one of the signatures that also generate H as a hash index value. If an exact match comparison finds a match the content is declared to have matched a specific signature otherwise there is no match or the compressed signature database match is referred to as a false match. Such compressed organization of signatures may produce false positives but never generates false negatives i.e. if the content indeed contains a pattern that matches one of the signatures it will always be flagged as a match during the compressed signature database lookup as well as during exact match evaluation and will never be missed however anytime a match is found from the compressed signature database does not always mean that an exact match will be found. Thus to facilitate the exact match operation the signature search compiler flow generates a DFA or an AC FSA or the like and sets up a pointer to that at a location in internal or external memory associated with index H or Hn used for performing exact match as illustrated in . One preferred embodiment may use DFAs for storing exact match signatures. Another preferred embodiment may use AC FSA for storing exact match signatures. Other ways of storing and retrieving exact match signatures are all within the scope and spirit of the teachings of this patent as may be appreciated by one with ordinary skill in the art. A signature database entry for each signature with its compressed database and the exact match database comprised of DFA or AC FSA or the like is then generated as illustrated in . Once all the signatures have been processed a complete signature database comprising the compressed signature database as well as the exact match DFA or AC FSA or the like is generated block which is then used by the rules distribution engine to program it in PRISM nodes that support signature searches.

The width of the hash indices generated depends on the size of the compressed signature database. In one preferred embodiment there may be at least k times the total number of signatures where k is the number of hash functions and is an integer as the database size to provide adequate dispersion of hash results from various signatures.

Byte length specific signature search engine retrieves X bytes of content being examined and then generates k hash indices using k hash engines that use X bytes through . The hash engines each perform a different hash function on the retrieved X bytes. The hash functions being used are the same as those used on the signature rules to create the compressed signature database. The output index of each hash engine is then used to lookup the compressed signature database setup in the Signature Hash Memory for X byte length signatures . Since there are k hash functions k separate memory ports are used to simultaneously access the memory values at each of the hash index H through Hk for a high speed implementation. For a lower performance solution k memory look ups through a single memory port may optionally be used. The signature hash memory through M may be multi ported with k ports or signature hash memory block may be replicated such that each of the hash index location is read simultaneously. The outputs of the signature hash memory corresponding to the hash indices are coupled to match logic also referred to as coarse match logic in this patent . If all outputs of coarse match logic are set a coarse level match is generated by the coarse match logic which indicates that there is a good probability that a signature match has occurred. However since hashing is a many to one function it is possible that the coarse match may not mean an actual match exists with all bytes of a signature and to ascertain the match an exact match needs to be performed. To enable an exact match operation the search engine creates a coarse match descriptor which comprises of information like the flow ID or content ID or packet ID or the like the byte offset where the coarse match was flagged one hash index that was generated for the coarse match and the like. It puts the coarse match descriptor in an exact match queue from which the exact match controller retrieves it and performs an exact match. The exact match controller retrieves the coarse match descriptors from the exact match queues like through M in an order like round robin or smallest length signature search engine to higher length search engine or the like. As described above full signatures are processed by the signature search compiler flow to create an exact match data structure or data base in memory using either a DFA or Aho Corasick FSA or the like algorithm which can then be traversed or walked using a sequence of characters from the input content. All signatures that map to a specific hash index are all used to generate an exact match data structure for that hash index. Thus every hash index which has any signatures that map to it has an exact match data structure associated with it which may either provide the root node of the FSA or the like or can provide a pointer to the root node which may then be used to traverse the FSA based on the sequence of the input content where a coarse match is found. The exact match controller implements an exact match logic which enables the traversal of exact match data structure stored in memory coupled to the exact match controller through the memory interface . The exact match controller may start retrieving the packet bytes from the signature search controller starting at an address from the packet information retrieved from the coarse match descriptor. Then each byte of the content is used to walk through the exact match data structure by retrieving the root node of the FSA of the signatures stored at the hash index used as an offset in to the memory table storing the exact match signatures. The exact match data structure walk progresses one or more bytes per clock cycle retrieving the next state of the FSA based on the currently received input byte or bytes. Once a leaf node is reached it indicates the completion of the search and if the leaf node is not an empty node it indicates that the signature is completely matched and an exact match is flagged. However if the leaf node is an empty node then it means that the content stream at the flagged location does not meet any of the exact match signatures. If an exact match is detected by the exact match controller it may communicate this to the signature search controller and the PRISM controller which may then take an appropriate action as described by the policy associated with the matched signature. The exact match controller walks through the exact match queues of each of the byte length specific signature search engines to ensure that if more than one coarse match is found from a byte location of the content all such matches are processed. However if one of the coarse match results in an exact match the other match requests for that content may or may not be performed as per the policy programmed in the signature search controller for the application like anti virus.

One issue with architecture like the one illustrated in is that there is a need to have multiple byte length specific signature search engines to process all the variable size signatures which can result in an inefficient utilization of the hardware resources. Further when the line rate of the signature search engine needs to be increased by replication all byte length specific engines also have to be replicated as many times as the multiple in the line rate performance improvement. Additionally when developing a hardware solution that can be used for a variety of applications whose signatures may change over a period of time it is difficult to estimate how large the byte length specific signature hash memory through M should be to accommodate all applications that can use the signature search engines.

The PRISM memory of this invention may be manufactured into hardware products in the chosen embodiment of various possible embodiments using a manufacturing process without limitation broadly outlined below. The PRISM memory in its chosen embodiment may be designed and verified at various levels of chip design abstractions like RTL level circuit schematic gate level layout level etc. for functionality timing and other design and manufacturability constraints for specific target manufacturing process technology. The design would be verified at various design abstraction levels before manufacturing and may be verified in a manufactured form before being shipped. The PRISM memory design with other supporting circuitry of the chosen embodiment at the appropriate physical layout level may be used to create mask sets to be used for manufacturing the chip in the target process technology. The mask sets are then used to build the PRISM memory based chip through the steps used for the selected process technology. The PRISM memory based chip then may go through testing packaging process as appropriate to assure the quality of the manufactured product.

A memory architecture comprising programmable intelligent search memory PRISM for content search wherein the PRISM memory provides search capability for regular expression based search and a regular expressions are compiled into a format recognized by PRISM and that follows the PRISM FSA algorithm.

The regular expression compiler comprises of one or more of the following steps in no specific order 

The PRISM memory comprises of FSA extension architecture and mechanisms to enable programming of regular expressions that are larger than the basic PSE FSA search states. The FSA extension architecture may optionally comprise of Row wise FSA extension mechanisms or column wise FSA extension mechanisms or FSA rule groups extensions or a combination thereof to support large regular expressions and optionally to support groups of regular expressions that can be used to enable execution of other groups of regular expressions when a certain event in the first rule group is activated.

The PRISM memory Rule group FSA extension architecture may comprise of External state vectors and may optionally comprising of rule group control vectors. The ESVs and RCVs may optionally be addressed as memory locations that may be programmed by the PRISM controller or an external master processor or the cluster evaluation processor or a global evaluation processor or a combination to enable transitions into and out of rule groups in PRISM.

The Column wise FSA architecture may further comprise of Forwarding vector up or down local forwarding vectors up or down up control vector down control vector or a combination there of.

The row wise FSA architecture may further comprise of global state dependent vectors global control vectors global state transition controls global control network or a combination.

The PRISM control vectors like GSDV GCV FV LV LUV UV DC UC RCV or the like may be implemented as memory locations accessed for from programming from the PRISM address decode and control logic or PRISM cluster address decode and FSA controller or PRISM controller or a combination there of.

PRISM memory architecture that enables replicating states of an FSA that may enable proper FSA extensions of REs using FSA extension architecture and mechanisms described above.

The PRISM memory comprises of architecture and mechanisms to enable programming of regular expressions that comprise interval symbols like a x y and the like. The PRISM search engine with interval symbol comprises of at least one interval counter block that is used to count a number of times an event or a symbol or the like has been received. The PRISM search engine with interval symbol further comprises at least one count low evaluation memory which is used to program the interval symbol low limit and is used to compare the interval counter value with that programmed in the count low evaluation memory. The PRISM search engine with interval symbol further comprises at least one count high evaluation memory which is used to program the interval symbol high limit and is used to compare the interval counter value with that programmed in the count high evaluation memory. The PRISM search engine with interval symbol further comprises at least one interval symbol control vector memory to hold the interval symbol state dependent transition control vector bits that enable the transition from an interval symbol state to other ISCV enabled states of the PRISM FSA.

The PRISM memory with interval symbol memory compiler may further comprise of programming interval symbol state parameters like the state symbol the state low count limit the state high count limit the interval symbol type or the mode or a combination of the foregoing to enable programming of regular expressions with interval symbols into one or more PRISM search engines. If the regular expression being compiled by the compiler needs more interval symbol states than those provided by a PRISM search engine the compiler may also use FSA row wise or column wise or a combination FSA extension architecture mechanisms as described above.

The PRISM memory further comprises an array of search memory circuits that provide the regular expression search functions for searching content from documents messages or packets or other data received from the network or the local host or a master processor or a network processor or TCP Offload Engine or Processor or Storage Network processor or a security processor or other processor or a combination thereof.

The PRISM memory further comprises of a plurality of clusters of the search memory circuits that provide regular expression search functions for a plurality of regular expressions. The search memory circuits comprise of memory elements to store symbols of finite state automata representing the regular expressions. The search memory circuits further comprise memory elements to store mask vectors MV that may be applied to the stored symbols. The mask vectors are coupled to the symbol memory elements and the content being searched through symbol evaluation circuits that detect whether the received content comprises of the symbols being searched. The search memory circuits further comprise of memory elements to store elements of state dependent vectors SDV which are used to decide the state traversal by the search memory for the finite state automata. The search memory circuits further comprise of match detect circuits that operate by coupling with the memory elements for symbols MVs SDVs and the symbol evaluation circuits for multiple states of the FSAs to decide on the traversal of the states in the FSA based on the content being searched and the programmed symbols SDVs and MVs. The search memory circuits may further comprise tag and match detect circuits that operate to provide tagged FSA and regular expression search wherein the tagged FSA is used to detect sub string or partial regular expression match beside a full regular expression match.

The memory elements of the PRISM memory comprise of static memory cells. The memory elements are each independently addressable in a random order. The PRISM memory further comprises of circuits to couple the content search memory with other logic to provide coupling with processors that can interface to the PRISM memory integrated circuits. The PRISM memory further comprises of a controller for interfacing with the processors to receive the content to be searched. The PRISM memory may further comprise of address decode logic circuits which decode the received address to select the specific static memory cells location to be read or written. The memory elements of the search memory may each be uniquely addressed to read or write appropriate values in the memory elements. The address decoding logic and the controller generate control signals necessary to address the appropriate memory locations of the static memory cells based search memory. The control signals are coupled to the PRISM arrays as a series of word lines and bit lines that can randomly be used to access desired memory locations.

The memory elements of PRISM support detection of character pattern strings. The PRISM memory comprises of symbol detection circuits and may optionally comprise of mask vectors per symbol bits that may be used to evaluate received character string using simple XOR based compare or other logic function and create a match indication. The PRISM match signal processing circuits may logically combine multiple match signals from each symbol detection block to generate a composite match signal which would be activated only if all the symbols have a match. The composite match signal creates a match functionality like a traditional CAM chip and thus enable PRISM chip to be partially or fully configured to behave like a CAM provide a pattern matching functionality beside regular expression search.

The PRISM memory further comprises of signature search engines for searching content against a large set of signatures like those for anti virus. The PRISM signature search engines are coupled to the PRISM regular expression search engines to support applications that have fixed character signatures as well as regular expression signatures. The said PRISM search engines further comprise of fixed length signature recognition hardware. The fixed length signature search engines may comprise of a content buffer for content to be examined. It may further comprise of k hash generators to generate k hash indices to be used as memory addresses to retrieve the compressed signatures from a hash signature memory. The PRISM search engine may further comprise of a hash signature memory to store and retrieve a compressed signature database generated by applying k different hash functions to the said signatures. The PRISM signature search engines further comprise of exact match queues to store exact match descriptors used by an exact match controller to perform an exact match on a data structure associated with the hash index of the coarse match. The said exact match descriptors may comprise of the packet identification or flow ID or content ID or the like. The exact match descriptor may further comprise of the byte offset where the coarse match is detected. The said exact match descriptor may further comprise of the number of bytes used to generate the coarse match.

A PRISM signature compiler used for processing the signatures generates a compressed signature database and optionally a full signature database used for coarse match and exact match respectively. The full signature database comprises of a data structures for all signatures and when multiple signatures whose hash values map to the same hash index the signature database for that hash index uses all signatures that map to that location to create the said data structure. The said data structure may be realized as a FSA like a DFA or AC FSA or the like. The PRISM memory further comprises of an exact match controller to perform exact match of content with signatures when a coarse match is flagged. The PRISM signature search engines may further comprise of policies to take actions when an exact match is detected. The policies may be programmed by a PRISM controller or a master controller coupled to PRISM.

While the foregoing has been with reference to particular embodiments of the invention it will be appreciated by those with ordinary skill in the art that changes in these embodiments may be made without departing from the principles and spirit of the invention.

