---

title: Method and system for assembling information processing applications based on declarative semantic specifications
abstract: A method for assembling an information processing application, includes: inputting a plurality of component descriptions, wherein each of the component descriptions includes a graph pattern that semantically describes an applicability condition of a component and a graph pattern that semantically describes an inclusion effect of the component; inputting a processing request, wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome; assembling a processing graph, wherein the processing graph includes at least one component that satisfies the desired processing outcome; and outputting the processing graph.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08863102&OS=08863102&RS=08863102
owner: International Business Machines Corporation
number: 08863102
owner_city: Armonk
owner_country: US
publication_date: 20070402
---
This invention was made with Government support under Contract No. H98230 05 3 0001 awarded by the U.S. Department of Defense. The Government has certain rights in this invention.

This application is related to commonly assigned U.S. application entitled METHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING STREAM PROCESSING GRAPHS IN STREAM PROCESSING SYSTEMS which issued as U.S. Pat. No. 7 834 875 and is incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR SEMANTIC MODELING OF STREAM PROCESSING COMPONENTS TO ENABLE AUTOMATIC APPLICATION COMPOSITION which is currently pending with application Ser. No. 11 695 457 and is incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR DECLARATIVE SEMANTIC EXPRESSION OF USER INTENT TO ENABLE GOAL DRIVEN STREAM PROCESSING which issued as U.S. Pat. No. 7 899 861 and is incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING PROCESSING GRAPHS IN INFORMATION PROCESSING SYSTEMS which is currently pending with application Ser. No. 11 695 349 and is incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR MODELING COMPONENTS OF AN INFORMATION PROCESSING APPLICATION USING SEMANTIC GRAPH TRANSFORMATIONS which issued as U.S. Pat. No. 7 882 485 and is incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR DECLARATIVE SEMANTIC EXPRESSION OF USER INTENT TO ENABLE GOAL DRIVEN INFORMATION PROCESSING which is currently pending with application Ser. No. 11 695 279 and is incorporated by reference herein in its entirety and commonly assigned U.S. application entitled METHOD AND SYSTEM FOR COMPOSING STREAM PROCESSING APPLICATIONS ACCORDING TO A SEMANTIC DESCRIPTION OF A PROCESSING GOAL which is currently pending with application Ser. No. 11 695 410 and is incorporated by reference herein in its entirety.

The present invention relates to assembling information processing applications and more particularly to a method and system for assembling information processing applications based on declarative semantic specifications.

Generally software applications achieve a desired processing outcome at the request of a person or agent by using a collection of reusable software components assembled to achieve the outcome. When a request must be accommodated and no suitable application exists the requestor can cobble together a solution by collecting partial solutions from existing applications doing some additional manual work to complete the task. However new or adapted applications are generally needed thus requiring the initiation of a human process to accumulate application requirements and to develop adapt assemble applications that can achieve the desired outcome. A challenge arises in understanding the processing request understanding the components that might achieve the desired outcome and knowing how to build and or assemble the components to achieve the processing outcome and fulfill the request.

Expressing desired processing outcomes directly as computer programs coded using general purpose languages such as C or Java generally requires long development cycles and imposes high maintenance costs for any new type or variant of information processing outcome. Casting such requests as traditional queries can reduce some of the costs and delays by providing a simpler means of expressing and applying complex data transformations etc. However these query oriented approaches do not offer sufficient coverage for a wide variety of requests involving non query goals or requests for outcomes involving operations on unstructured data e.g. speech to text and image recognition operations nor are they resilient in the face of modifications to underlying conceptual schemas.

Both of the programming approaches and the query approaches suffer from an absence of an explicitly declared intent. In other words they do not explicitly denote the intent of the outcome requested with instead the intent being implicit and often only present in the minds of software developers. Thus any adjustments to either the requested outcome or the underlying conceptual schemas can become challenging and costly often requiring developers to reverse engineer existing applications in an attempt to harvest the original intent in order to adapt to the modifications.

Further in such approaches the requester of the processing outcome must generally know some potentially large amount of detail as to the means of fulfilling the request. For example programmers need to know specific steps to be taken and query writers need to know the structure of tables and the details of the operation composition to produce just one approach representing only one approach to fulfilling the request. If there are many possible means of satisfying a request the users must also know which way is best under what circumstances and the circumstances under which their solutions are to be used.

In an exemplary embodiment of the present invention a method for assembling an information processing application comprises inputting a plurality of component descriptions wherein each of the component descriptions includes a graph pattern that semantically describes an applicability condition of a component and a graph pattern that semantically describes an inclusion effect of the component inputting a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome assembling a processing graph wherein the processing graph includes at least one component that satisfies the desired processing outcome and outputting the processing graph.

The graph pattern that semantically describes the applicability condition of the component includes a description of a condition under which the component can be included in the processing graph.

The graph pattern that semantically describes the inclusion effect of the component includes a description of an effect of including the component in the processing graph.

The graph pattern that semantically describes the applicability condition of the component and the graph pattern that semantically describes the inclusion effect of the component are represented in an ontology description language.

The processing request further includes a constraint that is represented by a graph pattern that semantically describes constraints on the assembly of the processing graph.

The method further comprises deploying an information processing application embodying the at least one component of the processing graph and operating the information processing application.

Result data is produced when operating the information processing application. When the goal is a goal that requests the production of data the processing request further includes a disposition that describes a means of handling the result data.

The processing request further includes an outcome response that is represented by a graph that semantically describes another outcome to be achieved upon achievement of the desired processing outcome.

When the goal is a goal that requests the production of data the outcome response includes a semantic description of a means of handling result data that is produced when operating an information processing application embodying the at least one component of the processing graph after the information processing application has been deployed.

Assembling the processing graph comprises determining if an inclusion effect of a first component matches an applicability condition of a second component connecting the first component to the second component if the inclusion effect of the first component matches the applicability condition of the second component and determining a new inclusion effect of the second component when the first and second components are connected to each other.

In an exemplary embodiment of the present invention a system for assembling an information processing application comprises a memory device for storing a program a processor in communication with the memory device the processor operative with the program to receive and compile a plurality of component descriptions wherein each of the component descriptions includes a graph pattern that semantically describes an applicability condition of a component and a graph pattern that semantically describes an inclusion effect of the component receive and compile a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome assemble a processing graph wherein the processing graph includes at least one component that satisfies the desired processing outcome and output the processing graph.

The graph pattern that semantically describes the applicability condition of the component includes a description of a condition under which the component can be included in the processing graph.

The graph pattern that semantically describes the inclusion effect of the component includes a description of an effect of including the component in the processing graph.

The graph pattern that semantically describes the applicability condition of the component and the graph pattern that semantically describes the inclusion effect of the component are represented in an ontology description language.

The processing request further includes a constraint that is represented by a graph pattern that semantically describes constraints on the assembly of the processing graph.

The processor is further operative with the program to deploy an information processing application embodying the at least one component of the processing graph and operate the information processing application.

Result data is produced when operating the information processing application. When the goal is a goal that requests the production of data the processing request further includes a disposition that describes a means of handling the result data.

The processing request further includes an outcome response represented by a graph that semantically describes another outcome to be achieved upon achievement of the desired processing outcome.

When the goal is a goal that requests the production of data the outcome response includes a semantic description of a means of handling result data that is produced when operating an information processing application embodying the at least one component of the processing graph after the information processing application has been deployed.

The processor is further operative with the program when assembling the processing graph to determine if an inclusion effect of a first component matches an applicability condition of a second component connect the first component to the second component if the inclusion effect of the first component matches the applicability condition of the second component and determine a new inclusion effect of the second component when the first and second components are connected to each other.

In an exemplary embodiment of the present invention a computer program product comprising a computer useable medium having computer program logic recorded thereon for assembling an information processing application the computer program logic comprises program code for receiving and compiling a plurality of component descriptions wherein each of the component descriptions includes a graph pattern that semantically describes an applicability condition of a component and a graph pattern that semantically describes an inclusion effect of the component program code for receiving and compiling a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome and program code for assembling a processing graph wherein the processing graph includes at least one component that satisfies the desired processing outcome.

The foregoing features are of representative embodiments and are presented to assist in understanding the invention. It should be understood that they are not intended to be considered limitations on the invention as defined by the claims or limitations on equivalents to the claims. Therefore this summary of features should not be considered dispositive in determining equivalents. Additional features of the invention will become apparent in the following description from the drawings and from the claims.

In accordance with an exemplary embodiment of the present invention a method for conveying to an information system a user s desired outcome of one or more processing requests using semantic descriptions of processing goals plus semantically described constraints on potential solutions is provided. The corresponding semantic descriptions when specified according to the method and interpreted in the presence of semantically described processing components are used by a planner compiler to automatically assemble a processing graph to fulfill the request.

In this embodiment semantic graph patterns are used to convey the desired processing outcomes such as goals and constraints on the means by which the outcomes are pursued. In this manner the goals and constraints prepared by the user do not convey the mechanism by which the request is to be satisfied nor do they convey the operators to be applied to produce a result. This allows the compilation mechanism the freedom and flexibility to select from many alternative data sources and processing methods best suited to the computational resources at the time of the request. In this way information processing components not envisioned by the user can be applied thus potentially providing a higher quality outcome such as an outcome that consumes fewer computational resources or that satisfies any of a number of desired processing characteristics than can be selected by the user.

It is to be understood that since a predominant type of processing request for software systems is the production of information the following description of exemplary embodiments of the present invention will focus on how the method is used to describe information production requests and on how the method is used to automatically assemble processing graphs producing the requested information. However since other types of outcomes for example the modification of stored data or the initiation of a process are also in the realm of desired processing outcomes several other types of information processing goals are envisioned for use with the present invention. Further since the set of all processing outcomes is never completely known the method provides a means of extending the set of defined outcomes as well as a means of extending the set of constraints that may be imposed on the solutions.

In accordance with another exemplary embodiment of the present invention a method for semantically describing software components which can be dynamically added to a system embodying the present invention is provided. In accordance with yet another exemplary embodiment of the present invention a method and system for processing all of these descriptions by using a planner compiler is provided. Here the planner compiler interprets the desired outcomes the descriptions of candidate data sources and processing methods and produces one or more information processing applications believed to be responsive to the semantically expressed intent.

Since a processing graph will be referred to when describing exemplary embodiments of the present invention a brief description of a processing graph will now be provided.

A processing request is a semantically expressed request for processing to be performed by a suitable processing application. Typically such requests are for the production of information but other types of outcomes are possible.

Applications that process these requests are viewed as compositions of reusable software components. The compositions are referred to as processing graphs with the nodes being the various software components interconnected by arcs connecting inclusion effects which are typically output data productions to applicability conditions which are typically input data requirements.

For a given processing request a collection of data sources and components can be configured into a processing graph that can achieve the request s goal see .

A single processing graph might draw from one or more data sources and may perform any type of processing. For example a dataflow processing graph may filter transform aggregate correlate etc. data to provide the desired result data. Consider a stock prediction model isolating the top thread in that draws upon a single Trades data input and applies a Trade Analytics component and a Stock Price Predictor component to produce a single Stock Price Prediction. In order to improve the accuracy of the prediction the application may analyze data from Trades TV News and Radio sources as shown in with the Stock Price Predictor component basing a prediction on feeds from each of the analytic chains each conveying some information about the company in question.

A description of the exemplary embodiments of the present invention will now be provided in the following order Specification of Processing Requests Modeling Components using Semantic Graph Transformations and Method and System for Automatic Composition of Information Processing Applications.

Users convey to a system embodying the present invention their desired processing outcomes via processing requests. Processing requests are expressed via request specifications encoded in a request specification language. The request specification language is a machine interpretable encoding of the request. The specific encoding format is not important so long as the requisite elements are described and conveyed with enough formal machine interpretable descriptive content so that they can be interpreted by a request compiler planner. When feasible the compiler automatically assembles an application believed capable of achieving the processing outcome conveyed in the request specification.

A request specification is a declarative semantic expression of the desired effects of running a software application and the constraints under which the application is assembled. Request specifications carry the least amount of description needed to convey intent without unnecessary detail of how the request is to be carried out. A request specification can be automatically transformed by a request compiler into an application that is represented as a processing graph.

Request specifications are built from semantic graph expressions which are to be evaluated according to a semantic model of the concepts from a domain or domains of interest. Request specifications use terms that are formally defined in domain ontologies captured for example in a language such as Web Ontology Language Description Logic OWL DL W3C Rec. 10 Feb. 2004 a copy of which is incorporated by reference herein in its entirety. These domain ontologies contain formal models of the user s problem domain. In addition there are system ontologies that contain formal functional descriptions of processing components. With terms defined in a formal logic automated reasoners can be employed to match the request goals to component capabilities by using inference where necessary to apply domain independent components to the task of producing domain specific results.

Request specifications are authored by a user or some user agent and convey at the very least an expression of the user s goal for the request for example the goal of producing a notification that a particular company s stock value is anticipated to change by an amount greater than 5 of its current value or non information production goals such as the goal of having a piece of software installed or having a particular device configured. The request specification may also contain constraints on how that goal is to be achieved for example to avoid the use of video surveillance cameras as data sources or to favor the use of K means clustering algorithms.

The goals along with the accompanying constraints are described and conveyed in such a way that they can be processed by a request compiler. The compiler is a specialized artificial intelligence AI planner that treats these constrained goal specifications as end effects deriving them from the information needed to assemble suitable processing graphs.

Consider a simple request to watch for factors that might anticipate a significant change in a company s stock price. The request might be expressed informally as watch for changes greater than 5 percent in the stock price of company Breakfast Foods Group ticker symbol BFG . 

The request BFG Stock Activity Prediction has one goal that is to produce one result with two result elements the variables PredictedStockPrice and PredictedPercentageChange.

The request is written with a domain ontology in mind as shown e.g. by a domain ontology fragment in and states that for a Breakfast Foods Company with Ticker symbol BFG the elements PredictedStockPrice and PredictedPercentageChange are part of a Prediction associated with the company.

Produce goals optionally describe result disposition specifications which are descriptions of what to do with the resulting data. Some result data is surfaced for further processing some retained for later reference some for export to external stores database DB knowledgebase KB . . . and some for external reference for example via notification.

Results can be dealt with in a number of ways according to a set of disposition instructions e.g. to notify some interested person or their agent of the result to persist the result for some specified amount of time or to send the result to some IP port on some remote host etc. . Multiple dispositions can be expressed for each declared result and any disposition can be conditionally applied.

Here the result is persisted for one month six months if the PredictedPercentageChange 5 percentage points and the inquirer will be notified via a default mechanism of any PredictedPercentageChange 5 percentage points.

Note that the request shown above neither specifies nor constrains the components to be used in the processing graph. This approach favors discovery of components for example individual algorithms or processing subgraphs in an attempt to avoid over constrained specifications. User designation of components is optional the absence of such designations enables the request compiler to identify sources and methods that users may not have been aware of or that may produce higher quality results than those produced by user specified sources and methods.

However a request specification can include constraints regarding various plan elements. Constraints convey a requestor s instructions to Prefer Avoid etc. specified plan elements such as Data Sources Methods etc. These expressions provide indirect guidance to the compiler as soft constraints on the assembly of processing graphs. Say for example a custom developed algorithm for interpreting stock ticker data is strongly preferred or the use of any surveillance video is to be avoided 

Constraints can be either hard e.g. absolute or soft e.g. preferences . Hard constraints specifically require or prohibit some element or property of the solution. Soft constraints provide less strict guidance as to the composition of the processing graph. The use of preferences rather than absolute designations allows for the discovery of better alternative solutions in the context of user preferences and is thus favored for this method. Using only soft constraints the request specification can guide choices a compiler might make requiring user knowledge only of the items to be constrained but not of how the processing graph is assembled. But because hard constraints are sometimes required the method also provides a means of expressing such constraints.

The ontology in this example defines a property of Company called hasStockPricePrediction with a range StockPricePrediction. This value of this property is not likely to be available from a data source. More likely a combination of components capable of producing such a result would be needed to establish that relation and populate the remainder of the price prediction submodel for example the hasPredictedStockPrice and the hasPercentChange properties.

While subtle this is a key element for operator extensibility. For example rather than enriching a language with function calls accessing user provided code modules request specifications declaratively express the goal or goals of analysis via concepts and relations in the ontologies. So rather than calling a function to perform a task request specifications describe a result that can be achieved by assembling a processing graph that can produce the result. Thus a goal specified declarative description is used rather than a function invoked in a query expression. Further instead of requiring the requester to describe the operations needed to calculate a PredictedPercentChange some processing graph is automatically assembled to produce the result composed from the needed operators for example the data sources and software components that jointly surface the requested data.

Request specifications can be expressed and conveyed in a textual form as depicted in the BFG example above. Since request specifications are expected to be produced and consumed mostly by tools the predominant representation is expected to be an XML encoding conformant to an XML Schema W3C Rec. 28 Oct. 2004 a copy of which is incorporated by reference herein in its entirety.

The processing request can further include an outcome response represented by a graph that semantically describes additional goals that are to be achieved upon the fulfillment of the processing request goal. In other words the outcome response extends the processing request to include such other goals which are to be pursued upon the achievement of the processing request goal. When the outcome response is included in the processing request a generated processing graph must be assembled in a way such that upon operation the graph fulfills the goal of the processing request and also performs any additional specified outcome response goals.

For processing graph assembly to be automatable machine interpretable semantic descriptions of components functional characteristics are needed. Here the focus is on black box descriptions of each component providing semantic descriptions of the applicability conditions and inclusion effects of each component and the inclusion effects of each data source. Any machine interpretable description of a component s functional capabilities can be considered so long as there is a means by which those descriptions can be used by a planner compiler to create a suitable processing graph.

Applicability conditions and inclusion effects are modeled using semantic graph patterns. These graphs describe the criteria that determine the assembly of the processing graphs from among the complete set of graph elements i.e. the data sources and software components . For a graph element to be included in a processing graph its applicability condition must be met these conditions are met by the inclusion effects of other elements. The graphs associated with a given component s applicability conditions describe constraints that must be satisfied in order for the components to work correctly. Hence the descriptions are used to determine which other components via their inclusion effects can satisfy the inclusion criteria forming the basis for automated assembly of processing graphs.

For an embodiment in which a request for the production of data is provided the applicability conditions describe the availability of data for input to the component and the inclusion effects are the production by the component of output data. More simply the applicability conditions describe the component s inputs and the inclusion effects describe the component s outputs. The graphs associated with a given component s inputs describe constraints that any input data must satisfy in order for the component to work correctly. Hence the descriptions are used to determine which other components can provide input data to the component forming the basis for automated assembly of processing graphs.

These descriptions are represented using a semantic description technique for example OWL DL. Reasoning at an expressivity similar to DL reasoning is essential in the graph assembly process if any but the most trivial matching is to be pursued.

Semantic descriptions consist of processing component descriptions and descriptions of the conditions for applying the component and the effects of including the component in the graph. For data production graphs the semantic descriptions consist of processing component descriptions of the data produced required by the components. Processing component descriptions are based on core concepts defined in the system ontologies and the data descriptions are based on sets of domain and shared ontologies. The system ontologies define concepts such as DataSource and SoftwareComponent and the relations produces requires and contains. Expressed below in RDF N3 format is an excerpt of an exemplary OWL representation 

From these basic building blocks specific Data Source Software Component Input and Output prototypes can be defined each describing specific Data Source Input Output and Software Component exemplars such as DataSource HubbleEarthImageSource  and SoftwareComponent ImagePatternRecognizer  and their respective inputs and outputs.

The contains relation for input and outputs provides the mechanism for associating to a component semantic description of data to be carried on its inputs and or outputs.

In HubbleEarthImageSource  a DataSource produces an Output that contains HubbleEarthImage  an individual in the class InfraredImage 

The use of the double underscores   in  HubbleEarthImage  is a graphical shorthand indicating that Image  is also a Variable and an Exemplar represented above as being of type Variable and of type Exemplar both of which are special classes defined in the system ontology . The  HubbleEarthImage  is an Exemplar that can take the value of an individual in the class InfraredImage and that has the appropriate capturedBy and imageOf properties associated therewith. Note that Hubble and Earth do not really appear in the output instead they are semantic descriptions of the  HubbleEarthImage  data which appears in the output. Hence the contains relation is a special relation i.e. only those data items that the output explicitly describes using the contains relation are actually contained in the output . The remainder of the objects e.g. Earth while not contained in the output form a rich semantic description of the objects contained in the output  HubbleEarthImage  .

Software components are described as requiring some number of inputs and producing some number of outputs. An ImagePatternRecognizer  processing component ImagePatternRecognizer in is defined as requiring one input containing Image  an Image and as producing a single output containing Image  and a Keyword  Keyword  such that Image  is described By Keyword . Here the preceding Image  is a graphical notation that Image  is a Variable not an Exemplar . This means that the ImagePatterRecognizer  requires an input Image  and produces the same Image  as an output annotated by a new thing  Keyword .

The ImagePatternRecognizer  is defined to perform a few functions it conveys a known Image from input to output it creates a new object Exemplar e.g. a Keyword and it establishes a new relation describedBy.

In order to connect two components together it is first determined if the output of a first component can be connected to the input of a second component and once the components are connected to each other the resulting output produced by the second software component is then determined.

Given the descriptions of inputs and outputs of components a process for determining if an output of a first component can be matched to an input of a second component will now be described. The component matching problem is treated as a graph embedding problem in which the question Can the graph describing the input be embedded in a graph describing another component s output is answered. This approach is different from traditional approaches where matching is generally based on simple type checking alone. The graph embedding approach is more powerful building on the expressivity of semantic graphs.

To formally describe the component matching problem let G V C E represent the input graph where Vis the set of variable modules Cis the set of non variable of constant nodes and Eis the set of edges of the form u p v where node u is related to node v through property p. Similarly let G V C E represent the output graph. Note that Gand Gare directed graphs.

Gcan be embedded in Gif there exists a graph homomorphism f G G that is there is a mapping f V D V Csuch that if u p v Ethen f u f p f v E. In addition for any x C f x x. This means that constant nodes can only be mapped to equivalent constant nodes in the other graph while variable nodes can be mapped to other variable nodes or constant nodes.

In addition DL reasoning is applied to the output graphs to enable more flexible matching. In other words graph Gis expanded with the results of DL reasoning to create graph G . Graph Gis then checked to see if it can be embedded in G . The use of reasoning provides a matching process that is capable of connecting components even if the inputs and outputs are described using different terms. DL reasoning allows inferring new facts based on definitions in the ontology such as subclass and subproperty relationships transitive symmetric inverse and functional properties property restrictions equality and inequality statements etc.

For example in an output graph from HubbleEarthImageSource  is first expanded to include the results of DL reasoning. As a result a type link is added from  HubbleEarthImage  to Image this is obtained from the subclass relationship between InfraredImage and Image . In addition a depictedIn link is added from Earth to  HubbleEarthImage  depictedIn defined as an inverse property of imageOf . Next the matching process finds a homomorphism from an input graph of the ImagePatternRecognizer to the output graph of HubbleEarthImageSource . In this homomorphism Image  is mapped to  HubbleEarthImage  since they are both variables and Image is mapped to Image since they are both the same concept . Hence the matching process determines that there is a match.

To help determine the output of a software component as a result of drawing data from the outputs of other components a formal functional model of the software component is defined. In the model the software component can be viewed as performing a graph transformation on the semantic graphs on the inputs to produce semantic graphs on the outputs.

Note that there may be an overlap between and . Now assume that the m input graphs have been matched to m outputs generated by other components that is Lis matched to Xfor i 1 . . . m. The outputs Ycoming from this software component are determined as a result of connecting the inputs Yto the software component using a graph homomorphism 

In the model of the software components f satisfies the following properties for i 1 . . . m and j 1 . . . n 

3. f f and f f where represents the graph difference operation. This means that exactly that part of is deleted which is matched by elements of not in and exactly that part of is created that is matched by elements new in .

Using properties 2 and 3 the outputs Y of a software component can be determined as a result of connecting Xto the component. An example of this process is shown in where the output of the ImagePatternRecognizer  is generated based on the input that is connected to the ImagePatternRecognizer .

A semantic planner for automatically generating processing graphs from processing requests and semantic descriptions of components will now be discussed. The semantic planner enhances traditional AI planning techniques to plan on domains expressed in onotologies. Processing requests in this case user queries are expressed as semantic graph patterns. The planner recursively connects components to each other using the methods described above until it arrives at an outcome description that can be matched to the request specification or until no new output descriptions can be produced. In addition the planner satisfies various constraints such as privacy and security and produces optimal plans for a given resource consumption range.

As shown in a semantic planner consists of three main components a Stream Processing Planning Language SPPL Generator a DL Reasoner and a Plan Solver. The SPPL Generator takes OWL files describing software components and data sources and compiles them into a planning domain represented in the intermediate language SPPL as described for example in A. Riabov Z. Liu Planning for Stream Processing Systems in Proceeding of AAAI 2005 July 2005 a copy of which is incorporated by reference herein in its entirety.

The SPPL Generator makes use of the DL Reasoner to make inferences about the software component descriptions and inserts these inferences as facts into the domain description. In addition to semantic descriptions of inputs and outputs the planning domain also includes descriptions of other compositional operational constraints such as security and privacy constraints. In addition to creating the domain file the SPPL Generator translates each stream query into a goal description in SPPL. The Plan Solver then parses the generated domain and problem SPPL files and produces optimal plans using a backward chaining branch and bound algorithm as described for example A. Riabov Z. Liu Planning for Stream Processing Systems in Proceeding of AAAI 2005 July 2005. The Plan Solver solves the graph embedding problem by deducing appropriate mappings of variables in the input graph to nodes in the output graph. In this planning process multi objective optimization is carried out including for example computational cost and result quality. A Minerva Reasoner which is a highly sealable reasoner operating on a description logic program DLP which is an expressive subset of DL may be used as the DL Reasoner.

When the planner is given a processing request the planner searches for multiple alternative plans visiting software component descriptions and traversing potentially large associated input and output description graphs many times. Incurring the overhead of DL reasoning on each visit could have a huge negative impact on performance. This is overcome by adopting a two phase approach performing a priori reasoning over graphs of asserted and inferred facts caching expanded graphs for later use during query compilation. Because the products of the reasoning have been cached no DL reasoning need be used while searching for viable processing graphs.

An example of a processing graph assembled by the semantic planner in response to a request for hurricane associated images is shown in . It is to be understood that although only one processing graph is shown in the semantic planner can assemble several alternative processing graphs. The processing graph shown in draws on two data sources feeding three operators components to produce a sink including hurricane associated images e.g. images that contain possible storm pattern and images that were taken around that same time a hurricane was reported . depicts the same processing graph as shown in however here semantic graphs describing each data source s outputs  out each component s inputs  in and outputs  out and the sink s inputs  in are provided.

As can be gleaned from a review of it can be difficult to select from among a large set of data sources and software components to compose such a graph manually. For example even with the relatively small number of operators depicted in the processing graph the work needed to identify appropriate elements and to match outputs to inputs can be daunting especially for matches requiring reasoning. Since most processing graphs involve many more operators manual composition of even one graph is tedious and manual composition of multiple alternative processing graphs is impracticable. Hence automated compilation approaches such as planning are essential for compiling processing requests into processing graphs.

In accordance with an exemplary embodiment of the present invention a means of describing processing outcomes and processing component capabilities in such a way that information processing applications that satisfy these requests can be generated is provided. In this way software applications can be assembled more dynamically in seconds or minutes as opposed to days or months taking into account many more considerations security privacy resource availability and consumption etc. than most users could fathom let alone have the time or patience to accommodate. This automated approach makes it more practical to take into account a wide variety of constraints and to assemble multiple alternative applications for a given outcome and provides flexibility in choosing the best one for the given circumstances.

By using the present invention a user describing an intended outcome need neither know nor be required to express the details of how a processing outcome is to be fulfilled. In fact requiring users to convey the details of a solution can prevent an automated planner from discovering better ways of accommodating the request better data sources to draw from better algorithms to apply and the assembly of more effective and or efficient applications. Here users need only describe their requests and convey their constraints if any on how the request is to be fulfilled and an automated mechanism whereby various ways to fulfill their request can be automatically generated compared pruned and applied.

By providing a means of conveying the goals for and constraints on a processing outcome and doing so using semantic descriptions built according to an explicitly represented semantic model the user is freed up from the burden of knowing and applying some set of operators to produce some outcome. This allows the work of two different groups of people those conveying their request and those developing and describing application components to proceed in parallel. The present invention makes this possible by allowing the first group to convey their requests without having any knowledge of which data sources of processing methods are available for use. The second group can introduce new data sources or processing methods into the system these can be used to produce potentially better responses to user requests without awareness of the availability of the new sources and or methods.

It should be understood that the present invention may be implemented in various forms of hardware software firmware special purpose processors or a combination thereof. In one embodiment the present invention may be implemented in software as an application program tangibly embodied on a program storage device e.g. magnetic floppy disk RAM CD ROM DVD ROM and flash memory . The application program may be uploaded to and executed by a machine comprising any suitable architecture.

It is to be further understood that because some of the constituent system components and method steps depicted in the accompanying figures may be implemented in software the actual connections between the system components or the process steps may differ depending on the manner in which the present invention is programmed. Given the teachings of the present invention provided herein one of ordinary skill in the art will be able to contemplate these and similar implementations or configurations of the present invention.

It should also be understood that the above description is only representative of illustrative embodiments. For the convenience of the reader the above description has focused on a representative sample of possible embodiments a sample that is illustrative of the principles of the invention. The description has not attempted to exhaustively enumerate all possible variations. That alternative embodiments may not have been presented for a specific portion of the invention or that further undescribed alternatives may be available for a portion is not to be considered a disclaimer of those alternate embodiments. Other applications and embodiments can be implemented without departing from the spirit and scope of the present invention.

It is therefore intended that the invention not be limited to the specifically described embodiments because numerous permutations and combinations of the above and implementations involving non inventive substitutions for the above can be created but the invention is to be defined in accordance with the claims that follow. It can be appreciated that many of those undescribed embodiments are within the literal scope of the following claims and that others are equivalent.

