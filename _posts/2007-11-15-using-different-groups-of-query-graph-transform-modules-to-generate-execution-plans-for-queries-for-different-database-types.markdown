---

title: Using different groups of query graph transform modules to generate execution plans for queries for different database types
abstract: Provided are a method, system, and article of manufacture for using different groups of query graph transform modules to generate execution plans for queries for different database types. A plurality of first type query translator modules include information indicating a first data store type to which the first query translator modules apply and a plurality of second query translator modules include information indicating a second data store type to which the first query translator modules apply. A query is received to query a target data store. A determination is made as to whether the target data store is of the first data store type or the second data store type. The first query translator modules are used to translate the received query to a query execution plan in response to determining that the target data store is of the first data store type. The second query translator modules are used to translate the received query to a query execution plan in response to determining that the target data store is of the second data store type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08156134&OS=08156134&RS=08156134
owner: International Business Machines Corporation
number: 08156134
owner_city: Armonk
owner_country: US
publication_date: 20071115
---
The present invention relates to a method system and article of manufacture for using different groups of query graph transform modules to generate execution plans for queries for different database types.

Database queries may be provided for different types of database such as the querying of objects in an object oriented database or the querying of rows in a relational database table. A query of a relational database may be expressed in the Structured Query Language SQL and a query of an object in an object oriented database may be expressed in an object oriented query language such as the Enterprise JavaBeans Query Language EJB QL . Enterprise JavaBeans Query Language is a trademark of Sun Microsystems Inc. in the United States and other countries .

Further a common abstract query language may be used to query different data systems. The abstract query language is not dependent on the specific data system and a user can write a query in this abstract query language without knowing the specific backend data system that will be used to execute the query relational object etc and the specific query language of the backend system. In addition queries and programs written in the abstract query language may be ported from one data system to another. EJB QL is an example of such an abstract query language. The query written in EJB QL has to be changed into a query that can be executed by the specific data system. In the case of a relational database the EJB QL query must be translated to SQL. In the case of an object oriented database the EJB QL query may be executed by iterating through collections of data objects and performing the query operations.

To execute a query a query optimizer may parse the query and generate an optimized execution or access plan specifying the operations to perform to implement the received query with respect to the objects in memory for an object oriented database or relational database tables. Different query optimizers are used depending on the type of the target database subject to the query.

There is a need in the art for improved techniques for generating execution plans for queries in a heterogeneous data store environment.

Provided are a method system and article of manufacture for using different groups of query graph transform modules to generate execution plans for queries for different database types. A plurality of first type query translator modules include information indicating a first data store type to which the first query translator modules apply and a plurality of second query translator modules include information indicating a second data store type to which the first query translator modules apply. A query is received to query a target data store. A determination is made as to whether the target data store is of the first data store type or the second data store type. The first query translator modules are used to translate the received query to a query execution plan in response to determining that the target data store is of the first data store type. The second query translator modules are used to translate the received query to a query execution plan in response to determining that the target data store is of the second data store type.

Data store may comprise a data store that is not accessed using a query language but is accessed using an application . Thus the data store may comprise an application specific database that is accessed using application specific Application Programming Interfaces APIs generated from an application . The data store may comprise an in memory object or data store in a system memory not on a disk. The data store may comprise a database that may be accessed using a query language that is different from the query language of a user application such as an object oriented or relational database. In this way the data store is accessed using a different process than the data store which is accessed using a query language. The data stores and may comprise back end data stores for the application .

In the event that the data store comprises a relational database then the data store may include database tables. In the event the data store comprises an object oriented database then the data store may include objects having attributes and properties and an index associating key words and identifying objects whose properties satisfy the key words.

The query graph transformer may invoke a group of modules to generate an execution plan for the received query. The received query may comprise a query in a query language such as an object query language e.g. EJB QL and include an attribute to search a predicate which may comprise a comparison operator e.g. equals not equals greater than less than etc. and a value for the attribute. The queried attribute may comprise a column or field in a relational database table or a property or relationship of objects for an object oriented database. A parser initially translates the query to parse tree nodes comprising an algebraic representation of the query. A parse tree node module further processes the parse tree nodes to replace and group the nodes into query select from where term and operation where the term represent objects and object relationships the operation represents functions arithmetic comparison binary unary operations. The output of the parse tree node module may comprise a query graph which represents the query as nodes in a graph where the nodes comprise the query operations.

The query graph may comprise a single graph structure that can represent both object queries and relational queries. The query graph structure may further utilize a notion of operation that has been abstracted in such a way that a single class OPER is used to represent query predicates logical operations AND OR NOT functions average substring length etc. arithmetic and string operations. The terms in the query such as names of properties parameters and literals may be represented by a single class TERM .

In a further embodiment the query graph may include three types of nodes Queryop OPER and TERM. There is one Queryop node to represent the entire query and there is an additional Queryop for each subquery. The Queryop contains references to the major elements of the query such as the list of select expressions from expressions filter expressions grouping and ordering expressions. The OPER nodes represent arithmetic string operations predicates and logical. The TERM nodes represent defined properties parameters and literal values.

The memory includes two groups of query graph transformation modules including a group of modules and for a first type of data store subject to the query such as an application specific database and a second group of modules for a second type of data store subject to the query such as an object oriented or relational database . The module implementations for the different types of data stores include database specific operations to implement the query optimization for the type of database such as object oriented and relational or different structured relational databases and object oriented databases. Although two groups of query graph transformation modules are shown there may be additional groups of modules for different data store types or data stores of a same type having a different object or table structure. The query graph transformation modules may be executed and implemented within the query graph transformer of the query engine .

Resolve modules include code for their specific data store type to validate the names of the attributes to the query. The resolve operation checks the query graph against a dictionary or catalog of defined names to insure that the query is valid and that undefined names are not used in the query. For instance the first type resolve module may access a dictionary for the data store . The second type of resolve module may access a dictionary or other data structure depending on whether the data store comprises an object oriented or relational database. If the data store comprises an object oriented database then the resolve module may access an object class schema to determine whether the attribute comprising an object property and or relationship corresponds to a property and or relationship defined in the class schema of the object oriented database. For a relational database the resolve module may access a dictionary of the named columns and tables.

For instance there may be a ResolveRelational and ResolveObjectStore. The ResolveRelational module translates path expressions into equivalent join operations and a ResolveObjectStore may not translate into joins. The ResolveRelational and ResolveObjectStore may use common code.

Check type modules traverse the query graph to determine whether the operations in the query graph have valid input arguments. This may be performed by checking that numerical operations are only performed on numerical type data and that string operations are only performed with respect to string data. This may involve checking whether the attribute subject to the query is of a data type consistent with the data type of the query and operator.

The plan generation modules may process the query graph to generate an execution plan. As part of generating an execution plan the plan generation module or other component may rewrite the query for optimization. The plan generation module may generate an access plan to access data in the data store . The plan generation module may rewrite terms to an object oriented or relational database query language. Further the plan generation module may generate statements for a specific vendor database because different vendor databases may utilize vendor specific versions of SQL. For relational databases different variations of the generation module can be subclasses of a common Relational Generate module with appropriate overrides that deal with the database differences.

A module mapping provides a mapping for different data store types to a group of modules and . provides an example of the module mapping entry as including entries comprising a data store type a data store structure of the data and a translator module e.g. or to use for the particular data store type and structure .

The query graph transformation transform may take parse tree nodes to form the graph and then perform three transformations on the nodes comprised of and for translation type processes or alternatively and for queries that must be executed over data stores. Each transformation may consist of traversing the query graph and processing each node as outlined in .

The query engine may invoke the parser to generate at block a parse tree of nodes . A parse tree node module is invoked at block to group the nodes according to the query parts such as query select from where term and operation to produce a query graph . The query engine may then direct the query graph to the determined first or second query translator modules. The query graph is forwarded at block to the determined first or second type resolve module to validate that the query attributes correspond to attributes in the target data store or i.e. are the queried attributes or properties valid named components of the queried data store or . If at block the query attributes are not validated then an error exception may be thrown at block . Otherwise if at block the query attributes are validated then the query graph is forwarded at block to the determined first or second type check module to verify that the query operators are valid with respect to the query attributes. If at block the query operators are not valid then an error exception may be thrown at block .

If at block the query operators are validated then with respect to if at block the determined data store type is a first type of data store such as an application specific data store then the query graph is forwarded at block to to the first type path generator module to generate an application specific access plan to execute the query against the data store . The first type finalize module may execute at block the execution plan and return the results from the application specific data store .

If at block the data store comprises an object oriented or relational database then the second type generator module may generate query language statements such as an SQL query specific to the type of data store . For instance if the data store comprises an object oriented database then the second type plan generator module or some other component may determine whether the object properties and relationships subject to the received query map to relational database tables. If so then the plan generator module or some other component such as a rewrite module may rewrite the query graph to a relational database query e.g. SQL query where references between objects may be translated into join operations. The rewritten query graph may be forwarded to the second type path generator module to generate an execution plan against tables in the relational database . In object oriented queries the objects may map to columns or tables in the relational database and the object relationships subject to the query may map to primary and foreign keys in the relational database tables. When the objects and relationships in an object oriented query are found in columns or fields in relational database tables the objects may map to one or more columns of one or more tables and the queried relationships may map to primary and foreign key or keys in the relational tables. The object oriented query path may be decomposed when the objects or relationships are composed path expressions. A composed path expression is a path expression that has at least one path expression which is a relationship reached by navigating from another relationship. To decompose a composed path expression into a simple path expression to rewrite an object oriented query to a relational database SQL query all the elements from the composed path expression may be processed. If the element is in a relationship between two objects then the relationship may be written into an inner join of the base object from which the relationship is navigating from and the target object to which the relationship leads.

Yet further if the queried object properties specified in the query graph do not map to relational database tables and if there are indexes on the objects provided index keys for the query attributes or properties then the first type path generator generates from the query graph an execution plan using the indexes on the query object properties to determine qualifying objects or objects having property values that satisfy the property values specified in the received query. The objects in the database subject to the query may be stored in the memory where the indexes may provide access to the objects in memory based on object property values. Otherwise if indexes are not provided for the queried properties then the first type path generator module may generate an execution plan that scans the objects in memory to determine objects having properties attributes satisfying the query values provided specified for query properties. The second type finalize module executes at block the execution plan and returns results.

Described embodiments provide different groups of modules used to generate an execution plan for a query that may be directed to different data stores and data store types such that the group of modules is automatically selected to generate an execution plan based on the target data store type to which the query is directed. Described embodiments provide for execution plan generation in environments where queries may be directed to heterogeneous data stores. The operations to validate and generate the execution plan may be expressed in modules specific to the type of data store to which the query is directed where the modules implement the general query translation operations for different data store specific implementations.

The described operations may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. The described operations may be implemented as code maintained in a computer readable medium where a processor may read and execute the code from the computer readable medium. A computer readable medium may comprise media such as magnetic storage medium e.g. hard disk drives floppy disks tape etc. optical storage CD ROMs DVDs optical disks etc. volatile and non volatile memory devices e.g. EEPROMs ROMs PROMs RAMs DRAMs SRAMs Flash Memory firmware programmable logic etc. etc. The code implementing the described operations may further be implemented in hardware logic implemented in a hardware device e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. . Still further the code implementing the described operations may be implemented in transmission signals where transmission signals may propagate through space or through a transmission media such as an optical fiber copper wire etc. The transmission signals in which the code or logic is encoded may further comprise a wireless signal satellite transmission radio waves infrared signals Bluetooth etc. The transmission signals in which the code or logic is encoded is capable of being transmitted by a transmitting station and received by a receiving station where the code or logic encoded in the transmission signal may be decoded and stored in hardware or a computer readable medium at the receiving and transmitting stations or devices. An article of manufacture comprises computer readable medium hardware logic and or transmission signals in which code may be implemented. A device in which the code implementing the described embodiments of operations is encoded may comprise a computer readable medium or hardware logic. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention and that the article of manufacture may comprise suitable information bearing medium known in the art.

The terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments of the present invention s unless expressly specified otherwise.

The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise.

The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries.

A description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments of the present invention.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously.

When a single device or article is described herein it will be readily apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be readily apparent that a single device article may be used in place of the more than one device or article or a different number of devices articles may be used instead of the shown number of devices or programs. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments of the present invention need not include the device itself.

The illustrated operations of show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover steps may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The foregoing description of various embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

