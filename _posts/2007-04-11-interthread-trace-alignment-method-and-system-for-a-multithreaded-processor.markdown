---

title: Inter-thread trace alignment method and system for a multi-threaded processor
abstract: Techniques for the design and use of a digital signal processor, including (but not limited to) for processing transmissions in a communications (e.g., CDMA) system. Inter-thread trace alignment with execution trace processing includes recording timing data relating to a common predetermined event. Such an event may be the number of cycles since a last thread initiated execution tracing or the number of cycles since all threads terminated execution tracing. The number of cycles at which a thread initiates execution tracing is referenced to the common predetermined event for maintaining the timing of execution tracing. The data relating to the common predetermined event is then updated to associate with the time at which the thread initiated execution tracing. The result is to permit aligning the timing data associated with all threads. Interrelated records permit reconstructing interdependent execution tracing information for threads operating in the multi-threaded processor, as well as synchronizing timing data for all operating threads.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484516&OS=08484516&RS=08484516
owner: QUALCOMM Incorporated
number: 08484516
owner_city: San Diego
owner_country: US
publication_date: 20070411
---
This application is related to the following co pending United States patent application numbers application Ser. No. 11 560 217 filed Nov. 15 2006 entitled NON INTRUSIVE THREAD SELECTIVE DEBUGGING METHOD AND SYSTEM FOR A MULTI THREAD DIGITAL SIGNAL PROCESSOR application Ser. No. 11 560 323 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR A DIGITAL SIGNAL PROCESSOR DEBUGGING DURING POWER TRANSITIONS application Ser. No. 11 560 332 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR TRUSTED UNTRUSTED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS application Ser. No. 11 560 339 filed Nov. 15 2006 entitled EMBEDDED TRACE MACROCELL FOR ENHANCED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS and application Ser. No. 11 560 344 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR INSTRUCTION STUFFING OPERATIONS DURING NON INTRUSIVE DIGITAL SIGNAL PROCESSOR DEBUGGING.

The disclosed subject matter relates to data processing systems and processes such as may find use in data communications and similar applications. More particularly this disclosure relates to a novel and improved method and system for digital signal processing debugging operations including providing an inter thread trace alignment method and system for an multi threaded processor.

Increasingly telecommunications and other types of electronic equipment and supporting video complex audio videoconferencing and other rich software applications involve signal processing. Signal processing requires fast mathematical calculations and data generation in complex but repetitive algorithms. Many applications require computations in real time i.e. the signal is a continuous function of time which must be sampled and converted to digital signals for numerical processing. The processor must execute algorithms performing discrete computations on the samples as they arrive.

The architecture of a digital signal processor DSP is optimized to handle such algorithms. The characteristics of a good signal processing engine include fast flexible arithmetic computation units unconstrained data flow to and from the computation units extended precision and dynamic range in the computation units dual address generators efficient program sequencing and ease of programming.

One promising application of DSP technology includes communications systems such as a code division multiple access CDMA system that supports voice and data communications as well as text messaging and other applications between users over a satellite or terrestrial link. The use of CDMA techniques in a multiple access communication system is disclosed in U.S. Pat. No. 4 901 307 entitled SPREAD SPECTRUM MULTIPLE ACCESS COMMUNICATION SYSTEM USING SATELLITE OR TERRESTRIAL REPEATERS and U.S. Pat. No. 5 103 459 entitled SYSTEM AND METHOD FOR GENERATING WAVEFORMS IN A CDMA CELLULAR TELEHANDSET SYSTEM both assigned to the assignee of the claimed subject matter.

A CDMA system is typically designed to conform to one or more standards. One such first generation standard is the TIA EIA IS 95 Terminal Base Station Compatibility Standard for Dual Mode Wideband Spread Spectrum Cellular System hereinafter referred to as the IS 95 standard. The IS 95 CDMA systems are able to transmit voice data and packet data. A newer generation standard that may more efficiently transmit packet data is offered by a consortium named the 3Generation Partnership Project 3GPP and embodied in a set of documents including Document Nos. 3G TS 25.211 3G TS 25.212 3G TS 25.213 and 3G TS 25.214 which are readily available to the public. The 3GPP standard is hereinafter referred to as the W CDMA Standard.

Complex DSP operational software employing the W DCMA Standard for example requires robust development tools. Such development tools may include those for code generation integration testing debugging and evaluating application performance. In developing and operating software or complex DSP applications such as advanced telecommunications applications there is the need for sophisticated yet non intrusive debugging software. That is debugging software applications must be not only sufficiently robust to monitor test and support the correction of software defects and operational problems. At the same time debugging software may need to operate so as not to interfere with the core processor software operations during concurrent debugging operations. Otherwise any problems in the core processing software may not be detected or detected properly during software debugging operations.

During debugging operations there is a need for associating with the non intrusive software debugging operations tracing functions for tracing the operations of the processing of the operating threads within the DSP. Such a system may provide information on the DSP s state parameters for capturing such information both before and after a specific event occurs. At the same time the desired tracing functions cannot add any significant burden to processor performance even while the DSP operates at full speed. In combination with a non intrusive debugging operation such a tracing process may capture specific types of information. The tracing functions therefore provide for monitoring and recording in conjunction with non intrusive debugging operations in a multi threaded processor.

One particularly useful set of information a tracing function may provide includes inter thread execution behavior. That is a need exists for a set of tracing functions capable of inter relating tracing data among different threads of a multi threaded DSP. No known system provides such information. In debugging software operations the user may desire to choose an arbitrary point in time at which to know which instructions a multi threaded processor may be executing at a particular point in time. This information may be particularly valuable in the instance that different threads activate different per thread debugging operations at different times.

In an interleaved multi threaded DSP the execution of multiple instruction sequences may occur concurrently. As such the processor may be viewed as several single threaded processors operating independently. Once such processor may include an execution tracing unit that records the runtime execution sequence of each of the operating threads. These traces facilitate program debugging operation by breaking down the program flow into a sequence of packets. In such a system thread number fields may be added to certain packets to identify which packet belongs to which thread. With such an approach each packet sequence for a particular thread may recreate the full execution sequence including all program flow changes and all instruction timing.

While identifying which packets belong to which thread is advantageous no known tracing function provides the ability to identify inter thread timing relationships during execution tracing. For instance time differences between trace activation may be very large from one thread to another. When thread tracing begins on different threads sat different times it may not be possible to align one thread s timing with other threads that are also being traced.

Accordingly there is a need for a set of tracing functions capable of operating within a non intrusive debugging process that establishes and maintains timing relationship between different DSP threads.

Yet a further need exists for a method and system that permits the alignment of different threads of a multi threaded processor for use in association with an embedded trace macrocell process of the multi threaded processor.

Still further a need exists for an inter thread trace alignment method and system for an interleaved multi threaded processor capable of operating in association with a broad array of non intrusive in silicon debugging processes occurring during core processor software operations.

Techniques for providing inter thread trace alignment in an multi threaded processor are disclosed which techniques cooperate with an embedded trace macrocell for identifying inter thread timing relationships and therefore to establish and maintain various timing relationships between different threads. The method and system here disclosed improve both the operation of a digital signal processor and the efficient use of digital signal processor instructions for increasingly powerful software applications including applications operating in personal computers personal digital assistants wireless handsets and similar electronic devices as well as increasing the associated digital processor speed and service quality.

According to one aspect of the disclosed subject matter a method and system are provided for inter thread trace alignment with execution trace processing which includes recording timing data relating to a common predetermined event. Such a common predetermined event may be the number of cycles since a last thread initiated execution tracing or the number of cycles since all threads terminated execution tracing. The number of cycles at which a thread initiates execution tracing is referenced to the common predetermined event for maintaining the timing of execution tracing. The data relating to the common predetermined event is then updated to associate with the time at which the thread initiated execution tracing. The result is to permit aligning the timing data associated with all threads. Interrelated records permit reconstructing interdependent execution tracing information for threads operating in the multi threaded processor as well as synchronizing timing data for all operating threads.

These and other advantages of the disclosed subject matter as well as additional novel features will be apparent from the description provided herein. The intent of this summary is not to be a comprehensive description of the claimed subject matter but rather to provide a short overview of some of the subject matter s functionality. Other systems methods features and advantages here provided will become apparent to one with skill in the art upon examination of the following FIGUREs and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the accompanying claims.

The disclosed subject matter for a inter thread trace alignment method and system for use in association with execution trace processes of a multi threaded digital signal processor has application for multi threaded processing of any type for which the benefits here presented may be advantageous. One such application appears in telecommunications and in particular in wireless handsets that employ one or more digital signal processing circuits. For explaining how such a wireless handset may be used provides a simplified block diagram of a communications system that may implement the presented embodiments of the disclosed interrupt processing method and system. At a transmitter unit data is sent typically in blocks from a data source to a transmit TX data processor that formats codes and processes the data to generate one or more analog signals. The analog signals are then provided to a transmitter TMTR that modulates filters amplifies and up converts the baseband signals to generate a modulated signal. The modulated signal is then transmitted via an antenna to one or more receiver units.

At a receiver unit the transmitted signal is received by an antenna and provided to a receiver RCVR . Within receiver the received signal is amplified filtered down converted demodulated and digitized to generate in phase I and Q samples. The samples are then decoded and processed by a receive RX data processor to recover the transmitted data. The decoding and processing at receiver unit are performed in a manner complementary to the coding and processing performed at transmitter unit . The recovered data is then provided to a data sink .

The signal processing described above supports transmissions of voice video packet data messaging and other types of communication in one direction. A bi directional communications system supports two way data transmission. However the signal processing for the other direction is not shown in for simplicity. Communications system may be a code division multiple access CDMA system a time division multiple access TDMA communications system e.g. a GSM system a frequency division multiple access FDMA communications system or other multiple access communications system that supports voice and data communication between users over a terrestrial link. In a specific embodiment communications system is a CDMA system that conforms to the W CDMA Standard.

Output from execution data paths goes to register file write circuit also configured to accommodate individual threads T T for returning the results from the operations of DSP . Thus the data path from circuit and before to register file write circuit forms a processing pipeline . The present embodiment may employ a hybrid of a heterogeneous element processor HEP system using a single processor with up to six threads T T. Processor pipeline has six stages which matches the minimum number of processor cycles necessary to fetch a data item from circuit to registers and . DSP concurrently executes instructions of different threads T T within a processor pipeline . That is DSP provides six independent program counters an internal tagging mechanism to distinguish instructions of threads T T within processor pipeline and a mechanism that triggers a thread switch. Thread switch overhead varies from zero to only a few cycles.

DSP therefore provides a general purpose digital signal processor designed for high performance and low power across a wide variety of signal image and video processing applications. provides a brief overview of the DSP architecture including some aspects of the associated instruction set architecture for one manifestation of the disclosed subject matter. Implementations of the DSP architecture support interleaved multi threaded IMT processing. In this execution model the hardware supports concurrent execution of multiple hardware threads T T by interleaving instructions from different threads in the pipeline. This feature allows DSP to include an aggressive clock frequency while still maintaining high core and memory utilization. IMT processing provides high throughput without the need for expensive compensation mechanisms such as out of order execution extensive forwarding networks and so on. Moreover the DSP may include variations of IMT processing such as those variations and novel approaches disclosed in the commonly assigned U.S. patent applications by M. Ahmed et al and entitled Variable Interleaved Multi threaded Processor Method and System and Method and System for Variable Thread Allocation and Switching in a Multi threaded Processor. 

Sequencer provides hybrid two way superscalar instructions and four way VLIW instructions to S Pipe unit M Pipe unit LD Load Pipe and LD ST Store Pipe unit all of which communicate with general registers . AXI Bus also communicates via Bus I F with shared data cache LD ST instructions to threads T T. Optional L Cache TCM signals include LD ST instructions with shared data TCM which LD ST instructions further flow to threads General Registers . From AHB peripheral bus MSM specific controller communicates interrupts with T T including interrupt controller instructions debugging instructions and timing instructions. Global control registers communicates control register instructions with threads T T.

DSP therefore includes six virtual DSP cores each containing global control registers and private supervisor control registers . Global control registers are shared between all threads. Each thread shares a common data cache and a common instruction cache. Load store and fetch operations are serviced by a common bus interface. High performance AXI bus and a lower performance AHB bus are used to connect the data and instruction traffic to off core memory and peripherals. An integrated level two memory cache and or TCM input is optional. Peripheral access may be through memory mapped loads and stores. The physical address partition between AHB and AXI may be configured at the MSM level.

Clearly the presented architecture for DSP may evolve and change over time. For example the number of instruction caches that DSP may use could change from six to one or other numbers of caches. Superscalar dispatch L data at TCM and other architectural aspects may change. However the present subject matter may have continued relevance in a wide variety of configurations and for a large family of modifications of DSP .

ISDB through JTAG interface provides a hardware debugger for DSP . ISDB provides software debug features through JTAG interface by sharing system or supervisor only registers. These registers are divided into supervisor control registers on a per thread basis as well as global control registers between all threads. The system control registers are used for per thread interrupt and exception control and per thread memory management activities. Global registers allow interacting with the ISDB for debugging operations.

ISDB enables software developers to debug their software while DSP operates. ISDB hardware in combination with a software debugger program operating in ISDB may be used to debug the DSP operating system software. ISDB supports debugging hardware threads individually. Users may suspend thread execution view and alter thread registers view and alter instruction and data memory single step threads stuff instructions to threads and resume thread execution. Trusted users have access to all of ISDB features while untrusted users have access to a subset of features.

ISDB may interface with a debugger interface card to communicate with ISDB debugging software residing on a program counter PC yet all through JTAG interface . Host debugger software may interact with the ISDB by reading and writing ISDB control registers. Communication for example may be through a 40 bit packet which identifies the ISDB register to which read write is to occur as well as a 32 bit data payload. A packet format supporting this operation may be up to 64 control registers which may be 32 bits wide each.

The per thread mode state diagram of is supported by various instructions or events. These include Except or internal exception event an Int or external interrupt event an RTE or software return instruction from exception mode and SSR or update to SSR register instruction a Stop or software stop instruction that may be entered from any mode a Start or software Start Instruction that also may be entered from any mode a trap or software Trap Instruction a Wait or software wait Instruction a Resume or software Resume Instruction a DE or Debug Event and a DR or Debug Instruction. While the functions in different implementations of the claimed subject matter may vary slightly from those here presented the meanings of Start Wait Resume DE and or DR may be given their broadest interpretations consistent with the scope of the claimed subject matter.

Registers are available in DSP in both USER mode and SUPERVISOR mode . The user mode registers are divided into a set of general registers and a set of control registers. General registers are used for all general purpose computation including address generation scalar and vector arithmetic. Control registers support special purpose functionality such as hardware loops predicates etc. General purpose registers are 32 bits wide and may be accessed as single registers or as aligned pairs of two registers. The general register file provides all operands for instructions including addresses for load store data operands for numeric instructions and vector operands for vector instructions.

DEBUG mode provides a special state where the thread is waiting for commands from ISDB . Whenever an ISDB Debug Event occurs such as by the execution of a software breakpoint instruction a breakpoint command from ISDB or occurrence of a hardware breakpoint indicated threads may enter DEBUG mode . While in DEBUG mode the core is controlled by ISDB via commands from JTAG interface . When the ISDB releases the thread due to execution of a resume command the thread may resume operation according to their current mode settings. When a thread is in DEBUG mode it is controlled by ISDB and cannot be controlled by other threads. A Wait Resume Start or Stop instruction from a running thread targeting a thread in DEBUG mode may be ignored. Similarly a Non Maskable Interrupt NMI may be ignored by threads in DEBUG mode .

A HARDWARE RESET mode not shown in and DEBUG mode are global to all threads. Whenever the hardware reset pin is asserted regardless of any thread s processing state DSP may enter HARDWARE RESET Mode. In HARDWARE RESET mode all registers are set to their reset values. No processing may occur until the hardware reset pin is de asserted. When the reset pin is asserted the processor may transition into reset mode and all registers may be reset to their HARDWARE RESET values. After the reset pin is de asserted thread T may be given a soft reset interrupt. This may cause thread T to enter SUPERVISOR mode and begin executing at the reset vector location. All other threads may remain off. At this point the software is free to control mode transitions for each thread individually.

The ETM therefore provides comprehensive debug and trace functions for DSP and other similar digital signal processors. These functions allow information on the processor s state to be captured both before and after a specific event while adding no burden to the processor s performance even as DSP runs at full speed. The ETM may be configured in software to capture only select trace information and only after a specific sequence of conditions. A dedicated configurable trace port and FIFO then allow the compressed trace data to be read from the chip by an external trace port analyzer without interrupting or affecting the processor.

The trace port can be configured from a 1 to 32 bit data bus with trace clock independent to the core clock. For example the data rate from the ETM can be half of the core clock and the number of pins increased to maintain the data bandwidth. Similarly the number of pins can be halved and the data rate increased. The ETM may be used in both stand alone and within a multi core environment to allow the developer to view simultaneous correlated trace from multiple asynchronous cores.

As shown in the ETM monitors the DSP pipeline. Using this information ETM performs two primary functions filtering triggering and compression packetization. The filtering and triggering operations are programmed by the user through JTAG interface and are used to define when to turn tracing on and off. The compression packetization unit takes the DSP execution information and efficiently forms it into packets that are sent out of ETM through the trace port. The trace stream leaving ETM is fed into trace repository . Trace repository provides a large memory capacity for recording trace records and may be either off chip or on chip. The on chip repository is known as an embedded trace buffer ETB . Decompressor component is a software component running on Debug Host that takes the packet stream from trace repository and along with the program image reconstructs the execution flow of DSP giving the user detailed visibility into the DSP pipeline .

ETM provides trace instruction sequencing and timing for all six threads as well as the ability to record and send out profiling counts cache misses bank conflicts and micro tlb misses . ETM may trigger on PC and LDST addresses as well as on LDST data. ETM supports serial and external event detections. Moreover ETM may also generate ISDB breakpoint trigger events external trigger event and DSP interrupts. ETM is programmable through JTAG and may support a dedicated ETB trace repository of in one embodiment 512 32 bits in one embodiment. ETM may contain 4 trigger blocks each with 2 address and 1 data comparators and may contain a 3 state sequencer. ETM tracing may operate under the control of a secure DSP enable register and may be programmed for operation during DSP power collapse.

ETM generates an instruction trace as a recording of the full progression of the program counter for a thread over a given window in time. Optionally the timing of the program counter progression i.e. identification of stall cycles can also be included in an instruction trace. The event resources mechanisms are used to define when to generate these instruction traces. The trigger and filtering functions are controlled through the programming of the event resources. In more detail the event resources control filtering triggering and ISDB breakpoint generation. Filtering includes the functions of deciding when to enable and disable an instruction trace. Triggering involves deciding when to insert a trigger marker into the packet stream. ISDB breakpoint determination involves specifying the conditions under which ISDB generates and responds to a breakpoint for debugging operations.

ETM contains a number of primary event resources e.g. address and data comparators to detect when specific conditions within DSP occur e.g. whether a certain PC is executed or if a certain memory location is read . In addition there are secondary event resources trigger blocks and the sequencer which enable detection of more complex arrangements of events.

ETB trace repository provides an on chip memory area where trace information is stored during capture rather than being exported immediately through a trace port at the pins of the device. The stored information can then be read out at a reduced clock rate from ETB trace repository once capture has been completed. This is done through JTAG interface . This two step process removes the necessity for a wide trace port that uses many high speed device pins. Effectively a zero pin trace port is created where the device already has a JTAG port at the pins. ETB trace repository may accept data at a higher frequency and with the full 32 bit data port exceeding trace port bandwidth limitations and may integrate with a RAM block supplied by the system integrator.

In one embodiment ETB trace repository has a size of 2 KB arranged as 512 entries each 32 bits wide. However other sizes for ETB trace repository are clearly within the scope of the disclosed subject matter. ETB trace repository interfaces with the user through a set of JTAG accessible registers. Each register can be read or written through JTAG interface . These registers are used to set up ETB trace repository for a trace capture session and to read out the contents of ETB trace repository once trace capture is complete. ETB trace repository provides a read pointer as an index into the ETB trace repository memory array. When reading out the contents of ETB trace repository through JTAG interface the read pointer indicates the location to read. ETB trace repository also provides a write pointer as an index into the ETB trace repository memory array. When trace data is written into ETB trace repository it is written to the entry indicated by the write pointer. Each of the write operations auto increment the write pointer to the next location after write occurs. ETB trace repository may only capture a small window of the ETM trace stream. The ETB looks for a trigger packet from the ETM to determine when to capture data and the trigger counter is used to specify the division between pre trigger data and post trigger data captured by ETB trace repository .

ETM therefore aids a programmer in debugging code for DSP . ETM generates instruction traces which are a record of the execution flow for a thread over a given window in time. Using a recorded instruction trace the programmer can see a detailed view of their code s runtime behavior. For example if the user s program generates and unexplained exception the ETM aids in determining the flow of instructions leading up to the exception thereby allowing the user to assess exactly what happened. ETM uses a particular packet based protocol for efficiently representing program flow and for minimizing the generation of trace data.

One aspect of ETM includes a sequencer process for chaining of events and more complex event detection scenarios. To illustrate operation of the sequencer process and associated trigger block circuits presents sequencer flow diagram . In response to trigger block circuit inputs sequencer process operates in the shown example at three states S S. For operation of sequencer process from state S process flow may go to S or S. From S sequencing advances either ahead to S or back to S. From S sequencing advances to either S or S.

Sequencer process therefore includes three states S S with the transitions between states being programmable and based on matches from trigger blocks circuits . Sequencer process has use in trace filtering for enabling each trigger blocks circuits to be conditioned on state enables. This allows tracing to be restricted to certain states. Upon entering a new state the counter in each trigger blocks circuits may be reloaded to an initial value. Upon entering a given state an ISDB breakpoint can be asserted. Upon entering a given state a trigger marker can be inserted into the trace stream. Upon entering a given state an external trigger control may also be asserted. The external trigger may remain asserted anytime that the sequencer is in the given state. Upon entering a given state an interrupt to DSP may be asserted. After reset the counter is initialized to S. If multiple transitions fire at the same time the sequencer remains in the current state.

In one embodiment ETM contains six counters that can record various events related to DSP performance. The basic operation makes use of each counter as a programmable source. A user programmable region counter divides execution into windows of a fixed number of cycles. During the window the events are accumulated into counters. At the end of the window the counter values are formed into packets and sent out through the trace port. The counters are then reset and the process begins again. When the profiling unit is operated in at the same time as the program flow tracing this results in the program flow trace being overlaid with detailed information about performance events. In addition the profiling unit contains a state enable mask to limit when the unit is active.

A region counter is used to divide up the execution into windows of a fixed number of cycles. The size of the region is determined by a user programmable register. The region counter is initialized to the user specified value and all of the profiling event counters are reset. The region counter then begins counting down. When the region counter reaches zero the value for each of the profiling event counts is emitted in the trace stream. The process then begins again. The region counter only counts when the state enable matches. When the profiling is inactive the region counter maintains its value and resumes when an enabled state is re entered.

Different events for which a profiling counter may accumulate information include a d cache misses b d cache stall cycles c i cache misses d i cache stall cycles e ITLB and DTLB misses and f total stall cycles. In addition each profiling counter contains a six thread mask to restrict the counter to events that occur in certain hardware threads.

As with the region counter the profiling counters are only active when the state enable mask matches the current state. During all other times the counts maintain their values and counting resumes when an enabled state is re entered.

The present disclosure provides a novel packet protocol set of functions to support inter thread trace alignment. That is for any thread that is being traced using ETM at any arbitrary point in time the present disclosure allows identifying for all other threads being traced the program counter value and instruction state e.g. stalled executed etc. of those threads at that point. Thus when ETM operates in a cycle accurate mode trace alignment makes use of a trace port protocol supporting inter thread trace alignment. The present disclosure therefore make cycle count fields for isync restart packets thread relative as well as the cycle count field fully precise for inter thread alignment. The disclosure arrangement generates an isync periodic packet on the same thread cycle for all threads. This further allows for re alignment in the event that thread alignment is lost for any reason.

In one embodiment of the present disclosure provides for the execution of multiple instruction sequences occurring concurrently and during which DSP may be viewed as several single threaded processors operating independently. In ETM program flow is broken down into a sequence of packets and that include thread number tnum fields to certain packets to identify which packet belongs to which thread. For identifying inter thread timing relationships the present disclosure establishes and maintains timing relationships between different threads. Because each thread may enable and disable instruction tracing independently when a thread turns on instruction tracing other threads may already have had their tracing enabled for some time. The presently disclosed method and system establish the relative timing of the threads execution sequences by marking the offset between when a thread turns on tracing and when other threads have turned on and do subsequently turn on tracing.

The present disclosure therefore includes a thread cycle offset field for indicating the number of cycles since the last thread turned on tracing. Also if no other threads are active the cycle offset field contains the number of cycles since the most recent trace turn off among all threads. After a trace session the packets allow for reconstructing the thread execution. Then using the offset fields the execution sequences may be properly aligned among the threads. In addition an instruction alignment mechanism allows re establishing execution tracing in case of a data loss.

The disclosed subject matter furthermore allows re establishing the inter thread timing relationships. By maintaining a global counter that permits periodically generating synchronization packets when the counter reaches zero a packet may be generated for each thread. Such a packet contains the current program counter value for that thread. Now because of various limitations that may exist with DSP relating to simultaneous packet generation for all threads the present disclosure includes a cycle offset field to a synchronization packet. The cycle offset field indicates the number of cycles since the last thread among the other threads generated a synchronization packet. The cycle offset field is of limited size and if the count saturates synchronization will not be able to be achieved and may wait for the counter. Using these mechanisms which are more fully described below the present disclosure allows maintaining inter thread execution timing relationships at any given point for one thread. The result is the ability to observe operations and states of all threads for debugging and other important purposes.

With this understanding illustrates important concepts of the presently disclosed inter thread trace alignment process. Referring to inter thread alignment process is based at time t 0 as time line indicates. For the various threads and that may be operating on DSP thread initiation may occur at different points in time. Thus at time t t thread may initiate operations. Then at a later time t t thread may initiate operations. At time t t thread begins at t t thread begins operations and at t t thread initiates operations. As will be described more fully below in duration represents the number of cycles until tracing becomes active for thread . Duration represents the number of cycles for the trace start program counter PC from the isync restart packet. For all inter related threads an isync periodic packet is generated for all threads at the same time. Furthermore duration addresses the situation of a long stall occurring for example in thread .

To more fully describe the inter thread operations of the present disclosure shows a functional overview of one embodiment of a packet generation unit . Packet generation unit includes packet generation control circuitry which received inputs of atomW atomN and atome for generating outputs of genTsyncP genAsync genBranch genPheader genlsyncR genProf and genCCount to FIFO input mux . Pheader generation circuit receives w count e count and n count inputs from packet generation control circuit and atome input all for generating pheaderPK output to FIFO input mux . PC tld asid tnum input flows to isync restart cycle count generation functions isync periodic generation functions and branch address generation functions . Isync restart cycle count generation functions provide isyncRPK isyncRLen CCPK and CCLen outputs to FIFO input mux . Isync periodic generation functions provide isyncPPK and isyncPLen inputs into FIFO input mux . Branch address generation functions which also receives branch type inputs provides branchPK and branchLen outputs to FIFO input mux . Furthermore profile generations functions receives profile identifier inputs for generating profPK and profLen outputs to FIFO input mux .

FIFO input mux takes all of the packets that need to be generated on a given cycle and forms them into a contiguous chunk. FIFO input mux must account for packets being variable sized when doing its concatenation. The output of FIFO input mux is registered before being sent to the FIFO.

For the present disclosure packet generation and FIFO input mux operations occur across three stages. In the first stage of packet generation packet generation control functions and individual packet generation engines through operates as well as atom counters w count e count and n count increment. FIFO input mux operations include merging all packets generated in the cycle into a contiguous block in this first stage. In the second stage FIFO write occurs to include rotating data to align to FIFO write pointer computing and rotating write enables and writing data into FIFO mux registers. At the third stage FIFO read stage data may be read from FIFO registers. At this third stage also the special case of inserting the trigger packet and sending data to ETB occurs.

As seen in each of the individual packet generation units packetizes its respective data and then sends the resulting packet and length to FIFO input mux for concatenation. In addition packet generation control circuit maintains the atom counters and decides which packets to generate on a particular cycle. Packet generation unit maintains three counters to record the number of pending atoms that may be sent out in future pheader or cycle count packet. The E atom counter increments whenever an E atom is encountered. The N atom counter increments whenever an N atom is encountered and the count includes the current atom. That is if the current atom is an N it will be included in the N atom count. The W atom counter increments whenever a W atom is encountered. These counters are per thread counters and as such there are six copies of each in the present embodiment. The counters are reset whenever the counts are sent out through a pheader or cycle count packet.

From branch address generation functions a branch address packet may be generated for a target of an indirect branch loopback if the target is different from previous loopback. If all loopbacks mode is set the packet is sent out for every loopback. Also a new loopback packet is forced out after an isync restart and isync periodic packet is generated. The target of a PC relative branch IF direct branches mode is then set. The target of an event interrupt exception SWI TRAP etc. returns the RTE instruction. The branch address packet may be generated when trace enable is asserted and it is not the first cycle of tracing an isync restart packet may be generated instead . The packet generation control unit maintains a previous loopback target register for each thread to determine if a loopback branch address packet is needed.

The branch address packet is variable with PC TID ASID and type compression. The TID ASID may be sent out if either one has changed since the last branch address packet or isync restart or periodic for the tnum. The type may be sent out if it has changed since the last type was sent out. It may be generated on the first branch address packet after a isync restart or isync periodic. The PC is compressed relative to the previous PC sent by a branch address isync restart or isync periodic. The lower portion of the PC that has changed may be sent out. For each thread previous PC previous TID ASID and previous type registers are used to determine the proper compression.

Anytime an isync restart packet is encountered the present disclosure may inspect the cycle count field and cycle count type field. If the type field is global the process assigns a last isync restart count to the cycle count field value and annotates that packet with last isync restart count. If the type field is offset the process may increment the last isync restart count by the value in the cycle count field and further annotate the packet with last isync restart count. At which point each isync restart packet will be annotated with a global thread cycle value.

The next step is to annotate the atoms. The process splits the trace stream into the individual thread local packet streams based on the tnum values in the packet stream. For each thread local packet stream the process maintains a variable global thread cycle. This value is maintained such that anytime an isync restart packet is encountered global thread cycle is assigned to the value that was annotated. Each time an instruction atom is encountered E N S or W the process may annotate that atom with global thread cycle and increment global thread cycle by 1. Using the normal decompression procedure the process determines the program counter values for each atom. After this procedure is applied every cycle of every thread being traced may be annotated with a global thread cycle count value. As a result for example for a given thread cycle the current program counter value for all six threads may be determined as well as the state of the pipeline for those threads stalled executed etc. 

For the non cycle accurate version the TID field is expanded to 32 bits. For the cycle accurate version the TID is expanded to 32 bits and the new cycle count field is defined to support trace alignment. A global cycle count indicates the number of thread cycles since the last hardware reset. An offset cycle count indicates the number of cycles since the last isync restart packet was generated.

The ETM isync periodic counters may be decremented whenever packet bytes are sent to the FIFO. When the counter reaches zero for a thread an isync periodic packet may be marked as pending. At the next opportunity the isync periodic packet is generated. An isync periodic may be held back if any of the following packets are being generated isync restart trigger branch address async profile . Each thread may maintain its own isync periodic counter. The isync counters may be reset whenever any isync restart packet is generated for that thread.

The cycle count in the isync restart packet has been redefined as two possible types a 64 bit global count that is referenced from the last hardware reset and a 16 bit offset count that indicates the number of thread cycles since the last isync restart packet from among all threads .

In addition to two byte and three byte cycle count packets the present disclosure provides a three byte packet to fit a 32 bit value into the 16 bit payload. In the present subject matter a five byte packet which includes a one byte header and four byte payload is defined as shown in . For each thread the disclosed process maintains a count global thread cycle. For the first isync periodic packet that is encountered the process sets a global thread cycle to that packet s annotated value and annotates the previous atom with that value. The global thread cycle is then incremented by 1. Anytime an atom E N S W is encountered the process annotate that atom with the global thread cycle and increments the global thread count by 1. The process may decompress the stream as normal to assign program counter values to each atom. At this point as before every cycle of every thread being traced will have a global thread cycle associated with it.

In summary the disclosed subject matter provides a method and system for inter thread trace alignment with a multi threaded processor for use with execution trace processing. The disclosed subject matter therefore includes recording timing data relating to a common predetermined event. Such an event may be the number of cycles since a last thread initiated execution tracing or the number of cycles since all threads terminated execution tracing. The number of cycles at which a thread initiates execution tracing is referenced to the common predetermined event for maintaining the timing of execution tracing. The data relating to the common predetermined event may then updated to associate with the time at which the thread initiated execution tracing. The result is to permit aligning the timing data associated with all threads. Interrelated records permit reconstructing interdependent execution tracing information for threads operating in the multi threaded processor as well as synchronizing timing data for all operating threads.

As seen above the processing features and functions described herein for inter thread trace alignment with a multi threaded processor in a multi threaded digital signal processor including an interleaved multi threaded processor may be implemented in various manners. For example not only may DSP perform the above described operations but also the present embodiments may be implemented in an application specific integrated circuit ASIC a microcontroller a digital signal processor or other electronic circuits designed to perform the functions described herein. Moreover the process and features here described may be stored in magnetic optical or other recording media for reading and execution by such various signal and instruction processing systems. The foregoing description of the preferred embodiments therefore is provided to enable any person skilled in the art to make or use the claimed subject matter. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without the use of the innovative faculty. Thus the claimed subject matter is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

