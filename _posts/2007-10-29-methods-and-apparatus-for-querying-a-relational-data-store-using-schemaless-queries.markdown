---

title: Methods and apparatus for querying a relational data store using schema-less queries
abstract: The invention provides, in one aspect, a method of searching an RDF triples data store of the type in which the triples are maintained in accord with a first storage schema. The method includes inputting a first query specifying RDF triples that are to be identified in the data store. That first query assumes either (i) that the triples are stored in a schema-less manner (i.e., with no storage schema) or (ii) that the triples are maintained in accord with a second storage schema that differs from the first. The method further includes generating, from the first query, a second query that specifies those same RDF triples, yet, that reflects the first storage schema. That second query can be applied to the RDF triples data store in order to identify and/or retrieve the desired data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08412720&OS=08412720&RS=08412720
owner: 
number: 08412720
owner_city: 
owner_country: 
publication_date: 20071029
---
This application is a continuation of U.S. patent application Ser. No. 11 101 361 filed Apr. 6 2005 entitled Methods And Apparatus For Querying A Relational Data Store Using Schema Less Queries now published as US 2005 0187926 which is a continuation of U.S. patent application Ser. No. 10 302 764 filed Nov. 21 2002 entitled Methods And Apparatus For Querying A Relational Data Store Using Schema Less Queries now issued as U.S. Pat. No. 6 925 457 which claims the benefit of priority of U.S. Provisional Patent Application Ser. No. 60 332 053 filed Nov. 21 2001 entitled Methods And Apparatus For Querying A Relational Database In A System For Real Time Business Visibility and U.S. Provisional Patent Application Ser. No. 60 332 219 filed on Nov. 21 2001 entitled Methods And Apparatus For Calculation And Reduction Of Time Series Metrics From Event Streams Or Legacy Databases In A System For Real Time Business Visibility. U.S. patent application Ser. No. 10 302 764 is also a continuation in part of U.S. patent application Ser. No. 09 917 264 filed Jul. 27 2001 entitled Methods and Apparatus For Enterprise Application Integration now issued as U.S. Pat. No. 7 058 637 which claims the benefit of priority of U.S. Provisional Patent Application Ser. No. 60 291 185 filed May 15 2001 entitled Methods And Apparatus For Enterprise Application Integration. U.S. patent application Ser. No. 10 302 764 is also a continuation in part of U.S. patent application Ser. No. 10 051 619 filed Oct. 29 2001 entitled Methods And Apparatus For Real Time Business Visibility Using Persistent Schema Less Data Storage now issued as U.S. Pat. No. 6 856 992 which claims the benefit of priority of U.S. Provisional Patent Application Ser. No. 60 324 037 filed Sep. 21 2001 entitled Methods And Apparatus For Real Time Business Visibility Using Persistent Schema Less Data Storage and which is a continuation in part of U.S. patent application Ser. No. 09 917 264 filed Jul. 27 2001 entitled Methods and Apparatus For Enterprise Application Integration now issued as U.S. Pat. No. 7 058 637 . The teachings of all of the foregoing applications are incorporated herein by reference.

The invention pertains to digital data processing and more particularly to methods and apparatus for enterprise business visibility and insight using real time reporting tools.

It is not uncommon for a single enterprise to have several separate database systems to track internal and external planning and transactional data. Such systems might have been developed at different times throughout the history of the enterprise and therefore represent differing generations of computer technology. For example a marketing database system tracking customers may be ten years old while an enterprise resource planning ERP system tracking inventory might be two or three years old. Integration between these systems is difficult at best consuming specialized programming skill and constant maintenance expenses.

A major impediment to enterprise business visibility is the consolidation of data from these disparate legacy databases with one another and with that from newer e commerce databases. For instance inventory on hand data gleaned from a legacy ERP system may be difficult to combine with customer order data gleaned from web servers that support e commerce and other web based transactions. This is not to mention difficulties for example in consolidating resource scheduling data from the ERP system with the forecasting data from the marketing database system.

An object of this invention is to provide improved methods and apparatus for digital data processing and more particularly for enterprise business visibility and insight hereinafter enterprise business visibility .

A further object is to provide such methods and apparatus as can rapidly and accurately retrieve information responsive to user inquiries.

A further object of the invention is to provide such methods and apparatus as can be readily and inexpensively integrated with legacy current and future database management systems.

A still further object of the invention is to provide such methods and apparatus as can be implemented incrementally or otherwise without interruption of enterprise operation.

Yet a still further object of the invention is to provide such methods and apparatus as to facilitate ready access to up to date enterprise data regardless of its underlying source.

Yet still a further object of the invention is to provide such methods and apparatus as permit flexible presentation of enterprise data in an easily understood manner.

These and other objects are attained by the invention which provides in one aspect a method of searching an RDF triples data store of the type in which the triples are maintained in accord with a first storage schema. The method includes inputting a first query based for example on a user request specifying RDF triples that are to be identified in the data store. That first query assumes either i that the triples are stored in a schema less manner i.e. with no storage schema or ii that the triples are maintained in accord with a second storage schema that differs from the first. The method further includes generating from the first query a second query that specifies those same RDF triples yet that reflects the first storage schema. That second query can be applied to the RDF triples data store in order to identify and or retrieve the desired data.

The invention provides in further aspects a method as described above including the steps of examining the first query for one or more tokens that represent data to be used in generating the second query. It also includes dispatching context specific grammar events containing that data. A related aspect of the invention provides for dispatching events that represent any of declarations and constraints specified in the first query. A still further related aspect provides for dispatching declaration events specifying RDF documents from which triples are to be identified and constraint events specifying the triples themselves.

Further aspects of the invention provides methods as described above that include the steps of extracting statement data from the first query and associating that statement data with at least a portion of the second query. That second query can be generated according to related aspects of the invention in the form of an SQL SELECT statement. The associating step can include associating statement data from the first query with one or more clauses of the SELECT statement to with the SELECT clause the FROM clause the WHERE clause and the ORDER BY clause.

Still further aspects of the invention provide a method of translating a schema less input query in a first language to an output query in a second language. As above the method includes examining the schema less input query for one or more tokens that represent data to be used in generating the output query dispatching context specific grammar events containing that data and populating portions of the output query according to the events and data. The method further includes generating the output query in the second language comprising those populated portions where the output query embodies a schema of a relational database storing RDF triples.

A related aspect of the invention provides methods as described above in which the dispatching step includes generating any of a logical condition event a selection term declaration event and a triple declarations event. A further related aspect of the invention includes generating a logical condition event containing data which when applied to the relational database via the output query identifies RDF triples according to a specified Boolean condition. A further related aspect of the invention includes generating an event containing data which when applied to the relational database via the output query identifies RDF triples including a specified term. A still further related aspect of the invention includes generating an event containing data which when applied to the relational database via the output query identifies RDF triples having a specified subject predicate and or object.

Related aspects of the invention provide methods as described above in which the first language is any of SQL like and XML like.

These and other aspects of the invention are evident in the drawings and in the description that follows.

Legacy databases represent existing and future databases and other sources of information including data streams in a company organization or other entity hereinafter enterprise . In the illustration these include a retail e commerce database e.g. as indicated by the cloud and server icons adjacent database maintained with a Sybase database management system an inventory database maintained with an Oracle database management system and an ERP database maintained with a SAP Enterprise Resource Planning system. Of course these are merely examples of the variety of databases or other sources of information with which methods and apparatus as described herein can be used. Common features of illustrated databases are that they maintain information of interest to an enterprise and that they can be accessed via respective software application program interfaces API or other mechanisms known in the art.

Connectors serve as an interface to legacy database systems . Each connector applies requests to and receives information from a respective legacy database using that database s API or other interface mechanism. Thus for example connector applies requests to legacy database using the corresponding SAP API connector to legacy database using Oracle API and connector to legacy database using the corresponding Sybase API.

In the illustrated embodiment these requests are for purposes of accessing data stored in the respective databases . The requests can be simple queries such as SQL queries and the like e.g. depending on the type of the underlying database and its API or more complex sets of queries such as those commonly used in data mining. For example one or more of the connectors can use decision trees statistical techniques or other query and analysis mechanisms known in the art of data mining to extract information from the databases.

Specific queries and analysis methodologies can be specified by the hologram data store or the framework server for application by the connectors. Alternatively the connectors themselves can construct specific queries and methodologies from more general queries received from the data store or server . For example request specific items can be plugged into query templates thereby effecting greater speed and efficiency.

Regardless of their origin the requests can be stored in the connectors for application and or reapplication to the respective legacy databases to provide one time or periodic data store updates. Connectors can use expiration date information to determine which of a plurality of similar data to return to the data store or if dates are absent the connectors can mark returned data as being of lower confidence levels.

Data and other information collectively messages generated by the databases in response to the requests are routed by connectors to the hologram data store . That other information can include for example expiry or other adjectival data for use by the data store in caching purging updating and selecting data. The messages can be cached by the connectors though they are preferably immediately routed to the store .

The hologram data store stores data from the legacy databases and from the framework server as discussed below as RDF triples. The data store can be embodied on any digital data processing system or systems that are in communications coupling e.g. as defined above with the connectors and the framework server . Typically the data store is embodied in a workstation or other high end computing device with high capacity storage devices or arrays though this may not be required for any given implementation.

Though the hologram data store may be contained on an optical storage device this is not the sense in which the term hologram is used. Rather it refers to its storage of data from multiple sources e.g. the legacy databases in a form which permits that data to be queried and coalesced from a variety of perspectives depending on the needs of the user and the capabilities of the framework server .

To this end a preferred data store stores the data from the legacy databases in subject predicate object form e.g. RDF triples though those of ordinary skill in the art will appreciate that other forms may be used as well or instead. By way of background RDF is a way of expressing the properties of items of data. Those items are referred to as subjects. Their properties are referred to as predicates. And the values of those properties are referred to as objects. In RDF an expression of a property of an item is referred to as a triple a convenience reflecting that the expression contains three parts subject predicate and object.

Subjects also referred to as resources can be anything that is described by an RDF expression. A subject can be person place or thing though typically only an identifier of the subject is used in an actual RDF expression not the person place or thing itself Examples of subjects might be car Joe http www.metatomix.com. 

A predicate identifies a property of a subject. According to the RDF specification this may be any specific aspect characteristic attribute or relation used to describe a resource. For the three exemplary subjects above examples of predicates might be make citizenship owner. 

An object gives a value of a property. These might be Ford United Kingdom Metatomix Inc. for the subject and objects given in the prior paragraphs forming the following RDF triples 

Objects can be literals i.e. strings that identify or name the corresponding property predicate . They can also be resources. In the example above rather than merely the string Metatomix Inc. further triples may be specified presumably ones identifying that company in the subject and giving details in predicates and objects.

A given subject may have multiple predicates each predicate indexing an object. For example a subject postal zip code might have an index to an object town and an index to an object state either or both index being a predicate URI.

Listed below is a portion of a data set of the type with which the invention can be practiced. The listing contains RDF triples here expressed in extensible markup language XML syntax. Those skilled in the art will of course appreciate that RDF triples can be expressed in other syntaxes and that the teachings hereof are equally applicable to those syntaxes. Further the listing shows only a sampling of the triples in a database which typically would contain tens of thousands or more of such triples.

Subjects are indicated within the listing using a rdf about statement. For example the second line of the listing defines a subject as a resource named postal zip 02886. That subject has predicates and objects that follow the subject declaration.

One predicate is associated with a value Warwick . Another predicate is associated with a value RI . The same follows for the predicates and which are associated with values USA and 02886 respectively. Similarly the listing shows properties for the subject postal zip 02901 namely Providence RI US and 02901. 

In the listing the subjects and predicates are expressed as uniform resource indicators URIs e.g. of the type defined in Berniers Lee et al RFC 2396 August 1998 and can be said to be expressed in a form . For the subjects given in the example is postal is zip and is for example 02886 and 02901. 

The predicates too are expressed in the form as is evident to those in ordinary skill in the art. In accord with XML syntax the predicates in lines two et seq. of the listing must be interpreted as suffixes to the string provided in the namespace directive xmlns http www.metatoinix.com postalCode 1.0 in line one of the listing. This results in predicates that are formally expressed as http www.metatomix.com postalCode 1.0 town http www.metatomix.com postalCode 1.0 state http www.metatomix.com postalCode 1.0 country and http www.metatomix.com postalCode 1.0 zip. 

Hence the for the predicates is http and is wwwmetatomix.com postalCode 1.0. The portions are and respectively. It is important to note that the listing is in some ways simplistic in that each of its objects is a literal value. Commonly an object may itself be another subject with its own objects and predicates. In such cases a resource can be both a subject and an object e.g. an object to all upstream resources and a subject to all downstream resources and properties. Such branching allows for complex relationships to be modeled within the RDF triple framework.

As indicated in the drawing RDF triples maintained by the store are received from the legacy databases via connectors and or from time based data reduction module described below in the form of document objects e.g. of the type generated from a Document Object Model DOM in a JAVA C or other application. In the illustrated embodiment these are stored in the model document store A as such i.e. document objects particularly using the tables and inter table relationships shown in see dashed box labelled B .

The model document manager B manages storage retrieval of the document object to from the model document store A. In the illustrated embodiment the manager B comprises the Slide content management and integration framework publicly available through the Apache Software Foundation. It stores and retrieves document objects to and from the store A in accord with the WebDAV protocol. Those skilled in the art will of course appreciate that other applications can be used in place of Slide and that document objects can be stored retrieved from the store A in accord with other protocols industry standard proprietary or otherwise.

However use of the WebDAV protocol allows for adding updating and deleting RDF document objects using a variety of WebDAV client tools e.g. Microsoft Windows Explorer Microsoft Office XML Spy or other such tools available from a variety of vendors in addition to adding updating and deleting document objects via connectors and or time based data reduction module . This also allows for presenting the user with a view of a traversable file system with RDF documents that can be opened directly in XML editing tools or from Java programs supporting WebDAV protocols or from processes on remote machines via any HTTP protocol on which WebDAV is based.

RDF triples received by the store are also stored to a relational database here store C that is managed and accessed by a conventional relational database management system RDBMS D operating in accord with the teachings hereof. In that database the triples are divided into their constituent components subject predicate and object which are indexed and stored to respective tables in the manner of a hashed with origin approach. Whenever an RDF document is added updated or deleted a parser E extracts its triples and conveys them to the RDBMS D with a corresponding indicator that they are to be added updated or deleted from the relational database. Such a parser E operates in the conventional manner known in the art for extracting triples from RDF documents.

The illustrated database store C has five tables interrelated as particularly shown in see dashed box labelled C . In general these tables rely on indexes generated by hashing the triples respective subjects predicates and objects using a 64 bit hashing algorithm based on cyclical redundancy codes CRCs though it will be appreciated that the indexes can be generated by other techniques as well industry standard proprietary or otherwise.

Referring to the triples table maintains one record for each stored triple. Each record contains an aforementioned hash code for each of the subject predicate and object that make up the respective triple along with a resource flag resource flg indicating whether that object is of the resource or literal type. Each record also includes an aforementioned hash code m hash identifying the document object stored in model document store A from which the triple was parsed e.g. by parser E.

In the illustrated embodiment the values of the subjects predicates and objects are not stored in the triples table. Rather those values are stored in the resources table namespaces table and literals table . Particularly the resources table in conjunction with the namespaces table stores the subjects predicates and resource type objects whereas the literals table stores the literal type objects.

The resources table maintains one record for each unique subject predicate or resource type object Each record contains the value of the resource along with its aforementioned 64 bit hash. It is the latter on which the table is indexed. To conserve space portions of those values common to multiple resources e.g. common identifiers are stored in the namespaces table . Accordingly the field r value contained in each record of the resources table reflects only the unique portion e.g. identifier of each resource.

The namespaces table maintains one record for each unique common portion referred to in the prior paragraph hereinafter namespace . Each record contains the value of that namespace along with its aforementioned 64 bit hash. As above it is the latter on which this table is indexed.

The literals table maintains one record for each unique literal type object. Each record contains the value of the object along with its aforementioned 64 bit hash. Each record also includes an indicator of the type of that literal e.g. integer string and so forth . Again it is the latter on which this table is indexed.

The models table maintains one record for each RDF document object contained in the model document store A. Each record contains the URI of the corresponding document object uri string along with its aforementioned 64 bit hash m hash . It is the latter on which this table is indexed. To facilitate associating document objects identified in the models table with document objects maintained by the model document store A each record of the models table also contains the ID of the corresponding document object in the store A. That ID can be assigned by the model document manager B or otherwise.

From the above it can be appreciated that the relational triples store C is a schema less structure for storing RDF triples. As suggested by Melnik supra triples maintained in that store can be reconstituted via an SQL query. For example to reconstitute the RDF triple having a subject equal to postal zip 02886 a predicate equal to http www.metatomix.com postalCode 1.0 town and an object equal to Warwick the following SQL statement is applied 

Those skilled in the art will of course appreciate that RDF documents and more generally objects maintained in the store can be contained in other stores structured relationally hierarchically or otherwise as well in addition to or instead of stores A and C.

Referring to the relational triples store manager D supports SQL queries such as the one exemplified above for extracting a triple with the subject postal zip 02886 the predicate http www.metatomix.com postalCode 1.0 town and the object Warwick . As evident in the example such SQL queries must take into account the underlying storage schema of the relational database here hashed by origin . To remove that as a constraint on queries e.g. made by a user and applied via the framework or otherwise a query translator translates schema less queries into schema based SQL queries for application to the relational store C. In the illustrated embodiment the schema less queries are expressed in an SQL like language here identified as HxQL or in an XML like language here identified as HxML however it will be appreciated that any language or means for expressing a query schema less or otherwise may be used instead or in addition.

The illustrated query translator has a language parsing component an event processing component and an SQL statement management generation component . The language parsing component examines the input query for tokens that represent data to be used in generating the SQL statement and dispatches context specific grammar events containing that data to the event processor. The event processor receives these and retrieves the data stored within them for use by statement management generation component to generate the SQL SELECT statement .

In the illustrated embodiment the language parsing component has two parsing elements each directed to one of two languages in which schema less queries can be expressed. The HxQL parser parses queries expressed in the HxQL language while the HxML parser parses queries expressed in the HxML. HxQL grammar is based on R. V. Guha s RDFDB query language Libby Miller s SquishQL and Andy Seaborne s RDQL. The HxQL parser is implemented using JavaCC a commercially available parser developed jointly by Sun Microsystems and Metamata. H ML comprises a grammar based on XML. The HxML parser is implemented using an XML parser such as Xerces available from Apache. It will be appreciated that in other embodiments the language parsing component can have more or fewer parsing elements and that those elements can be used to parse other languages in which the input query may be expressed.

The illustrated language parsing component can dispatch eight events. For example a global document declaration event is dispatched indicating that a RDF document specified by a URI is included in the optional set of default document models to query. A logical condition event is dispatched when a constraint is parsed limiting triple data that is to be considered for retrieval. A namespace declaration event is dispatched when a mapping has been declared between an alias id and a URI fragment. An order by declaration event is dispatched when a record sorting order is specified with regard to columns of data representing terms selected for retrieval. A selection term declaration event is dispatched when a term is selected for retrieval. A triple declaration event is dispatched when a criterion for triple consideration is declared. A triple document declaration event is dispatched when at least one URI for an RDF document is declared to replace the set of default document models to query against but for a single particular triple criterion. And finally a triple model mapping event is dispatched when the set of default document models to query against for an individual triple criterion will be shared with a different individual triple criterion. It will be appreciated that more or less that these events are only examples of ones that can be dispatched and in one embodiment more or less events are appropriate depending on the schema of the database to be searched.

The event processing component listens for context specific grammar events and extracts the data stored within them to populate the statement management generator component with the data it needs for generating the SQL SELECT statement . For example a Boolean constraint represented in a logical condition event is extracted and dispatched to the statement management generation component for inclusion in a SELECT WHERE clause of a SQL SELECT statement.

The statement management generation component stores and manages statement data and maps it directly to the relational triples store C schema. It uses that mapped data to generate an output query corresponding to the input query . The statement manager delegates the generation of the SQL SELECT statement to agent objects . Each agent generates a particular clause of the SELECT statement e.g. the SELECT FROM WHERE and ORDER BY clauses. In other embodiments the statement manager can generate queries according to a different database storage schema and can output queries conforming to other languages.

In the illustrated embodiment a select clause agent generates the SELECT clause by mapping each term to the appropriate table and or field name corresponding to tables field names in triples data store C. A from clause agent generates the FROM clause and ensures that table instances and their alias abbreviations are declared for use in other clauses. A where clause agent generates the WHERE clause and ensures that all necessary table JOINS and filtering constraints are specified. Lastly an order by clause agent generates an optional ORDER BY clause thus specifying an order of the output results. In one embodiment the agent objects distribute SQL generation between custom fragment managers and uses differing agents in accord with the database to be searched. Hence it can be appreciated that the above agents are exemplary of a query translator directed to generating queries for a relational triple store C and in other embodiment agents will be in accord with the data store of that embodiment. Each agent can also gather data from other agents as necessary for example alias information stored in a SELECT clause can be used to formulate constraints in the WHERE clause. Hence the agents work in tandem until all statement data is properly mapped according to the schema of the triples store C.

It will be appreciated by those skilled in the art that the query translator can be encapsulated and composited into other software components. It will also be appreciated that although the query translator is directed toward an RDF triples store utilizing the hash with origin schema it can generate output for use with triples or other stores utilizing other database vendors. For example the query translator can be implemented to output various SQL dialects e.g. Microsoft SQL which uses 0 and 1 for Boolean values versus the conventional TRUE FALSE keywords. Further configurable options such as generating SQL with or without computed hash codes in join criteria can be accommodated as well.

Illustrated below is an example of use of the query translator to generate an output SQL query for application against a relational store C containing triples organized in the aforementioned hashed with origin schema from the RDF document 

A schema less query here expressed in the HxQL language for returning all blood types stored in the triples store C is as follows 

Operation of the query translator results in generation of the following SQL SELECT statement for application against the relational data store C 

The data store includes a graph generator not shown that uses RDF triples to generate directed graphs in response to queries e.g. in HxQL or HxML form from the framework server . These may be queries for information reflected by triples originating from data in one or more of the legacy databases one example might be a request for the residence cities of hotel guests who booked reservations on account over Independence Day weekend as reflected by data from an e Commerce database and an Accounts Receivable database . Such generation of directed graphs from triples can be accomplished in any conventional manner known the art e.g. as appropriate to RDF triples or other manner in which the information is stored or preferably in the manner described in co pending commonly assigned U.S. patent application Ser. No. 10 138 725 filed May 3 2002 entitled METHODS AND APPARATUS FOR VISUALIZING RELATIONSHIPS AMONG TRIPLES OF RESOURCE DESCRIPTION FRAMEWORK RDF DATA SETS and Ser. No. 60 416 616 filed Oct. 7 2002 entitled METHODS AND APPARATUS FOR IDENTIFYING RELATED NODES IN A DIRECTED GRAPH HAVING NAMED ARCS the teachings of both of which are incorporated herein by reference. Directed graphs so generated are passed back to the server for presentation to the user.

According to one practice of the invention the data store utilizes genetic self adapting algorithms to traverse the RDF triples in response to queries from the framework server . Though not previously known in the art for this purpose such techniques can be beneficially applied to the RDF database which due to its inherently flexible i.e. schema less structure is not readily searched using traditional search techniques. To this end the data store utilizes a genetic algorithm that performs several searches each utilizing a different methodology but all based on the underlying query from the framework server against the RDF triples. It compares the results of the searches quantitatively to discern which produce s the best results and reapplies that search with additional terms or further granularity.

Referring back to the framework server generates requests to the data store and or indirectly to the legacy databases via connectors as discussed above and presents information therefrom to the user via browser . The requests can be based on HxQL or H ML requests entered directly by the user though preferably they are generated by the server based on user selections responses to questions dialog boxes or other user input controls. In a preferred embodiment the framework server includes one or more user interface modules plug ins or the like each for generating queries of a particular nature. One such module for example generates queries pertaining to marketing information another such module generates queries pertaining to financial information and so forth.

In addition to generating queries the framework server and or the aforementioned modules walks directed graphs generated by the data store to present to the user via browser any specific items of requested information. Such walking of the directed graphs can be accomplished via any conventional technique known in the art. Presentation of questions dialog boxes or other user input controls to the user and likewise presentation of responses thereto based on the directed graph can be accomplished via conventional server browser or other user interface technology.

In some embodiments the framework server permits a user to update data stored in the data store and thereby that stored in the legacy databases . To this end changes made to data displayed by the browser are transmitted by server to data store . There any triples implicated by the change are updated in store C as are the corresponding RDF document objects in store A. An indication of these changes can be forwarded to the respective legacy databases which utilize the corresponding API or other interface mechanisms to update their respective stores. Likewise changes made directly to the store C as discussed above e.g. using a WebDAV client can be forwarded to the respective legacy database. 

In some embodiments the server can present to the user not only data from the data store but also data gleaned by the server directly from other sources. Thus for example the server can directly query an enterprise web site for statistics regarding web page usage or otherwise.

A further understanding of the operation of the framework server may be attained by reference to the appendix filed with U.S. patent application Ser. No. 09 917 264 filed Jul. 27 2001 and entitled Methods and Apparatus for Enterprise Application Integration which appendix is incorporated herein by reference.

Described herein are methods and apparatus meeting the above mentioned objects. It will be appreciated that the illustrated embodiment is merely an example of the invention and that other embodiments incorporating changes to those described herein fall within the scope of the invention of which

