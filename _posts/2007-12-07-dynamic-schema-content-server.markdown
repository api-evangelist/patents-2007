---

title: Dynamic schema content server
abstract: A method to develop a game using a networked content server includes an efficient method to add or modify a new object into the game environment. The method includes the generation of an XML input file describing the new object. The XML new object definition file is uploaded from a game developer client device to a content server. The content server automatically examines the XML input file and converts the definition file to an object type graph and then into a set of SQL instructions as well as a set of web methods. The content server automatically executes the SQL instructions to enter the new object into a database. Web methods corresponding to the new object and are provided to the client device for access to the new object. The game developer thus has nearly immediate access to the new object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256654&OS=09256654&RS=09256654
owner: Microsoft Technology Licensing, LLC
number: 09256654
owner_city: Redmond
owner_country: US
publication_date: 20071207
---
The development of game software is a time consuming process. Typically a new game is developed for a given gaming platform such as XBox manufactured by Microsoft Corporation. The gaming platform manufacturer provides a software development kit SDK to game developers to start their new game development. The SDK contains application programming interfaces APIs that allow the game developers to access functionality of the gaming platform. Also provided may be basic physics video and audio packages that can control the movement look and sound of objects presented in a game for the gaming platform.

When a game developer decides to create a new object for a game such as a new vehicle or a new tool or weapon the game developer contacts the gaming platform manufacturer and provides a description of the desired new object. Documentation for the new object is generated by the game developer and sent to the gaming platform manufacturer who then takes the new object description and generates the new object essentially manually. The new object along with the supporting access APIs for the new object are then generated in a new build of the SDK. The next version of the SDK can then be provided to the game developer after the release of the new SDK build. This process can take weeks or more and much time can be lost in iterations of this process to develop the most desirable form for the new object. Thus the development of new games for a new gaming platform can take as much as two years before a first version of the new game is available for public consumption.

It would be advantageous to reduce the time delay in developing new objects for games to be run on gaming platforms. A reduction in time delay and the removal of human intervention in new object development at the gaming platform manufacturer would likely result in greater efficiencies in game development activities better utilization of human resources and a shorter time to market for new games. The present invention addresses these concerns and others.

In one aspect of the invention a game developer need only submit a human readable input document such as an XML input document or file that describes a new object or object type or class that is desired to be added to a new game to be run on a gaming platform in order to automatically initiate the generation of the new object or object type or object class. The inventive system inputs the client based game developer provided XML input description file and the system automatically creates the new object in a networked content server database. The game developer is then able to access the new object within minutes of the submittal of the XML input via a new library that includes the new object.

To create the new object the XML file is automatically converted at the content server into a type graph and type graph abstraction. The type graph abstraction is then converted into a set of SQL statements that instruct a database management system DBMS of the content server to create the new object. In addition web method procedures or RPC calls similar to web based Application Programming Interfaces APIs that correspond to use of the new object in the gaming platform are generated and then sent from the content server to the client as part of an update to the software development kit used by the client to develop the new game for the gaming platform. This is a pre production use of the aspects of the new method to develop new game software for a specific gaming platform.

The new features of the new gaming configuration can also be used post production by game players. In this post production aspect game players can upload data objects such as photos video captures game player developed vehicles maps and ratings and the like to the content server. An uploaded data object can be shared among all game players to enhance the game playing experience.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The local network shown in supports a network interface that may interface to a larger network such as an Intranet or the World Wide Web. Platform developer is a network entity that represents the game platform generator. For Example the game developers can be developing a new game application that runs on a specific game platform such as PlayStation by Sony of New York or XBox by Microsoft of Washington. As an aspect of the current invention the platform developer e.g. Microsoft Corporation supplies the content server also connected to network which supports game application development for the game platform of interest such as XBox .

The game developers can download base programs such as physics programs base layouts and operational application programming interfaces APIs from the platform provider that assist in developing games that are compatible with the platform. In the example of the platform developer provides and maintains the content server for this and other purposes. Thus game developers can access the necessary tools and interfaces needed to design a new game application compliant with the rules and features of the game platform e.g. Xbox .

As discussed briefly above in the prior art if game developers wanted to develop new objects for a platform a new object would have to be formulated with the help of the platform developer. The new object description would have to be delivered or otherwise communicated to the platform developer possibly via standard ground transportation based package mail and be implemented by the platform developer by hand. Then after implementation of the new object the platform developer would have to compile the new object and provide a new build of the game software development kit and issue it to the game developers and . This process takes a great deal of time where the game developers have to work without the desired new object.

In one aspect of an embodiment a system and method supporting the efficient development of software for a game includes the use of a content server . The content server is a server device on the network that is maintained by the platform developer for the benefit of the game developers . The content server includes a network interface allowing communications through the network to other entities also on the network. Authentication block is used to enforce a restricted access to content server files. For example access to the content server would allow a user to search and acquire database objects via the SQL database within the content server . The game development team may have access to objects and files that are related to their particular game and would be prevented from having access to files and objects belonging to another game development team.

In one aspect of the invention a human readable document or file such as but not limited to an XML document or file is prepared at the game developer client that describes a new object a new object type or a new object class. Generally these three forms may be collectively referred to as a new object herein for the convenience of a reader skilled in the art. A new object once created and stored in the content server database can easily be shared by any of the game developers . Examples of a new object include photos vehicles maps or roads background scenes characters tools for characters and players or any custom generated game feature. The XML document is prepared according to a schema that defines dynamic classes and queries. The document is sent over the network from a game developer client to the content server .

The content server receives the XML document via the network interface and authenticates the user via the authentication block . The content server then receives the XML document and validates and parses the XML description document. The XML converter block of the content server serves to perform several conversions. The first conversion is an XML to object type graph conversion. This conversion produces an object type graph corresponding to the XML document using the schema developed for the input document description of the object being generated. The result of first conversion is a type graph that serves as in input to a second conversion. The second conversion generates a set of SQL statements that will generate modify or delete tables in a SQL database. The second converter of the XML to SQL conversion is thus an object type graph to SQL statement converter. Another conversion is a type graph to web method procedures conversion which produces Remote Procedure Calls RPCs allowing the use of APIs so that the newly created object may be acquired via a web method.

The output of the type graph to SQL converter is a set of SQL instructions which load various tables within the SQL database that correspond to the new object. The new object is thus created and becomes part of the SQL database as the SQL instructions are executed by the SQL DBMS . Although the new object is created and stored in the database as a result of the execution of the SQL instructions the new object is useless to the game developers if the new object cannot be properly accessed. Therefore hooks to the new object must be generated for the game developers use. The content server API engine generates program hooks i.e. Application Programming Interfaces that can be used by a game developer client to access the new game object.

The API engine inputs information related to the new object table generation by generating APIs that can be used by the game developers to access the new object. This set of APIs automatically generated along with the automatic generation and execution of the SQL instructions is assembled as part of a library of information for the game developers. Also provided in the library information are query standards so that the new object may be searched and retrieved using SQL queries against the Database . The library of information containing the APIs that invoke the SQL queries in the content server is gathered into a new segment of a software development kit SDK update. This SDK update is given to the game developers for immediate use to search and utilize the new object and its corresponding functionality.

Thus game developers instead of waiting days or weeks for a new object to become functional in their prototype game can use the fast turn around aspects of the functionality of to design submit and receive an updated SDK for their new object in a matter of minutes. This improvement in turn around time increases game developer productivity and creativity because it allows near real time creation and updates of game objects during game development.

As a consequence of this added capability to develop new game objects during the development of games the same basic creation tool can be extended in a game application form to game players in post production of the game. Some of the same aspects of the invention expressed herein are used to upload and share objects between players. Although the players are not granted permission to change the game additional objects may be loaded by game players for game use.

In one aspect of the invention the content server and the dynamic schema definition may be used by game players to share objects that relate to their game play. For example after the game is produced and sold to gamers gamers can use aspects of the invention such as the content server to share information between the players. Examples of shared information include in game photos taken by one of the players during a game play video capture replays of events in a previous game play vehicles that can optionally be used in a game maps to help orient gamers to the playing field of the game world ratings of any piece of data or a collection of statistics concerning players games played downloaded or rated.

Typically a game player is going to create a new object such as a photo or a new vehicle via graphical user interface presented in the course of playing the actual game. Usually the game developer has already written the code to take the player created object instance and encode it as values in a C structure. The game client provides libraries that then transform those C structures into serialized blobs of data suitable for transmission across the network to the content server. Once at the content server the blob is deserialized into a runtime representation of an object instance of the types previously described and created in pre production by the game developer. Then the blob goes through a system that translates the in memory representation into appropriate SQL commands to insert a row or rows into the table or tables previously generated by the developer using content server in pre production. The whole process can be reversed for retrieving objects from the database for presentation in the game client. Thus the one can also add functionality in the middle of that process such as when the object is in memory on the content server before or after being in SQL database to add such features as content rating or other modifications or processes.

The following code provides are example embodiments of XML input file formats for the schema according to aspects of the invention. The name of each schema is provided below as the game name Gotham and a descriptor for the schema. The Gotham Common Content Classes schema functions to enumerate content classes associated with Car Information Replay of Car Information and Description Information. The Gotham Photo Content schema serves to identify class and class members associated with Photos. The Gotham Replay content schema serves as a replay descriptor. The Gotham Ghost Content schema enumerates subclasses of the ghost name. In one embodiment an XML Schema Definition XSD file is written to explicitly describe the rules that describe the new schema. One of skill in the art will realize that an XSD file may be needed to further process the XML schemas presented below.

Returning to once the input XML is received at step it is parsed at step for syntax errors and user type. The user type graph is generated at step and a type graph abstraction is generated at step . The user type graph abstraction may then be used to generate SQL code for the element or object being generated and web methods for use by game developers.

As is well known by those of skill in the art a type graph indicates the relationship between base classes subclasses and data member types. illustrates an example type graph for a base class called vehicle this base class has fields or attributes including cost make owner and the like. As part of a class inheritance example vehicles include an automobile having files or attributes of gross vehicle weight number of axles and the like. Another example vehicle is an airplane having attributes of the number of seats wingspan and the like. Yet another example of a vehicle is a boat having the attributes of length body style and the like. As mentioned before a vehicle also has an ownership attribute. This ownership attribute has a type and may be referred to as a field type reference. In this instance the type is called an identity which may include a field or attribute for a name address and the like. The identity may have an inheritance tree which includes a business where the ownership or the industry description may be attributes. Another example of identity type is a user which may have attributes of owner password or other like attributes. ia merely an example of a type graph for a base class named vehicle. Such type graphs exist in memory and in relation to the present invention are produced at steps and of

Returning to the generation of a type graph abstraction for a new object for the game under developments provides a useful mechanism to generate in parallel a DBMS object related to the XML definition provided via the input file at step and a web method that may be used by a game developer. Using the example object type graph provided via step above the process continues at step with the following steps that define the object type to SQL statement conversion. As can be appreciated by one of skill in the art although SQL or a relational database implementation DBMS RDBMS etc. is described other database languages and database forms such as relational or non relational can be used equally well with all of the descriptions presented herein.

The type graph abstraction is used to generate SQL tables and procedure definitions at step corresponding to the new object defined by the XML input file of step and the type graph representation of step . In one embodiment the SQL tables and procedure definition statements are generated as Transact SQL T SQL form. The tables and procedure statements generated are then executed at step to create the new object defined via the XML input file of step .

In a parallel process the abstraction of the type graph generated at step is used at step to generate web method procedures corresponding to the new object. Web methods are essentially remote procedure calls RPCs that define application programming interfaces APIs useful across the web to invoke action concerning the new object in the content server. The web method procedures are generated and are made available to the client via client side API stub definitions at step . These client side APIs allow the client to display and use the new object generated by the T SQL instructions and made accessible via the web method procedures. In one embodiment the client side APIs behave like proxy stubs for client code to appear as a local client call but in actuation produce RPC like calls.

Also depicted in is an input leg at steps and that permit the construction of a system type graph from a .Net language file. In this path the new object could be defined in a .NET language such as C and be input and compiled at step . The compiled .Net file cn them be converted to a common language runtime CLR type graph at step . The type graph is further defined as a system type graph at step before being converted to an abstraction of a type graph at step . From there the generation of the new objects is as before where the object itself is generated and stored in the DBMS via SQL statement generation execution and result storage via steps . The web method procedures are also automatically generated and provided to the client via steps as described above.

In the API Engine produces APIs and SQL search information resulting from the above referenced XML conversions to type graphs and the subsequent generation of new objects in a SQL DBMS and corresponding web methods. The APIs and SQL search information resulting from the API Engine operations produces a software development kit SDK update useful to the game developer which allows access to the newly created or modified object. In general the SDK content includes the APIs corresponding to the SQL queries used by the game developer client device to access the DBMS tables containing the new or modified object in the content server . The client device uses the APIs provided in the SDK which invoke web methods. The web methods invoke the SQL statements which have been created and installed on the content server in order to access the new objects. It should be noted that developers typically modify only the type graph and thus the tables and APIs during game development. However during game play a game player typically does not modify the type graph. Instead a game player typically creates an actual instance of the types described by the type graph envisioned by the game developer. The type graph envisioned by the game developer becomes defined or is referenced in the parameters of the relevant APIs during game development. As a result of the definition during game development the developed type graph is stored as rows in the tables of the type graph.

Returning to initially a game developer generates an XML file describing the new object to be created for the game platform at step . Alternatively the game developer may desire to modify an existing game object and may submit an XML document describing the modified game object or the game object to be deleted. The generated XML file is uploaded via a network to the content server from the game developer client server in step .

The received XML file is received by the content server parsed and examined for completeness at step . Here the parsing and examination includes a detection to ensure that all necessary elements of the XML file are compliant with the dynamic schema which is used as a format for generating an XML input file. For example the XML input file must comply to the schema which may include such elements as the class and type of object an object name and other attributes useful to either define the object or useful to search for the object. Search elements may include the date of object creation the author and the game and version identification. Attributes for object operation may include characteristics of the object and limitations on object use.

Once the input XML file is checked for completeness a conversion from XML to an object type graph is performed at step . This step is further explained via of the present application as presented herein. At this point two paths are taken. One path including steps and generate the new object in accordance with the type graph produced in step . The other path steps generates APIs and other useful elements to enable game developers to use the new objected created from the input XML file. Now following the generation of the object in the content server after an object type graph is acquired in step a conversion is performed in step from an object type graph to a set of SQL instructions. This conversion automatically generates SQL instructions needed to realize new or updated tables and search instructions for the new or modified object in the DBMS of the content server. The SQL instructions are then automatically executed at step in the content server SQL DBMS so that tables indexes on tables and queries are generated relating to the new or modified object. At this point the XML input file defining the new object has been realized in multiple tables in a SQL database associated with the content server for the specific game platform that the game developers are using.

Following the API generation path after generation of the object type graph of step application programming interfaces APIs relating to the use of the new or modified object are automatically generated at step . These APIs are related to web methods which allow APIs to be used as part of remote procedure calls RPCs which can invoke a call for the newly generated object. These newly assembled APIs and RPCs along with search references for the new objects are assembled into a library at step . This library constitutes an updated software development kit SDK that is immediately within minutes of receiving the input XML file downloaded to the client device over a network. This updated SDK can now be used to search for the new or modified object using the search terms provided in the SDK in step . In using the automatically generated APIs and RPCs for the new object a user essentially invokes the web methods which include invoking of the SQL instructions and statements for accessing the new object already stored on the DBMS of the content server. Use of the updated SDK features results in a display of the new or modified object at the game developer client device.

Using the features of the process allows game developers a capability to create new objects via an XML schema and submit an XML input file. The newly created object is then made available in minutes instead of days or weeks. The time saving alone in game development represents an advance over prior art processes for new object creation in a game development based on a gaming platform. This greatly reduced turn around time for new object also allows a game developer to quickly make modifications to any object in the game environment. For example in step of the game developer at a client device can now access the newly created object and generate modifications via a second XML input file. This new input file can then be loaded into the content server from the client device at step . The process then can automatically proceed through the multiple conversion processes automatically execute new SQL instructions for the modified object generate APIs RPCs and SQL queries for the new object and a new library and SDK will be delivered to the client device so that the game developer can access his modified object within minutes.

Although not required embodiments of the invention can also be implemented via an operating system for use by a developer of services for a device or object and or included within application software. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers PCs server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing an example host computer includes a general purpose computing device in the form of a computer system . Components of computer system may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures.

Computer system typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disk Read Only Memory CDROM compact disc rewritable CDRW digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer system .

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer system such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer system may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer system . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory not shown . In addition to monitor computer systems may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer system may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer system is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s .NET platform available from MICROSOFT Corporation includes servers building block services such as Web based data storage and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of an embodiment of the invention may also be implemented via an operating system application programming interface API or a middle man object between any of a coprocessor a display device and a requesting object such that operation may be performed by supported in or accessed via all of .NET s languages and services and in other distributed computing frameworks as well.

As mentioned above while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to implement a method for quickly realizing a new object in a game environment. Thus the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same similar or equivalent systems and methods achieved by embodiments of the invention.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

