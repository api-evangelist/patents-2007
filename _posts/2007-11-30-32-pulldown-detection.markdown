---

title: 3:2 pulldown detection
abstract: Field-based detection of 3:2 pulldown in a sequence of digital video fields using a programmable graphics processor is described. The detection is performed using a threshold value to determine equivalence between a pair of fields of digital video data. Furthermore, additional threshold values may be used to control switching into a mode where duplicated fields of digital video data are identified and not displayed and out of the mode where duplicated fields of digital video data are identified and not displayed. Look ahead can be used to detect when to switch into or out of the mode where duplicated fields of digital video data are identified and not displayed, reducing the occurrence of visual artifacts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08094239&OS=08094239&RS=08094239
owner: NVIDIA Corporation
number: 08094239
owner_city: Santa Clara
owner_country: US
publication_date: 20071130
---
Current graphics data processing includes systems and methods developed to perform a specific operation on graphics data e.g. linear interpolation tessellation rasterization texture mapping depth testing and the like. Traditionally graphics processors include several fixed function computation units to do such specific operations and more recently the computation units have a degree of programmability to perform user specified operations.

While computation units included in each graphics processor can vary a common element is a sampling unit that processes graphics primitives and generates sub primitive data such as pixels or fragments. Graphics primitives include geometry such as points lines triangles quadrilaterals meshes and the like. A graphics processor uses a sampling unit and computation units to convert graphics primitives into sub primitive data and generate image data.

Graphics processors use memory to store graphics data and program instructions where graphics data is any data that is input to or output from the computation units within the graphics processor. Graphics memory is any memory used to store graphics data or program instructions to be executed by the graphics processor. Graphics memory can include portions of system memory local memory directly coupled to the graphics processor register files coupled to the computation units within the graphics processor and the like.

The computation units within some graphics processors are coupled to each other to form a graphics pipeline such that the output of a first computation unit is coupled to the input of a second computation unit to form a node. Computation units are coupled in sequence to form additional nodes. Additional computational units can be connected between two nodes to form parallel computational units. Within the graphics pipeline processing can proceed simultaneously within each of the computational units.

Recently graphics processors can be programmed using shader programs and vertex programs permitting a wider variety of functions to be performed using these programmable graphics processors. Consequently functions that traditionally required dedicated fixed function hardware such as video processing functions can be performed using programmable graphics processors.

During the transfer of film to video each film frame is decomposed into an odd field including odd horizontal scan lines from a film frame and an even field including even horizontal scan lines from the film frame for display on an interlaced display such as an NTSC video display. An odd or even field is replicated every other film frame during 3 2 pulldown to compensate for the greater number of frames displayed per second during video playback. When film content is transferred using 3 2 pulldown information indicating 3 2 pulldown was used may be encoded with the data. This information may be used by later progressive video decoding hardware to remove the replicated odd or even fields. Removal of the replicated fields reduces artifacts resulting from displaying temporally asynchronous fields synchronously. However for some content e.g. extras such as cut scenes interviews music videos and the like the pulldown information is not encoded or may not be accurate and visual artifacts can be introduced by improperly removing fields or by not removing replicated fields prior to display.

Accordingly it is desirable to accurately detect the presence of 3 2 pulldown independent of the pulldown encoded information and to selectively determine which fields to display for each frame of progressive video. Furthermore when possible it is desirable to use a programmable graphics processor to perform the functions traditionally performed using dedicated fixed function hardware.

A method for detecting 3 2 pulldown in a digital video data sequence measures a difference between a subsequent pair of digital video data fields to produce a field difference. The subsequent pair of digital video data fields includes an nth digital video data field in the digital video data sequence and an n 2 th digital video data field in the digital video data sequence. The field difference is compared to a field match threshold value to produce a field match result.

Another method for detecting 3 2 pulldown in a digital video data sequence measures a difference between portions of subsequent pairs of digital video data fields to produce a field portion difference. The measurement is repeated to produce additional field portion differences.

Another method for detecting pulldown in a digital video data sequence filters a portion of a field of digital video data and filters a corresponding portion of a subsequent field of digital video data. A field portion difference between the filtered portion of the field of digital video data and the filtered corresponding portion of the subsequent field of digital video data is measured to produce a field portion difference. The filtering and measurement is repeated to produce additional field portion differences.

Another method for detecting 3 2 pulldown in a digital video data sequence measures differences between five sequential pairs of fields of digital video data to produce five field differences. Each of the five field differences is compared to a field match threshold value to produce a matched field count and a field compare count. Detection of 3 2 pulldown is indicated when the field compare count is five and the matched field count is one. Detection of 3 2 pulldown is not indicated when the field compare count is five and the matched field count is not one.

Another method for detecting a 3 2 pulldown pattern in a digital video data sequence measures differences between five sequential pairs of fields of digital video data in the digital video data sequence to produce a matched field count and a field compare count. A pulldown match count is updated when the field compare count is five and the matched field count is one. A pulldown non match count is updated when the field compare count is five and the matched field count is not one. The pulldown match count is compared to a matched field count threshold value and the pulldown non match count is compared to a non matched field count threshold value to produce a pulldown result.

A method for using look ahead to detect 3 2 pulldown in a digital video data sequence to reduce visual artifacts during display stores five sequential pairs of fields of digital video data in the digital video data sequence in a graphics memory as texture map data. The five sequential pairs of fields of digital video data in the digital video data sequence are read from the graphics memory. Differences between the five sequential pairs of fields of digital video data in the digital video data sequence are measured to produce a pulldown result. The five sequential pairs of fields of digital video data in the digital video data sequence are selectively displayed at least partially responsive to the pulldown result.

A graphical user interface for 3 2 pulldown detection includes a graphical element for a user to select enter or adjust a match field threshold value for use by a programmable graphics processor configured to perform 3 2 pulldown detection in a digital video data sequence.

A graphical user interface for 3 2 pulldown detection includes a graphical element for a user to select enter or adjust a matched field count threshold value for use by a programmable graphics processor configured to perform 3 2 pulldown detection in a digital video data sequence.

A graphical user interface for 3 2 pulldown detection includes a graphical element for a user to select enter or adjust a non matched field count threshold value for use by a programmable graphics processor configured to perform 3 2 pulldown detection in a digital video data sequence.

An application programming interface for a programmable graphics processor includes a function call to configure the programmable graphics processor to use at least one threshold value for detecting 3 2 pulldown in a digital video data sequence.

A programmable graphics processor configured to detect 3 2 pulldown in a sequence of digital video fields includes a read interface configured to read the sequence of digital video fields from a graphics memory and a fragment shader configured to detect 3 2 pulldown in the sequence of digital video fields under control of shader program instructions.

A computing system includes a host processor a host memory the host memory storing programs for the host processor a system interface configured to interface with the host processor a video unit configured to provide digital video data to the system interface and a programmable graphics processor. The programmable graphics processor includes a read interface configured to read the digital video data from a graphics memory and a fragment shader configured to detect 3 2 pulldown in the digital video data under control of shader program instructions.

Another computing system includes a host processor a host memory the host memory storing programs for the host processor a system interface configured to interface with the host processor and a programmable graphics processor. The programmable graphics processor includes a video unit configured to provide digital video data to a fragment shader. The fragment shader is configured to detect 3 2 pulldown in the digital video data under control of shader program instructions.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

Likewise a Field is the odd field of Frame and a Field is the even field of Frame . A Field is the odd field of Frame and a Field is the even field of Frame . During 3 2 pulldown Field is duplicated so it precedes and follows Field in Portion of Pulldown Sequence . A pattern in Portion of Pulldown Sequence started with Frame is completed with the even field of Frame a Field and the odd field of Frame a Field .

A Portion of Film Content Sequence is constructed using Portion of Pulldown Sequence . Fields and are displayed as a Frame . Fields and are displayed as a Frame . Fields and are displayed as a Frame . Fields and are displayed as a Frame . Fields and are displayed as a Frame . When fields from different frames in Portion of Film Sequence are displayed in a frame in Portion of Film Content Sequence visual artifacts can be introduced. For example Frame is displayed using even Field from Frame and odd Field from Frame . Fields and were not acquired synchronously and spacial visual artifacts such as combing feathering smearing and the like can be introduced for portions of Frame that differ from portions of Frame .

A Portion of Film Content Sequence is also constructed using Portion of Pulldown Sequence . Unlike Portion of Film Content Sequence Portion of Film Content Sequence only includes frames displayed using fields captured synchronously. Fields and are displayed as a Frame and the duplicated Field is discarded. The construction of Non Interlaced Video Sequence is more complex than the construction of Portion of Film Content Sequence because fields in Portion of Pulldown Sequence are selectively discarded. Fields and are displayed as a Frame . Fields and are displayed as a Frame and the duplicated Field is discarded. To achieve a desired number of frames per second constructed Frames and others are replicated during the construction of Non Interlaced Video Sequence . A programmable graphics processor can be used to construct Non Interlaced Video Sequence as described further herein.

Host computer communicates with Graphics Subsystem via System Interface and an Interface . Graphics Subsystem includes a Local Memory and a Programmable Graphics Processor . In addition to Interface Programmable Graphics Processor includes a Graphics Processing Pipeline Memory Controller and an Output Controller . Data received at Interface can be passed to a Geometry Processor within Graphics Processing Pipeline or written to Local Memory through Memory Controller . In addition to communicating with Local Memory and Interface Memory Controller also communicates with Graphics Processing Pipeline and Output Controller through read and write interfaces in Graphics Processing Pipeline and a read interface in Output Controller . The read and write interfaces generate address and control signals to Memory Controller .

Within Graphics Processing Pipeline graphics processing units Geometry Processor and a Fragment Processing Pipeline each contain at least one programmable computation unit PCU to perform a variety of computational functions. Some of these functions are table lookup scalar addition vector addition multiplication division coordinate system mapping calculation of vector normals tessellation calculation of derivatives interpolation and the like. Geometry Processor and Fragment Processing Pipeline are optionally configured such that data processing operations are performed in multiple passes through Graphics Processing Pipeline or in multiple passes through Fragment Processing Pipeline . Each pass through Programmable Graphics Processor Graphics Processing Pipeline or Fragment Processing Pipeline concludes with optional processing by a Raster Analyzer .

Geometry Processor receives a stream of program instructions and data and performs vector floating point operations or other processing operations to produce processed data. The program instructions and data are stored in graphics memory e.g. portions of Host Memory Local Memory or storage resources within Programmable Graphics Processor . Storage resources can include register files caches FIFOs first in first out and the like. When a portion of Host Memory is used to store program instructions and data the portion of Host Memory can be uncached so as to increase performance of access by Programmable Graphics Processor . The processed data is passed from Geometry Processor to a Rasterizer . In a typical embodiment Rasterizer performs scan conversion and outputs fragment pixel or sample data and program instructions to Fragment Processing Pipeline . Therefore Fragment Processing Pipeline is typically programmed to operate on fragment pixel or sample data. For simplicity the remainder of this description will use the term fragments to refer to pixels samples and fragments.

Fragment Processing Pipeline is programmed to process fragments using shader programs that are sequences of program instructions compiled for execution within Fragment Processing Pipeline . Fragment Shader within Fragment Processing Pipeline generates codewords from shader program instructions. Furthermore Fragment Shader within Fragment Processing Pipeline is optionally configured using shader programs such that data processing operations are performed in multiple passes within Fragment Shader . Data processed by Fragment Shader is passed to Raster Analyzer which optionally performs near and far plane clipping and raster operations such as stencil z test and the like and saves the results in graphics memory. Raster Analyzer includes a read interface and a write interface to Memory Controller through which Raster Analyzer accesses data stored in Local Memory or Host Memory .

When processing is completed an Output of Graphics Subsystem is provided using Output Controller . Output Controller is optionally configured to deliver data to a Display Device network electronic control system other Computing System other Graphics Subsystem recording device or the like.

The field match result can be used to selectively output the sequence of digital video data without the duplicated fields thereby removing the fields introduced during 3 2 pulldown. In additional steps are included following the steps and shown in . The additional steps are used for outputting the fields of digital video data. In step Compare Unit is configured by shader program instructions to compare the field difference to a field match threshold value and if the field difference does not exceed i.e. is not greater than the field match threshold value in step Programmable Graphics Processor outputs one of the fields of digital video data and the subsequent field of digital video data. If in step the field difference exceeds i.e. is greater than the field match threshold value in step Programmable Graphics Processor outputs both the field of digital video data and the subsequent field of digital video data. Alternatively Compare Unit is configured by shader program instructions to compare the field difference to a field match threshold value and if the field match threshold value exceeds i.e. is greater than the field difference Programmable Graphics Processor outputs one of the field of digital video data and the subsequent field of digital video data. Furthermore If the field match threshold value does not exceed i.e. is not greater than the field difference Programmable Graphics Processor outputs the field of digital video data and the subsequent field of digital video data.

In step Fragment Shader determines if there are more portions of the pair of fields of digital video data and if so Fragment Shader repeats steps and to produce additional filtered field portion differences. If in step Fragment Shader determines there are no more portions of the pair of fields of digital video data in step Fragment Shader combines the filtered field portion difference and the additional filtered field portion differences to produce a field difference. In step Compare Unit is configured by shader program instructions to compare the field difference to a field match threshold value to produce a field match result.

In step Fragment Shader compares the pair of fields of video data and generates a field match result as described further herein. In step Fragment Shader also updates the field compare count by incrementing the field compare count. In the alternative embodiment the field compare count is decremented. In step Fragment Shader uses the field match result to determine if the pair of fields of video data match and if so in step the matched field count is updated by incrementing the matched field count. In the alternative embodiment the non matched field count is updated by incrementing the non matched field count. If in step Fragment Shader determines the pair of fields of video data do not match Fragment Shader proceeds to step . In step Fragment Shader determines if five field comparisons have been completed e.g. the value of the field compare count is equal to five and if not Fragment Shader repeats steps and and optionally repeats step until Fragment Shader determines that five field comparisons have been completed in step . In the alternative embodiment in step Fragment Shader determines that five field comparisons have been completed when the value of the field compare count is equal to zero.

For example a sequence of field match results generated in step during processing of Portion of Pulldown Sequence shown in is equal for the comparison of Field and duplicated Field not equal for a comparison of Field and Field not equal for a comparison of duplicated Field and Field not equal for a comparison of Field and Field and not equal for a comparison of Field and Field . For every five successive field comparisons of the fields in Portion of Pulldown Sequence there is one matched field due to the use of pulldown to generate Portion of Pulldown Sequence from Portion of Film Sequence .

Continuing in step if Fragment Shader determines that five field comparisons have been completed in step Fragment Shader determines if there is one matched field count e.g. the matched field count is equal to one. In the alternative embodiment Fragment Shader determines there is one matched field count when the non matched field count is equal to four. If in step Fragment Shader determines there is one matched field count in step Fragment Shader determines a pulldown result e.g. sets a pulldown flag to a true state and returns to step . If in step Fragment Shader determines there is not one matched field count in step Fragment Shader determines a pulldown result e.g. sets the pulldown flag to a false state and returns to step . The pulldown flag can be used by Fragment Shader to disable display of duplicated fields effectively removing the duplicated fields. The pulldown flag can also be used by Display Device to control a display mode. When the pulldown flag is set to the true state video fields excluding any disabled video fields originating from film content are displayed using a non interlaced display mode. Conversely when the pulldown flag is set to the false state video fields originating from video content i.e. without 3 2 pulldown are displayed using an interlaced display mode.

In step Fragment Shader bilinearly interpolates each component e.g. Y U and V of the four neighboring texels read from field to generate an interpolated texel from field . In step Fragment Shader bilinearly interpolates each component of the four neighboring texels read from field to generate an interpolated texel from field . Bilinearly interpolating the texels within each field reduces the texel data by a factor of four and utilizes at least one PCU or Filter Unit that would otherwise be idle. Consequently the number of absolute differences input to the mean absolute difference computation for each pair of fields is also reduced by a factor of four.

In step Fragment Shader computes an absolute value of a difference between each component of the interpolated texel from field and each component of the interpolated texel from field to generate an interpolated texel difference for each component. In step Fragment Shader accumulates the interpolated texel difference for each component with the FieldDiff. In step Fragment Shader determines if there are texels in field or field that have not been read and bilinearly interpolated and if so steps and are repeated. If in step Fragment Shader determines that all of the texels in field and field have been read and bilinearly interpolated in step Fragment Shader computes a mean of the FieldDiff.

In step Fragment Shader determines if FieldDiff is less than a field match threshold value to be further described herein. In an alternative embodiment Fragment Shader determines the field match threshold value is not less than than FieldDiff. If in step Fragment Shader determines FieldDiff is less than the field match threshold value in step Fragment Shader sets a field match result to a true state. If in step Fragment Shader determines FieldDiff is not less than the field match threshold value in step Fragment Shader sets the field match result to a false state. The field match result is used by Fragment Shader in step of .

The field match threshold value can have a default value and the field match threshold value can be modified by writing a new value to a field match threshold register in Programmable Graphics Processor that is readable by Fragment Shader . In an alternative embodiment the field match threshold value can be selected from a fixed set of values using a program instruction or register write. Additionally a distribution of the FieldDiff values for a plurality of field comparisons can be collected and fuzzy logic can be used to dynamically tune the field match threshold value based on the distribution.

When to switch into film mode can be determined by counting the number of times pulldown is detected for a sequence of fields of digital video data. Likewise when to switch into film mode can be determined by counting the number of times pulldown is not detected for a sequence of fields of digital video data. For each sequence of five digital video field pair comparisons the number of times pulldown is detected is counted and the number of times pulldown is not detected is counted to generate a pulldown match count and a pulldown non match count respectively. The pulldown match count is compared to a matched field count threshold value IFMT into film mode threshold value to control a transition into film mode and the pulldown non match count is compared to a non matched field count threshold value OFMT out of film mode threshold value to control a transition out of film mode.

In step Video Unit receives a stream of MPEG encoded digital video fields. In step Video Unit decodes the stream of MPEG encoded digital video fields and outputs a sequence of digital video fields containing fields of digital video data. In step System Interface stores the fields of digital video data as texture maps in Host Memory or in Local Memory via Interface and Memory Controller . In step the field compare count and the matched field count in Fragment Shader are each initialized to a value of zero. In step Fragment Shader reads a pair of fields of digital video data as texture maps.

In step Fragment Shader compares the pair of fields of digital video data and produces the field match result. In step Fragment Shader also updates the field compare count by incrementing the field compare count. In step Fragment Shader uses the field match result to determine if the pair of fields of digital video data match and if so in step the matched field count is updated by incrementing the matched field count. If in step Fragment Shader determines the pair of fields of digital video data do not match Fragment Shader proceeds to step . In step Fragment Shader determines if the value of the field compare count is equal to five and if not Fragment Shader repeats steps and and optionally repeats step until the field compare count is equal to five in step .

In step if Fragment Shader determines five field comparisons have been completed in step Fragment Shader determines if there is one matched field. If in step Fragment Shader determines there is one matched field in step Fragment Shader updates the pulldown match count by incrementing the pulldown match count and proceeds to step . If in step Fragment Shader determines there is not one matched field in step Fragment Shader updates the pulldown non match count by incrementing the pulldown non match count and proceeds to step . In step Fragment Shader determines if the pulldown match count is greater than the IFMT and if so in step Fragment Shader sets the pulldown flag to a true state and proceeds to step . If in step Fragment Shader determines the matched field count is not greater than the IFMT in step Fragment Shader determines if the pulldown non match count is greater than the OFMT and if not returns to step . If in step Fragment Shader determines the pulldown non match count is greater than the OFMT in step Fragment Shader sets a pulldown flag to a false state and proceeds to step . In step Fragment Shader initializes the pulldown match count and the pulldown non match count to zero and returns to step and the process continues.

The pulldown flag and the field match result can be used by Programmable Graphics Processor to control switching into film mode by selecting which fields within the sequence of digital video fields to output or display i.e. marking duplicated fields such that they are not output or displayed. Digital video fields that are not output or displayed are effectively discarded. Likewise the pulldown flag can also be used by Programmable Graphics Processor to control switching out of film mode by selecting all fields within the sequence of digital video fields for output or display.

Graphical User Interface includes options for setting the field match threshold value. A user may select one option by selecting a radio button a radio button or a radio button and the selection is communicated to Fragment Shader as described further herein. Selecting radio button enables Fragment Shader to dynamically tune the field match threshold value based on a distribution of the FieldDiff values for a plurality of field comparisons. In an alternative embodiment Selecting radio button enables Fragment Shader to detect 3 2 pulldown according to a user defined algorithm included in a shader program. Selecting radio button enables the user to specify the field match threshold value using a slider bar to select a match percent ranging from zero to one hundred percent match. In an alternative embodiment the user selects the match percent by entering a value into a data entry field. The match percent is converted into the field match threshold value. Selecting radio button allows the user the select the field match threshold value encoded for a studio or other content provider using a drop down menu . In an alternative embodiment the user selects the field match threshold value encoded for a studio or other content provider using a button.

Graphical User Interface includes options for setting the IFMT. The user may select one option by selecting a radio button a radio button or a radio button . Selecting radio button enables Fragment Shader to dynamically tune the IFMT based on a distribution of the pulldown match counts and pulldown non match counts for a plurality of field comparisons. Selecting radio button enables the user to specify the IFMT using a slider bar to select the IFMT ranging from one to ten or even higher. Selecting radio button allows the user the select the IFMT value encoded for a studio or other content provider using a drop down menu .

Graphical User Interface includes options for setting the OFMT. The user may select one option by selecting a radio button a radio button or a radio button . Selecting radio button enables Fragment Shader to dynamically tune the OFMT based on a distribution of pulldown match counts and pulldown non match counts for a plurality of field comparisons. Selecting radio button enables the user to specify the OFMT using a slider bar to select the OFMT ranging from one to ten or even higher. Selecting radio button allows the user the select the OFMT value encoded for a studio or other content provider using a drop down menu .

An application programming interface API can be used by an application to specify the values for the field match threshold value IPHM or OFMT. For example the API can be used to communicate selections entered by the user of Graphical User Interface to Fragment Shader . The API is executed by Host Processor and includes a function call that is used to write at least one register in Programmable Graphics Processor that is readable by Fragment Shader . For example the OFMT value corresponding to the studio selection entered by the user of Graphical User Interface is written to an OFMT register in Fragment Shader using the function call. The function call includes the register address and the value to be stored in the register.

A device driver executed by Host Processor detects that Programmable Fragment Shader supports the field match threshold value IPHM or OFMT and communicates that information to the API. A graphics application executed by Host Processor can issue the function call to specify values stored in the at least one register that is readable by Fragment Shader .

Consequently the transition into film mode when pulldown is detected occurs earlier than without the use of look ahead. Conversely the transition out of film mode when pulldown is not detected occurs earlier than without the use of look ahead. The occurrence of visual artifacts e.g. combing feathering and the like caused by displaying video content non interlaced will be minimized.

In step five pairs of fields of digital video data are stored in Local Memory as texture maps. In step a sequence count is initialized. The sequence count can be set to IFMT when Pulldown is false and set to OFMT when Pulldown is true. Alternatively the sequence count can be set to an independent value using a register write instruction. In step Fragment Shader reads the five pairs of fields of digital video data stored as texture maps. For example referring to Portion of Pulldown Sequence in Frames duplicated and are read by Fragment Shader . In step Fragment Shader compares the five pairs of video fields as described in or and updates e.g. decrements the sequence count. For example referring again to Portion of Pulldown Sequence in Frames and duplicated are compared Frames and are compared Frames duplicated and are compared Frames and are compared and Frames and are compared. The field match result for each comparison is used to generate duplicated field information. The duplicated field information is saved as state information stored in Fragment Shader or in graphics memory.

In step Fragment Shader determines if the sequence has been completed e.g. the sequence count is equal to zero and if so Fragment Shader determines if the pulldown flag is set to a true state. If in step Fragment Shader determines if the sequence has been completed e.g. the sequence count is not equal to zero Fragment Shader proceeds to step .

If in step Fragment Shader determines the pulldown flag is set to a true state in step Fragment Shader uses the duplicated field information and updates field display state information to disable any fields that are duplicates. If in step Fragment Shader determines the pulldown flag is not set to a true state i.e. the pulldown flag is set to a false state Fragment Shader proceeds to step . In step the field display state information is passed from Fragment Shader to Output Controller via Raster Analyzer and Memory Controller and enabled fields are output for display by Output Controller . In step Fragment Shader initializes the sequence count and in step Fragment Shader reads the next five video fields for example beginning with duplicated Field . The last two of the previously read video fields e.g. Fields and Field in Portion of Pulldown Sequence in are also available in Fragment Shader to provide five pairs of video fields for step . In an alternative embodiment the last two of the previously read video fields are read by Fragment Shader in step . In one embodiment the sequence count is decremented in step and the display of the first video field occurs after the sequence count is decremented to a value of zero. Therefore the higher the value that the sequence count is initialized to the longer the time will be from Programmable Graphics Processor receiving a first video field until the first video field is displayed.

While foregoing is directed to embodiments in accordance with one or more aspects of the present invention other and further embodiments of the present invention may be devised without departing from the scope thereof which is determined by the claims that follow. Claims listing steps do not imply any order of the steps unless such order is expressly indicated.

