---

title: Delaying database writes for database consistency
abstract: A continuous set of committed transactions can be lost without destroying the integrity of the database, by deferring the writing of the database pages stored in cache to the database on stable storage. A waypoint tracks a point in the transaction log following which transactions have not been applied to the database on stable storage and thus records after the waypoint are not needed for recovery to a consistent database. When there is a failover of an active database on Node A to a passive database on Node B, log records are compared starting with the most current and moving backwards and the point at which divergence in the log occurs is determined. When the lost portion of the log occurs after the point indicated by after the waypoint, the database is recoverable by log-based incremental reseed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08768890&OS=08768890&RS=08768890
owner: Microsoft Corporation
number: 08768890
owner_city: Redmond
owner_country: US
publication_date: 20070314
---
In databases ACID stands for Atomicity Consistency Committed Isolation and Durability. These features are considered to be among the key properties required of a database management system or DBMS because without them the integrity of the database cannot be guaranteed. In practice these properties are often relaxed somewhat to provide better performance. Within the context of database management a single logical operation on the data of the database is called a transaction. For example transferring funds from one account to another even though it consists of multiple individual operations such as debiting one account and crediting a second account is a single transaction because if just the debiting is performed or just the crediting is performed the database data will be inconsistent.

Atomicity refers to the ability of the DBMS to guarantee that either all of the tasks of a transaction are performed or that none of the tasks are performed. To continue the example above the transfer of funds can be completed or it can fail but atomicity guarantees that the first account will not be debited if the second account is not credited and vice versa.

Consistency ensures that the database is in a legal state when a transaction begins and ends. A transaction is not allowed to violate the integrity constraints of the database. For example if an integrity constraint or rule states that all accounts must have a positive balance then any transaction that takes the balance to a negative number violates this rule and is aborted. When a transaction is aborted it is rolled back that is a rollback operation undoes all the work performed in the transaction and the database is returned to the consistent state it was in before rollback was performed. A commit operation is the opposite of a rollback . A commit operation generally makes a set of tentative changes permanent. In SQL for example a transaction begins with a BEGIN statement includes one or more SQL statements and ends with a COMMIT statement. The COMMIT statement makes the changes made by the transaction visible to other users and releases or updates any checkpoints that were saved. In contrast the ROLLBACK statement undoes all the work performed since the BEGIN statement was issued.

Isolation refers to the ability of an application to make operations in a transaction appear isolated from all other operations. The isolation property is the most often relaxed ACID property in a DBMS because to maintain the highest level of isolation a DBMS must acquire locks on data which may result in a loss of concurrency or cause performance problems.

Durability refers to the guarantee that once a user has been notified of success the transaction will persist and will not be undone it will survive system failure and the database system has checked the integrity constraints and will not abort and roll back the transaction. Typically all transactions are written into a log that can be played back to recreate the system to a state some time before the failure. A transaction is usually considered committed after it has been written to the log thus when a database is recovered it is typically recovered back to the last most recent committed transaction. This ACID property is occasionally relaxed on databases with lazy commit whereby the committed data may not be immediately written to the transaction log.

Logging in the database context refers to the practice of saving a copy of transactions applied to a database so that in the event that the program or system crashes the transactions can be reapplied to the database to ensure consistent data. Logging can also be used in the event that the active database is no longer available or has become corrupted to reapply transactions to a backup copy of the database to return the database to its pre failure state or to some approximation thereof. Write ahead logging WAL refers generally to techniques for providing atomicity and durability in database systems. In a system that uses WAL all modifications or compensating undo data are written to a log before they are applied to the database. WAL allows updates of the database to be done in place which is generally considered preferable to the alternative copy on write.

Shadow paging is not in place updating. A page in the context of shadow paging refers to a unit of physical storage typically on a hard disk of the order of 210 to 215 bytes. Shadow paging is a copy on write technique that avoids in place updates of pages. Instead when a page is to be modified a shadow page is allocated. Since the shadow page has no references from other pages on disk it can be modified without worrying about consistency constraints etc. When the page is ready to be persisted all the pages that referred to the original page are updated to refer to the new replacement page instead. Because the replacement page is activated only when it is ready it is atomic. If the pages that referred to the original page are also updated via shadow paging this procedure may recurse many times becoming quite costly in terms of performance. Shadow paging is not germane to this discussion.

A continuous set of committed transactions that have been applied to database pages stored in a database cache in memory can be lost without destroying the integrity maintaining the Atomic Isolated and Consistent portions of ACID ity of the database by deferring the writing of the database pages stored in cache to the database on stable storage. In addition to tracking a checkpoint indicating a point in the log at which a database recovery operation should be initiated a waypoint tracks a point in the transaction log following which no portion of the transactions have been applied to the database on stable storage. Thus the waypoint represents the last log file or the last log record within a log file that is actually needed for recovery to a consistent database. Further the waypoint represents the last log file or the last log record within a log file that is actually needed before using a log based incremental reseed as described herein to fix divergence between two nodes in a log shipping based replication system. This is because after the point indicated by the waypoint no modifications have been written to the database and therefore the databases do not diverge only the logs diverge. The log based incremental reseed ensures that the logs that should be kept are kept and the logs that should be discarded are discarded.

When there is a failover of an active database on Node A to a passive database on Node B the passive database becomes the active database. When all of the records in the transaction log that existed on Node A are not available to Node B there will be some data lost because the passive database is not completely up to date and cannot be made up to date because of the lost log data. This is called a lossy failover. Log records are compared starting with the most current and moving backwards and the point at which divergence in the log occurs is determined. When the lost portion of the log occurs after the point indicated by the waypoint log based incremental reseed is allowed as described herein. The recovery process is very quick because it involves copying sequential log files rather than randomly accessed database pages but some loss of committed transactions is likely to occur. Thus the durability feature of the database ACID properties is sacrificed in order to simplify and speed up recovery of replication.

WAL Write Ahead Logging allows for an updated page to be written back to the location in which it was read in place updating and is meant to guarantee that the log records representing the changes or at least log records representing the ability to compensate or undo changes are persisted to stable storage before the in place updating is performed on the database. The transaction log can be thought of as a series of database page updates and provides a way to recover the database in the event of a program crash or other system outage event such as power outage kernel panic or blue screen . When a log record for an update to a database page is persisted to stable storage a reference to the database page the log record acts upon and often a logical time sequence stamp of the page is added to the log record. Then if the database crashes theoretically the database can be returned to a consistent state by reading the log records persisted to stable storage and checking to see if the update was made by loading the indicated database page and comparing the record data or database page metadata to the log record data or sometimes by comparing a timestamp in the log record with a timestamp on the database page . If the update was made the next log record is read. If the update was not made the change indicated in the log record is reapplied and the next log record is read. This process is sometimes called recovery. Recovery is complete when all the records in the log file persisted to stable storage have been checked against the database file updates reapplied if necessary and any operations performed by unfinished i.e. uncommitted transactions have been undone or backed out. Thus after recovery theoretically the database will be in a consistent state and will be up to date with the last committed transaction written. In order for recovery to work the database must be in the correct physical state to begin with. Similarly replaying incorrect log files may corrupt a database. Finally if too many log records are lost perhaps because the database is operating on the premise that all committed transactions have been persisted on stable storage and that is not true the recovered database may be corrupt or the database may be unrecoverable. For example if any log records are lost committed transactions may or may not be lost. If a log record relating to an update to a database page that has been persisted is lost the database may be corrupt as the Atomicity and Consistency requirements of ACID transactions may have been broken.

Many hard drives including IDE based drives cache IOs input output operations such as disk writes typically for performance reasons . Some of these types of drives support use of a Forced Unit Access flag so that use of the disk write cache can be avoided. Others do not have this feature and use of the disk write cache cannot be avoided. When a database system is run on a drive without the Forced Unit Access flag feature or on one that does not have the avoidance feature activated the database update software may issue an IO to for example write this log record to stable storage and continue processing such as writing a database page to persisted storage with that previously written logged data assuming that the log record has actually been written to stable storage when actually the log record may have only been written into the disk write cache and has not actually been written to stable storage. If a power outage or other event prevents the disk write cache from being written to stable storage the log record the software thought was safely persisted to stable storage is gone. As it is impossible to know when this type of hard drive actually persists the cached operations to stable storage it is impossible to guarantee recoverability because some of the log records required to return the database to a consistent state may be gone.

It is also impossible to guarantee database consistency when drives that cache disk writes and do not have the Forced Unit Access flag feature or do not have it activated are used for database operations on databases that rely on the premise that any completed write IO is guaranteed to be persisted to stable storage. Most modern databases rely on this premise because then the database engine can issue subsequent write IOs write operation requests knowing that the data in the previously completed IO has been applied to the persisted database. The problem arises because some drives that cache IOs consider the write IO to be completed when the data makes its way into the disk write cache not when the disk write operation has actually written the data to stable storage. That is the disk drive does not support direct access to stable storage media. This allows the database engine to issue subsequent IOs that can corrupt the database. To understand how this can happen consider one possible scenario. Suppose for example that a transaction that applies a series of updates to databases pages 1 and 15 is received. Database pages 1 and 15 are loaded into the database cache and the log records for the transaction including a reference to the database pages they affect are written into the log buffer in volatile storage. The updates are applied to the database pages in the database cache. When the COMMIT record is encountered signaling that the last update belonging to the transaction has been reached the commit processing is performed. If the commit processing completes successfully a disk write IO is issued to write the log records for this series of updates from the log buffer to stable storage. Any time thereafter the updated database pages can be written to stable storage. Suppose updated database page 15 is written to stable storage. Now suppose a power outage is experienced and the log records representing the transaction were only in hard drive cache and never actually made it to stable storage while database page 15 did make it to stable storage. This would in effect lose part the transaction relating to page 1 destroying the atomicity of the transaction and making the database inconsistent.

To address these problems in accordance with embodiments of the invention write operations for database pages stored in the database cache are not issued for some specified period of time or until some specified number of IO bytes have been written. In other embodiments of the invention disk writes for log records are tracked and IOs for database pages stored in the database cache are not issued until a certain number of disk writes for log records have been issued. In other embodiments of the invention the transaction log is segmented into generations of log files and write IOs to write database pages stored in the database cache to stable storage are not issued until a specified number of generations of log files between the log tip the end of the log where incoming log records are added and the log record corresponding to the database page update exist. In each embodiment writing of database pages to stable storage is deferred according to some policy that is not or is not solely based on whether or not transactions are committed. This allows a set of committed transactions to be lost without destroying the integrity or consistency of the database even when the disk type used by the database system does not guarantee direct access to persistent storage. That is a lose able section of the log exists where log records in the lose able section of the log can be lost and yet recovery to a consistent database can occur. In addition to tracking a checkpoint indicating a point in the log at which a database recovery operation should be initiated a waypoint is tracked. The waypoint is a point in the transaction log following which corresponding updates to the database have not been applied to the database on stable storage. That is the waypoint indicates a point after which log records can be lost and yet recovery to a consistent database can occur maintaining all the elements of an ACID transactional system except Durability. In some embodiments of the invention similar logic is applied to checkpoint processing. For example losing page writes flushes performed as a result of checkpoint maintenance can adversely affect the database because the page writes may not have actually made it to stable storage e.g. to disk . In some embodiments of the invention a first traditional checkpoint is used to drive database IO to persistent storage and a second further deferred or delayed checkpoint is used to track where to begin recovery in the event of a system crash. Any of a number of policies can be used to determine the delay as described above.

Replicating a database by making a copy of it and then applying the logged transactions to the database copy is called log shipping. When the database copy is initially set up a seeding is typically done by copying over the original database from the active node Node A to the passive node Node B and then beginning to copy the transaction logs continuously and incrementally from Node A to Node B. If Node A fails Node B becomes the active node. Because there is some delay in the process of copying transactions logs and applying them Node B is likely to be somewhat out of date. The two databases are said to be divergent. That is not all of the last updates applied to the database on Node A would be expected to have been made it over onto Node B s database so that the database on Node A right before it crashed is not likely to be exactly the same as the database on Node B. Replication can be re established by copying over Node B s database back onto Node A. This is called a reseed or full reseed and is likely to be an expensive operation if the database is large as it involves copying the entire database. A number of optimizations for re establishing replication without copying the entire database are known. For example only a subset of the database would have to be copied over if the blocks in the database that changed after a lossy failover could be identified. This is called traditional incremental reseed but known methods of traditional incremental reseed require the data in the database to be examined. Embodiments of the invention present a way to perform a new type of incremental reseed without analyzing the database data for divergent blocks. Instead an incremental reseed in accordance with embodiments of the invention is based on a comparison of transaction logs rather than by comparison of database data and by tracking state e.g. the waypoint stored in the database headers. Examining the transaction logs and database headers will incur significantly less random IO than traditional incremental reseed.

Embodiments of the invention can be implemented via an application programming interface API for use by a developer and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory . GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard embodiments of the invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Embodiments of the invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. Embodiments of the invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

A continuous set of committed transactions that have been applied to database pages stored in a database cache in memory can be lost without destroying the integrity of the database by deferring the writing of the database pages stored in cache to the database on stable storage in accordance with a specified value representing a waypoint. In some embodiments of the invention the transaction log is segmented into chunks of a specifiable size. A current log file is allocated and incoming transactions are logged by adding the log record for the transaction to the tail end or log tip of the current log file. When the current log file reaches the specified size the current log file is renamed to a sequentially numbered log file. A new current log file is then allocated and the process repeats. When the new current log file reaches the specified size the new current log file is renamed to an incremented sequentially numbered log file. This series of incremented sequentially numbered log files are called log file generations. In the example presented above two generations of log files have been created. The database writes to stable storage may be delayed until a specified number of log file generations have been written to the log on stable storage. The specified number of log file generations that must exist before the updated database page s corresponding to the log record is flushed to disk may be referred to as having a waypoint depth of X . In some embodiments of the invention the log may be a continuous file where the waypoint and checkpoints are references to a point in the file. Alternatively instead of basing a waypoint on a number of required log file generations a waypoint may be set based on some specified period of time that must elapse from issuance of a disk write I O for a log record or based on some specified number of disk write IO bytes that must be written to a disk write cache before corresponding disk writes for database pages are issued. A waypoint is not restricted to occurring on a log file boundary it may point to a record within a log file. A waypoint may be implemented as an offset from the end of the current log file. For example a waypoint may be specified as a rounded up number of generations of log files from the tail end of a current log file. The waypoint is tracked in addition to tracking a checkpoint indicating a point in the log at which a database recovery operation should be initiated. The waypoint thus represents a point in the transaction log following which all portions of the transactions have not been applied to the database on stable storage and therefore represents the last log file or record within a log file that is actually needed for recovery of a consistent database. In some embodiments of the invention the current waypoint is stored in the header of the database and is incremented whenever a new log file is written whenever a new log file generation is created. 

When log shipping is implemented and there is a failover of an active database on Node A to a passive database on Node B the passive database becomes the active database. When all of the log files that existed on Node A are not on Node B there is a lossy failover of the active database to the passive database but the database on Node B is consistent. That is although some of the updates applied to the Node A database will not have been applied to the database or log on Node B those that have been applied to the database on Node B have left it in a consistent state by virtue of the Atomicity property of database transactional processing. A current log is started on Node B for the now active database on Node B. Suppose for example that four generations of complete log files existed on Node A when it failed. Only three generations of log files may have been received by Node B. Hence when Node B starts a current log it is starting its fourth generation log file. Thus log generation numbers already used on Node A are used on Node B but the content of these same numbered generations of log files on the two nodes are not the same. Because transactions in log files on Node A have been applied to the database on Node A and have not been applied to the database on Node B the content of the database on Node A is not the same as the contents of the database on Node B. Traditionally a full reseed of the database on Node A copy the entire database from Node B to Node A would now be done to bring the divergent databases back into the same state. Alternatively and as is known the database pages referenced in the logs not applied to Node B could be compared in the database on Node A to those on Node B and if divergent Node A could request Node B for the affected database pages and replace the affected database pages on Node A with the corresponding pages from the database on Node B. This is a traditional incremental reseed. In accordance with embodiments of the invention the existing post waypoint log files on Node A are deleted and the post waypoint log files are copied from Node B to Node A. At this point normal log shipping resumes. That is in accordance with embodiments of the invention a log based incremental reseed is performed by copying log files instead of by copying database pages and is based on the comparison of log files instead of by examination of database pages. Alternatively in accordance with other embodiments of the invention on a database system with perfect UNDO characteristics whereby recovery can be run in reverse to produce a previous version of the database this invention method could be extended to fixing divergence occurring in pre waypoint log files. In such an implementation the pre waypoint log files could be undone or backed out of the database and then any divergent log files are copied from Node B to Node A to execute the incremental reseed and allow normal log shipping to resume. Great economies can be realized using log based incremental reseeding because log files are simple sequential files and just a few log files will need to be copied. Thus log files can selectively be replayed on the active database. A point at which divergence in the log files occurs is found by comparing log files starting from the most recent log file and working backwards. If divergence in the log files occurs after the waypoint the databases are not divergent and the log based incremental reseed is required only to correct divergence in the transaction logs of Node A and Node B. If the new active database has replicated logs up to the waypoint the initially active database can perform a fast incremental reseed based on the logs instead of based on a comparison of the databases. In an alternative implementation such could be accomplished by working on segments of the transaction log rather than full generation based log files. In a database that does not maintain complete UNDO information if the point of divergence in the log files occurs before the waypoint some form of traditional reseed is needed.

The database page or pages of database to be updated by the transaction are loaded into volatile storage database cache . Logging is performed after the database page is modified in volatile storage and before the database page is persisted to stable storage back to database . In accordance with some embodiments of the invention a log record may be generated from each of the update records in the transaction and may include one or more of the following pieces of information a session number timestamp page number page offset one or more length indicators and data as well as other information. A sample set of log records may look like the ones illustrated in in which the first update record is

The type of operation for this update record is BEGIN that is this record signals the beginning of a group of updates that comprise a transaction. The session number is 8. The session number ties the different log records of the transaction together. For example the log records beginning 27224 9 and 27225 5 are from different sessions and thus from different transactions specifically log record 27224 is from session 9 and log record 27225 is from session 5. The second update record of this transaction is a REPLACE operation having the timestamp of 27223 a page reference of 1477 and page offset of 6 in the format page page offset 3 length indicators 8 8 8 and binary data 01 00 00 00 70 03 00 00 and so on. The COMMIT record signals the end of transaction of session 8. Thus log records include transactional information such as begin and commit and provide a record of physical modifications to the database. In some embodiments of the invention only post images are logged to reduce the size of log files. As described above one logical operation may result in a number of physical modifications of the database. Operations performed by different transactions may be interleaved in some implementations that is any log file can include log records of different transactions mixed together.

In some embodiments of the invention a log e.g. log is broken up into smaller segments as described above and is assigned a generation number typically though not necessarily starting with generation one. illustrates such a log. In . a log is divided into segments comprising files E00001.log E00002.log E00003.log E00004.log E00005.log and current log E00.log . Space may be allocated in volatile storage for the current log file e.g. E00.log and new transactions coming in may be written into the E00.log current log. New transactions are added to the tail end of the file. The point at which new transactions are added to the current log is called the tip of the log or logtip e.g. logtip . When the allocated space is filled up E00.log is full the current log file is renamed and is assigned a generation number. For example in when E00.log is full it will be renamed to E00006.log because logically it is the log after E00005.log . A new E00.log is created and subsequent future transactions are written into current log E00.log. When E00.log fills up again E00.log is renamed to the next generation log file E00007.log not shown and so on.

When the COMMIT record is encountered signaling that the last update belonging to the transaction has been reached the commit processing is performed. In traditional commit processing as known in the art if the commit processing completes successfully a disk write IO is issued to write the log records for this series of updates from the log buffer to stable storage and as described above in known systems any time after the disk write IO is completed the updated database pages can be written to stable storage. In contrast in accordance with some embodiments of the invention any updates relating to log records in log files after the waypoint e.g. E00005.log and E00.log in are guaranteed not to have been persisted to the database on stable storage. Any particular record in the log thus will not be flushed to the database until the log record has moved past the waypoint going from right to left e.g. in that means the database page corresponding to the log record will not be flushed until the log record is somewhere in E00001.log E00002.log E00003.log or E00004.log . Hence any log records to the right of the waypoint can be lost without causing database inconsistency during recovery although some committed transactions may be lost. Logs may be lost for many reasons including but not limited to the following the CHKDSK utility may erase a log because it detects data corruption an anti virus program may erase a log thinking it is a virus human error an administrator or other user may erase a log in error or log or logs may be lost because of the disk write cache problem described above.

Referring to again all the committed log records in log files E00001.log and E00002.log prior to checkpoint have been persisted to the log on stable storage and the database pages that these transactions have affected have been persisted to the database on stable storage as evidenced by the location of checkpoint . A committed transaction is one for which the COMMIT record of the transaction has been flushed to the log. In other implementations instead of acting in whole log files merely a reference to a point in the log stream is used. Thus log files E00001.log and E00002.log are not needed for recovery because all of the records in these files have been persisted to the log on stable storage flushed log in have been used to update the database cache updated db cache in and the updated database pages have been flushed to persistent storage flushed pages in . All of the log records in log files E00003.log and E00004.log between checkpoint and waypoint have been persisted to the log on stable storage flushed log have been used to update the database cache and some of the updated database pages have been flushed to persistent storage denoted by maybe flushed page in . All of the log records in log files E00005.log and in the current log E00.log have been flushed to the log and correspond to transactions that have updated the database cache but the updated database pages in cache have not been flushed to the database on persistent storage. The updates not yet added to the log are referred to as not committed future or lazy transactions. This means that E00001.log and E00002.log can be lost because these transactions have already been applied to the database on stable storage and E00005.log and E00.log can be lost because none of the database pages that these transactions have affected have been persisted to the database on stable storage. The only log files that would be needed to successfully run recovery for whatever reason in this scenario are E00003.log and E00004.log . It will be appreciated that although shows two generations of log files between the checkpoint and the waypoint and one complete log file between the waypoint and the logtip in implementations where a single transaction log file is maintained similar functionality is obtained by specifying segments of the transaction log as being under such behavior control. It will be appreciated that although shows two generations of log files between the checkpoint and the waypoint and one complete log file between the waypoint and the logtip any number of log file generations may be maintained between the checkpoint and the waypoint and between the waypoint and the logtip as specified by the waypoint. For example a certain amount of time may be specified to elapse before updated database pages are persisted to stable storage or a certain number of disk writes for log files may be specified as required to be written before updated database pages are persisted to stable storage. A specified number of generations of log files to the right of the waypoint as illustrated in may be required to exist before corresponding database pages are allowed to be flushed.

In accordance with embodiments of the invention when there is a lossy failover of the active database to the passive database the passive database becomes the active database. If the new active database has replicated logs up to the waypoint to the left of the waypoint as illustrated in the initially active database can perform a fast incremental reseed based only upon copying back the logs following the waypoint to the right of the waypoint as illustrated in from the new active database.

Referring again to suppose that Node A fails and a lossy failover to Node B is performed. Suppose further that at the time of Node A s failure the state of the database and log is as represented in . Given these circumstances the copy of the database and log of Node B can be in one of the following states 

the database or log on Node B can be replicated to a point after the checkpoint but preceding the waypoint 

If the database or log on Node B has been replicated to some point following the waypoint a fast log based incremental reseed according to embodiments of the invention can only be performed by removing log files E00005.log and E00.log because Node A would not have applied any portion of the transactions in the log files after the waypoint and Node B would not have all of those log files. If Node B has replicated only through E00003.log to its log a fast log based incremental reseed according to embodiments of the invention can not be performed. For example suppose the database on Node B has been replicated through E00003.log but not through E00004.log . When Node B becomes active it would start generating a new log generation that would differ from E00004.log so that if Node B merely shipped back the new E00004.log generated on Node B the state of database would be inconsistent because of the portion of E00004.log transactions persisted to stable storage as explained above. Because a portion of E00004.log may have been applied to database persisted to stable storage on Node A and because Node B would not have E00004.log to accept a new version of log E00004.log created on Node B would result in two different sets of transaction logging being applied to Node A s database and thus would result in database corruption.

Database divergence refers to a condition in which the content of the database and the content of the copy of the database are different. A log file divergence refers to a condition in which the contents of log file generation X on the active node differs from the contents of the same generation log file log file generation X on the passive node. Divergence in database or in log files can be caused by a lossy failover by a split brain operation on a cluster because even if clients cannot connect to the database background maintenance still modifies the database by administrator error by for example running recovery incorrectly . In some embodiments of the invention the replication service detects divergence. Divergence is detected by comparing the last log file on the currently passive node copy to the same generation log file on the currently active node.

If the database on Node B has been replicated to the waypoint through E00004.log a fast log based incremental reseed could be performed because doing so would result in a consistent database although some committed transactions are likely to have been lost. For example suppose the database on Node B has been replicated through E00004.log when Node A fails. Node B becomes the active node and Node A becomes the passive node. Database copy becomes the active database and database becomes the database copy. Now passive Node A detects when coming up that it has lost the active role and asks now active Node B for the state of the logs. By comparing the log files of Node A to the log files of Node B no database comparison is needed it is determined that Node A can perform the fast incremental reseed by removing the log files following the waypoint E00005.log and the current log on Node A and copying the logs following the waypoint on now active Node B E00005.log and the current log from now active Node B to now passive Node A before Node A starts the regular log shipping recovery process. It will be appreciated that E00005.log and the current log on Node B contain different data from that in E00005.log and the current log on Node A.

If the database on Node B has been replicated past the waypoint by one or more complete log files a fast log based incremental reseed can be performed because doing so results in a consistent database although some committed transactions may have been lost. For example suppose the database on Node B has been replicated through E00005.log when Node A fails. Node B becomes the active node Node A becomes the passive node database copy becomes the active database and database becomes the database copy. Now passive Node A detects when coming up that it has lost the active role and asks now active Node B for the state of the logs . By comparing the log files of Node A to the log files of Node B no database comparison is needed it is determined that Node A can perform the fast incremental reseed by removing the log files past the waypoint that have diverged i.e. the current log E00.log and copying the logs following this point on now active Node B log E00005.log or the current log if E00005.log does not exist from now active Node B to now passive Node A before Node A starts the regular log shipping recovery process.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of embodiments of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects of embodiments of the invention e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While embodiments of the invention have been described in connection with the figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same functions without deviating there from. Therefore the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

