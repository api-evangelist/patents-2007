---

title: Java stack machine execution kernel dynamic instrumentation
abstract: A method and system for performing dynamic instrumentation. At least some of the illustrative embodiments are methods comprising setting at least one monitor value (wherein the at least one monitor value is associated with a software monitoring handler), detecting a value within a register equal to the at least one monitor value, and executing the software monitoring handler based on the detecting.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08806459&OS=08806459&RS=08806459
owner: Texas Instruments Incorporated
number: 08806459
owner_city: Dallas
owner_country: US
publication_date: 20071213
---
The present application claims priority to EP Application No. 07291170.4 filed on Sep. 28 2007 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation based on a plurality bytecodes that define specific tasks. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly.

Many times a processor that directly executes Java bytecodes is paired with a general purpose processor so as to accelerate Java program execution in a general or special purpose machine. It would be advantageous to provide accelerations similar to those seen for directly executed Java bytecodes in other languages and development environments.

Also it is often useful to monitor the execution of a software application for a variety of purposes such as Dynamic Adaptive Compilation DAC hotspot detection memory profiling or to determine how often certain pieces of code are executed. Such application monitoring may be implemented by instrumentation of the software application code. Various implementations of code instrumentation result in code expansion and may call for changes in a Java platform used to execute the Java bytecodes. Thus it would be desirable to provide more efficient code instrumentation that is not subject to code expansion and or other drawbacks resulting from modification of the Java platform.

The problems noted above are solved in large part by a method and system for performing dynamic instrumentation. At least some of the illustrative embodiments are methods comprising setting at least one monitor value wherein the at least one monitor value is associated with a software monitoring handler detecting a value within a register equal to the at least one monitor value and executing the software monitoring handler based on the detecting.

Other illustrative embodiments are processors comprising fetch logic that retrieves instructions from memory decode logic coupled to the fetch logic and an active program counter comprising a value. The processor monitors the active program counter value during execution of an application and when the active program counter value reaches a predetermined value the processor executes a software monitoring handler.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure including the claims unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

The subject matter disclosed herein is directed to a programmable electronic device such as a processor. The processor described herein may be particularly suited for executing Java Bytecodes or comparable code. Java is particularly suited for embedded applications and is a relatively dense language meaning that on average each instruction may perform a large number of functions compared to various other programming languages. The dense nature of Java is of particular benefit for portable battery operated devices. The reason however for executing Java code is not material to this disclosure or the claims that follow. Further the various embodiments may be described in the context of Java but should not be limited to the execution of only Java instructions. The processor described herein may be used in a wide variety of electronic systems e.g. cell phones .

Optional processor may be referred to as a Micro Processor Unit MPU . System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise an Application Programming Interface implementation API and a Java Virtual Processor JVP discussed more below . The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

The MPU also may execute non Java instructions. For example the MPU may host an operating system O S which performs various functions such as system memory management system task management and most or all other native tasks running on the system management of the display and receiving input from input devices. Java code executed on the JVP may be used to perform any one of a variety of applications such as multimedia games or web based applications in the system while non Java code which may comprise the O S and other native applications may run on the MPU .

Most Java bytecodes perform stack based operations. For example an IADD integer add Java opcode pops two integers off the top of the stack adds them together and pushes the sum back on the stack. A simple opcode is one in which the JSM may perform an immediate operation either in a single cycle e.g. an IADD opcode or in several cycles e.g. DUP2 X2 . A complex opcode is one in which several memory accesses within the JVM or JEK data structure for various verifications e.g. NULL pointer array boundaries are made.

The JSM processor in accordance with some embodiments may execute in addition to the Java bytecodes a second instruction set other than Java bytecodes. In some exemplary embodiments the second instruction set may comprise register based and memory based operations rather than stack based operations. This second instruction set complements the Java instruction set and accordingly may be referred to as a complementary instruction set architecture C ISA . By complementary it is meant that some complex Java bytecodes may be replaced by a micro sequence comprising C ISA instructions. The execution of Java code may thus be made more efficient and run faster by replacing some opcodes by more efficient micro sequences of C ISA instructions. The JSM thus comprises a stack based architecture for direct execution of Java bytecodes combined with a register based architecture for direct execution of memory based micro sequences of C ISA instructions. Because various data structures may be JVM dependent and thus may change from one JVM implementation to another the software flexibility of the micro sequence provides a mechanism for various JVM optimizations now known or later developed.

As discussed above the JVP provides a layer of abstraction. In particular the JVP is a virtual hardware platform that is compatible with any Java API any real hardware software platform that may comprise a JSM processor or any JVM implementation. In some exemplary embodiments the JVP comprises a JEK core that has an execution engine a memory management component and a compiler. The execution engine may comprise a Bytecode engine a class loader a notification manager and an external method interface. The memory management component may comprise a memory allocator an object mapper for physically constrained objects a garbage collector a memory defragmentor and a swapper. The compiler may comprise a dynamic compiler and provide code buffer management. The JEK core may also comprise firmware to facilitate the execution of Java Bytecodes on the JSM processor.

In embodiments of the present invention some C ISA instructions micro sequences may comprise software monitoring handlers useful for monitoring of software applications via code instrumentation discussed below . In such cases Java bytecodes may not be replaced as described above but may instead have their execution suspended while a software monitoring handler is executed. As discussed further below code instrumentation utilizing software monitoring handlers executes faster and more efficiently than other approaches to code instrumentation in the related art.

The JVP also provides the API with methods to create software class loaders. A class loader loads classes used by an application at runtime. Other hardware components of the hardware platform or software components are virtualized within the JEK as Java Virtual Devices JVD that communicate with the JEK core. Each JVD comprises some combination of fields methods and notifications. The fields may comprise standard Java fields or may be mapped to a predefined or constrained physical memory space wherein the constraint may be due to hardware or software. The fields may also comprise a map to indirect memories. The methods may comprise standard bytecodes or may comprises JSM native code hardware instructions or may use any kind of native interface such as a Java Native Interface JNI or a KVM Native Interface KNI . The notifications may be initiated by an event for example a hardware interrupt or from software. Additionally the JEK core manages native interface links and the notification mechanism provides a way to implement flexible monitoring.

Java bytecodes may pop data from and push data onto the micro stack which micro stack comprises a plurality of gates in the core of the JSM . The micro stack comprises the top x entries of a larger stack that is implemented in data storage . Although the value of x may be vary in different embodiments in accordance with at least some embodiments the size x of the micro stack may be the top eight entries in the larger memory based stack. By implementing the micro stack hardware in the core of the processor access to the data contained in the micro stack is very fast although any particular access speed is not a limitation on this disclosure.

ALU adds subtracts and shifts data. The multiplier may be used to multiply two values together in one or more cycles. The instruction fetch logic fetches instructions from instruction storage which instructions may be decoded by decode logic . Because the JSM is configured to process instructions from at least two instruction sets the decode logic comprises at least two modes of operation one mode for each instruction set. As such the decode logic unit may comprise a Java mode in which Java bytecodes may be decoded and a C ISA mode in which micro sequences of C ISA instructions may be decoded.

The data storage comprises data cache D cache and data random access memory D RAM . The stack excluding the micro stack arrays and non critical data may be stored in the D cache while local variables and data may be stored in D RAM . The instruction storage may comprise instruction RAM I RAM and instruction cache I Cache . The I RAM may be used for opcodes or micro sequences and the I Cache may be used to store other types of Java bytecode and mixed Java C ISA instructions.

Referring now to the registers of may comprise a plurality of registers designated as R R. Registers R R R R R and R R may be used as general purposes GP registers for any purpose. Other registers and some of the GP registers may be used for specific purposes. For example registers R and R may each be used to store program counters with R storing a program counter PC for a stream of bytecodes and R storing a micro program counter micro PC for executing micro sequences. In addition to use as a GP register register R may be used to store the base address of a portion of memory in which Java local variables may be stored when used by a Java method. The top of the micro stack can be referenced by the values in registers R and R and the top of the micro stack may have a matching address in external memory pointed to by register R. The values contained in the micro stack are the latest updated values while their corresponding values in external memory may or may not be up to date. Register R provides the data value stored at the top of the micro stack. Registers R and R may also be used to hold the address index AI and address index AI . Register R may also be used to hold the indirect register index IRI . Register R may be used for status and control of the JSM . At least one bit called the Micro Sequence Active bit not specifically shown in status register R is used to indicate whether the JSM is executing by way of a micro sequence. This bit controls in particular which program counter is used R PC or R micro PC to fetch the next instruction.

In accordance with some exemplary embodiments it may be useful to monitor the execution of an application for a variety of purposes such as Dynamic Adaptive Compilation DAC hotspot detection memory profiling or to determine how often certain pieces of code are executed. Monitoring of the application may be implemented by instrumentation of the application code. Various approaches to code instrumentation in the related art result in code expansion and may call for changes to the JVM. Some examples from the related art include code rewriting and relocation creating a full JVM instrumented interpretation loop which calls for two interpreters or creating an instrumented version of the original code and executing it by modifying the JVM interpretation loop.

As previously described the JSM implements two program counters the PC register R and the micro PC register R . In accordance with some embodiments only one of these two program counters is an active program counter used to fetch and decode instructions at any one time. Further the active program counter may be used to trigger the software monitoring handlers. In particular when the PC stored in register R is the active program counter and a PC value equal to a monitor value is encountered the associated software monitoring handler comprising a micro sequence is executed. In some embodiments other registers having other values such as registers R R as illustrated in e.g. micro program counter register general purpose registers etc. may be used to trigger the software monitoring handlers to enable other kinds of code monitoring.

By way of example and for the purposes of this disclosure the monitor value at a location indicated by arrow may be referred to as the monitor value . Thus as shown in the monitor value is associated with the software monitoring handler the monitor value is associated with the software monitoring handler and the monitor value is associated with the software monitoring handler . As previously discussed the JEK uses the JSM hardware instruction to associate the monitor values to the software monitoring handlers in order to instrument the original code . During code execution each time the JSM reaches a monitor value the JSM executes the corresponding JEK software monitoring handler. For example when the application code executing in a direction indicated by arrow reaches the monitor value i.e. a PC value stored in register R equal to the monitor value is detected execution of the original code is temporarily suspended while the software monitoring handler is executed as indicated by arrow . After execution of the software monitoring handler execution of the original code resumes at the same PC value where execution was previously suspended as indicated by arrow . In some embodiments an instruction corresponding to the detected PC value stored in register R may be executed prior to execution of the software monitoring handler. In such a case execution of the original code may resume at a PC value immediately following the detected PC value that triggered execution of the software monitoring handler.

Each monitor value corresponds to a specific PC value and is associated with a specific software monitoring handler. The associations between the monitor values and the software monitoring handlers may be managed by a table such as shown in . The table may be implemented in the decode logic as separate logic in the JSM or as software within the JEK . Furthermore in some embodiments the JEK may dynamically overwrite associations stored in the table with new associations thus allowing any of the available software monitoring handlers to be triggered by any monitor value and thus by any PC value that is encountered. The table comprises a plurality of entries . The entries may comprise one entry for each monitor value. For example if there are a total of 10 monitor values the table comprises at least 10 entries. Each entry comprises at least two fields a field and an associated field . Field may comprise a monitor value corresponding to a specific PC value and the associated field may contain a reference to a micro sequence for a particular software monitoring handler that is triggered upon detection of a PC value equal to the monitor value.

The associated field may comprise a full starting address in instruction storage of the micro sequence or a part of the starting address that can be concatenated with a base address that may be programmable in the JSM. In the former case the associated field may provide sufficient address bits to access the full memory space. In the latter case a register within the JSM registers or within a JSM configuration register accessible through an indirect addressing mechanism using the IRI register is programmed to hold the base address and the associated field may supply only the offset to access the start of the micro sequence. Additionally the JSM internal registers and any other registers accessible by the JVP or the MPU may be modified by the JVM. This latter addressing technique may be used to reduce the number of bits needed within the associated field .

The software monitoring handlers may be triggered by a PC value when the PC stored in register R is the active PC and when the PC value is equal to a monitor value as defined in the table as discussed above . The micro program counter register R temporarily becomes the active program counter instead of the program counter during execution of the software monitoring handler. At this point the JSM begins fetching and decoding the instructions of the micro sequence. The switch from PC to the micro PC is effective immediately after a PC value equal to a monitor value is detected thereby reducing the latency. However in some embodiments the instruction corresponding to the detected PC value may execute prior to switching from the PC to the micro PC.

The software monitoring handler comprising the micro sequence may end with a predetermined instruction called RtuS return from micro sequence that indicates the end of the sequence. This C ISA instruction causes a switch from the micro PC register R to the PC register R upon completion of the micro sequence. Thereafter the PC points to the instruction at the PC value that previously triggered the software monitoring handler. In some embodiments the PC may have been incremented or offset by some predetermined value during execution of the micro sequence so that the PC may point to an alternative instruction for subsequent decoding.

The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

