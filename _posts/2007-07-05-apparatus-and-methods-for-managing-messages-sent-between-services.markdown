---

title: Apparatus and methods for managing messages sent between services
abstract: Disclosed are methods and apparatus for managing services within a computer network. In one embodiment, a message interchange network for exchanging application-level messages between services, which are located outside the message interchange network, is provided. At the message interchange network, a plurality of application-level messages, which each specify which one or more receiving services are to receive the each application-level message, are received. Each received application-level message is forward towards the one or more receiving services. Correlation information regarding each application-level message that is received into message interchange network is retained. The application-level messages are sent between pairs of the services, and the retained correlation information for each application-level message pertains to each application-level message and any other application-level messages related to the each application-level message. A query can then be received, at the message interchange network from a first service, to search the retained correlation information for specific one or more portions of the retained correlation information. A response to the query, which includes the specific one or more portions of the retained correlation information, is sent to the first service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09037726&OS=09037726&RS=09037726
owner: salesforce.com, inc.
number: 09037726
owner_city: San Francisco
owner_country: US
publication_date: 20070705
---
This application claims priority and is a continuation of U.S. application Ser. No. 10 728 356 filed 3 Dec. 2003 by Peter A. Panec et al. now U.S. Pat. No. 7 249 195 issued 24 Jul. 2007 which application is a continuation in part and claims priority of U.S. application Ser. No. 09 820 966 filed 30 Mar. 2001 by Lev Brouk et al. application Ser. No. 10 728 356 and application Ser. No. 09 820 966 are herein incorporated by reference in their entirety for all purposes.

The present invention relates to methods and apparatus for processing data within a computer network. More specifically it relates to correlating messages sent within such computer network.

Corporate reliance on technology has become more complex and more pervasive. Increasingly companies are identifying opportunities to extend their core business or cut costs using the Internet. Both trends have put increasing priority on integrating disparate business applications. For this reason enterprise application integration EAI has emerged as a solution for allowing information technology departments to build bridges that are designed to unify their legacy systems into a single enterprise application. Ideally the creation of this single enterprise application would not require sweeping changes to the underlying structures.

EAI suppliers typically offer end point solutions for managing business process interactions between end points within a computer network. Although a specific enterprise software package may be designed to transparently handle diverse business processes carried out by two or more end nodes each specific enterprise software package requires releasing customized connectors or adapters which will work for the specific business processes and applications used by the specific end nodes. As a result these enterprise solutions are not easily scalable. Additionally scores of adapters need to be built for each vendor for example Oracle corporation of Redwood Shores Calif. SAP AG of Waldorf Germany and PeopleSoft Inc. of Pleasanton Calif. . As each supplier releases new versions of their software EAI vendors find themselves unable to gain traction under the burden of supporting their existing adapters.

Notwithstanding the benefits of EAI the software costs and resource investments of EAI prevent small to medium enterprise SME customers from embracing EAI solutions. For SMEs reliance on application service providers ASPs represents an increasingly attractive alternative.

The web service provider market is one of the fastest growing segments of the software industry. Service providers make enterprise applications e.g. human resources administration recruiting travel and expense management sales force automation available to customers over the web at a server device. Those applications are fully managed and hosted by the provider providing significant cost savings to enterprises.

Some providers merely host and manage third party packaged software for their customers managed hosts . Others build new applications from the ground up to take advantage of the benefits and cost savings of web service provider model. Service providers enjoy the profit margins and operational scalability of consumer Web companies like eBay Inc. of San Jose Calif. and Yahoo Inc. of Sunnyvale Calif. while at the same time offering the feature sets of complex enterprise software applications such as software applications by PeopleSoft and Siebel Systems Inc. of San Mateo Calif.

Although the service provider approach allows a single business to set up a host server for allowing itself and its business partners to use third party or customs applications this approach does not allow the set up and dismantling of complex arrangements between business partners. For instance a first business may wish to allow a second business to access a first set of services while the second business may wish to provide a second different set of services to the first business.

Additionally message correlation in EAI or service provider approaches is nonexistent or cumbersome at best. In an end point based EAI each end point must first agree on message identifiers before sending messages between each so that the related message can be correlated. This process is time consuming and difficult to implement and coordinate among diverse end point users.

In view of the above improved mechanisms for correlating messages sent between diverse entities in a scalable manner are needed.

In one embodiment a method for correlating services within a computer network is disclosed. A message interchange network for exchanging application level messages between services which are located outside the message interchange network is provided. At the message interchange network a plurality of application level messages which each specify which one or more receiving services are to receive the each application level message are received. Each received application level message is forward towards the one or more receiving services. Correlation information regarding each application level message that is received into message interchange network is retained. The application level messages are sent between pairs of the services and the retained correlation information for each application level message pertains to each application level message and any other application level messages related to the each application level message. A query can then be received at the message interchange network from a first service to search the retained correlation information for specific one or more portions of the retained correlation information. A response to the query which includes the specific one or more portions of the retained correlation information is sent to the first service.

In a specific implementation each service is registered at the message interchange network so that each registered service is specified as being accessible by one or more specific services. In a specific aspect the retained correlation information for each application level message further includes an indication as to whether the each application level message has completed transmission. In yet another aspect the session information for each session includes a Session Identifier ID uniquely identifying the each session and the session information for each session further includes an indication as to whether the each session is complete and a reason for the session not being complete if the each session fails to complete. In an alternative embodiment the query for the retained correlation information is regarding a particular session or call and wherein the specific portions of the retained correlation information that are sent to the first service are related to the particular session or call of the query. In another aspect it is determined whether the first service is authorized to make the query and specific one or more portions of the retained correlation information are only sent to the first service when it is determined that the first service is authorized.

In another embodiment the invention pertains to a computer system operable to correlate services within a computer network. The computer system includes one or more processors and one or more memory. At least one of the memory and processors are adapted to provide at least some of the above described method operations. In yet a further embodiment the invention pertains to a computer program product for correlating services within a computer network. The computer program product has at least one computer readable medium and computer program instructions stored within at least one of the computer readable product configured to perform at least some of the above described method operations.

These and other features and advantages of the present invention will be presented in more detail in the following specification of the invention and the accompanying figures which illustrate by way of example the principles of the invention.

Reference will now be made in detail to a specific embodiment of the invention. An example of this embodiment is illustrated in the accompanying drawings. While the invention will be described in conjunction with this specific embodiment it will be understood that it is not intended to limit the invention to one embodiment. On the contrary it is intended to cover alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims. In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. The present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

In accordance with the present invention the interchange of enterprise data is supported through an open platform for enterprise application integration EAI . This open platform overlays a public network e.g. the Internet and does not require business entities to heavily invest in specialized software and resources. As will be described in greater detail below the present invention enables the provision of extra enterprise application integration as a service. This service facilitates EAI efficiently and affordably to the businesses that need it the most i.e. the small and medium sized enterprise SME market . More generally the open platform of the present invention can be used to support services provided by business to business B2B enablers system integrators and other node enablers.

A directory not shown includes a list of all SMEs webware ASPs and ITPs that can be accessed via Message Interchange Network . Only publicly available services i.e. those services that organizations register as accessible by any user of the network are viewable in the directory.

In general all applications that are connected to Message Interchange Network can be referred to as a service. In the illustrated embodiment of applications owned by SMEs webware ASPs and ITPs can each be referred to as services. Each service is owned by an organization and an organization can have any number of services connected to Message Interface Network . The message exchange within Message Interface Network is therefore between services.

In one embodiment services that receive messages can take a set of arguments that further define the intended action the service will perform on a received message. For example a service may receive the name of an operation or may permit configuration parameters. In this environment the service would provide a means e.g. through a URL to documentation for message composers to know about arguments accepted by the particular service. The message composer can then include selected arguments as a part of the service declaration in a message.

As described services registered with Message Interface Network represent applications that send or receive messages. An organization may however wish to create virtual services which act as proxies to other services. For example a business X may have a relationship with business Y such that messages sent to business X s service are redirected to business Y s service. Services can implement redirection through routing scripts that map invocations of the service to invocations of another service including redirection of replies.

For each service registered by an organization with Message Interface Network there are a number of properties and permissions that can be associated with the service. Examples include a unique service identifier authentication information mode of message delivery windows of time during which messages are accepted URL address of service permission to invoke other services to act on a message and rules that modify the invocation of services. These properties and permissions affect the routing of messages from or to the service.

SDK component serves as a foundation for supported development of client applications that interface with Message Interface Network . Owning organizations can use SDK component for custom integration with their software applications. As would be appreciated SDK component is not required to enable a service to access Message Interface Network . A service can use any development tool or process that would enable the service to leverage the application programming interface API that is supported by message router component .

In general SDK component enables the provision of an interface that would be available on most common platforms and in most popular languages. In this manner SDK component abstracts away the complex technical requirements of transferring messages using Message Interface Network .

SDK component need not have any business logic built into it. SDK component can be used to develop plug ins to shrink wrapped applications thereby greatly reducing development time. As would be appreciated SDK component can provide convenient libraries and utilities that a service may optionally use to facilitate the 1 creation and reading of messages conforming to the message router component API and 2 authentication of users of Message Interface Network .

Repository component is the primary database of Message Interface Network . Repository component includes information on customer profiles message logs and directories. As will be described in greater detail below message router component uses repository component to retrieve customer and application information that affects message routing. Message router component also writes message log information to repository component about messages that are processed through Message Interface Network .

Billing component uses the message log information in repository component to derive actual usage of Message Interface Network by customers and handles the invoicing and payment collection from customers. In one embodiment the billing within message interchange system can be based upon actual customer usage of Message Interface Network . For example billing component can charge customers based on a per transaction basis. In one embodiment the per transaction cost is based on the size of the messages being processed. As would be appreciated these per transaction costs can be assessed to parties in a variety of ways. For example the costs can be assessed against the originator of the message the intermediate services the recipient of the message or any combination of those parties. This billing flexibility is in sharp contrast to conventional EAI solutions that generate revenue through software license fees.

Web interface component is the front end component of Message Interface Network . Web interface component interfaces directly with users by enabling login registration account maintenance directory lookup rules configuration reporting billing and customer support functionality. The web interface provides online forms for data entry and can perform preliminary validations on the data. Through web interface component the user can also perform queries against repository component for directory lookups or reporting.

In one implementation Message Interface Network is an open network architecture that not only facilitates the easy introduction of services into the network but also enables businesses to access a robust suite of services via one connection to the Message Interface Network .

As noted message router component provides the core function of message routing and delivery within Message Interface Network . In one embodiment message router component is implemented as an Internet based message exchange service that provides a transport level messaging service. In other words message router component need not be aware of the application semantics of a message exchange.

Preferably Message Interface Network need not inherently provide business process modeling. This is in contrast to conventional EAI solutions that may require a continual traversal up and down a protocol stack in routing a message from a sending service to a recipient service. For example if the protocol stack included transport routing transformation and work flow layers then each message exchange segment may require analysis and processing at each layer to determine the next service intermediate or final that should receive the message.

As noted services can post messages to and retrieve messages from message router component using an API. This provision of a standardized interface enables parties to easily connect to and use Message Interface Network without being restricted in the type of message content.

In one embodiment the protocol for posting and retrieving messages with Message Interface Network is the Simple Object Access Protocol SOAP . The SOAP messaging protocol defines a mechanism to pass commands and parameters between HTTP clients and servers. Through this standard object invocation protocol HTTP is used for transport and XML is used for data encoding. The SOAP messaging protocol does not rely on the use of particular operating systems programming languages or object models on either the server side or the client side. As would be appreciated other protocols can also be supported by Message Interface Network .

While the message header can use extensible markup language XML syntax the message body can accommodate any type of data whether it be text or binary encrypted or unencrypted. If the message body is also in XML form then the message body can opt to use a schema based on an industry standard such as ebXML BizTalk RosettaNet OAGIS or any other suitable standard.

In one embodiment message exchange through Message Interface Network is asynchronous. Recipient services can be configured to poll Message Interface Network for incoming messages or if they have their own server can have Message Interface Network push messages to them.

After a sending service posts a message to Message Interface Network one or more in transit services can operate on the message before it reaches the recipient service. In transit services can perform useful operations on messages such as data transformation enrichment cross reference ID mapping filtering credit scoring or the like. Through the standardized interface in transit services can independently join the Message Interface Network and operate on messages. This flexibility encourages independent third parties to build services that can be plugged into Message Interface Network . Such an open network would encourage third parties to market a data service that generates revenue based upon the level of utilization of the service.

As noted in transit services can be included in a message path that begins at a sending service and terminates at a recipient service. As will be described in greater detail below sending services can explicitly specify a set of services to operate on a given message. In addition recipient services can specify services that should operate on messages before delivery to the recipient service. In one example a recipient may always want messages to pass through a filtering service to screen out messages from unknown senders.

Messaging through Message Interface Network can be as secure as the participants desire. Each service registered with Message Interface Network can specify a security policy declaring encryption and authentication levels for Message Interface Network to enforce. For messages that flow through in transit services a sender can also specify the permissions for each in transit service to access or operate on parts of the message.

In one embodiment Message Interface Network uses the secure HTTPS protocol to support secure transport connections when a service posts a message or polls for messages and when Message Interface Network pushes messages to a client server. Authentication can be based on either username password or certificates.

SSL encryption as part of HTTP can be used to provide data protection during message transmission over the public Internet. In general this level of protection is sufficient for most situations. Services can however perform their own extra encryption of message documents to keep them private even from Message Interface Network . Services that add extra encryption can ensure however that all services that operate on the message documents have the necessary keys to decrypt the documents.

As is well known the authentication protocol of SSL includes a server s presentation of a certificate to clients. Accordingly Message Interface Network presents a server certificate to services that connect for posting or polling. The connecting service has the option of then providing either a username password or certificate for Message Interface Network to authenticate the service. The form of client authentication is a configuration option within the profile Message Interface Network maintains for each service.

When Message Interface Network pushes messages to a service the service s server can present a server certificate to Message Interface Network for authentication of the service. For the reverse authentication the service can then require either a username password or certificate from Message Interface Network . Again that option can be configured in the profile information Message Interface Network maintains for the service.

As a message flows through a selection of services on the way to the recipient service and as the recipient service s response returns to the sending service Message Interface Network maintains an audit trail of all operations on the message and all services that touched the message. The audit trail serves several purposes. First it enables Message Interface Network to reconstruct the message history in the case of queries on the message trail. Second it allows Message Interface Network to compile a usage report for any service for reporting and billing purposes.

Having described the general framework of Message Interface Network a more detailed description of a message transaction lifecycle within Message Interface Network is provided with reference to in accordance with one embodiment of the present invention.

In this framework a message can be embodied as a self contained collection of information to serve a particular purpose such as a request a response a notification or an acknowledgement. As noted Message Interface Network can generally be agnostic about the content of a message other than header information that affects routing of the message.

In one embodiment request response and notification messages can be defined. A request message expects a subsequent response message from the recipient s to be returned to the sender. Request messages may represent inquiries but might also represent update requests that only expect a return status response. If an error occurs in routing a request message Message Interface Network returns an error response message to the sender.

A response message is issued by a recipient of a request message. The response message references the original request message. Failure of the response message may result in an error response message being returned to the sender of the original request message.

A notification message is a one way message. No response to the notification message is expected back to the sender. Message interchange network can regard any response message referencing a notification message as an invalid message. If a notification message fails no error message is returned to the sender.

As would be appreciated further messages can be defined for Message Interface Network . For example a cancel message can also be defined wherein the cancel message is used by the sender to cancel a previous message.

The operation of these messages is now described with reference to the request response illustration of . This illustration demonstrates a typical example of a sending service such as an enterprise making an inquiry to a recipient service such as a webware provider. In one embodiment a sender s application that connects to Message Interface Network is a desktop application. In another embodiment a sender s application that connects to Message Interface Network is an enterprise server or an EAI package.

The first step in the message transaction process is the creation of a message. In one embodiment a sender formats the messages to conform to an XML schema for messages. This XML schema prescribes the format for message headers while allowing any kind of data to be included in the message body or payload . As part of message construction sending service specifies the recipient service s of the message. In one embodiment a recipient service s name includes an organization and a specific service provided by that organization. The service name can be generally represented in the message via a globally unique ID.

The actual set of elements contained in a message depend on whether the message is being posted or delivered. In one embodiment a message includes a header element a body element and or attachments. In one embodiment the attachments are based on multi part Multipurpose Internet Mail Extensions MIME .

An embodiment of a message includes header and body elements. As would be appreciated the actual message format can differ depending on the protocol. In particular protocols other than the SOAP protocol can be used. The header element may include routing and invocation information. The header as posted by a sending service may often be modified by Message Interface Network for delivery to the receiving service.

The body element may include the documents the sender is sending to the recipient s . These documents can also be operated upon by one or more services. The documents can be in the form of XML or any other representation including text binary etc. In one embodiment all or part of the documents that are being sent are included in an attachment to the message.

While messages preferably have a similar overall structure the actual composition of elements can differ between the various message types and between messages as posted and as delivered. For example some elements in a sent message can be changed or not be included in the message as delivered such as elements particular to constructing a route. Some elements can also be inserted only in the message as delivered such as identifier elements.

If the sending service wishes to have the message routed through any services before delivery to the recipient service s the sending service can specify an explicit sequence of services that should operate on the message. The sender can also implicitly include services in the route for a message through the specification of routing scripts associated with the defining service. Routing scripts are described in greater detail below.

After a message is constructed the message is posted to Message Interface Network . illustrates an example posting of a message by application to message post interface . As noted in one embodiment the posting of a message is performed using the SOAP messaging protocol.

If sending service posts a message that does not have well formed XML the message posting is rejected and an error response is returned. In general messages can be rejected for a variety of other reasons. For example a message can be rejected if the service indicated in the message header as the sender is not the same as the actual sender of the message the message is a duplicate posting of a previous message a service attempts to reply to a message for which it was not a recipient or a response message does not reference a prior message.

In one embodiment each message posted by a service can have a unique handle assigned by the service to identify the message. This unique handle can be used to provide a means for Message Interface Network to detect duplicate postings of the same message. Duplicate postings can occur in the case of failure recovery by the service. In one embodiment if a service specifies that Message Interface Network should reject duplicate postings of a message then the service could provide unique handles for messages and set a potential duplicate flag in messages that may be a duplicate posting. Regardless of whether or not a service provides a unique handle for a message Message Interface Network can assign a globally unique session identifier to each posted message.

After a message is posted Message Interface Network routes the message to the recipient service s . The routing of the message is based upon a route calculation by Message Interface Network . The calculated route includes all intermediary services that are scheduled to operate on the message en route to recipient service s . The calculated route can be based on routing instructions specified explicitly in the message header and or on routing scripts pre defined by the sending service recipient service or any in transit services that have been included within the calculated route.

In general routing scripts define a procedure for enabling determination of at least part of a route. This procedure can be based on any type of criteria. For example a procedure can be defined that determines a next destination of a message based on the existence of one or more attributes of the message. In another example a procedure can be defined that effects a determination based on the comparison of one or more attributes of the message to a reference value. In yet another example a procedure can be defined that effects a determination based on pattern matching e.g. regular expression matching . As would be appreciated routing scripts can embody any of a variety of criteria based procedures.

Routing scripts can specify a sequence of services that operate on either inbound or outbound messages for a service. As noted in transit services may themselves have routing scripts requiring processing by other services. Therefore the route calculation can be recursively defined based upon routing scripts specified by all services that interact with the message.

In one example the sending service may specify a routing script that requires a cross reference mapping service to be included in the calculated route whenever sending service sends a message to recipient service . In another example recipient service may specify a routing script that requires that any incoming request messages must first pass through a filter service to block messages from a list of sending services .

Routing scripts enable sending services to include services into the message route without having to explicitly specify the services in the message itself. Also routing scripts enable recipient services to require services to be in the calculated route regardless of the sending service s route specification.

In one embodiment a routing script is embodied as a routing rule. A routing rule includes two parts a condition and one or more resultant actions. The conditional part of a rule can be based on any elements or element attributes in a message s header. Additionally content based routing can be supported through conditional rules based on attributes of an element in a message s body and or attachments.

Every rule generally has at least one condition. Conditions include an operator and zero or more operands. Example operators include equals notEquals equalsOneOf lessThan greaterThan and exists operators. In one embodiment operators act on XML elements XML attributes or on other conditions.

From the standpoint of the element operators XML elements contain either child elements or character data. Therefore the operands for an element comparison both represent the same type of content either elements or character data. Character data can be in the form of a string number or date. Conditions involving elements that do not appear in the message will evaluate to false.

Attributes generally have a type of character data which can be string number or date. Many attributes are implicitly included in an XML document with default values. Therefore an attribute identified in a condition can refer to either an explicit or implicit attribute. Conditions involving optional attributes that do not appear in the message will evaluate to false.

The usual boolean operators can combine conditions into more complex conditions. Condition operators act on other conditions. Example condition operators include AND OR XOR and NOT condition operators.

The result of satisfying a rule s conditions is that an action will be triggered to modify the route for a message. Probably the most common result of a rule is to add one or more services into the route for a message. Several rule actions can be defined and several are described further in the above reference Lev Brouk et al. U.S. patent application.

A service can maintain an evaluation sequence for the scripts associated with each role that the service can have with respect to a message. That sequence determines the order in which the scripts for that service are applied.

In one embodiment scripts are evaluated in the following order 1 scripts for the sender of the message 2 scripts for services included by the scripts for the sender this is recursive 3 scripts for the recipients of the message in the order of recipients in the message header and 4 scripts for services included by scripts for the recipients this is recursive .

When multiple scripts for a service include services into a route the order of services in the route will follow the order of the scripts. That is if script inserts service A and script inserts service B and if script is evaluated before script then service B follows service A in the route.

In one embodiment routing scripts are evaluated only once during the initial calculation of the route for a message. The message header contains the basic information to initially construct a route such as sending service and recipient services . The message can also contain an explicit specification of a set of services to include in the route. Once the route is constructed from the header information routing scripts are applied to further elaborate the route.

In an alternative embodiment at least part of the message route is calculated after the physical routing of the message has begun. Dynamic routing is described in greater detail below in the context of physical and logical routing.

At the transport level Message Interface Network routes a message to a service by delivering the message through the Internet to a physical machine on which the service resides. That service operates on the message and if the message is a request returns a response message back through the Internet to Message Interface Network . The sequence of message deliveries and responses between Message Interface Network and services represents the physical routing of a message.

Message interchange network also provides a mechanism for a service to act on a message without the message being physically delivered to the service over the Internet. This mechanism is enabled through the logical routing of the message to the service. With logical routing a service can modify the routing of the message or modify the context of the message for delivery to the next service. Significantly a service can be logically included in a message routing without being included as part of the physical routing of the message.

In one embodiment logical routing of messages is implemented through the specification of routing scripts. As described above a service can define one or more routing scripts. These defined routing scripts are stored within Message Interface Network and are processed to determine what routing behavior should occur when a message is logically routed to the service.

Logical routing can take place statically or dynamically. With static logical routing a message is logically routed to all services prior to any physical routing. In other words Message Interface Network logically routes the message to all services prior to the physical delivery of a message to any services. This logical routing is represented by the sequential evaluation of the routing scripts that are defined by those services. As noted above in one embodiment the routing scripts are evaluated in the following order 1 scripts for the sender 2 scripts for the services included by the sender recursive 3 scripts for the recipient and 4 scripts for the services included by the recipient recursive .

In dynamic logical routing the logical routing is not completed prior to the start of the physical routing. Rather the logical routing takes place in sequence with the physical routing of the message. The relation between logical routing and physical routing is described in greater detail below.

As noted Message Interface Network delivers a message logically to every service participating in a message s routing. Of those services some subset will also accept physical delivery of the message.

To illustrate this concept consider an example where service A includes service B into the message route. Service A can include service B into the route either prior to itself in the route provided service A is not the originator of the message or after itself in the route. In either case Message Interface Network would logically route the message first to service A which includes service B into the route. Message interchange network then logically routes the message to service B and after service B produces a response Message Interface Network logically returns the response to service A. The point at which service A physically receives the message depends on whether service A included service B prior or after itself in the route. If service A includes service B prior to itself in the route then the order of physical delivery is first to service B then to service A. Conversely if service A includes service B after itself into the route then the order of physical delivery is first to service A then to service B. In the latter case the response from B is not necessarily physically delivered back to service A. Rather it may be only logically delivered back to service A.

Services to which a message is logically routed do not necessarily have to also physically receive the message. In the above example service A could have been logically routed with physical delivery only to service B. Consider the following scenario. Suppose service X includes service A into the route and service A includes service B into the route. The logical routing of the message would proceed from service X to service A to service B back to service A back to service X. Service A can choose not to be included into the route for physical delivery in which case the physical routing of the message is from service X to service B.

In general the act of routing a message physically or logically to a service can be thought of as an invocation of the service. When a service includes another service into the route of a message the including service is effectively invoking the included service. The invocation of a service does not necessarily imply the physical delivery of information to the invoked service. The logical routing of a message is then the logical invocation of services. A route that includes a progression of services including other services can effectively be modeled as a progression of invocations.

In logical routing each service is not only able to manage the inclusion of other services into the route but is also able to manage the context of those inclusions. From the standpoint of invocations an invoking service is able to set the context for the invocation. An invoked service can also set the context of its return.

Message interchange network can also affect context management on behalf of invoking services. As noted while an invoking service can be logically included in a message routing it need not be included as part of the physical routing of the message. In general Message Interface Network can persistently store contexts of a message thereby enabling proper restoration of contexts upon return from an invocation. Several embodiments of context management are described in the above referenced Lev Brouk et al. U.S. patent application.

Having touched on a framework for logical routing and invocation of services the description of the physical routing process is continued with reference to . In this example it is assumed that static logical routing has produced a route for the message.

After deriving the route for a message Message Interface Network validates the route. There are numerous conditions that can cause a route to be invalid. For example there may be routing permission violations or a service may be currently disallowed by Message Interface Network due to for example the non payment of usage bills.

If the route is determined to be invalid then Message Interface Network rejects the posted message and may return an error to the sending service either in the response to the posting call or in an error message.

Message interchange network routes the message to all services in the calculated route. In the event of failure at any stage in the routing Message Interface Network aborts the message routing and if the original message was a request returns an error message back to sending service . For messages with multiple recipients an error in the routing to one recipient will not necessarily affect routing to other recipients. Errors during routing can occur due to several circumstances. For example a message may fail to reach a recipient within the expiration time for the message a service may fail to return a reply to a delivered message or a service may return an error status for a message.

Message Interface Network sequentially delivers a message to each service identified in the message route. In this process is illustrated as a flow of the posted message through message routing element and on to one or more services . In one embodiment Message Interface Network includes all of the message documents in the message delivered to service even if service only expects to operate on one document or documents of a particular content type. Service would ignore documents that it does not expect.

As noted Message Interface Network invokes in transit services in the same way as delivering a message to any sending or recipient service. In general a service does not necessarily need to be aware whether it is being invoked as an in transit service or as a recipient service.

After processing the message service sends the results in a response message back to Message Interface Network . If service is unable to produce a valid result for its operation on a message then service may return an error code in its response message to Message Interface Network . If service fails to respond to a received message the message will ultimately expire and Message Interface Network may return an error message back to the sending service .

Upon receipt of the response message from service Message Interface Network then routes the message to the next destination e.g. another service on the routing list. After passing through each of the intermediate destinations on the routing list the message is then stored in queue for recipient service . Queues can also be associated with in transit services . For simplicity these queues are not shown in the illustrated embodiment of .

Application in recipient service can retrieve the message from queue via message poll interface . In the poll mode application periodically issues a call to message poll interface to ask for any waiting messages. If there are queued messages waiting for delivery to that service then the one or more messages are returned in a reply. When making poll requests a service can provide selectors on the messages to fetch. For example a service can retrieve messages based upon the sender message type topic etc.

In an alternative embodiment message delivery is enabled through a push mode. In the push mode the recipient would have its own server to which Message Interface Network can send messages. A service can specify a maximum number of tries as well as the retry interval for Message Interface Network to send the message to the service before aborting pushed delivery. A service to which Message Interface Network pushes messages can also optionally poll for messages.

In the push mode a service can also specify a delivery window in which it will accept pushed messages. For example a service might only accept messages between the hours of 1 AM and 2 AM.

As further illustrated in a response message can be posted by recipient service to message post interface . The message is then routed through one or more services prior to being stored in message queue . The message can then be retrieved by sending service through message poll interface . As noted the return path would not necessarily match the forward path.

In one embodiment the sender of a message can specify a time by which the routing of a message must complete. If that expiration time passes before delivery of the message to it final destination Message Interface Network will abort further routing of the message. In one embodiment the final destination for a request message is the delivery of a response message back to the original request sender. In this embodiment senders of response messages cannot specify an expiration since the response is considered part of the routing of the original request message. If a request message expires Message Interface Network will return an error response back to the sender. If the sender does not specify an expiration time then a default message expiration time e.g. 48 hours can be used. Message expiration is not the same as document expiration. Document expiration is associated with a specific document and indicates how long the document s information is valid.

As part of the message delivery process Message Interface Network logs all posted messages including invalid messages. For each message Message Interface Network logs relevant information to track the history of the message. Message Interface Network also maintains a correlation between messages. That is for request messages Message Interface Network associates the log of the response message s with the log of the request message.

In one embodiment logged information can include the message header the calculated route for the message unless route calculation fails the status of route validation the size of the message at each stage of the route and the routing history including the status for each service along the message s route. The status values for each service depends on the role of the service.

Message Interface Network correlates all messages for the same message transaction. That is for request messages Message Interface Network associates the log of the response message s with the log of the request message. Similarly if a message causes an error message then Message Interface Network associates the log of the generated error message with the log of the original message.

A service may represent any computer application or device accessible to other entities through an interface such as an application programming interface API user interface or Internet web user interface by any of a variety of protocols over a network within an entity or over the public Internet. A service may also be comprised of multiple methods or applications implemented on a single device or distributed across multiple devices.

In particular cases a message may also be sent to a routing script as described above. In a correlation implementation a routing script can also be defined as a service. For example an application type service may send a message to a routing script type service. Accordingly routing programs can be session participants. In fact one of the major uses of sessions may be that a session encompasses the set of calls into and from a routing script.

The messages in this communication exchange are all related and are preferably correlated together. Response message is in reply to request message and hence related to request message . Likewise response message is in reply to request and hence related to request message . These two pairs of messages may each be referred to as a call. As shown request and response form a call while request and response form a call.

In one embodiment each message is given a Hop Identifier ID and each call is given a Call ID. As shown request and response are given Call ID and request and response are given Call ID . In this example the messages belonging to Call ID are also related to the messages belonging to Call ID since the latter messages were initiated in response to the former messages. Hence the messages associated with both Call ID and are given a Session ID . In sum each message is given a Hop ID each set of related messages exchanged between two services is given a Call ID and each set of messages belonging to related calls are given a Session ID.

In this example the messages of these related calls all have the same assigned unique Session ID. Similarly each call has a unique Call ID while each message within each call has a unique Hop ID. However not all calls initiated by a particular service have to be part of the same session. For example service can choose that some of the resulting calls are not part of the same session. In one implementation a call is a predefined set of messages e.g. as preconfigured in the Message Interchange Network such as a notification message or a pair of request and response messages. A call may be predefined as any number and type of messages. A session in this implementation depends on how the particular services define sessions. That is a service may be implemented to define its messages any suitable manner. For example a service may send a first message with the intention of the message being part of a first session and send a second message with the intention of the message being part of a second session. In this example the sending service may include a first Session ID in the first message and a second Session ID in the second message. Alternatively the Message Interchange Network may predefine what constitutes a session. For instance messages which are spawned from a service in response to a message received into such service may be defined as part of a same session.

In summary a call may include any predefined number and type of messages. For instance each call may include any number of request and response messages and or any number of notification messages e.g. a response is not sent by the receiving service . Each session may include any number of calls between any number of service pairs. While the definition of sessions is general common uses of sessions include grouping calls comprising a conversation between services comprising a transaction involving multiple services or comprising a trace of routing a message through diverse services.

A same message may be passed through any number of services or hops. That is a particular message may result in multiple Hop ID s one Hop ID for each hop of its route. A same message may also be modified by such services as it passes through such services. A message which enters a service is modified by such service and output from such service may be defined as two different messages a first message which is received by such service and a second modified message which exits the service.

Any suitable technique may used to correlate related messages. is a flowchart illustrating a procedure for correlating messages in accordance with one embodiment of the present invention. Initially a message is received into Message Interchange Network in operation . The message may be any form such as a request response or notification message. Any of these three message types can also include error messages alert messages cancel messages acknowledge messages etc.

It is then determined whether this is the first message for the current session in operation . In other words it is determined whether the received message is the start of a new session. This determination may be performed in any suitable manner. In one implementation if the received message does not include a Session ID or a Call ID then it is determined that it is the first message in the session e.g. that this is the start of a new session . The Message Interchange Network then assigns a unique session ID for the current session in operation . The Message Interchange Network may also return the assigned Session ID to the sender of the message and embeds the Session ID in the received message before forwarding the message to the recipient service in operation . When the received message is not the first message in the current session assignment of a new Session ID is skipped.

If the message is not the first message in the current session a Session ID may still be returned back to the message sender in an alternative implementation as well as storing information about the message. In either implementation a new Session ID is not assigned but rather the Session ID of the current session is used for correlating with the current message.

Messages which are sent by either the sender service or the receiver service after the first message will include the either the assigned Session ID or Call ID if they belong to the current session. A message which is in reply to a request message may simply include a Call ID which is the same as the Call ID of the corresponding request message. In this case the response message does not include a Session ID and the Message Interchange Network determines that the response message belongs to the session to which the Call ID is associated.

It may then be determined whether the received message is the first message in the current call in operation . In one example if the message already includes a Call ID then it is determined that the message is not the first message for such call. If the message does not include a Call ID then it is determined that this is the first message for the current call and the Message Interchange Network then assigns a Call ID in operation . The Call ID may also be returned to the message sender and embedded in the received message in operation . If it is determined that this message is not the first message for the current call then this operation for assigning a new Call ID is skipped.

If the message is not the first message in the current call a Call ID may still be returned back to the message sender in an alternative implementation as well as storing information about the message. In either implementation a new Call ID is not assigned but rather the Call ID of the current call is used for correlating with the current message.

This Call ID assignment operation is also performed after the Session ID assignment operation where a determination is not made as to whether the message is the first message in the current call. When it is determined that the message is the first message for the current session it is also assumed that it is the first message for the current call.

The Message Interchange Network may then assign a Hop ID to the received message in operation . The Hop ID generally identifies the current message and its associated hop between its sender and receiver.

The Session ID Call ID and Hop ID may be assigned to a message in any suitable order besides the order illustrated in . For particular protocols the messages may not be able to embed a Session ID and or a Call ID. For these protocols the assigned Hop ID Call ID and Session ID and their corresponding message information may still be stored as described below.

Information regarding the received message the current call and the current session is then stored in operation . This information can be stored at the same time or individually for the received message current call and current session at various points in the message handling process. No matter when the information is stored it may be stored in any suitable one or more memory device s .

In one implementation the Hop ID Call ID and Session ID and their associated information regarding the message call and session are stored in a repository. is illustrates a Message Correlation Table for correlating information regarding each message a Call Correlation Table for correlating information regarding each call and a Session Correlation Table for correlating information regarding each session in accordance with one embodiment of the present invention. The Tables and may be stored in repository . The repository may be formed from any suitable number of databases stored on any suitable number of memories on any suitable number of computer systems.

As shown the Message Correlation Table includes one or more entries for each message. Each entry includes correlation information for each message. In this embodiment each entry corresponds to a particular message and includes the particular message s Hop ID message information regarding the particular message the particular message s Call ID and the particular message s Session ID. The message information may include any information relevant to the particular message such as the message s sending service and receiving service whether the message has completed its transmission e.g. to its intended destination service and a reason or error log regarding why a message has failed to complete its hop selected message content the size of the message the receiving and sending times for the message the topic of the message the status on processing steps taken on the message the protocols used in receiving and sending the message etc. The message s session ID may be assigned by the Message Interchange Network embedded in the message received into the Message Interchange Network or inferred from the Call ID embedded in the message e.g. the same session to which the Call ID is associated .

As shown a message having Hop ID equal to hop belongs to the same call as a message identified by Hop ID hop. This same call is identified by Call ID call. Additionally another message having Hop ID hop belongs to a call identified by Call ID call while another message having Hop ID hop belongs to a call identified by Call ID call. Also illustrated in the example of messages having Hop ID s hop hop and hop all belong to a same session identified by Session ID session. In contrast the message having Hop ID hop belongs to a different session having a Session ID session. 

In an alternative embodiment a service could define a message field that is to be used as a message identifier. For example the profile information for a service could include an XPath expression designating a field in XML messages. In this embodiment the Message Interchange Network would extract the value of the field from a received message and store the custom message identifier along with the assigned Call or Session ID. This alternative implementation then enables a service to query for correlation information using their own identifier rather then necessarily the assigned Call or Session ID s.

The Call Correlation Table also includes one or more entries for each call. As shown each entry includes a Call ID for a particular call and call information regarding the particular call. The call information for a particular call may include an indication as to whether the particular call is complete a reason for the particular call not completing the type of call the receiving and sending times for the call the sender and recipient services of the call the status of policy evaluation for the call the set of hops in the call etc.

The Session Correlation Table includes one or more entries for each session. Each entry for a particular session generally includes a Session ID for the particular session and session information regarding the particular session. The session information for a particular session may include any information relevant to a particular session such as the calculated or executed route for messages sent within such particular session the size of each message at each stage in the route the identity and status of each service within the route paths of the particular session whether a session has been completed and reasons for a session failing to complete the initiating time and completion time for the session the set of calls in the session etc.

The tables shown in illustrate only one embodiment of storing correlation information. Any other suitable set of tables and relationships among tables may be used to store correlation information. For example the message route of a session may not be stored directly in one table but rather may be inferred from the set of calls and hops related to the session as stored in one or more other tables.

At any time during the correlation process an entity may query the Message Interchange Network for information which has been correlated together. For example a service may request correlation information regarding a particular session. In this example the Message Interchange Network collects all entries within the Correlation Tables and that relate to the requested session s Session ID. Likewise an entity may request correlation information regarding a particular service route call time period message status etc.

The Message Interchange Network preferably determines whether a request service is authorized to receive a compilation of its requested correlation information. This determination may be performed in any suitable manner. In one implementation the requesting service is authorized when the requested information is in any way related to a service owned by the requesting service s organization. For example a service may request correlation information regarding any messages sent by such requesting service and any messages from calls or sessions belonging to the same call or session as the sent messages. In another implementation the requesting service may request correlation information which is related to any one message which contains an identifier of the requesting service.

The correlation techniques of the present invention allow end points or services to correlate through an intermediary which handles ID assignments. Thus the end points or services do not have to separately negotiate the use of an ID for their communication exchanges with every service. As a result this approach greatly simplifies correlation of complex message interchanges over a computer network between diverse services and or end point entities.

In summary since an intermediary network e.g. message interchange network handles identification of messages calls and sessions as well as correlation of information related to same users of such intermediary network do not have to implement any procedures for correlation. Since an intermediary is performing the correlation of messages sent between diverse and distributed services any end point or service can also easily gain a clear picture as to what is happening with messages sent as a result of its interactions with such diverse services. Since the retained correlation information is performed by a single intermediary network the correlation information is standardized and easily compiled into a clear summary of interactions results.

As thus described Message Interface Network enables flexible interaction between services. Several embodiments for provisioning or setting up services with Message Interface Network and routing messages through Message Interface Network between such provisioned services are further described in the above referenced Lev Brouk et al. U.S. patent application.

Generally the correlation techniques of the present invention may be implemented on software and or hardware. For example it can be implemented in an operating system kernel in a separate user process in a library package bound into network applications on a specially constructed machine or on a network interface card. In a specific embodiment of this invention the techniques of the present invention are implemented in software such as an operating system or in an application running on an operating system.

A software or software hardware hybrid packet processing system of this invention is preferably implemented on a general purpose programmable machine selectively activated or reconfigured by a computer program stored in memory. In one embodiment portions of the correlation system e.g. Message Interchange Network may be implemented on a general purpose network host machine such as a personal computer or workstation.

Referring now to a computer system suitable for implementing the present invention includes a master central processing unit CPU one or more memory input and output interfaces and a bus e.g. a PCI bus . When acting under the control of appropriate software or firmware the CPU is responsible for implementing various portions of the techniques of the present invention. It preferably accomplishes all these functions under the control of software including an operating system and any appropriate applications software. CPU may include one or more processors such as a processor from the Intel family of microprocessors or the MIPS family of microprocessors. In a specific embodiment a memory such as non volatile RAM and or ROM also forms part of CPU . However there are many different ways in which memory could be coupled to the system. Memory block may be used for a variety of purposes such as for example caching and or storing data programming instructions etc.

The input and output interfaces typically provide an interface to various I O devices such as mouse keyboard display as well as providing an communication interface with other computer systems over a computer network. Among the communication interfaces that may be provided are Ethernet interfaces frame relay interfaces cable interfaces DSL interfaces token ring interfaces and the like. In addition various very high speed interfaces may be provided such as fast Ethernet interfaces Gigabit Ethernet interfaces ATM interfaces HSSI interfaces POS interfaces FDDI interfaces and the like. Generally these interfaces may include ports appropriate for communication with the appropriate media. In some cases they may also include an independent processor and in some instances volatile RAM.

Although the system shown in is one specific computer system of the present invention it is by no means the only system architecture on which the present invention can be implemented.

Regardless of system s configuration it may employ one or more memories or memory modules such as for example memory block configured to store data program instructions for the general purpose network operations and or the inventive techniques described herein. The program instructions may control the operation of an operating system and or one or more applications for example. The memory or memories may also be configured to store information in repository etc.

Because such information and program instructions may be employed to implement the systems methods described herein the present invention relates to machine readable media that include program instructions state information etc. for performing various operations described herein. Examples of machine readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROM disks and DVDs magneto optical media such as floptical disks and hardware devices that are specially configured to store and perform program instructions such as read only memory devices ROM and random access memory RAM . The invention may also be embodied in a carrier wave travelling over an appropriate medium such as airwaves optical lines electric lines etc. Examples of program instructions include both machine code such as produced by a compiler and files containing higher level code that may be executed by the computer using an interpreter.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Therefore the described embodiments should be taken as illustrative and not restrictive and the invention should not be limited to the details given herein but should be defined by the following claims and their full scope of equivalents.

