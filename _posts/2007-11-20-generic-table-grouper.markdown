---

title: Generic table grouper
abstract: A system and process that groups identical values that are adjacent to one another within a column of a table. The system provides this functionality through an application and backend implementation independent module. Custom grouping information for a table or columns within a table can be stored for retrieval each time a table is open or displayed. A user can manage the customizations through a centralized portal.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08204880&OS=08204880&RS=08204880
owner: SAP Aktiengeselleschaft
number: 08204880
owner_city: Walldorf
owner_country: DE
publication_date: 20071120
---
The invention relates to table management. Specifically the embodiments of the invention relate to a method and system for reorganizing tables to group redundant field values in columns and store and apply default column grouping customizations.

Tables are utilized in a large number of different applications. The applications include spreadsheet applications such as EXCEL by Microsoft Corporation of Redmond Wash. supply chain management applications such as SCM by SAP AG of Waldorf Germany database applications such as MySQL by MySQL AB of Uppsala Sweden and similar applications. These applications access stored data draw a table and insert the data into the table.

Tables are organizations of data as entries or records. Each entry or record includes a set of fields that are common amongst the entries. The entries can be displayed in rows and columns where each row corresponds to an entry and each column to a field of the entry. Often values in the fields of different entries are identical. Organizing entries with identical values in a given field can help the user establish relationships between the entries and identify information about the data set as a whole. The relationships between the entries can constitute a hierarchy of information within the table.

Some applications provide a grouping functionality to assist a user in understanding the data presented in a flat table. The grouping function is programmed and incorporated into the application by the application developer. The grouping function iterates through a selected column of a table and merges fields with identical values. The entries are reordered to be consistent with the resulting groupings. When the application is closed or a window containing the table is closed the grouping is lost and must be recreated by user direction upon a subsequent opening of the data.

Embodiments of the invention include a system and process that groups identical values that are within a column of a table. The system provides this functionality through an application and backend implementation independent module. Custom grouping information for a table or columns within a table can be stored for retrieval each time a table is open or displayed. A user can manage the customizations through a centralized portal.

The applications A C can be any type of applications including word processing programs spreadsheet applications supply chain management applications database management applications and similar types of applications that utilize and rely on tables to display sets of data to a user. A set as used herein refers to any positive whole number of items including one item. The system can include any number of applications A C that can be executed by a single computer system or a set of computer systems. The applications A C rely on a user interface layer to generate basic aspects of the application interface.

The user interface layer can be a library set of classes or similar components that are utilized by applications to generate basic user interface elements such windows menus icons and similar user interface elements. The user interface layer is implemented separately from the applications A C to allow for reuse of the functionality of the user interface across applications to provide a consistent style to simplify programming requirements. The user interface layer can be exposed to applications through an application programming interface API or similar interface set of classes or library. The user interface layer can be provided as part of an operating system programming platform or environment such as Java by Sun Microsystems of Santa Clara Calif. or similar software.

The context layer can be a library set of classes or similar components that are utilized by applications to provide a software environment to the applications including providing functionality and data to the user of the applications. The context layer can store data including user data environment data and similar data. The context layer can also include a table generator component a table sorting component and a column grouping component and similar components.

A table generator component receives events calls interrupts or similar activities from applications A C the user layer and other content layer components. For sake of clarity the example of servicing an event is presented. One skilled in the art would understand that other paradigms can operate on similar principles. The events can include an indicator for a table or similar table data. The indicator can be an object representing the table data a link or pointer to the table data an identifier for the table data or similar representation of the table data. The table generator component can receive an indicator of a table to load from the backend implementation through the backend interface or that has already been loaded. The table generator component organizes the loaded data into rows and columns and returns the organized data to the component that generated the event. In another embodiment the table generator component draws or similarly manipulates the data to be displayed to the user.

A table sorting component receives events calls interrupts or similar activity from applications A C the user layer and other context layer components. For sake of clarity the example of servicing an event is presented. One skilled in the art would understand that other paradigms can operate on similar principles. The events can include an indicator for a table or similar table data. The indicator can be an object representing the table data a link or pointer to the table data an identifier for the table data or similar representation of the table data. The table sorting component reorganizes the data in a table. The table sorting component may be able to perform any number of different types of sorting and filtering algorithms on the table data. The table sorting component can reorder columns rows or entries based on any criteria. The criteria can be user specified application specific or similarly designated. The table sorting component can return a pointer indicator or similar link to reorganized data. In another embodiment the table sorting component can directly draw and manipulate the data shown to the user.

A column grouping component receives an event call interrupt or similar activity from an application A C user layer or other context layer component. For sake of clarity the example of servicing an event is presented. One skilled in the art would understand that other paradigms can operate on similar principles. The events can include an indicator for a table or similar table data. The indicator can be an object representing the table data a link or pointer to the table data an identifier for the table data or similar representation of the table data. The column grouping component receives an indicator of a table and a set of columns to group. The column grouping component identifies all of the identical values in the columns and merges those values into a single grouping. The column grouping component may also reorder the rows of the table to accommodate the groupings of the set of columns. The column grouping component may call the table sorting component to further organize the entries within the groupings.

The backend interface I F is an abstraction of the communication components that allow the context layer user interface layer and applications A C to communicate with a backend implementation . The backend interface can be implemented using any combination of remote function calls RFC remote procedure calls RPC open database connectivity ODBC Java database connectivity JDBC or similar backend communication and interfacing technologies. The backend interface can vary depending on the type of backend implementation . In one embodiment multiple backend implementations can be utilized. Each backend implementation can have a separate backend interface or share any combination of backend interfaces .

The backend implementation can be any server such as a database management system file system web server or similar program. The backend system provides and manages data utilized by the applications C including application and user data. The backend implementation can store table data customization data user data and similar types of data to be accessed by the applications A C. The backend implementation can be local to the machines executing the applications A C or remote from the machines executing the applications A C. The backend implementation can exchange data with the applications through the backend interface . The data provided by the backend system is stored on fixed disks such as hard drives optical drives and similar storage systems. As a result the access times for the data provided by the backend implementation can be on the order of milliseconds seconds or longer. Thus it can be advantageous to minimize the number of times that the backend system is accessed to improve performance of the applications A C.

The context layer improves overall system performance including application A C performance by storing data such as the table data and performing functions such as table generation sorting and grouping. Storing this data locally and performing these functions independent of the backend system minimizes the number of accesses to the backend system .

The components of the context layer are independent of the backend implementation and the applications A C. Thus the applications do not have to replicate the functionality of the context layer components or manage the storage of the data in the context layer . Similarly the applications A C do not have to communicate with the backend implementation to retrieve and manipulate the table data to maintain.

A portal interface can be a web based interface that presents a user interface through a web page or similar document accessible by a web browser or similar application to allow a user or administrator to customize application settings and similar settings. In one embodiment the portal interface is accessible by a general purpose application such as a web browser or the portal interface is accessible through an application of the local software environment B. The user or administrator customizations are stored in a data structure accessible to the portal interface and the components of the local software environment B.

The stored customization can be any type of data structure. The data structure can be a database hash table list object or similar data structure. The stored customization can be stored in an recordable medium including a set of a fixed disks removable memory devices flash memory devices or similar memory devices. The stored customization can be distributed across multiple storage media or stored in a centralized storage device such as a central data store. The stored customization can be directly or indirectly accessible by other components of the software environment . The stored customization can include security controls to limit access to user customizations to those application and components associated with that user.

The applications can access and interact with the portal interface and stored customizations . The applications can include an interface or link to access the portal interface to allow a user to update and view customizations for the application in user or other applications. The application can also access either directly or indirectly the stored customization data to configure the application according to the stored customizations including customization relating to the creation and display of tables by the application .

The table generator or similar component can also have access to the stored customization data or the portal interface . The table generator can service requests from applications to generate tables for display. The table generator or application then accesses the portal interface or stored customization data to determine whether any customizations need to be applied to a table to be generated. For example a user can established an order to table columns and settings for which columns are to be grouped. The table generator in response to the retrieval of the grouping customization data can call a column grouping component to effect the customized grouping settings.

In one embodiment the application may also access the customization data for the requested table through the portal interface or may directly access the customization data. The customization data can be requested from the portal interface or customization data storage and if present the requested data is returned to the application block . In another embodiment the table generator accesses the customization data for the requested table through the portal interface or may directly access the customization data. In an embodiment where the application retrieves the customization data the application may then pass the customization data on to the table generator block .

In an embodiment where the application does not pass the customization data on to the table generator then the application calls the column grouping component block as needed to create the column groupings required by the customization data. A table generator that is passed the customization data can similarly call the column grouping component. The application table generator and column grouping component each manipulate the table data as required by the customization data block . After each customization has been implemented the application displays the table as requested by the user block . The division of functionality between the table generator component column grouping component and application can be implemented in a variety of distributions. In each case the table generator component and column grouping component are implemented independent of the application and the backend implementation. This allows the application to utilize the functionality of the table generator component and column grouping component without regard to the backend implementation.

The column grouping component receives the call from the application. It accesses the table data including the column to be grouped. The column grouping component then iterates through the values of the column to identify and group identical values. Identical values are merged into a single value block . The entries associated with grouped values are reordered to allow them to be adjacent to one another. The entries may be kept in relative entry order prior to grouping or may be sorted and reordered based on any criteria or scheme.

The column grouping component then returns the table data or an indicator of the reorganized table to be accessed or made available to the requesting applications. The column grouping component can work on table data stored in the context layer to avoid having to access table data in the backend implementation. The column grouping component can have a standard interface or be part of an application programming interface API or similar library that is backend implementation independent.

In one example the columns illustrated are in their default organization. No columns are grouped or otherwise reorganized from the default table format.

In one embodiment the column grouping and customization system may be implemented as hardware devices. In another embodiment these components may be implemented in software e.g. microcode assembly language or higher level languages . These software implementations may be stored on a machine readable medium. A machine readable medium may include any medium that can store or transfer information. Examples of a machine readable medium include a ROM a floppy diskette a CD ROM a DVD flash memory hard drive an optical disk or similar medium.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

