---

title: Method and system for stealing interrupt vectors
abstract: A system for stealing interrupt vectors from an operating system. Custom interrupt handler extensions are copied into an allocated block of memory from a kernel module. Also, operating system interrupt handlers are copied into a reserved space in the allocated block of memory from an interrupt vector memory location. In response to copying the operating system interrupt handlers into the reserved space in the allocated block of memory, custom interrupt handlers from the kernel module are copied over the operating system interrupt handlers in the interrupt vector memory location. The custom interrupt handlers after being copied into the interrupt vector memory location handle all interrupts received by the operating system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08145819&OS=08145819&RS=08145819
owner: International Business Machines Corporation
number: 08145819
owner_city: Armonk
owner_country: US
publication_date: 20070604
---
The present invention relates generally to an improved data processing system. More specifically the present invention is directed to a computer implemented method system and computer usable program code for stealing interrupt vectors from an OS to gain access to all system resources.

Today computer systems have evolved into extremely sophisticated devices that may be found in many different settings. Typically computer systems include a combination of hardware e.g. semiconductors circuit boards etc. and software e.g. computer programs . The combination of hardware and software on a particular computer system defines the computing environment. Thus different hardware platforms and different operating systems OSs provide different computing environments.

As advances in semiconductor processing and computer architecture push the performance of the computer hardware higher more sophisticated computer software programs have evolved to diagnostically test these hardware components. However most OSs do not allow test programs to run in a privileged or a partition manager mode. In addition most OSs do not allow test programs access to real memory. Consequently in order for a user program to test all possible computer states and resources the test program must have the ability to get around these OS limitations.

Current solutions to these OS limitation problems include test programs that simply do not run on an OS or test programs that only use as many system resources as the OS will give the test programs to test. Test programs that do not run on an OS are written in assembly language and are loaded directly into memory or a cache. In addition these types of test programs run independently of any OS and do not have access to standard OS services such as virtual memory management and scheduling which may be a disadvantage.

In contrast test programs that run on top of an OS may only request memory and resources from the OS. By only being able to request memory and resources from the OS much of a computer s functionality is out of the reach of these types of test programs. As a result these types of test programs must rely on indirectly influencing the OS to execute some code in a privileged or a partition manager mode in order to test those out of reach areas.

Another related solution is to have a custom OS which has built in test functionality to allow test programs access to the whole computer. The downside of utilizing this type of test program is the necessity of maintaining a completely separate OS. As a result an additional solution is needed to allow test programs to run on an existing OS and yet still allow access to all of a computer s resources.

Therefore it would be beneficial to have an improved computer implemented method system and computer usable program code for stealing interrupt vectors from an OS to allow a test program access to all system resources.

Illustrative embodiments provide a computer implemented method system and computer usable program code for stealing interrupt vectors from an operating system. Custom interrupt handler extensions are copied into an allocated block of memory from a kernel module. Also operating system interrupt handlers are copied into a reserved space in the allocated block of memory from an interrupt vector memory location. In response to copying the operating system interrupt handlers into the reserved space in the allocated block of memory custom interrupt handlers from the kernel module are copied over the operating system interrupt handlers in the interrupt vector memory location. The custom interrupt handlers after being copied into the interrupt vector memory location handle all interrupts received by the operating system.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

Computer may be any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a personal computer other embodiments may be implemented in other types of data processing systems. For example other embodiments may be implemented in a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

Next depicts a block diagram of a data processing system in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as computer in in which code or instructions implementing the processes of the illustrative embodiments may be located.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub NB MCH and a south bridge and input output I O controller hub SB ICH . Processing unit main memory and graphics processor are coupled to NB MCH . Processing unit may contain one or more processors and even may be implemented using one or more heterogeneous processor systems. Graphics processor may be coupled to NB MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to SB ICH audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB and other ports . PCI PCIe devices are also coupled to SB ICH through bus . Hard disk drive HDD and CD ROM are coupled to SB ICH through bus .

PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to SB ICH .

An OS runs on processing unit . This OS coordinates and controls various components within data processing system in . The OS may be a commercially available OS such as Microsoft Windows XP . Microsoft and Windows XP are trademarks of Microsoft Corporation in the United States other countries or both. Alternatively the OS may for example be an advanced interactive executive AIX OS which is a product available from the IBM Corporation. An object oriented programming system such as the Java programming system may run in conjunction with the OS and provides calls to the OS from Java programs or applications executing on data processing system . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

Instructions for the OS the object oriented programming system and applications or programs are located on storage devices such as HDD . These instructions and may be loaded into main memory for execution by processing unit . The processes of the illustrative embodiments may be performed by processing unit using computer implemented instructions which may be located in a memory. An example of a memory is main memory ROM or in one or more peripheral devices.

The hardware shown in and may vary depending on the implementation of the illustrated embodiments. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in and . Additionally the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

The systems and components shown in may be varied from the illustrative examples shown. In some illustrative examples data processing system may be a personal digital assistant PDA . A personal digital assistant generally is configured with flash memory to provide a non volatile memory for storing OS files and or user generated data. Additionally data processing system may be a tablet computer laptop computer or telephone device.

Other components shown in may be varied from the illustrative examples shown. For example a bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any suitable type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. Additionally a communications unit may include one or more devices used to transmit and receive data such as modem or LAN network adapter . Further a memory may be for example main memory or a cache such as found in NB MCH . Also a processing unit may include one or more processors or CPUs. Moreover illustrative embodiments may be implemented in a logically partitioned data processing system.

The depicted examples in and are not meant to imply architectural limitations. In addition the illustrative embodiments provide for a computer implemented method apparatus and computer usable program code for compiling source code and for executing code. The methods described with respect to the depicted embodiments may be performed in a data processing system such as data processing system shown in or data processing system shown in .

Illustrative embodiments provide a computer implemented method system and computer usable program code for stealing interrupt vectors from an operating system such as for example an advanced interactive executive operating system. In response to a superuser such as a system administrator with root access to a data processing system installing a kernel module on an operating system in the data processing system the kernel module allocates a contiguous block of real memory in the data processing system and copies custom interrupt handler extensions from the kernel module into the allocated block of memory. In addition the kernel module copies operating system interrupt handlers into a reserved space in the allocated block of memory from an architected interrupt vector memory location. The reserved space is located directly after each of the custom interrupt handler extension vector locations in the allocated block of memory. In response to copying the operating system interrupt handlers into the reserved space in the allocated block of memory the kernel module copies custom interrupt handlers from the kernel module over the operating system interrupt handlers in the architected interrupt vector memory location. The custom interrupt handlers after being copied into the interrupt vector memory location handle all interrupts received by the operating system.

Then in response to the operating system receiving an interrupt one of the custom interrupt handlers associated with the interrupt begins processing the interrupt. The custom interrupt handler associated with the interrupt saves basic register states and branches to one of the custom interrupt handler extensions. The custom interrupt handler extension corresponds with the custom interrupt handler. Afterward the custom interrupt handler extension determines whether special processing is required by the custom interrupt handler extension. In response to determining that special processing is required by the custom interrupt handler extension the custom interrupt handler extension continues to custom interrupt code for executing for example a test program that tests all of the data processing system s resources. Subsequently the custom interrupt handler extension returns from the interrupt.

An interrupt is a signal that indicates the need for a change in execution of a processing unit. A normal response to an interrupt signal is to begin execution of an interrupt handler at the interrupt vector. The interrupt handler saves the execution state of the processing unit and initiates a context switch. The interrupt vector is a memory address of the interrupt handler or an index into an interrupt vector table. The interrupt vector table contains memory addresses of interrupt handlers. The interrupt vector table associates the interrupt handler with an interrupt request. When a processing unit is interrupted by an interrupt the processing unit looks up the interrupt handler in the interrupt vector table and transfers control to the interrupt handler.

Illustrative embodiments allow a test program to run on top of an OS while allowing the test program access to any and or all system hardware resources such as real memory caches and registers for testing. However it should be noted that alternative illustrative embodiments may only allow a test program access to specified portions of the system s hardware resources. Illustrative embodiments provide the test program total access to a system s resources by stealing control of interrupt vectors from the OS and replacing the stolen OS interrupt handlers with custom interrupt handlers that allow the test program full access to the system. When the test program does not require custom interrupt processing the custom interrupt handler extensions simply pass control on to the OS interrupt handlers as if the custom interrupt handlers and custom interrupt handler extensions were not present. In other words the OS is not aware of the presence of the custom interrupt handlers and custom interrupt handler extensions. By incorporating certain hooks in the custom interrupt handler extensions the test program may enter any machine state and have access to all the machine s resources without the OS s knowledge. As a result a user may use illustrative embodiments to for example periodically track specific interrupts or periodically monitor processor special purpose register values of a privileged or a partition manager mode.

Illustrative embodiments consist of a software program that is in the form of a kernel module or kernel extension which a superuser installs on the OS custom interrupt handlers that replace the OS interrupt handlers and real extension code that is called from the custom interrupt vectors. It should be noted that the program developer must write the kernel module in such a way that the kernel module has knowledge of the system s hardware architecture and the OS that the kernel module will be run on.

After the OS receives an interrupt the custom interrupt handler only saves a few essential registers and then branches to the custom interrupt handler extension for that specific interrupt. The custom interrupt handler extension determines if the interrupt is taking place inside a test is being called to start a test or is being handled by the OS. If the interrupt is taking place inside a test or is called to start a test then the interrupt handler branches to code for handling these types of test situations. If the interrupt is handled by the OS then the processor registers that were previously used are restored and the execution path continues on as normal by falling into a copy of the original OS interrupt handler.

Thus illustrative embodiments allow the OS interrupt handlers to continue handling interrupts as normal when the test program is not executing a test on the system s resources. In addition illustrative embodiments let the test program run on top of the OS without the restrictions or knowledge of the OS while maintaining access to all system resources. Illustrative embodiments have an advantage over the no OS test program method because the test program does not need to worry about anything but writing test code and executing the tests as the OS takes care of the test program s memory needs and scheduling. Also illustrative embodiments may allow multiple test programs to run at the same time under the OS which may provide more versatility in system testing. Furthermore illustrative embodiments have an advantage over the specialized test OS method because illustrative embodiments do not require maintenance of another entire OS. Moreover illustrative embodiments may take advantage of all of the functionality of the existing OS.

With reference now to a block diagram illustrating components of a data processing system is depicted in accordance with an illustrative embodiment. Data processing system may for example be implemented in data processing system in . However it should be noted that the example depicted in is only intended for the purpose of illustration and does not imply any architectural limitations on illustrative embodiments. In other words illustrative embodiments may include more or fewer components and may include any components necessary to accomplish the task of stealing interrupt vectors from an OS to allow access by a test program to all system resources or any portion thereof.

In the depicted example of data processing system includes OS application programming interface API application and GUI . In addition data processing system also includes processing units and such as for example processing unit in .

OS runs on a processor such as processing unit and or and provides high level control of the components within data processing system . It should be noted that illustrative embodiments may reside on OS . For example a superuser such as a system administrator with root access to data processing system may install kernel module on OS . Kernel module is a software module that extends the functionality of a kernel thread to perform processes of an illustrative embodiment. Further kernel module includes OS interrupt vector stealing code . OS interrupt vector stealing code is code for stealing OS interrupt vectors in accordance with processes of illustrative embodiments. Kernel module utilizes OS interrupt vector stealing code to steal OS interrupt handlers at the interrupt vectors from OS to allow a test program access to any and or all data processing system resources.

After the superuser installs kernel module on OS OS interrupt vector stealing code uses its knowledge of OS and the architecture of data processing system to perform the following steps. First OS interrupt vector stealing code allocates a contiguous block of real memory that is large enough to contain all existing OS interrupt handlers and custom interrupt handler extension code. After allocating the real memory block OS interrupt vector stealing code copies the custom interrupt handler extension code into this allocated memory block with space after each custom interrupt handler extension to put the stolen OS interrupt handler for that particular interrupt.

Subsequently OS interrupt vector stealing code calls a kernel thread for every processing unit in the data processing system such as processing units and . Then OS interrupt vector stealing code has each kernel thread for processing units and execute a synchronize processing units routine. Consequently all the kernel threads sync up and disable external interrupts.

Afterward OS interrupt vector stealing code directs one of the kernel threads such as a master processing unit kernel thread to copy each OS interrupt handler from its respective interrupt vector into the allocated memory block behind the OS interrupt handler s associated custom interrupt handler extension code. Subsequently OS interrupt vector stealing code uses that master processing unit kernel thread to copy the custom interrupt handlers over the OS interrupt handlers in the interrupt handler memory locations. Then the copying kernel thread signals copying task completion to the other kernel threads. After the copying task is completed OS interrupt vector stealing code once again syncs up all the kernel threads and re enables the external interrupts. Then all but the starting kernel thread terminate.

At this point the custom interrupt handlers are in place in the interrupt vector memory locations and the custom interrupt handler extension code for each interrupt is positioned directly before the OS interrupt handler code in the contiguous block of real memory. The custom interrupt handler extension code is positioned before the OS interrupt handler code in such a way that if an interrupt is passed on to OS then the custom interrupt handler extension code restores all previously used registers and without any branch or use of a short relative branch begins executing the OS interrupt handler code as if the custom interrupt handler code and custom interrupt handler extension code never existed.

API allows a user of data processing system which may be an individual or a software routine to invoke system capabilities using a standard consistent interface without concern for how the particular functionality is implemented. Application may for example be a test program for testing hardware and or software components of data processing system . However it should be noted that application may represent any type of software application or program and may also represent a plurality of applications and or programs.

A user of data processing system utilizes GUI to interact with programs and applications residing within data processing system such as for example OS and application . GUI is a graphics based user interface that incorporates movable windows and icons which may be displayed in a display screen and manipulated by user input devices. For example GUI may be displayed in video display terminal and manipulated by keyboard and mouse in . Typically GUI is the standard way a user interacts with a computer such as data processing system .

With reference now to an exemplary illustration of copying OS interrupt handlers into a reserved memory space is depicted in accordance with an illustrative embodiment. OS interrupt handler copying process includes architected interrupt vector memory location custom interrupt vectors and contiguous real memory block . Architected interrupt vector memory location includes OS interrupt handlers for interrupt vectors one through six. Interrupt vectors one through six contain OS interrupt handlers one through six respectively. Also custom interrupt vectors include custom interrupt handlers for interrupt vectors one through six. Custom interrupt vectors one through six contain custom interrupt handlers one through six respectively.

Contiguous real memory block is a contiguous block of real memory that is large enough to store all custom interrupt handler extensions and OS interrupt handlers. In addition contiguous real memory block is contained within a volatile memory device such as for example main memory in or another random access memory RAM device. Contiguous real memory block includes custom interrupt handler extensions for interrupt vectors one through six and reserved space . Interrupt vectors one through six contain custom interrupt handler extensions one through six respectively. Reserved space is a space reserved for OS interrupt handlers one through six. OS interrupt handlers one through six are associated with custom interrupt handler extensions one through six respectively. Illustrative embodiments copy each OS interrupt handler one through six below its associated custom interrupt handler extension one through six in reserved space .

With reference now to an exemplary illustration of copying custom interrupt handlers over OS interrupt handlers is depicted in accordance with an illustrative embodiment. Custom interrupt handler copying process includes architected interrupt vector memory location custom interrupt vectors and contiguous real memory block . Architected interrupt vector memory location includes OS interrupt handlers for vectors one through six. Interrupt vectors one through six contain OS interrupt handlers one through six respectively.

Custom interrupt vectors include custom interrupt handlers for custom interrupt vectors one through six. Custom interrupt vectors one through six contain custom interrupt handlers one through six respectively. Custom interrupt handlers one through six are associated with OS interrupt handlers one through six respectively. Illustrative embodiments copy custom interrupt handlers one through six over OS interrupt handlers one through six respectively in architected interrupt vector memory location .

After illustrative embodiments copied OS interrupt handlers for vectors one through six after their associated custom interrupt handler extensions for vectors one through six in reserved space in contiguous real memory block contains custom interrupt handler extensions for vectors one through six and OS interrupt handlers for vectors one through six. OS interrupt handlers for vectors one through six are duplicate copies of OS interrupt handlers for vectors one through six respectively.

With reference now to an exemplary illustration of a final memory map after stealing interrupt vectors from an OS is depicted in accordance with an illustrative embodiment. Final memory map includes architected interrupt vector memory location custom interrupt vectors and contiguous real memory block .

Subsequent to illustrative embodiments copying custom interrupt handlers for vectors one through six over OS interrupt handlers for vectors one through six in architected interrupt vector memory location contains custom interrupt handlers for vectors one through six instead of OS interrupt handlers for vectors one through six such as for example OS interrupt handlers for vectors one through six in architected interrupt vector memory location in . Custom interrupt handlers for vectors one through six are duplicate copies of custom interrupt handlers for vectors one through six respectively. Contiguous real memory block contains custom interrupt handler extensions for vectors one through six and OS interrupt handlers for vectors one through six such as for example contiguous real memory block in .

It should be noted that custom interrupt handlers handle all interrupts. Then custom interrupt handlers branch to the associated custom interrupt handler extensions where custom handling continues if necessary. Alternatively the interrupt state is restored and OS interrupt handlers handle the interrupt as normal.

With reference now to a flowchart illustrating an exemplary process for stealing interrupt vectors from an OS is shown in accordance with an illustrative embodiment. The process shown in may be implemented in a kernel module such as for example kernel module in .

The process begins when a superuser such as a system administrator with root access to the system installs the kernel module on an OS such as OS in step . After the superuser installs the kernel module in step the kernel module allocates a block of real memory such as for example contiguous real memory block in step . Subsequently the kernel module copies custom interrupt handler extensions for interrupt vectors such as for example custom interrupt handler extensions for vectors one through six in into the allocated block of real memory step .

Then the kernel module copies OS interrupt handlers for interrupt vectors such as for example OS interrupt handlers for vectors one through six in into the allocated block of real memory each directly after its corresponding custom interrupt handler extension in a reserved space such as for example reserved space in step . However it should be noted that in an alternative embodiment step may not need to be performed if the kernel module is loaded into real memory. The kernel module may be loaded into real memory by for example performing a hack to the operating system kernel. Afterward the kernel module generates a kernel thread for each central processing unit such as for example processing units and in in the system and binds the generated kernel thread to its associated central processing unit step . Subsequently the kernel module synchronizes the kernel threads disables external interrupts in each kernel thread and then synchronizes the kernel threads again step .

Afterward each of the central processing units in the system makes a determination as to whether the central processing unit is a master central processing unit step . If the central processing unit is the master central processing unit yes output of step then the kernel module uses the created kernel thread in the master central processing unit to copy custom interrupt handlers for interrupt vectors such as for example custom interrupt handlers for vectors one through six in over the OS interrupt handlers in an architected interrupt vector memory location such as for example architected interrupt vector memory location in step . Subsequently the created kernel thread in the master central processing unit signals to the other created kernel threads in their respective central processing units that copying of custom interrupt handlers over OS interrupt handlers for the interrupt vectors is completed step . Thereafter the process proceeds to step .

Returning again to step if the central processing unit is not the master central processing unit no output of step then the central processing unit makes a determination as to whether the master central processing unit is finished copying interrupt handlers for the interrupt vectors step . If the master central processing unit is not finished copying interrupt handlers for the interrupt vectors no output of step then the process returns to step where the central processing unit waits for the master central processing unit to finish the copying process. If the master central processing unit is finished copying interrupt handlers for the interrupt vectors yes output of step then the kernel module restores external interrupts in each kernel thread and exits the kernel threads step . The process terminates thereafter.

With reference now to a flowchart illustrating an exemplary process for processing OS interrupts is shown in accordance with an illustrative embodiment. The process shown in may be implemented in a custom interrupt handler at a vector such as for example custom interrupt handler in for vector .

The process begins when an OS such as for example OS in receives an interrupt step . Subsequent to the OS receiving the interrupt the custom interrupt handler at the vector begins processing the interrupt step . Afterward the custom interrupt handler at the vector saves basic registers states step . Then the custom interrupt handler at the vector branches to a custom interrupt handler extension at a vector such as for example custom interrupt handler extension at vector in associated with the interrupt step .

After branching to the custom interrupt handler extension the custom interrupt handler extension makes a determination as to whether special processing such as for example system resource testing is required by the custom interrupt handler extension step . If special processing is not required no output of step then the custom interrupt handler extension restores the basic registers to their states at the time of the interrupt step . Then the custom interrupt handler extension short relative branches to an OS interrupt handler at a vector such as for example OS interrupt handler at vector in or just continues executing as if the OS interrupt handler is directly after the custom interrupt handler extension step . Subsequently the custom interrupt handler extension returns from the interrupt step . The process terminates thereafter.

Returning again to step if special processing is required yes output of step then the custom interrupt handler extension continues to custom interrupt code step . After returning to the custom interrupt handler extension upon completion of the custom interrupt code in step the custom interrupt handler extension makes a determination as to whether the custom interrupt handler extension continues to the OS interrupt handler step . If the custom interrupt handler extension does continue to the OS interrupt handler yes output of step then the process returns to step where the custom interrupt handler extension restores the basic registers to their states at the time of the interrupt. If the custom interrupt handler extension does not continue to the OS interrupt handler no output of step then the process returns to step where the custom interrupt handler extension returns from the interrupt.

Thus illustrative embodiments provide a computer implemented method system and computer usable program code for stealing interrupt vectors from an OS to allow a test program access to all system resources. The invention may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention may take the form of a computer program product accessible from a computer usable or computer readable storage medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable storage medium may be any tangible apparatus that may contain or store the program for use by or in connection with the instruction execution system apparatus or device.

The medium may be an electronic magnetic optical or semiconductor system or apparatus or device . Examples of a computer readable storage medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements may include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices et cetera may be coupled to the system either directly or through intervening I O controllers.

Network adapters also may be coupled to the system to enable the data processing system to become coupled to other data processing systems remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

