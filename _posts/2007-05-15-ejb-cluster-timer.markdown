---

title: EJB cluster timer
abstract: Multiple application server instances can be arranged in a cluster that implements a distributed EJB timer system. A high availability database can store EJB timer info. The EJB timer jobs can be distributed among the application server instances of the cluster that implement the distributed EJB timer system. In case of a failure of an application server instance, the EJB timer info can be used to reassign the EJB timer jobs associated with the failed application server instance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09384103&OS=09384103&RS=09384103
owner: ORACLE INTERNATIONAL CORPORATION
number: 09384103
owner_city: Redwood Shores
owner_country: US
publication_date: 20070515
---
This application claims priority to U.S. Provisional Application No. 60 747 364 entitled NEXT GENERATION CLUSTERING filed May 16 2006 and to U.S. Provisional Application No. 60 909 179 entitled EJB CLUSTER TIMER filed Mar. 30 2007 which applications are hereby incorporated by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Enterprise Java Bean EJB containers are quite popular for many types of applications. Typically EJBs are used to contain secure and persist business logic.

The EJB 2.1 Specification includes an EJB timer Application Programming Interface API . The EJB Timer API allows for the running of EJBs at predetermined times specified by the EJB Timer API. This allows the running of EJB code to be scheduled for times when the overall system utilization is low.

An application server can be a server computer on a computer network dedicated to running certain software applications as opposed to e.g. a file server or print server . Generally an application server such as the WebLogic Server available from BEA Systems Inc. of San Jose Calif. can be a software engine that delivers applications to client computers. In some cases an application server can handle most if not all of the business logic and data access of the application. Benefits of application server technology can include the ease of application development and centralization. A J2EE application server refers to an application server that can comply with Java 2 Platform Enterprise Edition J2EE standard.

An application server cluster can consist of multiple application server instances running simultaneously and working together to provide increased scalability and reliability. A cluster can appear to clients to be a single application server instance. The server instances that constitute a cluster can run on the same machine or be located on different machines. Users can increase a cluster s capacity by adding additional server instances to the cluster on an existing machine or user can add machines to the cluster to host the incremental server instances.

Some of the services of the application servers called singleton services should be run on only one application server of a cluster. These singleton services can include JMS servers transaction recovery services or any other software that should be only run in a single instance.

One way of implementing the EJB timer API is for each application server in a cluster that receives EJB timer API requests to store the EJB timer and at the time indicated through the EJB timer API will run an EJB. One downside of this implementation is that when new application server instances join the cluster they will not run any of the EJB timer jobs until they receive new EJB timer API requests. This may mean that the EJB timer jobs at the time of their execution are not well distributed. Additionally in the case of a failure of an application server instance recovery of the EJB timer jobs held by that application server instance will be relatively slow since they will need to wait for the recovery of the entire application server instance.

Embodiments of the present invention concern a distributed EJB timer system . The EJB timer information can be stored in a central location. EJB timer requests from the EJB Timer API can enter into the application server cluster . In the example of application server distances and can store the EJB timer information in a database such as high availability HA database.

One of the application servers such as Application Server can have timer master functionality. The timer master can get the EJB timer job info from the database then distribute the EJB timer jobs to the EJB timer clients at the application servers such as Application Servers and . When the EJB timer triggers for a job the local EJB pool at the application server can then set up the EJB and do the required processing.

In this example the EJB timer jobs are distributed close to their time of execution so that newly added application servers are able to get EJB jobs near their time of execution. This can mean that the EJB timer jobs as a whole will be well distributed. Upon a failure of an application server instance EJB timer jobs can be quickly reassigned to a new application server instance without waiting to recover the entire failed application server instance.

One embodiment of the present system has multiple application server instances in a cluster the cluster implementing a distributed EJB timer system. A high availability database can store EJB timer info . EJB timer jobs can be distributed among the application server instances of the cluster that implement the distributed EJB timer system. In case of a failure of an application server instance such as a failure of application server the EJB timer info can used to reassign the EJB timer jobs associated with the failed application server instance.

One of the application server instances can act as a timer master. The timer master can assign and reassign the EJB timer jobs to other application server instances. In case of a failure of the application server instance acting as timer master another application server in the cluster can be reassigned the timer master functionality.

In one embodiment the timer master functionality can be assigned to another application server by a migration master. The timer master can schedule jobs in addition to the EJB timer jobs. The timer master can maintain a timer master lease. The other application servers can request EJB timer jobs from the timer master. Each application server instance and that is a part of the EJB timer system can view all of the scheduled EJB timer jobs via the high availability database . The cluster can contain an application server instance that is not part of the distributed EJB timer system.

An application server instance can include code that allows the application server instance to form part of a cluster that implements a distributed EJB timer system. The application server instance can include code that allows the application server instance to act as a timer master and distribute EJB timer jobs to other application server instances of the cluster. In case of a failure of one of the other application server instances EJB timer jobs associated with the failed application server instance can be reassigned.

In the example of EJB timer API is used to input an EJB timer job into the cluster. In this case EJB timer job D is to be executed at midnight. The EJB timer job D information joins the information for EJB timer jobs A B and C that are also to be executed at midnight in central location .

Periodically as shown in the application server instance acting as the timer master gets the EJB timer job information from central location . The application server instance acting as the timer master distributes these EJB timer jobs for execution. Each application server that can run EJB timer jobs can request them from the application server instance that is running the timer master.

In application server instance fails. The application server instance acting as the timer master can realize that application server instance has failed and then can as shown in redistribute the EJB timer jobs B and D by obtaining them from the central location or from a local storage at application instance .

The cluster is preferably homogenous but it is possible that an application server instance of the cluster is not part of the distributed EJB timer system. The EJB timer info can indicate that the it is to be sent only to application server instances that are a part of the distributed EJB timer system

The timer master can assign scheduled jobs to other applications servers of the cluster. The application server can maintain a lease for the timer master from a lease table . The timer master can store job info for the scheduled jobs in a database. The job info can include EJB timer job info . In the case of a crash of the application server another application server of the cluster can be assigned the timer master which can use the job info to assign scheduled jobs.

The scheduled jobs can include reports such as database reports. Such reports can require a large number of database accesses and thus can take a lot of system resources. The scheduled jobs can thus be scheduled to run at an off peak time so as to not reduce the performance of other applications. The lease table can be in the database or alternately a database less leasing system can be used. The timer master can be a singleton service. The timer master can be assigned to the application server by a migration master. Other application servers can request jobs from the timer master.

Some of the services of the application servers called singleton services should be run on only one application server of a cluster. These singleton services can include JMS servers transaction recovery services or any other software that should be only run in a single instance.

A migration master can check the lease table and reassign a singleton service to a second application server of a cluster if the application server holding the singleton service such as the timer master fails to maintain the lease. The lease table can be maintained in a database or by using database less leasing.

The application server can fail to update the lease because of a crash of the first application server or the first application server can fail to update the lease because the application server is partitioned from the lease table. The application server can heartbeat the lease to maintain control of the singleton service. The singleton service can be a JMS server a timer master or any other software that should be run in a single instance.

The application servers can run a predetermined activation script before getting the singleton service and run a predetermined deactivation script after giving up the singleton service. The migration master can select the next application server to run the singleton service such as by selecting the next application server.

Clustered EJB Timer Service can be an EJB timer service that is cluster aware. Users can be able to configure the new clustered timer service or a local server based timer service. The EJB timers can be able to load balance and failover Timers for a given EJB can be accessible on all nodes in the cluster in which that EJB is deployed.

A timer need not exist in server memory unless a user requests it or it is about to expire. This is different from a timer service implementation where all timers remain in memory throughout their lifecycle. Although this will be more efficient in terms of memory usage requests to access existing timers can be relatively slower since the timers will have to be loaded from the database.

Timers for a given EJB can be accessible on any node in the cluster. Invoking getTimers on the javax.ejb.TimerService object can return a Collection of all timers in the cluster that were created for the EJB. The Job Scheduler can provide functionality to access existing timers via the TimerManager API. One API method can allow access to all timers created for a given TimerManager. This can allow access to all timers created for a stateless session bean or message driven bean deployment. EJB timers for 2.1 entity beans are different than stateless session or message driven bean timers in that an entity bean timer is tied to the primary key of the bean in which it was created. So calling getTimers from an entity bean with primary key foo will only return timers created from bean instances with that primary key. To efficiently support this case we can make use of the timer name column of the database table used by the Job Scheduler. In that column we can store a string version of the entity beans primary key hashcode. Using the TimerManager method for obtaining timers by name we can get all timers with the matching primary key hashcode. Since hashing collisions are possible this set of timers will have to be filtered to ensure they are no timers for beans with other primary keys.

EJB timers can take advantage of the Job Scheduler s load balancing and failover capabilities. With some timer service implementations if a server crashes any timers created on that server will not execute until the server is brought back up. Also once a timer is created on a server it will remain on that server for the duration of its lifecycle. The clustered timer service can take advantage of the Job Schedulers load balancing and failover capabilities to solve these problems. Timers created with the clustered timer service can automatically failover to a healthy server and timer expirations may execute on any node in the cluster to which the EJB is deployed.

If the EJB Timeout method requires transactional execution the TimerManager can be configured to start the transaction before the TimerListener is invoked. This can allow the database update that occurs after the TimerListener finishes executing to be part of the transaction. This can prevent a given timeout from committing two transactions if it is executed twice.

EJB timers may be concurrently updated by multiple threads. A local timer service implementation may prevent two threads from updating a timer at the same time. This will no longer be the case with the clustered timer service since the same timer may exist on multiple servers at once. For example it is possible for a timer on Server to be executing a timeout while the same timer on Server is executing a cancel request. Locking at the database level can prevent any data stomping issues so this shouldn t cause problems.

EJB timers can be responsible for storing the application classloader annotation. Since EJB timers will be created in the context of an application but deserialized from the database outside of this context there are potential classloader issues that must be addressed. This can be solved by storing the application classloader annotation in the database. Using the classloader annotation we can ensure the proper context classloader is on the thread before application specific classes are deserialized.

It is possible that that an EJB may not be deployed to all members of a cluster. In this case we need to ensure the TimerMaster does not delegate timer jobs to servers in which the EJB is not deployed. The TimerMaster will use the application classloader annotation to determine what servers in the cluster can service a given timer execution.

EJB timers can be removed when the application is undeployed. The timer s need not be removed during an application redeploy. If the situation arises where an application is redeployed and the Serializable class associated with active timers is changed incompatibly the timers can fail to deserialize. The serialization errors will be logged but the timers will not be removed. The user may then have to undeploy the application completely to remove the timers or redeploy their application with a compatible version of the Serializable class used by the timers.

A Job Scheduler can make the timers cluster aware and provides the ability to execute them any where in the cluster. Timers are no longer tied to the server that created them.

1. Make timescluster aware. Timers should be able to execute anywhere in the cluster and failover as needed.

2. Provide time based scheduling such as a unit based cron job type of execution within the application server cluster. Users should be able to specify things like execute this job repeatedly somewhere in the cluster. The job should run if there is at least one running member in the cluster . There is no dependency on the server that actually created the timer. The timer execution is load balanced across the cluster and is able to failover to another running member in case of failures.

A local timer can be scheduled within a server JAVA Virtual Machine JVM and lives within the same JVM forever. The timer runs as long as the JVM is alive and dies when the JVM exits. The application needs to reschedule the timer on subsequent server startup.

A cluster wide timer can be aware of other server JVM s that form part of the same cluster and is able to load balance and failover. The timer s lifecycle is not bound to the server that created it but it is bound to the lifecycle of the cluster. As long as at least one cluster member is alive the timer can be able to execute. Such timers are able to survive a complete cluster restart. Cluster wide timers are created and handled by the Job Scheduler.

Each type can have its own advantages and disadvantages. Local timers can handle fine grained periodicity in the order of milliseconds. Job schedulers cannot handle fine grained periodicity with precision as the timers need to be persisted. Cluster wide timers work well with coarse grained intervals in the order of few seconds or more. Job scheduler can be used to schedule jobs like running reports every day or at the end of every week. It can be important to run the job even if the server that created it is no longer available. Other cluster members can ensure that the job continues to execute.

1. Use customer configured database to persist timers and make them available to the entire cluster. Job Scheduler is dependent on a database and cannot function without it. Oracle DB2 Informix MySQL Sybase MSSQL are supported.

3. Submitted jobs can run anywhere in the cluster. Two consecutive executions of a job can run on the same server or on different servers. Only one server can execute the job at any given point in time.

4. Job Scheduler is dependent on Leasing. Leasing support is needed to elect the TimerMaster. Each server can also use leasing to claim ownership on the job before executing it.

6. Job Scheduler can be bound into the global JNDI tree of each server using a well defined name. The JNDI name can be weblogic.JobScheduler . Users can cast the looked up object to commonj.timers.TimerManager and use its methods to create jobs.

7. Only Serializable jobs are accepted by the Job Scheduler. Non Serializable jobs can be rejected with an IllegalArgumentException.

8. ClusterMBean can expose an attribute called DataSourceForJobScheduler that will be used to access the database. In one embodiment Job Scheduler functionality is only available with the datasource is configured.

9. In one embodiment Job Scheduler will only support schedule at fixed delay functionality. Two consecutive job executions are separated by an interval period.

10. In one embodiment only round robin load balancing of jobs is supported. Every cluster member will periodically poll the TimerMaster which is just another cluster member for ready jobs to execute. The TimerMaster will give a fraction of the total ready jobs to each member for execution.

Job Scheduler can require a database for persisting timers. All databases supported by Server Migration functionality can be supported by Job Scheduler as well.

In one embodiment the Job Scheduler only functions in a cluster. All cluster nodes can participate in executing jobs without discrimination. In one embodiment Job Scheduler will be turned on only if the DataSourceForJobScheduler ClusterMBean attribute is set to a valid data source in config.xml. Here is an example 

Job Scheduler can be looked up using the JNDI name weblogic.JobScheduler and cast to commonj.timers.TimerManager. Here is an example 

Job scheduler can use leasing functionality to claim ownership of individual timers before execution and to select a Timer Master. The Timer Master can be running on exactly one cluster member and is responsible for allocating timers to individual servers. The leasing basis can be dependent on the ClusterMBean.getLeasingBasis attribute. If the LeasingBasis is set to database then the configuration associated with database leasing can be setup just like in Server Migration. If the LeasingBasis is set to consensus then no database support is required for leasing.

Console can provide an option to set ClusterMBean.setDataSourceForJobScheduler . The data source can be inherited from server migration or session persistence during shutdown. If customers configure data source for one they should be able to reuse it for Job Scheduler functionality as well.

One embodiment may be implemented using a conventional general purpose of a specialized digital computer or microprocessor s programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present discloser as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

One embodiment includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the features present herein. The storage medium can include but is not limited to any type of disk including floppy disks optical discs DVD CD ROMs micro drive and magneto optical disks ROMs RAMs EPROMs EEPROMs DRAMs flash memory of media or device suitable for storing instructions and or data stored on any one of the computer readable medium media the present invention can include software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers and user applications.

Embodiments of the present invention can include providing code for implementing processes of the present invention. The providing can include providing code to a user in any manner. For example the providing can include transmitting digital signals containing the code to a user providing the code on a physical media to a user or any other method of making the code available.

Embodiments of the present invention can include a computer implemented method for transmitting code which can be executed at a computer to perform any of the processes of embodiments of the present invention. The transmitting can include transfer through any portion of a network such as the Internet through wires the atmosphere or space or any other type of transmission. The transmitting can include initiating a transmission of code or causing the code to pass into any region or country from another region or country. For example transmitting includes causing the transfer of code through a portion of a network as a result of previously addressing and sending data including the code to a user. A transmission to a user can include any transmission received by the user in any region or country regardless of the location from which the transmission is sent.

Embodiments of the present invention can include a signal containing code which can be executed at a computer to perform any of the processes of embodiments of the present invention. The signal can be transmitted through a network such as the Internet through wires the atmosphere or space or any other type of transmission. The entire signal need not be in transit at the same time. The signal can extend in time over the period of its transfer. The signal is not to be considered as a snapshot of what is currently in transit.

The forgoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to one of ordinary skill in the relevant arts. For example steps preformed in the embodiments of the invention disclosed can be performed in alternate orders certain steps can be omitted and additional steps can be added. The embodiments where chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular used contemplated. It is intended that the scope of the invention be defined by the claims and their equivalents.

