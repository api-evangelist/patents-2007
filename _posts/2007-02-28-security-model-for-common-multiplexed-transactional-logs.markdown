---

title: Security model for common multiplexed transactional logs
abstract: A security model is provided in a transactional logging infrastructure that is arranged as a protected subsystem built on an underlying secure file system. Files in the underlying file system used by virtual log streams are protected from direct user writes, and are written-to only through the protected subsystem that is brokered by a machine-wide principal so that virtual log files sharing the same multiplexed physical log are kept secure from each other. Log file handles and user- and kernel-mode objects are exposed to log clients through interfaces using consistent security semantics for both dedicated and virtual logs. Log clients are agnostic of the underlying secure file system and can only manipulate file system containers—abstract objects that implement the physical log and used to virtualize the file system by normalizing input/output operations—by using the interfaces brokered by the principal in the protected subsystem.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321667&OS=08321667&RS=08321667
owner: Microsoft Corporation
number: 08321667
owner_city: Redmond
owner_country: US
publication_date: 20070228
---
Transactional logging involves maintaining a transactional log that durably records a time serial history of transactions in a system. The transactional log provides information for restoring a system to a particular state in time prior to a system failure. A transactional logging system must be able to reliably and accurately restore logging functionalities after such a system failure. In some transactional logging systems log files are arranged as either real i.e. dedicated logs or virtual i.e. multiplexed logs that are presented as opaque file handles or file objects that are exposed to user and kernel mode clients.

It would be desirable to be able to preserve log file semantics including security semantics between real and dedicated log files. An objective is that log client application logic should be agnostic as to whether its underlying log is running in a dedicated or multiplexed mode. That is implementing an application with either a dedicated log client or multiplexed log client should have no impact on the application logic. A particular virtual log would therefore need to be secured against access by a user of any other virtual log stream unless such a user is granted explicit access because all virtual log streams share the same physical multiplexed log. Such security is desirable in order to prevent a pathological log client with a malicious intent from inappropriately accessing another log stream or data from containers used in the file system which underlies the multiplexed log. Accidental or inadvertent access to another log client s virtual stream and or data is also preventable with such security.

This Background is provided to introduce a brief context for the Summary and Detailed Description that follows. This Background is not intended to be an aid in determining the scope of the claimed subject matter nor be viewed as limiting the claimed subject matter to only those implementations that may solve any or all of the disadvantages or problems presented above.

A security model is provided in a transactional logging infrastructure that is arranged as a protected subsystem built on an underlying secure file system. Files in the underlying file system used by virtual log streams are protected from direct user writes and are written to only through the protected subsystem that is brokered by a machine wide principal e.g. a local system principal or a common log file system principal called a CLFS principal so that virtual log files sharing the same multiplexed physical log are kept secure from each other. Log file handles and user and kernel mode objects are exposed to log clients through interfaces using consistent security semantics for both dedicated and virtual logs. Log clients are agnostic of the underlying secure file system and can only manipulate file system containers abstract objects that implement the physical log and used to virtualize the file system by normalizing I O input output operations by utilizing the interfaces to the protected subsystem. The principal manipulates container handles to responsively direct the I O from the log clients to the underlying file system.

In an illustrative example a creator of a log file real and or virtual is the owner of the log file is provided access to the log file and its associated metadata and may add log streams to the log file. The owner is further enabled with the ability to grant permissions to others to access the log file and or add log streams. However such log file access is kept separate and distinct under the present security model from access to containers in the underlying file system. Container security is separately implemented from log file security in the protected subsystem. The machine wide principals such as the CLFS principal or local system principal are the only components in the present security model which are given the responsibility to write to containers in the underlying file system and update discretionary access to containers.

In other illustrative examples a set of assertions i.e. rules is defined to govern log file security and another set governs container file security. Security descriptors or alternatively cryptographically secure signatures which encode access control to the log files and file system containers are atomically validated and updated across multiple file system containers. In addition because log files cannot be copied or moved without going through the protected subsystem a log file import export functionality is provided.

The present security model for common multiplexed transactional logs advantageously provides for the same high level of security for multiplexed virtual logs that is enabled for dedicated logs while maintaining security semantics and application logic irrespective of whether a real or virtual log is utilized. By separating log file from file system access the protected subsystem enables log file security while preventing inadvertent or malicious access to a log through the file system.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. The benefits and advantages noted in this Summary are not intended to limit the claimed subject matter to only those implementations that contain those benefits or advantages. In addition this Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Transactional systems include database management systems messaging systems such as store and forward systems transaction managers transaction files systems and online transactional processing systems. A single logical operation on data in such systems is called a transaction. Key transactional processing properties are commonly identified by the acronym ACID which stands for Atomicity Consistency Isolation and Durability. Conforming with ACID properties generally ensures that transactions are processed reliably and durably.

One method for implementing the ACID properties involves the use of a transactional log. A transactional log may comply with the popular ARIES Algorithms for Recovery and Isolation Exploiting Semantics in which case it is called an ARIES log. Typically ARIES implements write ahead logging WAL where any change to an object is first recorded in the log and the log is written to stable storage e.g. a disk before the changes to the object are implemented. Thus changes to the object and transactions in general are capable of being rolled back or undone. Thus ARIES logs are commonly utilized in system recovery and restoration situations so that transactional systems may be brought back to the state in which they were operating before a system failure.

Turning now to the drawings in which like reference numerals indicate like elements is a simplified block diagram of an illustrative computer system such as a personal computer PC or server with which the present security model for common multiplexed transactional logs may be implemented. Computer system includes a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus or a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer system such as during start up is stored in ROM . The computer system may further include a hard disk drive for reading from and writing to an internally disposed hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD compact disc DVD digital versatile disc or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computer system . Although this illustrative example shows a hard disk a removable magnetic disk and a removable optical disk other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks data cartridges random access memories RAMs read only memories ROMs and the like may also be used in some applications of the present dynamic database memory management. In addition as used herein the term computer readable medium includes one or more instances of a media type e.g. one or more magnetic disks one or more CDs etc. .

A number of program modules may be stored on the hard disk magnetic disk optical disc ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device such as a mouse. Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers. The illustrative example shown in also includes a host adapter a Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer system is operable in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be selected as another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a single representative remote memory storage device is shown in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are often deployed for example in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the local area network through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a broadband modem network gateway or other means for establishing communications over the wide area network such as the Internet. The broadband modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules related to the computer system or portions thereof may be stored in the remote memory storage device . It is noted that the network connections shown in are illustrative and other means of establishing a communications link between the computers may be used depending on the specific requirements of an application of database memory management.

A server communicates with a plurality of client computers . . . over a network e.g. local area network as shown in . Note however that remote logging by the client computers is an optionally utilized functionality as the present security model is applicable to either local or remote logging or combinations thereof. In this illustrative example the server and clients are each implemented using a computer system that is arranged with similar features and functionalities as computer system shown in and described in the accompanying text. More specifically server is arranged to host an operating system that includes a kernel mode driver which in this illustrative example is called a common log file system CLFS driver .

CLFS driver is a component that in combination with kernel mode and user mode APIs application programming interfaces as described below provides logging services to a number of log clients in the network environment . In this illustrative example the provided logging services are ARIES compliant. However the CLFS driver and associated APIs are not limited to supporting ARIES and may be used in a variety of logging scenarios.

Log clients and N are indicated by reference numerals in . Log clients may include applications drivers threads or other units of software that use a transactional log.

Each log client is shown in as having an associated virtual log . The logs are virtual in the sense that each log client is provided with a log that appears and functions as a client s own dedicated log even though only a single common physical log is managed by CLFS driver . In this illustrative example the physical log contains multiplexed log records from the plurality of log clients . In most applications such multiplexing provides an effective method for providing robust logging services on a memory efficient basis and is thus generally preferred. Although this illustrative example uses a multiplexed physical log file the choice of usage of dedicated or multiplexed logs will typically be made according to the requirements of a specific application of transactional logging.

As shown in virtual logs and indicated by reference numerals are coupled to the CLFS driver at the kernel mode level through network connection . In addition the Nth client is commonly disposed in server and is coupled to the CLFS driver in kernel mode. The 4th client is also commonly disposed in server and is coupled to the CLFS driver in user mode. Accordingly log clients are considered kernel mode log clients and log client is considered a user mode client.

CLFS architecture functions to marshal log records generated by the log clients into virtual logs and then reliably read them back. Log records in the virtual logs are sequenced into log streams and written to stable storage in the form of log I O blocks which are buffers for the log records . The log clients are thus enabled with the ability to accurately repeat history after recovery from a system failure or system restart. In addition CLFS architecture enables user mode and kernel mode clients to create open log files expand and shrink them delete them and marshal log records to and from client defined buffers in a marshalling area. The marshalling area is an abstraction provided by APIs and to respective kernel mode log clients and user mode log clients.

Architecture is divided into user mode and kernel mode . Kernel mode is the processor access mode in which operating system components and drivers run. Kernel mode processes can directly access system data and hardware and are not restricted as are user mode processes. Performance sensitive drivers and services run in kernel mode to interact with hardware more efficiently. All kernel mode components are fully protected from applications running in user mode.

User mode is the processor access mode in which applications and subsystems run on the computer system e.g. computer system in in user mode. Processes that run in user mode do so within their own virtual address space. They are restricted from gaining direct access to many parts of the system including system hardware memory not allocated for user mode and other portions of the system that might compromise system integrity.

CLFS architecture is arranged to cleanly separate the marshalling function from the physical I O to disk. This is accomplished by maintaining a separate marshalling area for each log client with its own address space. Marshaled log I O blocks for each of the client s log files are queued for stable storage through a single shared and centrally managed log flush queue not shown . APIs and control the respective marshalling of log records into log I O blocks and the migration of log I O blocks to and from the log flush queue for kernel mode and user mode log clients.

In user mode the user mode API passes references to log I O blocks shown as a single representative log I O block in to the log flush queue managed by CLFS driver using I O request packets IRPs on a log file handle to an I O manager . CLFS driver provides handlers for each type of I O request and schedules the log I O block on the log flush queue for writing to the physical log in the proper order across all the virtual logs . Kernel mode operations are arranged in this illustrative example to bypass the I O manager and manipulate log file objects directly through the kernel mode API using an API call . Accordingly log I O blocks shown as a single representative log I O block in from kernel mode log clients are scheduled on the log flush queue.

An abstract object called a container is used to present an underlying file system such as the NTFS file system in the Windows operating system to the CLFS architecture and log clients to thereby normalize all I O operations. Containers are utilized to form the logical sequential physical log. The file system may utilize one or more file system volumes that are physically implemented on one or more hard disk drives in . Containers are used to embody the physical log utilized in the present security model as a logical single contiguous physical log . Use of the container abstraction advantageously enables any local or remote file system conforming with the Windows NT operating system I O model to interoperate as the underlying file system supporting the CLFS architecture . Such interoperability reduces the need to embed volume management functionality in the CLFS driver and streamlines the APIs and .

CLFS driver writes log I O blocks shown as a single representative log I O block into containers using IRPs . The physical log generally will comprise multiple discrete containers and the CLFS driver strings multiple containers together logically to form a single logical sequential disk extent to give the log clients a logical view of a single contiguous physical log stream.

For a given physical log all containers have the same size. A single container provides a unit of growth or shrinkage of a physical log according to the log streams feeding it. Initially at least two containers must be allocated to each log but a log client can dynamically grow or shrink a physical log by respectively adding containers to or deleting them from the physical log. Resizing the physical log involves minimal synchronization and performance overhead.

Protected subsystem exports both a user mode interface and a kernel mode interface to log clients. Operations on these interfaces are determined by permissions applied to the log client at the time it obtains the interface. The log client is arranged to be agnostic with regards to the underlying file system and is not provided with any means for manipulating the containers . The CLFS driver intercepts all I O requests from the log clients on the interfaces and and directs the I O appropriately to the underlying file system . Containers are opened and manipulated only through operations on the container object interfaces indicated collectively by reference numeral .

Within the protected subsystem the CLFS driver manipulates two types of file objects log file objects used for real and virtual logs and container file objects. The security of the log file depends on the specification of security on these two types of file objects in relationship to the log client.

User and kernel mode log clients create log files using APIs named CreateLogFile and ClfsCreateLogFile respectively. The same APIs create both real and virtual log files in both user and kernel mode and the log file named parameter is used to distinguish between the creation of a real and a virtual log file. Here a log file name consists of a real log file name and an optional virtual stream name that is unique to the real log file as shown below log virtual stream name 

A dedicated log file is created simply by specifying the real log file name component without the delimiter and the virtual stream name. Specifying log creates a multiplexed log without any virtual streams. Virtual logs may be added later by log clients with FILE ADD FILE permissions on the real log. This option is motivated by scenarios where log clients want to perform administrative functions on the log file only and not necessarily write data to the log. In cases in which a real log file administrator also wants to write to virtual log streams in a multiplexed log a full log name including an initial default virtual log stream can be specified. In this case the administrator automatically has FILE ADD FILE access to the real log file. Other log clients wishing to add virtual streams must acquire these rights explicitly.

The creator of a log file both real and virtual is the owner of the log file and has full I O access to the log file its metadata and discretionary access control. However such ownership does not mean that the creator of the log file has full access to its underlying containers. The creation APIs noted above are arranged with a security attributes parameter with which log creators explicitly may allow or deny discretionary access control to other log clients. After creation log file owners can add delete or modify discretionary access control with the APIs named GetSecurityInfo and SetSecurityInfo.

The present security model employs the following set of assertions or rules that are applied to log file objects 

Assertion 1 gives the creator of either a real or virtual log full access to the log data. The creator of the log has the ability to grant or deny any permissions whatsoever on the log to any other principal on the system.

Assertion 2 specifies the set of principals that may override the rule specified in Assertion 1 . The set includes the system principal any administrator and principals with backup restore privileges. Assertion 2 also specifies that the owner of a physical log has full access to any stream. This logically follows since whoever controls the physical log has full access to the log data and metadata at any time. Virtual log clients will therefore always have to trust the principal or log client that owns the underlying physical log but need not trust any peer owners on other virtual log streams.

Assertion 3 says that any arbitrary log client lying outside the ownership set implied by Assertions 1 and 2 must be granted child creation permissions on the underlying real log file to create a virtual log within it. These permissions are established when the real log file is created or can be granted by modifying the real log file security permissions. Note because of this assertion none of the principals belonging to the ownership set need to have initial child creation access to the real log file but may grant this permission themselves if necessary.

Assertion 4 defines the default security on a real log file as the union of Assertion 1 and the permissions inherited from the underlying file system . Inherited permissions are determined by the permissions on the file containing the log metadata called a base log file BLF as described below in the text accompanying . Assertion 5 specifies that the default security on a virtual log file is the union of Assertion 1 and the permissions inherited from the underlying physical log. Note that in both cases ownership permissions for a log file are attached to a log client creating the log file via an access control list even though the default security is inherited.

Assertions 6 through 8 specify the meaning of and conditions for null security on a log file. Note that null security where all log clients are explicitly granted access rights to a log file is distinguished from default security where no security is specified. Assertion 6 intuitively conveys the notion of null security on most file systems while Assertions 7 and 8 specify a necessary condition for secure log files. More specifically a corollary of Assertions 7 and 8 is that a log file is secure if and only if all components of its containers and its metadata are stored on a secure file system. Otherwise either the log file does not exist or it has null security.

The present protected subsystem as noted above is restrictive with access to container file objects and exclusively delegates container access to the machine wide principal e.g. either a CLFS principal or a local system principal . Accordingly the present security model also employs the following set of assertions or rules that are applied to container file objects 

Assertion A is the basis for implementing a protected subsystem. This assertion specifies that containers are opened by the protected subsystem under the context of a broker i.e. the machine wide principal on behalf of the client. In one illustrative example the CLFS driver is responsible for maintaining and managing log file containers. Assertion C qualifies Assertion B as it defines special read and delete privileges on containers for owners of a real log file to which the container belongs even though the real log file owner has no ownership on the containers themselves .

Assertion B specifies that any administrator has ownership rights over a log file container but no permissions delete the container or access data within the container. In order to perform these operations an administrator must explicitly give itself these permissions.

Assertion D specifies that no container on a secure file system ever has null or default security and Assertions A B and C will always apply and the protected subsystem remains intact.

Assertion E specifies that containers can always be backed up and restored by principals that have the appropriate backup and restore privileges respectively. Such privileges do not necessarily imply other rights or privileges are given however. Principals with backup privileges accordingly have read access to both the container metadata and its data and a principal with restore privileges has read write access to both the container data and metadata.

Because containers belong to the underlying file system their security descriptors are stored as persistent attribute data in the file system and are therefore maintained by the underlying file system. As shown a plurality of containers . . . N are used to store a physical log associated with one or more real or virtual log streams. Each container has its own security descriptor . . . N which is maintained by the underlying file system.

In addition to log file security descriptors log file metadata includes configuration data on both real and virtual log files. Part of the configuration of a real log file comprises unique container identifiers container location and the relationship among containers in a container queue. All metadata on a log file is stored in a file called the base log file BLF . The security descriptor for the BLF is maintained by the underlying file system. Thus the security descriptors internal to BLF are associated with log files while the external security descriptors i.e. security descriptors and are associated with containers.

When a log client creates a real log file for the first time it creates a BLF based on the path specified by the physical log part of the log file name. The BLF is created under the context of a CLFS principal or the local system principal on behalf of the log client. These principals are the owners of the BLF . The log client principal is not set as an owner of the BLF but will be granted permission to read or delete the BLF .

Members of the administrative group will have administrative access to change discretionary access control on the BLF but no immediate permissions to read write or delete the BLF . Creation of the BLF is atomic and the security descriptor for the BLF is maintained by the underlying file system.

As part of any log file creation real or virtual the CLFS driver creates a security descriptor for the log file giving the log client principal full access to the log and stores the security descriptor as part of the metadata file within the context of the CLFS principal or a local system principal. BLF and containers in the present security model paradigm are owned by the user that initiates their creation. In this way quota restrictions may be enforced to log file creation and log container creation. It also implies that log files may be owned by a user that is different from the owner of the BLF .

The security descriptor for the log file is maintained solely by the CLFS driver but stored as file system data in the BLF . The log client can use the administrative calls to read and change the security descriptor and therefore has complete discretionary control over who accesses the log file with the exceptions outlined in Assertion B above.

Before a log client reads or writes to the log file it must first add containers to back the data read from or written to the log. The log client must have opened a handle or log file object with write permission to the log to add or delete a container. As noted above containers are created with the same security descriptor as the BLF file. Therefore a log client owning the log file is enabled to directly read or delete a container at any time by working through the file system. The CLFS driver must guarantee that the security descriptor on the BLF is identical to the security descriptor on all containers at all times. This requires that any change in ownership of the physical log file be propagated to the security descriptor on the BLF and all other containers atomically as described below. In alternative arrangements where a cryptographically secure signature is utilized protection against unauthorized access i.e. spoofing to the BLF and or containers is further enhanced.

On opening a log file a log client implicitly supplies its principal s security token and explicitly requests the type of access permission on the log file. If the log file is not otherwise opened it must first open the BLF of the underlying physical log in containers and validate its security descriptor and those of each of the containers . Once the authenticity of the BLF and the containers is determined the CLFS driver opens all containers associated with the physical log file to check the log security token and the access type of the request against the stored security descriptor for the log file. Only after all these tests are successful is the log client given a handle or file object to the log file. If the log file is otherwise opened validation of the security descriptor is bypassed but the security token of the log client and its access types are still tested against the security descriptor of the log file. In alternative arrangements utilizing a cryptographically secure signature the cryptographically secure signature is validated in addition to the security descriptor for the BLF and containers before a log client is provided with a handle or file object to the log file.

Once a log file is open the access type of each operation on the log is tested against open attributes of the log file objects. This check determines whether or not the operation is allowed on the handle and complements authorization at the handle or file object creation time. Both types of tests must succeed for any operation on the log file to complete successfully.

The present protected subsystem operates by delegating all operations on a log file to the CLFS principal or the local system principal. These principals are the only ones given the responsibility to write containers and update their discretionary access control in the underlying file system.

The present security model maintains that the security descriptor of each container is identical to that of the BLF to thereby provide a mechanism for validating the integrity of the BLF and any container it references. Also as noted above owners of the physical log are allowed to read and delete log containers. This facilitates debugging and recovery of log files as an owner as opposed to a system principal. It thus follows that any change in ownership of the physical log must be propagated to the security descriptor of the BLF and all log containers. Any inconsistency between security descriptors would be evidence that a potentially pathological log client has attempted to corrupt a log. However it is emphasized that log files may be owned by a user that is different from the owner of the BLF as required to preserve quota protections.

Consider two log clients Uand Uon a log L owned by U. Suppose Uchanges security on the log to give Uownership rights on L. Also presume that with its new authority Uproceeds to deny Uall access to the log. If the update to security is not atomic then these operations may result in race conditions that lead to paradoxical and non deterministic semantics. Furthermore atomicity must be guaranteed across system crashes. The following algorithms check the consistency of security descriptors among the BLF and its containers and guarantee their atomicity is persistent across system crashes.

The following illustrative algorithms assume a log file L with a BLF C and n containers C C . . . Cand utilization of a cryptographically secure signature. Such cryptographically secure signature is arranged to protect the containers as well as the metadata in the BLF that if misused could enable corruption of the log or enable the user to attack the other data sources. In an alternative arrangements where a security descriptor is utilized such security descriptor may also be atomically propagated as described herein.

The containers are laid out in the container queue as a permutation C C . . . Cof C C . . . Csuch that Cprecedes Cif i 

A validation algorithm 1 below verifies this equality invariant on the container cryptographically secure signature 

Algorithm 1 first reads the cryptographically secure signature for the BLF then compares it against the cryptographically secure signature for each container in order of the container queue. If all the containers have the same cryptographically secure signature then the validation passes. However if there exists some container say C with a cryptographically secure signature Sthat differs from S the cryptographically secure signature contained in the BLF which could occur as a result of a failed or interrupted update then the cryptographically secure signatures of all containers from Conward in the container queue are updated to S. This could occur for example if there was an update in progress of cryptographically secure signatures that was incomplete. Note that on any error the validation fails with an appropriate error code for example that the log file is corrupt.

An update algorithm 2 below guarantees that if Sattempts to change to S during some interval between time t and t where t t either a S S S . . . S S the cryptographically secure signature was updated or b S S S . . . S S the cryptographically secure signature was not updated at time t .

Step 2 of algorithm 2 ensures that the equality invariant on container cryptographically secure signatures holds for the current BLF. On successful completion of Step 2 the algorithm binds the new value of the cryptographically secure signature in Step 3. Step 4 updates the cryptographically secure signatures of all containers in the container queue and guarantees atomicity of the operation on failure by rolling back to the old value of the cryptographically secure signature. Lastly Step 6 updates the cryptographically secure signature of the BLF itself again guaranteeing atomicity by rolling back to the old value of the cryptographically secure signature on failure. A simple proof of the algorithm will show that the equality invariant holds with the cryptographically secure signature of the BLF set to Sor S dependent on whether the algorithm ends in error or ends successfully.

Recall Assertion C above. This assertion establishes that owners of a real or physical log initially have the authority to read and delete containers but no authority to write to them. To write to a container the log owner must either be the CLFS or the local system principal or explicitly be given permission to do so by the protected subsystem . Also the protected subsystem always checks that the BLF and its containers are primarily owned by the CLFS or local system principal otherwise it invalidates the log as one containing a corrupted BLF or container. Typically therefore owners of a log file are able to read container data but are unable to write to containers or to the BLF during a log file copy or migration process.

Log migration therefore introduces a new requirement on the user mode log API set to include log export and import functionality. Exporting a log enables the protected subsystem to serialize all relevant BLF and container data consistently to a single file on behalf of a log file owner. Conversely export is a mechanism that allows log file owners to create a log and import its metadata and data from a serialized exported log file.

Log migration from a non secure file system to a secure file system does not present an opportunity for the underlying file system or operating system to be compromised. On a non secure file system log security descriptors are potentially exposed to unauthorized updates in the metadata file. However this can only compromise the security of the logs themselves because the present security model cleanly separates log file security from container security. Container security is maintained by the underlying file system and modification is extremely restrictive only the CLFS and local system principal have write or write control access to containers. All other principals on the system have at most read and delete access to the container. Therefore there is no means for a malicious user to transitively leverage permissions on the log security descriptors to gain unauthorized access to the file system or other secure operating system objects.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

