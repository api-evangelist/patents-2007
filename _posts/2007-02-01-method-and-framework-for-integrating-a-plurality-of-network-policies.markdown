---

title: Method and framework for integrating a plurality of network policies
abstract: A method and system is disclosed for managing and implementing a plurality of network policies in a network device. Each of the plurality of policies are defined by one or more filters. The filters are installed in a policy engine. A layer identifies the network policy to be applied to a packet by sending a request to the policy engine. The policy engine then returns the policy to the requesting layer. The method and system may be used to implement a programmable, host-based, distributed, authenticating firewall that enables security and other policies to be applied at several protocol layers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761708&OS=07761708&RS=07761708
owner: Microsoft Corporation
number: 07761708
owner_city: Redmond
owner_country: US
publication_date: 20070201
---
This application is a division of U.S. application Ser. No. 10 456 093 filed Jun. 6 2003 entitled METHOD AND FRAMEWORK FOR INTEGRATING A PLURALITY OF NETWORK POLICIES which application is incorporated herein by reference in its entirety.

The present application contains subject matter related to that of patent applications Multi Layer Based Method for Implementing Network Firewalls Ser. No. 10 456 770 Multi Layered Firewall Architecture Implemented in a Network Device Ser. No. 10 456 766 and Method for Managing Network Filter Based Policy Ser. No. 10 456 433 filed on the same day as the parent application the disclosures of which are hereby expressly incorporated by reference.

This invention generally relates to computer systems and to network security. More particularly this invention relates to a method of integrating a plurality of network policies into a single framework within a network device.

Network protocols are designed to facilitate communication between network devices through an open exchange of data. While the open exchange of data greatly enhances the use of network devices to accomplish tasks it also creates problems because network protocols are not designed for and generally do not provide network security. Computers coupled to both public and private networks such as Local Area Networks LANs Wide Area Networks WANs intranets and the Internet are susceptible to malicious attacks perpetrated by other network devices coupled either directly or indirectly to the network. Such malicious attacks include theft of data Denial of Service DOS attacks the proliferation of computer viruses and the like.

Various methods have been developed to protect network devices against malicious attacks usually through implementation of one or more network policies. One network policy is a security policy such as provided for by the Internet Protocol Security IPSec Suite. The IPSec suite provides protocols such as Encapsulating Security Protocol ESP Authentication Header AH and Internet Key Exchange and Management IKE protocol. The ESP protocol documented in Internet Engineering Task Force IETF Request for Comments RFC 2406 is an authenticating and encrypting protocol that uses cryptographic mechanisms to provide integrity source authentication and confidentiality of data. The AH protocol documented in IETF RFC 2402 is an authentication protocol that uses a hash signature in the packet header to validate the integrity of the packet data and authenticity of the sender.

The IKE protocol documented in IETF RFC 2409 provides a method for network devices to negotiate security settings used with the AH and ESP formats. The negotiated security settings form a data structure called a security association SA . The SA defines parameters such as the authentication algorithm encryption algorithm keys and the lifetime of keys used by ESP or AH to protect the contents of the IP packet. Because ESP and AH require an established SA an IKE negotiation is executed before the ESP or AH protocols are used to transmit data.

A network device identifies packets that are subject to IPSec e.g. IKE AH or ESP processing and the manner that such packets should be IPSec processed based on a security policy maintained in a Security Policy Database SPD . The security policy is a set of rules assigned to the network device that defines how to use IPSec. The security policy includes filter lists authentication methods and other information. The proper security policy to be applied to a packet is usually determined based upon the packet s source and destination IP address source and destination ports and protocol type.

Another network policy used to protect against malicious attacks is a firewall policy. The firewall policy is implemented by one or more filters. Each filter includes filter parameters and associated policy to be applied to packets that match the filter parameters. The filter parameters include information such as hardware addresses e.g. Media Access Control MAC addresses network addresses e.g. IP addresses protocol type e.g. Transport Control Protocol TCP port numbers and the like. The firewall policy in the filter identifies how packets with parameters that match the filter parameters should be treated. As a specific example the filter includes as its parameters a Uniform Resource Locator URL address e.g. http www.foo.com. The filter policy indicates that packets with that URL address should be dropped. Whenever the network device examines a packet and through that examination identifies the URL address http www.foo.com as embedded in the packet the network device drops the packet thereby preventing it from traversing the network.

Network devices also use non security related policies to control the flow of network traffic. As one example network devices implement Quality of Service QOS based policy. QOS addresses the fact that transmission rates error rates and other characteristics can be measured improved and to some extent guaranteed in advance. Packets can be expedited based on policy and reservation criteria. QOS is used for example to allocate network bandwidth for improved communications between network devices.

It is not uncommon for multiple policies e.g. security policy firewall policy QOS policy and the like to be implemented in a network device. These policies may conflict i.e. identify contradictory actions to take on the same packet. Implementing multiple network policies in a network device also makes it difficult to diagnose packet transmission problems. For example if packets are not being properly transmitted or received it is difficult to identify which of the network policies is interfering with the packets.

The invention is directed to a method and framework for implementing a plurality of network policies in a network device. The plurality of network polices are defined by a set of filters installed in a policy engine. Each filter includes a set of filter conditions an action and a policy context. The filter conditions include parameters that allow the policy engine to identify one or more filters that match a packet. The action and policy context identify the network policies that apply to packets matching the filter conditions.

A requesting layer sends a request to the policy engine with a set of parameters associated with the packet. The policy engine identifies one or more matching fibers for the packet by comparing the parameters associated with the packet to the filter conditions. The network policy is then identified from the policy context and action in the matching filters. After the network policy is identified it is executed by the network device.

In an embodiment of the invention one of the plurality of network policies is a firewall policy implemented by including as the action in the set of filters permit or block thereby identifying whether packets matching the filter conditions should be permitted to traverse layers in a network stack or conversely blocked from further network traversal.

In an embodiment of the invention one of the plurality of policies is a security policy including as the policy context data identifying the security policy to be applied to packets matching the filter conditions.

In an embodiment of the invention one of the plurality of policies is a quality of service policy including as the policy context data identifying communication settings to be applied to packets matching the filter conditions.

The method and framework of the present invention may be used to implement a programmable host based distributed authenticating firewall that enables security and other policies to be applied at several protocol layers. Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments which proceeds with reference to the accompanying figures.

A method and framework of implementing and managing a plurality of filter based network policies in a network device is described. Typical filter based network policies include security policy firewall policy and QOS policy. The plurality of filter based network policies are stored in a filter policy engine.

The filter based policies are implemented in a framework that includes a user policy engine and a kernel policy engine. The framework also includes kernel layers and user layers. The kernel policy engine kernel layers and one or more callouts execute within the kernel mode of an operating system. The kernel layers include an application layer a transport layer a network layer and link layer forming a network stack. The user policy engine and user mode layers execute in an operating system user mode along with one or more policy providers. An exemplary user layer is a keying module layer used to identify security policy. Alternatively the method and framework of the present invention executes within a single operating system mode or within one or more program modules or applications executing outside of the operating system.

The user layers and kernel layers each form a requesting layer that receive a packet and corresponding packet context data from a previous layer or system process. The requesting layer sends a request to the kernel policy engine or the user policy engine via an application programming interface API . The request includes information such as the packet received by the requesting layer the packet context and a set of layer parameters associated with the requesting layer. The policy engine processes the request and returns an action and policy context. The layer then implements the network policy according to the action and policy context.

The plurality of network policies are defined by a set of installed filters. Each of the set of installed filters includes a set of filter conditions an action and policy context. The action is used to return firewall policy such as permit or block. The policy context includes other policy such as security or QOS policy. The kernel or user policy engine processes the request sent from the requesting layer by identifying one or more matching filters. The matching filters have filter conditions that match the layer parameters and packet context.

The policy providers are used to create network policy and derive the policy from any suitable source such as volatile or non volatile memory or through a graphical user interface. The policy is a source of information for rendering a new filter including the set of filter conditions action and policy context. The user policy engine adds the new filter to the set of installed filters in the user policy engine or kernel policy engine.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a personal computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers hereto illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

In the description that follows the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computer unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.

A network environment wherein the method of implementing and managing a plurality of filter based network policies according to the present invention will now be described with reference to . The network is exemplary in nature as the method of the present invention is implemented in any network device that is coupled to any network configuration. The network environment includes a private network and a public network . The private network and public network are any suitable type such as Local Area Networks LANs Wide Area Networks WANs intranets the Internet or any combination thereof.

The network environment includes a plurality of network devices and . Network devices are coupled to the private network . Network devices are coupled to the public network . The network device is coupled to and provides an interface between both the private network and the public network . The network devices are coupled to the public and private networks using any suitable technology such as Ethernet 1394 or 802.11 b . The network devices are further implemented as any suitable computing devices such as personal computers servers handheld devices printers switches routers bridges repeaters or the like.

The network device includes a filter management module and one or more filters . The management module is a program module or a set of program modules implemented according to the present invention. The management module examines network packets exchanged between the network devices coupled to the private network and the network devices coupled to the public network . In an embodiment of the invention the management module also examines locally destined network packets sent from and destined to network devices within the private network .

The management module controls network traffic exchanged between the private network and the public network . Alternatively the management module is implemented in and controls network traffic for a single network device such as illustrated in the network device . The management module is also capable of being implemented as a centrally administered set of hosts and or edge network devices

The filters are implemented as part of the management module . Alternatively the filters are implemented as part of a separate data structure accessible by the management module . Each filter includes a set of filter conditions an action and policy context. The filter conditions are used to identify data that is subject to network policy and include information such as interface numbers hardware addresses network addresses protocol type port numbers and payload data. The action is used to implement firewall policy and indicates how the network device implementing the management module should treat packets that match the filter conditions. Typical actions include permit i.e. allow the packet to continue network traversal and block i.e. preclude further network traversal by dropping packet. The policy context is used to store information identifying other network policies such as security and QOS policies which are likewise to be applied to packets matching the filter conditions.

As used herein the term network packet or packet refers to data. The data may be formatted according to a network protocol such as IP TCP HTTP or may include a basic data stream. By comparing packet information referred to herein as packet parameters to the filter conditions the management module identifies one or more matching filters. A matching filter results when the filter conditions match the packet parameters. The packet parameters include information that is derived from the packets and includes packet context information and layer parameters. When the management module identifies a matching filter the one or more actions and or policy context associated with the filter conditions are executed.

The management module includes a user mode process and a kernel mode process . The user mode process and kernel mode process execute as part of an operating system in a network device. Those skilled in the art will appreciate that the user mode process and the kernel mode process of the operating system include additional components that for simplicity are not shown. Alternatively the management module is executed in whole or in part outside of the operating system as one or more program modules or application programs.

The kernel mode process includes kernel layers a kernel policy engine and optional callouts . The kernel mode process implements an established network policy by identifying matching filters for network packets processing packets according to known protocols and executing other actions on the packet as designated by matching filters.

In an embodiment of the invention the kernel layers form a network stack. The network stack comprises a plurality of layers including a data stream layer a transport layer a network layer and a link layer . The management module is extensible and additional layers are dynamically added and deleted as needed. An example of an added layer includes file access layer implemented according to a Server Message Block SMB protocol. The kernel mode process is preferably configured to implement firewall policy to be applied to packets traversing the kernel layers .

The kernel policy engine includes a layer API a set of installed filters and a callout API . The kernel policy engine performs various functions according to the method of the present invention including 1 maintaining the set of installed filters defining network policies e.g. security QOS firewall policy and the like 2 receiving requests from the kernel layers 3 identifying one or more matching filters based on the request and 4 instructing the layer of any action to take on the packet based on the matching filters and network policy defined therein.

The user policy engine includes a filter module . The filter module is an instance of the kernel policy engine in the user mode . The instance of the filter module in the user policy engine permits the user policy engine to replicate the services of the kernel policy engine for one or more user layers . The user layers are added in the same way that kernel mode layers are created. Because the filter module is the user mode instance of the kernel policy engine it will be understood that any functionality described herein for the kernel policy engine also applies to the filter module . For example additional user mode layers are added or deleted from the system architecture and callouts may be created thereby providing added functionality to the user mode layers. Filters defining network policy are added into the filter module and user mode layers can identify policy for packets or data matching designated parameters by sending a request to the user policy engine . While the user layers are shown executing in the operating system user mode the user layers may also be distributed in other system processes.

The set of installed filters are used to implement one or more network policies. Each filter includes a set of filter conditions an action and policy context. As described with reference to the filter conditions identify the packets that are subject to the filter policy as defined by the action and policy context. The actions specified in the set of installed filters include permit and block. The policy context is any suitable data structure used to store known policy parameters for policies such as security and QOS. An exemplary form of the filters is described with reference to .

The layer API provides an interface between the kernel layers and the kernel policy engine. Through the layer API the requesting layer requests the kernel policy engine to identify network policy to be applied to a packet.

The callouts are used to implement added functionality such as parental controls intrusion detection and the like. A callout is executed when the kernel or user policy engine identifies a matching filter for the packet that includes as the associated action a callout to one of the callout modules. Additional callouts like layers are added as needed thereby providing an extensible architecture. A specific implementation of the callout API is described with reference to .

The user mode process includes the user policy engine and one or more policy providers identified as PP PP and PP. The policy providers are processes that add network policy i.e. installed filters into the management module . Any process is used to accomplish this task. An example is a legacy IPSec policy service LIPS . The legacy IPSec policy service adds filters defining network traffic that is supposed to use Internet Protocol Security IPSec such as Encapsulating Security Protocol ESP and Authentication Header Protocol AH . As a specific example the legacy IPSec policy service adds a firewall policy indicating that all unsolicited inbound packets must be encrypted according to the ESP protocol. The policy further provides that any unsolicited inbound packet in clear text i.e. an unencrypted packet should be blocked. The policy providers obtain the policy from any suitable source such as data in volatile or nonvolatile memory or a Graphical User Interface GUI that permits an administrator or system users to directly enter policy. The user policy engine converts the policy into a new filter i.e. defines the policy in terms of filter conditions and associated actions and adds the new filter into the set of installed filters .

The management module further includes a filter engine API that forms an interface between the user policy engine and the kernel policy engine . The engine API provides a mechanism for the user policy engine to add new filters into the set of installed filters and to examine installed filters matching selected criteria for diagnostic purpose. A management API accessible by policy providers also provides a mechanism to add and remove filters from the architecture.

Each user and kernel layer is capable of receiving a packet from a previous layer module or system process. Each user or kernel layer also maintains packet context passes the packet context to a next layer or system process issues a classification request to the kernel or user policy engine and takes action on the packet according to the one or more network policies.

The packet context is a data structure that follows the packet. Each layer maintains the context by adding into the context data structure a set of parameters that the layer is designed to process or that may be derived from the packet. An exemplary data structure used for the packet context is described with reference to .

The classification request is a call by a layer requesting that any filters that match the packet be identified and any action e.g. permit or block and or associated policy context be returned to the layer. The layer issuing the classification request is referred to herein as a requesting layer. Each layer also takes the action on the packet that is returned by the kernel or user policy engine.

The management module also includes a keying module layer . The keying module layer is used to lookup network policies used with keying protocols such as the Internet Key Exchange and Management IKE protocol implemented as part of a security protocol such as IPSec. A keying module API provides an interface between the user policy engine and the keying module layer. Filters can be added to the filter module through the user policy engine defining which packets are subject to a given set of security parameters. The keying module API provides a mechanism for other processes to invoke the services of the keying module layer to identify matching installed filters that include policy context identifying the policy to be applied.

Referring to the set of installed filters which may be installed into filter module or kernel policy provider will now be described. Each filter has a plurality of fields including a filter Id a weight one or more Actions a policy context and a set of filter conditions . The filter Id provides a unique identification to the filter.

The weight field includes a value that identifies priority of the filter . The higher the value in the weight field the higher the priority of the filter. The filter priority determines the order whereby matching filters are applied to the packet by the kernel policy engine or user policy engine. Alternatively the filter is manually ordered and the weight field is optionally excluded.

The set of filter conditions determine whether a packet matches the filter . Each filter condition includes a type data and a layer Id field Id . The number of filter conditions is dynamically configurable such that a filter can include any number of filter conditions and filter conditions can be added or deleted as the need arises.

The type defines the length and number of variables included in the corresponding data . The architecture provides for predefined known variable types such as Byte Short Long 8 Bytes String Internet Protocol version 4 IPv4 Address Internet Protocol version 6 IPv6 Address IPv4 Address plus Mask IPv6 Address plus Mask and Address Range.

The data field includes data matching the type. For example if the type is IPv4 Address an acceptable value for the data field is a 32 bit number in range of 00.00.00.00 to 255.255.255.255 as expressed in dotted decimal notation. In some instances the type provides for multiple values in the data field . The Address Range IPv4 Address plus Mask and IPv6 Address plus mask types allow two IP address values defining a beginning and ending range of IP addresses. For maximum flexibility the architecture also permits user defined types. Alternatively additional types are manually added to the system architecture.

The layer Id field Id field is used to identify an originating layer and a parameter from the originating layer respectively. The originating layer and the parameter from the originating layer define packet parameters i.e. layer parameters and packet context that the data is compared against. The originating layer identifies a particular kernel or user layer. The parameter from the originating layer identifies a specific parameter associated with the originating layer. As a specific example is illustrated by filter condition . The type is IPv4 thereby indicating the data is a 32 bit IP address. The layer Id is IP representing that the 32 bit number is an IP i.e. network layer parameter. The field Id is Src IP Addr which in the example represents an IP layer parameter specifically a source IP address. The IP address provided in the data filed is 123.3.2.1 indicating that any packet with that source IP address meets the filter condition thereby matching the filter.

The action designated in the filter is permit block callout or null. If the action in the filter is permit or block and the packet matches the filter the permit or block action is returned to the requesting layer. The permit and block actions are typically used to implement firewall policy. If the action is callout the policy engine issues its own classification request that includes the full packet layer parameters context and identification of the matching filter to the designated callout module . The callout module performs its programmed function on the packet e.g. intrusion detection. The callout may return an action either permit block to the policy engine which in turn relays the action to the requesting layer. The callout is also capable of maintaining packet context that is likewise returned to the requesting layer via the policy engine .

The kernel policy engine or user policy engine also returns a policy context . The policy context is used to store policy other than firewall policy such as security policy or QOS policy. The policy context is any suitable data structure. For example the policy context is a 64 bit number that is interpreted by a process that added the policy context . The policy context in the filter may include actual policy or a value that is used by the system to map to the actual policy.

As a specific example entry includes the layer Id field Id NDIS Src. MAC Addr. NDIS represents a Network Driver Interface Specification implementation of the link layer . Src MAC addr. represents a source MAC address. Thus the layer field Id indicates that the data in the value field is a source MAC address that was processed by the NDIS Link layer. The value field includes the actual source MAC address which in the example is 00.08.74.4F.22.E5 as expressed in hexadecimal notation.

As a second example entry has a layer Id field Id of NDIS IF No. This again identifies the layer as NDIS but in this case identifies the parameter as IF No representing an interface number as the specific NDIS parameter. The value field includes the actual interface number which in this case is 2.

As a third example entry has a layer Id field Id of IP Dst IP Addr. The IP represents the network layer using the IP protocol and the Dst IP Addr represents a destination IP address as the IP layer parameter. The value field includes the actual destination IP address of 123.3.2.1. 

Having described the underlying firewall architecture attention is drawn to the functional interfaces of the system and exemplary methods that are performed using the underlying firewall architecture described herein. The functional interfaces are implemented as a plurality of application programming interfaces APIs . The APIs include the layer API the callout API the filter engine API and the keying module API as illustratively shown in and .

The layer API facilitates data exchange between the kernel layers and the kernel policy engine . By extension the methods described for the Layer API also facilitate data exchange between the user layers and the filter module and are included as part of the keying module API described below. As shown the layer API includes a Classify method an Add Layer method and a Delete Layer method .

The Classify method is used by the requesting layer to send layer parameters the packet as received by the requesting and the packet context to the kernel policy engine or the filter module . The kernel policy engine or filter module compares the 1 layer parameters from the requesting layer and 2 packet context entries to the filter conditions in each filter assigned to the requesting layer to identify matching filters. The following is an exemplary implementation of the Classify method. It will be understood that the following methods are described as receiving or returning data values. According to known programming techniques the methods may use pointers to data values instead of actual data values.

LayerId identifies the kernel or user layer issuing the classification request i.e. the requesting layer. Referring to the Layer Id identifies the layer as the data stream layer the transport layer the network layer the link layer or a user layer such as the keying module layer. Other layers are valid if added to the system.

pInFixedValues includes a subset of the layer parameters processed by the requesting layer. The pInFixedValues along with the packet context entries are compared to the filter conditions to determine if the packet matches the filter. The default layer parameters included in the pInFixedValues for kernel layers are identified in Table A below. There are no default parameters for the user layers. It will be understood that the following values are exemplary only as an advantage of the architecture is that it allows the layers to use any values accessible to that layer.

pInContext includes the context data structure as received by the requesting layer. The packet context is used in conjunction with the layer parameters to identify matching packets.

pActionType includes the action that is returned to the requesting layer. The action returned is permit block continue or null as identified in the matching filter or callout modules executed by the matching filter. As previously described the action is used to implement and identify network firewall policy.

pOutContext includes the policy context data. As previously described the policy context is used to implement network policies associated with IPSec QOS and any other non firewall filter based policy.

The Add Layer and Delete Layer methods are used to add and remove a user or kernel layer from the management module respectively. The following is an exemplary form of the Add Layer method.

pLayerId is a unique layer identification value returned to the layer being added i.e. the layer executing the Add Layer method.

In an embodiment of the invention certain layers are included in the architecture when the operating system is initiated. Examples of such layers include the link network and transport layers. Accordingly the AddExtensionLayer method is not required to include these layers in the framework. A LayerSetProperties method is provided to identify for the policy engine which fields are valid filter conditions for the layer how to calculate the filter weight and the like. The following is an exemplary form of the LayerSetProperties method 

layerProperty identifies the layer properties including the layer fields and calculation of filter weight.

The Callout API facilitates data exchange between the kernel or user policy engine and the callouts. Like the Layer API the Callout API has a Classify method. The Classify method of the Callout API is similar to the Classify method of the Layer API except that it also includes matching filter data. The following is an exemplary form of the Classify method used to execute a callout.

fixedValues includes the layer parameters sent from the requesting layer. The fixedValues is the same data provided by the requesting layer in pInFixedValues data sent as part of the Classify method in the layer API .

wfpContext includes the context data structure . This data is the same as sent by the requesting layer in the pInContext sent as part of the Classify method in the layer API .

packet includes the entire packet as received by the requesting layer. This data is the same as sent by the requesting layer in the pPacket sent as part of the Classify method in the layer API .

matchedFilter identifies the filter requesting the callout. Typically the matching filter is identified by the filter Id of the matching filter initiating the Classify method of the callout API .

pActionType includes the action that is returned to the kernel or user policy engine from the callout . If the pActionType is Permit or Block it is returned to the requesting layer as the pActionType returned by the Layer API . The callout can also return a Continue action that instructs the policy engine to continue applying matching filters to the packet.

The callout API also includes the Notify method . The Notify method is used to notify a callout when a filter is added to the set of installed filters that identifies as one of its Actions the callout module . The Notify provides the callout with an opportunity to take any required action such as allocating or de allocating buffers that will be used by the callout when it is executed by the policy engine . The following is an exemplary form of the Notify method .

notify includes a numerical value that indicates whether the filter is being added or deleted. For example a value of 1 indicates the filter is being added and a value of 2 indicates that the filter is being deleted.

filter identifies the filter being added or deleted by unique value. This may be accomplished by providing the Filter Id included as part of the filter . The callout API also includes a Callout Registration method and Callout Deregistration method to add and remove callout modules respectively. An exemplary form the Callout Registration method is as follows 

callout provides any callout specific information such as a driver service name device name and pointers to the callout classify and notify functions.

sd provides a security descriptor for the callout. The security descriptor identifies which processes can and read and delete the callout.

The filter engine API facilitates data exchange between the user policy engine and the kernel policy engine. As shown the filter engine API includes an Add Filter method a Delete Filter method and an Enum Layer method .

The Add Filter and Delete Filter methods are used to add a new filter to the set of installed filters and to delete an existing filter from the set of installed filters respectively. The following is an exemplary form of the Add Filter method .

The Enum Layer method provides a mechanism for the user policy engine to identify all filters matching a set of criteria. This allows the management API to identify conflicting filters for filter arbitration and conflict resolution. The following is an exemplary form of the Enum Layer method .

pEnumTemplate includes a data structure defining the filters to be returned. For example it include parameters that the filter conditions must match for the filter to be returned.

The keying module API provides an interface between user mode keying module layers and the user policy engine . The keying module API includes an IPSec SA Acquire method an Expire Notify method and an IPSec SA Acquire Complete method a Keying Module Register method a Keying Module Deregister method an IPSec Inbound Get SPI method an Add Inbound SA method an Add Outbound SA method an Inbound SA Expire method and a Keying Module Initiate method . The keying module API may also include the methods previously described for the layer API.

The keying module API is used to facilitate use of known security protocols such as defined by IPSec used by an initiating computer user or service and a responding computer user or service. IPSec includes protocols such as AH and ESP. The ESP protocol is an authenticating and encrypting protocol that uses cryptographic mechanisms to provide integrity source authentication and confidentiality of data. The AH protocol is an authentication protocol that uses a hash signature in the packet header to validate the integrity of the packet data and authenticity of the sender.

The IKE protocol provides a method for an initiating computer and a responding computer to negotiate security settings used with the AH and ESP protocols. The negotiated security settings form a data structure called a security association SA . The SA defines parameters such as an authentication algorithm encryption algorithm keys and the lifetime of keys used by ESP or AH to protect the contents of an IP packet. Because ESP and AH require an SA an exemplary method is to use an IKE negotiation before the ESP or AH protocols are used by the initiating and responding computer. Alternatively the SA can be manually created. A given SA is identified by a value known as a Security Parameter Index SPI .

Each of the initiating and responding computers include an IPSec driver and classification module that determine based on an IPSec policy whether data sent between the initiating and responding computers requires encryption or authentication. The IPSec policy is a set of filters that defines how the network device uses IPSec and includes filter lists authentication methods and other information. In an embodiment of the invention the IPSec policy is defined by filters included in the set of installed filters in the kernel policy engine or the filter module . The policy that applies to a packet is identified by invoking the keying module layer which uses the Classify method to identify matching filters.

The IPSec SA Acquire method is called by the user policy engine via a client proxy to pass a driver acquire or an external initiate request to the keying module layer. The keying module layer returns this call and does the negotiation asynchronously. Once the keying module layer has completed the negotiation the keying module layer calls the IPSec SA Acquire Complete method to notify the user policy engine that the negotiation is complete. The following is an exemplary form of the IPSec SA Acquire method.

acquire includes the necessary information for negotiating the SA according to known protocols such as IKE.

The Expire Notify method is called to pass an expire notify to the keying module layer that added the inbound SA. The following is an exemplary form the Expire Notify method.

expireNotify contains information identifying the expiring SA. For example in the case of an outbound SA the SPI is provided.

The IPSec SA Acquire Complete method is called by a keying module layer to close the user policy engine s context after it has finished negotiation and added all the SAs or after it has come across an error. After this method is executed the keying module layer does not reuse the ipsecContext for any other API method. The following is an exemplary form the IPSec SA Acquire Complete method.

status provides status and other details of the SA negotiation. The status is returned by the user policy engine if the acquire was externally initiated via FwpKeyingModuleInitiate0.

The Keying Module Register method is called by a keying module layer to register with the user policy engine and pass its function pointers. The following is an exemplary form of the Keying Module Register method.

keymodInfo includes registration information about the keying module layer such as pointers to process IPSec SA Acquire and process IPSec SA Expire functions.

The Keying Module Deregister method is called by the keying module layer to deregister the keying module from the user policy engine . The following is an exemplary form of the Keying Module Deregister method.

The IPSec Inbound Get SPI method is called by the keying module layer to obtain the SPI for a new inbound. SA. The IPSec Inbound Get SPI method is usually used when the keying module layer executes in a responding network device. The following is an exemplary form the IPSec Inbound Get SPI method.

ipsecTrafficDescription is a 5 tuple description for creating an inbound larval SA. The 5 tuple includes source and destination IP addresses source and destination ports and transport layer protocol type.

udpEncapInfo is UDP encapsulation data for creating the larval SA. UDP encapsulation is a known method of embedding a packet formatted according to a security protocol into an unencrypted UDP packet.

The Add Inbound SA method is called by the keying module layer to add an inbound SA i.e. update the larval SA. The user policy engine uses the SPI in the SA to map this call to its internal state and ioctl the SA down to the IPSec driver. The following is an exemplary form of the Add Inbound SA method.

The Add Outbound SA method is called by a keying module layer to add an outbound SA. The user policy engine uses an inbound SPI parameter to map this call to its internal state and ioctl the SA down to the IPSec driver. The following is an exemplary form the Add Outbound SA method 

The Inbound SA Expire method is called by the keying module layer to expire the inbound SA that was previously added. The following is an exemplary form the Inbound SA Expire method .

Wherein the following characterizes the recited parameters. enginehandle is the handle to the user firewall engine .

The Keying Module Initiate method is called by known external application like RAS Winsock API and the like to initiate the keying module layer and setup SAs before an application starts sending its network traffic. The user policy engine asynchronously pends the RPC call gets the SPI from an IPSec driver and passes the acquire to the appropriate keying module. Once the keying module layer calls FwpIPSecSAAcquireComplete0 the user firewall engine completes the asynchronous RPC with the negotiation status. The following is an exemplary form of the Keying Module Initiate method.

waitEvent is a handle to an event that is triggered when negotiation status is available. If a client i.e. calling external application is not interested in waiting for the negotiation to complete it can set this parameter to NULL. Internally the client proxy optionally passes this event to RPC and request it to set the event once the asynchronous RPC call completes.

negotiationStatus includes an outcome of the negotiation. The negotiationStatus is NULL if waitEvent is NULL. Otherwise negotiationStatus remains valid until the waitEvent is triggered.

The first requesting layer may be a user mode layer such as the keying module layer or a kernel layer such as one of the layers in the network stack. The first requesting layer communicates with the policy engine via the layer API.

The request e.g. a classification request using the Classify method includes the layer parameters the packet context and the full packet as received by the requesting layer . The policy engine uses the layer parameters and the packet context to identify any matching filters from the installed filters . Typically the policy engine applies filters in order of the weight specified by the matching filters. The policy engine then returns values including an action and the policy context . The action is used to return firewall policy such as permit or block. The policy context is used to return other policy such as security or QOS policy. The returned action and policy context are indicated as none or null where the filter does not include corresponding policy.

The first requesting layer may interact with a second requesting layer . This occurs when the requesting layer is a kernel layer in the network stack. The first requesting layer may update the packet context with the layer parameters processed by the requesting layer. The first requesting layer also may process the packet according to a layer protocol. The requesting layer passes the modified packet context to the second requesting layer . The requesting layer also passes the packet after it is processed according to the layer protocol. For example if the first requesting layer implements the IP protocol it processes the packet according to the IP protocol. The first requesting layer then passes the packet to the second requesting layer which in the case of an inbound packet is a transport protocol layer and in the case of an outbound packet is a link layer. The second requesting layer may then repeat the process by sending a classification request and receiving returned action and policy context values.

In step the requesting layer identifies the layer parameters. The layer parameters are the parameters to be used in combination with packet context to identify matching filters. The default layer parameters are described above in Table A and are included in the pInFixedValues of the Classify method .

In step the requesting layer issues the classification request to the kernel or user policy engine. An exemplary method of issuing classification requests was described with the reference to the Classify method in the layer API .

In response to the classification request an action and policy context is returned to the requesting layer as shown in step . The requesting layer determines based on the returned action whether to drop the packet . If the policy engine returns block as the action then the requesting layer drops the packet. The requesting layer may also drop the packet if the policy engine returns the action as no matching filters found. As previously described the action is used to implement firewall policy. If the matching filters do not include firewall policy the returned action may be none or null.

Steps are normally only carried out when the requesting layer is a layer in the network stack but are optionally carried out by user mode layers. If the returned action is permit further packet processing occurs. In step the requesting layer modifies the packet context to include layer information typically the same type of information that was included as the layer parameters in the classification request. Thus Table A above not only identifies the layer parameters but also the default information added by each layer to the packet context. The packet context is maintained in a data structure such as the data structure described with reference to .

In step the requesting layer processes the packet according to the protocol implementation for that layer. Such processing is well known and need not be described in detail herein. Exemplary protocol implementations include HTTP FTP SMTP and RPC for the application layer TCP and UDP for the transport layer IP for the network layer and NDIS for the link layer.

In step the requesting layer passes the packet processed according to the layer protocol along with the modified packet context to a next layer. The process is repeated by each layer and continues until the packet traverses all layers in a series of layers e.g. the layers in the network stack or until the packet is dropped by one of the layers.

Referring to a method used by the kernel or user policy engine to identify matching filters and return the action and policy context to the requesting layer will now be described. In step the policy engine receives the packet layer parameters and packet context from the requesting layer via the appropriate API.

In step the policy engine identifies one or more matching filters. In an embodiment of the invention filters are assigned to a particular requesting layer. The policy engine only attempts to identify filters as matching if the filter is assigned to the requesting layer and the packet parameters match all filter conditions . As previously described the packet parameters include both layer parameters from the requesting layers and the packet context. After all matching filters are identified the policy engine orders the filters based on the weight field in each matching filter. Alternatively filters are not assigned to a particular requesting layer and all filters may be a matching filter.

In step the policy engine applies the filter with the highest weight field that has not yet been applied. Specifically the policy engine identifies the action specified in the filter and the policy context. If the action designates a callout module the policy engine executes the callout. The callout may return an Action to the policy engine.

If the action was not callout or after the callout is executed the policy engine returns an associated action and policy context from the matching filter or as identified by the callout to the requesting layer as shown in step . Alternatively the policy engine waits to execute step i.e. return the action until all matching filters have been applied.

In step the policy engine determines if any additional matching filters exist. If not the process terminates. If additional matching filters do exist the process returns to step where the next highest priority filter is applied. The process continues until all matching filters are applied. Alternatively the process terminates once a terminating action is identified for the packet. An action type may be defined as a terminating action. By default permit and block are terminating actions. If no matching filters are identified for the packet the policy engine notifies the requesting layer that no matching filters were found.

In step the filter is assigned a weight value by the user policy engine. The weight value is assigned by the policy provider e.g. manually by a user via the policy provider GUI. Alternatively the user policy engine automatically calculates the weight value. The kernel policy engine uses any suitable method to calculate weight. For example filters with more specific filter conditions are given higher weight values than less specific filters. More specific filters have filter conditions that match a smaller number of potential packets. For example a filter that includes a single IP address as its filter conditions is more specific than a filter that includes a range of IP addresses as its filter conditions.

In step the user policy engine compares the new filter to each of the installed filters assigned to the same layer to identify any conflicts. To conflict the filters must share a common set of filter conditions such that they will act on the same packet and identify different actions. For example if the filter condition for the installed filter is a source IP address in the range of 123.4.0.0 to 123.4.0.100 with an associated action of permit and the new filter has filter condition with source IP addresses in the range 123.4.0.50 to 123.4.0150 with an associated action of block the new and installed filter overlap to the extent both filter conditions include the IP address range 123.4.0.50 to 123.4.0.100.

If the filters conflict the user policy engine resolves the conflicting using any suitable technique as shown in step . A method for calculation of filter weight and identifying and resolving filter conflicts is described in copending U.S. patent application Ser. No. 10 456 433 entitled Method for Managing Network Filter Based Policy . The new filter may be added to the set of installed filters as part of the conflict resolution process. If the new filter does not conflict with the set of installed filters the new filter is added into the set of installed filters either in the user policy engine or the kernel policy engine as shown in step .

If the new filter is loaded into the set of installed filters any callouts that are executed by the filter i.e. the callouts are included as an associated action in the filter are notified as shown in step . An exemplary method of notifying the callout was described with reference to the Notify method described as part of the callout API .

All of the references cited herein including are hereby incorporated in their entireties by reference.

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. The present invention can be used to manage and execute filters and filter based polices of these and additional processes. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

