---

title: JMS provider with plug-able business logic
abstract: The invention provides plug-in framework, enabling embedding of content-based processes to in a messaging paradigm provider service. In the preferred embodiment, the messaging paradigm is JMS and the invention provides a plug-able framework embedded in a JMS Provider. The plug-able server is particularly suited for efficient and secure transmission of real-time, streaming data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161168&OS=08161168&RS=08161168
owner: Metafluent, LLC
number: 08161168
owner_city: Warrenville
owner_country: US
publication_date: 20070314
---
This application claims priority from U.S. provisional application 60 783 369 of the same title and by the same inventors filed Mar. 18 2006 the entirety of which is incorporated by reference as if fully set forth herein.

The invention generally relates to the field of streaming data over a network and more specifically the automating of business processes driven by real time information.

Many integration systems for streaming and static data over a computer network or over the Internet exist already. Approaches may be found within several areas of integration middleware extract transform load ETL enterprise application integration EAI enterprise information integration EII and domain specific middleware like a financial market data system or RFID middleware.

In the last decade client server systems for static data integration have increasingly favored locating logic to the extent possible on the server rather than the client. Loading logic on the server lowers costs shortens time to market and reduces long term risks. Integration vendors have continued this trend by introducing products that perform more integration on application servers and leave less to developers of client applications.

Current data integration systems do not provide for streaming data the same quality available for static data nor for system integration of mixtures of streaming and static. Currently available integration products for streaming data force application developers to implement a great deal of logic related to content acquisition and transformation. This logic implementation costs application developers a great deal of time and money in both the short and long term. Moreover to the extent that some streaming data integration products try to simplify the developer s task such simplification is achieved by putting logic into the API Application Programming Interface . However putting logic in the API forces developers to use proprietary APIs and proprietary APIs become harder to maintain on a variety of platforms as the APIs evolve to incorporate more business logic.

What is needed is a flexible way for an integration system to acquire transform and distribute streaming data as well as a means for the integration system to support standards e.g. Java Message Service JMS . What is also needed is a means to shift the burden of content integration from the client side application to the server infrastructure.

Financial services firms have information intensive business processes that consume information from a large variety of sources both internal and external. Much of the data they consume is related to activity in the financial markets and therefore updates continuously while the markets are open. These firms also generate information and distribute it within their enterprise and with external business partners.

A major financial services firm will develop hundreds or thousands of different software applications that consume manipulate and perhaps publish data from one or more data sources. Each of these applications is designed to perform some specific business function ranging from graphical display for users to fully automated algorithmic trading.

Financial services application are typically complex by virtue of interaction with multiple streaming and static data sources as well as the rapid update of continually changing information. A large scale application for example may consume data relating to hundreds of thousands of different financial instruments and absorb tens or hundreds of thousands of updates per second. Currently proprietary technology data integration systems meets the specialized need of the industry requiring high development costs poor integration of the proprietary with the larger mainstream is a chronic problem.

Financial services firms must constantly improve their ability to exploit market place opportunity to remain competitive. Streaming data integration is critical. The ability of developers to rapidly provide new software to serve a particular business need is a vital aspect of preserving productivity and shortening time to market. What is needed is a system and method for integration of streaming data that provides data virtualization flexible transformation customer controlled as opposed to vendor dictated or proprietary data models and standards based interfaces. Further needed are a method and system capable of simultaneously integrating multiple disparate data sources both streaming and static as well as executing high through put low latency deployment of data to subscribers clients applications inter application messaging and transactional messaging. And a data integration system providing dynamic tailorability of subscription permissions and improved resource allocation in service of deployment are needed.

The invention provides computer implementable methods via hardware or software comprising a plug in server framework. The inventive plug in framework supports different implementations of JMS functionality e.g. normal JMS functions such as inter application messaging with transactional capabilities and also the gateway type functionality provided by many JMS Providers that give access to other middleware . The inventive framework further supports embedding of domain specific business logic or messaging implementations into the server e.g. in the market data domain market data subscription management and content based permissioning.

The preferred embodiment includes a JMS Provider JMSP implementation comprised of a JMS client library and a supporting Server application that supports plug in implementations of the JMS messaging paradigm as well as mechanisms that allocate and manage connections and sessions with JMS clients and which activate the appropriate plug in when a topic or queue is requested according to the namespace mappings that have been configured.

The preferred embodiment further provides interfaces that define the abstractions to be implemented by each plug in e.g. factories destinations subscribers and publishers.

An implementation of the inventive protocol uses many fewer bytes than the commonly used protocols used to support JMS MapMessage. By sending field name and type information as needed once only rather than in each message the inventive method reduces the resources required to process messages on both the JMS Provider server and on the JMS client reduces the network bandwidth required and also the CPU utilization to allocate and reclaim the memory used for storing the field names.

The invention further provides a plug in that implements the standard JMS messaging behavior as described in the JMS API specification as well as a plug in that provides JMS topic based publish subscribe applications with access to real time streaming content and that utilizes an optimized MapMessage protocol as described above.

The invention according to the preferred embodiment provides a series of plug ins including but not limited to a plug in that implements a bidirectional gateway to TIBCO Rendezvous messaging a plug in that implements a bi directional gateway to other JMS providers a plug in that provides a bi directional gateway to subscriptions for Reuters Market Data System. The invention according to the preferred embodiment further provides a plug in that accomplishes load balancing based on the topic or queue namespace as well as a plug in that provides load balancing based on server load.

Subscription management. A specific example of the benefits of embedding business logic in the server is in subscription management. The invention provides the ability to embed a content provider into the server that can then efficiently manage the life cycle of streaming real time content subscriptions. In order to conserve total system resources publishers of high volume streaming data typically strive to publish only the data that subscribers have specifically requested and to stop publishing when there are no longer any subscribers for the data.

Implementing this principle using a previous JMSP requires business logic to be layered on top of JMS. Logic is required to notify publishers when downstream users are interested in a particular topic meaning that the publisher should start publishing that topic and when all users have stopped subscribing to the topic so that the publisher should stop publishing to the topic . This was accomplished by creating topics to which subscribers publish and publishers subscribe in order to communicate that the subscriber has started subscribing. It also required heartbeat topics on which subscribers send periodic messages to publishers ensuring them that they are still actively watching the data topic to which they have subscribed and preventing the situation where a subscriber exits without unsubscribing to a topic and the publisher believes the subscriber remains active forever.

The invention taught herein enables the JMS Provider to internalize this sort of subscription management logic thereby relieving publishers and subscribers of this burden. This greatly simplifies the total system and vastly improves its efficiency. Through use of a Managed Content Plug in that publishes content rather than requiring a publisher to use the JMS publishing interface the JMS Providers can use information about which subscribers have subscribed to which topics in order to start and stop publishing as appropriate thereby most efficiently using resources within the JMS Provider itself as well in other deFApendent systems.

Application Context. The invention provides Application Contexts that are specific to a given type of application thereby overcoming some disadvantages of traditional JMS Providers that use the same namespace and resources for all sessions. When for example an application change requires restructuring of the topic namespace all subscribers must change simultaneously or two versions of the system must run in parallel consuming redundant resources. Likewise if two clients want the same information but with different qualities of service e.g. one demands very low latency which is resource intensive while the other is happy with higher latency that must be incorporated into the topic namespace separate topics must be created for each quality of service for every topic that may be requested . The invention provides an Application Context that provides a sandbox of resources that are specific to a given type of application including plug in configurations and any dependent configurations such as content descriptions etc.

The inventive Application Context makes it easier to extend the functionality of the server while protecting existing applications from change. For example a new version of an application can maintain backward compatibility with applications associated with the old sandbox while supporting the new topic namespace for applications in the new sandbox. 

Furthermore the relevant Content Adapter can serve both Application Contexts from the same resources CPU memory . The Application Context mechanism also provides the means to manage the allocation of key resources such as CPU and bandwidth to different types of applications and deliver the throughput and latency characteristics required for each type of application.

Content based Permissioning. The invention provides efficient and effective secure authorized user access to any piece of content by internalizing the ability to check content based permissions through a Managed Content Plug in.

Conventional JMS Providers can permission on topic name only and requires the system administrator to maintain a permissions lookup database for all topics. When the universe of topics is large and or dynamic maintaining an up to date database that is readily accessible to every relevant JMS Provider may not be feasible or cost effective.

This is especially true when permission mappings are determined by an external provider e.g. market data vendor . In such a case it is better to derive the permission requirements from the content itself. However only the publishing application has content knowledge in conventional JMS Providers and implementing Content based Permissioning in such a case requires the application developer to create and system administrator to manage a Rube Goldberg esque approach requiring the client and server to exchanges multiple messages regarding each topic request. Ultimately this does not prevent knowledgeable unauthorized users from accessing the data. Thus efficient performance of content based control mechanisms by means of embedding a content provider in the server is another example of the benefits of the invention.

The invention also provides a set of software interfaces and protocols that support authentication and authorization of downstream users with respect to data subscription and publication using modular authorization mechanisms that can vary from one type of data to another.

The invention also provides a computer implementable means for performing streaming data management as between a data source and a data receiver comprising a session oriented client server architecture and streaming data integration logic providing streaming data subscriptions across multiple servers.

The preferred embodiment of the invention provides a plug able JMS architecture including a modular and extensible mechanism to insert domain specific implementations of the JMS messaging paradigm into a server based JMS provider infrastructure also referred to herein as a JMS server plug in model . The preferred embodiment further provides a protocol optimized for streaming content management. The preferred embodiment also provides a means for load balancing of content supporting scalability of the system.

Co pending patent applications by the same inventors entitled System and Method for Integrations of Streaming and Static Data and Content Aware Routing of Subscriptions for Streaming and Static Data elaborate embodiments of the inventive system and method taught herein. Both co pending applications claim priority from U.S. provisional application 60 783 369 filed Mar. 18 2006 the entirety of which and the entirety of the two co pending applications are incorporated by reference as if fully set forth herein. The examples of the invention herein are as the invention applies to the financial services market. However the invention may be implemented in other markets where high volumes of dynamic data data integration messaging and transactions are important.

The invention includes a networked and computer implemented system and as can be appreciated by those of average skill in the relevant art the invention includes a memory device capable of storing instructions to direct a computer as well as apparatus operable to store receive and implement instructions from a memory device. The invention is not limited to the code language used or to any hardware software or firmware embodiment but is intended to cover all manners of performing the invention and configuring the inventive system.

The inventive architecture of a client server system according to the invention is presented first followed by an elaboration of a JMS API implementation as a preferred embodiment of the invention. Included in this discussion are inventive aspects including system and method of integration of streaming data and content aware subscription routing which are each the subject of companion patent applications in their own right.

For convenience of the reader an effort has been made to discuss figures in the order presented as well as use of a numbering scheme permitting easy reference to inventive elements depicted in different figures. However the drawings figures and depictions are to enhance understanding and not to limit the invention. Defined terms are capitalized. Other terms have their ordinary meaning in the respective art unless stated otherwise. Moreover it is understood that the invention is not limited by the specifics of the particular implementation of the invention including the coding language or configurations peculiar to such elective expressions.

Term usage and definitions. In describing the invention many terms are used according to common usage and understanding. To aid in the understanding of the invention we define a selection of terms used in describing the invention.

Application Context The collection of Context objects used to allocate the Components for a given Client Application.

Atomicity atomic change. from database terminology meaning all or nothing for transactions . As used herein atomic change is multiple changes to individual fields grouped as a discrete event associated with a larger unit of content. Example the coupling of discrete data e.g. bid and ask values such that in the event of a change affecting one of the couple updates downstream propagate only when both discrete data in the couple have been updated.

Chained Events Events relating to Managed Content that are induced within the scope of an atomic update event by other changes to Managed Content e.g. a mid price is the mean of the bid and ask values and will change when either the bid or ask change.

Client Application An application that interacts with the inventive architecture via some type of distribution protocol or programming interface e.g. a JMS application or an HTTP application browser .

Client Library In a client server JMS Provider architecture the client side library that implements the JMS API.

Client Network Connection In a distributed client server implementation of the architecture the client side manifestation of a network connection between client and server.

Component an object an instance of some class or an object with references to other closely related objects. Simple components provide a specific type of service to other components complex components combine many other components directly and indirectly to provide many different services and a high level of functionality. Example 1 a component may provide a simple encapsulation of a JDBC connection or even a pool of JDBC connections. Example 2 a JMS server implementation is a component that uses many other components to support remote JMS client applications. Components have a life cycle i.e. they need to be initialized when they are created and also need to know when to release any resources they use that are no longer needed. The component lifecycle is managed by the Component Framework.

Component Framework A collection of software interfaces and associated implementations whose function is to assemble and initialize Components. The Component Framework manages component lifecycle allocates and stores components for use by other components.

Content Adapter A Component whose function is populating and maintaining fields values in one or more Content Instances. A Content Adapter functions to interpret external data events and apply such external data event to such Content controlled by that Content Adapter.

Content based Permissioning function of application access control by comparing permission required for a particular Content Instance to permissions associated with the User credential user identifier supplied by application multiple permissioning paradigms are supported as a permission paradigm is assigned to each Content Instance. Content Integration Framework provides the ability to authenticate on the basis of the Content Instance rather than on the basis of topics or names as in for example standard JMS .

Content Cache A set of Content Templates where each Content Template provides access to one or more Content Instances.

Content Instance An object comprised of discrete primitive values or fields which may refer to another Content Instance a document a unit of Content. A change in the state or the data associated with a Content Instance is an event.

Content Integration Framework In the abstract the set of Components providing access to Managed Content with a Component Framework.

Content Life cycle A process driven by the Content Template comprising the procedure and supporting software interfaces by which a Content Instance is allocated initialized maintained or updated and finally released.

Content Linking A mechanism expressed in meta data and also at run time by which one Content Specification refers to another and such that Content Instances resulting from a Content Specification with linking meta data contains a navigable link Content Link such that a Distribution Adapter can access data from an arbitrary depth of Content Instances linked in this manner. Content Linking allows the re use of meta data and the re use of run time resources.

Content Specification Meta data a description used by a Content Template to define the structure of a Content Instance and to initialize one or more Content Adapters. In the preferred embodiment a Content Specification is an XML document.

Content Template An object that uses a Content Specification and Content Adapters to create and maintain a Content Instance. A Content Template is parametized such that different parameter values allow for the creation of different Content Instances. A Content Template caches all Content Instances it creates.

Context An interface part of the Component Framework providing access to Components responsible for allocating initializing and caching Components for use within the application.

Datafeed A source of streaming data from an external system e.g. a feed from the New York Stock Exchange NYSE or from the Options Price Reporting Authority OPRA .

Data Model a collection of Content Specifications as defined by a customer in a particular deployment of the architecture.

Distribution Adapter A Component whose functions are to encode and distribute Managed Content to downstream applications and also to receive data publishing events from downstream applications and apply such events to Managed Content.

Embedded Connection In an embedded implementation of the architecture the connection between client and server sessions.

FAST an acronym for FIX Adapted for STreaming and FIX is itself an acronym for Financial Information eXchange protocol.

JMS Java Message Service a standard Java programming interface see java.sun.com products jms javadoc 102a index.html .

Mapping Plug in A JMS Plug in whose function is to map publish and subscribe requests to other Plug ins based on a configured set of expressions against which topic and queue names are matched.

Plug able Component oriented implementations on a server wherein dynamic configuration of Components permit flexible plug ing in of different implementations of any given application server paradigm.

Plug able JMS Component oriented implementations on a JMS API supporting simultaneous different implementations of JMS functionality.

Plug in JMS Plug in A Component whose function is to provide a specific implementation of the JMS messaging paradigm. For example the Standard JMS Plug in provides a typical JMS messaging implementation whereas the Managed Content Plug in supports publish subscribe access to Managed Content and a Mapping Plug in maps messaging Destinations to other Plug in by partitioning the namespace of Destination names.

Reference Data Static data relating to market data e.g. information as might appear in an annual report.

Schema a rule set that governs how a type of data content is specified. The rule set may be an industry standard or where no standard exists defined by the system architecture. The preferred embodiment uses XML eXtensible Markup Language for specifications and XML Schema to define the rule set.

Server Application A collection of one or more Contexts and Components where a Component is an object an instance of some class and a Context provides access to Components.

Server Network Connection In a distributed client server implementation of the architecture the server side manifestation of a network connection between client and server.

The invention as generally depicted in a generalized framework for client server systems provides an architecture optimized for real time subscription to static and streaming data content integration and distribution. The JMS implementation receives input from a variety of streaming and static data sources including middleware e.g. MDS TIBCO RV JMS MQ Series as well as reference data and enterprise data not depicted . As depicted in a JMS implementation of the invention provides a Component Framework . Within the Component Framework a Content Integration Framework including Content Adapters Content Specifications Content Templates and Managed Content . The Content Adapters by way of example include Datafeed Adapter Database Adapter Analytics Adapter MDS Adapter MQ Series Adapter JMS Adapter RV Adapter . The Component Framework also includes Distribution Adapters . Examples of Distribution Adapters are depicted including JDBC Distribution Adapter MQ Series Distribution Adapter MDS Distribution Adapter SMTP Distribution Adapter SOAP Distribution Adapter HTTP Distribution Adapter . The preferred embodiment includes JMS Provider which can be understood to include the Component Framework with the exclusion of the Distribution Adapters .

Client Applications may access data from the Content Integration Framework using a variety of different protocols. For each type of distribution protocol the architecture provides a different type of Distribution Adapter. The function of a Distribution Adapter is to expose content and content related events to interested client applications that use a particular distribution protocol. Distribution Adapters provide a mechanism by which data and or events can be exchanged between the Content Integration Framework and downstream applications. The capabilities of different Distribution Adapters are largely a function of the underlying protocol and not all protocols have the same level of utility. Distribution Adapters can integrate with mechanisms including but not limited to a JMS server plug in as in the current invention standard JMS providers proprietary messaging middleware such as IBM WebSphere MQ and TIBCO Rendezvous SOAP Web Services Notification http get post JDBC and ODBC interfaces flat files SMTP SMS SIP JSP and ASP interfaces relational databases specialty databases such as KX Systems KDB VhaYu Velocity Financial Information eXchange FIX FIX Adapted for Streaming FAST proprietary market data systems such as the Reuters Market Data System IBM WebSphere Front Office and the Wombat Distributed Ticker Plant.

The JMS Provider is characterized by a modular architecture comprised of a variety of plug ins or modules which serve as extensible mechanisms to insert domain specific implementations of the JMS messaging paradigm into a server based JMS Provider infrastructure also referred to herein as a JMS server plug in model . Such plug ins depicted include by way of illustration JMS Distribution Content plug in Std JMS plug in Redirect plug in RV plug in JMS Plug in MDS Plug in MQ series plug in and Mapping Plug in .

The JMS Provider also includes a Server Session a Server Network Connection and a Client Network Connection . Further depicted in are the embedded connection the Client Session and the JMS API .

Java Message Service JMS is an industry standard programming interface for a message based communication between client applications. A Client Application written to this standard should be compatible with any implementation of the JMS API or in JMS terminology any JMS Provider . Briefly JMS Client Applications exchange messages using either topics or queues each being a type of destination. Topics provide the means for one or more message publishers to reach one or more subscribers in what is known as the publish subscribe paradigm where a message from a publisher goes to many subscribers. Queues provide a request response paradigm as is typically used in a client server relationship. Conceptually a message sent via a queue goes to a single receiver which may or may not respond to the sender depending on the application level protocol.

Plug able JMS. The inventive architecture system and method provide a JMS architecture that uses a component oriented or plug able implementation of its server. The plug able implementation supports simultaneous different implementations of the JMS functionality. For example the inventive JMS implementation provides a plug in that offers typical JMS functionality as defined by the standard in which applications send messages to one another using either the topic or queue messaging pattern. It also provides plug ins whose function is to route JMS messages to and from other middleware infrastructures. This plug in architecture also allows a JMS provider according to the invention to deliver certain application level services and integration capabilities that would otherwise be impractical with typical JMS architectures such as in particular providing a specialized plug in that operates as a Distribution Adapter for real time content.

The plug in mechanism is also configurable and extensible meaning that the specific set of plug ins deployed is determined at run time and can be extended over time. Because the mapping of topic and queue names to plug in implementation is configurable developers or system administrators can manage the destination namespace and assign specific names or name hierarchies to a particular type of plug in.

Another inventive aspect is an ability to provide Application Contexts that are specific to a given type of JMS client application. A typical Client Application has at least an implicit dependency on a set of topics or queues destinations that it uses. It is also dependent on message protocols and message semantics associated with those destinations. A destination map and its plug in configurations adapter specifications content definitions etc. therefore constitute a set of resources upon which a client application depends. All resources associated with client connections and sessions are allocated via a particular Context associated with the client session. The Application Context approach makes it easier to extend the functionality of the server while protecting existing client applications from change. The Application Context mechanism also provides the means to manage the allocation of key resources such as CPU and bandwidth to different types of client applications and deliver the throughput and latency characteristics required for each type of client application.

Several representative configurations of the inventive architecture are discussed hereinbelow. The preferred embodiment uses a JMS API and the term JMS Provider also referred to as Provider means a representative implementation of the invention.

The JMS Provider targets Client Applications that engage in publish subscribe activities using real time market data. Using standard JMS functionality and paradigms Client Applications based on the inventive JMS Provider can access streaming market data via standard JMS topic subscriptions. Through a single topic Client Applications can access content that may originate from one or more sources of both static and dynamic content and may include inline analytics. Client Applications can also subscribe to complex collections ordered or not by various criteria. Using topics from the Provider Client Applications can also publish content to other applications using the Provider and also to applications using other types of enterprise middleware or a dedicated market data system MDS .

In the example provided herein the Provider supports market data semantics such as image update data streams and data condition advisories. In the preferred embodiment market data semantics are conveyed using JMS Message properties including a Message Type property a Status property a Data Condition property a Text property a Data Stream Identifier property and also Next and Previous Stream Identifier properties.

The Data Condition property indicates that data is either Stale meaning the current data values are suspect or OK. The Status property can have values of OK Access Denied supporting Content based Permissioning Closed supporting dynamic collections of multiple data streams whose membership may change over time or Invalid i.e. cannot be serviced for some reason . The Text property conveys informational text for human consumption. The Data Stream Identifier provides the means to differentiate multiple streams of data delivered on a single destination. The Next and Previous Stream Identifier properties provide the means to convey order on a collection of data streams.

In addition to market data publish subscribe activities Client Applications can also use standard JMS messaging functionality to interact with other applications.

From an implementation perspective the Provider consists of a programming library used by JMS client applications and various server configurations. Servers represent a deployment of the Component Framework including the Content Integration Framework and some combination of Components that provide authentication and authorization content and middleware integration and distribution using the inventive protocol depicted in .

A Provider according to the invention can deliver high volumes of updating data using minimal CPU. It is horizontally scalable and supports various types of load balancing content aware routing across servers to provide efficient use of system resources. Data architects and client application developers have full control over the data model and its representation in JMS and can also manage the quality of service provided to a particular type of client application.

Integrating content from new data sources is simple and may require no additional coding in the Client Application. IT managers manage run time resources including underlying sessions and connections CPU memory etc and make trade offs between latency and throughput for different classes of Client Applications as well as managing the underlying resources and data providers. Because Client Applications are insulated from naming and data model dependencies systems administrators are free to choose between multiple data sources or vendors. The Provider offers both topic and content field level access control for publish subscribe activities. Reporting tools provide a full audit trail of publish subscribe capabilities and activity.

In alternate embodiments not depicted the architecture may be embedded or of a hybrid character. Moreover the use of the Content Integration Framework is not restricted to JMS distribution.

In the preferred embodiment a RMDS Value Added Server not depicted comprising the Component Framework and the Content Integration Framework in conjunction with an RMDS Distribution Adapter delivers advanced content integration capabilities to the installed base of RMDS applications. In its simplest form it serves as a feedhandler providing symbology mapping and a customizable transformation of feed data to the RMDS data representation. It can also serve as a highly flexible analytics server that consumes data from various sources including RMDS and republishes integrated value added content to RMDS consumer applications. The Value Added Server exposes content collections as RMDS marketfeed chains. Data architects and application developers have full control over the data model and its RMDS representation. New content and analytics can be added without programming. The Value Added server integrates with DACS the RMDS entitlements mechanism.

The invention is discussed hereinbelow from a logical view discussing various design packages according to the preferred embodiment. Select figures are presented for illustration as an aid to understanding. It can be appreciated however that the text should be sufficient for the practitioner of average skill in the programming art.

Referring to the com.tbd.dcontent.adapter package extends the basic Data Model with new abstractions and implementations to support different types of Content Adapters. This package provides primitive types for storing and updating dynamic content. It also defines the models abstractions and conventions for the Component lifecycle content state management and content access control.

The following interfaces support the Content Adapter lifecycle AdapterResource abstraction represents a Content Adapter Component that needs to be initialized and released. Instances of AdapterResource are allocated and registered with an instance of DynamicContent during the document initialization phase. RunnableResource abstraction is an extension of AdapterResource that provides lifecycle support for thread aware adapter resources i.e. those that need to be started after initialization is complete and stopped before resources are released. AsynchronousResource abstraction is an extension of AdapterResource used by adapters that retrieve content asynchronously. Adapters that fit this pattern implement the AsynchronousResource interface and register themselves with their containing DynamicContent instance during initialization. The state of a document is affected by the state of any constituent instances of AsynchronousResource. Once these elements are synchronized then the document is also synchronized.

Interfaces and classes in the com.tbd.dcontent.adapter package provide the primitives for dynamic content providing storage for primitive values and support for bi directional content modification are as follows 

MNumeric MString and MBoolean interfaces provide the abstractions for mutable versions of primitive types. The setXXX operations of the above classes have a Boolean argument in addition to the value argument. The Boolean argument indicates whether or not the new value is contributed meaning that a downstream client application is setting the value. Content Adapters that accept contributed values create sub classes of the appropriate MutableXXX class and override the setXXX method to intercept the contributed values. These values can then be passed on to upstream systems.

MutableDouble MutableFloat MutableLong MutableShort are concrete implementations of the MNumeric abstraction are chosen by Content Adapter designers depending on storage design requirements. MutableString class provides a concrete implementation of the MString abstraction. MutableBoolean class provides a concrete implementation of the MBoolean abstraction. DynamicObject abstraction provides an implementation of the EventTarget construct.

DynamicString DynamicNumeric DynamieBoolean are concrete implementations of the DynamicObject abstraction implement MString MNumeric and MBoolean respectively and provide event propagation wrappers around primitives of type MString MNumeric and MBoolean. Content Adapters may install primitives of this type in a DynamicContent instance however these types use more memory than the equivalent MutableXXX primitives because they allocate storage for the event propagation mechanism. DynamicContent will automatically wrap a MutableXXX field in the appropriate DynamicObject implementation if an event target for that field is requested. For this reason a Content Adapter should typically install a MutableXXX primitive and always use the index driven setter methods of DynamicObject to update the value of a field rather than modifying the field itself. DynamicContent can then handle the event propagation calls if necessary.

DynamicContent implementation of InstanceContent provides the storage and state management for a particular set of dynamic content primitives fields associated with a Template . Content Adapter Components associated with a particular instance of DynamicContent use it to Register adapter resources for lifecycle management and access control Register adapter resources for data state management Publish content values and updates Receive contributed values from downstream Client Applications Preserve atomicity of data change events Nest content.

Downstream Components e.g. Distribution Adapter Components use an instance of DynamicContent to Perform read and write contribution access checks Access current values for all fields Receive atomic notifications regarding data updates Receive notifications regarding data state events Contribute values Access nested content. Both Content Adapters and downstream Components such as Distribution Adapters use the Template associated with an instance of DynamicContent for meta data and navigation. In the case where Content Linking is used the inventive architecture adopts a convention within the XPath expression of using character is used to delimit boundaries across linked documents for example root a link a root b link b root c value. Note that it is possible to analyze an XPath expression and compute a result expressed as a sequence of indices corresponding to the target nodes for each component of the XPath. This means that having computed the index path values can be quickly access by index rather than repeating a potentially expense XPath analysis.

AccessControlledResource is an abstraction that represents resources within a document Content Instance that require authorizations for read or write access by a Subject. Content Adapters that provided access controlled resources should provide an implementation of this interface in particular those whose function relates to Content based Permissioning.

DataSource is an abstraction representing a remote data source. Its function is to expose the state of the remote data source to Distribution Adapters. As an implementation of EventTarget it generates events corresponding to state changes in the data source. Distribution Adapters can then efficiently convey state changes for all content derived from that source.

DataSourcePool is a simple repository of DataSource implementations. The package com.tbd.dcontent.auth provides the interfaces and class for content access authorization based on numeric codes. Using this paradigm an administrator assigns numeric codes to content and assigns access rights to users based on those codes. The abstraction for code based authorization mechanisms CodeBasedAccessController extends com.tbd.security.auth.SubjectAccessController interface. CodePermission is an implementation of java.security.Permission granting or denying access based on numeric values.

The com.tbd.dcontent.list package has a single interface and provides an abstraction for sources of content collections lists . The DocumentListSource abstraction represents a source of document lists presented as a java.util.Iterator. A request for a list is qualified with a set of parameters passed as a java.util.Map. The com.tbd.dcontent.list.db package provides a database implementation of the list source abstraction. DBDocumentListSource is a database implementation of the DocumentListSource abstraction. DBDocumentListIterator is an iterator implementation it traverses a result set from a database query.

DBDocumentListSourceXMLPrototype is specialization of XMLPrototype that configures an instance of DBDocumentListSource.

The package com.tbd.dcontent.util provides the following TokenBasedParameterGenerator see extracts the values for a collection of name value pairs parameters from a tokenized string Parameter a named entity that extracts as its value one or more tokens from a specific position in a sequence of tokens MappedParameter a specialized implementation of Parameter that maps the value extracted from a tokenized string to a value from a different namespace of values with the help of a NameMapper NameMapper an abstraction providing the means to map a value from one namespace of values into a value from a different namespace. The following discussion in conjunction with describes some exemplary Content Adapters in more detail. The package com.tbd.nca.basic contains a Content Adapter that provides some primitive dynamic content fields as well as a mechanism for linking one Content Instance with another Content Linking .

The JMS Server according to the preferred embodiment. In the current embodiment the package javax.jms contains the standard JMS interface. As the standard JMS interface is well known it is not set forth here. Inventive aspects of the preferred embodiment are set forth below.

The package com.tbd.jms.client provides the preferred implementation of the standard JMS programming interface supporting both Topic and Queue destination types. The discussion below focuses on the inventive features of the preferred embodiment and relies for background on the commonly understood properties of JMS. The invention is further discussed in patent applications by the same inventors cited in the introduction.

In the preferred embodiment ConnectionImpl an abstract class is the base implementation for the JMS Connection abstraction. A Connection is a logical connection concept defined by the JMS model. The preferred embodiment of the invention extends implementation of this concept first to separate the logical connection from the physical implementation and second to allow a single logical connection to comprise multiple physical connections to one or more remote servers.

The separation of physical connections and sessions from the logical representation supports various types of load balancing in which different destinations are assigned to different servers see .

When creating a Connection a client application may specify the host and port specifically or may rely on the connection factory in deciding where to connect. The implementation according to the preferred embodiment provides an extension that allows the client application or factory to provide a list of possible host port server end points InetSocketAddress . ConnectionImpl will try each of these in turn and attempt to establish an initial physical connection an instance of NetServerConnection . A ConnectionImpl also caches dictionaries used for optimized MapMessage encoding and decoding. This optimization is support by some server side plug in implementations. The cache dictionaries is built dynamically as entries are sent by the server on an as needed basis.

The SessionImpl abstract class is the base implementation for the JMS Session abstraction. A SessionImpl corresponds to the logical session defined by the JMS model. The TBD implementation extends this concept to separate the logical session from the physical implementation and allows a single logical session to comprise multiple physical sessions attached to one or more remote servers. The physical sessions are each represented by an instance of NetServerSession. An instance of SessionImpl creates and caches Destination instances.

NetServerConnection this class represents a physical connection to a remote server. It implements the standard Java Runnable interface and provides the execution loop that processes inbound and outbound messages for that particular physical connection. A NetServerConnection establishes the physical socket connection and authentication with a server synchronously i.e. during initialization it performs blocking I O and waits for a response from the server. The positive acknowledgement from the server will include a list of destination level permissions for the authenticated user.

A NetServerConnection supports one or more sessions with the server each of which is represented by an instance of NetServerSession. Connection initialization is synchronous the connection passes credentials to the server and waits for a response. The connection also caches the instances of destination read write permissions for the authenticated subject by creating a list of instances DestinationPermission. The permission data is sent by the server as part of a successful initialization sequence. A ConnectionImpl also caches the meta data for destinations that use a compressed MapMessage protocol.

NetServerSession A NetServerSession represents a physical session established with a remote server and is the main focal point of all session level messaging. As a client application creates consumers and publishers NetServerSession enables the flow of messages between client and server and routes messages to and from the server and any consumers and publishers in the client application.

DestinationImpl is an abstract class that is the base implementations of the Destination abstraction. An instance of DestinationImpl caches instances of MessageConsumer and MessageProducer and for client applications that consume messages by polling implements a message queue.

MessageProducerImpl class interacts with a SessionImpl on behalf of a client application end point that produces messages. MessageConsumerImpl class interacts with a SessionImpl on behalf of a client application end point that consumes messages.

TopicConnectionFactoryImpl an implementation of TopicConnectionFactory creates instances of TopicConnectionImpl. TopicConnectionImpl a specialization of ConnectionImpl provides a connection for topic based communication. TopicSessionImpl an implementation of SessionImpl provides the functionality to create concrete instances of topic specific abstractions i.e. Topic TopicSubscriber and TopicPublisher. TopicImpl an extension of DestinationImpl provides a concrete implementation of the Topic abstraction. TopicSubscriberImpl an extension of MessageConsumerImpl provides a concrete implementation of the TopicSubscriber abstraction. TopicPublisherImpl an extension of MessageProducerImpl provides a concrete implementation of the TopicPublisher abstraction.

The EventListener interface represents a Component interested in receiving events from some event source. DataSourcePool is a simple repository of DataSource implementations an abstraction representing a remote data source whose function is to expose the state of the remote data source to Distribution Adapters see . The ActiveComponent interface represents Components that require explicit initialization and release via start and stop methods.

The Connection class represents a remote JMS client API connection. It authenticates client credentials and allocates instances of Session corresponding to session created in the client API. A Connection instance performs the read write operations for all its Session instances.

A Connection authenticates a client using a Connection.CredentialsCallbackHandler . Authenticated clients receive a list of destination permissions obtained from a JMSPermissionStore . Clients can then perform destination level authorization Permission without contacting the server.

A Connection uses a SessionFactory to allocate sessions and retrieves that SessionFactory from a particular Context . If the client application does not specify a Context a default is applied. A Session allocates all resources from that Context effectively providing an Application Context that can isolate the resources for one session from other sessions. A Connection uses the login framework defined by the Java Authentication and Authorization Service JAAS . When a client connection is created the server creates a login Context whose implementation is determined by configuration. The JAAS mechanism uses a callback construct Connection.CredentialsCallbackHandler to obtain the credentials required for a particular login domain. In this case the server satisfies the call back requests using initialization data passed by the Client Application. The login Context LoginContext will perform validation of credentials. Possible implementations of the login Context include trivial no credentials required database stored name password operating system name password and distributed mechanisms such as Kerberos. After successful authentication the JAAS framework provides an authentication Context or Subject that is retained by the Connection.

Connection.ReadWork Connection.WriteWork are implementations of Runnable provide scalability by allowing a Connection to delegate I O activities to an Executor ExecutorWrapper class is a wrapper around an instance of java.uti.concurrent.ThreadPoolExecutor. The wrapper is a configurable Component exposed for management with JMX. By virtue of being a Component it allows an executor to be shared among multiple Components. 

The SessionFactory class encapsulates the configuration for a session. All sessions created by a particular SessionFactory have an identical configuration. The Session class manages requests from the client API for consumption and production of messages. Based on demand from the JMS client application to consumer and or produce messages it locates instances of Destination by name using a DestinationFactory an abstraction. It then obtains instances of MessageConsumer and MessageProducer as appropriate.

A Session uses the JAAS run as construct initiate consumer and producer requests from clients using the Subject associated with the session s Connection. This identity is then available to the plug in implementations for authorization purposes. The Session provides an audit trail that logs identity host name time and activity type for subscription start stop and publication start stop activities.

Session.EnableConsumeWork and Session.EnableProduceWork implementations of Runnable provide scalability by allowing the Session to assign these activities to an Executor. Session.EnableConsumeAction and Session.EnableProduceAction implementations of the standard Java PrivilegedAction interface encapsulate consumer and produce requests in the identity of the requesting clients and allow a plug in to perform authorization of client activity. SessionConsumerInterest SessionProducerInterest are discussed with .

The JMSPermissionStore abstraction represents a repository of JMSPermission that provides the list of permissions for a specific identity. JMSPermission represents consume and produce privileges for a single destination name or a pattern of destination names. The package com.tbd.jms.server.pug ins.model defines the abstractions and base implementation classes that comprise the modular implementation of the JMS server. Depictions can be seen by reference to and as noted. The Destination interface represents the abstraction for a JMS messaging destination. Destinations can be either topics or queues. In this architecture there can be many different implementations of the Destination abstraction. Each JMS plug in provides a different type of implementation. The DestinationFactory interface represents the abstraction for creating destinations. A Session uses this interface to allocate instances of Destination. The DestinationCache interface represents a collection of Destination instances. Destinations use this interface to release themselves from cache when there are no longer any producers or consumers for that particular destination. The MessageConsumer abstraction provides the means to route message from a Destination to a particular remote message consumer via a Session and Connection .

SessionInterest an abstraction represents the interest of a Session in a particular Destination for either consumption or production of messages. A SessionInterest retains the unique identifier associated with a particular Destination on a given client Session.

SessionConsumerInterest is an implementation of SessionInterest represents the interest of a Session in consuming messages from a particular Destination. For each JMS client API consumer either a TopicSubscriber or a QueueReceiver the SessionInterest uses the Destination to allocate a corresponding MessageConsumer instance. SessionProducerInterest is an implementation of SessionInterest represents the interest of a Session in producing messages for distribution to consumers.

Plug able Logic Framework. The preferred embodiment provides a plug able framework. Certain plug ins of the preferred embodiment are discussed herein by way of example and description of inventive aspects. The server includes a plug in that provides standard JMS functionality for both Topics and Queues providing transactional capabilities and supporting persistent messages. The discussion assumes familiarity with commonly understood standard JMS functionality.

The plug in configuration handles the mapping of topics to instance documents or to templates. An instance mapping associates a specific named topic with a specific named document. A template mapping uses tokens extracted from the topic name to generate the template parameters.

The preferred embodiment provides a mechanism that maps topic name tokens to alternate values and provides the means to reference the same stream of market data with multiple symbologies For example a client application using a Reuters Instrument Code RIC might use the topic equity.ric.IBM.N while a client application using the Committee on Uniform Securities Identification Procedures CUSIP number might use the topic equity.cusip.459200 10 1.NYSE .

From the perspective of the Data Model the XML content plug in coupled with an implementation of JMS adapter is a type of Distribution Adapter. Referring to the XMLDestination is implementation of Destination allows a consumer to receive events generated by dynamic content . It also allows producers SessionProducerlnterest to modify i.e. contribute to dynamic content. The XMLTopic is a topic centric implementation of XMLDestination. The JMSAdapter is an abstraction for a Component that maps dynamic content to a JMS protocol. The XMLMessageConsumer is an implementation of the MessageConsumer abstraction. The XMLTopicSubscriber is a topic centric implementation of XMLMessageConsumer. The XMLTopicFactory is an implementation of SimpleDestinationFactory that allocates instances of XMLTopic . It interprets a topic name to generate the parameters using the TokenBasedParameterGenerator necessary to instantiate dynamic content from a particular Template It associates a JMSAdapter instance with the content and associates the adapter with the an XMLTopic. The JMSAdapterFactory is an abstraction for Components that allocate a particular type of JMSAdapter.

Another plug in com.tbd.jms.server.plug ins.list maps a collection of content to a single JMS topic relying on JMS Adapter instances to map content to a specific JMS protocol. When a client application subscribes to a topic mapped to this type of plug in it receives multiple streams of data messages each associated with a different document instance. The plug in accesses the list of documents through list source abstraction and associates each document provided by the list source with an adapter instance. A number of different implementations of the list factory abstraction are possible including lists generated by data vendors and lists generated by database queries.

Marketfeed encoded content is mapped to a JMS map message protocol by a plug in com.tbd.jms.server.plug ins.mf a useful mechanism to expose RMDS Marketfeed content to JMS client applications. Further included are plug ins that a provide implicit conversion of TIBCO Rendezvous messages to Topics with a MapMessage protocol b provide implicit conversion of arbitrary JMS providers to Topics and Queues in the preferred embodiment c provides implicit conversion of IBM MQSeries queues to Queues according to the preferred embodiment.

Protocol. As depicted in the invention provides a method for transmission of data between a client side of the JMS provider Client and a server side JMS provider Server where said data is represented to JMS client applications as JMS MapMessages and where the protocol comprises the steps of 

In the inventive architecture the use of a Destination Specific Dictionary enables message optimization as follows 

When this protocol is applied in the context of the a Distribution Adapter associated with the Content Integration Framework or other Plugins the result is a highly efficient distribution protocol that minimizes packet sizes and the processing required to encode transfer and decode messages. For example the meta data that describes the mapping of Managed Content to the MapMessage protocol can order the fields such that fields that update more frequently are represented early in the bitmap whereas those that update less frequently or not at all are represented later in the bitmap thereby reducing the size of the bitmap sent with updates.

Consider that without this mechanism of the inventive architecture each MapMessage would have to convey the name type and value of each field in each message.

Content Aware Routing. Notable is the subscription load balancing performance provided by the invention in a preferred embodiment. Various plug ins supports various types of destination level redirection or load balancing. For additional discussion please refer to the companion patent application cited in the introduction. As depicted in RedirectorDestinationFactory a specialization of SimpleDestinationFactory creates instances of RedirectDestination and has a reference to some implementation of the Redirector abstraction. RedirectDestination an implementation of Destination uses the Redirector from the factory to redirect all consumers and subscribers. The Redirector abstraction encapsulates different types of redirection algorithms. StaticRedirector is an implementation of Redirector configured to redirect requests to a specific host port and Context. When combined with a Mapping Plug in this implementation is useful for partitioning servers based on the destination namespace so for example content can be partitioned across multiple servers. Further the LoadBalancingRedirector implementation of Redirector monitors a pool of JMS provider implementations that provide equivalent capabilities and redirects requests to different providers based on relative load. The load balancer and the servers communicate using peer group middleware such as JGroups peer to peer communication with a TCP IP transport JGRPS the servers use JGroups to publish their load factor.

JMS Server Application Configurations. In the preferred embodiment Server applications defined by this architecture are collections of Components. Runtime configuration governs the precise makeup of a server application. The only required class is an instance of com.tbd.application.Application which uses command line parameters to create an initial Context with a specified resource search path. From that Context the Application then bootstraps itself to create the top level Components in the system. The Context initializes these Components which in turn need other Components and so on. If the Components created during initialization allocate threads then the application runs until all those threads terminate.

Concluding remarks. The examples of the invention herein are as the invention applies to the financial services market. However the invention may be implemented in other applications where high volumes of dynamic data data integration messaging and transactions are important. The scope of the invention is not limited to the examples or the description of the preferred embodiment as other embodiments within the scope of the invention will be apparent to those of skill in the related art.

