---

title: Managing memory resident objects to optimize a runtime environment
abstract: Systems and methods for optimizing memory management in a runtime environment are provided. The method comprises monitoring one or more objects loaded into primary memory of a computing system to determine if at least a first object can be removed from the primary memory; instantiating a proxy object to replace the first object in the primary memory; removing the first object from the primary memory; and monitoring calls to the proxy object to determine whether the first object is invoked by a process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865901&OS=07865901&RS=07865901
owner: International Business Machines Corporation
number: 07865901
owner_city: Armonk
owner_country: US
publication_date: 20070521
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The owner has no objection to the facsimile reproduction by any one of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyrights whatsoever.

Certain marks referenced herein may be common law or registered trademarks of third parties affiliated or unaffiliated with the applicant or the assignee. Use of these marks is for providing an enabling disclosure by way of example and shall not be construed to limit the scope of this invention to material associated with such marks.

The present invention relates generally to computing systems and more particularly to a system and method for implementing logic code that can improve performance in a computing system by intelligently utilizing annotations embedded in the logic code.

In a runtime environment it is desirable to monitor and manage the executable code loaded in memory for various logical objects because if the memory space occupied by the objects exceeds a certain threshold system performance may suffer.

Self healing software systems may be designed to overcome such problems and to improve overall system behavior by monitoring system performance and providing a solution to the detected problems. While the current self healing systems can monitor certain runtime events to detect one or more problems such systems cannot obtain sufficient information about the events or the context within which the problems arise to provide an optimized solution.

Therefore self healing methods and systems are needed that can overcome the aforementioned shortcomings by providing means to understand the nature of the detected events and the context in which the problems arise so that an optimized solution can be selected.

The present disclosure is directed to a system and corresponding methods that facilitate optimizing memory management process in a runtime computing environment.

For purposes of summarizing certain aspects advantages and novel features of the invention have been described herein. It is to be understood that not all such advantages may be achieved in accordance with any one particular embodiment of the invention. Thus the invention may be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages without achieving all advantages as may be taught or suggested herein.

In accordance with one embodiment a method for optimizing memory management in a runtime environment is provided. The method comprises monitoring one or more objects loaded into primary memory of a computing system to determine if at least one object can be removed from the primary memory instantiating a proxy object to delegate invocations of the first object in the primary memory removing the first object from the primary memory upon memory starvation detection and monitoring calls to the proxy object to determine whether the first object is invoked by a process.

In one embodiment the method further comprises restoring the first object to primary memory in response to determining that the first object has been invoked and storing the first object in secondary memory once the first object is removed from the primary memory. The proxy object preferably has a smaller memory footprint in comparison with the first object and maintains a reference to the first object so that the first object can be restored to primary memory if the first object is invoked by a runtime process.

In one embodiment the proxy object comprises one or more interfaces associated with the first object so that it can be determined that the first object is invoked by a process using one of said one or more interfaces to communicate with the first object. A hierarchical order for removing the one or more objects may be determined based on the relative importance of the one or more objects within the runtime environment or the relative memory footprint of the one or more objects within the runtime environment. Preferably the first object is removed from primary memory when the primary memory is occupied beyond a first threshold.

One or more of the above disclosed embodiments in addition to certain alternatives are provided in further detail below with reference to the attached figures. The invention is not however limited to any particular embodiment disclosed.

Features elements and aspects of the invention that are referenced by the same numerals in different figures represent the same equivalent or similar features elements or aspects in accordance with one or more embodiments.

The present disclosure is directed to systems and corresponding methods that facilitate improving performance in a computing system by intelligently utilizing annotations embedded in the logic code.

In the following numerous specific details are set forth to provide a thorough description of various embodiments of the invention. Certain embodiments of the invention may be practiced without these specific details or with some variations in detail. In some instances certain features are described in less detail so as not to obscure other aspects of the invention. The level of detail associated with each of the elements or features should not be construed to qualify the novelty or importance of one feature over the others.

Referring to an exemplary runtime environment illustrated as software environment comprises an operating system executed over a computing system . In accordance with one aspect of the invention software environment supports a self healing system wherein a self healing software application can be executed on top of operating system .

Software application may comprise a plurality of software components e.g. components etc. . The software components may comprise logic code software application program code or any other logic routines that may be annotated by way of human interaction or an automated operation that allows for inclusion of annotations in logic code.

As shown in component may include annotations A and B component may include annotations A and B and component may include annotations A and B for example. Preferably said annotations are not executable but are informative at runtime such that a healing agent or a monitoring software can utilize said annotations to detect problems and provide solutions that optimize execution of software application in software environment .

Referring to in accordance with one embodiment annotations are inserted into the logic code for components of software application S preferably at design and coding time to later serve as an interface for runtime monitoring managing configuring and healing of the annotated system components. Healing agent may provide self healing capabilities suited for a variety of application types such that in the runtime environment healing agent is automatically invoked by the monitoring software for example to optimize and heal the software application .

In accordance with one or more exemplary embodiments where a software component s execution can predictably lead to a problem e.g. excessive CPU utilization memory overflow etc. annotations can be embedded in that software s component to provide detailed information about the software component so that the details will be useful to a healing agent to correct the problem. To detect a problem monitoring software monitors the execution environment for events or conditions that correspond to or can trigger certain problems. For example monitoring software may monitor parameters associated with memory usage or CPU cycle to determine if the available memory is about to fall below a minimum threshold or whether the CPU is at a peak utilization capacity.

When an event or condition is detected that indicates a problem may arise during the execution of a software component S annotations embedded in the respective logic code for the software component are processed by monitoring software for example S to determine if the annotations may be helpful in correcting a detected problem S . If so the results obtained from processing the annotations are used by the corresponding healing agent to optimize the execution of the respective software component S as provided in more detail below.

In some embodiments annotations may be processed S prior during or after the detection of any event or condition S without detracting from the scope of the invention allowing for annotation processing so that certain events of interest can be detected in advance. In accordance with one aspect of the invention software application and its components may be implemented in two stages 1 application logic programming and 2 self healing overlay programming. The first stage is associated with the process of designing the basic logic of software application . The second stage is associated with enabling software application s components with self healing properties.

As provided earlier a set of target components for self healing are identified and decorated using annotations to define the healing properties. The runtime framework automatically and transparently may create proxy objects e.g. placeholder objects for the self healing enabled components. The proxy objects provide a self healing overlay through which a healing agent may monitor manage configure and optimize the healing enabled components.

In one embodiment a self healing enabled component is a component with a logic code that comprises embedded annotations. The embedded annotations may define at least one of a logic category class or type to which the software component belongs. In certain embodiments the annotations provide information about a parameter of relevance to healing of the software component or a preferred healing procedure for example. The annotations may also provide one or more details about a certain healing procedure to be performed by a certain healing agent or information about the condition in response to which the healing agent is to be invoked.

In some embodiments the logic code for the self healing software application is separately implemented and maintained from the logic code for the healing agent . Such separation is advantageous in that it allows for the algorithm in the healing agent to be easily distinguished maintained and optionally replaced by another algorithm while leaving the logic code for software application and its components intact.

Depending on implementation various methods can be used to annotate components of software application . For example special annotation software or an integrated annotation interface in software application may be utilized to embed the annotations in a software component s logic code prior to execution. Once a component is annotated the component is identified and categorized as healing enabled for example.

When the logic code for software application or its healing enable components is executed runtime monitoring software intercepts the instantiation and initialization of the objects that correspond to the executed components. In an exemplary embodiment the runtime monitoring software comprises a class loader to inspect a healing enabled component prior to the component s instantiation and registers the component with a runtime managing module or operating system for example.

In some embodiments the class loader identifies the embedded annotations in the logic code handles the annotations and registers the component as noted above. As part of the components registration process an object belonging to a certain class e.g. a class corresponding to monitoring software may be constructed and associated with one or more classes that correspond to one or more healing enabled components. Preferably the registered class object holds the run time information about the healing enabled components.

The registered class in one embodiment comprises a processed view of a component s annotations and may be used to control a component s instrumentation at runtime. For example the defined registered class may correspond to a manageable object so that when a reference for the registered class is obtained the corresponding object can be queried regarding the component s annotations and the component s runtime behavior can be controlled.

In an exemplary embodiment the annotations entered into the logic code are Java annotations devised to support self healing and optimization. The annotations are configured to enable a developer to annotate a given component either at class level or method and field level. A class level annotation applies to a component preferably as a whole logic unit whereas a method and field level annotation provides more details that can be used to resolve a detected problem during execution

Depending on implementation different categories of annotation may be included in the logic code for a component. In one embodiment an execution category annotation may apply to class methods types and fields to categorize a given element to a known category relevant to self healing. For example an annotation may indicate that the developer of a component believes that CPU and IO are major factors impacted by the run time behavior of a component or vice versa and therefore important for its healing.

In a certain embodiment healing agent may be implemented to provide automated instructions on how to generate annotations to be embedded in a component s logic code. Healing agent may advantageously also indicate the type category and location in which the annotations should be inserted in the logic code. The automated addition of annotation may be assisted by code that analyzes needs types and locations of annotations to be inserted in the logic code.

One or more elements e.g. methods types and fields of an annotated component may share a category. An element may be annotated by defining several standard execution categories such as IO CPU MEMORY and NETWORK for example. A developer may also define custom categories. In the following certain exemplary custom categories are discussed in detail. It is noteworthy however that the scope of the invention should not be construed as limited to such exemplary embodiments.

Healer Agent Annotation The healer agent annotation associates the annotated component with a specific set of healing agents in the context of specific metric types and in relation to the execution category annotation. At runtime the healer agent annotation results in the runtime monitoring software instantiating a healing agent . The healing agent may using the runtime monitor software application programming interfaces APIs register with several system metrics monitoring events e.g. CPU utilization page faults etc. .

In one embodiment event monitoring is implemented using standard approaches e.g. the Java Event Listener incurring known overheads associated with each event. By monitoring for events healing agent can detect problem symptoms and react upon them to heal the problem.

In a case where a method level healing agent is associated with a metric type with which a class level healing agent is associated the method level healing agent overrides the class level healing agent. In one embodiment the annotations may specify equally sized vectors which associate metric types with one or more appropriate healing agents.

Define Latency Monitor Annotation The following represents an exemplary logic code i.e. method that is annotated with a latency monitor type annotation.

The purpose of the above annotation is to transparently instrument a given method to produce a latency measurement. In this example the annotation defines four attributes 1 Healer the healing agent that handles the latency related events. 2 Predicate a predicate object of which the returned value indicates whether a healing operation is to be performed. For example the predicate may check whether the measured latency was greater than a predefined threshold. 3 Frequency dictates how often the runtime should report the measurement. 4 Enable a Boolean flag indicating whether the annotation is enabled. In case a developer does not indicate the healer attribute then the class level healing agent that is associated with the metric type latency is used instead.

In accordance with one aspect of the invention two categories of healing agents are provided application specific and generic healing agents. Application specific healing agents comprise healers written for specific applications. Such healers are implemented with application specific knowledge and provide a detailed level of healing and optimization for a specific application. Generic healing agents on the other hand are implemented to be applied to a variety of application classes.

Generic healing agents are classified according to the generic problem class that is healed. These types of agents may be further classified according to tradeoffs between the improved status of healed properties and the deterioration in the status of other properties. Preferably generic healers provide a less detailed level of healing due to their broad application to a plurality of problems.

In certain embodiments healing agents cover an abstract healer class e.g. a core healer class . Healing agents may register for events and implement an event method that allows the healing agents to receive component level events and system level events. A method signature is presented in the logic code provided above within the MyPredicate class. The arguments are 1 targetComponent points to the managed component 2 evt the event s listened for e.g. object creation events monitoring events etc. 3 stack the relevant stack trace elements of the thread which triggered the event.

In addition to implementing standard interfaces a healing agent may also implement some healing specific logic. Examples of generic healers are provided below without detracting from the scope of the invention.

SyncSwitchHealer In accordance with one embodiment this healer attempts to either increase application throughput or reduce CPU utilization by altering components invocation model at runtime. Accordingly a synchronous invocation is one where the caller blocks waiting for the answer and an asynchronous invocation is one where the caller does not block. Asynchronous invocations enable better utilization of the processing power and increases application throughput.

ObjectPoolHealer In accordance with one embodiment this healer dynamically creates object pools to allow object reuse in cases where object reinstantiation introduces undesirable delays in response time. As distinguishable from common implementations of object pooling the ObjectPool healer is preferably used in cases where the managed application does not implement object pools or the implemented pools handle only certain classes of objects but not others. The ObjectPool healer identifies opportunities for object re use which are not handled by the application s pools and dynamically creates pools to handle these cases.

In one embodiment the ObjectPool healer registers for object instantiation events of manageable components and measures the latency of the instantiation process. It also listens for response time threshold violation events at the system level. In cases where the latter occur in correlation with the instantiation process of monitored objects the ObjectPool healer transparently attempts to create an object pool for those objects. The healer may receive feedback from the runtime monitoring software to dynamically determine the pool s size.

ObjectDumpHealer In accordance with one embodiment this healer monitors memory utilization page faults per second and CPU utilization and may decide according to its algorithm to store memory resident objects to secondary memory and release the memory allocated to them. By moving objects from primary memory to secondary memory the ObjectDump healer frees resources. The healer uses a configurable object dump policy such as LRU in order to decide which components should be removed from the primary memory first.

Referring to a self healing software application may be implemented with annotations in its components logic code to help identify memory resident objects that can be removed from memory without affecting the system s performance. Once software application is executed the respective objects are loaded into memory S .

Preferably a runtime monitoring software monitors system memory to determine if available system memory has fallen below a certain threshold S . If so the runtime monitoring software identifies the memory resident objects that can be removed without affecting system performance S based on the annotation embedded in the logic code of software application s components.

In one embodiment healing agent creates a proxy object not shown to monitor the invocation of a target object that is or that is to be removed from memory S . Healing agent may remove a target object from memory either before or after the proxy object is created S . In one embodiment either the healing agent or the runtime monitoring software monitors runtime software environment to determine if the removed object is invoked during execution of software application S . If so the removed object is restored to memory.

Replacing a target object with a proxy object as noted above advantageously reduces the object s footprint in the primary memory. This is because the proxy object preferably provides a reference e.g. pointer to the target object and thus occupies a smaller amount of memory space in comparison to a target object that comprises the entire executable code for a method for example.

In accordance with one embodiment the target object once removed from the primary memory is stored in a secondary memory such as a hard disk drive where it can be readily loaded from in case the target object is invoked. Further the proxy object is implemented such that in addition to a reference to the target object it also comprises one or more of the interfaces associated with the removed object with the runtime environment so that when an interface with the runtime environment is activated monitoring software can determine that the removed object should be restored to primary memory.

In accordance with yet another aspect of the invention annotations embedded in a component s logic code may provide information about the order in which memory resident objects can be removed from memory. That is the annotations can be utilized to identify a hierarchical removal order for the memory resident objects such that the memory resident objects are removed from memory based on at least one or more of the following 1 the object s size 2 the object s frequency of invocation 3 the object s operational importance or other object attributes that affect the system s performance and optimization.

In accordance with an exemplary embodiment to free the memory allocated to a target object one or more references to the memory residence objects are set to null and then a garbage collector module is invoked. As noted earlier a low memory footprint proxy object is dynamically generated for the annotated component. This proxy object preferably provides the same set of interfaces of the target component and contains a single reference to the target object.

Method invocations for the target object are intercepted by this proxy and forwarded to the target object if the target object is not removed from memory. If the target object has been already removed from primary memory healing agent loads the target object from secondary memory where it has been stored and transparently restarts the object s invocation.

In an exemplary embodiment healing agent is implemented to register for creation events of objects or components that can be removed from active memory i.e. dumpable components . Preferably monitoring software provides two different events during the creation process of a healing enabled component. The first event is the precreate monitor event for example that is called before a class object is loaded. The purpose of this event is to enable healing agent to instrument the target class according to a specific annotation.

The second creation event is the creation monitor event which is called when the class is already loaded. The purpose of this event is to start the actual monitoring. This event preferably also provides the initial size of the object in memory and the time it took to create it. Thus in one embodiment healing agent registers to receive a memory related event that will indicate that the used memory has reached a predefined threshold. When this event is received healing agent is invoked.

In some embodiments healing agent additionally registers for system s page faults events these events indicate that the operating system memory management subsystem is over utilized. In such cases the healing agent may decide to avoid operation allowing the operating system to stabilize for example. Once the dumpable components are identified and registered the proxy creation process is completed and a reference to the proxy agent is returned by monitoring software . A process that invokes an object may transparently acquire a read lock on the object for example and is preferably blocked when healing agent starts to restore or remove the object to or from system memory.

In accordance with one embodiment references to the target memory resident objects may be kept in a ring data structure depending on implementation. In a first state e.g. initialization state the objects are memory resident. Periodically healing agent is activated to set the target components reference bit to zero for example and to move them to a second state e.g. pre dumped state . Once an object is invoked the reference bit is reset.

Accordingly when the healer needs to free memory the ring is scanned to locate the components for which the reference bit is equal to zero. These components are then serialized and the proxy s target object reference is set to null. At this stage the component s state is changed to a third state e.g. dumped . Once a predetermined number of such components have been removed nullified the garbage collection process is activated.

In certain embodiments accessing a swapped out component initiates a swapping in process in the context of a process that invokes a removed object. Once the object is loaded to system memory the proxy state changes to a fourth state e.g. memory resident and the system proceeds with invocation of the removed object.

In different embodiments the invention can be implemented either entirely in the form of hardware or entirely in the form of software or a combination of both hardware and software elements. For example computing system and software and may comprise a controlled computing system environment that can be presented largely in terms of hardware components and software code executed to perform processes that achieve the results contemplated by the system of the present invention.

Referring to a computing system environment in accordance with an exemplary embodiment is composed of a hardware environment and a software environment . The hardware environment comprises the machinery and equipment that provide an execution environment for the software and the software provides the execution instructions for the hardware as provided below.

As provided here the software elements that are executed on the illustrated hardware elements are described in terms of specific logical functional relationships. It should be noted however that the respective methods implemented in software may be also implemented in hardware by way of configured and programmed processors ASICs application specific integrated circuits FPGAs Field Programmable Gate Arrays and DSPs digital signal processors for example.

Software environment is divided into two major classes comprising system software and application software . System software comprises control programs such as the operating system OS and information management systems that instruct the hardware how to function and process information.

In one embodiment operating system may be implemented as system software and software application healing agent and monitoring software may be implemented as application software executed on one or more hardware environments to facilitate optimizing software environment . Application software may comprise but is not limited to program code data structures firmware resident software microcode or any other form of information or routine that may be read analyzed or executed by a microcontroller.

In an alternative embodiment the invention may be implemented as computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and digital videodisk DVD .

Referring to an embodiment of the application software can be implemented as computer software in the form of computer readable code executed on a data processing system such as hardware environment that comprises a processor coupled to one or more computer readable media or memory elements by way of a system bus . The computer readable media or the memory elements for example can comprise local memory storage media and cache memory . Processor loads executable code from storage media to local memory . Cache memory provides temporary storage to reduce the number of times code is loaded from storage media for execution.

A user interface device e.g. keyboard pointing device etc. and a display screen can be coupled to the computing system either directly or through an intervening I O controller for example. A communication interface unit such as a network adapter may be also coupled to the computing system to enable the data processing system to communicate with other data processing systems or remote printers or storage devices through intervening private or public networks. Wired or wireless modems and Ethernet cards are a few of the exemplary types of network adapters.

In one or more embodiments hardware environment may not include all the above components or may comprise other components for additional functionality or utility. For example hardware environment may be a laptop computer or other portable computing device embodied in an embedded system such as a set top box a personal data assistant PDA a mobile communication unit e.g. a wireless phone or other similar hardware platforms that have information processing and or data storage and communication capabilities.

In certain embodiments of the system communication interface communicates with other systems by sending and receiving electrical electromagnetic or optical signals that carry digital data streams representing various types of information including program code. The communication may be established by way of a remote network e.g. the Internet or alternatively by way of transmission over a carrier wave.

Referring to application software can comprise one or more computer programs that are executed on top of system software after being loaded from storage media into local memory . In a client server architecture application software may comprise client software and server software. For example in one embodiment of the invention client software is executed on computing systems or and server software is executed on a server system not shown .

Software environment may also comprise browser software for accessing data available over local or remote computing networks. Further software environment may comprise a user interface e.g. a Graphical User Interface GUI for receiving user commands and data. Please note that the hardware and software architectures and environments described above are for purposes of example and one or more embodiments of the invention may be implemented over any type of system architecture or processing environment.

It should also be understood that the logic code programs modules processes methods and the order in which the respective steps of each method are performed are purely exemplary. Depending on implementation the steps may be performed in any order or in parallel unless indicated otherwise in the present disclosure. Further the logic code is not related or limited to any particular programming language and may comprise of one or more modules that execute on one or more processors in a distributed non distributed or multiprocessing environment.

Therefore it should be understood that the invention can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is not intended to be exhaustive or to limit the invention to the precise from disclosed. These and various other adaptations and combinations of the embodiments disclosed are within the scope of the invention are further defined by the claims and their full scope of equivalents.

