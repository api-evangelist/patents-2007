---

title: Method to direct data to a specific one of several repositories
abstract: Data de-duplication schemes reduce the amount of storage necessary to store a data set by dividing the data into segments and storing a segment identifier on a storage medium in place of each data segment. Each unique data segment is stored in a repository, and duplicate data segments are not stored. Methods and apparatus are provided for distributing data segments across multiple repositories in a data storage system, thereby reducing the quantity of data stored at a particular repository. Segments are assigned to repositories based upon a characteristic of the segments. The characteristic may be the length of the segment or some other value produced by a repeatable, uniformly-distributed function of the segment. The characteristic may be stored on the storage medium along with the segment identifier. The original data may be regenerated by retrieving the segment identifiers and characteristics from the storage medium and retrieving each segment from the repository identified by the characteristic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08209334&OS=08209334&RS=08209334
owner: 
number: 08209334
owner_city: 
owner_country: 
publication_date: 20071228
---
The present invention relates generally to data storage and more specifically to techniques for distributing segments of data among multiple storage repositories.

Capacity optimization schemes factor objects into parts and plans and store the parts and plans in an optimized store or repository. Parts that are unique i.e. have not been previously encountered are stored. Before a new part is added to the optimized store the part is compared with the parts already located in the store. Direct comparison is generally too expensive computationally to provide useful performance from the factoring process. Instead the parts are fingerprinted using for example a cryptographic checksum. When a part is added to the optimized store its checksum is added to an index of checksums. Before a new part is added to an optimized store the index is examined. If the checksum is found in the index then the part is determined to be already in the optimized store and is not added again. To provide useful factoring performance the index of checksums is typically maintained in computer memory.

Capacity optimization schemes operate on arbitrary binary electronic data by dividing the original i.e. initial unprocessed data into multiple segments which correspond to the parts described above. The segments may vary in size and the segment boundaries are typically chosen with the goal that the segments correspond to the most repeated i.e. duplicated portions of the original data. Then the segments are stored in a segment pool in a repository i.e. a database using a relatively small numeric key value as a lookup value. The key value may be for example a hash value based on data in the segment. The key value is essentially a unique identifier for the segment. A de duplicated data object. e.g. a file which corresponds to the plan described above is created and the key value of each segment is added to the de duplicated data object in succession. The segment values need not be written to the de duplicated data. Instead the segments are stored in the repository and each segment is stored only once hence the term de duplication . Note that data duplication schemes are also referred to as reduced redundancy systems.

The de duplicated data object may for example include a file a data structure in memory or an object. Each segment need only be stored in the repository once because the references to that segment in the de duplicated data object can all be resolved by retrieving the same segment. The de duplicated plus the data stored in the repository is typically significantly smaller in size than the original data. The original data can be regenerated by sequentially reading the de duplicated data i.e. the sequence of key values retrieving the segment for each key value from the repository and concatenating the key values together in the order of retrieval.

The Blocklets technology of RockSoft now part of Quantum Corporation of San Jose Calif. is an example of a de duplication scheme. The Blocklets scheme uses the term blocklet for the segment described above. Blocklets are stored in a blocklet pool in a repository similar to the segment pool described above.

When the segment is stored in the segment pool in a repository an entry is typically made in an index that is also stored in the repository. The size of the index in a data de duplication scheme may grow to be very large. If the original data is relatively large then many thousands or millions of segments may be created and the size of the index may grow beyond the capacity of typical computer systems. The index may become so large that insertions of new segments into the repository and retrieval of existing segments take a substantial amount of time and performance will consequently suffer. Furthermore the index or the segment pool may become very large and possibly exceed the storage capacity of a single storage device or server. In particular the index is typically stored in computer memory for efficient access and is therefore limited in size by the size of the computer s memory. The access time characteristics of a single index and repository may not scale well as the number of accesses increases e.g. as a result of large numbers of users or high frequency of access. That is the index and repository become a bottleneck to system throughput as the usage load increases. Furthermore the index and repository are a single point of failure in that a failure of the computer or storage system providing the index and repository may lead to temporary or permanent loss of the original data. Therefore when the amount of data stored by a de duplication scheme is large or the frequency of access is high it would be desirable to be able to increase the performance and reliability of data de duplication schemes.

In general in a first aspect the invention features segment distribution logic for distributing data segments to storage repositories. The logic includes segmentation logic for dividing data into at least one segment according to a segmentation scheme characteristic generation logic for generating a characteristic based upon the at least one segment where the characteristic generation logic is operable to repeatedly produce the same characteristic for the same segment and the characteristic generation logic is further operable to generate a substantially uniform distribution of characteristics for different segments repository selection logic for generating a repository identifier based upon the characteristic and communication logic for communicating the at least one segment to a repository identified by the repository identifier.

Embodiments of the invention may include one or more of the following features. The characteristic may comprise a cryptographic hash value based upon the at least one segment a simpler hash value based upon the at least one segment or a length of the at least one segment. The repository selection logic may select the repository identifier based upon the characteristic from a mapping table. The repository identifier may be based upon the characteristic modulo a number of repositories. The segment distribution logic may further comprise output logic for storing on a storage medium at least one segment identifier that refers to the at least one segment of data wherein the segment identifier comprises the repository identifier and a key based upon the at least one segment of data. The output logic may generate the key using a hash function. The repository may be located on a remote computer.

In general in a second aspect the invention features segment re assembly logic for re assembling original data from segments distributed across multiple repositories the logic comprising segment identifier retrieval logic for retrieving at least one characteristic from a storage medium repository selection logic for generating at least one repository identifier based upon the at least one characteristic and communication logic for receiving at least one segment of data from at least one repository identified by the at least one repository identifier.

Embodiments of the invention may include one or more of the following features. The characteristic may comprise a cryptographic hash value based upon the at least one segment of data a simpler hash value based upon the at least one segment of data or a length of the at least one segment of data. The repository selection logic may select the repository identifier based upon the characteristic from a mapping table. The repository identifier may be based upon the characteristic modulo a number of repositories. The segment identifier retrieval logic may be further operable to retrieve from the storage medium at least one key associated with the at least one repository identifier and the at least one segment of data is identified in the repository by the at least one key.

In general in a third aspect the invention features a method of distributing at least one segment of data across multiple repositories in a data storage system the method comprising generating a segment identifier based upon the at least one segment of data wherein the segment identifier comprises a key and a repository identifier and the key and the repository identifier are based upon the at least one segment of data generating a characteristic based upon the at least one segment of data using a characteristic generation method that is capable of repeatedly producing the same characteristic for the same segment and that is capable of producing a substantially uniform distribution of characteristics for different segments generating the repository identifier based upon the characteristic and communicating via a communication network the segment identifier and the segment of data to a repository identified by the repository identifier.

Embodiments of the invention may include one or more of the following features. The characteristic may comprise a cryptographic hash value based upon the at least one segment of data a simpler hash value based upon the at least one segment of data or a length of the at least one segment of data. Generating the repository identifier may comprise selecting the repository identifier based upon the characteristic from a mapping table. The repository identifier may be based upon the characteristic modulo a number of repositories. The method of distributing at least one segment of data may further comprise storing the identifier on a storage medium.

In general in a fourth aspect the invention features a method of regenerating at least one segment of data in a data storage system the method comprising retrieving at least one segment identifier from a storage medium wherein the at least one segment identifier comprises a hash value and a characteristic generating a repository identifier based upon the characteristic communicating the identifier to a repository identified by the repository identifier via a communication network and receiving at least one segment of data from the repository via the communication network wherein the at least one segment of data corresponds to the hash value.

Embodiments of the invention may include one or more of the following features. The characteristic may comprise a cryptographic hash value based upon the at least one segment of data a simpler hash value based upon the at least one segment of data or a length of the at least one segment of data. Generating the repository identifier may comprise selecting the repository identifier based upon the characteristic from a mapping table. The repository identifier may be based upon the characteristic modulo a number of repositories.

In general in a fifth aspect the invention features a computer program product comprising program code for distributing data segments to storage repositories the program code comprising dividing data into at least one segment according to a segmentation scheme generating a characteristic based upon the at least one segment using a technique that is repeatable and produces a uniform distribution of characteristics generating a repository identifier based upon the characteristic and communicating the at least one segment to a repository identified by the repository identifier.

Embodiments of the invention may include one or more of the following features. The characteristic may comprise a cryptographic hash value based upon the at least one segment a simpler hash value based upon the at least one segment or a length of the at least one segment. Generating the repository identifier may comprise selecting the repository identifier based upon the characteristic from a mapping table. The repository identifier may be based upon the characteristic modulo a number of repositories. The program code may further comprise storing on a storage medium at least one segment identifier that refers to the at least one segment of data wherein the segment identifier comprises the repository identifier and a key based upon the at least one segment of data.

In general in a sixth aspect the invention features a computer program product comprising program code for re assembling segments distributed across multiple repositories to form original data the program code comprising retrieving at least one characteristic from a storage medium generating at least one repository identifier based upon the at least one characteristic and receiving at least one segment of data from a repository identified by the repository identifier.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of particular applications and their requirements. Various modifications to the embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover in the following description numerous details are set forth for the purpose of explanation. However one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances well known structures and devices are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Host A communicates with a storage device A via a storage device interface . The storage device A includes storage medium which may be removable e.g. a tape or non removable e.g. a disk or memory. Host A includes a Repository A for storing data segments in a segment pool. An index associated with the segment pool provides for retrieval of segments by an associated key value. The segments stored in the segment pool are typically stored on a persistent storage medium such as the storage medium . The index may be stored in the memory or on a storage medium such as the storage medium . The storage capacity of the memory is typically smaller than the storage capacity of the storage medium . Multiple storage devices may be used by Host A such as additional storage devices not shown or remote storage devices not shown accessible via the network . Repository A may store the repository contents on any of these additional or remote storage devices.

Host B is similar to Host A. Host B communicates with a storage device B which may include a storage medium that stores data . Host B includes a Repository B for storing segments in an indexed segment pool. Repository B may store its contents e.g. segments on the storage medium or on another local or remote storage device as described above with reference to Repository A . Host C provides a Repository C which stores its contents in a storage device C . Host C acts as a repository but does not perform data de duplication. The reduced redundancy system may include more or fewer hosts than are shown in . The particular three host configuration with three repositories is shown as an example. Not all hosts in the system need include repositories and not all hosts need include all of the components shown in Host A or Host B . Furthermore more than one repository may reside on a single computer or host in which case the repositories on the same host would operate independently using separate indexes for example and separate storage files or database tables. The repositories on the same host may share the host s resources such as storage space CPU and network interfaces.

In one example one of the hosts e.g. Host A receives original data in a memory e.g. by reading the data from a storage device or by receiving the data from a user not shown or by receiving the data from a network . The original data is for example an arbitrary sequence of bytes. The reduced redundancy system identifies redundant segments of the original data and produces a de duplicated representation of the original data . The de duplicated representation is for example a sequence of identifiers that refer to the segments of the original data. The segments are stored in repositories on the hosts. For example some of the segments may be stored in Repository A on Host A some in Repository B on Host B and some in repository C on Host C .

A characteristic i.e. a property of each of the original data segments is used as input to repository selection logic that generates a repository identifier value that identifies the repository that will store the segment. In one example the selection of a repository for storage of the segment and optionally storage of the identifier is based on selecting a characteristic of a segment where the characteristic generation logic or method exhibits the properties of repeatability uniform distribution and ease of computation. A logic function or operation is repeatable if the function or operation generates the same result value every time the function or operation is applied to the same input value. A characteristic is repeatable if the same characteristic is produced every time the characteristic is evaluated for the same input data e.g. for the same segment . The characteristic may be for example the size of the part e.g. the length in bytes of the segment a cyclic redundancy check CRC value of the part and cryptographic hash value of the part e.g. SHA1 or MD5 or a non cryptographic hash value of the part e.g. a hash function that takes less time to compute than a cryptographic hash function . Those characteristics would be generated by characteristic generation logic or a by characteristic generation method using a length function a CRC function a cryptographic hash function and a simpler hash function e.g. of the type used for storing data in hash tables respectively. The length or size of the part is easily computed is repeatable i.e. reproducible and may produce a uniform distribution. The CRC value is repeatable uniformly distributed and computationally inexpensive. Cryptographic hashes or checksums are repeatable and uniformly distributed but may be computationally expensive. However a cryptographic hash or checksum may be available in data duplication systems as the hash value generated for each part. Therefore a cryptographic hash may be used to generate the characteristic of the segment with little additional computational burden in a data de duplication system. A simpler type of hash function i.e. a non cryptographic hash function may similarly be used to generate a simpler hash value for use as the characteristic . The simpler hash function may use an addative method or a rotative method to process the data and generate the simpler hash value. For example the simpler hash function may traverse its input data e.g. a data segment and for each byte of input data multiply the byte by a prime number and add the result to a sum. After all bytes of the input data have been processed the sum is the simpler hash value. A checksum or CRC value may be computed similarly and used as the characteristic .

The repository selection logic generates a repository identifier based upon the characteristic . That is the characteristic used to select the repository in which the segment is stored. In one example the repository selection logic may generate the repository identifier using a modulo operation on the characteristic . The modulo operation may for example select an appropriate quantity of the least significant bits of the characteristic to form the repository identifier . In one example the repository identifier is a number to be used to directly address the repository. In some examples the repository identifier may be an instance number of the repository that is converted to a repository address by additional logic. In other examples the repository identifier may be a network address of a repository in which case the repository selection logic may produce an index into a mapping table where the index selects a repository address from the mapping table.

The repository selection logic may use any technique that maps a numeric characteristic value to a repository identifier. In one example there are fewer repositories than possible characteristic values so the characteristic is reduced in size to select a repository. The repository selection logic may select one or more ranges of bits from the characteristic to form a new number to be used to address the repository. The repository selection logic may select digits in a repeatable manner e.g. according to a predefined formula from the characteristic to form a new number that selects the repository. The repository selection logic may select digits of the characteristic by using an exclusive or XOR operation to select ranges of bits in a repeatable manner e.g. according to a formula from the characteristic to form a repository address. The repository selection logic may use a combination of those operations e.g. a bit selection followed by an XOR operation to produce the repository identifier .

In one aspect a key value e.g. a hash value for each segment is generated to identify the segment within the repository in which the segment is stored. Each repository includes an index that maps key values of the segments to the locations of the segments in a block pools managed by the repository. The characteristic and hash value of each of the segments are stored as an identifier in the de duplicated data in a positions e.g. sequential positions that corresponds to the position of the segment in the original data . That is the identifiers are written to the de duplicated data in the same order that their corresponding segments occur in the original data .

The storage space used by the de duplicated data combined with the storage space used by the segments and hash table entries in the repositories is typically substantially smaller than the storage space used by the original data e.g. by a factor of 10 to 20 or more. The original data may be removed from memory e.g. from the storage medium and from the memory after the de duplicated data has been stored and the segments have been stored in the repositories . Subsequently the original data can be re constituted from the de duplicated data and the segments in the repositories by reading the identifiers from the de duplicated data stored on the storage medium . In one example each segment may be retrieved by using the characteristic value included in each identifier to select a repository according to the same method used to select the repository when the segment was stored by sending the hash value included in the identifier to the repository typically via the communication network if the repository is on a remote computer i.e. a different computer that is accessible via a network and by receiving the segment from the repository via the network .

In one example segment distribution logic located on Host A i.e. available to be executed on Host A performs de duplication of the original data into distributed segments by defining the segments generating the identifiers sending the segments to the appropriate repositories and storing the identifiers in the de duplicated data . The segment distribution logic may send each of the segments to a selected repository such as repository A repository B or repository C . As described above the repository may be selected based upon a characteristic of each of the segments . If the selected repository is located on a remote computer e.g. repository C on host C the segment distribution logic sends the segment to the remote computer via a communication network . Segment distribution logic located on Host B is similar to the segment distribution logic and performs de duplication of original data located on a storage medium accessible in a storage device B accessible by Host B . The segment distribution logic on Host B may store de duplicated data on for example the storage medium . In other examples the segment distribution logic may send the de duplicated data to a repository for storage such as Repository A or Repository C via the network . That is the original and de duplicated data may be stored on any storage device such as a disk tape or memory accessible to a host or repository. The original data and the de duplicated data are shown stored on the storage device A for illustrative purposes.

In one example segment reassembly logic located on host A reads or receives the de duplicated data from the storage medium or from some other source . The segment reassembly logic re assembles the de duplicated data to by retrieving the segments referenced by the identifiers from the corresponding repositories referenced by the identifiers such as repository A . If one or more of the referenced segments is stored on a remote computer e.g. on a repository or a storage device located on a remote computer the segment reassembly logic receives the segment from the remote computer via the communication network . The retrieved segments are reassembled to form re assembled data by combining or concatenating the segments in the order of their corresponding segment identifiers . The re assembled data not shown is essentially equivalent to the original data . The re assembled data may be stored in the memory or on the storage medium or on any other storage device accessible to the host on which the segment re assembly logic is located. Re assembly may be performed on any host that can access the de duplicated data and the repositories in which the corresponding segments are stored. For example host B may include segment re assembly logic and may perform de duplication of data stored on the storage device such as de duplicated data and may store some or all of the re assembled data not shown in the memory on host B . The re assembled data may also be stored on the storage medium on host B or on the storage medium on host A or on the storage medium on device C . The re assembled data may be stored on a different host by for example sending the data in a message to the repository on which the data is to be stored.

The list of segments includes Segment Segment and Segment N . The list of segments may include any number of segments but three are listed here for illustrative purposes. The segment distribution logic processes each segment in the list of segments by creating a corresponding segment identifier that includes the hash value and a repository identifier . The hash generator generates the hash value using for example a cryptographic checksum generator such as an MD5 or SHA1 generator. The repository identifier is generated by repository selection logic . In this example the repository selection logic generates a repository identifier which is also used as the repository identifier in the segment identifier .

The repository selection logic generates the repository identifier based upon a characteristic of the segment . The repository identifier may be for example a numeric value that identifies a repository e.g. 1 for repository number or Uniform Resource Locator URL that identifies a repository server instance on an Internet host e.g. http hostname instancename . In the example of the repository selection logic sets the repository identifier to the length of the data in the segment modulo the number of repositories. Therefore the repository identifier will vary uniformly across the repositories and will be the same for equivalent segments. In this example there are 3 repositories and the repository identifier is a number that identifies the repository e.g. 1 for the first repository 2 for the second repository and 3 for the third repository. For example a segment with a data length of 4 would correspond to a characteristic value of 1 4 modulo 3 and would therefore be stored on the first repository. In this example the repository identifier is generated based upon a modulo operation of a characteristic of the segment data. In other examples the repository identifier may be based upon the length of the segment in bytes or the CRC value of the segment or a cryptographic checksum value e.g. SHA1 of the segment . In still other examples the repository identifier may be generated by selecting one or more ranges of bits from the characteristic to form a number that may be used to address the repository or by selecting digits in a formulaic i.e. deterministically repeatable manner from the characteristic to form a new number that identifies a specific repository or addresses the repository or by using an exclusive or XOR operation on ranges of bits selected in a formulaic manner from the characteristic to form a new number that identifies or addresses the repository. The repository identifier may be generated by combinations of such operations and by any other operation that is repeatable i.e. produces the same result each time the operation is applied to a particular data segment.

As described above the size of data is reduced by creating a de duplicated representation of the data. The de duplicated representation is shown in as de duplicated data . In one example the de duplicated data includes a list of segment identifiers .

In one example the output logic adds the segment identifier to the list of segment identifiers to create the de duplicated data . The segment identifiers may be stored on for example a storage device such as a disk tape or memory or may be stored in a repository such as the remote repository . In the segment identifiers are stored on the storage device as de duplicated data . Each segment identifier such as a first segment identifier refers to a corresponding data segment e.g. segment of the original data .

In one example communication logic communicates the hash and the segment and optionally the repository identifier by sending a request containing the hash and the segment and optional repository identifier to the remote repository via a communication network . The specific repository to which the request is communicated is identified by a destination repository ID . In one example the segment may be written to a storage device associated with the local computer on which the segment distribution logic is executing or to a repository located on the local computer in which case the segment need not be sent to a remote repository . In one example the communication logic selects the address of the remote repository based upon the repository identifier . In another example the communication logic selects the address of the remote repository based upon the hash value .

In one aspect the communication logic sends the segment in a request to the selected remote repository via the communication network . At the remote repository communication logic receives the request shown as a receive request from the network . The communication logic extracts the hash value and the segment from the received request . The repository stores the segment as a stored segment in a segment pool . The segment pool is for example a region of memory or space on a storage medium in which data can be stored and retrieved to and from memory locations identified by addresses which are typically numeric values that uniquely identify corresponding memory locations. The repository creates an index entry that refers to or points to the location in memory or on a storage medium at which the received segment is stored. Although a hash index and a block pool are used in this example other techniques may be used such as search trees or other storage techniques known to those skilled in the art of data storage. The segment can subsequently be retrieved from the repository by querying the index for the hash value to retrieve the index entry that contains the location of the segment in the segment pool . The subsequent index query will return the entry which contains the reference or pointer to the segment .

In one example this technique allows each of the data segments to be stored on a different repository. When data segments are stored the characteristic generation logic selects a repository based upon a characteristic of each of the segments . The data is stored in a de duplicated form as a list of segment identifiers that refer to the segments by their repository and hash value within the specified repository. When the de duplicated data is read from a storage medium the original data segments may be retrieved from the repository or repositories or other storage device using the information stored in the segment identifiers. The segment identifier s characteristic identifies the repository on which the segment is stored. The segment identifier s hash value identifies the segment within that identified repository. For example segment may be stored in the repository at a location identified by the hash value . Other segments of the same data may be stored in different repositories. Segment for example may be stored in a different repository. For example if the characteristic of segment e.g. the length of the segment in bytes is mapped to the value 1 by the characteristic generation logic and the characteristic of segment the segment s length in bytes is mapped to the value 2 by the characteristic generation logic then segment will be stored on the repository that is identified by the value 1 and segment will be stored on the possibly different repository that is identified by the value 2 .

In some examples the segment identifier includes a characteristic of the segment. In other examples the segment identifier includes a repository identifier. The segment re assembly logic includes segment identifier retrieval logic which receives each segment identifier from the storage device .

If the segment identifier includes a characteristic e.g. the repository identifier was not written to the storage medium but a characteristic of the segment was written then repository selection logic generates a repository identifier as described above with reference to the repository selection logic of . The repository identifier is used by the communication logic as the destination repository identifier to identify the repository on which a particular segment referenced by the segment identifier is stored. If the segment identifier includes a repository identifier e.g. the repository identifier was stored on the storage medium when the segment identifier was written then the repository selection logic is not necessary and the repository identifier read from the segment identifier is used as the destination repository identifier by the communication logic .

The segment re assembly logic includes communication logic for requesting and receiving segments from remote repositories when the characteristic of a segment indicates that the segment is stored on a remote repository. If the characteristic of a segment identifier indicates that the segment is stored locally e.g. a characteristic value that corresponds to the local host the segment reassembly logic may request and receive the segment from a local repository or from local memory using storage techniques known to those skilled in the art e.g. hash table indexes and block pools stored in memory using the hash to store the segment in the hash table . As the original data is re assembled the segments of the original data are stored in the memory or on a storage device or repository accessible by the host not shown on which the segment re assembly logic is located.

For each segment identifier that refers to a segment stored on a remote repository e.g. according to the segment identifier s characteristic the communication logic creates a request that includes the hash value portion of the segment identifier . As in the segment distribution logic of the communication logic sends the request to the repository address that corresponds to the characteristic . In other examples additional repository selection logic not shown may perform further steps to select a repository based upon the characteristic in which case repository selection logic should also be present in the segment distribution logic so that both the segment distribution logic and the segment re assembly logic will select the same repository for the same segment characteristic. In the example shown in the segment re assembly logic the characteristic is retrieved from the segment identifier that was generated by the segment distribution logic of .

In one example communication logic located on the destination repository receives the request via the communication network extracts the hash value from the request looks up the hash value in the index to find an entry that specifies the location of the corresponding segment in the segment pool retrieves the segment and sends the segment back to the requesting communication logic as a segment in a response . The requesting communication logic receives the response extracts the segment and stores the segment as part of the reconstructed original data . For example the communication logic may append the segment to the reconstructed original data in the memory or may append the segment to a disk file to create a reproduction of the original data .

In this example the characteristic of each segment is the length of the segment in characters. The length of the first segment T is 1 character so the characteristic of the first segment is 1. The length of the second segment EST is 3 characters so the characteristic of the second segment is 3. The length of the third segment R is 1 character so the characteristic of the third segment is 1. The length of the fourth segment EST is 3 so the characteristic of the fourth segment is 3. The length of the fifth segment QUANT is 5 so the characteristic of the fifth segment is 5.

Note that the characteristic of each segment may be independent of the segment s hash value so the characteristic may need to be evaluated even if the segment is a duplicate of a previous segment because the characteristic may depend on properties of the segment that do not affect the hash value. For example when the characteristic is based on the length of the segment the characteristic will be the same for segments that are considered duplicates according to the hash value.

In the example of the segment characteristic is transformed to a repository identifier by a modulo operation that ensures the repository identifier is in a specified numeric range. The operation X modulo Y can be understood as a reduction of the value X to a value less than or equal to Y. There are three repositories in this example so the number of repositories is 3. In this example the repository identifier is generated as the characteristic modulo the number of repositories and the number of repositories NR is 3 so the repository identifier is always in the range 0 to 3. The lengths of T EST and R are less than or equal to 3 so the modulo operation does not change their value and the repository identifier is equal to the lengths for those segments. However the length of QUANT is 5 and 5 modulo 3 is 2 i.e. the remainder of 5 divided by 3 is 2 so the repository identifier assigned to the value QUANT is 2.

In the example of the de duplicated data includes segment identifiers for each of the segments . In this example the segment identifiers appear in the same order as the corresponding segments of the original data . The first segment identifier includes the repository identifier 1 and hash value 36 of the first segment. The second segment identifier includes the repository identifier 3 and hash value 42 of the second segment. The third segment identifier includes the repository identifier 1 and the hash value 64 of the third segment. The fourth segment identifier includes the repository identifier 3 and the hash value 42 of the fourth segment. The fifth segment identifier includes the repository identifier 2 and the hash value 27 of the fifth segment. In another example the characteristics may be stored in the de duplicated data instead of the segment identifiers in which case the retrieval logic that reconstructs the original data would recalculate the repository identifiers using the same transformation as is used when the de duplicated data is stored. In other examples the order in which the segment identifiers appear in the de duplicated data may differ from the order in which the corresponding segments appear in the original data but when the order differs a position and length of the segment may be stored with each segment identifier in the de duplicated data so that the segments can be re assembled in their original order. The position and length allow the segment re assembly logic of to process the segment identifiers in any order and to store the retrieved segment in the re created data in any order. Furthermore when the segment identifiers include the position and length of each segment the segment re assembly logic may execute in parallel on multiple processors that re assemble the original data in parallel by writing segments to a shared file so that the re assembly process can be sped up.

In one example as described above each segment is stored in a repository that is selected based upon the characteristic associated with the segment. The segments with characteristic 1 are stored in repository number 1 . The first segment is stored as an entry in a segment pool located at repository number 1 and the location of the entry is specified by a key entry in the index with the value 36 the segment s hash value . That is the first segment may be retrieved efficiently by querying repository number 1 for the segment with hash value 36 . The third segment is stored as an entry in the segment pool of repository 1 and the location of the third segment s entry is specified by a key entry in the index with the value 64 in that repository s index .

The second segment is stored in repository number 3 as an entry in that repository s segment pool . The location of the entry within the repository is specified by a key entry in the index with the value 42 . That is the second segment may be retrieved efficiently by querying the repository number 3 for the segment with hash value 42 . The second segment identifier for example can therefore be used to retrieve the second segment using the repository number 3 and hash value 42 contained in that segment identifier .

The fifth segment is stored in repository number 2 as an entry in that repository s segment pool . The location of the entry within the repository is specified by a key entry in the index with the value 27 . That is the fifth segment may be retrieved efficiently by querying repository number 2 for the segment with hash value 27 . The fifth segment identifier for example can therefore be used to retrieve the fifth segment using the repository number 2 and hash value 27 contained in the that segment identifier .

Block generates a repository identifier based upon the characteristic of the data. For example block may generate the repository identifier as the characteristic of the data modulo the number of repositories in the system. As another example block may consult a mapping table that maps ranges of characteristic values e.g. 1 10000 to repositories e.g. http host1 repository1 for the range 1 10000 . Block is similar to the repository selection logic of . Block creates a segment identifier that contains the characteristic value and a key e.g. a hash value that is based on the segment data. Block sends the segment identifier and the segment to the repository identified by the repository identifier. Block adds e.g. appends the segment identifier to a de duplicated representation of the original data. Block repeats the process for each segment in the original data.

Block acquires e.g. extracts the repository identifier or characteristic value and key e.g. hash value from the segment identifier. If the characteristic value was retrieved i.e. the repository identifier is not present on the storage medium then block generates the repository identifier as described above with respect to block of . If the repository identifier is stored on the storage medium then block may be omitted. Block sends the key value to a repository that corresponds to the characteristic. Block selects a repository based upon the characteristic. In one example the characteristic value is a repository identifier so block simply supplies the characteristic value as a destination repository number and sends a request to the repository identified by that repository number. Block receives a segment from the repository in response to the request sent in block . The received segment corresponds to the key value. Block adds e.g. appends the received segment to a regenerated representation of the original data. Block repeats the process for each segment identifier in the de duplicated data.

While the invention has been described in terms of particular embodiments and illustrative figures those of ordinary skill in the art will recognize that the invention is not limited to the embodiments or figures described. Those skilled in the art will recognize that the operations of the various embodiments may be implemented using hardware software firmware or combinations thereof as appropriate. For example some processes can be carried out using processors or other digital circuitry under the control of software firmware or hard wired logic. The term logic herein refers to fixed hardware programmable logic and or an appropriate combination thereof as would be recognized by one skilled in the art to carry out the recited functions. Software and firmware can be stored on computer readable media. Some other processes can be implemented using analog circuitry as is well known to one of ordinary skill in the art. Additionally memory or other storage as well as communication components may be employed in embodiments of the invention.

Computing system can also include a main memory such as random access memory RAM or other dynamic memory for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computing system may likewise include a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor .

The computing system may also include information storage system which may include for example a media drive and a removable storage interface . The media drive may include a drive or other mechanism to support fixed or removable storage media such as a hard disk drive a floppy disk drive a magnetic tape drive an optical disk drive a CD or DVD drive R or RW or other removable or fixed media drive. Storage media may include for example a hard disk floppy disk magnetic tape optical disk CD or DVD or other fixed or removable medium that is read by and written to by media drive . As these examples illustrate the storage media may include a computer readable storage medium having stored therein particular computer software or data.

In alternative embodiments information storage system may include other similar components for allowing computer programs or other instructions or data to be loaded into computing system . Such components may include for example a removable storage unit and an interface such as a program cartridge and cartridge interface a removable memory for example a flash memory or other removable memory module and memory slot and other removable storage units and interfaces that allow software and data to be transferred from the removable storage unit to computing system .

Computing system can also include a communications interface . Communications interface can be used to allow software and data to be transferred between computing system and external devices. Examples of communications interface can include a modem a network interface such as an Ethernet or other NIC card a communications port such as for example a USB port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which can be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a channel . This channel may carry signals and may be implemented using a wireless medium wire or cable fiber optics or other communications medium. Some examples of a channel include a phone line a cellular phone link an RF link a network interface a local or wide area network and other communications channels.

In this document the terms computer program product computer readable medium and the like may be used generally to refer to media such as for example memory storage device or storage unit . These and other forms of computer readable media may be involved in storing one or more instructions for use by processor to cause the processor to perform specified operations. Such instructions generally referred to as computer program code which may be grouped in the form of computer programs or other groupings when executed enable the computing system to perform features or functions of embodiments of the present invention. Note that the code may directly cause the processor to perform specified operations be compiled to do so and or be combined with other software hardware and or firmware elements e.g. libraries for performing standard functions to do so.

In an embodiment where the elements are implemented using software the software may be stored in a computer readable medium and loaded into computing system using for example removable storage drive drive or communications interface . The control logic in this example software instructions or computer program code when executed by the processor causes the processor to perform the functions of the invention as described herein.

It will be appreciated that for clarity purposes the above description has described embodiments of the invention with reference to different functional units and processors. However it will be apparent that any suitable distribution of functionality between different functional units processors or domains may be used without detracting from the invention. For example functionality illustrated to be performed by separate processors or controllers may be performed by the same processor or controller. Hence references to specific functional units are only to be seen as references to suitable means for providing the described functionality rather than indicative of a strict logical or physical structure or organization.

Although the present invention has been described in connection with some embodiments it is not intended to be limited to the specific form set forth herein. Rather the scope of the present invention is limited only by the claims. Additionally although a feature may appear to be described in connection with particular embodiments one skilled in the art would recognize that various features of the described embodiments may be combined in accordance with the invention.

Furthermore although individually listed a plurality of means elements or method steps may be implemented by for example a single unit or processor. Additionally although individual features may be included in different claims these may possibly be advantageously combined and the inclusion in different claims does not imply that a combination of features is not feasible and or advantageous. Also the inclusion of a feature in one category of claims does not imply a limitation to this category but rather the feature may be equally applicable to other claim categories as appropriate.

Moreover it will be appreciated that various modifications and alterations may be made by those skilled in the art without departing from the spirit and scope of the invention. The invention is not to be limited by the foregoing illustrative details but is to be defined according to the claims.

