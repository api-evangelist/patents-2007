---

title: Intelligent configurable graphics bandwidth modulator
abstract: An apparatus and method to dynamically regulate system bandwidth in a graphics system includes receiving vertex data from an application by way of an application programming interface. The rate that the vertex data is received from the application is then determined. In the event the rate is greater than a selected threshold, the graphics system is configured to operate in immediate mode, wherein vertex data is rendered immediately upon reception. In the event the rate is less than the selected threshold, the graphics system is configured to operate in retained mode, wherein vertex data is stored prior to being rendered. The apparatus and method switches between each of the modes on-the-fly in a manner that is transparent to the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08031194&OS=08031194&RS=08031194
owner: Vivante Corporation
number: 08031194
owner_city: Sunnyvale
owner_country: US
publication_date: 20071109
---
This invention relates to three dimensional graphics systems and more particularly to apparatus and methods for reducing system bandwidth requirements of three dimensional graphics systems.

Three dimensional 3D computer graphics refer to graphics systems that generate two dimensional 2D images from 3D geometric models. These 2D images may then be displayed on computer screens or other raster based devices. Currently complex 3D graphics are used in applications such as computer games and are typically reserved for PC or entertainment based platforms. Such 3D graphics may be unable to run on mobile devices e.g. cell phones PDAs navigation systems due to hardware limitations such as memory memory bandwidth and processing limitations. Memory bandwidth in particular is a major contributor to overall system power in mobile devices. Power consumption is one of the most if not the most significant limitation in the design of many mobile devices.

In general there are two techniques for rendering a scene containing 3D objects immediate mode and retained mode. Immediate mode is the most commonly used mode and is what most modem APIs and high performance GPUs implement. In this mode a state or primitive is rendered when it is passed from an application to a graphics driver. This architecture typically supports very high throughput but its main disadvantage is that is uses significant memory bandwidth. This is because every pixel is read or written several times to the frame and depth buffers. Because the frame and depth buffers store information associated with every pixel of a display they are typically implemented in external graphics memory outside the GPU. Access to this external memory increases system power requirements significantly.

Retained node is a rendering mode where all or a significant portion of the data for a scene is stored before it is rendered. This allows software to perform many different operations on the data prior to rendering it. For example software could sort all of the vertices of a scene from back to front eliminating the need for a depth buffer. In general retained mode imaging provides a higher level of abstraction than immediate mode imaging and may be more amenable to hardware acceleration and caching. This feature may also reduce the amount of work a programmer needs to perform loading managing culling and rendering data and allows a programmer to focus on higher application level functions. Nevertheless retained mode imaging may also slow performance considerably due to the need to gather save and sort data from a scene prior to rendering it.

In view of the foregoing what is needed is an apparatus and method to provide many of the advantages of retained mode and immediate mode architectures while avoiding many of the disadvantages of each. Further needed is an apparatus and method to dynamically and seamlessly switch between retained and immediate modes of operation in a way that is transparent to an application. Further needed are apparatus and methods to reduce graphics system bandwidth and reduce power consumption when performing 3D rendering.

The invention has been developed in response to the present state of the art and in particular in response to the problems and needs in the art that have not yet been fully solved by currently available apparatus and methods. Accordingly the invention has been developed to provide a novel apparatus and method for reducing graphics system bandwidth. The features and advantages of the invention will become more fully apparent from the following description and appended claims and their equivalents and also any subsequent claims or amendments presented or may be learned by practice of the invention as set forth hereinafter.

Consistent with the foregoing a method to dynamically regulate system bandwidth in a graphics system is disclosed in a first example of the invention as including receiving vertex data from an application by way of an application programming interface. The rate that the vertex data is received from the application is then determined. In the event the rate is greater than a selected threshold the graphics system is configured to operate in immediate mode wherein vertex data is rendered immediately upon reception. In the event the rate is less than the selected threshold the graphics system is configured to operate in retained mode wherein vertex data is stored prior to being rendered. The method may switch between each of the modes on the fly in a manner that is transparent to the application.

In selected examples the method may include assembling the vertex data to generate primitives and calculating a bounding box for each of the primitives when operating in retained mode. This vertex data may in selected examples be stored in a buffer. Similarly the primitives and associated bounding boxes may be stored in a separate buffer. In certain examples the method may also include calculating a batch bounding box for each batch of primitives that has the same render state. These batches and associated bounding boxes may also be stored in a buffer.

When operating in retained mode the method may include dividing a frame buffer into subdivisions or windows and determining which primitives are associated with each subdivision. This may be accomplished by determining which primitive and batch bounding boxes overlap with each subdivision. Each subdivision may then be rendered individually using on chip memory local to the GPU. In selected examples the method may include optimizing the size and position of subdivisions to efficiently utilize the on chip memory. In selected examples the size and position of subdivisions may be optimized to encompass entire batches of primitives.

In another example of the invention a graphics system to dynamically regulate system bandwidth may include a graphics driver capable of receiving commands and vertex data from an application by way of an application programming interface. A graphics processing unit GPU may communicate with the graphics driver. The GPU and graphics driver together may be configured to operate in either immediate mode wherein vertex data is rendered immediately upon being passed to the graphics driver or retained mode wherein vertex data is stored prior to being rendered. A switching module may be provided to dynamically switch between immediate mode and retained mode in a manner that is transparent to the application. The switching module may be configured to switch between these modes according to the rate at which vertex data is received from the application.

In another example of the invention an apparatus to dynamically regulate system bandwidth in a graphics system may include means for receiving vertex data from an application by way of an application programming interface and means for determining the rate at which vertex data is received from the application. The apparatus may further include means for operating in immediate mode wherein vertex data is rendered immediately upon reception in the event the rate is greater than a selected threshold. The apparatus may also include means for operating in retained mode wherein vertex data is stored prior to being rendered in the event the rate is less than the selected threshold.

It will be readily understood that the components of the invention as generally described and illustrated in the Figures herein may be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of the examples of the system apparatus and methods of the invention as represented in the Figures is not intended to limit the scope of the invention as claimed but is merely representative of selected examples of systems devices and methods that embody or otherwise incorporate the invention.

Some of the functional units described in this specification have been labeled as modules in order to emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like.

Modules may also be implemented in software for execution by various types of processors. An identified module of executable code may for instance comprise one or more physical or logical blocks of computer instructions which may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose of the module.

Indeed a module of executable code could be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices and may exist at least partially merely as electronic signals on a system or network.

Reference throughout this specification to one example an example or similar language means that a particular feature structure or characteristic described in connection with the example may be included in at least one example of the invention. Thus appearances of the phrases in one example or in an example in various places throughout this specification are not necessarily all referring to the same example.

Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more examples. In the following description specific details may be provided such as examples of programming software modules user selections or the like to provide a thorough understanding of examples of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods or components. In other instances well known structures or operations are not shown or described in detail to avoid obscuring aspects of the invention.

The illustrated examples of the invention will be best understood by reference to the drawings wherein like parts are designated by like numerals throughout. The following description is intended only by way of example and simply illustrates certain selected examples of apparatus and methods that are consistent with the invention as claimed herein.

Referring to one example of a computing device for implementing an intelligent configurable graphics bandwidth modulator in accordance with the invention is illustrated. In selected examples the computing device is a mobile device such as a mobile phone personal digital assistant PDA portable media player handheld game console navigation system information appliance or the like where system power consumption is a major limitation. Nevertheless the bandwidth modulator described herein may be used with a host of different computing devices including fixed or non portable systems embedded or general purpose systems to reduce graphics system bandwidth and power consumption.

As shown one example of a computing device may include a central processing unit CPU a core logic device e.g. memory controller video controller etc. and main memory . The graphics system of the computing device may include a graphics processing unit GPU external graphics memory and a display device such as an LCD CRT display plasma display or other type of display . In selected examples the components illustrated in may be discrete components or integrated onto single chips or circuits. For example a memory controller e.g. core logic device may be integrated onto the same chip as the CPU or main memory . In other examples the external graphics memory and the main memory may be the same memory device . The computing device as illustrated is simply provided by way of example and is not intended to be limiting.

In selected examples the GPU may include a GPU core as well as on chip memory . The external graphics memory may include a frame buffer to store a complete frame of video data for output to the display device .

Referring to in selected examples a GPU may implement a modified and improved version of a conventional 3D graphics pipeline to achieve the objectives of the present invention. The following description provides a very brief explanation of the function of one example of a graphics pipeline and is not intended to be limiting. As shown a conventional 3D graphics pipeline may include a GPU front end to act as a command parser for the GPU and perform tasks such as fetching vertices for transmission through the pipeline . A vertex shader may perform mathematical operations on the vertex data such as transforming vertices or changing the color texture or lighting on the vertices. A primitive assembler may receive the vertices from the vertex shader and assemble them to create triangles or other primitive shapes.

In selected examples the pipeline may include a setup engine to perform selected mathematical operations needed to render 3D images and reduce the workload of a CPU. A rasterizer may work closely with the setup engine to perform tasks such as computing primitive bounding boxes computing edge equations and edge slopes and converting primitives to pixels. A pixel shader texture unit may be provided to manipulate the pixels generated by the rasterizer on a pixel by pixel basis to apply effects such as water or metal effects as well as apply textures to each of the pixels. Finally a pixel engine may perform operations such as depth comparisons stenciling for shadow effects and alpha blending on pixel color. The pixel engine may function as a cache controller with a large cache to reduce system bandwidth.

The 3D graphics pipeline and components thereof as illustrated in provide the basis of the improved pipeline illustrated in . Nevertheless the graphics pipeline illustrated in is simply one example of a 3D graphics pipeline that may be used with the present invention and is not intended to be limiting. That is apparatus and methods in accordance with the invention may be used with different pipeline models other than that illustrated which use different steps ordering of steps techniques processes APIs or the like to render 3D graphics. Thus the invention may utilize different pipeline models as appropriate and is not limited to the illustrated model.

Referring to in selected examples a graphics system in accordance with the invention may dynamically switch between retained and immediate modes of operation to take advantage of the benefits of each. For the purposes of this specification the phrase retained mode instead of referring to an API is used generally to refer to any 3D graphics technique where all or a significant portion of the graphics data for a scene is stored after it is passed to the graphics driver but before it is rendered to the display. This allows various operations to be performed on the graphics data prior to rendering it. Similarly the phrase immediate mode instead of referring to an API is used generally to refer to any 3D graphics technique where graphical objects are rendered when they are passed to the graphics driver without storing all or a large portion of the graphics data for a scene prior to rendering. Thus the phrases retained mode and immediate mode refer to all techniques regardless of the names or designations given to the techniques that operate in the above described manner or in a manner similar thereto.

As shown in selected examples a graphics system in accordance with the invention may include an application for producing graphics data hereinafter referred to as vertex data representing graphical objects e.g. triangles or other graphical representations. The vertex data may be passed to a graphics driver by way of an application programming interface . The graphics driver may then pass this vertex data to a GPU implementing a pipeline which has been specially configured to provide the benefits of the invention.

As shown a GPU in accordance with the invention may implement a modified pipeline that is divided into two separate passes a geometry pass and a rendering pass . In general the geometry pass may be used to convert all or many of the vertices received from the graphics driver to triangles or other primitives . The rendering pass on the other hand may receive the triangles from the geometry pass and convert them to pixels for display on a computing device . A routing module in accordance with the invention may be inserted between the geometry pass and the rendering pass to route primitives in one of several directions depending on the mode of operation. The dotted lines as shown in represent data paths that may exist but not be utilized by the GPU when operating in immediate mode.

When operating in immediate mode the graphics driver may pass vertex data and associated commands to a GPU front end in order to send the vertices down the pipeline . A vertex shader may transform the vertices or perform tasks such as modifying the color texture or lighting on the vertices. A primitive assembler may assemble the vertices received from the vertex shader to create triangles or other primitives. In immediate mode the routing module may be configured to route the triangles directly to the rendering pass . This may be accomplished by routing the primitives to a multiplexer which may communicate with the routing module and the GPU front end .

Once the primitives are transmitted to the multiplexer the primitives may be transmitted to the setup engine where they may be rendered in the conventional manner. That is a rasterizer may among other tasks compute the bounding box of primitives edge equations and edge slopes of primitives and convert the primitives to pixels. A pixel shader texture unit may manipulate the pixels on a pixel by pixel basis to apply effects and textures to each of the pixels. A pixel engine may perform operations such as depth comparisons stenciling for shadow effects and alpha blending on pixel color.

Referring to when operating in retained mode the routing module may route primitives received from the geometry pass for storage in one or more data buffers instead of immediately sending the primitives to the rendering pass . Examples of the content and format of these data buffers will be described in additional detail in association with . Once the primitives for a scene are stored in these buffers the graphics driver may manipulate sort or perform operations on the primitives and other data to optimize the rendering process and conserve system bandwidth. These optimizations sorting and operations will be discussed in additional detail in association with .

Once the graphics driver has manipulated sorted or performed operations on the primitives and other data in the data buffers the graphics driver may pass the primitives to the GPU front end . Because these primitives have already been processed by the geometry pass the GPU front end may be configured to send the primitives directly to the multiplexer and the rendering pass . Thus an additional pipe or direct data path may be provided between the GPU front end and the rendering pass .

Because the immediate and retained modes of operation may be implemented exclusively by the graphics driver and the GPU pipeline switching between the two modes of operation may be transparent to the application . Thus a common API may be provided to take advantage of both modes. This will also reduce system bandwidth and optimize system resources in a way that is transparent to the application .

Referring to in selected examples a method may be implemented to dynamically switch between immediate and retained modes of operation. In certain examples this method may be implemented by the graphics driver as will be explained in association with . In selected examples a method may include receiving vertex data from an application or other source of graphical data. The rate or speed of the incoming vertex data may be monitored as it is received. In certain examples the rate may be calculated based on the number of vertices that are received over a specified period of time the number of vertices that are received for a scene or frame or using other criteria.

This rate may then be compared to a threshold value. If the rate is greater than the threshold value the graphics system may be configured to operate in immediate mode. This step may include switching the graphics system to immediate mode if not previously in immediate mode or keeping the graphics system in immediate mode. Similarly if the rate is less than the threshold value the graphics system may be configured to operate in retained mode. This step may include switching the graphics system to retained mode if not previously in retained mode or keeping the graphics system in retained mode. Switching between modes may occur on the fly such as on a frame by frame basis.

The threshold value used in the comparison step may be calculated based on the speed or resources available on the GPU e.g. size of on chip memory etc. the size of the frame buffer or the like. For example the larger the on board memory on the GPU the larger vertex rate the GPU may be able to handle before switching from retained mode to immediate mode.

In general the graphics system illustrated in may be configured to operate in retained mode for low vertex rates i.e. below a selected threshold and immediate mode for high vertex rates i.e. above a selected threshold . At low vertex rates retained mode all or a significant portion of the vertex and primitive data for a scene may be saved and sorted prior to being rendered. These primitives may then be rendered to small subdivisions or windows of a display using on board memory local to the GPU. Once a window is completely rendered using the on board memory the pixels for the window may be written to the frame buffer in external memory. Such window based rendering significantly reduces graphics system bandwidth by reducing the number of times the GPU needs to read and write to external memory.

At higher vertex rates immediate mode all or a significant portion of the vertex and primitive data may be transmitted through the pipeline in a single pass without storing or sorting the primitives prior to rendering. Because time and resources are needed to store primitives when operating in retained mode retained mode may be unsuitable in situations or with applications where vertex rates exceed a selected threshold. That is retained mode may be unable to support e.g. keep up with triangle rates above a certain threshold without impairing performance. Although immediate mode operation may consume significantly more system bandwidth than retained mode operation the ability to switch between the two modes dynamically may be used to ensure that immediate mode is used only when vertex rates go up such as when playing 3D games or using complex 3D applications. When vertex rates go down which may occur most of the time depending on the way the computing device is used the graphics system may switch to retained mode to reduce system bandwidth and power consumption.

Referring to in selected examples the data buffers described in association with may include a vertex buffer a primitive buffer and a batch buffer . A vertex buffer may be used to store each vertex for a scene which may include attributes such as the position e.g. coordinates color texture lighting and other data associated with the vertex. A primitive buffer may be used to store each primitive e.g. triangle line output by the primitive assembler . This may include storing the vertices associated with each primitive . In certain examples the primitive buffer may store vertex indices identifying the vertices as opposed to storing the vertices themselves to avoid duplicating vertex data in the primitive buffer

In selected examples a bounding box may be calculated for each primitive passing through the geometry pass . This bounding box may be stored with the primitive in the primitive buffer . In certain examples a left coordinate a top coordinate a right coordinate and a bottom coordinate may be used to identify the bounding box of a primitive . The graphics driver may use the bounding box to determine if a primitive overlaps with a subdivision or window as will be shown in . In selected examples the primitive buffer may also store the area of each primitive. The setup engine may use the area to perform interpolation computations. Similarly the primitive buffer may store other data or attributes as needed.

In selected examples in accordance with the invention the data buffers may also include a batch buffer . The batch buffer may store information about batches of primitives that belong to the same object or have the same render state e.g. same texture . As will be described in more detail hereafter this batch information may be used to optimize window size and placement to encompass entire batches of primitives thereby allowing a batch of primitives to be rendered together in a single pass. In selected examples the batch buffer may store a batch bounding box for the entire batch the number of vertices in the batch and the number of primitives in the batch .

The data buffers described in simply provide one method for storing data without being limited to the illustrated approach. Indeed different methods groupings and formats may be used to store data needed for retained mode operation. Thus the buffers illustrated in may be modified to include fewer or additional buffers. Similarly different types of data may be added or deleted from the buffers as needed.

Referring to in selected examples a graphics driver in accordance with the invention may be configured to dynamically switch between retained mode and immediate mode to reduce system bandwidth and conserve power. In selected examples a graphics driver may include a bandwidth modulator module to perform the above stated functions. In certain examples the bandwidth modulator module may include a switching module an optimization module and a rendering module .

A switching module may be configured monitor an incoming vertex or triangle rate using a vertex triangle counter or other monitoring module . As mentioned previously this may be accomplished by monitoring the number of vertices that are received over a specified period of time the number of vertices that are received for a scene being processed or using other criteria. The switching module may then compare the rate to a threshold value . If the rate is greater than the threshold value the switching module may switch the graphics system to immediate mode or continue operating in immediate mode. If the rate is less than the threshold value the switching module may switch the graphics system to retained mode or continue operating in retained mode.

An optimization module may be configured to optimize the subdivisions or windows used to render primitives using the GPU s on board memory. For example the optimization module may optimize window size window placement or the order that windows are rendered to efficiently utilize system resources. For example window size and placement may be used to render an entire batch of primitives e.g. primitives associated with the same object or render state in a single window allowing the primitives to be rendered together in a single rendering pass. In other cases the windows may be enlarged to take advantage of larger on board memory on the GPU . In other cases the windows may be rendered in a specified order such that more significant or important objects or primitives are rendered prior to other objects or primitives. In yet other cases the windows may be sized and positioned to minimize the number of primitives that overlap multiple windows reducing the number of primitives that are rendered multiple times. In certain examples the optimization module may be configured to dynamically perform these optimizations on the fly when in retained mode.

Because the primitives may be stored in a single buffer rather than being sorted and stored in separate buffers which are associated with different windows of fixed size and position the optimization module may be very flexible in the way it sizes and positions windows. Once the windows are optimized primitives overlapping each window may be retrieved from the primitive buffer and transmitted to the rendering pass in the designated order .

A rendering module may be provided to render the primitives once the window size placement and order has been determined. For example the rendering module may determine the current window the window currently being rendered . A primitive batch determination module may then determine which primitives or batches of primitives overlap or are contained within the current window such as by evaluating the overlap between the primitive and batch bounding boxes and the current window . A transmission module may then send the primitives batches that overlap with the current window to the rendering pass by way of the pipe

Although the modules described in are shown as software modules included within the graphics driver in other examples one or more of the modules may be implemented outside the graphics driver such as within the GPU or within a separate application. Similarly in other examples the modules may be implemented in software hardware firmware or combinations thereof. Thus any hardware software firmware or the like which provides the stated function of the modules regardless of the module s location or method of implementation is intended to fall within the scope of the invention.

Referring to as mentioned a screen may be divided into subdivisions or windows which may then be rendered individually using on chip memory of the GPU . Once the dimensions and placement of the windows has been determined primitives overlapping each window may be retrieved from the primitive buffer and transmitted to the rendering pass . For example a primitive having a bounding box and a primitive having a bounding box may overlap the window and thus be transmitted to the rendering pass rendered using on chip memory and then resolved to the frame buffer when rendering the window . Similarly subsequent windows may be rendered sequentially in a designated order after rendering the first window

Referring to as mentioned the optimization module may in certain examples optimize window dimensions and placement to encompass selected primitives or entire batches of primitives thereby allowing primitives or batches of primitives to be rendered in a single pass and in a single window. For example the windows may be reorganized e.g. resized repositioned etc. to encompass primitives or batches of primitives that were formerly outside windows partially overlapping windows or divided across window boundaries. This may be accomplished by evaluating the primitive and batch bounding boxes prior to determining window size and placement. In selected examples the optimization module may ensure that the windows utilize the same memory footprint i.e. include the same number of pixels in order to effectively utilize on chip memory .

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described examples are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

