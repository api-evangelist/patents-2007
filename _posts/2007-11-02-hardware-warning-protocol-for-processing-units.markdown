---

title: Hardware warning protocol for processing units
abstract: Processing units are configured to capture the unit state in unit level error status registers when a runtime error event is detected in order to facilitate debugging of runtime errors. The reporting of warnings may be disabled or enabled to selectively monitor each processing unit. Warnings for each processing unit are propagated to an exception register in a front end monitoring unit. The warnings are then aggregated and propagated to an interrupt register in a front end monitoring unit in order to selectively generate an interrupt and facilitate debugging. A debugging application may be used to query the interrupt, exception, and unit level error status registers to determine the cause of the error. A default error handling behavior that overrides error conditions may be used in conjunction with the hardware warning protocol to allow the processing units to continue operating and facilitate in the debug of runtime errors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08127181&OS=08127181&RS=08127181
owner: NVIDIA Corporation
number: 08127181
owner_city: Santa Clara
owner_country: US
publication_date: 20071102
---
Embodiments of the present invention relate generally to a protocol for communicating errors in a computing system and more particularly to indicating programming errors in a processing unit when a program is run.

Current graphics program compilers detect illegal instructions in programs to enable program debugging. However some errors cannot be detected or prevented by graphics program compilers such as single bit errors in random access memories RAMs . More recently graphics devices are configured to detect runtime errors such as illegal operands that are not caught by the compiler and override the programmed state that causes an error using a default state to continue processing in a repeatable and predictable manner. This default error handling behavior can complicate debugging of the runtime errors since the device continues processing and information needed to debug the error is unavailable.

Accordingly what is needed in the art is a system and method for improving the ability to debug runtime errors while allowing for the default error handling behavior.

Processing units are configured to capture the unit state in unit level error status registers when a runtime error event is detected in order to facilitate debugging of runtime errors. The reporting of the error events as warnings may be disabled or enabled to selectively monitor each processing unit. Warnings for each processing unit are propagated to a front end monitoring unit and then logged in an exception register in the front end monitoring unit. The warnings are then aggregated and propagated to an interrupt register in order to selectively generate an interrupt and facilitate debugging. A debugging application may be used to query the interrupt exception and unit level error status registers to determine the cause of the error. The default error handling behavior that overrides error conditions may be used in conjunction with the hardware warning protocol to allow the processing units to continue operating following a runtime error event.

Various embodiments of a method of the invention for indicating warnings for a processing unit within a system include receiving an error event signal indicating that a programming error has been detected by the processing unit and then capturing error state information of the processing unit in an error status register. The capturing is triggered by the error event signal. An error bit in the error status register that indicates an error event has occurred and an exception bit in an exception register of a front end monitoring unit are updated to indicate a hardware warning that signals that the error event has been detected by the processing unit.

Various embodiments of the invention for a computing device configured to execute programs include a front end monitoring unit that is coupled to a processing unit. The front end monitoring unit includes an interrupt register and an exception register. The processing unit is configured to receive an error event signal indicating that a programming error has been detected and capture error state information of the processing unit in an error status register. The capturing is triggered by the error event signal. The processing unit updates an error bit in the error status register that indicates an error event has occurred and updates an exception bit in the exception register of the front end monitoring unit to indicate a hardware warning that the error event has been detected by the processing unit.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

Memory bridge which may be e.g. a Northbridge chip is connected via a bus or other communication path e.g. a HyperTransport link to an I O input output bridge . I O bridge which may be e.g. a Southbridge chip receives user input from one or more user input devices e.g. keyboard mouse and forwards the input to CPU via path and memory bridge . A parallel processing subsystem is coupled to memory bridge via a bus or other communication path e.g. a PCI Express Accelerated Graphics Port or HyperTransport link in one embodiment parallel processing subsystem is a graphics subsystem that delivers pixels to a display device e.g. a conventional CRT or LCD based monitor . A system disk is also connected to I O bridge . A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including USB or other port connections CD drives DVD drives film recording devices and the like may also be connected to I O bridge . Communication paths interconnecting the various components in may be implemented using any suitable protocols such as PCI Peripheral Component Interconnect PCI Express PCI E AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

An embodiment of parallel processing subsystem is shown in . Parallel processing subsystem includes one or more parallel processing units PPUs each of which is coupled to a local parallel processing PP memory . A pushbuffer shown as instruction stream buffer that specifies the location of data and program instructions for execution by each PPU may be stored in each PP memory . In general a parallel processing subsystem includes a number U of PPUs where U 1. Herein multiple instances of like objects are denoted with reference numbers identifying the object and parenthetical numbers identifying the instance where needed. PPUs and PP memories may be implemented e.g. using one or more integrated circuit devices such as programmable processors application specific integrated circuits ASICs and memory devices.

As shown in detail for PPU each PPU includes a host interface that communicates with the rest of system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. Host interface generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path and directs them to appropriate components of PPU . For example commands related to processing tasks may be directed to a front end unit while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a memory interface . Host interface may be of generally conventional design and a detailed description is omitted as not being critical to the present invention. Host interface receives interrupt signals from front end and outputs an interrupt reset to front end to clear the interrupt as explained further herein. Host interface may also read an interrupt register and an exception register in front end in addition to unit level error status reporting registers within cores .

Each PPU advantageously implements a highly parallel processor. As shown in detail for PPU a PPU includes a number C of cores where C 1. Each processing core is capable of executing a large number e.g. tens hundreds or thousands of threads concurrently where each thread is an instance of a program one embodiment of a multithreaded processing core is described below. A processing context encompasses a complete set of state through PPU while a thread may encompass only the state required to shade a single pixel. Threads run inside processing contexts one processing context might contain thousands of running threads. Cores receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from a front end unit . Work distribution unit can implement a variety of algorithms for distributing work. For instance in one embodiment work distribution unit receives a ready signal from each core indicating whether that core has sufficient resources to accept a new processing task. When a new processing task arrives work distribution unit assigns the task to a core that is asserting the ready signal if no core is asserting the ready signal work distribution unit holds the new processing task until a ready signal is asserted by a core .

Cores communicate with memory interface to read from or write to various external memory devices. In one embodiment memory interface includes an interface adapted to communicate with local PP memory as well as a connection to host interface thereby enabling the cores to communicate with system memory or other memory that is not local to PPU . Memory interface can be of generally conventional design and a detailed description is omitted.

Cores can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local PP memories into internal on chip memory process the data and write result data back to system memory and or local PP memories where such data can be accessed by other system components including e.g. CPU or another parallel processing subsystem .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by the pushbuffer via memory bridge and bus interacting with local PP memory which can be used as graphics memory including e.g. a conventional frame buffer instruction stream buffer texture maps and the like to store and update pixel data delivering pixel data to display device and the like. In some embodiments PP subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated PP memory device s or no dedicated PP memory device s .

In operation CPU is the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to instruction stream buffer and which may be located in system memory PP memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from instruction stream buffer and executes commands asynchronously with operation of CPU .

A compiler program executing on CPU or another CPU may be used to identify programming errors such as illegal instructions. However runtime errors may be undetected and front end may be configured to implement a default error handling and override illegal conditions so that processing units such as cores may continue processing. Cores are configured to capture the unit state in unit level error status registers when a runtime error event is detected in order to provide warnings and facilitate debugging of runtime errors. The reporting of the error events as warnings may be disabled or enabled to selectively monitor each core . Warnings for each core are propagated to an exception register in front end . The warnings are then aggregated and propagated to an interrupt register in front end in order to selectively generate an interrupt and facilitate debugging. Front end outputs enabled interrupts to host interface .

A debugging application i.e. runtime debugger may be used to query the interrupt exception and unit level error status registers via host interface and front end to determine the cause of any hardware warnings. The default error handling behavior that overrides error conditions may be advantageously used in conjunction with the hardware warning protocol to allow the processing units to continue operating.

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of PPU to the rest of system may also be varied. In some embodiments PP system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

A PPU may be provided with any amount of local PP memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment in such embodiments little or no dedicated graphics PP memory is provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory e.g. via a bridge chip.

As noted above any number of PPUs can be included in a parallel processing subsystem. For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of the PPUs could be integrated into a bridge chip. The PPUs in a multi PPU system may be identical to or different from each other for instance different PPUs might have different numbers of cores different amounts of local PP memory and so on. Where multiple PPUs are present they may be operated in parallel to process data at higher throughput than is possible with a single PPU .

Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Capturing all or at least a portion of the error state in error status register permits debugging of the program that caused the error at a later time such as after an image is rendered. Since each core within PPU includes an error status register the hardware error reporting protocol is systematic and consistent. Host interface is configured to access error status register to enable error status register to capture error state information read error status register during debug and reset error status register to clear the error state information.

Core finite state machine signals error status register to capture the error state and outputs an error event signal to an exception register within front end indicating that an error event has occurred in core . Error event signal causes an exception bit in exception register corresponding to the particular core to be updated. Exception register functions as a set reset flip flop to capture an assertion of each unit level error event signal . The bits of exception register are set by core and reset by host interface . Host interface can read exception register as needed to determine which core s reported a hardware warning. As shown in additional error event signals are provided to exception register by other cores .

In addition to exception register front end includes an exception enable register combining logic interrupt register interrupt enable register and interrupt logic . Front end may also include additional circuitry to perform functions other than the hardware warning protocol. For each bit in exception register there is a corresponding bit in exception enable register that is configured to enable or disable propagation of each hardware warning represented by a bit in exception register to interrupt register via combining logic . Host interface may write interrupt enable register to enable and disable warnings for one or more cores . The corresponding bits of exception register are combined with the bits in exception enable register as shown in combining logic to produce hardware warning bits that are aggregated to produce a hardware interrupt signal. As shown in an OR gate is used to aggregate the hardware warning bits into a single hardware interrupt signal. In other embodiments of the present invention other logic gates may be used to aggregate the hardware warning bits into one or more hardware interrupt signals.

The hardware interrupt signal is stored in interrupt register which functions as a set reset flip flop to capture an assertion of the hardware interrupt signal. The bit of interrupt register is set by combining logic and reset by host interface . Host interface can read interrupt register to determine if any cores initiated an interrupt. For the bit in interrupt register there is a corresponding bit in interrupt enable register which is configured to enable or disable propagation of the hardware interrupt to host interface . Host interface may write interrupt enable register to enable and disable interrupts. The corresponding bit of interrupt register is combined with the bit in interrupt enable register as shown in interrupt logic to produce an interrupt signal that is output to host interface .

Reset is a write only bit that can be written only by host interface . When reset is set error is reset and trapping of the error state for core in status is re enabled. Error is set by core finite state machine when an error event occurs reset by reset and read by core finite state machine to determine whether or not an error event is a first trapped error event for core following an assertion of error . Status includes one or more bits that are loaded by core finite state machine when a first trapped error event occurs and read by host interface . In other words status functions as a mousetrap to trap the error state for core and can represent any number of bits.

Once the trap is tripped by an error event setting error status stores and holds the error status. However core finite state machine may be configured to assert error event signal to front end for each error event not only the first trapped error event. Strobing reset re enables the trap to capture the error state in status for a subsequent error event. The bits in status are specific to core and a value of all zeros may be reserved to indicate that no error event has occurred. Additional error status registers may be included in core to capture more error state information. Examples of error state information include address values instruction words and the like.

A second error event error event occurs and error event signal is asserted. However status is not loaded with the error state information for the second error event since reset has not been asserted following the first error event error event . Once set error exception bit and interrupt bit remain asserted until they are each reset.

Host interface may read interrupt register exception register and error status register to facilitate debug of the first error event. Following any reading by host interface enable may be negated. In order to re enable trapping of error events host interface initiates reset event and reset is asserted. When reset is asserted status changes to reset status and error exception bit and interrupt bit are cleared. In other embodiments of the present invention status maintains error state information until the next trapped error event occurs. In the timing diagram of error exception bit and interrupt bit are all reset simultaneously. In other embodiments of the present invention error exception bit and interrupt bit may be reset during different clock cycles.

If in step core finite state machine determines that the error event is the first trapped error event then in step core finite state machine loads status with the error state information. In step core finite state machine sets error . In step core finite state machine asserts error event signal to write a hardware warning bit in exception register indicating that an error event has occurred for a core .

In step the hardware warning bit in exception register is combined with the corresponding exception enable bit of exception enable register and if the hardware warning bit is not enabled then front end proceeds directly to step . Otherwise in step combination logic aggregates the enabled hardware warning bit with other enabled hardware warning bits of exception register to produce a hardware interrupt signal. In step a hardware interrupt bit of interrupt register is written using the hardware interrupt signal.

In step the hardware interrupt is combined with the corresponding interrupt enable bit of interrupt enable register and if the interrupt enable bit is not enabled then front end proceeds directly to step and the hardware error reporting is complete. Otherwise in step the enabled hardware interrupt is output to host interface to signal that an error event has occurred in at least one processing unit.

If another hardware warning bit is not asserted then the driver software has obtained all of the error state information and it proceeds to step and clears the interrupt bit in interrupt register . Otherwise steps and are repeated for the additional core . In this manner the driver software is able to systematically obtain error state information for each first trapped error event for a processing unit. This error state information may then be used to diagnose and debug the runtime error event s while allowing the default error handing behavior to function during execution of the program.

In step the driver software reads interrupt register to determine if a hardware warning was been reported during execution of the program and if so in step the program may be run again in a debug mode. Additionally the driver software may obtain the error state information as described in conjunction with . If in step the driver software determines that a hardware warning was not reported during execution of the program then in step the program debug is complete.

The hardware warning protocol allows for error event state information to be captured and retained for use in debugging runtime programming errors while allowing for the default error handling to be used. The default error handling behavior advantageously overrides error conditions to allow the processing units to continue operating. Individual processing units may be enabled or disabled for reporting hardware warnings and interrupts may also be disabled or enabled. Therefore bogus warnings may be ignored while other warnings are detected and diagnosed.

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

