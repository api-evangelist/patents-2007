---

title: Simultaneously accessing file objects through web services and file services
abstract: Accessing data file objects includes providing a file system interface on a client, where the file system interface allows an application running on the client to make file system calls to access the data file objects. A Web Services interface may also be provided on the client, where the Web Services interface allows an application to access file objects using the Web Services at the same time that file objects are being accessed through the file system interface. The Web Services interface may be a SOAP interface and/or a REST interface. Accessing data file objects may also include providing a direct file object interface on the client, where the direct file object interface allows an application to directly access file objects at the same time that file objects are being accessed using the Web Services interface and using the file system interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836018&OS=07836018&RS=07836018
owner: EMC Corporation
number: 07836018
owner_city: Hopkinton
owner_country: US
publication_date: 20071024
---
This application relates to the field of storing data and more particularly to the field of data storage services in a scalable high capacity system.

It has been estimated that the amount of digital information created captured and replicated in 2006 was 161 exabytes or 161 billion gigabytes which is about three million times the information in all the books ever written. It is predicted that between 2006 and 2010 the information added annually to the digital universe will increase more than six fold from 161 exabytes to 988 exabytes. The type of information responsible for this massive growth is rich digital media and unstructured business content. There is also an ongoing conversion from analog to digital formats film to digital image capture analog to digital voice and analog to digital TV.

The rich digital media and unstructured business content have unique characteristics and storage requirements that are different than structured data types e.g. database records for which many of today s storage systems were specially designed. Many conventional storage systems are highly optimized to deliver high performance I O for small chunks of data. Furthermore these systems were designed to support gigabyte and terabyte sized information stores.

In contrast rich digital media and unstructured business content have greater capacity requirements petabyte versus gigabyte terabyte sized systems less predictable growth and access patterns large file sizes billions and billions of objects high throughput requirements single writer multiple reader access patterns and a need for multi platform accessibility. Conventional storage systems have met these needs in part by using specialized hardware platforms to achieve required levels of performance and reliability. Unfortunately the use of specialized hardware results in higher customer prices and may not support volume economics as the capacity demands grow large a differentiating characteristic of rich digital media and unstructured business content.

Some of the cost issues have been addressed with tiered storage which attempts to reduce the capital and operational costs associated with keeping all information on a single high cost storage tier. However tiered storage comes with a complex set of decisions surrounding technology data durability functionality and even storage vendor. Tiered storage solutions may introduce unrelated platforms technologies and software titles having non zero operational costs and management requirements that become strained as the quantity of data increases.

In addition tiered storage may cause a data replica incoherence which results in multiple disjoint copies of information existing across the tiers of storage. For example storage management software handling data backup and recovery may make multiple copies of information sets on each storage tier e.g. snapshots backup sets etc . Information Life cycle Management ILM software dealing with information migration from one tier to another may create additional and often overlapping copies of the data. Replication software may make an extra copy of the information set within a particular tier in order to increase performance to accessing applications. Each of these functions typically runs autonomously from one another. The software may be unable to realize and or take advantage of the multiple replicas of the same information set.

In addition for large scale unstructured information stores it may be difficult to maintain a system and manage the environment as components fail. For example a two petabyte information store may be comprised of eight thousand 250 gigabyte disk drives. Disk failures should be handled in a different manner in a system of this scale so that the system continues to operate relatively smoothly whenever one or only a few of the disk drives fail.

Thus it would be desirable to provide a storage system that addresses difficulties associated with high cost specialized hardware storage tiering and failure management.

According to the system described herein accessing data file objects includes providing a file system interface on at least one client where the file system interface allows an application running on the at least one client to make file system calls to access the data file objects and providing a Web Services interface on the at least one client where the Web interface allows an application to access file objects using the Web at the same time that file objects are being accessed through the file system interface. The Web Services interface may be a SOAP interface and or a REST interface. Accessing data file objects may also include providing a direct file object interface on the at least one client where the direct file object interface allows an application to directly access file objects at the same time that file objects are being accessed using the Web Services interface and using the file system interface. Accessing data file objects may also include providing file name services that translate file names into file object identifiers where the file name services are accessed by the file system interface and or the Web Services interface. Providing the file system interface may include providing a virtual file system in a kernel address space of the at least one client. Accessing data file objects may also include providing a layout manager that manages file objects. The layout manager may be provided in the kernel address space of the at least one client. The layout manager is provided in user address space of the at least one client. The virtual file system may access the layout manager using a bridge between kernel memory address space and user memory address space.

According further to the system described herein a client that accesses a plurality of file objects includes a file system interface that allows an application running on the at least one client to make file system calls to access the data file objects a Web Services interface that allows an application to access file objects using the Web at the same time that file objects are being accessed through the file system interface and a communication interface coupled to the file system interface and to the Web Services interface that exchanges file object data between the client and a plurality of servers containing the file objects. The client may also include a direct file object interface that allows an application to directly access file objects at the same time that file objects are being accessed using the Web Services interface and using the file system interface. The client may also include a file name service that translates file names into file object identifiers where the file name service is accessed by the file system interface and or the Web Services interface. The file system interface may include a virtual file system in a kernel address space of the at least one client. The client may also include a layout manager that manages file objects. The layout manager may be provided in the kernel address space of the at least one client. The layout manager may be provided in user address space of the at least one client. The virtual file system may access the layout manager using a bridge between kernel memory address space and user memory address space.

According further to the system described herein computer software provided in a computer readable storage medium includes executable code that allows an application running on at least one client to make file system calls to access the data file objects and includes executable code that allows an application to access file objects using the Web at the same time that file objects are being accessed through the file system interface. The computer software may also include executable code that allows an application to directly access file objects at the same time that file objects are being accessed using the Web and using file system calls. The computer software may also include executable code that translates file names into file object identifiers.

According further to the present invention a system simultaneously allows accessing a plurality of file objects using a file system interface and a Web Services interface. The system includes a plurality of servers that contain the file objects and at least one client coupled to the servers. The client includes a file system interface that allows an application running on the at least one client to make file system calls to access the data file objects a Web Services interface that allows an application to access file objects using the Web at the same time that file objects are being accessed through the file system interface and a communication interface coupled to the file system interface and the Web Services interface that exchanges file object data between the client and a plurality of servers containing the file objects. The file system interface may include a virtual file system in a kernel address space of the client.

According further to the system described herein managing objects for a data file includes obtaining a metadata object for the file determining if the metadata object indicates that a portion of the data file includes synchronous mirrors and in response to a write of new data to the data file writing the new data to each synchronous mirror. Data objects of a data file may be in one of four states current stale empty and immutable. In response to a read operation and the corresponding data object being in a stale state data may be read for a corresponding synchronous mirror that is in a current state.

Referring to a diagram illustrates servers coupled to a plurality of clients . Each of the clients represents one or more processing devices that receives file services from the servers . Each of the clients may or may not be independent of other ones of the clients . One or more of the clients may be a multiprocessing multiuser system and possibly have multiple independent users. The clients are meant to represent any number of clients.

The file services provided by the servers may include data storage and retrieval as well as related operations such as data mirroring cloning etc. The servers may be implemented using a plurality of services and or interconnected file servers including SAN components that are provided by interconnected processing and or storage devices. In an embodiment herein each of the clients may be coupled to the servers using the Web possibly in conjunction with local TCP IP connections. However it is possible for one or more of the clients to be coupled to the servers using any other appropriate communication mechanism and or combinations thereof to provide the functionality described herein.

Referring to the client is shown as being coupled to the servers and to one or more other network s . The other network s may include a local area network LAN . Thus the client may be a gateway between the servers and a LAN to which one or more other devices not shown may also be coupled. The client may act as a local file server to the one or more other devices coupled to the LAN by providing data from the servers to the one or more other devices. Of course it is possible for one or more other clients to simultaneous act as gateways to the same or different other network s . Generally for the discussion herein reference to a particular one of the clients may be understood to include reference to any or all of the clients coupled to the servers unless otherwise indicated.

Referring to a diagram shows the client being coupled to the servers and one or more other network s e.g. a LAN in a configuration that is different from that shown in . In the configuration of a router is coupled between the servers and the client . The router may be any conventional router that may be accessed by the client . In the configuration of the client uses only a single connection point to both the servers and to the other network s . In the configuration of the client may act as local file server and gateway between the servers and one or more other devices not shown coupled to the other network s . Of course any other appropriate connection configurations may be used by any of the client coupled to the servers and or to other network s .

Referring to the client is shown in more detail having server operations software client software and an interface layer that includes a plurality of interfaces between the server operations software and the client software . The server operations software facilitates the exchange of information data between the client and the servers to provide the functionality described herein. The server operations software is described in more detail elsewhere herein. The client software represents any software that may be run on the client including application software operating system software Web server software etc. that is not part of the server operations software or the interface layer . As described in more detail elsewhere herein it is possible to have the client software interact with the servers through different ones of the interfaces at the same time.

The file services described herein may be implemented by the servers using a set of file objects where a file that is accessed by the client software includes a metadata file object which points to one or more data file objects that contain the data for the file. Accessing the file would involve first accessing the metadata file object to locate the corresponding data file objects for the file. Doing this is described in more detail elsewhere herein. Note however that any appropriate file object mechanism may be used for the system described herein.

Referring to a file is shown as including a metadata file object and a plurality of data file objects. The metadata file object contains information that points to each of the data file objects . Accessing the file includes first accessing the metadata file object and then using information therein to locate the appropriate one or more of the corresponding data file object .

Referring to the metadata file object is shown in more detail as including an object attributes section and a Layout Storage Object LSO tree section . The object attributes section contains conventional file type attributes such as owner id group id access control list last modification time last access time last change time creation time file size and link count. Many of the attributes are self explanatory. The last modification time corresponds to the last time that the data for the data objects had been modified while the last change time corresponds to when the object metadata had last been changed. The link count indicates the number of other objects that reference a particular file e.g. aliases that point to the same file . In an embodiment herein a file and its related objects are deleted when the link count is decremented to zero.

The LSO tree section includes a data structure that includes one or more maps for mapping the logical space of the file to particular data file objects. The LSO tree section may also indicate any mirrors for the data and whether the mirrors are synchronous or asynchronous. LSO trees and mirrors are described in more detail elsewhere herein.

Referring to a simple LSO tree is shown as including an LSO root node and a single map . The LSO root node is used to identify the LSO tree and includes links to one or more map s used in connection with the file corresponding to the LSO tree . The map maps logical locations within the file to actual data storage location. A process that accesses logical storage space of a file represented by the LSO tree first uses the LSO root node to find the map and then uses the map to translate logical addresses within the file to an actual data storage locations.

Referring to an LSO tree is shown as including an LSO root node and a plurality of maps . Each of the maps may represent a different range of logical offsets within the file corresponding to the LSO tree . For example the map may correspond to a first range of logical offsets in the file. The map may map logical locations in the first range to a first actual storage device. The map may correspond to a second range of logical offsets in the file different than the first range which may be mapped to a different actual storage device or may be mapped to the same actual storage device as the map . Similarly the map may correspond to a third range of logical offsets in the file different than the first range and the second range which may be mapped to a different actual storage device or may be mapped to the same actual storage device as the map and or the map .

Referring to an LSO tree is shown as including an LSO root node and a pair of replication nodes which indicate that the underlying data is to be mirrored replicated and which indicate whether the mirror is synchronous or asynchronous. Synchronous and asynchronous mirrors are discussed in more detail elsewhere herein. The node has a plurality of children maps associated therewith while the node has a plurality of children maps associated therewith. The replication nodes indicate that the data corresponding to the maps is a mirror of data corresponding to the maps . In some embodiments the nodes may be implemented using a single node to indicate replication.

A process accessing a file having the LSO tree would traverse the tree and determine that data is mirrored. As discussed in more detail elsewhere herein depending upon the type of mirroring the process accessing the LSO tree would either write the data to the children of both of the nodes or would provide a message to another process server e.g. the servers that would perform the asynchronous mirroring. Mirroring is discussed in more detail elsewhere herein.

For the system described herein file objects are accessed by one of the clients by first requesting and obtaining a lease from the servers . The lease corresponds to the file objects for the particular file being accessed and to the type of access. A lease may be for reading writing and or more some other operation e.g. changing file attributes . In an embodiment herein for objects corresponding to any particular file the servers may issue only one write lease at a time to any of the clients but may issue multiple read leases simultaneously and may issue read lease s at the same time as issuing a write lease. However in some embodiments it may be possible to obtain a lease for a specified logical range of a file for operations only on that range. Thus for example it may be possible for a first client to obtain lease for writing to a first logical range of a file while a second client may independently obtain a lease for writing to a second and separate logical range of the same file. The two write leases for different logical ranges may overlap in time without violating the general rule that the system never issues overlapping write leases for the same data.

The lease provided to the clients from the servers includes security information security token that allows the client appropriate access to the data. The security token may expire after a certain amount of time. In an embodiment herein a client accesses data by providing an appropriate security token for the data as well as client users ownership information. Thus for example a user wishing to access data would first obtain a lease and then would provide the access request to the servers along with the security token and information identifying the owner client accessing the data. The servers would then determine whether the access requested by the client was permissible. After the lease expires the security token expires the user requests the lease again. Data security may be implemented using conventional data security mechanisms.

After obtaining a lease for accessing a file a client may then cache the corresponding metadata including the LSO tree into local storage of the client. The client may then use and manipulate the local cached version of the metadata and may use the metadata to obtain access to the data. As described in more detail elsewhere herein a client does not directly modify metadata stored by the servers but instead sends update messages to the servers to signal that metadata for a file may need to be modified by the servers .

Referring to a flowchart illustrates steps performed by a client in connection with requesting a lease for a file objects associated with a file for performing operations thereon. Processing begins at a first step where the client requests the lease for the file. As discussed in more detail elsewhere herein a client requesting a lease includes specifying the type of access e.g. read write etc. . Following the step is a test step where it is determined if the request has been granted. If not then control transfers from the test step to a step where processing is performed in connection with the lease not being granted to the client. The particular processing performed at the step may include for example providing an error message to the client process requesting access to the file corresponding to the lease and or waiting for an amount of time and then retrying the request. Note that it is possible that a lease for a particular file is not available at one time is subsequently available at another time because for example the lease is released by another client in between the first request and the second request. In any event any appropriate processing may be performed at the step . Following the step processing is complete.

If it is determined at the test step that the least requested at the step has been granted then control transfers from the test step to a step where the client performs an operation using the file for which the lease was granted. Operations performed at the step include reading data and or writing data. Different types of processing that may be performed at the step are described in more detail elsewhere herein.

Following the step is a test step where it is determined if the operations performed at the step require an update. In some instances a client may obtain a lease and perform operations that do not affect the file or the underlying file objects. For example a client may acquire a lease for reading a file and the operation performed at the step may include the client reading the file. In such a case no update may be necessary since the file and corresponding file objects metadata data objects etc. have not changed. On the other hand if the client obtains a lease for writing data the file and the operation performed at the step includes writing data to the file then the underlying file objects will have been changed and an update message needs to be sent the servers . If it is determined at the test step that an update is necessary then control passes from the test step to a step where an update message is sent by the client to the servers .

Following the step or following the step if no update is necessary control passes to a test step where it is determined if the client is finished with the file. In some instances the client may perform a small number of operations on the file after which the client would be finished with the file at the step . In other cases the client may be performing a series of operations and may not yet have completed all of the operations.

If it is determined at the test step that the client is not finished with the file then control passes from the test step to a test step where it is determined if the lease for the file has expired. Note that a lease may be provided by the servers to the client with a particular expiration time and or the associated security token may expire. In addition it may be possible for the servers to recall leases provided to clients under certain circumstances. In either case the lease may no longer be valid. Accordingly if it is determined at the step that the lease has expired and or has been recalled by the servers then control passes from the test step back to the step request the lease again. Otherwise if the lease has not expired then control passes from the test step back to the step to perform another iteration.

If it is determined at the test step that the client is finished with the file then control passes from the test step to a step where the client releases the lease by sending a message to the servers indicating that the client no longer needs the lease. Once the client releases the lease it may be available for other clients. Following the step processing is complete.

In an embodiment herein data file objects may be indicated as having one of four possible states current stale immutable or empty. The current state indicates that the data object is up to date and current. The stale state indicates that the data is not valid but instead requires updating perhaps by some other process. In some instances the stale state may be used only in connection with mirror copies of data explained in more detail elsewhere herein . Data may be stale because it is a mirror of other data that was recently written but not yet copied. The immutable state indicates that the corresponding data is write protected perhaps in connection with a previous clone snapshot operation. The empty state indicates that no actual storage space has yet been allocated for the data.

Referring to a flow chart illustrates steps performed by a client in connection with performing read operations after obtaining a read lease for a file. Processing begins at a first test step where it is determined if the data object being read is in the current state. If not then control transfers from the test step to a step where it is determined if the data object being read is in the immutable state. If it is determined at the step that the data object being read is in the immutable state or if it is determined at the test step that the data object being read is in the current state then control transfers to a step where the read operation is performed. A client reads file data by providing the appropriate data file object identifier to the servers as well as providing appropriate security credentials. Accordingly the read operation performed at the step includes the client sending an appropriate request to the servers and waiting for a result therefrom.

Following the step is a test step where it is determined if the servers have returned a result indicating that the data file object is unavailable. In some cases a data file object that is otherwise current or immutable may nevertheless become unavailable. For example the physical storage space that holds the data file object may become temporarily disconnected and or temporarily busy doing some other operation. If it is determined at the test step that the data file object is available then control transfers from the test step to a test step where it is determined if the read operation was successful. If so then control transfers from the test step to a step where the result of the read operation is returned to the process at the client that caused the read operation to be performed. The result may include the data that was read and a status indicator. Following the step processing is complete.

If it is determined at the test step that the read operation performed at the step was not successful then control transfers from the test step to a step where error processing is performed. The particular error processing performed at the step is implementation dependent and may include for example reporting the error to a calling process and or possibly retrying the read operation a specified number of times. Following the step processing is complete.

If it is determined at the test step that the data object being read is not in the immutable state then control transfers from the test step to a test step where it is determined if the data object is in the stale state. If not then by virtue of the test steps and process of elimination the data object is in the empty state. In an embodiment herein reading a data object in the empty state causes zeros to be returned to the calling process. Accordingly if it is determined at the test step that the data object is not in the stale state then control transfers from the test step to a step where zeros are returned in response to the read operation. Following the step processing is complete.

If it is determined at the test step that the data file object is in the stale state or if it is determined at the test step that the data file object is not available then control transfers to a test step to determine if an alternative version of the data file object is available for reading. As discussed in more detail elsewhere herein there may be multiple versions of the same data file objects that exist at the same time due to mirroring. Accordingly if the data file object being read is in the stale state or otherwise unavailable it may be possible to read a mirror copy of the data file object that may be in the current state. The test performed at the step is described in more detail elsewhere herein.

If it is determined at the test step that an alternative version of the data file object is available then control transfers from the test step to a step where the alternative version of the data file object is selected for use. Following the step control transfers back to the test step for another iteration with the alternative data file object.

If it is determined at the test step that an alternative version of the data file object is not available then control transfers from the test step to a step where the client process waits. In an embodiment herein it may be desirable to wait for a data file object to become current and or available. Following the step control transfers back to the step for another iteration. Note that instead of waiting at the step processing may proceed from the step to the step to perform error processing if there is no alternative data file object available. In other embodiments it may be possible to perform the step a certain number of times and then if the data file object is still unavailable or in the stale state and there is no alternative data file object then perform the error processing at the step .

Referring to a flow chart illustrates steps performed by a client in connection with performing write operations after obtaining a write lease for a file. Processing begins at a first test step where it is determined if the data file object to which the write is being performed is in the immutable state. If so then control transfers from the step to a step where new actual storage space is allocated for the data file object to avoid overwriting the immutable data. Allocating new storage space for a data object may include providing an appropriate request to the servers . Following the step control transfers back to the step to begin the processing for the write operation again.

If it is determined at the step that the data file object to which the write is being performed is not in the immutable state then control transfers from the step to a step where it is determined if the data file object to which the write is being performed is in the stale state. If not then control transfers from the test step to a test step where it is determined if the data file object to which the write is being performed is in the empty state. If so then control transfers from the step to the step discussed above where new physical storage space is allocated. Following the step control transfers back to the step to begin the processing for the write operation again.

If it is determined at the step that the data file object to which the write is being performed is not in the empty state then control transfers from the test step to a step where the write operation is performed. Note that the step is reached if the data file object to which the write operation is being performed is not in the immutable state not in the stale state and not in the empty state and thus is in the current state . A client writes file data by providing the appropriate data file object location identifier to the servers as well as providing appropriate security credentials. Accordingly the write operation performed at the step includes the client sending an appropriate request to the servers and waiting for a result therefrom.

Following the step is a test step where it is determined if the write operation performed at the step was successful. If so then control transfers from the test step to a test step where it is determined if there are synchronous mirrors of the data file object to which the write is being performed. The test performed at the step may include for example determining if a parent node of the data file object in the file LSO tree indicates replication. If not then control transfers from the test step to a step where an update message is sent to the servers indicating that the write had been performed. Following the step processing is complete.

If it is determined at the test step that there are synchronous mirrors of the data file object to which the write is being performed then control passes from the test step to a step where the data that was written at the step is also written to the synchronous mirror s . The processing performed at the step is discussed in more detail elsewhere herein. Following the step control transfers to the step discussed above where an update message is sent to the servers . Following the step processing is complete.

If it is determined at the test step that the write operation performed at the step was not successful or if it is determined at the test step that the data file object to which the write operation is being performed is in the stale state then control transfers to a step where the data file object to which the write is attempting to be performed is removed from the client s local copy of the LSO tree. At the end of the write operation illustrated by the flow chart the client may inform the servers at the step of the difficulty in writing to the data object so that the servers can take appropriate action if necessary.

Following the step is a test step where it is determined if an alternative version of the data is available. As discussed in more detail elsewhere herein there may be multiple versions of the same data file objects that exist at the same time due to mirroring. Accordingly if the data file object to which the write operation is being performed is stale or otherwise cannot be written to it may be possible to write to a mirror copy of the data. The test performed at the step is like the test performed at the step and is described in more detail elsewhere herein. If it is determined at the test step that an alternative version of the data corresponding to the data file object is available then control transfers from the test step to a step where the alternative version is selected for writing. Following the step control transfers back to the test step for another iteration with the alternative data file object.

If it is determined at the test step that an alternative version of the data corresponding to the data file object is not available then control transfers from the test step to a step to perform error processing if there is no alternative available. The particular error processing performed at the step is implementation dependent and may include for example reporting the error to a calling process and or possibly retrying the write operation a specified number of times before reporting the error. Following the step control transfers to the step discussed above to send update information to the servers . Following the step processing is complete.

Referring to a flow chart illustrates in more detail steps performed in connection with the alternative available test step of and or the alternative available test step of . Processing begins at a first test step where it is determined if the file has any mirror data file objects at all. In some instances a file may not use mirrors in which case there would be no alternative copy available. Accordingly if it is determined at the test step that the file does not have any mirror data file objects then control transfers from the test step to a step where a value is returned indicating that no alternative copies are available. Following the step processing is complete.

If it is determined at the test step that mirror copies are available then control transfers from the test step to a step where a pointer is made to point to a first mirror data file object. For the processing discussed herein a pointer may be used to iterate through mirror data file objects to find a useable data file object. Following the step is a test step where it is determined if the pointer is past the end of the list of mirror data file objects has iterated through all of the mirror data file objects . If so then control passes from the test step to the step discussed above to return a value that indicates that no alternatives are available.

If it is determined at the test step that the pointer is not past the end of a list of mirror data file objects then control transfers from the test step to a test step where it is determined if the pointer points to a data file object in a stale state. If so then control transfers from the test step to a step where the pointer is made to point to the next data file object to be examined. Following the step control transfers back to the step discussed above for another iteration. If it is determined at the test step that the pointer does not point to a data file object in the stale state then control transfers from the test step to a step where the data file object that is pointed to by the pointer is returned as an alternative data file object that may be used by the calling process. Following the step processing is complete.

Referring to a flow chart illustrates in more detail operations performed in connection with the step of the flow chart of where data that has been written is copied to a number of synchronous mirrors mirror data file objects . Processing begins at a first step where a pointer that is used to iterate through the mirror data file objects is set to point the first one of the mirror data file objects. Following the step is a test step where it is determined if the pointer used for iterating through the mirror data file objects points past the end i.e. if all of the mirror data file objects have been processed . If so then processing is complete. Otherwise control transfers from the test step to a test step where it is determined if the status of the mirror data file object pointed to by the pointer indicates that the mirror data file object is current. If not then control passes from the test step to a test step where it is determined if the status of the mirror data file object pointed to by the pointer indicates that the mirror data file object is in the stale state. If so then control passes from the test step to a step where the mirror data file object is removed from the client s local copy of the LSO tree. In an embodiment herein a synchronous mirror data file object should not be in a stale state and if that occurs it may indicate an error condition. Accordingly following the step is a step where information about the stale mirror is sent to the servers which may perform recovery processing in response thereto.

Note that if a mirror data file object is neither in the stale state nor in the current state then the mirror data file object is either in the empty state or in the immutable state. In either case it may be necessary to allocate new space for a data file object to which the data is to be written. Accordingly if it is determined at the test step that the data file object is not in the stale state then control passes from the test step to a step where new space is allocated for the mirror data file object. Following the step is a step where the data that is being copied across synchronous mirror data file objects is written to the mirror data file object pointed to by the pointer used to iterate through the mirror data file objects. Note that the step may also be reached from the test step if it is determined that the mirror data file object is current. Following the step is a step where the pointer used to iterate through the mirror data file objects is made to point to the next one. Note that the step is also reached following the step . Following the step control transfers back to the test step for another iteration.

The system described herein may access file objects using object identifiers. In an embodiment herein each file object that is stored among the servers may be assigned a unique object identifier that identifies each file object and distinguishes each file object from other file objects in the system. However many applications use a file naming structure and or a hierarchical directory to access files and data therein. For example a file name C ABC DEF GHI.doc indicates a file called GHI.doc stored in a sub directory DEF that is stored in another directory ABC located on a root volume C . A nested directory structure may be provided by implementing directories as special files that are stored in other directories. In the example given above the sub directory DEF may be implemented as a file stored in the directory ABC .

The system described herein may present to applications a conventional naming structure and directory hierarchy by translating conventional file names into file object identifiers. Such a translation service may be used by other services in connection with file operations. In an embodiment herein each directory may include a table that correlates file names and sub directory names with file object identifiers. The system may examine one directory at a time and traverse sub directories until a target file is reached.

Referring to a flow chart illustrates steps performed in connection with providing a file name translation service file name service that translates a conventional hierarchical file name into a file object identifier. The file name service may receive a conventional hierarchical file name as an input and may return an object identifier or in some cases an error . Processing begins at a first step where the file name service receives a file name such as a conventional hierarchical file name. Following the step is a test step where it is determined if the syntax of the file name is OK. Checking the syntax of a hierarchical file name is know and includes for example checking that only appropriate characters have been used. If it is determined at the test step that the syntax is not OK then control transfers from the test step to a step where an error indicator error message is returned to the calling process. Following the step processing is complete.

If it is determined at the test step that the syntax of the provided name is OK then control transfers from the test step to a step where the root directory is read. In an embodiment herein all file name paths begin at a single common root directory used for all file objects stored in the servers . In other embodiments there may be multiple root directories where specification of a particular root directory may be provided by any appropriate means such as using a volume identifier specifically selecting a particular root directory etc.

Following the step is a test step where it is determined if the target file or sub directory that is part of the file name path is in the directory that has been read. If not then control passes from the test step to the step discussed above where an error is returned. In some embodiments the file not found error that results from the test at the step may be different from the syntax error that results from the test at the step .

If it is determined that the target file or a sub directory that is part of the file name path is in the directory that has just been read then control passes from the test step to a test step where it is determined if the directory that has just been read contains the target file as opposed to containing a sub directory that is part of the file name path . If so then control passes from the test step to a step where the object identifier of the target file object is returned to the calling process. Following the step processing is complete.

If it is determined at the test step that the directory that has just been read contains a sub directory that is part of the file name path then control transfers from the test step to a step where the sub directory is read so that the sub directory becomes the directory being examined. In effect processing at the step traverses the chain of subdirectories to eventually get to the target file. Following the step control transfers back to the step discussed above for a next iteration.

Referring to a diagram shows the client as including user address memory space and kernel address memory space. In an embodiment herein user address memory space is memory space that is generally used by user applications and related processes while kernel address memory space is memory space that is generally accessible only by system processes such as an operating system kernel and related processes. As discussed in more detail herein it is possible to have different portions of the system described herein reside and operate in the user memory space and or the kernel memory space. In addition it is possible for the client to have multiple different interfaces to access file objects at the servers.

In the client is shown as including an application in the user memory address space and a virtual file system VFS file name services kernel I O drivers a layout manager and a communication interface in the kernel memory address space. The VFS is an abstraction layer on top of a more concrete file system. The purpose of a VFS is to allow client applications to access different types of concrete file systems in a uniform way. The VFS allows the application running on the client to access file objects on the servers without the application needing to understand the details of the underlying file system. The VFS may be implemented in a conventional fashion by translating file system calls by the application into file object manipulations and vice versa. For example the VFS may translate file system calls such as open read write close etc. into file object calls such as create object delete object etc.

The VFS may use the file name services described elsewhere herein to translate file names into object identifiers. The kernel I O drivers provide an interface to low level object level I O operations. The kernel I O drivers may be modeled after and be similar to Linux I O drivers. The layout manager may perform some of the processing on LSO trees corresponding to files as discussed in more detail elsewhere herein. The communication interface provides communication between the client and the servers . The communication interface may be implemented using any appropriate communication mechanism. For example if the client communicates with the servers via an Internet connection then the communication interface may use TCP IP to facilitate communication between the servers and the client .

The application of may correspond to the client software of . The VFS of may correspond to one of the interfaces of . The file name services kernel I O drivers layout manager and communication interface of may correspond to the server operations software of . Similar correlation between components of and other figures may also be found.

Referring to a flow chart illustrates steps performed by a VFS to provide file services in connection with an application running on the client . Processing begins at a first step where a file system operation requested by an application may be translated into one or more object operations. For example a file operation to open a file for reading may be converted to object operations that include obtaining an object lease for reading as discussed elsewhere herein. Following the step is a step where the VFS translates the file name into an object identifiers using the file name services discussed above in connection with . Operations that follow may be performed using the object identifiers obtained at the step .

Following the step is a test step where it is determined if the requested operation requires the LSO tree. As discussed elsewhere herein operations such as read write etc. use LSO trees corresponding to file objects. However some possible file operations may not require accessing a corresponding LSO tree. If it is determined at the test step that the LSO tree is needed then control transfers from the test step to a step where the VFS accesses the LSO manager to perform the necessary operations. For example for a read operation the LSO manager may perform processing like that illustrated in the flow chart of . Following the step or following the step if the LSO is not needed is a step where the operations are passed to low level kernel I O drivers e.g. via one or more appropriate API s . The kernel I O drivers use the communication module to communicate between the client and the servers in connection with performing the requested operation s . In instances where the application running on the client has requested data and or other information from the servers the data and or information may be passed back up through the communication interface kernel I O drivers etc. to the VFS and ultimately to the application.

Referring to the client is shown as having an application file name services user level I O drivers and a layout manager all provided in user memory address space. The functionality of the VFS that was shown in and described above may be performed instead by library routines linked to the application and thus are part of the application. These routines would provide functionality like that discussed above in connection with . Accordingly it is the application that uses the file name services and makes calls to the user level I O drivers like the kernel I O drivers and to the layout manager. The communication interface is still maintained in the kernel memory address space.

Note that for the configuration of modifications are provided by modifying system processes the operating system which is disadvantageous for a number of reasons. For example if the client is a multiuser computing system then modifying the operating system may involve restarting the entire system and thus disrupting all of the users. In contrast the configuration of is advantageous since it allows modification of the system in the application user memory address space so that the operating system of the client does not need to be modified. However the configuration of does not use a VFS and thus does not obtain the advantageous separation of the application from the file system that is provided by the VFS in .

Referring to the client is shown as having an application in user memory address space that accesses file objects through a VFS in kernel memory address space like that illustrated in . However the file name services I O drivers and the layout manager all reside in the user memory address space like the system illustrated in . The VFS communicates with components in the user memory address space through a bridge between kernel memory address space and user memory address space such as a FUSE or similar interface. The bridge allows file system components to be provided in user memory space instead of kernel address memory space while still preserving the VFS in the kernel address memory space. Thus the configuration illustrated by provides the advantages of using a VFS as illustrated in the configuration of along with the advantages of having file system components in the user address memory space as illustrated in the configuration of .

It is possible in some instances to have applications and or other processing in the user memory address space of the client access file objects directly rather than through a file services layer like the VFS and or equivalent functionality provided by user linkable libraries e.g. the configuration illustrated in . Accessing file objects directly may include invoking routines that create objects read objects modify objects delete objects etc. In such a case the application would need to know how to interpret and or manipulate the object data which may not always be desirable. For example an application that accesses file objects through the VFS may not need to take into account or even know about the structure of an LSO tree while an application that accesses objects directly may need to use the LSO tree. On the other hand removing the file services layer may provide an opportunity for optimizations not otherwise available. Note that since the servers exchange object information operations with the clients the servers may not need to distinguish or be able to distinguish between application on the clients using a file system interface file services like the VFS and those that are not.

Referring to the client is shown as including an application in the user memory address space and kernel I O drivers a layout manager and file name services in the kernel memory address space. The configuration illustrated in is like that illustrated in except that the VFS is not used. In the configuration illustrated in the application could directly access the file name services the kernel I O drivers and the layout manager. The communication interface in the kernel memory address space communicates with the servers just as in other configurations. The direct access illustrated in allows applications to manipulate file objects via for example appropriate API s while access via the VFS or similar allows applications to accesses file objects indirectly through file system calls to the VFS.

Referring to the client is shown as having an application user level I O drivers a layout manager and file name services all provided in user memory address space. The configuration shown in is like that shown in . However as set forth above the configuration of includes file service libraries that are linked into and thus part of the application. In contrast in the configuration of the application is not linked into libraries with extensive file services. Instead like the application of the configuration illustrated in the application in the configuration of uses minimal file services and instead uses and operates upon file objects directly using the user level I O drivers the layout manager and if a file name translation is needed the file name services.

Referring to the client is shown as having an application in user memory address space and a bridge in the kernel memory address space. File name services user level I O drivers and a layout manager are provided in user memory address space. However unlike the configuration of the application does not make direct calls to the file system components in the user memory address space. Instead the application calls the file system components indirectly through the bridge. Just as with the configuration illustrated in the configuration of advantageously locates file system components in the user memory address space and at the same time provides a kernel memory address space layer between the application and the file system components.

Referring to the client is shown as having an application in user memory address space and a Web Services module in kernel memory address space. The application may be a Web server application or any application that handles communication with the Web. In an embodiment herein the application allows communication with the client which acts as a Web server to other computing devices not shown that access the client through a Web connection.

The configuration illustrated in provides Web Services in a manner similar to the file services and or file object access provided by other configurations. However the Web Services receives requests data via a Web data protocol such as HTML and provides responses data also in a Web data protocol which may be the same or different from the protocol used for requests data. Operations handled by the Web Services may include object level operations such as create object delete object read object modify object modify object metadata etc. It is also possible to provide more file system level operations via the Web Services that open files read data from files etc. by including at least some of the functionality of the file services described elsewhere herein with the Web Services. The Web Services may present to the other computing devices a conventional well known Web Services protocol such as REST or SOAP or may provide any other appropriate protocol.

Referring to the client is shown as having an application Web Services user level I O drivers and a layout manager in user memory address space. The application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. The configuration of is like that of and . The advantages of the configuration shown in over the configuration shown in is that generally changes to the configuration shown in do not require reconfiguring kernel memory address space processes.

Referring to the is shown as having an application Web Services user level I O drivers and a layout manager in user memory address space. The application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. A bridge is provided in the kernel memory address space. The configuration of has similar advantages to the configuration shown in but also has the advantages provided by providing the bridge discussed elsewhere herein.

Referring to the client is shown as having a plurality of applications in user memory address space each of which may use a different interface to access file objects of the servers . Each of the applications shown in is meant to represent one or more applications. Accordingly APP1 may present one or more applications that access file objects at the servers using a Web Services interface. The APP1 application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. APP2 may represent one or more applications that access file objects at the servers using the VFS and APP3 may represent one or more applications that directly operate on file objects at the servers . The different interfaces may operate at the client at the same time.

Note that may other combinations of configurations including illustrated configurations are possible so that the client may simultaneously present to applications thereon different interfaces. For example it is possible to combine the configurations illustrated in and and or combine the configurations of and . Other combinations including combinations of only two illustrated configurations are also possible. The servers provide the file objects to the clients provided 1 the requesting client has appropriate authorization for whatever operation is requested for the file objects and 2 there is no conflict with any previous request. For example in systems where only one client is allowed to write to an object at any one time the servers would not allow one of the clients to modify a particular object while another one of the clients is also modifying the object.

The system described herein may be used with any server or any group of servers capable of providing file objects to clients. The particular form of the file objects may vary without departing from the spirit and scope of the invention. In some instances the order of steps in the flow charts may be modified where appropriate. The system described herein may be implemented using a computer program product software provided in a computer readable storage medium.

While the invention has been disclosed in connection with various embodiments modifications thereon will be readily apparent to those skilled in the art. Accordingly the spirit and scope of the invention is set forth in the following claims.

