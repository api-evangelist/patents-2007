---

title: Technique for controlling selection of a write adapter from multiple adapters connected to a high speed switch
abstract: A technique is provided for facilitating writing of messages to multiple adapters connected to a high speed switch in a distributed computing environment. The technique employs a first, relatively quick filter to initially test whether a previously used adapter of the multiple adapters should be used to send a new message. If the first filter fails to select the previously used adapter, then the technique includes employing a second, more complicated filter to determine which adapter of the multiple adapters should be used to send the message. The first filter includes a first set of tests, and the second filter includes a second set of tests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07796645&OS=07796645&RS=07796645
owner: International Business Machines Corporation
number: 07796645
owner_city: Armonk
owner_country: US
publication_date: 20071016
---
This application is a continuation of co pending U.S. patent application Ser. No. 11 457 612 filed Jul. 14 2006 and issued as U.S. Pat. No. 7 301 962 on Nov. 27 2007 entitled Technique for Controlling Selection of a Write Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden which is a continuation of U.S. patent application Ser. No. 10 156 554 filed May 28 2002 and issued as U.S. Pat. No. 7 161 954 B2 on Jan. 9 2007 entitled Technique for Controlling Selection of a Write Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden both of which are hereby incorporated herein by reference in their entirety. Additionally this application contains subject matter which related to the subject matter of the following commonly assigned patent which is also hereby incorporated herein by reference in its entirety 

 Technique for Controlling Selection of a Peek Adapter or a Read Adapter from Multiple Adapters Connected to a High Speed Switch by William S. Cadden U.S. Pat. No. 7 177 322 issued Feb. 13 2007.

This invention relates in general to a distributed computer system having a plurality of data processing nodes and one or more switch units which establish links between the plurality of processing nodes and more particularly to a technique for controlling selection of an adapter from multiple adapters for writing a message to the one or more switch units in order to enhance overall message writing performance.

In certain parallel processing systems containing a plurality of data processing nodes one or more switch units are provided for transferring data between the data processing nodes. A switch unit receives a connection request from one of a plurality of nodes and establishes a link between the data processing node which sends the connection request and another of the plurality of data processing nodes which is requested by the connection request. As used herein a switch node means any node of the plurality of data processing nodes which is capable of connecting to such a switch unit. A switch node includes a device driver and at least one adapter.

More particularly described herein is a control technique for a switch node having multiple adapters. Advantageously multiple adapters are assumed to write data faster than a single adapter. However it is recognized herein that a need exists in the art for a control technique for enhancing the process of switching between adapters during the writing of messages. The present invention provides such a selection control technique.

Although multiple adapters are assumed to write data faster than a single adapter it has been discovered by applicants that this is not always the case. If the speed at which the data can be written is limited by the path length of the computer program multiple adapters can actually slow down the writing of data i.e. the increased path length for switching between adapters slows down the application. This can create a situation where applications actually run slower on multiple adapters than on one adapter. Thus it has been discovered that a need exists for an effective technique for controlling switching between adapters. This control technique should benefit applications that write more data than one adapter can handle by allowing those applications to use multiple adapters while at the same time not penalizing applications that do not write data faster than one adapter can handle.

In view of the above provided herein in one aspect is a method of selecting an adapter of multiple adapters of a switch node for transmission of a message. The method includes employing a first filter to initially test whether a previously used adapter of the multiple adapters should be used to send a message and if the first filter fails to select the previously used adapter then employing a second filter to determine which adapter of the multiple adapters should be used to send the message. In one embodiment the second filter is more complicated and time consuming than the first filter.

The first filter may comprise a set of tests including one or more of the following determining whether the previously used adapter has sufficient resources to handle the message at this time determining a switch count to ascertain whether the message should be sent through the previously used adapter ascertaining that the message is not a first message of a group of messages and determining that the previously used adapter is currently operational.

Systems and computer program products corresponding to the above summarized methods are also described and claimed herein.

In one aspect presented herein is a technique for facilitating writing of messages to multiple adapters connected to a high speed switch in a distributed computing environment. The technique which employs minimizing overhead in switching between adapters in order to enhance performance can be utilized in a program interface that allows application programs to write to multiple adapters with the same interface used to write to one adapter.

Disclosed herein is an effective technique for switching between adapters which benefits applications that write more data than one adapter can handle by allowing those applications to use multiple adapters while at the same time not penalizing applications that do not write faster than one adapter can handle. This is accomplished by limiting the path lengths for switching between adapters to the point where no application suffers by using multiple adapters and many applications benefit. Using the technique presented herein applications can use multiple adapters expecting to perform at the same or greater speed than possible using a single adapter.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention.

All of the nodes in a frame of the SP computer are included in a LAN segment which is joined by the other LAN segments through LAN gates . As examples each LAN gate includes either a RISC 6000 computer any computer network connected to the LAN or a network router. However these are only examples. It will be apparent to those skilled in the art that there are other types of LAN gates and that other mechanisms can be used to couple the frames to one another.

Also connected to the LAN is a control workstation CWS which controls operation of the SP computer . The control workstation has a direct access storage device DASD referred to as the System Shared Disk on which is stored the system data repository SDR files. The SDR files include such information as a list of nodes that are in the system and their configuration and includes resources and object definitions for each of the nodes . Each node also includes a DASD device for storing data processed by the SP computer .

In one embodiment the nodes in each frame are also connected to an IBM Scalable POWERparallel switch SPS . Each of the SPS switches of each frame is connected to neighboring SPS switches of other frames by a bus .

As is well understood in the art the CWS node sends system data and control signals to the frames of the SP computer by means of the LAN while messages and data may be sent from one to another of the nodes by means of the high performance switches .

The distributed computing environment of is only one example. It is possible to have more or less than 8 frames or more or less than 16 nodes per frame. Further the processing nodes do not have to be RISC 6000 computers running AIX. Some or all of the processing nodes can include different types of computers and or different operating systems. Further aspects of the invention are usable with other types of communications environments. All of these variations are considered a part of the claimed invention.

A node includes an operating system such as AIX. Operating system includes for instance at least one communication device driver . The device driver is based on the type of adapter in the environment such as SP switch 2 and it may manage one or more adapters .

Each network adapter is used to couple its associated node to a particular network which corresponds to that adapter type. Network includes any IP capable network such as the Ethernet Token Ring FDDI ATM SP Switch Fiber Channel etc.

Before discussing particular processing embodiments in accordance with the present invention various concepts thereof are explained below.

The present invention works with adapters e.g. adapter of that connect computer hardware to for example a high speed network or switch. The configuration may have the following qualities.

The adapter can be on a high performance connection to other machines for example a connection on a high speed switch. In one aspect the present invention can be used to insure that the high performance of the connection is not lost through the path length of switching between adapters.

The adapters are assumed to have a method of storing messages that are going to be sent for example in a first in first out queue referred to as the FIFO . For simplicity in describing certain concepts of the present invention the example of a FIFO with a head of FIFO pointer and tail of FIFO pointer is used.

Obtaining information from an adapter may be a slower operation than obtaining information from main computer storage. For example obtaining the head of FIFO and tail of FIFO pointers from the adapter may be a slow operation.

An adapter may go down at any point while writing to it. When an adapter goes down an interrupt is generated for the application indicating that the adapter has gone down. The adapter may then come up again at any point generating another interrupt.

Messages are sometimes grouped together in the FIFO and then flushed to the network together for performance reasons. When some number of messages have been grouped together they are sent. This generally happens at a set interval for example every fourth message. Sometimes a flush is forced by calling the write message function with a 0 length message. In this case no new message is added and the existing messages are flushed from the FIFO. If there are no new messages waiting to be flushed when a 0 length message is written the 0 length message is ignored so that no message is sent.

When messages are grouped together it is sometimes advantageous to send as many of them as possible from the same FIFO. When messages are sent from different FIFOs they are more likely to arrive at the destination in a different order from the order in which they were sent. Since some applications work more quickly when messages are received in the order in which they were sent the present invention preserves the order as much as possible.

Writing to a single adapter is a relatively straightforward operation. In order to write to a single adapter a check is made that the adapter is up and that there is room in its associated FIFO. If both conditions are true the next message is written to the adapter. Pseudocode for this operation is shown below.

The concept of a significant difference number is also employed representative of the difference between the amount of space in one adapter FIFO versus other adapter FIFOs. The significant difference number can be set to be any number desired and it indicates that if some adapter FIFOs have more than significant difference number message slots available than other adapter FIFOs then messages should be written to the FIFOs with the greater number of message slots. For example if the significant difference number is 512 and certain FIFOs have 600 message slots available while others have 12 message slots available most messages should be written to the FIFOs with 600 message slots. It is assumed that the FIFOs with greater space are able to send messages faster than the other FIFOs and thus should be written to more rapidly.

Provision for specifying a preferred adapter is also assumed. A preferred adapter indicates that if a specified adapter is up it should be used and no switching between adapters should occur. When a preferred adapter is specified the switch count can be set to a very high value so that there is rarely an attempt to switch between adapters.

When messages are being grouped in a FIFO to be sent through an adapter it is preferred that processing can only switch to another adapter when subsets of the group of messages are flushed. If the switch count indicates that it is time to switch and a subset of the group has not yet been flushed processing should wait until the subset is flushed before switching. Subsets of the group of messages are flushed at some predefined interval for example after every fourth message of the group of messages. depicts computing node having adapters . . . with one or more of the adapters having an associated write FIFO . FIFO is shown by way of example to include four buffered messages which are assumed to be flushed together from the adapter in a write operation.

In order to have as many messages from each group sent on the same adapter to preserve the order of the messages adapters can be flipped at the start of every group of messages.

In view of the above write pseudocode for one approach to writing a message when two adapters are used is shown below.

As shown above there can be quite a few steps to execute when writing messages using multiple adapters. These steps are executed along critical performance paths and can cause an unacceptable performance slow down compared with the single adapter case. The problem becomes even worse when more than two adapters are used.

The invention presented herein avoids long path lengths by saving state information from previous tests by taking advantage of the fact that the program is notified in an interrupt or signal handler when the adapter goes down and by combining several tests into one. The processing discussed below takes advantage of the fact that in most cases the next message is written to the same adapter to which the previous message was written. This adapter is referred to herein as the previous adapter or the previously used adapter . For example if the switch count is then as long as there are enough message slots in the associated FIFO we will prefer to write messages to the previous adapter before a message is written to another adapter. Thus one aspect of the present invention is to make the path length of writing to the previous adapter as short as possible even if that makes the path length for switching between adapters a little longer. The shorter path length will be executed for the large majority of cases and the longer infrequently. Test processing to determine when the previous adapter can be employed is referred to herein as the simple set of tests or first set of tests while test processing employed to select a potentially new adapter is referred to as the more complicated set of tests or second set of tests .

Before describing the test processing in detail the environment of the invention is described in greater detail with reference to the distributed computing environment depicted in . As shown multiple computing nodes A B . . . each include a portion of an application A B . . . . The respective applications employ application programming interfaces APIs A B . . . to call particular functions such as the write function discussed herein as well as the peek function and read functions described in the above incorporated co filed application . The multinode network is connected by multiple high speed switches such as the RS6000 SP switch marketed by International Business Machines Corporation. The multiple high speed switches define multiple switch planes e.g. switch plane switch plane . Each computer is connected to the several switches using separate adapters A B . . . . Device drivers A B . . . facilitate the reading and writing of messages through the respective adapters.

In the example shown adapter of each node is connected to switch plane and adapter of each node is connected to switch plane . When a message is written from one node to another node the adapter that the message is sent through determines which adapter the data is received at. A message is received on the same adapter number that the message was sent on. So if a message is sent through adapter on a first computing node it will travel through switch plane to adapter on a second computing node.

In operation the portion of the application and program running on a particular computing node writes messages through its respective API to other parts of the application running on other computing nodes. Similarly the portion of the application on a receiving node reads messages from other parts of the application running on other computer nodes through its API.

Each adapter of each computing node has associated therewith a write FIFO and a read FIFO A B . . . . These FIFOs are employed when writing and reading messages through the adapters. When an application writes a message it calls its associated API to place the message into the write FIFO associated with the selected adapter. This FIFO has a fixed number of slots that can be filled by the API. When the adapter associated with the FIFO ascertains that a message is in the FIFO the adapter sends the message over the switch plane in a first in first out order. If the write FIFO is full the API detects this and tells the application. The application then waits until the adapter transfers a message out of the FIFO onto the switch before placing a new message into the FIFO. The adapter transfers a message from its associated FIFO onto the switch and the message travels across the switch to other computing nodes. An adapter on another computing node connected to the particular switch plane receives the message and places it into its associated read FIFO.

The receiving application may then call the API peek function to see a part of the contents of the message in the read FIFO. A peek operation returns a part of a message without removing the message from the read FIFO. The receiving application may read the rest of the message using the API read function which then removes the data from the read FIFO. Once the data is removed the space on the read FIFO is available for a new message.

Within this environment presented herein are various processing enhancements to facilitate enhanced processing performance of the multiple nodes using multiple adapters and their associated FIFOs. Unless otherwise specified the adapter FIFO discussed herein refers to an adapter s write FIFO.

One piece of state information which can be saved is the count of how many message slots are available in the adapter FIFO. From the point of view of the write operation it does not matter if there is one or many message slots available in the FIFO. If there is at least one message slot the message can be written to the adapter. To avoid reading information from the adapter with every message write an avail count can be saved in local storage of how many message slots are available in the FIFO. The available space avail count can be decremented every time the FIFO is written to. The variable indicates that there are at least avail count message slots available in the FIFO. The exact number of message slots will only need to be calculated when the avail count is decremented to 0. This improves performance because determining the exact number of message slots available in the adapter s FIFO may be a considerably slower operation than simply decrementing the avail count.

Part of the simple set of tests presented herein is to determine if the switch count or the avail count has reached 0. If either has then the more complicated set of tests is performed to determine whether to switch adapters. In one implementation there is no need to decrement both the switch count and the avail count every time a message is written. Rather a combined count called send test can be employed. The send test count is initialized to the smaller of the switch count and the avail count. Send test is decremented every time a message is written. When it reaches 0 it indicates that either the switch count or the avail count would have reached 0 had they been decremented. Using send test allows the processing discussed herein to decrement and test only one variable instead of two thus shortening the path length of the shorter set of tests.

Unfortunately switch count could reach 0 when we are unable to switch because unflushed messages reside at the previous adapter. If switch count reaches 0 and there are unflushed messages the next message is sent to the previous adapter and switch count is set to 1 so that it will be checked after the next message is sent.

Another feature of processing in accordance with the present invention is a test pointer to the previous adapter. If the pointer is NULL it indicates that the previous adapter is not to be quickly selected and the more complicated and relatively slower set of tests is to be used to select an adapter. If the pointer is not NULL it indicates that the next message should be written to the previous adapter. This being the case when the test pointer is not NULL only two tests are needed to ascertain which adapter to write to one to determine if the test pointer is NULL and the other to check if this is the first message in a group of messages where the order of the messages is to be preserved as much as possible. The pseudocode for this simple inquiry would be 

As an example there may be two times when the test pointer would be set to NULL. A first is when an indication comes in that the status of one of the adapters has changed that is an adapter has gone up or down . This is detected in an interrupt handler and the pointer is set to NULL from that interrupt handler so that the next time a write operation is called the more complicated set of tests will be used. By setting the test pointer from an interrupt handler path length is not added to the main line path of writing messages to the FIFO.

The setting of the test pointer in an interrupt handler does raise a timing issue which should be addressed. It is possible for the test pointer to be set in the interrupt handler at the same time that it is being set by the complicated set of tests. When this occurs there is uncertainty whether the value from the interrupt handler or the value from the more complicated set of tests is the one that remains. The interrupt handler could set the test pointer to NULL only to have the more complicated set of tests set it to another value an instant later. In this case the indication that the more complicated set of tests should be done the next time that the write is called could be lost. In order to handle this timing problem the interrupt handler also may set a flag which indicates that the test pointer has been set from an interrupt handler. The more complicated set of tests will examine this flag to see if an interrupt occurred while it was setting the test pointer and if it has the test pointer is set to NULL. This will cause the more complicated set of tests to be used the next time that the write operation is called and any effects of the interrupt will be handled. The more complicated set of tests may be used more often in this situation but since this will happen infrequently there is not a significant performance loss.

The second time the test pointer may be set to NULL is immediately after a message has been written. At this point send test is decremented. If it is less than or equal to 0 the test pointer is set to NULL indicating that the more complicated and slower set of tests is to be performed.

One embodiment of pseudocode for write adapter selection and use employing the simple set of tests is shown below.

Notice that whether the previous adapter should be used for the next write is determined with only the additional path length of testing the test pointer decrementing send test and testing the send test.

One embodiment of pseudocode for the more complicated set of tests when two adapters are used is shown below.

If more than two adapters are used the more complicated set of tests could be implemented as follows 

Beginning with the more simple set of tests initially inquires whether the test pointer is set to NULL or the message to be written is a first message in a group of messages with order to be preserved as much as possible . If either condition is true then the more complicated set of tests of is called . These two tests represent a quick analysis that is performed with each message write operation to determine whether the previously used adapter can continue to be used for the new write operation. As a default the test pointer could be set to use the previous adapter. The test pointer is set to NULL if any of a group of conditions arises as explained hereinbelow. In such a case the more complicated set of tests would be employed.

Assuming that the test pointer is set to other than NULL and the message is not a first message in a group of messages with order to be preserved then processing sets up to write the message to the previous adapter . Next it is determined whether the message length is zero . As noted above a message length of zero can be used as a signal to tell the API to flush the buffers in the adapter . After flushing any buffered messages write operation processing is finished .

Assuming that the message length is other than zero then processing prepares to write the message to the chosen adapter and inquires whether it is time to flush messages from the chosen adapter . If so the messages are flushed . Next processing decrements the send test counter . As noted above the send test counter is a variable which is initialized with a certain count equal to a number of messages that can be sent before processing needs to consider whether the message writes need to be flipped from the previous adapter. Next processing determines whether the send test count is less than or equal to zero . If no processing is complete since there is more room on the previous adapter s buffer for a next message.

If send test is zero or less then processing determines whether all messages have been flushed . If so the test pointer is set to point to NULL so that the more complicated set of tests will be used for the next write operation after which processing is complete . Otherwise determination is made whether there is space in the current adapter for another write . If so then send test is set to one so that the previous adapter is used for the next write and a check is made to see if an adapter switch should occur after the next write . If there is no space in the current adapter then the test pointer is set to NULL so that the more complicated set of tests will be used for the next write operation .

As noted the more complicated set of tests represented by the processing embodiments of can be called from the processings of when inquiry determines that the test pointer is either set to NULL or that the current message is a first message in a group of messages where order is to be preserved as much as possible. This more detailed processing begins by calculating a new value for switch count based on how much send count has been decremented . Processing then determines whether the previous adapter is down. If so the processing of is employed otherwise the avail count is determined for the previous adapter and inquiry is made whether the length of the current message is zero . If so the previous adapter is selected for use in the message write and processing continues as shown in .

If the current message length is other than zero then processing determines whether a preferred adapter is specified . If so then the processing of is called. Otherwise processing determines whether the avail count variable indicates that there is space available in the previous adapter determines whether the switch count variable is greater than zero and determines whether the current message is not the first message in a group of messages where order is to be preserved . If all conditions are true then processing sets up to write to the previous adapter and the processing of is performed. Otherwise processing determines whether there are unflushed messages . If so then the process flow of is followed and if not the process flow of is followed.

As noted the process of is called from the processing of when it is determined that the previously used adapter is down. process flow begins by finding another adapter which is up has space available and does not have significantly less space than any other adapter . The amount of significantly less space can be selected as desired for a particular implementation. For example if three adapters are employed the previous adapter is down and the third adapter has significantly less space available than second adapter then the second adapter would be chosen. Processing then determines whether an adapter was found . If no an indication is returned that the message cannot be presently written and processing is finished . If an adapter was found then processing sets up to write to the chosen adapter after which the switch count is set to the number of messages that should be written before switching to another adapter and the processing of is performed.

Processing next determines whether there is space available on the adapter pointed to by the temporary pointer . If no then a message is returned indicating that the message cannot be presently written and processing is complete . If there is space available processing sets up to write to the adapter pointed to by the temporary pointer . Next a determination is made as to whether the adapter pointed to by the temporary pointer is the preferred adapter or that the preferred not up . If either is true then it is desirable that the selected adapter be used every time so that the switch count is set to its maximum value and processing continues with . Otherwise a different adapter than the preferred adapter is being employed so switch count is set to one before proceeding with the processing of . By setting switch count to one processing indicates that the more complicated set of tests will again be performed the next time through the message write procedure.

The processings of are alternately followed from the process flow of in response to determining whether there are unflushed messages . If so then the processing of is followed otherwise the processing of is followed. Beginning with the flow initially determines whether there is space available on the previous adapter . If no then a message is returned indicating that the message cannot be currently written and processing is complete . If there is space available then processing determines whether the switch count equals zero . If so switch count is set to one . A switch count greater than zero indicates that processing is to continue to write messages to the previous adapter for some number of times. Processing next sets up to write to the previous adapter before proceeding with the process of .

Referring to processing initially finds another adapter which is up has space available and which does not have any significantly less space than any other adapter . If possible this adapter should not be the previous adapter but if the previous adapter is the only one that qualifies then that adapter can be used. Processing then determines whether an adapter was found . If no then an indication is returned that the message cannot be written after which processing is complete . If an adapter was found processing sets up to write to the chosen adapter and sets switch count to the number of messages that should be written before switching to another adapter . The processing of is then performed.

The present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The article of manufacture can be included as a part of a computer system or sold separately.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

Although preferred embodiments have been depicted and described in detail herein it will be apparent to those skilled in the relevant art that various modifications additions substitutions and the like can be made without departing from the spirit of the invention and these are therefore considered to be within the scope of the invention as defined in the following claims.

