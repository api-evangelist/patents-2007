---

title: Condition editor for business process management and business activity monitoring
abstract: A system for monitoring processes of a distributed business application an integration builder tool. The integration builder tool includes a condition editor having a user interface providing an editing area on a display in which to receive a text-based expression of one or more conditions of a business application process. The editing area further includes an operator palette providing a plurality of operators for use in the text based expression of each of the one or more conditions, and a toolbar providing one or more editing tools for editing the text-based expressions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732595&OS=08732595&RS=08732595
owner: SAP AG
number: 08732595
owner_city: Walldorf
owner_country: DE
publication_date: 20070118
---
This disclosure relates generally to computer based mechanisms for monitoring activity of a business application and more particularly to an infrastructure for monitoring local events of a distributed business application.

Business applications such as CRM or ERP applications usually lack communications necessary to be able to monitor business activity of the application. One comprehensive solution is the Business Activity Monitoring BAM provided by SAP AG to monitor events of business impact within an executing business application and deduce actions if necessary. BAM can span both the applications of an application system landscape as well as the application orchestration layer i.e. the integration processes.

A solution such as BAM introduces the notion of a monitoring process. A monitoring process collects events raised by diverse sources and deduces action items to be completed by business experts. Processes are predefined using an Integration Builder IB tool or the like and work items are created as a consequence of process execution.

BAM knows a number of event systems and is capable of connecting them. Applications spawn workflow events or local events to trigger follow up actions within one SAP system client . BAM allows to map these local events via the local event infrastructure into global events i.e. monitoring events that can be communicated across system borders.

BAM also introduces the concept of a monitoring event. A monitoring event is a notification sent to the monitoring process about a significant state change in the business application system. In SAP s XI the transport medium of monitoring events are XI messages and the transport mechanism is the XI messaging infrastructure. BAM enriches the scenario of event resolution with stateful processes and correlation of monitoring events.

An application can discharge monitoring events using message communication and therefore a monitoring event also represents a message interface that refers to message type etc. Each already existing message communication can be used to supply monitoring processes with information. Additional monitoring events are necessary when no message communication exists already.

Events can be used to enable application systems to fire monitoring events to eventually produce an event resolution. Event resolution in a basic sense means that an application detects invalid business data or some deadline that has been reached in a workflow event and an alert is dispatched. This alert will be used by an event resolution framework i.e. an Event Resolution Center or ERC to generate a resolution to the workflow event. Thus the application alone must be able to detect the inconsistent or incorrect state of the application data. In some cases the application will not be able to detect such inconsistencies because it may need additional data from other systems or because one monitoring event alone does not lead to an alert that is visible to an end user. In such cases a monitoring process should be used.

Conditions defined in conventional tools such as an IB support only a subset of the functionality provided by the proven Business Workflow condition component. Both integration process designers and XI administrators configuring integration scenarios have been restricted by this limitation. The need for a unified condition definition and execution environment one that provides the same set of functionality on all levels becomes even more urgent in light of BAM.

Conditional behavior is an integral part of business monitoring processes. Designers require full expressiveness to compare key figures or deadlines in a meaningful way. The user currently has to normalize conditions before being able to define them in a definition tool which is cumbersome when the condition exceeds a certain level of complexity. Conditions can cause runtime exceptions due to missing type checks in the definition environment.

Presently a condition editor is used at various places in the IB for activities such as Receiver Determination. Interface determination and BPM. Condition creation is done in a tabular fashion using the following general rules 1 For every new expression a new row is inserted into the table 2 Only following operators are supported EX 3 Extra UI symbols are provided in the first column of the table to represent parentheses however complex conditions become practically unreadable 4 Nesting of parenthesis is not supported and 5 A facility for using variables in a condition is not supported.

All this make the process of creating conditions complex and error prone with almost negligible help provided by the system. The number of operators that can be supported are very few which fails the basic idea of providing users like process designers and XI administrators with a flexible easy to use and full blown condition building experience. Hence a need arises to have an extensive easy to use and more readable condition editor UI.

In general this document discusses a condition editor system and method for providing extended conditions and expressions for business process management and business activity monitoring.

In one aspect a system for monitoring processes of a distributed business application includes an integration builder tool comprising a condition editor. The condition editor has a user interface providing an editing area on a display in which to receive a text based expression of one or more conditions of a business application process. The editing area further includes an operator palette providing a plurality of operators for use in the text based expression of each of the one or more conditions and a toolbar providing one or more editing tools for editing the text based expressions.

In another aspect a condition editor for creating and deploying conditions for a business process activity monitoring system includes a computer having a display. The condition editor further includes a user interface generated by the computer and providing an editing area on the display in which to receive a text based expression of one or more conditions of a business application process at least one text based expression including at least one operator and at least one variable the editing area providing drag and drop editing of the text based expression of the one or more conditions.

In yet another aspect a condition editor for creating and deploying conditions for a business process activity monitoring system includes a computer having a display and a user interface generated by the computer and providing an editing area on the display in which to receive a text based expression of one or more conditions of a business application process at least one text based expression including at least one operator and at least one variable. The condition editor further includes a parser module adapted to check the semantic correctness of a condition object associated with each condition.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

This document describes a condition editor and condition editor user interface UI for business process management and business activity monitoring of executing business applications. In preferred implementations the condition editor supports parsing the condition string as and when the condition editor UI requires and provides information about syntactically and semantically erroneous conditions.

The condition editor includes a UI with easy to use features a capacity to use more operators and can use variables in a condition. The condition editor further includes editing features such as the ability to receive user typed conditions and provide appropriate help during the conditions creation process including intelligence for possible operators operands drag and drop condition variables and so on. The user can undo redo changes made during editing the condition. Functions such as cut copy and paste of part or all of a condition string and operands can be made within the editing area.

The condition editor provides readability by highlighting the operators and matching parenthesis and performs a syntax and semantic check at the time of condition definition. The user can see the condition with semantically erroneous expressions highlighted. The set of operators supported by the Condition Editor UI is restricted however the escape character ESC could be used to provide comments while building conditions E.g. . . . . . . . This text within the escape character would provide the user the facility to document the condition in the editor itself.

The condition editor can use more operators so as to be extensible for building complex conditions provide all the operators supported by the Business Workflow condition component

The condition editor also includes a capacity to use variables. Each condition can be viewed as a set of operands and operators where each operand is a value by itself. Instead of providing absolute values long x paths repeatedly in the condition an indirection can provide variables representing the values of operands as explained more fully below.

A screen layout of the condition editor includes an editor layout. The editor layout is the default view for opening the condition editor. Depending on the calling application s mode display or edit conditions can be edited or viewed in this layout. The editor layout has the following views Operators Palette Editor View Condition Variable View Binding View Message Log View and Namespace prefix view. These views are explained in more detail below.

Two different tables or views are used for declaring and defining the variables to reduce the development effort by using an existing Container Panel and Property framework. The condition editor can include a unified table where the condition variables can be declared and defined.

Creation of a condition in the editing area can be done by a drag and drop of a variable operator or parenthesis. The user can drop any variable or operator at the cursor position. In a specific implementation an open parenthesis means that the variable is droppable at any cursor position and the condition editor could automatically insert a closing parenthesis at the first next syntactically correct position in the condition. For example in the condition a b if the user drops an open parenthesis before a a close parenthesis will be inserted after b . Likewise a close parenthesis can be dropped at any cursor position and the condition editor will automatically insert an open parenthesis at the first previous syntactically correct position in the condition. Using the example above in the condition a b if the user drops a close parenthesis after b an open parenthesis will be inserted before a .

The user can type in freely to the editing area in any text based expression and condition text is preferably case insensitive. If the user types in a valid variable i.e. available in condition variables the condition editor will highlight the variable as valid. If the user types in an invalid variable i.e. not available in condition variables the condition editor will highlight the variable as invalid. The condition editor treats typed in open closed parentheses similarly to parentheses that have been dragged and dropped as described above. Valid operators are highlighted as valid while invalid operators are highlighted as invalid.

Deletion of text from the editing area can either be done by using the toolbar delete button select and click delete or other editing ways i.e. using Back Space or Delete keys . If the user tries to delete an operand operator the condition editor will display a appropriate message indicating a probable error. If the user tries to delete a parenthesis the condition editor could highlight the first matching parenthesis and hence indicate the mismatched parenthesis.

For other editing functions a selected string can be dragged from one position in the editing area and dropped to another. The condition editor also includes an undo redo function for changes made in a condition. The Undo button removes the last change made in the editing area and the Redo button adds the last change made in the editing area.

Condition editor has a function to provide comments while writing conditions. In one implementation the symbol is used to start the comment and the symbol is used to close a comment although other symbols or representations can be used. Comments are visible at design time and in the condition definition produced by the cache import but do not have any runtime impact.

While building a condition the condition editor provides the user a context help function. The context help can include a popup that is displayed in response to receipt of a command such as Ctrl Space or other key commands. When requested the condition editor displays a popup with a list of all possible values at the current cursor position from which the user can select. This help function can assist the user find a next possible operator operand or parenthesis. If the cursor position is after an operand or parenthesis and the user requests for help the popup is displayed with all the possible operators and parentheses unary binary and parenthesis . The selected operator is inserted at the cursor position. If the cursor position is after an operator the popup display a list of all possible operands i.e. condition variables of same type and the selected operand is inserted at the current cursor position. If a cursor position is in between an incomplete operand substring of container element name a popup should be shown with all the possible operands same type starting with the same substring if there are multiple container elements starting with this substring. If there is only one matching variable starting with the typed in substring the rest of the string is completed with the matching variable.

To replace an existing operator or operand if the cursor position is before an operator operand the popup displays a list operators operands of same type i.e. a binary operator should not be replaced by a unary operator . The condition editor will replace the selected operator operand for the operator operand at the current cursor position. To get help for all the possible context objects for a given condition variable the user can ask help for all possible context objects of a message by typing in Ctrl Space. Message variables are inherited from the parent context e.g. block level container of an integration process . Syntactic correctness of the condition can be checked at a specified threshold after the user has stopped editing. The output of this check can be displayed in the editing area . A time lag can be inserted to ensure that the user is not regularly interrupted with a message while editing. Each update will clear the previously displayed message.

The editor view further includes a toolbar . The toolbar includes a number of functional buttons to execute such functions on a selected operand operator and or parenthesis as delete check condition and undo redo. When the check condition button is clicked the condition editor checks syntax and type and will highlight type mismatched operands and display an error message. The corresponding entry of the variable is highlighted in the container view. Valid invalid condition variables operators are highlighted to identify available variables and supported operators. Matching parenthesis are highlighted when the cursor is positioned before an open parenthesis and after a close parenthesis. Parenthesis mismatch is also highlighted. Shortcut keys can be provided for simple editing within the text editing area such as Cut Copy and Paste text.

The editor view also includes an operator palette to display a list of draggable supported operators with a separator that identifies a classification like Binary Unary . A message view displays all the syntactic and semantic error messages generated while creating a condition. The error message indicates the most probable position for the error in the condition. Clicking on an error message puts the cursor to the indicated position in the editing area .

A container view includes condition variables container elements where declaration and definition is divided into two parts a condition variable view declaration and a binding view defining bindings . The condition variable view has a toolbar and a table containing the condition variable. The toolbar can include a number of functional buttons such as Add Row Remove Row and Where Used. The Where Used button highlights all the places where a particular container element is used in a condition.

In addition to the toolbar the container view includes a table of container elements. The user can create by adding a new row and use the container elements in editing area . The user can also create container elements by providing a name and a type to a container element. Each container element can be modified and or deleted if necessary and can be dragged into and dropped in the editing area . Specified rows of each container can be highlighted. Container elements can be of XSD simple types. e.g. date time string and integer . Container elements can be passed while invoking condition editor and none of their attributes can be changed within the scope of the condition editor.

A binding view is used to define the condition variables declared in the condition variable view as described above. The binding view displays a table containing variable name and value pair. The condition editor automatically updates the variable declared in the condition variable view such as by adding modifying type change or deletion. The user can bind values constants and x path to variable using an expression editor but cannot delete or modify the variable name in this view. Also the user may not assign one local variable to another.

Possible values for a variable could be a constant where the user provides a constant value according to the type of container element or an expression x path context object . The condition editor provides a popup to the expression editor to set the value of the container element. All the information required by the expression editor will be provided such as execution context extract context etc. . The bindings view includes a namespace prefixes view to display all the prefixes used in the x path expressions used in variable definition . The namespace prefixes view will display editable prefix name and non editable value pairs. The condition editor can configure the set of operators required or used by the application from the available set operators in a condition editor API.

The IB tools allow users to create and activate objects. Every object obtains a unique object identifier and the IB versioning mechanism tracks changes to that object. Conditions are defined and interpreted in the context of such objects and need to be unique only in that context so that no condition specific versioning information is required. Conditions depend on design objects but do not possess design object qualities. Hence the lifetime of a condition is closely coupled to that of its host object. Conditions can only be created persisted and read if such a hosting object exists. Hence upon deletion of the host object its conditions will also be deleted and not reused over a number of design objects. Furthermore the distinction between client side and server side components in IB requires all objects including dependent ones to support the Java object serialization mechanism.

The IB framework requests a number of functions that are implemented by the following core services persistence of in memory condition instances serialization of in memory condition instances and migration of existing condition instances.

Once configured a ConditionManager instance can be requested to construct condition instances according to its configuration. After obtaining such an instance the application provides the input stream to be parsed. From an application point of view this is the finest level of granularity. The actual implementation of the condition instance behavior is not visible from the outside. The parse routine results in an abstract syntax tree represented by the ConditionSyntax Tree. Next to it a condition instance holds variable declarations and instantiations in the form of a Container and PropertySet discussed further below .

The only way for an application to manipulate the state of this instance is by either having it parse a new input stream or by setting new container elements and the respective bindings. In the event of a change the notification mechanism is triggered to inform subscribers about the state transition. illustrates condition model classes.

A formal language is a set of finite character strings. These character strings are composed from the members of a finite alphabet set usually according to a set of rules that specifies their production. A formal grammar is a system that specifies abstracts over such a formal language the grammar thus differentiates between strings that belong to the formal language and those that do not. A grammar imposes a structure on the language it generates. Strings derived from the grammar are consistent according to the rules of the Grammar. The morphemes henceforth referred to as tokens are available to the processor along with their relationship to each other. The structure is especially crucial to an automatic processor.

Conditions being a language construct themselves are subject to this formal treatment. Accordingly a condition follows a set of rules which can be represented by the condition grammar. A parser then interprets the condition against these rules. The formal approach and the automatisms that the formality generates results in the following advantages 

Error detection the input stream could be in error. Depending on the sequence on the token encountered so far and the matching production rules the parser can anticipate the set of next possible tokens. If the scanned token is not from this set the input string is in error as per the grammar.

Input suggestion The set of possible tokens discussed above can also be used to suggest a valid possible next token in the input string that is encountered so far. This is of interest for UIs such as the condition editor where the user inputs the string that represents a condition.

Parsing theory is well understood and parsers for computer programming languages its sub constructs such as the condition described in the previous section are rarely written by hand. Instead they are more often generated by programs called parser generators also referred to as compiler compilers . As shown in a parser generator acts on the input grammar specification parser source to produce the source code of the parser for that grammar. The generated parser can then be augmented by means of the same formal specification so that it constructs an Abstract Syntax Tree . This will serve as input to the type system as described below.

The advantages of using a parser generator over hand crafting the parser include the parser being independent of its implementation. Thus the production rules are easily separable instead of being buried in the code. As a consequence the actualization of the changes in the grammar in the parser implementation is comparatively lower. This approach also saves considerable effort in the development of the parser and avoids the errors that may creep in during hand crafting . Finally the generation approach is a widely adopted practice as amply demonstrated by the success of Parser Generator and lexical analyzer tools such as YACC and LEX respectively.

The user needs access to message data context objects and constant values when defining a condition. The new condition model will retain direct input of context objects and constant values but will not allow direct input of XPath expressions. This is replaced by the concept of local variables. Such variables are defined and used only within the context of a particular condition.

The advantage of this approach is that it greatly helps a user in creating the condition. The user is relieved of having to input an XPath repeatedly. Instead the user defines a variable once e.g. totalValue assigns a type to it e.g. xsd int and then uses it throughout the condition totalValue

The container and property model provide a proven means to model data declarations and bindings. Thus a condition object hosts a container object to represent variable declaration and a property set object to define data bindings. The data manager encapsulates access to the respective APIs as well as provide additional functionality such as data format parsing.

Containers provide a simple means to declare variables. The user introduces a new symbol by assigning a name and a type to it. A variable name is unique i.e. there may only be one instance of a name in a given container context. Container instances can be linked to form a hierarchy. If an object has a container of its own it may set this container as the parent of the condition container. Hence all elements of a type derived from xsd simpleType or a message type in case of ccBPM of its container will also be accessible in the condition. In addition container eventing can be used to propagate changes in the container hierarchy. The condition instance receives and processes events by both the parent container as well as its own container.

Values in the Integration Builder are expressed by means of expressions an XPath expression a reference to a value contained in another container element or a constant . Two solutions are possible when trying to conceive the assignment of a value to a variable. In one solution the value expression is made part of the variable declaration. This requires a capacity to store expressions in the container which breaches the paradigm used so far in this domain i.e. to separate variable declaration from value assignment. Another solution is to introduce an indirection. Variable declaration can be represented by means of a container. A set of properties can be used stating that for any container element e there is a property p. This leads to the conclusion e p x where x is the value to be assigned.

In other terms a binding definition is a set of properties each assigning a value i.e. an XPath expression a value contained in another container element or a constant to a declared variable in a container. The user will have to define a binding for all local variables. If this is not the case the condition will not pass the checks implemented by the model. Since local variables are only a modeling construct they are mapped to so called named expressions before being transported to the cache import routine. A named expression in the condition serialization format has an additional name attribute. The serialization routine sets the container element name as the value of this attribute.

Elements in a container need to follow a naming scheme. In some exemplary implementations the naming scheme is specified as follows 

The type system identifies correct data formats. As the IB framework heavily relies on XSD types it is only logical to impose the XSD data formats as well. Finally XSD string format supports an arbitrary sequence of characters. To distinguish it from other formats the sequence should be enclosed by quotation marks. Given an input stream the data manager is able to both ensure format compliance as well as derive the type. This information can then be processed by the type system.

As a condition instance acts autonomously the hosting application and other possible stakeholders subscribe to it to be informed about otherwise internal state changes. The condition event manager extend the proven concepts already in place in the container eventing API. In addition it will feature event propagation. This mechanism is required to deliver events raised by the underlying container eventing API to subscribers. In a client server environment subscribers are treated as transient objects. As the condition event manager cannot enforce that its subscribers are serializable it must discard them before being sent back and forth between client and server.

A type system defines type relations and operator semantics and introduces a na ve type system to compute the semantic correctness of an abstract syntax tree. The type system is motivated by the requirement to assist users in pinpointing type errors and deduce missing information i.e. not provided by the user such as variables and variable types.

After parsing the input stream an abstract syntax tree consisting of token instances is obtained. These instances are organized in a hierarchy that defines how the condition will be interpreted. The type checks are not incorporated into the actual creation of the tree. That way even conditions containing invalid type assignments can be rendered as tree.

A type check needs to satisfy the following criteria the number of operands of an operator equals its declared arity the type of a given operand is a member of the types accepted by its operator and mapping the type of one operand to that of another can be successfully computed using one of the operator s type mapping function.

The generated tree passes the type check if its elements satisfy these criteria. Each element has a set of attributes needed to determine if it is compliant. These are Return type all elements Arity only operator elements and Type range only operator elements . In addition operator elements provide a set of type functions that describe possible mappings of operand types.

As shown in an algorithm queries these attributes to compute if the condition is correct with respect to type safety. The algorithm can also be used to deduce the type of certain elements. This can be helpful to assist the user by automatically typing elements that the user has not specified. When the algorithm encounters such an element it will determine its return type attribute based on the return type attributes of the previous sibling. The generic type mapping function can be described as a more specific type takes precedence over a more generic type. Specific types cannot be mapped onto each other whereas generic types can be mapped onto specific ones under certain circumstances.

Where the mapping might result in a dump at runtime a warning message is displayed for the user during design time. Where the mapping might result in an exception an information message is displayed.

Certain operators allow comparison of sets against single elements. Although the type mapping rules do not change the way the type is determined differs. In such a situation the type of the element is mapped onto the base type of the set. Consider a set of entries of type xsd integer. The single element will accordingly have to be either of type xsd integer or may also be of type potentially castable to xsd integer such as xsd string. The latter implies that a warning message is generated and displayed but the condition can still be activated.

A condition goes through certain stages as illustrated in . If the condition fails to pass to the next stage it cannot be activated. These stages are 1 Syntax check 2 AST Compilation and 3 Type check. A user may also decide to employ automatic typing to support creation of the condition. This can have three possible outcomes A Successful B Failed or C Undetermined the automaton was unable to fully compute all the attributes . Once automatic typing has finished the condition again has to pass the stages mentioned above.

The type system deals with proving the semantic correctness of a condition not with specifying the type of a variable or a constant. This is provided by the data manager. The data manager will provide information about each operand token be it constant or variable. It will return the type and occurrence i.e. multiline or singleline of each token and it maintains variable declarations to parse and assign a type to constant expressions such as an integer of timestamp.

The condition model provides a persistence mechanism which allows storing the condition objects on a relational database. In certain exemplary implementations conditions are not subject to XI object versioning and do not possess a global XI unique identifier. As a consequence they need to inherit that information from the XI object to which they belong. In addition each condition object obtains an identifier which is unique in the context of a given XI object. This triple of identifiers is required to establish a link between a given condition instance and its owner.

At the same time this implies that the lifecycle of a condition object is bound to its owner and so is persistence. A condition object is stored when its host object is stored it is deleted when its owner is deleted and so forth. The XI object s persistence will delegate this task to the condition persistence.

The condition persistence service fully supports the IB generic persistence GP framework providing persistence service implementation required relational database tables for the IB Repository and Directory and a method to enrich GP meta information objects of the calling application e.g. Integration Process Receiver Determination etc. .

An application registers the condition meta information to its own meta information object by calling the method provided by the condition persistence implementation. Furthermore when the persistence implementation of the application is called it delegates this call to the condition persistence in order to store or retrieve condition instances. As a consequence it need not deal with the exact details of condition persistence but can rely on the condition persistence to do so. XML Serialization is used in IB framework to either transport design objects from one system to another e.g. DEV to PROD or into the runtime cache. The condition model provides one common serialization format which will be used for both use cases.

Similar to persistence condition objects cannot be rendered into an XML string on their own but require the context of the XI object and hence the condition serialization is nested in the XML stream of that object. The serialization routine appends versioning information of the schema used to serialize a condition object so one can distinguish between current versions and deprecated formats.

The IB provides an upgrade framework wherein the condition migration service is registered. An upgrade will be performed in the application server migration mode i.e. a number of framework services are not available. Accordingly the migration of conditions is restricted to loading content in the old database tables and migrating content to the new database tables. The upgrade service loads conditions using the old API convert them in memory to an object instance as specified by the new condition model and persist them using the new persist service.

Additional work could be required in case of conditions that were defined in IB Directory e.g. Receiver Determination . Such conditions need to be translated since the condition engine handles them in a more tolerant way. This conversion will not alter the semantics of the condition. It will simply represent the condition in the way the condition engine internally interprets it. Accordingly the runtime behavior of the condition does not change. shows a conversion algorithm for operands. shows a conversion algorithm for operators.

Conditions defined in integration processes do not require this translation as the runtime interprets them exactly in the way they are defined. Such conditions will simply be converted into the new object model and stored in the new persistence layer. In some cases a type check of the migrated condition might fail. In such cases human intervention is required. The migration service creates log entries to inform an administrator that such additional work is required.

Embodiments of the invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of them. Embodiments of the invention can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium e.g. a machine readable storage device a machine readable storage medium a memory device or a machine readable propagated signal for execution by or to control the operation of data processing apparatus.

The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also referred to as a program software an application a software application a script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to a communication interface to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks.

Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the invention can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Embodiments of the invention can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

Certain features which for clarity are described in this specification in the context of separate embodiments may also be provided in combination in a single embodiment. Conversely various features which for brevity are described in the context of a single embodiment may also be provided in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example the steps recited in the claims can be performed in a different order and still achieve desirable results. In addition embodiments of the invention are not limited to database architectures that are relational for example the invention can be implemented to provide indexing and archiving methods and systems for databases built on models other than the relational model e.g. navigational databases or object oriented databases and for databases having records with complex attribute structures e.g. object oriented programming objects or markup language documents. The processes described may be implemented by applications specifically performing archiving and retrieval functions or embedded within other applications.

