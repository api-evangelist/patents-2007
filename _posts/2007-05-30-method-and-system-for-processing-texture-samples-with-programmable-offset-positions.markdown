---

title: Method and system for processing texture samples with programmable offset positions
abstract: A method and system for performing a texture operation with user-specified offset positions are disclosed. Specifically, one embodiment of the present invention sets forth a method, which includes the steps of deriving a first destined texel position based on an original sample position associated with a pixel projected in a texture map and a first offset position specified by a user and fetching texel attributes at the first destined texel position for the texture operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07924290&OS=07924290&RS=07924290
owner: NVIDIA Corporation
number: 07924290
owner_city: Santa Clara
owner_country: US
publication_date: 20070530
---
The present invention generally relates to computer graphics and more particularly to a method and system for processing texture samples with programmable offset positions.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

A common texture filtering approach to address aliasing artifacts involves accessing and filtering an equal number of texels along different axes that surround a pixel center mapped into texture space. Such an approach typically employs a bilinear filter or a trilinear filter. As an illustration is a texture map in which a prior art 2 by 2 filter kernel accesses four adjacent texels and surrounding a pixel center in a single clock cycle and then bilinear filtering the texels.

However some texturing applications filter texels differently. One example is texture based shadow mapping and another is highly dynamic range HDR rendering. Shadow mapping is a shadow rendering technique to enhance realism in computer generated scenes. More specifically during a shadow mapping process a scene is first rendered from a light s point of view to generate a special texture map commonly referred to as a shadow map in which each texel in the shadow map stores a depth value associated with a visible surface. Then the view of the scene is rendered from an observer s point view by which a pixel at a x y location in the screen space is projected into the light space coordinates and then tested for visibility. This test compares the depth value of the pixel with the depth value stored at the corresponding location in the depth map to determine whether the pixel is behind an object. Based on the comparison result the pixel is either drawn in shadow or lighted. To render smooth shadows pleasant to the eye more than four texels from the shadow map may need to be sampled per pixel and these texels often are not adjacent to one another.

As for the HDR rendering technique it is a technique for preserving detail in a scene with significant contrast differences. In other words if there are both dark and bright areas in a scene both of the areas can be accurately represented using this technique. Similar to the shadow mapping technique described above the HDR rendering technique also may sample more than four texels per pixel. These texels are usually distributed more sparsely than the 2 by 2 region such as texels and shown in .

Employing the prior art 2 by 2 filter kernel in the aforementioned shadow mapping and HDR rendering operations has several drawbacks. First the 2 by 2 filter kernel is likely only able to access one of the sparsely distributed texels per clock cycle. So to access all the desired texels multiple clock cycles are needed. To illustrate suppose a texturing application needs to access texels and and the prior art 2 by 2 filter kernel is used. Because the size of the 2 by 2 filter kernel is not large enough to cover all four desired texels at the same time but can cover one of the four texels such as texel three quarters of the available texture access bandwidth for the filter kernel is not used. For a texturing application needing to access more than four texels per pixel e.g. sixteen texels the inefficiency of the 2 by 2 filter kernel will be even more evident. Second the prior art 2 by 2 filter kernel bilinearly weigh the sampled texels which may not be optimal for certain texturing applications such as the ones involving the shadow mapping and HDR rendering operations discussed above.

As the foregoing illustrates what is needed in the art is thus a texture filtering technique that can efficiently and flexibly sample specified texels and address at least the problems set forth above.

A method and system for performing a texture operation with user specified offset positions are disclosed. Specifically one embodiment of the present invention sets forth a method which includes the steps of deriving a first destined texel position based on an original sample position associated with a pixel projected in a texture map and a first offset position specified by a user and fetching texel attributes at the first destined texel position for the texture operation.

At least one advantage of the invention disclosed herein is the ability to operate on texture samples at locations determined by a user specified offset position so that texture operations can be flexibly implemented and efficiently carried out.

Throughout this disclosure the term user broadly refers to a user or a developer of software program executing on a computing device. In addition the terms user specified and programmable can be used interchangeably to qualify a texture sample position or a texture sample offset position that can be specified or modified by a user. A texture sample is commonly referred to as a texel. Also some examples of a computer readable medium referred to herein include without limitation non volatile media e.g. optical or magnetic disks and volatile media e.g. dynamic memory .

System memory contains an application program a high level shader programs an application programming interface API and a GPU driver . Application program may invoke one or more instances of high level shader program . The high level shader programs typically include source code text of high level programming instructions that are designed to operate on one or more processing engines within GPU . High level shader programs may be translated into executable program objects such as executable shader programs by a compiler or assembler included in GPU driver or alternatively by an offline compiler or assembler operating either on computer device or other computer devices.

Executable shader program a texture buffer and a frame buffer all reside in GPU local memory . Executable shader program when executed by pixel shader engine in GPU issues instructions to different components of rendering pipeline . Texture buffer typically stores texture maps including shadow maps. Frame buffer includes at least one two dimensional surface that is used to drive display .

Rendering pipeline includes a pixel shader engine which further includes a texture unit . Texture unit is capable of retrieving requested texel attributes with programmable offset positions from texture buffer processing filter weights and performing depth comparison operations and texture filtering operations. Subsequent paragraphs will further detail the functions and operations of texture unit .

With P S Offset and texture n as inputs texture unit derives destined texel positions D D D and Dby applying the Offsetto P. For example if P is represented by u v and Offsetis represented by u v then D1 is then u u v v or u v . In addition as shown in with the origin at P each pair of u v is also associated with a vector V. For instance Vis associated with the origin at P and Offset. Furthermore in this implementation four different u v pairs are specified by a user and are not required to be symmetrical to one another. Specifically the length of uin Offsetis not required to be identical to any of the length of u or v in Offset Offset and Offset. Similarly the length of vin Offsetis also not required to be identical to any of the length of v or u in Offset Offset and Offset. Thus the size and the shape of the filter kernel covering these destined texel positions can be arbitrary. It should be apparent to a person with ordinary skills in the art to scale to N samples with N offset pairs without exceeding the scope of the present invention.

With the destined texel positions texture unit sends a read request to texture buffer to fetch appropriate texel attributes at D D Dand D such as the depth values. Then each of the depth values is compared against the depth value associated with P in a depth map test. is a conceptual drawing illustrating one set of results from applying the depth map test to texels D D Dand D. Whether the depth value associated with P is greater or smaller than the depth values stored at D D D and Dis represented by either 1 or 0. To derive the final shadow state value S texture unit applies filter weights to the results of the depth map test. In one embodiment texture unit calculates the shadow state value by simply averaging the results of the depth map test to blur aliasing effects. Here because there are four samples each of the four filter weights equals to . Alternatively texture unit can also apply filter weights that are based on the relative distance between the sampled texels and the projected pixel such as in the conventional bilinear filter. Texture unit returns the final shadow state value S to pixel shader engine .

While the foregoing embodiment describes one implementation in which the position of each sampled texel is derived from a user specified offset position the present invention contemplates other possible ways to derive destined texel positions. According to an alternative embodiment of the present invention is a conceptual diagram illustrating the derivation of texel positions from a single user specified offset position. In particular instead of receiving four user specified u v pairs as the aforementioned embodiment texture unit here receives a single Offset such as u v . Then texture unit symmetrically transforms the u v pair to generate the other three offsets without further user intervention. In one implementation Offset Offset and Offsetare v u v u and u v respectively. For example if u v has the values of 3 1 then Offset Offset and Offsethave the values of 1 3 1 3 and 3 1 respectively. With these Offset Offset Offset and Offsetand the original sample position of the projected screen pixel P the destined texel positions D D D and D are calculated. It is worth noting that unlike the implementation shown in and discussed above the symmetrical transformations employed in this implementation automatically generate destined texel positions that mirror one another and the size and shape of the filter kernel covering these mirroring texels cannot be as arbitrary.

According to yet another embodiment of the present invention texture unit applies a user specified scale factor to all the Offsets. Suppose is 3. Referring back to the example discussed above the scaled Offset Offset Offset and Offsetbecome 9 3 3 9 3 9 and 9 3 respectively. With the scale factor the size of the filter kernel covering the destined texel positions can be modified easily.

Instead of specifying only a single u v pair and relying on texture unit to generate the other three Offsets according to another embodiment of the present invention texture unit receives two user specified and non mirroring u v pairs and generates the other two pairs without further user intervention. For example referring back to suppose texture unit receives u v and v u . In this implementation texture unit symmetrically mirrors the received u v pairs to generate u v and v u respectively.

To trigger texture unit to perform any of the aforementioned operations one approach is to issue specific shader program instructions with certain input arguments to texture unit . This class of shader program instructions is referred to as programmable texel position PTP instructions. One of the input arguments for the PTP instructions can be a user specified offset position or an array of user specified offset positions. Alternatively one of the input arguments triggers texture unit to look up one or more offset positions specified and stored in a table by a user. According to one embodiment of the present invention some examples of the PTP instructions without limitation include 

Executing any of the PTP instructions above triggers texture unit to access a number of texels associated with a projected pixel at certain offset positions. The suffix ptp here means that only one programmable offset position is specified for one pixel in the instruction. In response to such an instruction with the ptp suffix texture unit generates the other three offset positions based on the single user specified offset position. The suffix ptp2 means that two programmable offset positions are specified in the instruction. In response to an instruction with the ptp2 suffix texture unit generates the other two offset positions mirroring the two user specified offset positions. Lastly the suffix ptp4 is used to indicate that four programmable offset positions are defined in the instruction. The preceding paragraphs detail some implementations of deriving offset positions from the user specified offset position s .

Once the destined texel positions are determined texture unit fetches the relevant texel attributes such as the depth values from the texture map specified in the PTP instruction in step . In step depending on the type and the contents of the issued PTP instruction texture unit performs the requested operation by the instruction. For example if the PTP instruction is Sample  ptp ptp2 ptp4 then the fetched texel attributes are filtered and a unique texel is generated per pixel. If the PTP instruction is Sample c  ptp ptp2 ptp4 then depth comparison is performed on the fetched texel attributes and the results are filtered to generate a unique texel per pixel. If the PTP instruction is Load4  ptp ptp2 ptp4 then the fetched texel attributes are returned per pixel. Neither the depth comparison operation nor the filtering operation is performed. If the PTP instruction is Load4 c  ptp ptp2 ptp4 then depth comparison is performed on the fetched texel attributes and the results are returned per pixel. No filtering operation is performed.

In one implementation this new class of PTP instructions is a part of API shown in so that they can be invoked by any application program developed using API and can be hardware plafform independent. Also these instructions in conjunction with texture unit enable a developer to efficiently implement sampling methods that result in filter kernels with large sizes and dynamically generated shapes such as the stochastic sampling technique. Furthermore in addition to bilinear filtering and equal averaging filtering as discussed above it should be apparent to a person with ordinary skills in the art to use the programmable offset positions in other filtering schemes such as anisotropic filtering and isotropic filtering. For example if an anisotropic filtering operation requires looking up and filtering sixteen samples then in one implementation one of the PTP instructions is issued four times so that sixteen offset positions are applied to all sixteen samples.

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples embodiments instruction semantics and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

