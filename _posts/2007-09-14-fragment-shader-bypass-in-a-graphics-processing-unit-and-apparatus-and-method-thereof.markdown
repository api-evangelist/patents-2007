---

title: Fragment shader bypass in a graphics processing unit, and apparatus and method thereof
abstract: Configuration information is used to make a determination to bypass fragment shading by a shader unit of a graphics processing unit, the shader unit capable of performing both vertex shading and fragment shader. Based on the determination, the shader unit performs vertex shading and bypasses fragment shading. A processing element other than the shader unit, such as a pixel blender, can be used to perform some fragment shading. Power is managed to “turn off” power to unused components in a case that fragment shading is bypassed. For example, power can be turned off to a number of arithmetic logic units, the shader unit using the reduced number of arithmetic logic unit to perform vertex shading. At least one register bank of the shader unit can be used as a FIFO buffer storing pixel attribute data for use, with texture data, to fragment shading operations by another processing element.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08325184&OS=08325184&RS=08325184
owner: QUALCOMM Incorporated
number: 08325184
owner_city: San Diego
owner_country: US
publication_date: 20070914
---
This disclosure relates to graphics processing units and more particularly to processing images with graphics processing units.

A graphics processing unit GPU is a dedicated graphics rendering device used to generate computerized graphics for display on a display device. GPUs are built with a highly parallel structure that provides more efficient processing than typical general purpose central processing units CPUs for a range of complex algorithms. For example the complex algorithms may correspond to representations of three dimensional computerized graphics. In such a case a GPU can implement a number of primitive graphics operations to create three dimensional images for display on a display device more quickly than using a CPU to draw the image for display on the display device.

A typical GPU receives an image geometry and uses a pipeline approach to generate graphics which can be output for example for display on a display device. A typical graphics pipeline includes a number of stages which operate in parallel with the output from one stage possibly being used at another stage in the pipeline. For example a typical graphics pipeline comprises vertex shader primitive assembly viewport transformation primitive setup rasterization hidden primitive and pixel rejection attribute setup attribute interpolation and fragment shader stages.

A vertex shader is applied to the image geometry for an image and generates vertex coordinates and attributes of vertices within the image geometry. Vertex attributes include for example color normal and texture coordinates associated with a vertex. Primitive assembly forms primitives e.g. point line and triangle primitives from the vertices based on the image geometry. Formed primitives can be transformed from one space to another using a transformation e.g. a viewport transformation which transforms primitives from a normalized device space to a screen space. Primitive setup can be used to determine a primitive s area edge coefficients and perform occlusion culling e.g. backface culling and 3 D clipping operations.

Rasterization converts primitives into pixels based on the XY coordinates of vertices within the primitives and the number of pixels included in the primitives. Hidden primitive and pixel rejection use the z coordinate of the primitives and or pixels to determine and reject those primitives and pixels determined to be hidden e.g. a primitive or pixel located behind another primitive or pixel in the image frame a transparent primitive or pixel . Attribute setup determines attribute gradients e.g. a difference between the attribute value at a first pixel and the attribute value at a second pixel within a primitive moving in either a horizontal X direction or a vertical Y direction for attributes associated with pixels within a primitive. Attribute interpolation interpolates the attributes over the pixels within a primitive based on the determined attribute gradient values. Interpolated attribute values are sent to the fragment shader for pixel rendering. Results of the fragment shader can be output to a post processing block and a frame buffer for presentation of the processed image on the display device.

The present disclosure seeks to address failings in the art and to provide efficiencies in graphics image processing to use one or more programmable processors in accordance with an input image geometry. A GPU can comprise one or more processors that provide powerful processing capabilities for use with the graphics pipeline. Under certain circumstances however an application may not need all of the processing capabilities provided by the GPU e.g. an application may need a less powerful alternative. In such a case it would be beneficial to be able to bypass certain portions of the GPU e.g. the fragment shader in order to make efficient use of the GPU s resources based on the needs of the application using the GPU for example.

Disclosed herein is a system method and apparatus which uses configuration information to make a determination to bypass or forego fragment shading by a shader unit of a graphics processing unit the shader unit being capable of performing both vertex shading and fragment shader. In accordance with the determination the shader unit performs vertex shading and bypasses fragment shading. In a case that some fragment shading is to be performed by the graphics processing unit a processing element other than the shader unit such as a pixel blender can be used to perform the fragment shading. Power supplied to arithmetic logic units used by the shader unit can be managed such that power is turned off to a number of the arithmetic logic unit in a case that the fragment shading is bypassed. The shader unit uses the reduced number of arithmetic logic units to perform vertex shading. Power can also be turned off to other components such as thread packing buffers and an input bus used to transport information to the shader unit from the thread packing buffer. At least one register bank typically used by the shader unit can be used as a buffer to buffer pixel attribute data for use along with texture data in performing fragment shading operations by the other processing element.

In accordance with one or more embodiments of the present disclosure a programmable processing element a shader unit configured to perform both vertex and fragment shading is dynamically re configured to perform vertex shading and to bypass or forego fragment shading based on information provided to the GPU. By virtue of this arrangement components determined to be unnecessary in the re configured pipeline can be bypassed. Components not used in a case that fragment shading is bypassed can be used for an alternative purpose. Alternatively power can be conserved by turning off power to such components. Other efficiencies can be achieved such as vertex shader threads having a reduced number of vertices.

In at least one embodiment a method is described for use with a graphics processing unit which uses configuration information to make a determination to bypass or forego fragment shading in a shader unit capable of performing both vertex shading and fragment shading performs vertex shading using the shader unit and bypasses performing fragment shading by the shader unit based on the determination.

In accordance with one or more embodiments an apparatus is described in which comprises a graphics processing unit and a shader unit. The graphics processing unit comprises a command decoder configured to use configuration information to make a determination to bypass or forego fragment shading in the shader unit. The shader unit is capable of performing both vertex shading and fragment shading. The shader unit is configured to perform vertex shading and bypass performing fragment shading based on the determination.

This brief summary has been provided so that the nature of the invention may be understood quickly. A more complete understanding of the invention can be obtained by reference to the following detailed description of the preferred embodiment s thereof in connection with the attached drawings.

Certain embodiments of the present disclosure will now be discussed with reference to the aforementioned figures wherein like reference numerals refer to like components.

In accordance with one or more embodiments a system method and apparatus are disclosed in which a shader unit is configured in accordance with configuration information provided to a graphics processing unit. Using the configuration information the shader unit which is capable of performing both fragment shading and vertex shading can be configured to perform the vertex shading and to forego the fragment shading. Another processing element other than the shader unit can be used to perform some fragment shading. One or more components that would otherwise be used by the shader unit to perform fragment shading can be used for another purpose or alternatively power can be turned off to components that are not otherwise used.

In the example of computing device includes a central processing unit CPU GPU and a memory module e.g. a random access memory RAM memory module or modules. CPU GPU and memory module communicate using a bus which can comprise any type of bus or device interconnect now known or later discovered. CPU can comprise a general purpose or a special purpose microprocessor. For example CPU may comprise a Core 2 Processor provided by Intel Corporation of Santa Clara Calif. or another type of microprocessor. GPU is a dedicated graphics rendering device. GPU can be integrated into the motherboard of computing device can be present on a graphics card that is installed in a port in the motherboard of computing device or can be otherwise configured to interoperate with computing device for example.

Display unit which is coupled to computing device can comprise a monitor a television a projection device a liquid crystal display a plasma display panel a light emitting diode LED array a cathode ray tube display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit for example. In the example of display unit can be a part of computing device . For instance display unit can be a screen of a mobile telephone. Alternatively display unit can be external to computer device and can be in communication with computing device via a wired or wireless communications connection or other connection for example. By way of a non limiting example display unit can be a computer monitor or flat panel display connected to a personal computer via a wired or wireless connection.

A software application can be executed via CPU . Software application can comprise any software application capable of executing via CPU such as a video game a graphical user interface engine a computer aided design program for engineering or artistic applications or another type of software application that uses two dimensional 2D or three dimensional 3D graphics by way of non limiting examples.

When CPU is executing software application software application can invoke subroutines of a graphics processing application programming interface API such as any one or more of an OpenVG API an OpenGL API a Direct3D API a Graphics Device Interface GDI Quartz QuickDraw or another type of 2D or 3D graphics processing API by way of non limiting examples.

In accordance with at least one embodiment when software application invokes a subroutine of graphics processing API graphics processing API invokes one or more subroutines of a GPU driver which execute via CPU on computing device . GPU driver can comprise a set of software and or firmware instructions that provide an interface between graphics processing API and GPU for example. When graphics processing API invokes a subroutine of GPU driver GPU driver formulates and issues a command that causes GPU to generate displayable graphics information. For example when graphics processing API invokes a subroutine of GPU driver to render a batch of graphics primitives GPU driver provides GPU with a processing configuration which GPU uses to render the batch of graphics primitives. GPU renders the batch of graphics primitives and outputs a raster image of the graphics primitives for example.

A command formulated by GPU driver can identify graphics processing configuration s that GPU is to use to perform the command which configuration s can identify a set of instructions to be executed by GPU a set of state register values and other types of information that GPU might need to perform the command.

In a case that GPU driver stores the graphics processing configuration s in memory GPU driver can reference the storage locations in memory module corresponding to the graphics processing configuration s in the command formulated by GPU driver . When GPU receives the command GPU can retrieve from memory the graphics processing configuration s referenced in the command received from GPU driver .

In accordance with at least one embodiment command decoder of GPU decodes the command from GPU driver and configures one or more of processing elements to perform the command. By way of a non limiting example command decoder retrieves the graphics processing configuration s from memory and loads a set of instructions identified by the graphics processing configuration s into processing element s . Command decoder can also be configured to provide input data to one or more processing elements .

In accordance with one or more embodiments processing elements implement a graphics pipeline . In accordance with such embodiments processing elements can implement graphics pipeline in a parallel mode. In a parallel mode processing elements can operate on data in parallel with output from processing element being used as input to another processing element . By way of a non limiting example processing element A performs a first graphics operation on a first set of initial input data received from command decoder and outputs a first set of intermediate results to processing element B. The initial input data can comprise data corresponding to one or more vertices which data can comprise coordinate and attribute data for example. Vertex coordinates identify a location within an image based on for example a four dimensional coordinate system with X Y and Z width height and depth coordinates and a W coordinate that comprises a perspective parameter. Vertex attributes can include color normal and texture coordinates associated with a vertex for example. Processing element B can perform another graphics operation on the first set of intermediate results output by processing element A and output a second set of intermediate results to another of the processing element and so on. While processing element B is performing the second graphics operation processing element A can be performing the first graphics operation on a second set of initial input data received from command decoder .

Processing elements can continue in this manner until processing element N outputs a pixel object to one or more buffers in memory module or output this new pixel object to some other destination. A pixel object is data that describes a pixel. Each pixel object may specify multiple color values and can specify a transparency level of the pixel. In some circumstances a pixel object may specify a first color in a first color format and a second color in a second color format.

In accordance with one or more embodiments of the disclosure one of processing elements comprises a shader unit that can be configured to perform one or more vertex shading operations each of which operate on vertex data and to perform one or more fragment shading operations each of which operate on pixel data. Thus in accordance with one or more embodiments a processing element can be configured as a unified shader unit which is capable of performing as a vertex shader that operates on vertex data and is further capable of performing as a fragment shader that operates on pixel data. In accordance with one or more embodiments the shader unit is a programmable processing element.

In accordance with one or more embodiments of the present disclosure GPU can be configured such that shader unit is used to process vertex data of vertex shader threads executed using shader unit . In addition and as is disclosed herein other processing elements of GPU can be configured to accommodate an absence of a fragment shader processing element.

Shader unit comprises two or more arithmetic logic unit ALU groups each of which comprises a number of ALUs . Each ALU performs an operation on one or more operands in conformance with an instruction fetched from instruction cache . The operands can comprise one or more constants retrieved from RAM via a communication line and or one or more temporary stored values retrieved from a register in one of registers banks via a communication line . Communication lines such as communication lines and identified herein can be a bus for example. Communication lines internal to shader unit can comprise a single bus or multiple buses. In accordance with one or more embodiments load control module also referred to herein as a load controller controls storage of constants to RAM via communication line and or storage of temporary values to and retrieval of temporary values from register file banks via communication line . In accordance with one or more embodiments RAM can comprise some portion of memory module for example.

Constants stored in RAM can be global values for use by shader threads . By way of a non limiting example under the control of load control module RAM can store constants for use with all of the shader threads used to process a command received from GPU driver . Register file banks access to which is also under the control of load controller can comprise a bank of registers used to temporarily store values. A set or bank of registers can be used to temporarily store values for use with a given one of the shader threads . ALUs can access e.g. store or retrieve temporary values in register bank via communication line .

In accordance with one or more embodiments the shader unit further comprises a thread scheduler and context register TSCR which operates to schedule shader threads and to synchronize the thread switch with load control module in accordance with information contained in a context register for a given shader thread . Shader threads scheduled by TSCR can be vertex and fragment shader threads. A vertex shader thread is one of a number of threads which implement a vertex shader used in graphics pipeline each vertex shader thread comprises a number of vertex shading operations that can be performed by the shader unit to provide a vertex shader for the graphics pipeline . Similarly a fragment shader thread is one of a number of threads which implement a fragment shader each fragment shader thread comprising a number of fragment shading operations that can be performed by the shader unit to provide a fragment shader for the graphics pipeline . In accordance with embodiments of the present disclosure shader unit is configured to schedule vertex shader threads . The shade unit is further configured to schedule fragment shader threads based on information obtained from GPU driver .

TSCR schedules a shader thread for execution and communicates with load control module via communication line so that a context for the scheduled shader thread can be loaded by load controller . A shader thread s context includes the instructions to be processed by shader unit in connection with the shader thread . Load controller controls instruction cache so that the instructions to be executed by ALUs for the scheduled shader thread are loaded in instruction cache and pointers to RAM and registers in register file banks point to the locations registers that store values global and temporary corresponding to the scheduled shader thread . As such instructions fetched from instruction cache for execution in connection with a scheduled shader thread operate in a context of the scheduled shader thread . For example an instruction is fetched from instruction cache and executed by one or more of ALUs for the scheduled shader thread . The scheduled shader thread can use one or more temporary values from a register file bank associated with the scheduled shader thread and or one or more global values from RAM associated with the scheduled shader thread in accordance with the fetched instruction.

Thread packing buffer can store data for a shader thread . The shader instructions or program for a scheduled shader thread can be pre loaded or runtime loaded into instruction cache by load controller from external memory or L2 cache in GPU pipeline via a bus not shown in and data can be loaded into the register bank corresponding to the scheduled shader thread based on the information provided to load controller by TSCR which identifies the scheduled shader thread . Constant RAM stores values such as global values available to all of the shader threads . Load control can request texture samples from texture engine for use with a scheduled shader thread .

In accordance with one or more embodiments of the present disclosure shader unit operates at a clock rate that may be faster than the graphics pipeline s clock rate speed. An asynchronous interface is used to allow communicate shader unit to communicate with a component external to shader unit . Communications lines and can comprise one or more communication bus structures with which shader unit communicates with one or more external components for example.

While shader unit can operate at a higher clock speed than other graphics pipeline components it need not. A higher clock rate is optionally used for example to achieve a throughput of shader operations for the vertex shader and or the fragment shader to match other graphics pipeline throughput if desired. Alternatively if the shader computation workload is light the shader unit clock speed can be lower than the graphics pipeline clock speed. When fragment shading is bypassed in accordance with embodiments of the present disclosure shader unit may be used exclusively for vertex shader operations such that even with a reduced number of vertices per thread and a reduced number of ALUs e.g. the ALUs in group A a vertex shading throughput similar to that achieved with a full complement of ALUs can be achieved using the reduced number of ALUs in a unit time period e.g. with shader unit scheduling a number of vertex shader threads that use the reduced number of the shader unit s ALUs . When fragment shading is not bypassed shader unit is shared by both vertex shader and fragment shader operations e.g. using the full complement of ALUs and larger thread sizes e.g. more vertices per thread to maintain an appropriate throughput.

By way of a non limiting example in each clock cycle of shader unit ALUs in both ALU groups A and B can operate on a number of vertices or pixels equal to the number of ALUs in ALU groups A and B. For example where N is equal to two ALU groups A and B can operate on four vertices or pixels per clock cycle of shader unit . In a case that the scheduled shader thread is a vertex shader thread four vertices in shader thread are operated on each by an ALU from ALU group A or B or both A and B during a given clock cycle of shader unit . Similarly in a case that the scheduled shader thread is a fragment shader thread four pixels in fragment shader thread are operated on each by an ALU from ALU group A or B or both A and B.

In the example shown in ALU groups A and B have the same number of ALUs . In accordance with one or more embodiments ALU group A may have a different number of ALUs than the number of ALUs in ALU group B. Furthermore in accordance with embodiments of the present disclosure the number of vertex shading operations and vertices processed need not be the same as the number of fragment shading operations and pixels processed . In some cases for example the workload ratio between vertex shading operations and fragment shading operations can be 1 4 1 2 1 1 2 1 or any other ratio. Similarly register file bank A can differ in size from that of register file banks B the size of both of which can be configured statically or dynamically. In general in a unit time period and in a case that the workload for the vertex shading operations is designated as NV for the number of vertices processed and the workload for fragment shading operations is designated as MP for the number of pixels processed the shader unit finishes NV vertices and MP pixels in a time sharing fashion during the unit time period. As an alternative to time sharing in accordance with another configuration or embodiment ALU group A may be scheduled to operate on vertex shader threads while ALU group B may be scheduled in parallel to operate on fragment shader threads at a shader unit clock cycle.

As discussed above GPU e.g. command decoder of GPU can determine that no or minimal fragment shading is needed based on information provided by application for example. In accordance with one or more embodiments in a case that it is determined that no or minimal fragment shading is needed fragment shading operations are bypassed in shader unit and shader unit need not process any fragment shader threads . Furthermore and in accordance with one or more such embodiments the number of vertices associated with each vertex shader threads can be reduced as discussed in more detail below and it is possible to operate shader unit using a reduced number of ALUs while still generating the same level of output per clock cycle of the graphics pipeline . In so doing power conservation can be achieved without any noticeable degradation in performance of or change in a level of output by shader unit . In a case that no or minimal fragment shading is indicated and shader unit implements vertex shading operations to the exclusion of fragment shading operations to the extent they would be used in connection with fragment shading operations thread packing buffer and corresponding input bus e.g. thread packing buffer B and input bus B can be disabled and power to these components can be turned off. In addition the register file banks used by fragment shader threads are available to store attribute data e.g. color data output by attribute interpolator . In so doing it is possible to use register file banks B for example as a first in first out FIFO buffer to store colors or other data for input to pixel blender . Use of the register file banks e.g. register file banks B as a FIFO can cover latency of some texture loading retrieval performed via texture engine for example.

In accordance with one or more embodiments a power management unit or power controller can be used to control power supplied to components of shader unit including ALUs as well as power to components external to shader unit e.g. thread packing buffers and input buses . In a case that a component e.g. an ALU thread packing buffer input bus etc. is not used by shader unit the power management unit can adjust e.g. turn off the power supplied to the component. In so doing components that are not used in a case that shader unit performs vertex shading operations to the exclusion of fragment shading operations power to unused one or more components can be reduced or completely shut off to achieve a reduced level of power consumption by the GPU . In accordance with such embodiments the power management unit can control power supplied to one component independent of the other components. By way of a non limiting example the power management unit can control power to each of the ALUs independent of the other ALUs . In this example the power management unit operates to turn a power supply off to one or more of ALUs A and B and to supply power to other of ALUs A and B. Alternatively in a case that the component comprises an ALU group the power management unit can control power supplied to an ALU group independent of other ones of the ALU groups . By way of a non limiting example the power management unit can control power to the ALUs A in ALU group A independent of the ALUs B in ALU group B. In this example the power management unit operates to turn a power supply off to the ALUs A and to supply power the ALUs B of ALU group B.

In a case that minimal fragment shading is needed GPU can configure a processing element other than shader unit to perform the fragment shading. In accordance with one or more embodiments the minimal fragment shading needed can be performed by a processing element that can be programmed to perform the fragment shading operations as is described in more detail below. In so doing the resources of the shader unit can be focused on the more involved shading operations and resources of shader unit not needed to perform the more involved shading operations being powered down.

In a case that shader unit is configured to not perform fragment shading operations TSCR schedules vertex shader threads each of which can include a reduced number of vertices. More particularly shader unit is configured to process vertices using a reduced number of ALUs while still generating the same level of output e.g. NV vertices in the same unit time period as shader unit schedules vertex shader threads exclusively to operate on ALU group A in every unit time period that shader unit is so configured.

Embodiments of the present disclosure are described by way of a non limiting example in which the number of ALUs per ALU group is two. In such a case shader unit and in particular TSCR can schedule a number of vertex shader threads in a unit time period. Vertices associated with each vertex shader thread scheduled by TSCR are operated on using one of ALU groups A and B e.g. ALU group A. In a first clock cycle of shader unit TSCR schedules a first vertex shader thread which results in a first set of two vertices corresponding to the first vertex shader thread being processed by shader unit using ALU group A. In a second clock cycle of shader unit TSCR schedules a second vertex shader thread which results in another two vertices the vertices in the second vertex shader thread being processing by shader unit and ALU group . Thus in a unit time period a set of vertices comprising the expected number of vertices are processed using half the ALUs of shader unit . By virtue of this arrangement a number of ALUs can be bypassed and the power otherwise consumed to operate the bypassed ALUs can be conserved by reducing or completely shutting off power to the unused ALUs .

In addition to vertex shader graphics pipeline of GPU includes primitive setup and rejection module attribute gradient setup module rasterizer hidden primitive and pixel rejection module attribute interpolator pixel blender and texture engine .

Vertex shader determines surface properties of the image at vertices within the image. In this way vertex shader generates vertex coordinates and attributes of each of the vertices within the image geometry. The vertex coordinates identify the vertices within the image geometry based on for example a four dimensional coordinate system with X Y and Z width height and depth coordinates that identify a location of a vertex within the image geometry and a W coordinate that comprises a perspective parameter for the image geometry. The vertex attributes for example may include color normal and texture coordinates associated with a vertex. In accordance with embodiments disclosed herein vertex shader within GPU makes the attributes and or coordinates for vertices processed by vertex shader to other stages of the pipeline .

Primitive setup and rejection module attribute gradient setup module rasterizer hidden primitive and pixel rejection module and attribute interpolator each use either vertex coordinates or vertex attributes to process the image geometry. Primitive setup and rejection module assembles primitives with one or more vertices within the image geometry applies perspective projection and viewport transformations on primitive vertices and determines edge coefficients for each primitive edge. In addition primitive setup and rejection module can examine a primitive to determine whether or not to reject the primitive e.g. by performing scissoring or backface culling using the XY coordinates of a primitive s vertices to determine whether or not to reject the primitive or a portion thereof from consideration for a given image frame. For example a primitive or primitive portion can be determined to be invisible e.g. located on a backside of an object within the image frame in which case the primitive or portion thereof can be rejected by the primitive setup and rejection module .

Attribute gradient setup module computes gradients of attributes associated with the primitives for the image geometry. In accordance with embodiments presently disclosed an attribute gradient comprises a difference between the attribute value at a first pixel and the attribute value at a second pixel within a primitive moving in either a horizontal X direction or a vertical Y direction. Attribute gradient setup module uses vertex attributes to compute the attribute gradients.

Once the attribute gradient values are computed rasterizer converts the primitives for the image geometry into pixels based on the XY coordinates of each of the vertices within the primitives and the number of pixels included in the primitives. Hidden primitive and pixel rejection module rejects hidden primitives and hidden pixels within the primitives e.g. using the early depth and stencil test based on the Z coordinates of the vertices within the primitives. Primitives or pixels within primitives can be considered hidden and be rejected from consideration during processing of a specific frame of the image for example when the primitives or the pixels within primitives are located behind another object within the image frame.

Attribute interpolator interpolates the attributes over pixels within the primitives based on the attribute gradient values. Fragment shader threads are packed at the end of processing by attribute interpolator and communicated to shader unit via communication line . Attribute interpolator can disregard attributes of vertices associated with rejected primitives within the image geometry. In accordance with one or more embodiments interpolated attribute values become input to pixel blender bypassing fragment shader . Results of pixel blender can be output for presentation of the processed image using an output device such as display unit .

As illustrated in the example of output from the vertex shader e.g. texture data generated by vertex shader can output to the texture engine for use in subsequent processing by graphics pipeline . In addition vertex shader can submit a texture data lookup request to texture engine to retrieve texture data for use with vertex shader . Referring to load control module can sample the texture data for the vertex shader threads via texture engine for example.

In a case that fragment shader is performed in graphics pipeline e.g. it is not bypassed attribute interpolator forwards its output e.g. pixel attribute color data to fragment shader . In addition attribute interpolator submits a request for initial textures to texture engine . In response texture engine obtains the requested textures and forwards them to the register file banks via load controller and communication lines and for use by shader threads implementing fragment shader .

Alternatively in a case that fragment shader is bypassed and some minimal fragment shading is to be performed a request for initial textures is submitted to texture engine from attribute interpolator . In response texture engine forwards the requested textures to pixel blender which uses the texture data in the fragment shading operations performed by pixel blender . Referring again to input output I O bus passes textures e.g. dependent textures comprising texture results from a previous operation to and from texture engine via load controller . Attribute interpolator requests initial textures from texture engine via communication line . In response texture engine forwards the initial textures to pixel blender via communication line . As discussed above register file banks e.g. register file banks B not used by fragment shader threads can be used as a FIFO buffer to store color values and other data such as non texture data output by attribute interpolator for input to pixel blender . The data stored in the FIFO buffer comprising some portion of register file banks is input to pixel blender via communication line . Dotted lines are shown between attribute interpolator and fragment shader and between fragment shader and pixel blender in to further illustrate that when shader unit bypasses fragment shading attribute color values are sent via register file banks of shader unit to pixel blender .

During initial processing by pixel blender the color data from the register file banks FIFO is synchronized with the initial textures received by pixel blender from texture engine . In accordance with one or more embodiments and in a case that some fragment shading is to be performed e.g. texture combining pixel blender is configured to perform or emulate the fragment shading functionality or texture combining functionality. The pixel blender is further configured to perform blending e.g. alpha blending on the result of the fragment shading operation s performed by pixel blender .

In accordance to one or more of such embodiments disclosed herein a programmable graphics processing element PGPE can be used to implement one or more of program elements . For example in accordance with such embodiments a PGPE can be used to implement pixel blender which is programmed to perform blending as well as fragment shading not performed by shader unit if any is needed. In accordance with one or more of such embodiments the PGPE can be for example a PGPE as described in U.S. application Ser. No. 11 735 353 entitled Programmable Graphics Processing Element the contents of which are incorporated herein by reference.

In accordance with one or more embodiments the PGPE can execute an instruction set which can vary depending on the functionality needed to be performed using PGPE. is a block diagram illustrating an exemplary PGPE . As illustrated in the example of PGPE comprises an input module which receives data corresponding to a pixel also referred to herein as a pixel object as input. For example PGPE can receive one or more pixel objects from one or more of processing elements memory module register file banks etc.

In accordance with one or more embodiments input module uses one or more arithmetic logic units ALUs to perform format conversions. In the example shown ALU s is a part of an ALU array ALU . Each of the ALUs is capable of performing arithmetic operations such as a single multiplication double multiplication 2D dot product maximum operation register copy operation gamma encoding gamma decoding operation and or other types of operations including other types of arithmetic operations by way of a few non limiting examples. ALU array can use an 8 bit integer 10 bit integer 16 bit floating point 32 bit floating point etc. value per color component for example. The ALUs can be single threaded or multi threaded.

Input module can store intermediate values e.g. a result of a format conversion in a register in a unified register file e.g. a register file comprises a number of hardware registers. Depending on the implementation of ALU array for example each hardware register can store four 8 bit integers that represent color components four 10 bit integers that represent color components four 16 bit floating point values that represent color components etc.

An instruction execution module IEM in PGPE fetches one or more instructions identified using program counter from an instruction module . Instruction module is capable of storing a number of instructions e.g. using hardware registers synchronized random access memory SRAM etc. IEM decodes the fetched instruction and fetches the operands as specified by the decoded instruction. IEM can fetch the operands from unified register file and or constant register file for example. As with register file constant register file can comprise hardware registers and or an SRAM for example. Constant register file can store a blending factor a pattern for a legacy 2D Raster Operation ROP or other constant values by way of non limiting examples.

An instruction can cause IEM to extract one or more color components from pixel objects stored in one or more registers in unified register file and to use these color components as operands. For example pixel objects stored in a register in unified register file can be formatted in the RGBA format having eight bits per color component. When a pixel object is formatted in the RGBA format bits 0 through 7 may represent the red component bits 8 through 15 may represent the green component bits 16 through 23 may represent the blue component and bits 24 through 31 may represent the alpha component. The alpha component of a pixel represents the level of transparency of the pixel. Using this example and in accordance with one exemplary instruction IEM extracts the red component of the pixel object and uses the red component as an operand e.g. bits 0 through 7 from the pixel object. Other instructions can instruct IEM to extract different or multiple components e.g. color and or alpha components from a pixel object. In another example an instruction in a depth stencil graphics operation may instruct IEM to extract a stencil value or a Z value from a pixel object in one of the registers in unified register file .

An instruction can instruct IEM to modify an operand prior to providing the operand to ALU array . In some instances an instruction can use a so called source modifier to instruct IEM how to modify an operand. For example an instruction can instruct IEM to provide a negative of the operand to provide an absolute abs value of the operand or to provide an inverted value of the operand. An inverting operation computes operation of 1.0 x in a normalized integer representation.

After fetching the operands IEM can instruct ALU array and in particular one or more ALUs in ALU array to perform one or more arithmetic operations specified by the decoded instruction using the fetched operands. When ALU array finishes performing the arithmetic operation ALU array can communicate the resulting value s back to IEM . When IEM receives the result s from ALU array IEM stores the result s in unified register file . IEM can provide value s stored in unified register file to ALU array as one or more operands in connection with another arithmetic operation.

Program counter is incremented to identify a next instruction in instruction module which can then fetched for execution as the new current instruction. This continues until all of the instructions are processed.

As illustrated in the example of PGPE can include an output module . Output module can read data from unified register file and output the data for use in another processing element of graphics pipeline for example. Output module can output data to multiple locations e.g. in a sequential or parallel manner for example. Output module can use ALU array to perform one or more format conversions on the data before outputting the data.

In accordance with one or more embodiments using as an example ALUs are shared by input module IEM and output module each of which is responsible to obtain the data to be operated on by an ALU and send an instruction and the obtained data to the ALU for execution. After completion of the operation the ALU returns the result to the module that provided the input to the ALU . Thus in such an example the ALU acts as a slave responsible for executing an operation under the command of another module which supplies the ALU with the input to be manipulated by the ALU and the instruction to be executed by the ALU . In such a case the ALU is not responsible for reading source input from register files such as unified register files and or constant register file or writing the result to a register file.

As an alternative in accordance with one or more embodiments the ALUs are shared by input module IEM and output module however the ALUs can be responsible for reading input source data from one or more register files and to output results to the one or more register files. In such a case an ALU receives an instruction from another module e.g. input module IEM and output module reads input source data from one or more of the register files performs one or more operations based on the instruction command received from the input module IEM or output module and writes the resulting data to one or more register files.

In such an alternative case a read write communication pathway not shown in between ALU array and unified register file can be used by an ALU for data input output to from unified register file based on control signal information received from the input module IEM or output module . Similarly a read communication pathway also not shown in can be used by ALU array for input of constant data from constant register file to an ALU based on control signal information received from the input module IEM or output module . The communication pathways can take the place of the communication pathways between constant register file or unified register file and one or more of input module IEM and output module shown in for example.

In accordance with one or more embodiments ALU array can execute instructions for color components and alpha components simultaneously in the same or a different clock cycle.

In accordance with one or more embodiments each instruction executed using PGPE can conform to a single syntax which specifies an operation code opcode some number of destination registers e.g. one or two destination registers and some number of source registers e.g. four source registers. The source registers specified in instructions may be registers in unified register file registers in constant register file or another location that stores data for example.

An instruction set for use in accordance with embodiments of the present disclosure can comprise any number and type of instructions each instruction can operate on a number of operands. The instruction set can include input output arithmetic e.g. add multiple subtract reciprocals gamma decoding gamma encoding etc. comparison e.g. minimum maximum compare etc. logic e.g. if else else endif etc. binary e.g. and or xor not etc. binding move and end instructions.

Any of a number of varied and different graphics operations can be performed using an instruction set implemented using PGPE . In accordance with one or more embodiments PGPE can be configured to implement one or more blending operations using such an instruction set as well as fragment shading operations not performed using shader unit .

In accordance with one or more embodiments pixel blender synchronizes color data received from the FIFO implemented using register file banks with texture data. Thereafter pixel blender can perform some amount of fragment shading using a texture combining operation e.g. using primary and secondary input pixel objects. In such a case pixel blender receives a primary input pixel object from attribute interpolator e.g. via the FIFO provided using register file banks and a secondary input pixel object. The secondary input pixel object can be a pixel object which specifies a texture color for a texture mapped pixel generated using a texture filtering operation and colors of texture pixels texels identified as nearby texels together with filtering factors and or weights which can be performed by texture engine for example.

The new pixel object generated using the texture filtering operation specifies a texture color for a texture mapped pixel using colors of the nearby texels specified by the secondary input pixel object. The new pixel object can be supplied to pixel blender as one of the pixel objects input to pixel blender to perform a fragment shading operation. e.g. texture combining operation. In a case that pixel blender is implemented using PGPE PGPE uses a primary input pixel object and a secondary input pixel object to perform a texture combining operation. The result can be stored for access by the pixel blender in performing a pixel blending operation on the result. In accordance with one or more embodiments PGPE can be used to implement a VG BLEND MULTIPLY mode a VG BLEND SCREEN mode and a VG BLEND DARKEN mode of the OpenVG API or a Porter Duff blending graphics operation such as a Porter Duff source operation a destination over source operation a source in destination operation and a destination in source operation by way of a some non limiting example. PGPE is relatively small in size comparing to shader unit thus it may take less power consumption to perform the same amount of operations on PGPE .

In one or more exemplary embodiments the functions described can be implemented in hardware software and or firmware or any combination thereof. If implemented in hardware the functions can be implemented in one or more microprocessors microcontrollers digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or the like. Such components can reside within a communication system data writing and or reading system or other systems. If implemented in software the functions can be stored on or transmitted over as one or more instructions or code on a computer readable medium. Computer readable media includes tangible computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media can be any available media that can be accessed by a computer. By way of example and not limitation such computer readable media can comprise RAM Flash memory read only memory ROM electrically erasable programmable read only memory EEPROM compact disc read only memory CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. The term computer readable medium can also be defined as a tangible computer program product. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

