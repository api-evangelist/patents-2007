---

title: Integration of secure data transfer applications for generic IO devices
abstract: Techniques are presented for sending an application instruction from a hosting digital appliance to a portable medium, where the instruction is structured as one or more units whose size is a first size, or number of bytes. After flushing the contents of a cache, the instruction is written to the cache, where the cache is structured as logical blocks having a size that is a second size that is larger (in terms of number of bytes) than the first size. In writing the instruction (having a command part and, possibly, a data part), the start of the instruction is aligned with one of the logical block boundaries in the cache and the instruction is padded out with dummy data so that it fills an integral number of the cache blocks. When a response from a portable device to an instruction is received at a hosting digital appliance, the cache is similarly flushed prior to receiving the response. The response is then stored to align with a logical block boundary of the cache.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032154&OS=09032154&RS=09032154
owner: SanDisk Technologies Inc.
number: 09032154
owner_city: Plano
owner_country: US
publication_date: 20071213
---
This invention pertains generally to the field of using portable media such as a secure memory card with digital appliances such as a telephone handset and more particularly to techniques for transferring instructions between a digital appliance and a portable media in communication therewith.

Digital appliances such as notebook or laptop computers personal digital assistants PDAs or mobile phones are commonly used with portable media such as memory cards or USB drives. In some cases secure data is stored on these portable media. The application responsible for securely transferring this data between the hosting appliance and the media often uses instructions that have a specific structure. As part of the transfer process the host may cache the instruction but as the host s operating system may unaware of the instruction s structure and because the host s cache structure may not be compatible with the instruction s structure the instruction along with any associated data may not be successfully transferred.

According to a one aspect techniques are presented for sending an application instruction from a hosting digital appliance to a portable medium where the instruction is structured as one or more units whose size is a first size or number of bytes. After flushing the contents of a cache the instruction is written to the cache where the cache is structured as logical blocks having a size that is a second size that is larger in terms of number of bytes than the first size. In writing the instruction having a command part and possibly a data part the start of the instruction is aligned with one of the logical block boundaries in the cache and the instruction is padded out with dummy data so that it fills an integral number of the cache blocks.

According to another aspect when a response from a portable device to an instruction is received at a hosting digital appliance the cache is similarly flushed prior to receiving the response. The response is then stored to align with a logical block boundary of the cache.

Various aspects advantages features and embodiments of the present invention are included in the following description of exemplary examples thereof which description should be taken in conjunction with the accompanying drawings. All patents patent applications articles other publications documents and things referenced herein are hereby incorporated herein by this reference in their entirety for all purposes. To the extent of any inconsistency or conflict in the definition or use of terms between any of the incorporated publications documents or things and the present application those of the present application shall prevail.

When transferring content between a portable medium such as a memory card and a hosting digital appliance such as mobile telephone handset a host s operation system will often use a caching mechanism for the content. This cache will typically have a structure where it is logically broken up into a number of blocks of a particular size. The content being transferred whether data or an instruction a command and maybe some associated data may also be structured in a specific way as one or more sections of a certain size. When the content is structure in units of one size for example as 512 Byte sectors and the cache is structured in units of another size for example in 2 KB blocks the caching mechanism may clash with the content s structural requirements.

This is particularly true with dealing with secure content and secure portable storage media such as that marketed under the TrustedFlash name. In such cases the more basic levels of a host s operating system that handle transfers between the host and the portable medium will see the instruction as just so much data being unaware of any embedded commands in the instruction and store it as such in cache. Examples of such instructions and their use are described in U.S. Pat. No. 7 237 046 U.S. patent application Ser. No. 10 899 260 and particularly U.S. patent application Ser. Nos. 11 298 349 and 11 299 186. Under such arrangements the host s operating system may treat the instruction as data to be written to a particular address on the medium but when received on the medium this instruction will be interpreted as for example a write command to store data at different address on the medium. If the host then tries to issue a read command for this data the address as seen by the host s operating system will not correspond to the actual address as interpreted on the medium and as the host may then rely what is thinks is cached copy of the data it will incorrectly use this cached data.

The techniques described here are widely applicable both for portable media such as memory cards that are primarily used with a hosting digital appliance and also digital. appliances which themselves include non volatile memory such as embedded flash. Example of such digital appliances include desktop notebook or laptop tablet computers personal digital assistants PDAS mobile phone handsets a variety of media players such as MP3 players DVD players gaming consoles digital recording devices such as digital cameras and others. Suitable portable media are available from SanDisk Corporation the assignee hereof which include those sold under trademarks TrustedFlash CompactFlash CF Multi Media Card MMC Secure Digital SD MicroSD and Memory Stick PRO. These memory cards are removably connectable with digital appliances through mating connectors that are different thr most cards. Flash drives sold as those sold under the Cruzer trademark contain a plug according to the Universal Serial Bus USB standard so can be plugged directly into any digital appliance having a USB receptacle. TrustedHash cards and other secure cards SIM SMMC SD etc allow secure storage of the both licenses and associated content. Also the following discussion will often refer to non volatile memory as flash the techniques given here are not so limited and more generally apply to other non volatile memory structures such as described in US patent application Ser. No. 10 841 379 published as US Patent Application Publication number 2005 0251617. for example for both portable devices and embedded memories. Although the teachings given here are not so limited when reference is made to a particular embodiment flit purposes of discussion the following will often refer to the concrete example of a mobile telephone handset used with a memory card such as that of the TrustedFlash variety having instructions whose structure is based on a sector.

To circumvent such possible difficulties with the host caching firmware associated with the secure transfer can be changed to be aware of the running time command size the associated application toolkit needs to be integrated with the applications instructions sent from the application to the platform operation system OS including write and read commands start with a cache block size aligned sector and that the write read buffer size should be cache block size aligned.

Technically to allow fast spread out of secure content media to users of digital appliances integration for these platforms with the corresponding secure content toolkit is important. Due to the special requirements of most secure content technology and code size consideration the corresponding application toolkit usually needs to be integrated into the operating system OS of a handset or other hosting device so that the applications can call the application programming interfaces APIs provided by the toolkit to access the media. However for certain standardized or open platforms say Linux and WIPI this solution can be complicated to implement since it is not easy to have the needed platform modifications to support secure content media.

To overcome this limitation every platform will provide a way for applications to access generic IO device in case of a TrustedFlash card this is the SD IO device. With this assumption the applications can use the provided IO access to communicate with the secure content media card by integrating the corresponding toolkit into the applications. This can be used for any platforms especially being good for those unmodified platforms as long as the IO device is accessible for applications. The major difficulty of this solution is to deal with the caching mechanism which is used most likely for every platform. The following section describes the nature of this caching mechanism and the conflicts between its buffered IO and the earlier versions of secure content transfer firmware.

As noted many command and data transfer processes rely upon a particular structure for instructions. For example current TrustedFlash firmware is defined to communicate with the handset or other host through sector 512 Bytes based instructions. The number of sectors for each instruction is predefined. This can cause a major IO problem for buffered IO only platforms. Due to the hosting platform s caching mechanism the instructions sent to TrustedFlash firmware on the media may not be sector based so that the TrustedFlash communication channel is broken. For example a TrustedFlash CREATE ACR command is a one sector write instruction. When an application sends a one sector write to the platform OS this write command may be changed to a write command with multiple sectors and the starting write location may be changed as well after this command reaches the secure transfer firmware on the media.

In practice some platforms support direct IO while others only provide buffered IO. In addition the caching algorithms may be different from platform to platform. Therefore a generic solution is quite preferable for integration with secure transfer application s toolkit. The following discussion present such an integrated solution based on the example for TrustedFlash that works whether the host platform uses direct IO or buffered IO. This is presented below as including four components the structure of system integration the modification of firmware and the methods of solving caching for write and for read.

Since a platform remains the same for the applications to access the secure content card the corresponding toolkit will need to integrate into the host s applications so that they can call the toolkit APIs to send say TrustedFlash commands to the TrustedFlash cards. Briefly the toolkit provides full package of APIs for applications to access the secure media. This package offers many functions related with secure system such as system operation account operation storage operation and digital rights management DRM operation.

The applications will directly call the toolkit s APIs and then the toolkit will talk to the corresponding secure medium by using the device operation methods provided by the platform OS. For example in Linux this methods are open read write and close . According to each individual platform this glue layer between toolkit and the platform is implemented in the Platform I O Device Operation.

As discussed above the instructions used in secure data protocols are often based on units of a particular number of bits. For example the TrustedFlash instructions for communicating between a host and the TrustedFlash firmware on media are sector based. The number of sectors for each instruction is predefined during the firmware loading. and table of show the TrustedFlash command structure as found in the TrustedFlash specification.

As shown in and as is developed further in U.S. patent application Ser. Nos. 11 298 349 and 11 299 186 the exemplary instruction is composed of a first sector 512 Bytes that holds the command. After this command block follows any associated sectors of data again structured as sectors. For example a write instruction for N sectors of data would consist of N 1 sectors a first for the write command followed by the data sectors. For commands without data such as a status request would just be the one sector of the command block. Any response such as the data of a read command would be treated by the read process of the last section below. The table of illustrates some details for the exemplary command block structure in the TrustedFlash protocol.

In order to make the media firmware understood the commands from platforms with buffered IO the current firmware preferably knows the dynamical command size of each commands. To do so one field can be introduced to add into the command block to specify the total size of current sending command. For example in the table of a new field for the dummy sector count can be added into the second portion of the command sector beginning at byte . The predefined command lengths will be treated as the default values and this field will tell the actual size of this command in run time. If this field is 0 then the default values will be used.

When a platform OS is using buffered IO the behaviors for both read and write may be changed as described below. The following two sections describe the way to deal with the caching on write when an instruction is sent to the medium and read when a response is returned. Briefly this process is illustrated in which is similarly numbered to except as shown in the instruction is now aligned with a logical block boundary in the cache and any partially filled cache blocks are then padded out as shown by the hatched area .

The secure transfer firmware is the agent inside the media e.g. TrustedFlash card to handle the commands. The secure transfer commands from the host are preferably sent to the card immediately. Therefore if the platform OS does not send a write command to the card but puts the data into the buffer instead the medium will have no way to get the command and respond to it. In addition for instructions structured with the command block required to be in a specific locations as with the TrustedFlash command block that must be the first sector of the whole command the sequence of the write command must follow the appropriate e.g. TrustedFlash protocol any extra reads or writes in the command sequence before command completion including get command status will cause problems to firmware so that the command will not succeed. Below is the method to solve these problems one by one.

Generally when a card is inserted to the host the host will initialize and mount the media card. To access the contents of the media it will open the media. It is considered as logical open. Related data table cache and so on are established. After that you can browse the directories or open file for read write operation. By closing the media all cache contents tables or data are cleared or invalidated. For example the Linux operating system includes an open command and a close command. The close command closes a file descriptor of the media so that it no longer refers to any file and may be used. Any record locks held on the file descriptor it was associated with and owned with the process are removed. To logically reopen the device a call to open will create a new open file description. These are described further in the Linux programmers manual. 

The other problem is the potential change of write location write buffer size and command sequence. To avoid these the toolkit will send to the medium a command in the following way 

The flow chart of describes this method of write command. The flow begins at with the original status of the medium being open. The cache is then flushed at by logically closing the device and then reopening it. Alternately if the operating system has a specific command to flush the cache this can be used instead.

The instruction is then placed in the flushed cache at block . As shown in the instruction including command block and in this example four sectors of data is stored so that it is aligned with a logical boundary in the cache . If this leaves any cache blocks only partially filled these are then padded out to maintain the instruction as an integral number of logical blocks in the cache. In this example as each logical block in the cache can hold 4 sectors and the instruction has 5 sectors when the instruction is contiguously cached the last sector of the instruction only occupies part of a cache block. The hatching at represents the added padded so that the host s operating system thinks the instruction is formed of complete cache blocks and treats it as such.

Returning to as shown in block this process can include the command block being filled with the total size of the actual instruction or command and reading back the starting sector with the cache s logical block size aligned. The data including any dummy sectors to fill out a complete cache block are then filled. The starting write sector can then be checked to confirm the block alignment of the instruction. At block the write command to send this instruction to the media can then be sent to the platform s operating system where the write process will now start with the logical block address LBA that aligns with the cache s block boundaries and size.

After receiving an instruction form the host the medium may need to respond to the host such as with a status or with data in response to a read request. Because of caching whenever the application send a read command the OS may just go to the cache to read it back if the related location data is in the cache. Therefore the actual firmware response is not returned back to the application.

At the cache is flushed as at with a close and then open or if available with a command to flush the cache. As the cache is now emptied this prevents the operating system from just returning cached material instead of the actual response from the medium. At the alignment is checked to see that when the received response is placed in the cache it will be aligned with the logical block structure of the cache. Finally the read command is sent to the platform s operating system.

Once these preparations have been made the driver can then send the read instruction to the medium which will then return the response. As noted this may include actual secure user data that data as seen be the secure transfer system or a non data response such as a status. The response is then cached aligned with the logical block boundaries of the cache. Padding which secure transfer application would then ignore may also be added to fill out an integral number of cache blocks.

Although the invention has been described with reference to particular embodiments the description is only an example of the invention s application and should not be taken as a limitation. Consequently various adaptations and combinations of features of the embodiments disclosed are within the scope of the invention as encompassed by the following claims.

