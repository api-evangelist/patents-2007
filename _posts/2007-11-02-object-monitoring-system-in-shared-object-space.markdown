---

title: Object monitoring system in shared object space
abstract: The present invention relates to a system for monitoring an object space shared among plural applications. Objects stored in the shared space are registered for monitoring and the system receives data related to the registered objects that can be utilized to perform statistical analysis, for example, relating to the overall health of the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08201187&OS=08201187&RS=08201187
owner: VMware, Inc.
number: 08201187
owner_city: Palo Alto
owner_country: US
publication_date: 20071102
---
This application is a continuation of U.S. patent application Ser. No. 10 690 783 filed Oct. 21 2003 now abandoned.

The present invention relates to a system for monitoring an object space shared among plural applications.

Computer hardware and storage media can only create store and process binary information i.e. information written using only two digits 0 and 1 . A compact disc for example has a surface subdivided into tiny sections that are either pitted 1 or not pitted 0 such that a laser can detect the presence or absence of pits. Similarly microprocessors have inputs and outputs to which a reference voltage either is 1 or is not 0 present. Microprocessors repeatedly measure the voltage at each input and output at regular intervals or cycles hence the speed of a processor is expressed in cycles per second or Hertz. Accordingly any computer program as well as any data used in that computer program must first be expressed in binary code for a computer to run the program or process the data.

Though binary code is conceptually simple its use to perform computerized tasks introduces two drawbacks. First binary code is a relatively inefficient way to express information. As a simple example the number 100 in decimal notation is expressed as 1100100 in binary code and therefore must at a minimum occupy seven pits on a compact disc and or occupy either a single input of a processor for seven cycles if entered serially or seven inputs for one cycle if entered in parallel . In technical terms the space that a piece of information occupies or alternatively the number of time cycles a piece of information occupies is referred to in bits. That is to say the number 100 is a 7 bit number because it takes seven digits to express in binary code. The number 101 is also a 7 bit number coded as 1100101 as is every number between 64 1000000 and 127 1111111 .

In computer applications binary code is even more inefficient because computerized information is by convention typically expressed in multiples of 8 bits e.g. 8 bit 16 bit 24 bit etc. The reason for this convention is that a computer processing or storage device has no physical way of distinguishing when one number ends and another number begins. Accordingly the convention is to write a program that specifies the bit rate i.e. the number of bits that each piece of data processed in the program will occupy. If a program is written in 8 bit code for example every piece of data occupies eight bits e.g. the number 0 is coded as 00000000 the number 1 is coded as 00000001 and the number 255 is coded as 11111111. In 8 bit code therefore every piece of data has a value between 0 and 255 and every piece of data occupies 8 bits even if it could theoretically be represented by a single bit. If a program requires that any piece of data take on a value greater than 255 the bit rate for the program must be increased incrementally to 16 bit 24 bit etc. as appropriate.

A computer program operating in binary code may therefore use a tremendous amount of storage space and processor cycles particularly when graphics are involved. For example a photographic quality image is often coded at 24 bits for every pixel. If the image resolution is 2 million pixels as is common with today s digital cameras each image would occupy 48 million bits or 4 Megabytes where a byte is defined as 8 bits per byte due to the convention of expressing binary code in multiples of 8 bits . Manipulating that image would similarly require 48 million cycles of processor time for each manipulation. The amount of storage space and processing time increases exponentially when manipulating video because the computer system must process and store many such images every second. In addition there are many other computer applications that are at least as intensive as image processing. Applications of such intensity tend to slow considerably as data is bottlenecked in the computer system.

One way of minimizing the impact of the inefficiency of binary code has been to increase the amount of storage space and processing speed of computers. For example personal computers sold commercially today offer up to 300 gigabytes 300 billion bytes of hard drive storage 4 gigabytes 4 billion bytes of temporary memory storage and processing speeds of over 4 gigahertz 4 billion cycles per second . Business computers such those used in the motion picture industry are even faster and include more storage. In other words as computer applications have demanded more storage space and processing time the computers have become faster with higher storage capacity. Still while these numbers are impressive computer systems are not sufficiently fast as to eliminate all bottlenecks and in fact as computers become faster with more available storage new applications are developed to take advantage of the improved technology so as to provide the need for even faster computers even more storage space etc.

Another way of minimizing the impact of the inefficiency of binary code is to write computer programs and applications as efficiently as possible. Thus there is always an emphasis on writing computer code that achieves its outcome in as few steps or calculations as possible. Similarly a computer program should not be written in 24 bit code when only 8 bit code is required for the application and the computer program may compress data when appropriate.

A second drawback of using binary code to perform computerized tasks is that it is impractical to write a computer program in binary code particularly with complex programs. The first rudimentary computers for example were operated by mechanically toggling electrical switches between on and off states to enter a sequence of binary instructions. Computer programs simply specified the sequence of binary instructions to enter. This method was feasible so long as the program was no more than about a hundred instructions long. Beyond that point programming directly in binary code became too complex and programs too difficult to correct or debug. Moreover because the binary instructions were dependent upon the particular electrical circuitry of the computer processor and related hardware the programmer was required to know in detail the particular architecture of the computer being used by the program.

To accommodate computer programs of increasing complexity as well as to facilitate the introduction of personal computers into the marketplace modern operating systems were developed. Early computer operating systems such as Microsoft DOS essentially acted as an interface with a computer s hardware so that a user could issue specific commands or instructions to the computer written in more ordinary language. The operating system would recognize the commands and automatically issue the instructions to the computer in binary code. For example in Microsoft DOS entering the command MEM into the computer would result in the computer displaying the types and amounts of computer memory available. The person issuing the command did not need to know anything about binary code or the manner in which the command being entered produced the desired result. The user simply needed to either memorize or look up a set of commands in an instruction manual.

Further early operating systems recognized simple programming languages such as BASIC and FORTRAN written in terms more intuitive than binary code. In these languages commands such as WRITE READ LOOP SET and other intuitive terms provided a means to write computer programs in a manner easily learned and perhaps more importantly in a manner more easily readable when debugging the program. A simple computer program to calculate the area of a circle for example might have been written in BASIC approximately in this form 

In this example after a person typed RUN PROGRAM 1 the computer would execute the command lines in numerical sequence whereby a person would be prompted to enter the value for a radius defined as R after which the computer would square that value multiply the squared value by pi and print out the computed area. Writing this same program in binary code not only would have required much more time and effort on the part of the programmer but the programmer also would have had to know the technical specifications of the computer processor. Obviously the introduction of operating systems along with intuitive programming languages was a boon to both consumers and computer programmers.

A number of such operating systems and programming languages became prevalent. For example Apple Macintosh and Microsoft Windows operating systems improved from a consumer s perspective upon simple text based operating systems such as DOS by allowing user to issue instructions to the computer using a point and click graphical interface displayed on a computer monitor. Computer applications such as word processing programs computer games and a host of others took advantage of this functionality to provide products that could be used more intuitively through the graphical interface. Today a host of operating systems are used such as many versions of Microsoft Windows 9x Macintosh OS Linux Windows NT among others.

A wide variety of programming languages also became prevalent. At first most new programming languages followed the model of the early FORTRAN language by structuring the programming language as a series of commands by which a programmer would issue instructions to a computer in a logical order. The most popular of these language types is a program called C. The creation of C is considered by many to have marked the beginning of the modern age of computer languages. C successfully synthesized what had seemed to be conflicting attributes of several existing programming languages adding new attributes to form a single powerful structured language that also happened to be easy to learn. Moreover it was a programmer s language. Prior to the development of C computer languages were generally designed either as academic exercises by engineers or designed by bureaucratic committees. C however was developed by programmers reflecting the way they approached the task of programming. As a result C found wide and rapid acceptance in the programming community attracting many followers who had near religious zeal for it.

Once again however the increasing complexity of computer programs exposed an underlying flaw of C as well as its predecessors. Each of these programming languages requires that a program be written as a series of linear steps or instructions with an occasional loop or branch thrown in . In fact writing such a program is similar to constructing a geometric proof and like a proof once a program such as C or FORTRAN exceeds a certain number of steps somewhere between 25 000 and 100 000 lines of code the program becomes too complex write effectively.

Therefore a new approach to computer programming began to find acceptance in the programming community commonly referred to as object oriented programming. Object oriented programming approaches a programming task in roughly the same way that a person s mind might approach that task by abstracting a solution. Rather than defining a series of steps or instructions by which a task could be accomplished an object oriented program focuses first on a program s data defining classes of data and objects where an object is a particular instance of a class. An object oriented oriented program still contains instructions referred to as methods which often are embedded within the classes or objects themselves. An example of a simple object oriented program that displays the volume of two boxes might look like this 

In this example program a box class is first defined having the variables of width height and depth the term double identifies the type of number that the variable is allowed to be . The box class also defines a method to display the volume of an object box of this class by multiplying width by height by depth. Once this class has been defined the program defines a second class BoxDemo which includes two objects of the initial box class. The class BoxDemo then twice calls the method of the first box class for displaying the volume of a box once to display the volume of mybox 1 and once to display the volume of mybox2.

Object oriented programming has quickly gained widespread popularity. One particularly popular object oriented language is called Java which is the programming language used in the foregoing example Java is a trademark of Sun Microsystems Inc. . The reason Java has become so popular is its versatility in defining classes and objects as well as its ability for one class or object to call functions in other classes and objects as well as to reuse data in other objects simply by referencing the function or the data. In Java therefore it is very easy to create multiple variations of a defined class to create new variations of an old class and to reuse a method previously defined by one class in a new class. Parenthetically another object oriented programming language that has become popular is C which expands C to include the functionality of both object oriented programming and the instruction oriented programming of C.

Java like any other programming language relies upon an interface to convert the program to the required binary instructions. With Java this interface is called a Virtual Machine VM because the interface behaves as if it were a computer unto itself. Every time a Java based computer application is initiated the application initiates a VM to run the application. The Java VM will be described in much greater detail later in this specification but several important principles will be introduced now. First while the input to a Java VM is always the Java programming language the output of a Java VM is customized to the particular platform or operating system that hosts the Java VM. In other words every Java application must be customized to the host operating system so that the VM that it creates is capable of converting the Java programming language to the commands unique to the host operating system which in turn issues the appropriate binary instructions to the computer.

Second Java VMs are designed to be independent of one another. If two Java applications are running on the same computer each application creates its own VM which is self sufficient i.e. neither VM needs rely upon the VM of the other application. If one application should close the other application will not be affected. This often becomes problematical however. Recall that even with today s processors and storage devices a computer s resources may still be strained by intensive applications. With multiple Java applications running simultaneously each creating its own VM system resources may be strained and slowdowns may result. In other words there is often a trade off between the desired independence of multiple Java applications and the speed at which the applications may run.

Third the creators of the Java VM Sun Microsystems emphasized uniformity of the Java VM with respect to all of the host operating systems. Thus while the guts of each VM will of necessity be different across each platform a user of a Java VM was not intended to be able to recognize any difference seeing the same functionality regardless of the host platform. This however became problematical. Many operating systems offer unique features not available to other operating systems. Thus a business operating on Windows NT might desire to have a Java VM and hence the Java application running the VM take advantage of that unique functionality. The same would hold true for a user of a Macintosh or a Linux system or a Windows 9x system etc. Therefore although Sun Microsystems s Java VM is uniform across all platforms an industry has blossomed by which Java applications may be truly customized to a host operating system whereby the features of the host operating system are more fully exploited and custom tailored to the particular needs of the business or person running the application.

This diversity among Java VMs tends to hinder the improvement of the Java VM and the programming language because many such improvements are tied to the particular species of Java VM upon which the improvement was developed. Many businesses may like the particular improvement but dislike other aspects of the Java VM. In that instance a business with its own custom or proprietary VM would have the options of buying the new VM with its perceived advantages and faults or spend the time and resources to engineer its own VM which it likes to include the new improvement. Exacerbating this problem is that the new improvement may be proprietary thus eliminating the second option.

What is desired then is an improved system for implementing object oriented computer applications that both efficiently allocates computer hardware resources among multiple computer applications running simultaneously on the same computer or network of computers or among multiple threads of a single computer application running on a computer or network of computers while also preserving the independence of multiple simultaneous applications. What is further desired is such an improved system that is sufficiently flexible so as to be compatible not only with the diverse range of existing object oriented computer applications but also with object oriented applications that are developed or modified in the future.

The foregoing and other objectives features and advantages of the invention will be more readily understood upon consideration of the following detailed description of the invention taken in conjunction with the accompanying drawings.

Specifically the class loader may comprise a system class loader and one or more user defined class loaders. The system class loader is a part of the Java VM implementation and loads classes including the Java application programming interface API class files in some default way and usually from the local disk of the host computer. As previously stated the particular default manner in which the system class loader loads classes is specific to the particular VM implementation being used and may be customized. The term system class loader is sometimes referred to as a primordial class loader a bootstrap class loader or a default class loader. 

At run time a Java application may also load application class files in custom ways through user defined class loaders such as by downloading class files across a network. While the system class loader is an intrinsic part of the VM implementation the user defined class loaders are not. Instead user defined class loaders are written in Java compiled to class files loaded into the virtual machine and instantiated just like any other object becoming a part of the executable code of a running Java application. User defined class loaders enable a programmer to dynamically extend a Java application at run time. As the application runs it can determine what extra classes are needed and load them through one or more user defined class loaders. Because the user defined class loaders are written in Java classes can be loaded in any manner expressible in the Java programming language.

For each class loaded by the virtual machine the virtual machine records which class loader loaded the class. When a loaded class refers to another class the virtual machine requests the referenced class from the same class loader that originally loaded the referencing class. For example if the virtual machine loads the class Volcano through a particular class loader it will attempt to load any classes to which Volcano referred with the same class loader. In this way Java s architecture enables a programmer to create multiple name spaces inside a single Java application. Each class loader in the executing Java application has its own name space which is populated by the names of all the classes it has loaded.

The execution engine executes instructions contained in the methods of loaded classes in bytecode essentially Java s machine language. The Java specification describes what is to result from a given instruction retrieved from a Java method but a programmer of a Java application determines the best way of achieving the result using software hardware or a combination of both. The execution engine is an abstraction Java is a programming language capable of simultaneously running multiple threads i.e. distinct paths of execution hence the execution of each thread can be considered an instance of the abstract execution engine . Thus at any given time there may be multiple instances of the execution engine .

The execution engine receives a bytecode stream of instructions in a thread and executes the thread one instruction at a time. The execution engine executes the actions requested by each thread and whenever intended by the Java application sends instructions to the operating system in the code that the operating system recognizes. From time to time the execution engine might encounter an instruction that requests a method written in some other language than Java referred to as a native method. On such occasions the execution engine will attempt to invoke that native method by accessing native method libraries through a native method interface shown in . When the native method returns the execution engine will continue executing the next instruction in the bytecode stream.

When the Java virtual machine runs an application it needs memory to store many items including information it extracts from class files objects that the program instantiates parameters to methods return values local variables and intermediate results of computations. The Java VM organizes the memory it needs to execute a program into several runtime data areas depicted in . These runtime areas may include a method area a heap one or more Java stacks one or more program counter PC registers and one or more native method stacks . Although the same runtime data areas exist in some form in every Java VM implementation the structural details of these areas are left to the designers of the VM and may therefore vary considerably from one Java application to another.

Each instance of a Java VM has one method area and one heap . These areas are shared by all threads running inside the VM . As each thread comes into existence it receives its own PC register and Java stack . When the VM runs a method contained in a thread several things happen. First the value of the PC register is used to tell the next instruction in the method s sequence to execute. Second the thread s java stack stores the state of each executing Java method in a stack frame which includes the thread s local variables the parameters with which it was invoked its return value if any and intermediate calculations. When the VM has invoked a method in a thread and that method subsequently completes the VM discards the stack frame for that method from the Java stack . The state of native method invocations is stored in the native method stack in a manner dictated by the designer of the Java VM .

Information about loaded data types are parsed from class files as they are loaded and stored in the method area . A data type refers to the format in which the data is expressed e.g. an integer a float etc. A data type could also be an address of an op code within a method or a reference to an object on the heap . The VM uses the type information stored in the method area as it executes the application it is running.

For each data type the VM loads it should store the following kinds of information in the method area 1 the fully qualified name of the type 2 the fully qualified name of the type s superclass 3 whether or not the type is a class or an interface 4 the type s modifiers 5 an ordered list of the fully qualified names of any direct superinterfaces 6 the constant pool for the type 7 field information 8 method information 9 all class variables declared in the type except constants 10 a reference to class CLASSLOADER and 11 a reference to class CLASS. Each of these kinds of information is well known to those in the art who design Java virtual machines and program in Java.

Referring to whenever an object is created by a Java application memory for the new object is stored in the heap . Because there is only one heap inside of any instance of a Java VM all threads share the heap and because each Java application runs inside its own Java VM there is a separate heap for every Java application running. In this manner one Java application cannot affect the objects in the heap of another application. Two different threads and of the same application however could affect each other s heap data i.e. the objects . For this reason synchronization of the access to objects of multiple threads must be planned.

The existing Java VM as illustrated in has several disadvantages. First it is inherently redundant. Referring to a single computer when running multiple Java applications or other applications that run in a VM must create a separate VM for each application. Each VM in turn generates its own method area heap PC register etc. using a good deal of the resources of the underlying computer. This is true even when each VM is running a separate instance of the same application where many of the objects created by the application will be identical. This is illustrated in where three computers and are running the same application through a server . In this instance many of the runtime data areas may be located on the server creating the same kind of redundancy as seen in .

The redundancy of existing VM systems translates to a loss in system speed for two reasons. First each VM must use its own resources i.e. time to load objects already loaded in other applications. Second the combined memory space of all VM applications often bottlenecks system resources. In many cases the speed at which an application or series of simultaneously running applications may operate defines the upper limit of a system s performance the number of trades processed web pages served or billing records updated per second. In other words the speed at which individually well tuned processes can operate determines how much value that system can provide on a second to second basis i.e. lost system speed means lost revenue.

The existing wisdom is that the redundancy and the associated loss of speed that results from designing every VM application to run in its own isolated VM is a small price in exchange for the assurance that one application cannot change or otherwise corrupt the data being used by another application. In addition the isolation of applications each within its separate VM ensures that if one application should close or suddenly crash the other applications would remain unaffected. The present inventors though came to the realization that there are a variety of applications in which the sharing of data across applications might actually be beneficial. In those instances the redundancy of the existing system for running VM applications and the associated loss of system speed would be needless.

With this in mind shows an improved system for running VM applications which broadly stated may comprise a shared object space and a native access layer operably connectable with a plurality of application programming interfaces API of independent VMs or other applications such as the C C application . The access layer permits each application through its associated API to load objects into the shared object space where the objects may be read and or modified by the particular applications . Although in some instances the individual applications may duplicate some of the objects stored in the shared object space within its own respective heap or other memory area the shared object space permits an application to store an object in the shared object space instead of its own heap or other memory area thus avoiding the redundancy of existing VM systems. Access to the objects in the shared object space may be synchronized using the methods that presently exist for controlling access to shared objects in a heap by multiple concurrently running threads. Further the shared object space will store an object so long as a thread of any connected application is using the object . In this manner even if the application that placed a particular object in the shared object space closes or crashes that object will still be available to other applications as necessary. Thus the shared object space permits multiple applications running simultaneously on a system or network to enjoy the stability of existing VM systems while providing a substantial boost in performance.

The shared object space is accessible to an application through the native access layer . Thus a Java application or other object oriented application will recognize the shared object space as simply another native method accessible through the interface that already exists in Java and other object oriented applications. Once accessed all the functionality of the shared object space will be instantly accessible to the connected application. Further the shared object space does not need to be tied to a particular VM but instead is backwards compatible with any individual VM whether it is a standard Java VM provided by Sun Microsystems or a customized VM of a particular business and forwards compatible with any VM including improvements that have yet to be developed. Thus the versatility of the shared object space can not be overstated. The versatility of the shared object space is furthered by its compatibility with a wide variety of application interfaces. As can be seen in the native access layer provides access to the shared object space by both Java applications and C or C applications. It should be understood that these examples are illustrative only and that the native access layer could provide access to the shared object space by a number of other application types whether object oriented like Java or command oriented like C or C .

The advantages of the shared object space are readily apparent particularly with respect to applications that benefit from the ability of multiple simultaneously running applications to update a shared object rather than simply read or copy a shared object. One such application might be online trading. As the popularity of online trading increases trading exchanges are faced with ever growing volumes of market data and concurrent trader activity. Systems that were built to handle moderate volumes now have to handle thousands of traders and billions of dollars in daily transactions. Such systems have to accommodate huge spikes in demand. For instance a single trade may require thousands of traders to be notified. Many traders watch for these price changes then jump in to sell or buy very quickly causing even more notification demand and more trading volume. The faster a trading system reacts to changes the more transactions an exchange can execute increasing its commissions while maximizing trader satisfaction with the service.

Another example of the utility of the shared object space might be its potential in improving speed of computerized activity in the telecommunications industry. Modem telecommunication networks have to process vast amounts of data very quickly. Every time a call is placed for example an application needs to access the customer s subscription information apply any special discounts that may be applicable monitor the call duration and establish a rate based on the time and distance to the terminating number. Given that the number of such calls can run into the thousands at any given moment a memory based data sharing facility is a necessity. In the past such telecommunications applications have been written from scratch in C at enormous expense. The availability of an off the shelf shared memory component that provides a shared object space makes it possible to write such systems in Java or another object oriented program more quickly cheaply and with less risk.

Yet another example of the utility of the shared object space is its potential use in large scale internet applications. Large internet content syndication and portal applications depend on fast caching for scalability. The shared object space provides an ideal caching facility for HTML and XML fragments XML DOMs and streams HTTP session information and JDBC query results. It can also hold very fast page request queues and other operational data structures. The shared object space may include multi language support which may be exploited when connected to web servers servlet engines content management suites and XML transcoders to speed up every phase of a sites operation.

In use the shared object space may be one element in a larger computing system . Specifically it is anticipated that the shared object space along with its associated native access layer may be used in conjunction with a console an administrative processor disk storage and a display suitable for displaying system statistics. The console is used to configure and start the system which may comprise a system manager the shared object space and the native access layer . The system manager creates and initializes the shared object space collects garbage gathers statistics and logs both system and user defined events. Once the system has been started the system manager can also be used to browse the shared object space enable statistics collection from individual objects and display the statistics graphically for analysis.

The system is preferably stored on a disk in a default directory e.g. defaultSystem that holds the system s configuration file and log file. The system may be included on an executable storage media such as a compact disk that include an installation tool that may be used to create the requisite directories on the disk . Additional custom system directories may also be installed on the same disk as desired. Preferably the system includes a number of default tools that operate on the default system however the console and a command line utility may allow the user to specify a different system.

To make use of the system and its shared object space the system includes a library file in the default directory. Java applications should include a reference to this library e.g. productdir lib gemfirejar on its CLASSPATH. On Windows systems the library may be made available by adding productDir bin to PATH and on Solaris the library can be made available by adding productDir lib to LD LIBRARY PATH. An application process connects to the system by making a call that contacts the system manager such as

Each system preferably maintains a global name space in the shared object space . The name space provides a fast object registry in which applications can register and look up root objects by name. Objects that are referenced from this name space are protected from garbage collection. Once connected to the system an application can look up shared objects in the name space with a command such as

A shared object like myStock always represents a current shared value that is all threads in all VMs always see the same field values just as all threads in a single VM see the same volatile field values for an object in that VM.

The system may include a Class Enhance tool that prepares an application class for sharing by modifying the class s bytecodes to provide transparent instantiation in shared memory and automatic read through and write through for field access methods. By default all fields may be shared but a user may establish more selective policies by providing an XML description of the fields to be shared in each domain class. Once a class in enhanced making an object of that class automatically puts the object into shared memory.

Referring to the system may support two methods of sharing objects copy sharing and direct sharing. An object that is copy shared is allocated twice once in the local memory of an application and again in shared memory . shows an example of a copy sharing method where application A creates an object in its local address space. The object is shared by putting it into the shared name space . At this point the object is not immediately written to a field in the shared object space instead the object is written to shared memory only after a user flushes i.e. updates the object to a new version for the first time. Once an object is written to shared memory application B is able to copy the object to its local memory by accessing the shared object by name in the shared name space . Application B may modify the copy of the object obtained from shared memory but may not update the shared version of the object . If application B wishes to see the most recently updated version of the object a refresh command may be used.

Oftentimes it is desirable to monitor an object space i.e. monitoring the state of a memory space objects in that space or methods that use objects in that space for statistical and other purposes. Two existing methods of monitoring an object space are typically employed. First applications are programmed to periodically generate messages concerning the state of the objects they create and these messages are then logged so that statistical data can be gathered relating to the use of those objects. This particular method adversely impacts performance however and takes up a large amount of disk and or memory space hence this method is typically used only for monitoring events that do not lend themselves to numeric representation. Alternatively existing operating systems compile statistics used for monitoring an object space. These statistics however are chosen by the vendor of the operating system and cannot be easily customized.

In contrast to these existing methods of monitoring an object space the disclosed shared object space may be conveniently monitored using a minimal amount of system resources and may be easily customized to suit the needs of a particular user. Referring to the disclosed system may include a console having a display and an interface such as the alphanumeric keyboard and optionally a mouse . The console may be operationally interconnected with an administrative processor and disk storage . The console in conjunction with the administrative processor may be defined as an administrative system and used to monitor a shared object space by gathering statistics and providing access to the system and a user defined event log as well as monitoring shared object allocation rates VM connections lock acquisitions shared queue sizes and so on. The administrative system may also be used to configure and initialize the shared object space and permits an administrative user to dynamically discover which particular applications are utilizing the shared object space such as the applications and as well as to monitor system health throughput and other custom statistics enabled by the application data. The administrative system also may provide automated alerts for serious problems so that the console can be used to take corrective action.

The shared object space may be associated with a distributed group management system having a distributed cache. In that instance the administrative system preferably uses administrative interfaces in the distributed group management system of the shared object space to become an adjunct member of the cache. This allows the administrative system to make requests in cache nodes such as gathering a snapshot of current contents of a distributed cache region taking corrective action on a deadlock alert gathering statistics for graphing or requesting log file contents for display.

The administrative system preferably monitors the shared object space so that any data or object such as or in the shared object space can be registered with the administrative system for statistical monitoring and periodic backup to a compressed file on the disk storage . Preferably the administrative system takes a snapshot of all registered statistical data once every second and transfers that statistical data to the disk storage where it can be analyzed later even after the shared object space no longer exists. A selected subset of the snapshot can also be simultaneously analyzed visually on the display . Alternatively the frequency of the monitoring system may be adjustable so that a user can cause the administrative system to record statistical data more or less frequently than once per second.

The administrative system preferably provides a framework for gathering application defined statistics. For example an application could identify any numeric field in a shared object class as a statistical field. The administrative system may then immediately sample the field at designated intervals log the results and make the numbers available in a graphical tool on the display . For example if object shown in as object R tracks the number of matches performed by a trading system matching engine that object might be registered with the statistics service with the command GemFireConnectionFactory.getinstance .setStatisticsArchived tradi ngStats after which the administrative system will thereafter automatically record the state of trading stats for statistical review at a later time. The aforementioned registration command is of course merely an example of one particular command that could be used and will vary from system to system depending on many factors including the programming language used the name of the shared object space system etc.

In operation the applications and as well as any other applications including the administrative system connected to the shared object space may insert references to existing shared objects to be monitored into the monitored object space such as the objects and . The objects and are preferably simply references to shared objects but in other embodiments may duplicate a shared object such as or or may be a specific field in any of the shared objects in the shared object space or alternatively may be customized to be data or fields of data that pertains in any way to the state of any shared object in the shared object space . An application may register an object to be monitored in the monitored object space in any desired manner such as by making a single call with the object to be monitored as the only argument inserting the registered monitored object such as or into the monitored object space . The size or capacity of the monitored object space may be any desired portion of the shared object space and may be variable so as to expand or contract as necessary.

The monitors and each record the state of the data in the monitored object space at a desired frequency. Preferably the system has a default frequency such as once per second which may be adjusted by a user or an application as necessary. The monitors and when directed by the administrative system may store recorded snapshots of the data to storage local to the administrative system for graphical display and analysis in the manner previously described.

As can be easily seen in reference to the disclosed system for monitoring objects in a shared object space is highly flexible in that any application using the shared object space or an administrative user has the ability to define data that may be monitored or statistics to be compiled. This represents a tremendous advantage over existing systems such as existing operating systems whereby the vendor of the operating system defined the set of statistics gathered which could then either not be modified or only modified after a great deal of effort.

The terms and expressions which have been employed in the foregoing specification are used therein as terms of description and not of limitation and there is no intention in the use of such terms and expressions of excluding equivalents of the features shown and described or portions thereof it being recognized that the scope of the invention is defined and limited only by the claims which follow.

