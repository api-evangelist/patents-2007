---

title: Extensibility application programming interface and framework for meta-model objects
abstract: The present invention relates to a system and methodology providing an Application Programming Interface (API) and framework that supports a meta-object model for application design and operating system interactions. The API includes an input component that receives data and/or instructions. The input component processes a meta-data model that interrelates data via a class hierarchy, wherein the class hierarchy includes relationship descriptions between class objects, attributes, rules, and/or behavioral descriptions. Another aspect includes a data management system that includes a component to receive an item having meta-data annotations. An analysis component determines at runtime a structure for the item via deployment of the meta-data annotations. The system can also include a framework component that defines meta-data class derivations, meta-data classes, meta-data integrity rules, and/or meta-data class behavior.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07979842&OS=07979842&RS=07979842
owner: Microsoft Corporation
number: 07979842
owner_city: Redmond
owner_country: US
publication_date: 20071105
---
This application is a Continuation of U.S. patent application Ser. No. 10 666 977 filed on Sep. 18 2003 entitled EXTENSIBILITY APPLICATION PROGRAMMING INTERFACE AND FRAMEWORK FOR META MODEL the entire contents of which are herein incorporated by reference.

The present invention relates generally to computer systems and more particularly to a system and method that facilitates application development via a meta model object and framework supporting meta classes meta attributes meta relationships rules and behavior.

Modern operating systems are required to support many diverse applications having complex interrelationships with the system. Such applications include word processors spreadsheets development tools communications applications graphical applications and processing applications to name but a few examples. One innovation for implementing such applications has been through employment of object oriented programming techniques. Object oriented programming shifts the emphasis of software development away from function decomposition and towards the recognition of units of software called objects which encapsulate both data and functions. Object Oriented Programming OOP objects are software entities comprising data structures and operations on data. Together these elements enable objects to model virtually any real world entity in terms of its characteristics represented by its data elements and its behavior represented by its data manipulation functions. In this way objects can model concrete things like people and computers and they can model abstract concepts like numbers or geometrical concepts. For example an object oriented computer scientist would be mostly concerned with an application under design and secondarily with the tools used to develop it whereas a non object oriented scientist would think primarily of his or her tools.

The benefit of object technology arises out of three basic principles encapsulation polymorphism and inheritance. Objects hide or encapsulate the internal structure of their data and the algorithms by which their functions work. Instead of exposing these implementation details objects present interfaces that represent their abstractions cleanly with no extraneous information. Polymorphism takes encapsulation one step further the idea being many shapes one interface. A software component can make a request of another component without knowing exactly what that component is. The component that receives the request interprets it and figures out according to its variables and data how to execute the request. The third principle is inheritance which allows developers to reuse pre existing design and code. This capability allows developers to avoid creating software from scratch. Rather through inheritance developers derive subclasses that inherit behaviors which the developer then customizes to meet particular needs.

In particular an object includes and is characterized by a set of data e.g. image data and a set of operations e.g. methods that can operate on the data. Generally an object s data is ideally changed only through the operation of the object s methods. Methods in an object are invoked by passing a message to the object e.g. message passing . The message specifies a method name and an argument list. When the object receives the message code associated with the named method is executed with the formal parameters of the method bound to the corresponding values in the argument list. Methods and message passing in OOP are analogous to procedures and procedure calls in procedure oriented software environments.

However while procedures operate to modify and return passed parameters methods operate to modify the internal state of the associated objects by modifying the data contained therein . The combination of data and methods in objects is called encapsulation. Encapsulation provides for the state of an object to only be changed by well defined methods associated with the object. When the behavior of an object is confined to such well defined locations and interfaces changes e.g. code modifications in the object will have minimal impact on the other objects and elements in the system.

Each object is an instance of some class. A class includes a set of data attributes plus a set of allowable operations e.g. methods on the data attributes. As mentioned above OOP supports inheritance a class called a subclass may be derived from another class called a base class parent class etc. where the subclass inherits the data attributes and methods of the base class. The subclass may specialize the base class by adding code which overrides the data and or methods of the base class or which adds new data attributes and methods. Thus inheritance represents a mechanism by which abstractions are made increasingly concrete as subclasses are created for greater levels of specialization.

Although object oriented programming techniques are still widely employed newer systems and applications have evolved. One such system includes a managed object system whereby the operating system itself is involved in the determination and management of the lifetime of an object e.g. automatically reclaiming an object from system memory via a garbage collector versus internal reference counting on the object . These systems also support different types of data such as meta data for example that provide data and corresponding descriptions for such data. When newer applications are developed for these type data structures and systems however object oriented models are at a minimum are problematic. For example such models may require application designers to maintain and manage operating system states and events in order to successfully implement an application. Thus with traditional approaches even simple changes to an application document or item can require very complex code to maintain internal document structure and to support corresponding changes.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

The present invention relates to systems and methods that facilitate application development by providing an Application Programming Interface API and framework supporting meta data manipulations and interactions. A meta model object is provided that supports a higher level abstraction for data classes operating in context of meta data than is provided by conventional object models. This abstraction includes a description for the types of classes that may be involved during application development deployment and execution. These descriptions also enable developers to describe attributes relationships and respective constraints for meta data that simplifies program development and operating system interactions.

In one aspect the API is provided as an extensibility framework that reduces the effort required to build and maintain applications e.g. software modeling tools . Users of the API can create assemblies that contain annotated classes that derive from classes defined by the associated framework. The framework reads meta data from respective component assemblies to determine at runtime the structure of an item such as a document for example. Thus users of the API may extend the structure of a base item or document with new meta classes meta attributes meta relationships integrity rules and behavior for example. Also the API supports base level functionality such as undo redo transactions and lightweight events thereby relieving developers from coding and managing such tasks.

As noted above the present invention defines and supports meta model objects to facilitate efficient application development and mitigate complexities associated with operating system interactions. Such models can include meta classes that are abstract entities that make up an item e.g. relational table . These classes correspond in general to classes in an object model. Thus meta classes may inherit from other meta classes. Other aspects of the model include meta attributes that are values associated with the meta class e.g. the name of a table and generally correspond to the fields of a class. Meta relationships which are also part of the model include descriptions of relationships that may exist between various model classes e.g. associating a relational table column with a bounded default for the column .

Another aspect of the present invention in conjunction with the API is to provide a set of basic services that are required to implement software design tools and editors for items such as documents having complex structure. Such items can be managed within components such as stores and sub stores. These basic services support for example 

The API enables developers to manipulate complex documents in a straightforward and natural manner. In contrast with traditional approaches even simple changes to a document can require very complex code to maintain internal document structure and suitably handle undo redo functionality for example. A typical use of the API is to create a set of interrelated classes that inherit from base classes in a core meta model. These classes are then able to leverage the base classes for services such as state management. Typically class implementers wrap calls to a lower level API with properties and events that call lower level APIs. Thus a broad range of high quality design tools for developers can be supported. The extensibility API significantly reduces the cost of development and increases the quality of design tools that are constructed therewith.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced all of which are intended to be covered by the present invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The present invention relates to a system and methodology providing an Application Programming Interface API and framework that supports a meta model object for application design and operating system interactions. In one aspect of the present invention an API is provided having an input component that receives data and or instructions. The input component processes a meta data model that interrelates data via a class hierarchy wherein the class hierarchy includes relationship descriptions between class objects attributes rules and or behavioral descriptions. Another aspect includes a data management system or engine that includes a component to receive an item having meta data annotations. An analysis component determines at runtime a structure for the item via deployment of the meta data annotations. The system can also include a framework component that defines meta data class derivations meta data classes meta data integrity rules and or meta data class behavior.

As used in this application the terms component framework assembly application system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Referring initially to a system illustrates an application programming interface and framework for processing meta model objects in accordance with an aspect of the present invention. The system includes an Application Programming Interface API and associated services that operate in conjunction with an operating system framework . The API enables one or more applications to utilize base functionality of the operating system framework while mitigating management and design of complex code to interact with the system. For example applications often need to be aware of system level states and events that may impact operation of the applications. The API relieves the applications from processing such states and events by providing functionality services and interfaces that can be called by the applications in lieu of designing and managing code for such services. In one specific example applications often need to undo and or redo a previous action such as when a user attempts to undo a graphics or text action in a document e.g. undo is often implemented as a control z action in the application . The API enables the application to call basic interfaces that support process such actions without causing any given application to replicate and manage code. As can be appreciated a plurality of such functionality can be provided by the API as will be described in more detail below.

In general the API provides an extension to the framework that reduces the effort required to build and maintain applications such as software modeling tools editor tools design tools graphics tools word processors and so forth. Users of the API can create one or more assemblies that contain annotated classes that derive from classes defined by the associated framework . The framework reads meta data from respective component assemblies to determine at runtime the structure of an item such as a document for example. Consequently users of the API may extend the structure of a base item or document with new meta classes meta attributes meta relationships integrity rules and behavior for example. Also the API supports base level functionality such as undo redo operations basic file operations other transactions and lightweight events thereby relieving developers from coding and managing such tasks.

The system defines and supports meta model objects to facilitate efficient application development and mitigate complexities associated with operating system interactions. Such models can include meta classes that are abstract entities that make up an item such as a relational table or other item component. These classes correspond in general to classes in an object model. Thus meta classes may inherit from other meta classes and or from base functionality provided by the framework . Other aspects of the model include meta attributes that are values associated with the meta class e.g. the name of a table and generally correspond to the fields of a class. Meta relationships which are also part of the model include descriptions of relationships that may exist between various model classes and are described in more detail below with other properties and behaviors illustrated at .

Before proceeding it is noted that the following discussion includes example code implementations. These implementations may employ such example coding aspects as utilizing C code or SQL statements. It is to be appreciated however that the meta model objects framework and associated API functionality can be applied to substantially any type of code mechanism e.g. X Pearl Ruby Python other dynamic languages and so forth component and or system that is operative with meta data and or managed operating systems.

The following discussion describes various aspects of meta model objects in accordance with the present invention. Meta data is data describing the structure of classes and relationships between the classes. Meta data can be logically decomposed into several types of meta data including meta models information about models such as a Relational Model or a Process Model meta classes information about classes and meta relationships relationships between meta classes . While each type of meta data generally has specialized information content some information content is shared between meta data classes. Typically all classes storing model meta data need to be uniquely identified. Globally Unique Identifiers GUIDs are guaranteed to be globally unique so they are a good choice for a unique identifier.

GUIDs are often difficult for humans to remember associate with a particular idea or even type without error. Because of this the system can attach non unique not guaranteed unique textual labels to meta data classes. These labels are sometimes referred to as Names. Meta data classes identities can be exposed in a user interface UI especially in property pages as the class of the model elements. Names are generally not appropriate here because they tend to be developer centric and they are not localized. In lieu of the Name property a localized friendly tag can be employed which is called a Caption. 

A meta model is type of meta data describing a model s structure. Examples of models include a UML model and an SQL Server Schema model. The model s structure is composed of the meta classes and meta relationships of the model. Each meta model can be associated with a partition of a database e.g. SQL server database which is called a schema.

The meta class is a class encapsulating data employed to represent another class. For example the meta class for a relational database table class may have operations to describe the type of the table class the column structure of the table and so forth. The classes that meta classes describe may have inheritance relationships with other classes. Attributes of the meta class are contained in an ordered set of meta attributes. As noted above meta classes may have relationships with other meta classes. For example relational tables have a relationship with relational table columns which may be named TableColumn for example.

The meta attributes are the attributes of the meta class . For example the meta attributes for a relational table column might include data type length and default value for example. Meta classes can be represented as a table in a Working Store described below and the meta attributes associated with the meta class are represented as the columns of that table. Meta relationships include various types of relationships between various model classes. For example relational tables contain relational table columns and relational table columns may be associated with a bound default. The descriptions of these relationships are contained in meta relationships . One example way to capture relationship data in a database is to use a join table which allows various cardinality combinations to be modeled uniformly. The meta classes that are participating in the relationship are said to play a role in the relationship. The information about these roles is called a meta role. Each meta relationship typically contains an ordered set of meta roles.

Meta roles are data about the participation of meta classes in a meta relationship. Meta roles have a reference to the meta class playing the role. This is used to determine which meta class instances can be allowed to participate in a particular meta relationship instance. Meta roles may be optional in a relationship. This information is used when validating a meta class instance a meta class instance is generally invalid if it is required to participate in a relationship with another meta class instance but no such instance is defined. Meta class instances may be logically composed of other meta class instances. For example relational table instances may contain be composed of its columns. Meta roles have an associated cardinality which is the maximum number of meta class instances that may play the role in a given meta relationship instance. This cardinality may be one or many. This information is used to determine whether a single meta relationship instance reference or an array of meta relationship instances is to store relationship instance data for a particular meta class instance.

Referring now to a model store also referred to as store is illustrated in accordance with an aspect of the present invention. Model data is typically stored in a directed acyclic graph DAG structure. This allows for the existence of a well known root from which model data may be located by traversing the DAG. The top level nodes in this DAG are called Stores . Stores contain data and meta data for a particular application e.g. Visual Studio Solution . More than one Store may exist in the application at a time. Store objects are contained in a static array of Stores contained by the Store class. This allows the Store class to act as the well known root of the model data DAG. Associated with the Store is optionally a database catalog which can be unambiguously specified by indicating a server catalog pair.

The following discussion describes the store and associated components in more detail. Working Store Proxies encapsulate a physical database that contains a Working Store. When a Working Store Proxy connects to a Working Store instance it should check to make sure that the versions of the schema in the Working Store match current versions. If the versions in the Working Store are more recent than those known by the Proxy an exception should be raised and no further interaction should be possible with the database. If the versions in the Working Store are out of date the Proxy should create a new database catalog and invoke methods on the Substores to migrate the model data to the new database. After the migration the Proxy will use the new database as the Working Store for the model.

Substores contain meta data for a particular meta model. When a database is loaded that contains a model the system or framework generally checks the version status of the model. There are at least four possible results current updateable transformable and non transformable. A current model is a database that contains a Working Store where each schema in the database has the same version that the C code or other type is designed to work with. An updateable model is a model where one or more schemas have a previous version stamp but there are no schema changes required the schemas can be brought up to date by simply changing the version stamps. A transformable model is a model that contains one or more schemas that have a previous version stamp and require a schema change to be brought up to date. A non transformable model is a database that either contains a future version of a meta model or one that does not contain a meta model at all.

The models described above may be much larger than the physical memory. This necessitates the use of a database management system to hold working data models. Information stored in databases is difficult to manipulate directly thus a scheme can be adopted where the database is hidden from the modeling classes and load a subset of the model into memory for manipulation using code in a natural manner. The amount of model data that can be in memory at any time is generally limited to a specific size based on the size of physical memory the size of code the size of the system software and other factors. The Model Data Cache Manager has the responsibility to determine which data needs to be in memory at any given time and loading or unloading data to match those needs.

The Element Class Factory is responsible for managing the lifetimes of Elements. The Element Class Factory provides methods to create new Elements load existing Elements from the Working Store and remove Elements from the Working Store. The first category of functionality is creating new Elements. New Elements can be created by specifying the C Type class of the Element or by specifying the meta class for the new Element. New Relationships can be created by specifying the C Type or the meta relationship to be instantiated along with a list of role players. When a new Element is created the Element Class Factory inserts default data rows into the appropriate tables in the working store creates an Attribute Bag for the Element e.g. memory location that selectively exposes data members creates the Element passing the Attribute Bag to the constructor and returns the new Element to the caller.

When a new Relationship is created the Element Class Factory inserts data rows into the appropriate relationship tables. The role player data can be set in the Working Store at this time. The Element Class Factory then creates a Role Bag or location for the Relationship creates the Relationship passing the Role Bag to the constructor and returns the new Relationship to the caller.

The second category of functionality for the Element Class Factory is loading existing Elements. A subset of Elements to load can be specified 

The Transaction Manager is responsible for creating transaction objects and keeping track of open transactions and their transaction level. Creating a new transaction when there is already an open transaction creates a new nested transaction with the current most nested transaction as the parent. Client code determines whether the database connection has any open transactions and the current transaction depth. A depth of zero indicates that there are no open transactions. Client code will likely need access to the current inner most transaction so the Transaction Manager should provide a way to access it.

Outermost transactions are used to track actions on the store for undo redo purposes. Transactions that are outermost need to have ID s and a localized string description e.g. delete class CSeamWelder useful for displaying in undo redo UI. As a convenience to client code the Transaction Manager provides a method to perform an arbitrary store operation in a transaction. The DoAsTransaction method creates a new transaction with a name specified by the caller and then calls an input delegate. If the delegate throws an exception the exception is caught the transaction rolled back and the exception is re thrown.

The Undo Manager is responsible for manipulating Undo Redo mechanisms in a Working Store. The Undo Manager provides methods to Undo the last action and Redo the last Undo. Multiple Redo s are supported so when an action is undone and Undo is called the previous action is undone ad infinitum.

In addition it is often helpful to allow user to undo multiple steps at once. The Undo Manager provides a method to undo all actions back to a specified transaction ID in a redo stack. Similarly the Undo Manager allows clients to redo undone actions up to a specified transaction ID in the redo stack. An associated user interface UI can display a list of transactions to be undone or redone. The Undo manager can provide this functionality. It is conceivable that the undo or redo stack might need to be truncated at some point. The Undo Manager provides methods to remove transaction ID s from bottom of the undo or redo stack to a particular transaction ID e.g. from the beginning to transaction 21199 .

Another aspect relating to the store involves transactions. A Transaction object encapsulates a store transaction. Transactions have an ID which is a GUID a Name and a Caption. A Name is a human readable string appropriate for use with the Undo Manager and for debugging purposes. A Caption is a localized version of the Name. Transactions may be nested. Nested transactions are named in order that an SQL Server can distinguish between nested transactions. The SQL Server transaction name will not be seen by users so the transaction name need not match the Transaction object name. Client code determines whether a particular Transaction object is outermost or if not outermost its transaction depth. An outermost Transaction has a transaction depth of one.

Transactions can be committed which makes the work done in the transaction durable. In the presence of nested transactions committing an outer transaction implicitly commits inner transactions. When a nested transaction is committed the SQL Server transaction name is specified so SQL Server knows what the client code is trying to commit. When a nested Transaction is committed its parent Transaction becomes the new innermost transaction. The Transaction Manager keeps track of the current innermost transaction so Transactions need to notify the Transaction when they are committed. Transactions also provide a way for the Transaction Manager to find their parent Transaction. Transactions may also be rolled back which abandons any changes made during the transaction. A Transaction is considered to be active until it is committed or rolled back. When the transaction has been committed or rolled back the transaction is inactive. It is an error to attempt to commit or roll back an inactive transaction.

Turning now to additional system components that can be employed with meta model objects are illustrated in accordance with an aspect of the present invention. These components can include elements events domains and or model schema . The Element is an instance of a meta class stored in a model. Element can also be super class of all model classes. Elements provide a mechanism for the classes derived from Element to access their attribute data. Attribute data is generally exposed to clients of Element objects as CLR properties or other type . Elements are generally identified by a GUID. This identifier is typically exposed publicly so that certain operations such as navigating relationships can be performed. Elements may also be removed from the model.

The Events are raised to keep various objects up to date with changes in the state of the system. For example object added events are raised to notify interested listeners when objects are added. The events generally contain two or more other objects the object raising the event and the event arguments. Composition of the event arguments varies with the type of the event but is intended to be enough information to meaningfully respond to the event. For example the event arguments for an object added event contain a reference to the object that was added.

Events can be raised at several levels. Store level events supply notifications of events that occur in a solution. Substore level events supply notifications for events that occur within a particular meta model. Meta class events provide notifications for instances of that meta class or derived meta class. Element events provide information on changes to an individual object.

Generally there are two broad categories of events Transactional and Atomic. Transactional events are events associated with a series of actions generally caused by the operation of a database transaction. Atomic events are events for a single action. Transactional events have both before and after variants. Before events are largely used to allow listeners to pre empt an action by throwing an exception. After events are mostly used to allow listeners to respond to a change. Transactional events include the following types 

The event arguments for transaction events contain a reference to the Transaction object associated with the event.

Atomic events are notifications that some occurrence has happened. Atomic events include the following types 

Event arguments for object added and object removed events contain a reference to the element that was added or removed. Event arguments for object changed events contain a reference to the changed element a reference to the meta attribute that was changed and the old and new values of the attribute.

The domain of an attribute is the definition of values that the attribute may take. For example the length of an nvarchar column in SQL Server is an integer between 1 and 4000 so the domain for a SQL Server Column Length attribute is integers between 1 and 4000. Each domain typically has a default value. This is employed to populate attribute values when more restrictive constructors are not used to create the model class. This also provides a cue to the user as to what reasonable values for the attribute might be for example the default length for nvarchar columns in a VS7 database designer is 50.

Domains used by models are subsets of integers unsigned integers datetimes or strings. While any value expressed as an integer unsigned integer or datetime would necessarily be a member of those respective Domains in practice Domains used by model classes will typically have a value restriction. Minimum value maximum value or both with be specified for Domains derived from these value types. Strings of course are unlikely to have value restrictions in the same way integers may but they can be restricted for string length and validation constraints may be applicable. For example legal SQL Server identifiers start with a letter underscore dollar sign or hash character and are less than 129 characters in length. Regular expressions may be used to define the constraint.

Another type of domain is an enumeration domain. Enumeration domains are analogous to C enums. Enumeration domains are defined as explicit sets of integers unsigned integers or strings. The base domain for an enumeration domain is the domain which underlies the values of the domain integers unsigned integers or strings. The base domain is used to determine what type of data should be used to store the value in the Working Store. String Enumeration Domains conceptually combine the features of Enumeration Domain and String Domain. The additional feature String Enumeration Domain supports is a method to get to the members of the domain. Restricted Length String Domain is a String Domain that restricts the lengths of strings in the domain.

The Model Schema is an object which creates and maintains the structure of a schema in the Working Store. The Model Schema creates the schema and the tables triggers constraints and so forth contained in the schema. There are two types of model updates that might need to occur. A trivial update is one that does not involve structure changes. In this case a version stamp is updated. A non trivial update is one that involves a schema migration. In this case a new database is created the new schema is created and the old data is migrated to the new database. During data migration from an old schema to a new schema it may be necessary to disable relational integrity RI constraints in the database. When the migration is achieved the RI constraints are then enabled. There is typically a Model Schema for each Substore.

Substores support the public method CopySubstore CreateDatabase SchemalsIdentical and EnsureValid with the signature 

An Element is a meta class instance object stored in a model. Elements are a specific instance of a meta class. Elements contain attributes which are defined by the corresponding meta attribute. Meta classes are organized into meta models. Typically element attributes will be exposed as C properties.

Elements support the public read only properties ID IsRemoved Store MetaClass and IsValid with the signature 

Relationships returns element links where the current element plays role. RolePlayers returns the elements that play targetRole where the current element plays sourceRole. Remove removes the element from the store. Copy copies the element from the store. EnsureValid attempts to correct corruption to the element to bring it into a valid state. EnsureValid raises an InvalidStore exception if it cannot make the element valid. GetObjectData is defined by ISerializable.

An ElementLink is a meta relationship instance tuple stored in the model . ElementLink inherits from Element . ElementLinks are a specific instance of a meta relationship MetaRelationship and contain roles which are defined by the corresponding meta role MetaRole . Typically element link roles will be exposed as C properties.

ElementLinks support the additional public read only properties MetaRelationship and Roles with the signature 

SetRolePlayer sets the role defined by metaRole e.g. Core.Element Ownership.OwnedElementMetaRole metaRoleId or ordinalPos to rolePlayer in the working store database . RolePlayer should be non null. Likewise GetRolePlayer returns the role player for the passed in parameter.

Initialize initializes the element link where Store is the store the element is part of id is the id of the element roles is the list of elements that play roles and assignments define the initial values of various attributes unspecified attributes will be initialized to their default values .

A MetaDataInfo holds the basic meta data for a meta data object. MetaDataInfo is an abstract class. The class MetaDataInfo supports public read only properties ID Name and Caption with the following signatures 

Respective meta objects defined in an assembly have a managed system e.g. Common Language Runtime attribute decorating them. That is along with some other MetaXXXX specified in the following sections one needs to also provide this attribute MetaObject . The constructor of this MetaObjectAttribute has the following signature.

Id is the guid in the form AE671BDC 41B2 44d5 832B BE0FEC502526 of this meta object. CaptionKey is the name key to the translated caption. This allows the system to provide translated strings to the client.

A MetaModelInfo holds the meta data for a meta model. MetaModelInfo inherits from MetaDataInfo. Meta model meta data is used for example to determine which database schema stores the meta model instance. There is typically a single read only instance per meta model. Meta model meta data supports public read only properties ID BaseMetaModel Name Caption MetaModels MetaClasses Substore and Schema with the following signatures 

A MetaModelAttribute declares the base models the associated meta model bases extends upon. Substores that have this attribute are treated as meta models by the store. Further classes descended from Element with a MetaClassAttribute and MetaObject in the same namespace are treated as meta classes of the meta model.

The MetaClassInfo holds the meta data for a meta class. MetaClassInfo inherits from MetaDataInfo. A meta class may have at most one parent meta class it inherits from. Meta classes are used for example to determine which database tables store the meta class. There is typically only a single read only instance per meta class.

A MetaClassAttribute declares the meta model owner for meta classes. Classes that derive from Element and have this attribute and MetaObject attribute are treated as meta classes by the store. Further properties with a MetaAttributeAttribute and MetaObject in the class are treated as meta attributes of the meta class.

A MetaAttributeInfo is the meta data for a meta attribute of a meta class. MetaAttributeInfo inherits from MetaDataInfo. Meta attributes are used for example to determine which database columns store the meta attribute. There is typically only a single read only instance per meta attribute.

Meta attributes support the public get properties ID MetaClass Domain Name Caption Property and Column with the signatures 

A MetaAttributeAttribute declares the meta attributes in meta class. Properties of meta classes that have this attribute and MetaObjectAttribute are treated as meta attributes by the store.

A MetaRelationshipInfo holds the meta data for a meta relationship. MetaRelationshipInfo inherits from MetaDataInfo. A meta relationship is a special type of meta class. Meta relationships are used for example to determine which database tables store the meta relationship. There is typically a single read only instance per meta relationship.

Meta relationships support the additional public read only property MetaRoles with the following signature 

A MetaRelationshipAttribute declares the meta model owner ID for meta relationships. Classes that derive from ElementLink and have this attribute and MetaObjectAttribtue are treated as meta relationships by the store. Further properties of the class with a MetaRoleAttribute and MetaObjectAttribute are treated as meta roles of the meta class.

A MetaRoleInfo holds the meta data for a meta role. MetaRoleInfo inherits from MetaDataInfo. A meta role is a role that a meta relationship plays with a meta class. Meta roles are used for example to determine which database columns store the meta role. There is typically a single read only instance per meta role. Meta roles support the additional public read only properties ID MetaRelationship RolePlayer Name Caption Property Column IsOptional IsAggregate IsNavigableFrom Cardinality PropagateRemove IsOrdered and PropertyCopyTargetPlayer with the following signatures 

ElementLink is automatically removed when the role player is removed. This flag allows the system to remove the opposite role players automatically. This is useful for parent child relationship. When parent model is removed child element is removed as part of the remove operation. IsOrdered indicates whether the role players play this meta role are ordered. PropertyCopyTargetPlayer indicates whether the target player should be copied when the source player is being copied. Again this is useful during a parent child relationship. When parent model element is copied the child element should automatically be copied as well.

A MetaRoleAttribute declares a meta role in the meta relationship. Properties of meta relationship that have this attribute are treated as meta roles by the store. Meta role attribute constructor does not have any parameters.

The class Domain supports the methods CreateEditor Contains and Caption with the following signatures 

An OrderedDomain is a domain that has a total ordering on it. OrderedDomain is an abstract class. Values in this domain support the IComparable interface.

A FiniteOrderedDomain is an ordered domain that is finite and thus bounded above and below . FiniteOrderedDomain is an abstract class. The class FiniteOrderedDomain supports public read only properties HasRestrictedMinimum HasRestrictedMaximum Minimum and Maximum with the following signatures 

Contains returns whether or not the value is in the domain i.e. Minimum.CompareTo value 0 . If HasContinuousRange is false then Contains will raise an assert and an InvalidOperationException exception since the implementation assumes a continuous range.

An IntegerDomain is a finite ordered domain that corresponds to a C int or other type . The class IntegerDomain supports public read only properties SqlType HasRestrictedMinimum HasRestrictedMaximum Minimum and Maximum with the following signatures 

The class IntegerDomain supports the public methods CreateEditor and Caption with the following signatures 

A DoubleDomain is a finite ordered domain that corresponds to a C double or other code type . The class DoubleDomain supports public read only properties SqlType HasRestrictedMinimum HasRestrictedMaximum Minimum and Maximum with the following signatures 

The class DoubleDomain supports the public methods CreateEditor and Caption with the following signatures 

A GuidDomain is a domain that corresponds to a C Guid or other code type . The class GuidDomain supports public read only property SqlType with the following signature 

A BooleanDomain is a domain that corresponds to a C bool or other code type . The class BooleanDomain supports the public read only property SqlType with the following signature 

An EnumerationDomain is a finite ordered domain that corresponds to a C Enum or other code type . The class EnumerationDomain supports public read only properties HasRestrictedMinimum HasRestrictedMaximum Minimum Maximum Enumeration and BaseDomain with the following signatures 

A DateTimeDomain is a finite ordered domain that corresponds to a C DateTime or other code type . The class DateTimeDomain supports public read only properties HasRestrictedMinimum HasRestrictedMaximum Minimum and Maximum with the following signatures 

A StringDomain is an ordered domain that corresponds to a C string or other code type . The class StringDomain supports public read only properties SqlType and MaxLength with the following signature 

Events are C events or other code type that raise as a result of changes to an element s state e.g. changed meta attribute values or the store s state e.g. an element being added or removed from the store . Events exist principally to keep the user interface up to date with changes in the store. Code to maintain data integrity should be implemented in the working store using standard database mechanisms such as triggers and referential actions. Events raise after the transaction they occur in completes. Even though multiple processes can modify a store events are generally guaranteed to arrive in a serialized order. If events fired immediately then listeners would not be guaranteed to receive events in the serialized order even if all transactions succeeded.

A meta attribute value change raises an ElementAttributeChanged event after the transaction completes. These events may be subscribed to on the store substore or the element. The events have the signatures 

Meta classes should implement change events for meta attributes even if the meta class has no direct meta attributes . These events should be able to be subscribed to on the meta class or the element. The implementation of these events is straightforward. An event should be exposed for the substore level event with an implementation such as 

where is the meta class and value is an event handler of type ElementAttributeChangedEventHandler. The store itself should propagate the event. Meta classes should implement change events for individual meta attributes. These events should be able to be subscribed to on the substore or the element. The implementation of these events is straightforward. An event should be exposed for the substore level event with an implementation such as 

where . MetaClass is the property giving s meta class . MetaAttribute is the property giving s meta attribute and value is an event handler of type ElementAttributeChangedEventHandler. The store itself should propagate the event. An event should be exposed for the element level event with an implementation such as 

where MetaAttribute is the property giving s meta attribute and value is an event handler of type ElementAttributeChangedEventHandler. The store itself should propagate the event.

A class ElementAttributeChangedEventArgs inherits from EventArgs and supports public get properties MetaAttribute MetaClass Element OldValue and NewValue with the signatures 

An element addition can raise an ElementAdded event after the transaction completes. These events may be subscribed to on the store or the substore. The events have the signatures 

Substores should implement added events for meta classes even if the meta class has no direct instances . These events should be able to be subscribed to on the substore. The implementation of these events is straightforward. An event should be exposed for the substore level event with an implementation such as 

where . MetaClass is the property giving s meta class and value is an event handler of type ElementAddedEventHandler. The store itself will propagate the event. Container meta classes should also support element added events for children at the element and substore level. This would allow for example subscription to all the elements added to a UML package.

The class ElementAddedEventArgs inherits from EventArgs and supports the public get properties MetaClass and Element with the signatures 

An element removal will raise an ElementRemoved event after the transaction completes. These events may be subscribed to on the store the substore or the element. After an element is removed from a store its state may be invalid thus it is an error to call non object methods and properties for any element in response to an ElementRemoved event. The exceptions are the ID Store and IsRemoved properties which may be called after the element has been removed. The event has the signature 

where the signatures are for a Store a Substore addition of meta class and an Element level event respectively.

Substores should implement removed events for meta classes even if the meta class has no direct instances . These events should be able to be subscribed to on the substore. The implementation of these events is straightforward. An event should be exposed for the meta class level event with an implementation such as 

where . MetaClass is the property giving s meta class and value is an event handler of type ElementRemovedEventHandler. The store itself will propagate the event. Container meta classes should also support element removed events for children at the element and meta class level. This would allow for example subscription to the elements removed from a UML package.

The class ElementRemovedEventArgs inherits from EventArgs and supports public get properties MetaClass and Element with the signatures 

A meta role player change will raise an RolePlayerChanged event after the transaction completes. These events may be subscribed to on the store substore or the element. The events have the signatures 

where the signatures are for a Store changes to role players ElementLink changes to all role players a Substore changes to role players of meta relationship a Substore changes to meta relationship s meta role s role player and an ElementLink changes to the meta role s role player level event respectively.

Meta classes should implement change events for the meta role even if the meta relationship has no direct meta roles . These events should be able to be subscribed to on the meta relationship or the element link. The implementation of these events is straightforward. An event should be exposed for the substore level event with an implementation such as 

where is the meta role and value is an event handler of type RolePlayerChangedEventHandler. The store itself will propagate the event. Meta classes should implement change events for individual meta roles. These events should be able to be subscribed to on the substore or the element link. The implementation of these events is straightforward. An event should be exposed for the substore level event with an implementation such as 

where . MetaClass is the property giving s meta class . MetaRole is the property giving s meta role and value is an event handler of type RolePlayerChangedEventHandler. The store itself will propagate the event. An event should be exposed for the element link level event with an implementation such as 

where MetaRole is the property giving s meta role and value is an event handler of type RolePlayerChangedEventHandler. The store itself will propagate the event.

A class RolePlayerChangedEventArgs inherits from EventArgs and supports the public get properties MetaRole MetaRelationship ElementLink OldRolePlayer and NewRolePlayer with the signatures 

A class TransactionBeginningEventArgs inherits from EventArgs and supports the public get property Transaction with the signatures 

Beginning a transaction should raise a TransactionBegun event. These events may be subscribed to on the store. The event has the signature 

A class TransactionBegunEventArgs inherits from EventArgs and supports public get property Transaction with the signatures 

A class TransactionCommittingEventArgs inherits from EventArgs and supports public get property Transaction with the signatures 

Committing a transaction should raise a TransactionCommitted event. These events may be subscribed to on the store. The event has the signature 

A class TransactionCommittedEventArgs inherits from EventArgs and supports the public get property Transaction with the signatures 

Rolling back a transaction should raise a TransactionRollingBack event. These events may be subscribed to on the store. The event has the signature 

A class TransactionRollingBackEventArgs inherits from EventArgs and supports public get property Transaction with the signatures 

Rolling back a transaction should raise a TransactionRolledBack event. These events may be subscribed to on the store. The event has the signature 

A class TransactionRolledBackEventArgs inherits from EventArgs and supports the public get property Transaction with the signatures 

A class ElementEventsBegunEventArgs inherits from EventArgs . After firing a series of element events an ElementEventsEnded event is raised. These events may be subscribed to on the store. The event has the signature 

A class ElementEventsEndedEventArgs inherits from EventArgs . The store supports the public methods AddElementAddedEvent 

AddElementAddedEventHandler registers handler to be called when an element of type metaClass is added to the store. RemoveElementAddedEventHandler unregisters handler to be called when an element of type metaClass is added to the store. AddElementAttributeChangedEventHandler registers handler to be called when an element of type metaClass has an attribute change value in the store. RemoveElementAttributeChangedEventHandler unregisters handler to be called when an element of type metaClass has an attribute change value in the store. AddElementAttributeChangedEventHandler registers handler to be called when an element of type metaClass has metaAttribute change value in the store. RemoveElementAttributeChangedEventHandler unregisters handler to be called when an element of type metaClass has metaAttribute change value in the store. AddElementRemovedEventHandler registers handler to be called when an element of type metaClass is removed from the store. RemoveElementRemovedEventHandler unregisters handler to be called when an element of type metaClass is removed from the store. AddRolePlayerChangedEventHandler registers handler to be called when an element link of type metaRelationship has a role player change in the store. RemoveRolePlayerChangedEventHandler unregisters handler to be called when an element link of type metaRelationship has a role player change value in the store. AddRolePlayerChangedEventHandler registers handler to be called when an element link of type metaRelationship has metaRole change value in the store. RemoveRolePlayerChangedEventHandler unregisters handler to be called when an element link of type metaRelationship has metaRole change value in the store.

The store supports public events ElementAdded ElementAttributeChanged ElementRemoved and RolePlayerChanged with the signatures 

Transactions are designed to allow a group of changes to a store to be made in an atomic and consistent way. Transactions may be nested. Completed transactions typically form a single undoable action. During a transaction the changes made so far can be rolled back i.e. undone . Persistent changes to the document are made through transactions.

In the second example the use of a try statement facilitates that the transaction is closed appropriately when the statement block completes normally or with an exception. Threads using a particular instance of a store and thus its SQL Server connection participate in the current transaction the last created transaction that is still open .

DoAsTransaction takes a delegate and executes it in a new serializable transaction. If the new transaction is an outermost transaction then a description of the transaction is given by the second parameter this description should be suitable for undo . If the delegate completes then the transaction is committed. If the delegate raises an exception then the transaction is rolled back and the exception re raised. BeginTransaction creates a new transaction. If the transaction is an outermost transaction then a description of the transaction is given by the parameter this description should be suitable for use in the undo user interface . The transaction will have an isolation level of serializable. UndoTransaction undoes the transaction with the ID id. RedoTransaction the transaction with the ID id. DeleteTransactionRecordsBefore discards transaction records before the transaction with the ID id.

The store supports the public get properties CurrentTransaction InTransaction and TransactionDepth with the signatures 

The class Transaction supports public get properties IsActive IsOutermost ID Name Caption and TransactionDepth with the signatures 

An example implementation of a substore Core containing a single meta class ModelElement is included in Appendix A.

The material contained in Appendix A which has been submitted withinin a compact disc as a file entitled Appendix A.txt created on May 3 2011 and having 11 kilobytes of data is incorporated herein by reference in its entirety.

Proceeding to one or more meta model objects are defined. Such objects include aspects such as meta classes meta relationships meta attributes and other facilities described above for controlling describing and interacting with meta data. At object relationships and behaviors are defined. As noted above meta classes for example can have a relationship described in meta data with other meta classes thus provide a higher level abstraction from ordinary object models. This also includes enabling meta classes to inherit properties from other meta classes which is also not provided by conventional object models. At one or more API s are provided to enable code to interact with an operating system framework. As noted above the API s mitigate any given code from redundant and or complex interactions with the system. At one or more assemblies are created that utilize the API s for system interactions. Such assemblies can be employed in conjunction with managed object systems for example e.g. .Net assemblies . At system properties are inherited via the meta model classes described above. In this manner system complexities such as writing complex code and managing system states events and or transactions can be mitigated since these can be provided by the underlying framework and associated API.

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 16 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 1102.3 Token Ring IEEE 1102.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the present invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly the present invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

