---

title: Error tracing with context history
abstract: Trace messages generated during execution of programming code are logged in a trace log. The logged trace messages logged during execution of a portion of the programming code are deleted from the trace log when the portion of programming code executes without an error. The logged trace messages are kept in the trace log when an error occurs during execution of the portion of the programming code. The trace log is output when the execution of the programming code ends.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07975262&OS=07975262&RS=07975262
owner: Microsoft Corporation
number: 07975262
owner_city: Redmond
owner_country: US
publication_date: 20070816
---
Most error tracing methods use different levels of tracing according to the level of detail needed. Computer code may include trace messages that are generated when the code is executed. The trace messages are usually put into a log file for later analysis and debugging by a user such as a software tester. In some cases the user may designate the level of tracing desired. For example the tracing level may extend from minimal logging i.e. logging of a small number of trace messages to verbose logging i.e. logging of numerous trace messages .

Usually the default tracing level is minimal. Once a log is generated a user analyzes the log by first looking for the time frame the error occurred. However if more logging information is needed than the minimal default logging provides then another run may be needed with an increased trace level in order to capture the necessary detailed logging to troubleshoot the error. But the error may not necessary reproduce during the re run. Also a re run is an extra effort and may not be easy to perform. For example the initial run may have been done on a remote location in a different time zone etc. Further the second verbose log generated will contain redundant information that is not needed to analyze the actual error and only pollute the log making the troubleshooting process more difficult.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments of the invention are directed to error tracing with context history. When an error occurs in execution of computer code trace messages generated by the code leading up to the error are kept in a log. Trace messages associated with successful actions are purged from the log. This allows detailed logging to be performed in a single run of the code without generating a bulky log that contains needless log entries and wastes resources.

Many of the attendant features will be more readily appreciated as the same become better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However the same or equivalent functions and sequences may be accomplished by different examples.

Embodiments of the invention provide error tracing with context history. In one embodiment a trace tree is kept only in cases of an error such as an exception . A trace tree branch corresponding to error free actions like procedures or functions of a program is trimmed. Thus the log will contain historical context information from the beginning of the run till the point of error. The historical context information contains brief tracing corresponding to successful actions and detailed tracing only for the failure path. In one implementation the highest level of tracing is turned on from the first run so that a re run of tracing is not needed. Embodiments of the invention may be used in various types of code including test code and product code.

Getting rid of detailed logging for successful calls saves a lot of storage space. Detailed logging as desired may be used without a fear of consuming huge memory resources. In one embodiment only the path from the beginning of the program to the point of error is kept as context historical information therefore isolating only the meaningful information related to the failure. Also it easier for a user to review test logs where only detail logging is shown when errors occurred. Users do not have to waste time combing through logging of successful events searching for the error related events.

System includes a tracing tool that is part of code . Code may include test code product code and the like. Test code includes code for exercising code under test to invoke actions from the code under test. Product code includes code that is eventually released in a licensed product. Tracing is often used in pre release builds of product code for software testing debugging and analysis.

Tracing tool includes computer readable instructions to implement embodiments of the invention. In one embodiment tracing tool is called at the beginning of execution of code to log trace messages generated during execution of code .

In one embodiment tracing tool includes a library that contains tracing functions that may be called from within code . One of the functions of the tracing library puts a tracing message in a tree structured tracing log and may be called from anywhere in code e.g. before any main instruction or group of instructions . Other functions of the tracing library include a trimming function to trim the tracing log tree structure once a function in code exits without error and a read tree function that reads the tracing tree branch down to the error point should an error occur in code .

When trace messages are generated during execution of code the trace messages are put in a trace log . In one embodiment trace log is maintained in memory of a computing device. When function calls return successfully i.e. without an error occurring during execution of the function then testing tool removes any trace messages generated during execution of the function from trace log . However when an error occurs during execution of the function then trace messages generated up to the error are kept in trace log .

In one embodiment when a first error occurs execution of code stops and the path to the first error is kept in trace log . In another embodiment when a first error occurs the path to the first error is kept in trace log but execution of code continues. If another error occurs then the path to the second error is kept in trace log . Assuming no further errors occur then in this case trace log contains two sub trees corresponding to the two errors that occurred during code execution. A user has discretion in deciding when to stop execution of code when an error occurs. The user may choose whether to stop and output trace log after a first error occurs or let execution continue.

In one embodiment an error includes an exception. In general an exception is raised thrown when something out of the ordinary or unexpected occurs in program execution. In most cases the exception will invoke separate code such as an exception handler at the top of code that catches all exceptions. Some exceptions may be treated as fatal errors some as recoverable errors and some merely as notifications. It is the code inside the exception handler that decides that.

In one embodiment only fatal exceptions are considered error events by tracing tool for trimming trace log . For example tracing tool may be configured to stop execution of code when the first error occurs and persist trace log to trace log file . For non fatal exceptions execution continues without outputting trace log to trace log file . If a function returns with only non fatal exceptions then the function is considered to have returned successfully and trace log will be trimmed. In other configurations additional exception types e.g. recoverable may be considered an error by tracing tool for trace message trimming. The user has the flexibility to configure tracing tool with the tracing and trace log trimming constraints as desired.

In one embodiment when execution of code completes e.g. code stops because of an error or code executes without error trace log is stored in a trace log file such as on a hard disk drive. In another embodiment when execution of code completes trace log is displayed in an output device for viewing by a user.

Turning to examples of error tracing using tree data structures is shown. shows a tree of tracing in a program without trimming the sub trees. shows a tree having trimmed sub trees as described herein. In one embodiment tracing tool generates and manages the tree data structure of tree . In one embodiment tree is generated and manipulated in memory of a computing device. Once the trace tree is trimmed in memory the tree is outputted to a trace log file. While embodiments of the invention are described using tree data structures to log trace messages one skilled in the art having the benefit of this description will appreciated that alternative data structures may be used.

If an error e.g. an exception occurs after message but before message in function f then tracing tool keeps only the log messages shown in . Tracing tool keeps each message logged in its tree data structure on a level equal with the function call depth. Once a function returns successfully then all messages logged by that function and by all the sub functions called by that function are deleted from the tree.

For example f logs message on level then calls function f . Function f which logged 3 messages and on level returned successfully. Since f returned successfully tracing tool deletes all messages i.e. tree nodes belonging to level or higher although in this instance there are not any levels higher than level for f of the tree i.e. all three messages belonging to f . Thus only message i.e. node is left.

Going further as the logging progresses message is logged next in the tree on level after message . Then function f calls function f which logs message on level f calls f which logs messages and on level . Function f then calls f which logs messages and on level . As shown in an error occurs in f after message but before message . Tracing tool will keep the logged messages along the tree branch to the error as shown in . This sub tree will be stored in trace log file . In one embodiment trace log file is displayed to a user using the actual tree data structure indented by levels as shown in .

The trace generates not only node information i.e. messages usually present by dumping the program stack trace but also time stamps and context information that historically extends from the starting point of the program till the point where the error occurred. The extra messages that provide context to the trace are and . A user can setup the trace to log as much detail as desired. However the user will not be overwhelmed with logged messages in the log file because tracing tool keeps only the messages logged from the beginning of the trace to an eventual error point. If no error occurs then no trace messages are kept.

In one embodiment the user may configure tracing tool to keep messages at a certain level or higher whether or not an error occurs. In the example of trace message was kept in the trace log because tracing tool was configured to keep all messages of level or higher. Tracing tool may keep only top or top n level messages if desired by the user. For example in the user may setup the trace to keep all messages at level and higher i.e. levels and regardless of whether an error occurs at those levels. Messages level and messages level would be kept in addition to any messages in a sub tree having an error.

Embodiments of the invention lead to efficient use of storage for log files as well as ease the burden on users to analyze log files. For example if one logs an average of 10 messages and 10 function calls per function and there are 5 level deep function calls that means that the tracing tool logs around 10 10 2 10 3 10 4 10 5 111 110 messages. If in the worst case scenario an exception occurs inside the last level function i.e. at the end of the trace run then the number of messages kept would be 10 10 10 10 10 50 messages. By using embodiments of the invention in general if each function calls n functions and displays n messages on a m level deep function call tree then the number of messages kept by tracing tool is around n m. The total messages kept by an ordinary logger at the same verbosity level would be around n m.

If tests performed by test code are logged carefully e.g. opening file X from location Y then searching for this info in this file etc. then the tester can reconstruct all the scenario steps to the failure just by looking at the trace produced by tracing tool inside the top exception handler upon a failure. Very often when a failure occurs the tester knows what went wrong at that point e.g. couldn t open a file but the tester does not know under what context e.g. the same file can be opened in several other places in the code . Using tracing tool a tester may look in one place e.g. trace log file and find context information about the failure without having to look at the code line numbers etc. This is very useful for testers when debugging test failures in a lab reducing investigation time considerably. This is also useful for testers who don t know much about the test run e.g. the tester is not a test or development component owner . The tester can spot a problem just by reading the verbose explanation in trace log file .

Experience in test activity has shown that test failure investigation consumes a significant amount of time and people resources and therefore money. Embodiments herein are a way of reducing this considerably. In one embodiment a tester logs his her actions as one does in a personal log i.e. very detailed which most of the time is the case as the tester needs to provide personal logging even for the most verbose trace logging setting . But the tester does not have to be concerned with logging level and about clogging the logger s pipe with too much detail. On failure only the historical context information related to the failure itself is kept and information of no use related to successful actions will have been trimmed.

Turning to in one embodiment of an error tracing system the logging by tracing tool may be enhanced by merging the logging performed by tracing tool with messages logged by another component. System includes test code that is used to test product code . Tracing tool generates test log using embodiments as described above. Product code also produces its own product log . Product log includes messages usually indexed by time stamp regarding actions performed during execution of product code . In one embodiment one or more components of system may be implemented by computer readable instructions executable by one or more computing devices.

Tracing tool may merge test log and product log to produce a single merged log file . In one embodiment logs and are merged by matching time stamps of messages in each log. In another embodiment messages in product log that occurred after the error will also be trimmed from the merged log file . Thus a user who wants to diagnose a problem looks in only one place i.e. merged log file and sees only meaningful test log and product log information. This one stop test failure diagnosis increases efficiency for the user and speeds up software testing. In one embodiment in memory test log merges with a product log file on disk to generate merged log file on the disk as well .

Turning to an embodiment of a log file that is the result of merging two logs by tracing tool is shown. Log file is produced after the error occurred between messages and as shown in . Messages logged by tracing tool are shown in log file by their associated message numbers same message numbers as in and time stamps. Information from a product log such as shown at has been merged with message shown at based on time stamps. That is the entries from two or more logs are aligned using the time stamps for the entries in each log. It will also be noted that the merged messages displayed in log file are indented similarly as the tree data structure in to aid the user in reading and analyzing log file .

In another embodiment tracing tool may trace individual threads in program code. The trace messages may be identified by a thread identification ID associated with the thread that executed the code for generating the message. Each thread can log trace messages in its own tracing tree structure. As one error is encountered in one thread the specific thread trace messages are output to a log file. In another embodiment the tracing trees of all threads are merged up to the point in time when an error occurred in one of the threads.

Turning to a flowchart shows operations of error tracing in accordance with an embodiment of the invention. In one embodiment at least a portion of flowchart may be implemented by computer readable instructions executable by one or more computing devices. In one embodiment tracing tool may perform at least some of the operations of flowchart .

Starting with operation the tracing tool is configured. Tracing tool may be configured by a user via a user interface a command line and the like. Configuring the tracing tool may include setting the trace level e.g. minimal to verbose . Configuring the tracing tool may include setting the level at which logged trace messages are trimmed after a successful function return. For example as described above tracing tool may keep all trace messages at or above a designated level regardless of whether an error occurred during function execution. In another embodiment configuring tracing tool includes designating the path to the one or more log files e.g. product log to be merged with trace log .

Proceeding to operation a function in the program code is entered. When the code is first executed this may be the main routine. One skilled in the art having the benefit of this description will appreciate that the logic of flowchart may be applied to multiple nested function call levels. Continuing to operation trace messages are logged as dictated in the code. Proceeding to decision the logic determines if an error has occurred in the code. If the answer is no then the logic proceeds to decision to determine if the function has returned. If the answer to decision is no then the logic returns to operation where the function continues executing and logging trace messages if any .

If the answer to decision is yes then the logic proceeds to operation to delete the sub tree of logged trace messages associated with the returned function and functions called by the returned function. In one embodiment the trace messages are deleted at and lower than a designated level. Next in decision the logic determines if there is more code for execution. If the answer is yes then the logic returns to operation to continue code execution. If the answer is no then the logic proceeds to operation discussed below .

Returning to decision if an error occurs during execution of a function then the logic proceeds to operation . At operation the sub tree of the logged messages that includes the error is kept. In one embodiment the sub tree entries in the tree data structure are flagged for keeping. Next in operation the trace log is merged with another log if desired. In one embodiment the logs are merged based on time stamps of the logged messages. Proceeding to operation the trace log is output by tracing tool . For example the trace log is stored in a trace log file displayed in a display device and the like. In one embodiment the trace log is maintained in main memory as trace messages are logged and or trimmed and then saved to a non volatile storage device as a trace log file.

Embodiments herein provide an error trace method in which a trace tree collapses on success. Sub trees corresponding to successful actions are trimmed i.e. collapsed automatically. Alternatively trace messages at or above a designated function call level may be retained in the tree even when no errors occur. In the case of an error the whole path from the root to the failure leaf remains intact. The trimming saves resources and allows for detailed logging in a first run that will be kept in cases of an error.

Although not required embodiments of the invention are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement embodiments of the invention may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allow device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency infrared Near Field Communication NFC and other wireless media.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

In the description and claims the term coupled and its derivatives may be used. Coupled may mean that two or more elements are in contact physically electrically magnetically optically etc. . Coupled may also mean two or more elements are not in contact with each other but still cooperate or interact with each other for example communicatively coupled .

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments of the invention. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device . Those skilled in the art will also realize that all or a portion of the computer readable instructions may be carried out by a dedicated circuit such as a Digital Signal Processor DSP programmable logic array and the like.

Various operations of embodiments of the present invention are described herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment of the invention.

The above description of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments and examples of the invention are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the following claims are to be construed in accordance with established doctrines of claim interpretation.

