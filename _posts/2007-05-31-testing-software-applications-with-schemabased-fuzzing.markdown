---

title: Testing software applications with schema-based fuzzing
abstract: Systems and methods to test software applications with schema-based fuzzing are described. In one aspect, the systems and methods automatically generate valid input data for a software application according to a fuzzing data schema. The fuzzing data schema describes characteristics of data format that would be proper or well formed for input into the software application. The systems and methods mutate to the valid input data with one or more fuzzing algorithms to generate corrupted versions, or malformed data. The malformed data is for fuzz testing the software application to identify any security vulnerabilities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07926114&OS=07926114&RS=07926114
owner: Microsoft Corporation
number: 07926114
owner_city: Redmond
owner_country: US
publication_date: 20070531
---
To avoid certain types of security vulnerabilities computer program applications should verify that consumed input is well formed without making false assumptions about input consistency. Otherwise security vulnerabilities such as buffer overruns resulting from malformed input and other types of errors may be fatal to proper functioning and results of the application. To locate any such vulnerabilities software developers often implement fuzz testing or fuzzing prior to releasing software. Fuzzing is a software testing technique that typically provides random data fuzz as computer program application data inputs. If the application fails in view of such randomly generated data inputs for example by crashing or by failing built in code assertions a software developer generally notes and attempts to address the defects. However conventional software fuzz testing techniques are typically very time consuming and labor intensive often requiring iterative manual effort and or use of inefficient automated techniques. For instance existing fuzzing techniques generally only locate very specific and simple faults often with poor code coverage. For example if input includes a checksum which is not properly updated to match other random changes only the checksum validation code will be verified. Every fuzzer is generally designed to find a different set of vulnerabilities or bugs.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Systems and methods to test software applications with schema based fuzzing are described. In one aspect the systems and methods automatically generate valid input data for a software application according to a fuzzing data schema. The fuzzing data schema describes format of data that would be proper or well formed for input into the software application. The systems and methods mutate the valid input data with one or more fuzzing algorithms to generate corrupted versions or malformed data. The malformed data is for fuzz testing the software application to identify any security vulnerabilities.

Conventional software fuzzing techniques include for example manual code reviews and inspections manual testing of negative test cases automated static code analysis and automated dumb fuzzing by randomly corrupting bits in the input data. These techniques are substantially limited. For example manual code reviews and inspections are typically very time consuming and error prone. One reason for this is that complicated dependencies and assumptions are difficult to identify manually. Another reason for this is that manual code reviews may introduce new bugs due to false positives. Additionally testing of negative test cases generally requires manual definition of a test case for every input. Enumerating all combinations of data formats for complex inputs is typically a very time consuming and difficult often insurmountable task. In another example automated static code analysis techniques typically locate only specific and very simple bugs. One reason for this is that such automated techniques are typically not aware of input structure. Moreover due to high processing costs of evaluating all possible code paths automated static code analysis techniques commonly have limited code path coverage. Furthermore existing automated dumb fuzzing which randomly corrupts input bits often results in missed bugs. One reason for this is that conventional automated dumb fuzzing techniques cannot correctly adjust the length or count fields with the input data.

Systems and methods to test software applications with schema based fuzzing to identify security vulnerabilities are described below with respect to . The systems and methods each of which is at least partially implemented by a computing device use a fuzzing data schema to describe aspects and structure of valid well formed input to a computer program application application . In one implementation for example the fuzzing data schema is an XML schema. The systems and methods parse the schema to identify input structure and automatically determine and generate all permutations of malformed input to the application. In this manner the generated malformed input is not randomly generated in a manner that could miss a particular permutation but rather systematically generated in view of specific data characteristics parsed from the schema. For purposes of exemplary description such malformed input is also hereinafter often referred to as malformed data. The malformed data determinations are made independent of whether input data field length changes because the systems and methods vary field length responsive to such changes. To identify security vulnerabilities in the application the systems and methods input the systematically generated malformed data into the application to identifying security vulnerabilities without false positives i.e. every bug identified is real and exploitable . In at least these manners the systems and methods to test software applications with schema based fuzzing address the limitations of conventional software fuzzing techniques.

These and other aspects of the systems and methods for testing software applications with schema based fuzzing are now described in greater detail

Although not required the systems and methods to test software applications are described in the general context of computer program instructions being executed by a computing device such as a personal computer. Program modules generally include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. While the systems and methods are described in the foregoing context acts and operations described hereinafter may also be implemented in hardware.

System memory includes program modules . Each program module is a computer program application including computer program instructions executable by processor . System memory also includes program data that is generated and or used by respective ones of the program modules . In this implementation for example program modules include fuzz testing fuzzing engine software application and other program modules such as an Operating System OS to provide a runtime environment an XML editor a testing tool device drivers etc. In one implementation fuzzing engine tests software application with schema based fuzzing to identify security vulnerabilities. Before describing exactly how fuzzing engine perform such operations we first describe aspects of fuzzing data schema .

In one implementation a software developer or other user manually defines fuzzing data schema . For example a user interfaces with an Extensible Markup Language XML editing application to generate fuzzing data schema . Although fuzzing data schema is shown as local to computing device in another implementation fuzzing data schema is remote from computing device e.g. in a database coupled to computing device over a network etc. . Fuzzing data schema describes models characteristics e.g. data types attributes relationships input sequences etc. of well formed valid input data e.g. input data message protocol formats etc. for software application . This data modeling does not directly provide specific instances of well formed data but rather describes attributes characteristics etc. that a specific instance of well formed data would have. Software application can be any arbitrary application. For instance valid input data to a web browser software application includes for example HTTP protocol response message to present HTML web pages. In another example valid input data to a SMTP server software application include data to present SMTP based messages. In either of these exemplary scenarios the user models corresponding protocols e.g. HTTP HTML SMTP and or so on including each specific form of the protocol. Examples of valid input data modeling for fuzzing data schema are presented below.

To model valid well formed input data for software application a user decomposes the input data into atomic groups of groups of elements or primitive elements strings numbers etc. . For each element the fuzzing data schema indicates data type valid values or relationships e.g. attributes describing legitimate variations of the element such as data length valid ranges minimum maximum values and or so on . Such relationships attributes valid formats indicate appropriate value s of an element for well formed i.e. expected input into the software application. For variable length fields fuzzing data schema indicates how to detect field termination e.g. by whitespace or carriage return character etc. . TABLES 1 and 2 respectively show an exemplary set of elements data fields and attributes and groups of elements or groups e.g. a group of groups to model well formed input data for software application . Although a certain number of elements and groups are described with respect TABLES 1 and 2 it can be appreciated that system can use other elements and groups to model well formed input data for software application .

Referring to TABLE 1 and in this implementation respective ones of well formed data elements for input into software application are modeled in fuzzing data schema for example as a corresponding character string numeric string integer byte array or bit array. A character string is a string of ASCII or Unicode characters of variable length. String length is fixed or determined by a specified terminator. In one implementation a valid character set is specified. A numeric string is a number encoded as a string. Such a number e.g. integer binary coded number floating point is signed or unsigned. In one implementation valid range relationships and or precision attribute s is are specified for a number. A byte array element is a stream of bytes. The length of the byte array is fixed or determined by a specified terminator. A bit array element is an array data structure which compactly stores individual bits 0 or 1 .

Referring to TABLE 2 and in this implementation groups in fuzzing data schema include for example one or more sequential groups single choice groups multi choice groups and bit array groups. A sequential group includes multiple elements or groups of element s in a specified order. For example if software application expects to receive element field A field B and field C in the specified order schema would contain a sequential group with data fields elements A B and C. A single choice group represents only one element or group out of possible options. A multi choice group represents multiple elements or groups in any order contained in the group. A bit array group is a list of bits contained in the group.

For example and in one implementation fuzzing data schema describes a simple HTTP Message in XML as follows 

Fuzzing engine parses fuzzing data schema to create valid input data . Valid input data represents data that conforms to respective elements in fuzzing data schema . Since fuzzing application models well formed data for input into software application valid input data represents valid data for input into software application data that software application was designed to consume or process.

In one implementation for example fuzzing engine randomly generates valid input data by iterating through each group and element combination in fuzzing data schema generating respective portions of valid input data according to the characteristics of the specific group type e.g. sequential single choice multiple choice etc and element type character string numeric string integer length valid range etc. . For example to generate valid input data associated with a single choice group one of the specified element s is randomly selected and created. In another example fuzzing engine generates a string element by iterating between zero 0 and a random length within an allowed specified maximum indicated by element attributes properties e.g. valid range minimum maximum values byte array length etc. . For every character a random character within an allowed specified set is generated.

After creating valid input data and in one implementation fuzzing engine parses and mutates changes valid input data to generate malformed data properly formed invalid data for input to and fuzz testing of software application . To this end fuzzing engine parses valid input data to generate a tree of groups and elements and corresponding attributes valid ranges characteristics etc to representing the valid input data . Tree isolates valid element data associated with respective individual elements of valid data so that malformed data can be generated from respective ones of the isolated elements.

Next and in one implementation fuzzing engine applies one or more known fuzzing algorithms to at least a subset of the data elements in tree to corrupt the data elements according to well known data type based vulnerability patterns. For instance one exemplary fuzzing algorithm inserts null values into string element s . Another exemplary fuzzing algorithm for example may sets integer value s to a maximum value 1 in a specified allowable range and or so on. Fuzzing engine further serializes the resulting mutated data tree i.e. a data tree with fuzzed corrupted data inputs resulting in fuzzed data buffer or mutation template . Serialization is a common computer term for converting a data structure comprised of a few elements into a data buffer. For purposes of exemplary description a mutation template is a sample of a legitimate data e.g. please see the example of paragraph 0022 .

In one implementation fuzzing engine provides at least a subset of malformed data to software application to test and validate portions of software application for security vulnerabilities. To this end and in one implementation fuzzing engine interfaces with an Application Programming Interface API exposed by a software application to input respective portions of malformed data into software application . For instance if software application is an SMTP application fuzzing engine sends fuzzed data respective portions of malformed data to the SMTP application. In another implementation fuzzing engine interfaces with an Application Programming Interface API exposed by a testing tool application independent of fuzzing engine to provide malformed data to the testing tool. In this scenario the testing tool communicates received malformed data to fuzz test software application . For purposes of exemplary illustration an exemplary such testing tool is shown as a respective portion of other program modules . In yet another implementation fuzzing engine provides malformed data to software application by generating a data file for parsing by the testing tool. For purposes of exemplary illustration such a data file is shown as a respective portion of other program data .

Responsive to receiving a piece of malformed data if software application crashes or otherwise performs contrary to target design the testing operations based on schema based fuzzing have identified a security vulnerability in a code portion of software application corresponding to the received piece of malformed data . Otherwise if no crash or other unusual behavior of software application occurs no security vulnerability was identified in the corresponding portion of code i.e. the code portion is validated . Because malformed data is systematically generated according to modeled format of well formed input data to the software application false positives for security vulnerabilities are not generated when malformed data is input into software application .

Referring to operations of block automatically generate valid input data for software application . The valid input data is generated according to well formed data characteristics described in a fuzzing data schema . Operations of block mutate at least a subset of the valid input data using one or more well known fuzzing algorithms to generate corresponding malformed data . Operations of block in one embodiment input data from the valid input data into the software application to validate and test the software application. Operations associated with block provide an additional avenue for test validation of the software application independent of fuzz testing the software application with malformed data . For instance these operations validate whether the software application properly operates responsive to receiving properly formed data.

Operations of block communicate at least a portion of the malformed data to the software application to determine if corresponding code portions of the software application exhibit security vulnerability. Operations of block notify a user of any code portions in the software application that do not properly process respective portions of valid input data as identified via the valid input data testing of block . Operations of block can also notify user of any code portions in the software application that have security vulnerability as identified via the fuzz testing of block . In one implementation such notification is via a message or dialog box presented to a user using a display device .

Operations of block generate a fuzzing data schema to describe group and element characteristics of a set of well formed input data for a particular software application . Operations of block parse the group and element characteristics and the fuzzing data schema to generate a set of valid input data . Operations of block fuzz test software application with fuzzing algorithm corrupted versions of the valid input data . System implements this fuzz testing to identify any code portions of the software application with security vulnerability. In this implementation the corrupted versions of the valid input data are shown as malformed data . Operations of block notify a user of any code portions of the software application that have security vulnerabilities identified via the fuzz testing operations.

Although system of has been described as using valid input data generated from fuzzing data schema merely to generate structure and content associated with malformed data in another implementation valid input data is used for additional purposes. For example in one implementation valid input data is utilized to test proper functionality and or results of software application this is as compared to utilizing malformed data to identify code portions of software application with security vulnerability . For purposes of exemplary illustration a testing tool shown as respective portion of other program data inputs data from valid input data into software application to test operations of software application .

For example in one embodiment valid input data specifies content of one or more messages for communication to the software application according to a specific protocol described by the fuzzing data schema . In this embodiment the testing tool communicates at least a subset of the messages to the software application to validate whether the software application properly processes the received messages. This is only one arbitrary example of using a particular exemplary aspect of valid input data to test proper functioning of software application . There are many different scenarios where different types of valid input data are used to test operations of software application .

In another example of an alternative embodiment although shows computing device as a stand alone device in one implementation computing device is coupled across communications network to a remote computing device . In this implementation computing device communicates fuzzed data buffer across network to remote computing device to test a software application at remote computing device for security vulnerabilities. In another example rather than fuzzing engine directly generating valid input data directly from fuzzing data schema in another implementation valid input data is determined using network capture or by manually generating the valid input data . In either of these latter two scenarios fuzzing engine generates fuzzed data buffer and malformed data based on valid input data . Techniques to collect input data via network capture are well known for example this can be done using network sniffer.

Although the above sections describe testing software applications with schema based fuzzing in language specific to structural features and or methodological operations or actions the implementations defined in the appended claims are not necessarily limited to the specific features or actions described. Rather the specific features and operations to test software applications with schema based fuzzing are disclosed as exemplary forms of implementing the claimed subject matter.

