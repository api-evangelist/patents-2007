---

title: Method and apparatus for application-specific programmable memory architecture and interconnection network on a chip
abstract: Programmable architecture for implementing a message processing system using an integrated circuit is described. In an example, specification data is received that includes attributes of the memory system. A logical description of the memory system is generated in response to the specification data. The logical description defines a memory component and a memory-interconnection component. A physical description of the memory system is generated in response to the logical description. The physical description includes memory circuitry associated with the integrated circuit defined by the memory component. The memory circuitry includes an interconnection topology defined by the memory interconnection component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07574680&OS=07574680&RS=07574680
owner: Xilinx, Inc.
number: 07574680
owner_city: San Jose
owner_country: US
publication_date: 20070129
---
One or more aspects of the present invention relate generally to integrated circuit design tools and more particularly to a programmable architecture for implementing a message processing system using an integrated circuit.

Programmable logic devices PLDs exist as a well known type of integrated circuit IC that may be programmed by a user to perform specified logic functions. There are different types of programmable logic devices such as programmable logic arrays PLAs and complex programmable logic devices CPLDs . One type of programmable logic device known as a field programmable gate array FPGA is very popular because of a superior combination of capacity flexibility time to market and cost.

An FPGA typically includes an array of configurable logic blocks CLBs surrounded by a ring of programmable input output blocks IOBs . The CLBs and IOBs are interconnected by a programmable interconnect structure. The CLBs IOBs and interconnect structure are typically programmed by loading a stream of configuration data known as a bitstream into internal configuration memory cells that define how the CLBs IOBs and interconnect structure are configured. Additionally an FPGA may include embedded memory such as block random access memories BRAMs one or more microprocessors sometimes referred to as embedded cores and digital clock managers DCMs . The combination of components on an FPGA may be used for system level integration sometimes referred to as system on a chip SOC .

Historically FGPAs have not been employed in network processing applications. Rather Network devices such as routers employ dedicated special purpose components for processing packets that propagate through the network. Conventionally network devices employ network processors or application specific integrated circuits ASICs to provide the desirable packet processing network processing functions. Such processor or ASIC based architectures however are static in nature providing a fixed amount of resources for packet processing network processing functions. Accordingly there exists a need in the art for more flexible message processing architectures.

One aspect of the invention relates to designing a memory system for implementation using an integrated circuit. Specification data is received that includes attributes of the memory system. A logical description of the memory system is generated in response to the specification data. The logical description defines a memory component and a memory interconnection component. A physical description of the memory system is generated in response to the logical description. The physical description includes memory circuitry associated with the integrated circuit defined by the memory component. The memory circuitry includes an interconnection topology defined by the memory interconnection component.

Another aspect of the invention relates to a design tool for designing a memory system for implementation using an integrated circuit. An input section is adapted to specify attributes of the memory system. A first database stores a memory model defining a memory component and a memory interconnection component. A second database stores a physical memory configuration associated with the integrated circuit. A memory model section includes a first portion and a second portion. The first portion is adapted to generate an instance of the memory component and an instance of the memory interconnection component. The second portion is adapted to implement the memory component instance and the memory interconnection component instance in terms of memory circuitry and interconnection circuitry respectively of the physical memory configuration to produce a physical view of the memory system.

Overview introduces aspects of the invention and exemplary embodiments of their relationships to one another 

Soft Platform describes a programmable architecture and associated design tool for implementing a message processing system using an integrated circuit 

Memory Model describes an application specific programmable memory architecture and interconnection network for an integrated circuit 

Multithread Model describes an inter process synchronization mechanism for threads implemented within a configurable logic portion of an integrated circuit and

Programming Interface describes a programming interface for a design tool embodying a soft architecture for implementing a message processing system using an integrated circuit.

One or more aspects of the invention are related to a configurable and programmable micro architecture for implementing message processing MP systems soft platform architecture . As used herein the term message encompasses packets cells frames data units and like type blocks of information known in the art that is passed over a communication channel. A message processing system is a system or subsystem for processing messages e.g. a packet processing system or a network processing system . The soft platform architecture is message centric to match the nature of MP systems. That is the processing components of the MP system go to the messages as opposed to the messages coming to the processing components.

Briefly stated a designer specifies attributes for an MP system such as structural and behavioral attributes for processing components and memory components. For example the designer may employ a set of descriptions or primitives that parametrically define the MP system attributes. The primitives provide an abstract mechanism for defining the MP system. A design tool embodying the soft platform architecture may include a programming interface for generating a logical description or logical view of an MP system based on the designer specified attributes.

Notably the logical view includes logical components of the soft platform architecture configured in accordance with the designer specified MP system. In particular the soft platform architecture includes a memory model component and a multithreading component. A physical view of the MP system may then be generated based on the logical view. The physical view includes physical components of an integrated circuit architecture that implement the logical components of the soft platform architecture. The physical view may then be processed to generate configuration data for the integrated circuit to realize the designer specified MP system e.g. a configuration bitstream for a PLD or mask data for an ASIC . Thus the soft platform architecture provides a mechanism by which a designer may design an MP system in an abstract fashion without knowledge of the particular physical configuration of the integrated circuit.

One or more aspects of the invention are described with respect to a programmable architecture for implementing a message processing system using an FPGA. While the invention is described with specific reference to an FPGA those skilled in the art will appreciate that other types of programmable logic devices may be used such as complex programmable logic devices CPLDs . In addition other types of mask programmable devices may be used such as application specific integrated circuits ASICs . Those skilled in the art will appreciate that if an ASIC is employed rather than an PLD then mask data is generated in place of a configuration bitstream.

The FPGA illustratively comprises programmable logic circuits or blocks illustratively shown as CLBs IOBs and programmable interconnect also referred to as programmable logic as well as configuration memory for determining the functionality of the FPGA . The FPGA may also include an embedded processor block as well as various dedicated internal logic circuits illustratively shown as blocks of random access memory BRAM configuration logic digital clock management DCM blocks and input output I O transceiver circuitry . Those skilled in the art will appreciate that the FPGA may include other types of logic blocks and circuits in addition to those described herein.

As is well known in the art the IOBs the CLBs and the programmable interconnect may be configured to perform a variety of functions. Notably the CLBs are programmably connectable to each other and to the IOBs via the programmable interconnect . Each of the CLBs may include one or more slices and programmable interconnect circuitry not shown . Each CLB slice in turn includes various circuits such as flip flops function generators e.g. a look up tables LUTs logic gates memory and like type well known circuits. The IOBs are configured to provide input to and receive output from the CLBs .

Configuration information for the CLBs the IOBs and the programmable interconnect is stored in the configuration memory . The configuration memory may include static random access memory SRAM cells. The configuration logic provides an interface to and controls configuration of the configuration memory . A configuration bitstream produced from the program memory may be coupled to the configuration logic through a configuration port . The configuration process of FPGA is also well known in the art.

The I O transceiver circuitry may be configured for communication over any of a variety of media such as wired wireless and photonic whether analog or digital. The I O transceiver circuitry may comprise gigabit or multi gigabit transceivers MGTs . The DCM blocks provide well known clock management circuits for managing clock signals within the FPGA such as delay lock loop DLL circuits and multiply divide de skew clock circuits.

The processor block comprises a microprocessor core as well as associated control logic. Notably such a microprocessor core may include embedded hardware or embedded firmware or a combination thereof for a hard or soft microprocessor. A soft microprocessor may be implemented using the programmable logic of the FPGA e.g. CLBs IOBs . For example a Microblaze soft microprocessor available from Xilinx of San Jose Calif. may be employed. A hard microprocessor may be implemented using an IBM Power PC Intel Pentium AMD Athlon or like type processor core known in the art.

The processor block is coupled to the programmable logic of the FPGA in a well known manner. For purposes of clarity by example the FPGA is illustrated with 12 CLBs 16 IOBs 4 BRAMs 4 DCMs and one processor block. Those skilled in the art will appreciate that actual FPGAs may include one or more of such components in any number of different ratios. For example the FPGA may be selected from the Virtex II Pro family of products commercially available from Xilinx of San Jose Calif.

One or more aspects of the invention include design tools for designing MP systems memory systems and multithreading systems. Such design tools may be implemented using a computer. Notably is a block diagram depicting an exemplary embodiment of a computer suitable for implementing processes methods and design tool sections described herein. The computer includes a central processing unit CPU a memory various support circuits and an I O interface . The CPU may be any type of microprocessor known in the art. The support circuits for the CPU include conventional cache power supplies clock circuits data registers I O interfaces and the like. The I O interface may be directly coupled to the memory or coupled through the CPU . The I O interface may be coupled to various input devices and output devices such as a conventional keyboard mouse printer display and the like.

The memory may store all or portions of one or more programs and or data to implement the processes methods and design tool sections described herein. Although one or more aspects of the invention are disclosed as being implemented as a computer executing a software program those skilled in the art will appreciate that the invention may be implemented in hardware software or a combination of hardware and software. Such implementations may include a number of processors independently executing various programs and dedicated hardware such as ASICs.

The computer may be programmed with an operating system which may be OS 2 Java Virtual Machine Linux Solaris Unix Windows Windows95 Windows98 Windows NT and Windows2000 WindowsME and WindowsXP among other known platforms. At least a portion of an operating system may be disposed in the memory . The memory may include one or more of the following random access memory read only memory magneto resistive read write memory optical read write memory cache memory magnetic read write memory and the like as well as signal bearing media as described below.

An aspect of the invention is implemented as a program product for use with a computer system. Program s of the program product defines functions of embodiments and can be contained on a variety of signal bearing media which include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM or DVD ROM disks readable by a CD ROM drive or a DVD drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or read writable CD or read writable DVD or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal bearing media when carrying computer readable instructions that direct functions of the invention represent embodiments of the invention.

Notably the FPGA circuit design may be interface centric in that the circuit design is driven by the behavior at the system interfaces as opposed to the processor centric model where the circuit design is driven by the behavior of an embedded processor. The interface centric circuit design model matches well with the message centric style of the soft platform architecture. Placement and usage of interfaces memories and their interconnections dominate the allocation of FPGA architecture features and then allocation of functional elements e.g. programmable logic embedded processors for the process components follow as a derivative.

More specifically the input section is coupled to one or more input devices and a database storing an application programming interface API API database . The API database includes a set of primitives associated with structural and behavioral attributes of the soft platform architecture. Thus the API provides a programming interface for the soft platform architecture. An exemplary embodiment of a programming interface for a soft platform architecture is described below in the section entitled PROGRAMMING INTERFACE. Using the input devices a designer may interact with the input section to produce specification data for an MP system or subsystem if the MP circuit is part of a larger system hereinafter referred to as an MP system .

Notably in one embodiment a designer may use the primitives in the API database directly to produce the MP system specification data for the soft platform architecture. In another embodiment a designer may design the MP system using alternate constructions provided by the input section . That is the input section may comprise a design entry tool specific to the MP domain. Examples of such MP specific design entry tools include Click available from The Massachusetts Institute of Technology Rave available from Cloudshield of Sunnyvale Calif. and SDL a telecom standard from ITU T . The input section may then map the MP system specified using the alternate constructions onto the primitives in the API database for the soft platform architecture. Thus the input section may provide a different level of abstraction than that provided by the soft platform architecture.

In one embodiment of the invention the MP system specification data may comprise program code for programmatically interacting with the soft platform section . The program code may be callable by an external design tool of the input section . In another embodiment the MP system specification data may comprise interpretive descriptions e.g. descriptions in a textual or binary format that the soft platform section may interpret e.g. an XML format . In either embodiment the MP system specification is used to configure the soft platform architecture.

The soft platform section is coupled to the input section for receiving the MP system specification data. The soft platform section is also coupled to a database storing the features or attributes of the soft platform architecture soft platform database and a database storing features or attributes of the architecture of the FPGA FPGA database .

The soft platform section includes a first portion for generating a logical description or logical view of an MP system in accordance with the MP system specification. The logical view is defined in terms of the logical components of the soft platform architecture stored in the soft platform database . The soft platform section includes a second portion for generating a physical view of the MP system. Notably using information in the FPGA database the soft platform section maps the logical view of the MP system defined in terms of the soft platform architecture onto the architecture of the FPGA . The soft platform section provides FPGA design data as output which represents a physical view of the MP system in terms of the architecture of the FPGA . Details of the soft platform architecture are described below with respect to .

The FPGA design tools section is coupled to the soft platform section for receiving the FPGA design data. The FPGA design data may comprise a physical description of the MP system specified by the designer in terms of the components and features of the FPGA . For example in one embodiment the FPGA design data may comprise a hardware description language HDL representation of the MP system design e.g. Very high speed integrated circuit description language VHDL or Verilog . The FPGA design tools section processes the FPGA design data to produce configuration bitstream data. For example the FPGA design tools section may comprise various well known FPGA design tools such as a synthesis tool a map place route tool like type tools known in the art. The FPGA design tools section provides configuration bitstream data as output which may be loaded into the FGPA .

At step a logical view of the MP system is generated in accordance with the MP system specification. As described above the logical view of the MP system is defined in terms of a soft platform architecture. The logical components of the soft platform architecture are configured in accordance with the MP system specification to generate the logical view of the MP system. The term logical components refers to both the structural and behavioral attributes of the soft platform architecture described in more detail below.

At step the logical view of the MP system is mapped onto an FPGA architecture to produce FPGA design data. That is the logical components comprising the logical view are linked to physical components of an FPGA and optionally other devices connected to the FPGA e.g. external memories . In one embodiment of the invention the FPGA design data comprises an HDL representation of the MP system design. As described above the FPGA design data provides a physical view of the specified MP system in terms of the architecture of the FPGA. That is FPGA design data corresponds to the physical implementation of the logical view of the MP system on an FPGA device.

At step the FPGA system design is processed to produce configuration bitstream data. For example if the FPGA system design comprises an HDL representation of the MP system design the FPGA system design may be synthesized mapped placed and routed in a well known manner to produce bitstream data for configuring an FPGA. At step the configuration bitstream data is loaded into an FPGA to realize the MP system specified at step . The process ends at step .

Notably the soft platform architecture includes a programming control interface and a debug test monitor interface . The programming control interface conveys the data for configuring the programmable portions of the soft platform architecture . The programming control information conveyed via the programming control interface comprises the structural and behavioral information related to the MIS component the process component and the SSS component . An exemplary embodiment of a programming interface to the soft platform architecture is described below in the section entitled PROGRAMMING INTERFACE. The debug test monitor interface may be used during the design and implementation of an MP system defined in terms of the soft platform architecture . The interfaces and are illustrative as there may be a single shared interface or more than two interfaces.

The MIS component is the logical storage point for all messages currently within the system implemented using the soft platform architecture . The MIS component includes an interface to the enclosing environment allowing for the input and output of messages. For example the soft platform architecture may be configured to produce an internet protocol IP packet router. The MIS component may be configured to store all IP packets currently in flight through the router. The interface may be one or more ports by which the router is connected to a physical network.

The MIS component may be physically implemented using a centralized memory device a plurality of distributed memory devices or a combination thereof. In addition the types sizes and interconnections of the physical memory elements as well as the interface to such physical memory elements are programmable through configuration of the MIS component . An exemplary embodiment of a logical memory configuration that may be used as the MIS component is described below in the section entitled MEMORY MODEL. 

The process component comprises one or more processes that may be classified as fine grain operations processes FOPs coarse grain operations processes COPs or perimeter interface processes PIPs . In addition the process component includes an inter process synchronization component . The FOPs COPs and PIPs operate on messages stored within the MIS component . The term process as used herein denotes a concurrent agent for operating on information stored within the MIS component . The term thread is used to denote an instance of a process.

Notably each single execution of a process within the process component is associated with a message stored in the MIS component through a message context . A process in the process component may be physically implemented directly in programmable logic of an FPGA or in a soft or hard embedded processor of an FPGA. In one embodiment of the invention the message context may be implemented using a data counter DC component . The DC component points to the current position in the current message being operated on by a particular process in the process component . As the process executes the DC component may be updated either automatically to advance to the next position in a message or by execution of programmed data jumps. In essence the process moves over the message. The DC component may be physically implemented using a memory element within the FPGA capable of storing an address associated with the location of a message in the memory of the MIS component . Depending on the memory organization of the MIS component the DC component may be a register a BRAM or an external RAM.

The processes of the process component include a common interface. The inter process communication component may utilize the common interface to allow interaction between processes of the process component . Such interactions may include for example creating or destroying a process or passing data to another process. The inter process communication component provides for a control flow in the processing of a message. At a microscopic level the inter process communication component is capable of providing a control flow within a single process s execution. At a macroscopic level the inter process communication component is capable of providing a control flow from one process s execution to another process s execution. An exemplary embodiment of a multithread model that may be used as the inter process communication component is described below in the section entitled MULTITHREAD MODEL. 

A FOP is the basic programmable unit for message processing. A FOP performs a sequence of steps on a message stored within the MIS component . At each step a set of concurrent operations are performed. A FOP may be associated with a DC component . After each step the DC component may be incremented or a data jump operation performed such that the FOP accesses a new portion of the message. The steps as well as the operations performed during each step may be programmable static or partially programmable and partially static in their definition. Examples of operations include inspecting a field e.g. a 16 bit header field of a message or performing simple arithmetic e.g. adding one to a 16 bit header field on a message.

A FOP may be implemented within an FPGA using programmable logic. For example a FOP may be implemented as a finite state machine FSM configured within the programmable logic of the FPGA. Alternatively a FOP may be implemented on an embedded processor within an FPGA. For example a FOP may be implemented as an operating system thread executed by the embedded processor. The physical implementation of a FOP may be programmable static or partially programmable and partially static in its definition.

A COP is used to incorporate a function block to perform a message processing operation. A function block may comprise a circuit or subsystem defined outside the context of the soft platform architecture . For example the function block may comprise a reusable intellectual property IP core for an FPGA. A COP provides a programmable adapter between the interface of the function block and the common interface of the process component . A COP may be started stopped or interrupted by another process of the process component .

A COP may be defined statically and be in existence permanently. Alternatively a COP may be created and destroyed dynamically to allow dynamic reconfiguration of the function blocks associated therewith. For example a COP may be used to incorporate a function block for compression or encryption of all or part of a message stored in the MIS component . A COP may be associated with a DC component which points to the beginning of the message in the MIS component to be processed by the COP .

A PIP is concerned with enabling the movement of a message to and from soft platform architecture . In one embodiment of the invention a PIP may be used to incorporate a function block similar to a COP . The function block associated with a PIP may comprise a circuit or subsystem defined outside the context of the soft platform architecture that is specifically geared to perform I O functions. In another embodiment of the invention a PIP may be implemented as a FSM in programmable logic of the FPGA.

For example a PIP may be used to receive or transmit successive words of a message over an interface using a protocol defined for the interface. For example a PIP may act as a smart adapter for the Xilinx LocalLink interface to a networking core or the interface to a Gigabit MAC core. A PIP may also communicate with other system components implemented within the FPGA.

The SSS component may be used to store state information associated with the processes of the process component . For example the SSS component may be used to store a message context for a FOP . The SSS component may be physically implemented using a centralized memory device a plurality of distributed memory devices or a combination thereof.

In particular the input section is coupled to a database that stores an API associated with the memory model referred to herein as the memory interconnection description language MIDL library . The MIDL library comprises a set of primitives for defining structural and behavioral attributes of the memory model. Thus the MIDL library provides a programming interface for the memory model. A designer may interact with the input section to produce specification data for a memory subsystem. The designer may work directly with the MIDL library or may work indirectly with the MIDL library through an alternative design tool defined within the input section . The memory subsystem specification data may be programmatic or may be interpretive e.g. XML . An example of an MIDL specification for a 32 bit wide memory constructed from two 16 bit wide memories which are in turn mapped to physical BRAM in an FPGA is shown in Appendix A.

The memory model section is coupled to the input section for receiving the memory model specification. The memory model section is also coupled to a database that stores the features or attributes of the memory model memory model database and a database that stores the memory attributes of an FPGA and external memories associated therewith FPGA memory database . The memory model section includes a first portion for generating a logical view of a memory subsystem in accordance with the memory subsystem specification. The logical view is defined in terms of the logical components of the memory model stored in the memory model database .

The memory model section may include an analysis optimization portion for analyzing and optimizing the logical view of the memory subsystem in accordance with constraint data provided by a designer. The memory model section further includes a second portion for generating a physical view of the memory system based on the logical view. Notably using information in the FPGA memory database the memory model section maps the logical view of the memory subsystem onto the physical memory components associated with an FPGA. The memory model section provides FPGA design data as output.

The memory model is characterized by a memory architecture and a memory interconnection architecture. The memory architecture pertains to the size type and topology of one or more memory circuits comprising the memory element . The memory interconnection architecture pertains to the type bus width e.g. number of wires and topology of interconnection e.g. crossbar of the one or more memory circuits comprising the memory element . In general with respect to the memory model the term interface imparts knowledge related to the protocols that must be adhered to for the particular interaction whereas the term architecture imparts knowledge related to the critical path that particular data follows within the memory model .

The memory and interconnection architectures of the memory model may be defined by the physical location of the memory circuits used to implement the model as well as the logical configuration of the interface to such memory circuits. For example the memory may be physically centralized i.e. a single physical memory circuit or several memory circuits may be physically distributed. The memory circuit s used to implement the memory model may be disposed within the FPGA e.g. any combination of on chip BRAMs LUT based RAMs and shift registers disposed external to the FPGA e.g. external SDRAMs DDR SDRAMs and RDRAMs or a combination thereof. In addition the interface to such memory circuit s may be logically centralized e.g. a unified programming interface or logically distributed e.g. multiple logical interfaces .

In light of the various physical and logical configurations for the memory and interconnection architectures various logical schemes for storing messages may be implemented using the memory model . In one embodiment all messages may be stored within a single memory e.g. a queue of messages in a memory uniform message storage . Alternatively different messages may be allocated over different memories interleaved message storage . In yet another alternative each message may be physically allocated over different memories striped message storage . In another embodiment each message may be logically allocated over different memories separated message storage . depict examples of memory subsystems illustrating exemplary configurations for the memory and interconnection architectures with respect to the storage of messages in a system. Those skilled in the art will appreciate that many other configurations for the memory and interconnection architectures may be employed in accordance with the above attributes of which are examples.

In particular is a block diagram depicting an exemplary embodiment of a memory subsystem that may be implemented using the memory model . The memory subsystem illustratively comprises a set of BRAMs through where N is an integer greater than one collectively referred to as BRAMs . The BRAMs may be disposed within an FPGA. Each of the BRAMs includes a memory interface . The memory interface of each of the BRAMs is configured for communication with a computational element . For example each of the computational elements may comprise an instance of a process e.g. a thread within the soft platform architecture described above. Each of the BRAMs includes a second interface for receiving incoming message data.

Notably an incoming message may be striped across the BRAMs such that each of the BRAMs stores only a portion of the incoming message. Each of the computational elements may then access respective ones of the BRAMs through the respective memory interface to access a portion of the incoming message. The memory subsystem is an example of striped message storage using physically distributed memories within an FPGA.

The BRAMs are logically part of one centralized memory with a dedicated memory interface that manages access to the messages stored in the BRAMs . Each of the computational elements may access a message or portion thereof through the memory interface . The memory subsystem is an example of a logically centralized physically distributed memory organization.

Returning to the memory and interconnection interfaces in the memory model may be defined in accordance with various configurable attributes such as the number of ports to a memory and the width of each port. In addition the memory model may be configured to provide a reactive memory subsystem such as a cooperative memory subsystem.

Notably is a block diagram depicting an exemplary embodiment of a cooperative memory interface that may be implemented using the memory model . Cooperative memories are memories that do not just stall or block when data is not available but rather respond back with a message such as data will be available in three cycles. As shown the memory element comprises a memory control logic and interface logic . The interface logic is coupled to the computational element via a data bus a control bus and a status bus . The data bus has a width of n the control bus has a width of m and the status bus has a width of k. In general the width of the control bus and the width of the status bus will be much less than the width of the data base . For purposes of clarity by example the data bus the control bus and the status bus are shown as separate buses. It is to be understood however that the data bus the control bus or the status bus or any combination thereof may be multiplexed within the interface logic over the same physical bus.

The computational element requests data using the control bus . The control logic determines whether the data is available within the memory . If so the data is communicated to the computational element over the data bus . Otherwise the control logic generates a status signal for communication to the computational element over the status bus . The status signal may indicate the unavailability of the requested data and an estimated duration after which the data will be available.

At step a logical view of the memory subsystem is generated in accordance with the memory subsystem specification. The logical view is defined in terms of the memory model . That is the logical components of the memory model are configured in accordance with the memory subsystem specification to generate a logical view of the memory subsystem.

At step the memory subsystem may be analyzed and optimized in accordance with predefined constraint and test data. The constraint data may include constraints on memory access time and interconnect resources. The test data may include one or more test memory access patterns. In one embodiment of the invention an analysis model based on memory access time and interconnect resources is employed.

Notably is a graph illustrating an exemplary embodiment of a memory analysis model. The graph includes an axis representing abstract memory addresses an axis representing abstract time and an axis representing interconnect resources. The graph depicts an exemplary access pattern comprising a plurality of points . Each point signifies a memory access corresponding to a particular memory location address at a particular time that utilizes a particular interconnect resource. For example the exemplary access pattern may result from a burst of packets entering the memory subsystem followed by some header manipulation and a burst of packets exiting the memory subsystem. The predefined constraint data is shown superimposed over the graph as a cuboid . If all points are within the cuboid the access pattern is valid. Otherwise an optimization is required to satisfy the constraints.

Returning to at step the logical view of the memory subsystem is mapped onto an FPGA architecture to produce FPGA design data. That is the logical components comprising the logical view are linked to physical memory components of an FPGA and optionally other memory devices connected to the FPGA. The FPGA design data provides a physical view of the specified memory subsystem in terms of the memory architecture of the FPGA. That is FPGA design data corresponds to the physical implementation of the logical view of the memory subsystem defined using the MIDL. In one embodiment of the invention the FPGA design data comprises an HDL representation of the MP system design.

At step the FPGA design data may be combined with other FPGA design data to define a system. For example the memory subsystem may be incorporated into an MP system designed as described above in the section entitled SOFT PLATFORM. That is the memory subsystem may be the implementation of the MIS component of the soft platform architecture used to implement an MP system.

At step the combined FPGA design data is processed to produce configuration bitstream data. For example if the combined FPGA design data comprises an HDL representation the FPGA design data may be synthesized mapped placed and routed in a well known manner to produce bitstream data for configuring an FPGA. At step the configuration bitstream data is loaded into an FPGA. The process ends at step .

In particular the input section is coupled to a database that stores a library of multithreading primitives multithread primitive database . The multithread primitive database stores a set of primitives for defining structural and behavioral attributes of the multithread model. Thus the multithread primitive database provides a programming interface for the multithread model. Notably the multithread primitive database includes primitives for starting a thread stopping a thread suspending a thread as well as synchronization of such starting stopping and suspending among threads. In addition primitives are provided for indicating status information for individual threads such as completion or suspension among other threads. Furthermore primitives may be provided for allowing data communication among threads.

A designer may interact with the input section to produce specification data for a multithreading system. The designer may work directly with the multithread primitive database or may work indirectly with the multithread primitive database through an alternative design tool defined within the input section . The multithreading system specification data may be programmatic or may be interpretive e.g. XML .

The multithread model section is coupled to the input section for receiving the multithreading system specification data. The multithread model section is also coupled to a database that stores the features or attributes of the multithread model multithread model database and a database that stores the physical attributes of an FPGA FPGA database . The multithread model section includes a first section for generating a logical view of the multithreading system in accordance with the multithreading system specification. The logical view is defined in terms of the logical components of the multithread model stored in the multithread database . The multithread model section includes a second portion for generating a physical view of the multithreading system based on the logical view. Notably using information in the FPGA database the multithread model section maps the logical view of the multithreading system onto the physical components associated with an FPGA. The multithread model section provides FPGA design data as output.

Notably the thread model may be physically implemented in programmable logic of an FPGA as a synchronous FSM. That is a clock drives the state machine s transitions and within each state of the state machine operations are performed on operands producing outputs. In another embodiment the thread model may be implemented using a microcontroller embedded within an FPGA. In yet another embodiment the thread model may be implemented using a hard or soft microprocessor embedded within an FPGA.

The thread includes control logic for processing data and producing control state data and operation state data . The control state data captures the state of the thread in terms of inter thread communication e.g. the thread is finished or suspended . The operation state data captures the internal state of the thread which is defined in accordance with the operation of the control logic .

In one embodiment of the invention the thread includes an IDLE control state that corresponds to the thread not currently carrying out any operation. During the IDLE control state the isFinished terminal is asserted to indicate that the thread is not doing any work. If the start terminal is asserted the thread moves out of the IDLE control state and performs the various operations that the thread is configured to perform. The isFinished terminal is no longer asserted to indicate that the thread is in operation. Asserting the stop terminal returns the thread to the IDLE control state terminating all operations. Asserting the suspend terminal causes the thread to remain in its current operation state regardless of how many clock cycles occur on the clock terminal . The suspend terminal may be used during debugging or testing through an external agent. The isSuspended terminal is asserted while the thread is suspended.

The operation state data depends on the operational configuration of the control logic of the thread in accordance with specification data provided by a designer. That is the control logic of the thread is configured to execute a series of steps where one or more operations are performed at each step. In one embodiment the thread may be designed to have one or more designated terminal operation states that cause the thread to enter the IDLE control state and assert the isFinished terminal . Alternatively there may be no such designated terminal control states in which case the thread is control externally by asserting the stop signal.

where the thread is implemented as a state machine. In this example the IDLE control state is implemented as an extra state added to the internal operation state set of the thread. While there is no explicit suspend control state the suspend mechanism may be implemented by driving the suspend terminal to prevent the calculated nextState from being latched into the state machine s register. Thus the thread will remain in the current operation state with no forward progress. For purposes of clarity by example the implications for the values of outputs from the state are not shown explicitly in the above exemplary VHDL code fragment.

The thread has thus far been described with respect to an external agent that asserts the start stop and suspend terminals. The external agent may be another thread thus allowing threads to control other threads. In order to enable one thread to write or read the signals of another thread the multithread model employs an interconnection topology and an addressing mechanism. That is a plurality of threads are interconnected for communication amongst themselves and a thread may associate the address of another thread with its collection of input and output signals.

Notably is a block diagram depicting an exemplary embodiment of a multithread model in accordance with one or more aspects of the invention. The multithread model comprises a set of thread models through where N is an integer greater than one collectively referred to as thread models . The multithread model also includes an interconnection component . Each of the thread models includes an input bus and an output bus . The input bus and the output bus of each of the thread models are in communication with the interconnection component . In one embodiment the interconnection component facilitates complete point to point communication of control status and or data among the thread models .

In one embodiment of the invention the output bus of a thread model comprises a start control bus a stop control bus a suspend control bus and a status bus . The width of each of the start control bus and the stop control bus is N i.e. the number of thread models in the multithread model . The width of the suspend control bus may be N 1 if self suspension of a thread is not defined. The status bus may comprise M status signals e.g. isFinished and isSuspended signals and thus the width of the status bus is M. The input bus of a thread model comprises a start terminal a stop terminal and a suspend terminal .

In one embodiment of the invention each of the thread models produces a control signal for each of the other thread models e.g. thread model produces control signals for thread models through through operation of control logic . Thus if there are eight thread models in the multithread model then each thread model will produce eight start signals eight stop signals and seven suspend signals in accordance with the control logic . For each of the thread models start signal and one stop signal is connected in a self loop which allows a thread model to start and stop itself. The interconnection component facilitates the connection between the output bus of a given thread model and the input buses of each of the other thread models.

Notably if it is not intended that a particular one of the threads control the starting of the thread then the start control terminal is not asserted. If one of the threads intends to start the thread the start control terminal of that thread is asserted. For example if the thread intends to start the thread then the thread asserts its start control terminal . The start control terminals are logically OR ed together by the OR component such that if one or more is asserted the thread will be started. For purposes of clarity by example a synchronization mechanism for starting the thread is shown. It is to be understood however that the multithread system may be extended to start stop and suspend any number of threads.

Returning to the output bus of a thread model may include a data bus . Data may be communicated amongst the thread models through the interconnection component . In one embodiment of the invention the data bus may comprise a bus for each of the thread models in the multithread model . For example if the thread model intends to send data to the thread model then the thread model communicates the data over the bus associated with the thread model . The validity of the data may be assured by timing with each of the thread models designed such that the consumer of the data does not access the data until it has been written. Alternatively a validity flag may be employed to indicate valid data.

In yet another embodiment each of the thread models may include an identifier e.g. a memory address . A pull mechanism may be employed to retrieve data from one thread model using another thread model. A thread model requiring data provides the identifier to the thread model in possession of the data together with a read request and the data item is provided after some latency. In yet another embodiment a push mechanism may be employed whereby once a thread model has data it pushes the data to all threads that are known to require the data together with its identifier .

In one embodiment of the invention the set of primitives comprises FOP primitives COP primitives PIP primitives signal grouping primitives inter process communication primitives memory element primitives run time primitives implementation metric primitives and debugging primitives . Each of the aforementioned primitives is discussed in detail below.

The FOP primitives provide a coding environment targeting multiple threads that operate in parallel. The FOP primitives include instruction set primitives and physical implementation primitives . The instruction set primitives are used to program the threads. That is the instruction set primitives provide a mechanism for establishing an instruction set of a thread where the instruction set itself is programmable. Thus a designer may modify an instruction set for a thread as desired e.g. providing a domain specific set of instructions . The physical implementation primitives are used to define the physical implementation of a given thread. For example a thread may be implemented in programmable logic of an FPGA or in a hard or soft microprocessor or using a microcontroller.

In one embodiment each thread is implemented as a custom FSM in programmable logic of an FPGA. An instruction set is defined for the FSM thread where each instruction has a dedicated implementation. There is no additional support required for unused operations in the instruction set and multiple instructions may be executed simultaneously.

The COP primitives are used to include a function block into the design. In one embodiment the COP primitives comprise include type primitives for specifying a particular function block to include within the design.

The PIP primitives may comprise instruction set primitives and physical implementation primitives . The instruction set primitives are used to define an instruction set for a thread in a similar manner to the FOP primitives described above. Unlike the FOP primitives however the instruction set primitives may be used to define certain system instructions. The system instructions are used to communicate with input output interface logic blocks that communication with another system within the FPGA or external thereto . For example an interface logic block may be a gigabit Ethernet MAC core. The instruction set primitives provide support for different communication protocols to read write data over various interfaces. For example one type of interface may be completely streaming with data arriving at every clock cycle. Another type of interface may have flow control where there may be a pause in the data stream.

The physical implementation primitives define the physical implementation of the PIP e.g. FSM microprocessor . The PIP primitives may also comprise include type primitives for specifying the inclusion of the interface function block. Each interface block may have multiple ports or groups of signals associated therewith. One group of signals contains the connectivity to the external environment. The others connect to one or more PIP threads. For example an interface block may have a set of signals that form a receive port and another set of signals that form a transmit port. In this case the signals may be grouped together such that each port is assigned to a different PIP thread.

The signal grouping primitives are used to define signal groups. Grouping of signals may occur in various contexts such as when connecting an interface block to a PIP thread as described above or when connecting to a memory element. In such cases the programming information for an element such as a FOP thread states that the FOP thread is connected to another element.

The inter process communication primitives provide support for synchronization and data communication between threads. Some basic aspects of the mechanism such as support for starting stopping and suspending processes may be built into the soft platform architecture. Thread synchronization and data communication however may be completely specified by a designer. In one embodiment connections are explicitly specified between processes. Alternatively required connections may be inferred from the operations defined for a particular group of processes. For example an operation to start another process may have the form of START process or an operation to pass a data value to another process may have the form of PASS data destination process . With such an operation a connection may be inferred without a designer explicitly defining the connection.

The memory element primitives are used to define the various types sizes and interconnections of memory elements. The memory element primitives may include the MIDL primitives discussed above in the section entitled MEMORY MODEL for specifying the logical view of a memory subsystem.

The run time primitives may be used to apply run time reconfiguration. Run time reconfiguration involves the modification of a circuit implemented within an FPGA at run time. Dynamic reconfiguration for an FPGA is well known in the art. For example the run time primitives may be used to migrate functionality between programmable logic and an embedded processor. Initially some functionality is implemented in programmable logic with other functionality implemented using an embedded microprocessor. Implicitly the programmable logic implementation exhibits higher performance than the processor implementation. Functionality may be offloaded to the processor to save area within the programmable logic. During execution statistics may be taken to give feedback on the chosen partition. A reconfiguration controller determines a new partition and reconfigures the FPGA. An exemplary decision condition would be based on the frequency of events. More frequency events may thus be handled in programmable logic with less frequency events handled by the embedded processor.

The implementation metric primitives may be used to define the requirements of the system. For example the implementation metric primitives may be used to establish performance requirements that must be met. The implementation metric primitives may be used to create constraints files e.g. timing constraint files that can be used by FPGA design tools e.g. map place route tools . The implementation metric primitives may also provide low level optimizations e.g. clock frequency requirements throughput latency requirements as well as high level optimizations e.g. optimize for area throughput latency power and the like .

The debugging primitives may be used to provide debugging capabilities. The debugging primitives may be used to capture simulated data associated with the soft platform architecture. For example instead of presenting signal waveforms to the designer the debugging primitives allow for data presentation in a more abstracted form. The debugging primitives also provide lower level functions through the use of tags or commands that cause the circuitry to be modified and operate in a debug mode.

Appendix C shows exemplary XML code that defines interface logic for a logic block or core referred to as Aurora which may be used to drive the soft platform architecture described herein. The Aurora interface available from Xilinx of San Jose Calif. is implemented as external intellectual property for point to point communication over multi gigabit transceivers. The first set of signals clk reset RXN RXP TXN and TXP represent the signals that connect to the external environment. In this example the data lines would be tied to serial transceivers. The port labeled rx is the receive port and has several signals associated therewith. Similarly the port labeled tx is the transmit port and also has several signals associated therewith.

Within each port is a clock associated therewith. The clock determines the clock domain. In the present example both rx and tx ports have an output clock. Thus the IP function block has circuitry to generate a clock signal. This clock would drive all threads in the determined clock domain. Alternatively a useclk tag may be used if the IP block does not generate a clock signal. The clock that drives the port is also used to drive other threads in the clock domain.

Appendix D illustrates an exemplary XML code of a PIP thread that handles the receive side connection to the Aurora interface defined in Appendix C. The PIP thread reads data from the receive port of the Aurora interface and stores the data in a buffer. The protocol for the interface includes flags marking the state of a frame end of frame and whether data is valid. The data valid RXSourceReadyBar signal allows the stream to pause. The PIP thread waits until the entire frame has been received before committing the frame to memory. Committing the frame to memory is an indicating mechanism informing the buffer that an entire frame is in memory. This ensures that other blocks of logic that read from the memory do not process a partial frame.

Line 2 of Appendix D illustrates that the PIP thread connects to the A port of a memory named a2e buf. Line 3 of Appendix D shows that the PIP thread also connects to the rx port of the interface block named Aurora as shown in Appendix C . Lines 4 8 of Appendix D define the variables of the PIP thread. In the present example only internal variables are shown but variables may also be defined to connect to other threads.

Appendix E illustrates exemplary XML code for effecting an explicit connection. A thread named sender having an output named myout is defined. Threads named receiver  and receiver  each with an input named myin are also defined. The defined connection will connect the output of the sender thread with the two input ports of the receiver threads.

While the foregoing describes exemplary embodiment s in accordance with one or more aspects of the present invention other and further embodiment s in accordance with the one or more aspects of the present invention may be devised without departing from the scope thereof which is determined by the claim s that follow and equivalents thereof. Claim s listing steps do not imply any order of the steps. Trademarks are the property of their respective owners.

