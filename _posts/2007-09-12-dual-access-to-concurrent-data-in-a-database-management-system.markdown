---

title: Dual access to concurrent data in a database management system
abstract: Various embodiments include one or more of systems, methods, software, and data structures that allow dual access to concurrent data in a database management system including uncommitted updated data. Some embodiments include a dual snapshot of data in a multi-version concurrency control style database, but the embodiments described herein are equally applicable to virtually any other type of database and database management system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930274&OS=07930274&RS=07930274
owner: SAP AG
number: 07930274
owner_city: Walldorf
owner_country: DE
publication_date: 20070912
---
Stored data under management of a database management system typically may be read in two ways. The first way of reading data is read only which is commonly utilized by users human and logical for reporting purposes. No exclusive locks on data are created when data is read in a read only fashion. The other way of reading data is read for update. When a read for update is performed an exclusive lock is placed on at least the affected data if not the entire rows or pages of data from which the data is selected. In such read for update instances other users may not access the exclusively locked data until a transaction of the read for update is terminated such as through a commit or rollback. Exclusive locking of data prevents not only other read for update transactions but also read only transactions.

As a result of data and row locking caused by read for update transactions database latency may become an issue. Although systems accessing data in a database management system may be able to perform operations on data quickly the database may not be able to keep pace in providing needed data when the data is locked. Thus database latency is often a root cause of overall system latency.

Multi version concurrency control MVCC provides a solution. MVCC systems maintain multiple versions of a record in a database management system and provide concurrent access to the database. Each user is provided with a snapshot of the database. Any changes made within that snapshot are not seen by other users of the database until the transaction has been committed.

MVCC uses time stamping incremental transaction IDs or other similar solutions to ensure a transaction does not need to wait for a locked record or other database objects by maintaining several versions of the record. Each version is given a relational identifier such as a timestamp to track relations between the concurrent data snapshots. A transaction is allowed to read the most recent committed version of a record that precedes its relational identifier.

Each time a record is edited and the change is posted to the database the database management system creates a new version of the record. All other transactions operating with the record continue see the old version as long as they do not commit. Accordingly a user accessing a given record sees the most recently committed version of the record. However the user cannot access a newer version of the record as modified in an open uncommitted read for update transaction. Such newer record versions are enclosed and isolated within their respective transactions until committed.

Various embodiments include one or more of systems methods software and data structures that allow dual access to data concurrently accessed by two or more users in a database management system including uncommitted updated data. Some embodiments include a dual snapshot of data in a multi version concurrency control style database but the embodiments described herein are equally applicable to virtually any other type of database and database management system.

Various embodiments include one or more of systems methods software and data structures that allow dual access to data concurrently accessed by two or more users in a database management system including uncommitted updated data. Some embodiments include a dual snapshot of data in a multi version concurrency control style database but the embodiments described herein are equally applicable to virtually any other type of database and database management system.

In the following detailed description reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific embodiments in which the inventive subject matter may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice them and it is to be understood that other embodiments may be utilized and that structural logical and electrical changes may be made without departing from the scope of the inventive subject matter. Such embodiments of the inventive subject matter may be referred to individually and or collectively herein by the term invention merely for convenience and without intending to voluntarily limit the scope of this application to any single invention or inventive concept if more than one is in fact disclosed.

The following description is therefore not to be taken in a limited sense and the scope of the inventive subject matter is defined by the appended claims.

The functions or algorithms described herein are implemented in hardware software or a combination of software and hardware in one embodiment. The software comprises computer executable instructions stored on computer readable media such as memory or other type of storage devices. Further described functions may correspond to modules which may be software hardware firmware or any combination thereof. Multiple functions are performed in one or more modules as desired and the embodiments described are merely examples. The software is executed on a digital signal processor ASIC microprocessor or other type of processor operating on a system such as a personal computer server a router or other device capable of processing data including network interconnection devices.

Some embodiments implement the functions in two or more specific interconnected hardware modules or devices with related control and data signals communicated between and through the modules or as portions of an application specific integrated circuit. Thus the exemplary process flow is applicable to software firmware and hardware implementations.

One or more application programs such as application software may be loaded i.e. transferred from storage into memory for execution by the system . DBMS is also loaded into memory . A user interface such as a Graphical User Interface GUI Application Programming Interface API or other interface may be used to receive user commands and data. The user interface may also serve to display or return the results of operation from the OS and application whereupon the user human or logical may supply additional inputs or terminate the session. User interface may be part of the DBMS .

The DBMS generally is a software subsystem for storing retrieving and manipulating information and stored in database tables. Information and may be records data pages data containers or other structures. Under the command of DBMS the system receives user commands and data through user interface . User interface may include a built in query surface or editor for accessing and processing database information. In some embodiments the database tables including information and may be loaded in memory to provide a memory centric database system. Such systems provide much faster data processing capabilities than he conventional disk based database system since the data does not need to move back and forth between the memory and disk storage devices.

The illustrated logical database table is a logical representation of how data is stored in a column and row fashion in a database such as a database under control of the database management system of . Such tables typically include one or more columns that make up a key to uniquely identify rows so that data of one database table may be related to another database table. When a user accesses a database table key values of one or more tables may be used to identify data to retrieve update delete or other actions.

The data of a logical database table may be stored in a storage or memory device in the form of the database table . However in some embodiments the data may be stored in data slots of data pages of data containers which equate to physical storage locations in memory or storage. A logical database table may then be linked to the physical storage using a version table .

A version table may be a hash table or a permanent table that may be utilized for data warehousing maintaining a data audit trail and other purposes. The version table typically includes an association to a database table column and row. Multiple versions of data of the table column row value may be stored in the version table . For example a number of version slots may exist in a version table . In some embodiments the number of version slots may be fixed but the number of version slots in other embodiments may only be limited by the amount of memory or storage resources available to a system such as the database management system of . In some embodiments a version table may exist for each table column row column of each database table . In other embodiments a version table may exist for each row which may also be referred to as a record of a database table . The granularity at which the version tables exists may also vary between embodiments from table to table and may be set in some embodiments as a default setting or by an administrator.

In some embodiment the version slots each include a version number i.e. V 1 V 2 V 3 etc. and a memory address or other mapping to a location where a value of the version is stored. As illustrated the mapping is represented as D CONT PAGE SLOT. This mapping refers to a data slot of a page within a container . The value of a version identified in the version table is stored in the mapped location. The mapping in some embodiments may include a physical memory address or other address that may or may not need to be translated to a physical address.

A data container may include one or more data pages that are used to store data according to an example embodiment. Each data page may be linked to other pages by pointers to establish a relationship between pages . A data page is typically memory or storage block and includes one or more data slots . A data slot is a sub block in the data page and stored an image such as a value of the data of a version. In some embodiments each data slot has an address that may be used as a record identifier RID . This RID may be used in a version table version slot .

Embodiments including version tables allow multiple values to be mapped to a single database table row and column or database record. In some embodiments multiple versions of values of a database table may be utilized to maintain multiple snapshots of data for use in servicing transactions accessing data stored in a database.

In some embodiments when a read only transaction is initiated within the database management system a snapshot of data needed by the transaction is retrieved and placed into a read only snapshot for that transaction. In other embodiments a read only instance of logical database tables is maintained in memory or storage and data may be read from the read only instance by all read only transactions. When an update is committed to an updatable instance or a stored value of data a new read only instance is created that will be used by subsequently initiated read only transactions.

Another snapshot may be taken of the data to allow updates. An updatable transaction such as a transaction including a READ FOR UPDATE query language statement may take a snapshot of currently stored values of data needed by the transaction. In some embodiments including version tables a most recent version of the data values are retrieved from data slots as identified within the mappings of the version tables . However in some embodiments when another transaction has modified a data value the updatable transaction rather than being locked from accessing a data item that is in a modified but uncommitted state the transaction may access the new uncommitted value and perform further modifications. The current transaction is typically prevented from committing the transaction until the other transaction is committed but time consuming locks are avoided. In some embodiments in the event the other transaction rolls back the modified value s the current transaction may also be forced to rollback but such instances are likely to be rare in most embodiments. In some embodiments uncommitted modified values of a first transaction may only be read by other updatable transactions if the first transaction has issued a commit statement that has not yet been executed. As a result in such embodiments if the commit is not successful other transactions modifying the same values need not be rolled back because the intention of the first transaction to commit is known. Thus rolling back of subsequent modifications is not required in such embodiments.

In such embodiments a modified uncommitted version is identified as the most recent version such as a highest version number with a timestamp of when the version was committed of NULL as is illustrated in version slot TS NULL In some embodiments read only transactions may also access such uncommitted modified data values. In some embodiments the data available to read only transactions is set by a system administrator. However in some embodiments a user may specify within a read only transaction whether to read uncommitted modified values.

Thus depending on the embodiment there may two or more snapshots of data stored in a database. In a simplified form there may be global snapshots available to all transactions. The global snapshots may include a read only snapshot that is always accessible for reading. After data modifications have been committed in updatable transactions a new global read only snapshot is created for use by subsequent read only transactions. Current global snapshots in some embodiments may also include an updatable snapshot that may be modified by transaction and always include the most recent changes even if the changes are not yet committed.

The snapshots in some embodiments include one or both of a read only snapshot and an updatable snapshot for each transaction. These snapshots may be instantiated in memory and maintained for the life of a transaction. When data is needed only for reads the read only snapshot is used. However once any modification is made to the data the updatable snapshot is used. In embodiments where version tables and data slots are utilized the modified value may be inserted into a data slot and a version slot is added or overwritten within a version table . The new version is then available to other updatable snapshots and transactions and may be further modified.

Transaction T is initiated first and reads data item X for update where X 1. In the Writer Snapshot X 1 and in the Reader Snapshot X 1. Transaction T updates X by writing X 3. The Writer Snapshot is updated so X now equals three. However Transaction T has not yet been committed so in the Reader Snapshot X still equals one.

Transactions T and T are then initialized. Transactions T and T may access both snapshots. The snapshot value for X in the Reader Snapshot is still X 1 and for the Writer Snapshot is X 3. X 3 is the value the uncommitted modified value as set by transaction T. Transaction includes another update to X and writes X 7. Transaction T is a read only transaction and utilizes the Reader Snapshot value for X of X 1 which is the most recently committed version of X. In some embodiments the X 7 Writer Snapshot as set by transaction T cannot be committed until the X 3 value of transaction T is committed. Thus there is a commit dependency between T and T. This commit dependency is discussed in detail below with regard to .

Transaction T is then initialized. Transaction T accesses the snapshots or instantiates its own snapshots. The Writer Snapshot of T includes X 7 and the Reader Snapshot of T includes X 1. Transaction T then writes X 9 to the Writer Snapshot and finishes. Transaction T is then dependent on the committal of the X values of transaction T and T. Transaction T commits first which then allows transaction T to commit. Once transaction T commits the Reader Snapshot is updated to include the value for X of X 3. Then transaction T commits and the Reader Snapshot is updated to include the value for X of X 7. In some embodiments updating the Reader Snapshot includes creating a new Reader Snapshot. In such embodiments other read only transactions accessing the original Reader Snapshot continue with the original Reader Snapshot. However subsequently initiated read only transactions access the new Reader Snapshot. Transaction T is then free to commit and the new Reader Snapshot and Writer Snapshot both include the value for X of X 9.

In some embodiments if any of the transactions after updating the value of X are rolled back all transactions that subsequently modify X are also rolled back. Thus pending transactions waiting on one or more commit dependencies to be resolved may be forced to rollback. In other embodiments if a transaction updating the value of X has not yet issued a commit other transaction may not access the updated value of X. However once a commit statement has been issued even if the commit has not yet been performed other transactions may access the modified value of X. In such embodiments if the commit is unsuccessful other transactions accessing and utilizing the modified value of X are not affected. The other transactions may continue without regard to the failed commit because the intent of the modification is known. Further detail of commit dependencies are described below with regard to .

Transaction T first performs a read for update of X 1 and modifies X to where X 3. Transaction T then performs a read for update of X 3 and writes X 7. Because T has not committed X 3 yet the update of transaction T to X is dependent upon a commit of T. This dependency is illustrated in the commit dependency branch below the table. T includes an arrow for X pointing to T to indicate the dependency.

Transaction T then performs a read for update of Y 1 and Writes Y 4. Transaction T does not modify any value for which an update is pending. Thus transaction T is included in the commit dependency branch without any dependencies. Similarly transaction T performs a read for update of Z 1 and writes Z 4. Transaction T does not modify a value for which an update is pending. Thus as with T T is included in the commit dependency branch without any dependencies. Both transactions T and T may commit their respective updated values of Y 4 and Z 4 at any time.

Transaction T performs a read of X for update of X 7 and a write of X 9. Transaction T further performs a read for update of Z 4 and writes Z 8. Transaction T must wait for transaction T to commit its value of X 7 and T to commit its value of Z 4 before it transaction T is allowed to commit its updates. The dependency of transaction T on both transactions T and T is illustrated in the commit dependency branch by the arrow from T for X to T and the arrow from T for Z to T.

The commit dependency branch illustrates the dependencies described above. Transaction T must commit its modified value X before transaction T is allowed to commit its value for X. Further T is prevented from committing its value for X until transaction T commits. Transactions T and T are free to commit at any time as they have no dependencies. However transaction T must wait for both transactions T and T to commit. Other transactions may be dependent on more than two transactions.

In the event of a rollback of a transaction some embodiments may require rolling back pending updates of dependent transactions. For example if transaction T is rolled back rather than committed Transaction T must be rolled back as well. In some embodiments in the event of a rollback a writer snapshot may be overwritten with or copied from the reader snapshot. In other embodiments however a modified value of a first transaction may only be accessed by other transactions upon receipt of an intent to commit a modified value from the first transaction such as through issuance of a commit by the first transaction. An intent to commit in such embodiments may provide other transactions one or both of the abilities to read and update the modified value. An intent to commit may remove the necessity to rollback subsequent modifications to one or more values also modified in the first transaction because the intent of the first transaction is known. Rolling back the other transactions is assumed in some embodiments to be unnecessary.

In some embodiments one or both of the first and second database query language statements may include a READ FOR UPDATE of the data. The second database query language statement may select one or more uncommitted updated data items of the first updatable transaction. Some such embodiments may further include receiving a third database query language statement to initiate a read only transaction including a read of one or more data items updated but not committed in at least one of the first and second updatable transactions. In such embodiments the read only transaction of the third database query language statement reads only committed values from the database. In some other embodiments when receiving the third database query language statement to initiate the read only transaction including a read of one or more data items updated but not committed in at least one of the first and second updatable transactions the read only transaction may read uncommitted values from the database. Thus depending on the particular embodiments a read only transaction may or may not read uncommitted updated data values from the database. However in some embodiments a read only transaction may wait for uncommitted modified values to be committed on commit time.

It is emphasized that the Abstract is provided to comply with 37 C.F.R. 1.72 b requiring an Abstract that will allow the reader to quickly ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims.

In the foregoing Detailed Description various features are grouped together in a single embodiment to streamline the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments of the inventive subject matter require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separate embodiment.

It will be readily understood to those skilled in the art that various other changes in the details material and arrangements of the parts and method stages which have been described and illustrated in order to explain the nature of the inventive subject matter may be made without departing from the principles and scope of the inventive subject matter as expressed in the subjoined claims.

