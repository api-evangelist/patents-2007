---

title: System and method for detecting file content similarity within a file system
abstract: A system and method for detecting file content similarity within a file system. The system may include a storage device configured to store a plurality of files and a file system configured to manage access to the storage device. The file system may be configured to compute a compressed size of at least a portion of a given file, and to store an indication of the compressed size in a named stream corresponding to the given file. In one specific implementation of the system, the file system may be further configured to determine a value of a file harmony metric from the compressed size of the concatenation of a first and second file and the compressed sizes of the first and second files, where the compressed sizes of the first and second files may be stored in a corresponding one of a plurality of respective named streams.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07693859&OS=07693859&RS=07693859
owner: Symantec Operating Corporation
number: 07693859
owner_city: Mountain View
owner_country: US
publication_date: 20070228
---
This application is a continuation of U.S. patent application Ser. No. 10 723 698 entitled SYSTEM AND METHOD FOR DETECTING FILE CONTENT SIMILARITY WITHIN A FILE SYSTEM filed Nov. 26 2003 now U.S. Pat. No. 7 188 118.

Computer systems often process large quantities of information including application data and executable code configured to process such data. In numerous embodiments computer systems provide various types of mass storage devices configured to store data such as magnetic and optical disk drives tape drives etc. To provide a regular and systematic interface through which to access their stored data such storage devices are frequently organized into hierarchies of files by software such as an operating system. Often a file defines a minimum level of data granularity that a user can manipulate within a storage device although various applications and operating system processes may operate on data within a file at a lower level of granularity than the entire file.

In many conventional file based computer systems files may be created destroyed and manipulated with relatively few constraints. Typically files may be arbitrarily named subject to operating system conventions and often unlimited numbers of exact copies of existing files may be made with ease subject only to available storage capacity. While such ease of data proliferation may simplify system operation for the user it may also result in inefficient use of storage devices and difficulties in data management. For example storage devoted to multiple identical copies of a given file may be redundant and therefore wasted but it may not be apparent that the copies are in fact identical. Similarly two given files may be mostly identical in content without being apparently related on the basis of e.g. file name. In some cases files may be similar in information content but encoded in different formats rendering a simple bitwise comparison of files uninformative. Generally speaking although files may be created and their content modified arbitrarily useful content relationships among various files may exist even though such relationships may not be obvious from conventional file characteristics such as file names.

Various embodiments of a system and method for detecting file content similarity within a file system are disclosed. In one embodiment the system may include a storage device configured to store a plurality of files and a file system configured to manage access to the storage device. The file system may be configured to compute a compressed size of at least a portion of a given file and to store an indication of the compressed size in a named stream corresponding to the given file.

In one specific implementation of the system the file system may be further configured to store a respective compressed size of each of the plurality of files in a corresponding one of a plurality of respective named streams to compute a compressed size of a concatenated file resulting from appending a first file to a second file and to determine a value of a file harmony metric from the compressed size of the concatenated file and the stored respective compressed sizes of the first file and the second file.

A method is also contemplated which in one embodiment may include storing a plurality of files computing a compressed size of at least a portion of a given file and storing an indication of the compressed size in a named stream corresponding to the given file. In one specific implementation the method may further include storing a respective compressed size of each of the plurality of files in a corresponding one of a plurality of respective named streams appending a first file to a second file to yield a concatenated file computing a compressed size of the concatenated file subsequent to the appending and determining a value of a file harmony metric from the compressed size of the concatenated file and the stored respective compressed sizes of the first file and the second file.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

Turning now to a block diagram of one embodiment of a storage system is shown. In the illustrated embodiment storage system includes a plurality of host devices and coupled to a plurality of storage devices and via a system interconnect . Further host device includes a system memory in the illustrated embodiment. For simplicity of reference elements referred to herein by a reference number followed by a letter may be referred to collectively by the reference number alone. For example host devices and and storage devices and may be referred to collectively as host devices and storage devices .

In various embodiments of storage system host devices may be configured to access data stored on one or more of storage devices . In one embodiment storage system may be implemented within a single computer system for example as an integrated storage server. In such an embodiment for example host devices may be individual processors system memory may be a cache memory such as a static RAM SRAM storage devices may be mass storage devices such as hard disk drives or other writable or rewritable media and system interconnect may include a peripheral bus interconnect such as a Peripheral Component Interface PCI bus. In some such embodiments system interconnect may include several types of interconnect between host devices and storage devices . For example system interconnect may include one or more processor buses not shown configured for coupling to host devices one or more bus bridges not shown configured to couple the processor buses to one or more peripheral buses and one or more storage device interfaces not shown configured to couple the peripheral buses to storage devices . Storage device interface types may in various embodiments include the Small Computer System Interface SCSI AT Attachment Packet Interface ATAPI Firewire and or Universal Serial Bus USB for example although numerous alternative embodiments including other interface types are possible and contemplated.

In an embodiment of storage system implemented within a single computer system storage system may be configured to provide most of the data storage requirements for one or more other computer systems not shown and may be configured to communicate with such other computer systems. In an alternative embodiment storage system may be configured as a distributed storage system such as a storage area network SAN for example. In such an embodiment for example host devices may be individual computer systems such as server systems system memory may be comprised of one or more types of dynamic RAM DRAM storage devices may be standalone storage nodes each including one or more hard disk drives or other types of storage and system interconnect may be a communication network such as Ethernet or Fibre Channel. A distributed storage configuration of storage system may facilitate scaling of storage system capacity as well as data bandwidth between host and storage devices.

In still another embodiment storage system may be configured as a hybrid storage system where some storage devices are integrated within the same computer system as some host devices while other storage devices are configured as standalone devices coupled across a network to other host devices . In such a hybrid storage system system interconnect may encompass a variety of interconnect mechanisms such as the peripheral bus and network interconnect described above.

It is noted that although two host devices and two storage devices are illustrated in it is contemplated that storage system may have an arbitrary number of each of these types of devices in alternative embodiments. Also in some embodiments of storage system more than one instance of system memory may be employed for example in other host devices or storage devices . Further in some embodiments a given system memory may reside externally to host devices and storage devices and may be coupled directly to a given host device or storage device or indirectly through system interconnect .

In many embodiments of storage system one or more host devices may be configured to execute program instructions and to reference data thereby performing a computational function. In some embodiments system memory may be one embodiment of a computer accessible medium configured to store such program instructions and data. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or CD ROM included in storage system as storage devices . A computer accessible medium may also include volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc that may be included in some embodiments of storage system as system memory . Further a computer accessible medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link which may be included in some embodiments of storage system as system interconnect .

In some embodiments program instructions and data stored within a computer accessible medium as described above may implement an operating system that may in turn provide an environment for execution of various application programs. For example a given host device may be configured to execute a version of the Microsoft Windows operating system the Unix operating system the Apple Macintosh operating system or another suitable operating system. Additionally a given host device may be configured to execute application programs such as word processors web browsers and or servers email clients and or servers and multimedia applications among many other possible applications.

During execution on a given host device either the operating system or a given application may generate requests for data to be loaded from or stored to a given storage device . For example code corresponding to portions of the operating system or an application itself may be stored on a given storage device so in response to invocation of the desired operation system routine or application program the corresponding code may be retrieved for execution. Similarly operating system or application execution may produce data to be stored.

Many operating system embodiments provide data and control structures for organizing the storage space provided by storage devices into files. In various embodiments the data structures may include one or more tables configured to store information such as for example the identity of each file its location within storage devices e.g. a mapping to a particular physical location within a particular storage device as well as other information about each file as described in greater detail below. Also in various embodiments the control structures may include executable routines for manipulating files such as for example function calls for changing file identity and for modifying file content as described in greater detail below. Collectively these data and control structures may be referred to herein as a file system and the particular data formats and protocols implemented by a given file system may be referred to herein as the format of the file system.

In some embodiments a file system may be integrated into the operating system such that any access to data stored on storage devices is governed by the control and data structures of the file system. Different operating systems may implement different native file systems using different formats but in some embodiments a given operating system may include a file system that supports multiple different types of file system formats including file system formats native to other operating systems. In such embodiments the various file system formats supported by the file system may be referred to herein as local file systems. Additionally in some embodiments a file system may be implemented using multiple layers of functionality arranged in a hierarchy as illustrated in .

As described above with respect to storage system of a given host device may reside in a different computer system from a given storage device and may access that storage device via a network. Likewise with respect to operating system in one embodiment a given process such as process A may execute remotely and may access storage devices over a network. In the illustrated embodiment file system includes network protocols to support access to the file system by remote processes. In some embodiments network protocols may include support for the Network File System NFS protocol or the Common Internet File System CIFS protocol for example although it is contemplated that any suitable network protocol may be employed and that multiple such protocols may be supported in some embodiments.

File system may be configured to support a plurality of local file systems. In the illustrated embodiment file system includes a VERITAS VxFS format local file system A a fast file system FFS format local file system B and a proprietary X format local file system X. However it is contemplated that in other embodiments any number or combination of local file system formats may be supported by file system . To provide a common interface to the various local file systems file system includes a virtual file system . In one embodiment virtual file system may be configured to translate file system operations originating from processes to a format applicable to the particular local file system targeted by each operation. Additionally in the illustrated embodiment operating system includes device drivers through which local file systems may access storage devices . Device drivers may implement data transfer protocols specific to the types of interfaces employed by storage devices . For example in one embodiment device drivers may provide support for transferring data across SCSI and ATAPI interfaces though in other embodiments device drivers may support other types and combinations of interfaces.

In the illustrated embodiment file system also includes filter driver . In some embodiments filter driver may be configured to monitor each operation entering file system and subsequent to detecting particular types of operations to cause additional operations to be performed or to alter the behavior of the detected operation. For example in one embodiment filter driver may be configured to combine multiple write operations into a single write operation to improve file system performance. In another embodiment filter driver may be configured to compute a signature of a file subsequent to detecting a write to that file. In still another embodiment filter driver may be configured to store information such as records or status information associated with particular files subsequent to detecting certain kinds of operations on those files as described in greater detail below. It is contemplated that in some embodiments filter driver may be configured to implement one or more combinations of the aforementioned operations including other filter operations not specifically mentioned.

It is noted that filter driver is part of file system and not an application or process within user space . Consequently filter driver may be configured to operate independent of applications and processes within the user space . Alternatively or in addition to the above filter driver may be configured to perform operations in response to requests received from applications or processes within the user space .

It is further noted that in some embodiments kernel space may include processes not shown that generate accesses to storage devices similar to user space processes . In such embodiments processes executing in kernel space may be configured to access file system through a kernel mode API not shown in a manner similar to user space processes . Thus in some embodiments all accesses to storage devices may be processed by file system regardless of the type or space of the process originating the access operation.

Numerous alternative embodiments of operating system and file system are possible and contemplated. For example file system may support different numbers and formats of local file systems or only a single local file system . In some embodiments network protocol may be omitted or integrated into a portion of operating system external to file system . Likewise in some embodiments virtual file system may be omitted or disabled for example if only a single local file system is in use. Additionally in some embodiments filter driver may be implemented within a different layer of file system . For example in one embodiment filter driver may be integrated into virtual file system while in another embodiment an instance of filter driver may be implemented in each of local file systems .

As described above file system may be configured to manage access to a plurality of files stored on storage devices . At any given time the contents of files stored on storage devices may vary widely including executable program instructions text video and audio data as well as data formatted for specific application software that may include a mixture of text numerical data and or control data specific to the application format. Generally speaking files may be said to store information encoded in numerous possible ways.

The information contained in each of any given pair of files i.e. the content of each file may be similar to varying degrees. For example immediately after a file copy operation the source file and destination file may share information content exactly and thus be exactly similar. An earlier version of a word processor document may share for example 90 of the information content of a later version of that document and may thus be 90 similar to that later version. In some cases files with dissimilar coding formats may be similar in information content. For example the information in a given document may be represented in one file as a Microsoft Word format document and in a second file as an Adobe Portable Document Format PDF document. Similarities in information content may also be present across different modes of information representation such as textual information vs. audio information. For example two files may represent the information of a given document in text form and in audio form respectively.

It is possible to determine the degree to which the information content of one file is similar to that of another regardless of encoding or mode of information representation by employing a compression algorithm. Generally speaking compression algorithms remove redundancy in an input information stream such as repeated data tokens or patterns thereby producing an output information stream that may be encoded using fewer units of information e.g. bits in a system employing binary encoding than the input stream. That is the compressed size of the information stream may generally be smaller than the native size of the information stream prior to compression. In some embodiments a compression algorithm may be completely reversible such that the original input stream may be completely reconstructed from the compressed output stream without loss of information such algorithms may be referred to as lossless compression algorithms. In other compression algorithm embodiments that may be referred to as lossy compression algorithms the input stream may not be completely reconstructed from the compressed output stream without loss of information.

In one embodiment a compression algorithm may be employed to determine the information content similarity of two files by determining the compressed size for example in bytes of each file compressed separately determining the compressed size of the joint file formed by appending one of the two files to the other and determining a ratio between the compressed size of the joint file and the sum of the compressed sizes of the individual files. For example if two files share identical information content an ideal compression algorithm may compress the joint file to a size nearly that of the size of either file compressed alone since the latter half of the joint file would be entirely redundant with the former half. In such a case the aforementioned ratio may be approximately 0.5. However if two files share no information content whatsoever the compressed size of the joint file may be approximately equal to the sum of the compressed sizes of the individual file since no additional redundancy would be present in the joint file. In this case the aforementioned ratio may be approximately 1. It is noted that such a method may be applied to determine a degree of content similarity irrespective of the manner in which the file content is encoded or whether the two files being compared share the same type of content encoding. Also it is contemplated that in various embodiments either lossless or lossy compression algorithms may be employed. More information regarding use of compression algorithms to determine similarity of information content may be found in e.g. Benedetto et al. Language Trees and Zipping vol. 88 no. 4 28 Jan. 2002. 

In the course of execution operating system and or processes may create or modify the information content of one or more files managed by file system . For example a given process such as process A may receive data input from a user or another process such as text or other data. Process A may issue a file operation such as a file write operation to cause the data to be saved in a given file. Subsequently the content of the given file may be compared against one or more other files to determine information content similarity using a compression algorithm as described above.

In one embodiment file system may be configured to compute a compressed size of at least a portion of a given file and to store the compressed size for use in determining information content similarity. illustrates one such embodiment of a file system. The embodiment of file system shown in may include those elements illustrated in the embodiment of however for sake of clarity some of these elements are not shown. In the illustrated embodiment file system includes filter driver an arbitrary number of files and a respective named stream associated with each of files . File system further includes a compression module . It is noted that a generic instance of one of files or named streams may be referred to respectively as a file or a named stream and that files and named streams may be referred to collectively as files and named streams respectively.

Files may be representative of files managed by file system . Each of files has a corresponding named stream . Each of named streams may be configured to store information about its corresponding file which may be referred to herein as metadata. In various embodiments metadata may include information such as but not limited to the file identity size ownership and file access permissions as well as a compressed size of the corresponding file as well as one or more compression dictionaries used in determining the compressed size of the file as described in greater detail below. It is noted that files and named streams may be physically stored on one or more storage devices such as storage devices of . However for purposes of illustration files and named streams are shown as conceptually residing within file system .

File system may be configured to detect and process file operations that modify the information content of a file . In the illustrated embodiment filter driver may be configured to detect various file operations received by file system and to cause such operations to be processed within file system . In one embodiment all read and write operations received by file system may pass through filter driver in the course of being serviced by file system and in some embodiments filter driver may monitor the type of operations received and store information regarding those operations within the appropriate named streams .

Compression module may be configured as a kernel mode process operating within file system as shown in although in some embodiments it is contemplated that compression module may be a kernel mode process operating externally to file system . In the illustrated embodiment compression module may be configured to scan file system at regular or irregular intervals for files that have been newly created or whose contents have been changed since a previous scan i.e. files with updated content . For example in one embodiment filter driver may store an indication such as a flag within the named stream of a given file subsequent to detecting an operation to create or modify given file . In such an embodiment compression module may scan for such indications. In another embodiment compression module may examine file modification and or file creation timestamps stored within named streams or elsewhere to detect files having updated content. In still another embodiment subsequent to detecting an operation to create or modify given file filter driver may store a record of the operation including the file identity in a history stream which may be a named stream associated directly with file system rather than with a particular file . In such an embodiment compression module may be configured to scan the history stream to detect files having changed contents.

Upon detecting a given file having updated content compression module may be configured to compute a compressed size of the given file . For example compression module may include a built in compression algorithm or it may call a routine provided by operating system via a compression library such as the zlib library. In the illustrated embodiment compression module may discard the output stream produced as result of compressing the given file and may store the resulting compressed size of file in the corresponding named stream . In some embodiments the employed compression algorithm may create a table of symbols or strings of symbols detected in the input data stream each symbol or string corresponding to a particular token appearing in the compressed output stream. Such a table may be referred to herein as a compression dictionary or simply a dictionary and such algorithms may be referred to as dictionary based algorithms. In some such embodiments compression module may store a dictionary created during compression of a given file in the corresponding named stream and may further be configured to use such a stored dictionary during subsequent compression operations on given file . It is contemplated that in some embodiments the compressed size of a given file and or the resulting compression dictionary may be stored in data storage other than a named stream. For example in one embodiment either of these items may be stored in a separate file associated with given file but not directly visible to application processes.

In addition to generating and storing compressed sizes of files subsequent to detecting file modification as just described compression module may further be configured to respond to requests to determine the similarity in information content between a given file and one or more other files . For example a user may request a determination of similarity of a document stored in a given file to each of a set of documents stored in a respective set of files or to all files stored within file system . Alternatively a kernel process which in some embodiments could be compression module itself may be configured to scan all or a portion of file system at regular or irregular intervals to determine content similarities among large numbers of files. For example a forensic application may seek to identify patterns of content similarity among files about which little else is known.

In one embodiment compression module may be configured to receive the identities of the given file and the one or more additional files to which the given file is to be compared. Compression module may append each additional file to the given file in turn to form a concatenated file and may compute a compressed size of each such concatenated file. In some embodiments compression module may be configured to also reverse the order of file concatenation compute the compressed size of the reverse concatenated file and select the smaller of the resulting compressed size or the compressed size of the original concatenated file. Compression module may further retrieve from the appropriate named streams the compressed size of the given file and each additional file previously computed and stored within those named streams as described above. If the compressed size of a particular file does not exist or is not current e.g. the particular file was created or modified subsequent to the last scan of compression module when a content similarity comparison involving that file is requested compression module may compute that file s compressed size responsive to the comparison request.

Once the compressed sizes of two files and their concatenation are available a file harmony metric may be evaluated with respect to the two files. Generally speaking a file harmony metric may be any function of the compressed file sizes and the compressed size of the concatenated files including a ratio as described previously. One exemplary file harmony metric between two files A and B is as follows 

It is noted that like filter driver compression module in the illustrated embodiment is part of file system and not an application or process within user space . Consequently compression module may be configured to operate independent of applications and processes within the user space . Alternatively or in addition to the above compression module may be configured to perform operations in response to requests received from applications or processes within the user space such as requests to determine content similarity of files. It is further noted that in the illustrated embodiment the compression and comparison activity performed by compression module as described above occurs in a processing path independent of file read and write operations processed by filter driver . That is file read and write operations processed by filter driver are not dependent on the compression and comparison activity of compression module for their completion. The compression and comparison activity may thus be described as occurring out of band with respect to file read and write operations. However it is contemplated that in an alternative embodiment the aforementioned functionality of compression module may be wholly or partly implemented by filter driver and may be implemented either out of band or in band with respect to file read and write operations. For example in an in band implementation computation of a compressed file size may occur as part of a file write operation whereby the write operation may not complete until the compressed file size is computed. It is further contemplated that in some embodiments the functionality of compression module may be implemented entirely within a different software module of file system or among multiple different software modules.

Subsequent to detection of a modified file a compressed size of the modified file may be computed block . As described above in one embodiment compression module may be configured to compute the compressed size of the detected modified file. Once the compressed size has been computed an indication of the compressed size such as its value in bytes for example may be stored in a named stream corresponding to the file block . As previously noted in one embodiment compression module may perform the storing and in some embodiments employing dictionary based compression algorithms compression module may also store the resulting compression dictionary in the named stream corresponding to the modified file .

The method of may be configured to operate in parallel with the method of in some embodiments. For example in one embodiment compression module may be configured to perform compression on one file while computing a file harmony metric with respect to that file or a different file. Referring collectively to through and operation begins in block where a request to determine the similarity in file content of two or more files is detected. For example such a request could originate from a user process A in response to a user request from a kernel process configured to scan part or all of file system for content similarity patterns as described above or from another source. In some embodiments one or more files may be compared for similarity in file content to one or more other files in a pairwise fashion while in other embodiments multiple files may be compared simultaneously according to the specific formulation of the file harmony metric as described above.

Subsequent to detecting such a request the compressed sizes of the files subject to the request may be retrieved from the named streams corresponding to those files block . For example in one embodiment compression module may retrieve previously computed compressed sizes of the files subject to the request from named streams .

In some instances one or more compressed sizes corresponding to respective files may not be current or may not exist within named streams . For example a given file may have been modified since its compressed size was last computed or created after compression module last scanned file system . For simplicity of explanation a nonexistent compressed size is understood to be not current in the illustrated embodiment. The retrieved compressed sizes may therefore be checked to determine if they are current block such as by checking flags timestamps or some other mechanism as discussed above. If for any file a compressed size is determined to be not current a current compressed size may be computed for that file block . It is contemplated that in some embodiments whether a compressed size is current as in block may be determined prior to retrieving compressed sizes from named streams as in block . In such embodiments compressed sizes may be retrieved from named streams only for files for which compressed sizes are determined to be current which may reduce the number of accesses to named streams.

In the illustrated embodiment subsequent to compressed sizes of individual files being retrieved from named streams and or recomputed as appropriate the concatenation of each file with each other file subject to the request may be formed by appending each such file to each such other file. Such concatenation may be performed on pairs of files or greater numbers of files depending on the formulation of the file harmony metric as described previously. Additionally the compressed size of each such concatenation may be computed block . For example compression module may be configured in one embodiment to perform the appropriate concatenations of the files subject to the request and to compute compressed sizes of the resulting concatenations. It is contemplated that in some embodiments this step may be performed prior to or in parallel with the steps of retrieving compressed sizes of files from named streams determining their currency and recomputing compressed sizes as needed as illustrated in blocks . It is further contemplated that in some embodiments this step may further include reversing or permuting if more than two files are referenced in the file harmony metric the order of each concatenation computing a compressed size of each reversed or permuted order concatenation and selecting the smallest compressed size of the various concatenations.

Once compressed sizes for each individual file subject to the request as well as compressed sizes for each appropriate concatenation of such files are available a value of a file harmony metric may be computed block . For example in one embodiment compression module may evaluate the FileHarmony A B metric given above. In some embodiments where multiple pairs or larger sets of files are being compared a value of a file harmony metric may be determined for each such pair or set. For example in one embodiment compression module may be configured to determine similarity in content of a given file to each of a set of files and may determine a value of a file harmony metric for each pairing of the given file with each of the set of files.

As described above when the contents of a given file are modified a previously computed compressed size corresponding to that file may no longer be valid and may consequently be recomputed. Depending on the compression algorithm employed and the size of the file the computational effort required to determine the compressed size of an entire file may be substantial. In one embodiment file system may be configured to reduce the average computational effort required to determine the compressed sizes of files by logically partitioning those files into portions which may also be referred to herein as chunks.

In one embodiment the chunks included in file may be of a uniform size. For example each chunk may represent a 64 megabyte MB portion of file although other sizes may be used in various embodiments. If file is not an integral multiple of the chunk size the final chunk i.e. chunk N may be smaller than the uniform chunk size in some embodiments whereas in other embodiments null data may be appended to the final chunk to render file an integral multiple of the uniform chunk size. In the illustrated embodiment the chunks included in file may be ordered such that chunk corresponds to the first portion of file i.e. the portion starting at the beginning of file chunk corresponds to the portion of file contiguously following chunk and so on.

In an embodiment of file system that logically organizes files into chunks such as illustrated in the operation of compression module may be modified to utilize file chunks. In one embodiment compression module may be configured to store a compression dictionary as well as a cumulative compressed size corresponding to each chunk of a given file in a corresponding named stream . Further in one embodiment a given dictionary corresponding to a particular chunk of a file may include all dictionaries corresponding to lower ordered chunks of the file . That is dictionary N may include the contents of dictionaries through N 1. In one embodiment compression module may be configured to produce such a set of cumulative or inclusive dictionaries and cumulative compressed sizes by storing its current working compression dictionary and the current compressed file size when a chunk boundary is encountered during compression of file . For example when compression module determines the compressed size of file for the first time it may begin operating at the beginning of file building a compression dictionary as it progresses. Upon reaching the end of chunk compression module may store its current working compression dictionary and the current working compressed file size in named stream as dictionary and CCS respectively. Compression module may then continue processing file continuing to augment its working compression dictionary and update its working compressed file size as additional input data is encountered and upon reaching the end of chunk may store its current working compression dictionary which includes the dictionary symbols corresponding to both chunks and and current working compressed file size which includes the compressed sizes of both chunks and in named stream as dictionary and CCS respectively. Processing may continue in a similar fashion until the end of file is reached at which point compression module may store the final working compression dictionary in named stream as dictionary N and may also store the final computed compressed size of file in named stream .

It is also contemplated that in an alternative embodiment the dictionaries stored in named stream may not be cumulative as described above. Rather in such an embodiment compression module may be configured to store in a dictionary corresponding to a given chunk only symbols that have been added to the working compression dictionary since the last chunk boundary was encountered. For example upon encountering the end of a given chunk K compression module may store as dictionary K only the symbols that have been added to its current working compression dictionary since the end of chunk K 1 was encountered.

When content of a file organized into logical chunks is modified such as due to a file write operation file system may be configured to determine which logical chunk or chunks have been modified. For example in one embodiment filter driver may be configured to detect a file write operation to a given file . Such a file write operation may include the offset into file at which the write operation is to modify the contents of given file i.e. the distance from the beginning of given file in terms of bytes blocks or some other metric . Given the size of each chunk of given file and the offset of a file write operation into given file filter driver may determine the number of the first chunk modified by the file write operation such as an arbitrary chunk K. Additionally given the length of the file write operation filter driver may determine the number of the last chunk modified by the file write operation if desired.

Once the first modified chunk of a given file has been determined in one embodiment file system may be configured to invalidate the dictionary corresponding to the first modified chunk stored in corresponding named stream . File system may also be configured to invalidate dictionaries corresponding to higher ordered chunks. For example in one embodiment each dictionary stored within a named stream may include a valid flag such as a bit or another field defined by the file system architecture that may be asserted when the respective dictionary is stored by compression module . In such an embodiment filter driver may be configured to deassert the valid flag of the dictionary K corresponding to the first modified chunk K as well as the valid flags of subsequent dictionaries K 1 through N. It is contemplated that in other embodiments other mechanisms for invalidating dictionaries may be employed. In one embodiment the data structures used to indicate validity of a given stored dictionary may be stored outside of the named stream including those dictionaries such as within filter driver or another part of file system for example.

Subsequent to modification of given file and invalidation of the appropriate dictionaries compression module may detect the file modification as described previously. For example in one embodiment compression module may detect an updated timestamp corresponding to given file a modified flag stored within corresponding named stream or some other mechanism. Upon detecting the modification of given file compression module may be configured to recompute its compressed size. In one embodiment rather than applying a compression algorithm starting at the beginning of the modified file compression module may be configured to determine the last chunk of the modified file for which a valid dictionary exists such as by examining the valid flags of the dictionaries. For example if the first modified chunk of given file is chunk K and dictionaries K through N are invalid chunk K 1 may be the last chunk for which a valid dictionary exists. After determining the last valid dictionary compression module may be configured to initialize the current working compression dictionary of its compression algorithm from that dictionary in embodiments where each given directory cumulatively includes each lower ordered dictionary as described above or from the set of dictionaries up to and including the last valid dictionary in embodiments where dictionaries are not inclusive as described above . Compression module may also initialize its current working compressed file size from the CCS field corresponding to the last valid dictionary. Subsequent to such initialization compression module may be configured to then recompute the compressed file size beginning with the first modified chunk K storing updated dictionaries and cumulative compressed file sizes in dictionaries K through N and CCS K through N 1 respectively.

It is noted that in such an embodiment compressed sizes for chunks through K 1 are not recomputed thereby potentially reducing the computational effort required to recompute the compressed size of given file following its modification. It is also noted that if chunk of given file is modified no valid dictionaries may exist and compression module may begin recomputing the compressed file size from chunk with a default initial dictionary such as a null dictionary for example.

In one embodiment employing the aforementioned chunk based compression techniques computation of the compressed size of a given file may be accomplished during multiple processing intervals that need not be contiguous. In such an embodiment compression module may be configured to pause suspend or otherwise allow computation of the compressed size of a given file to be interrupted before all dictionaries and the final compressed size of given file have been computed and stored. For example during a period of high file system or other processing activity the activity of compression module may be paused to allow more computational resources to be allocated to other processing activity. In such an embodiment compression module may be configured to indicate that its processing of given file is not complete such as by storing an indication in corresponding named stream . Alternatively compression module may be configured to scan file system for files with invalid dictionaries when it scans for modified files as described previously. In some embodiments compression module may be configured to prioritize the completion of interrupted compression processing over other types of operations such as computing the compressed sizes of newly modified files. In other embodiments different prioritization schemes may be used.

It is noted that in some embodiments the organization of files into logical chunks may exist in addition to other types of logical and physical organizations of files . For example operating system may implement a page based virtual memory system in which storage devices may be organized into virtual and physical pages in addition to logical chunks. Similarly individual storage devices may be physically organized into sectors that may differ among individual devices. Consequently in some embodiments a given file may be processed as a plurality of logical chunks for the purpose of determining a compressed file size as described above a plurality of pages for purposes of virtual memory processing and a plurality of sectors for purposes of physically accessing the file contents on a particular storage device.

Subsequently the modified file may be detected block . In one embodiment compression module may scan the contents of file system to detect modified files by examining file modification timestamps or modification flags set by filter driver during the file write operation or examining stored compression dictionaries for validity for example. Upon detecting the modified file the last valid compression dictionary may be determined block and the last valid compression dictionary and an associated cumulative compressed file size may be used to initialize a compression algorithm with the current working chunk of the compression algorithm initialized to the first modified chunk of the modified file block . For example in one embodiment compression module may examine the dictionaries stored in named stream corresponding to a given modified file to determine the last valid compression dictionary and may initialize its current working compression dictionary and current working compressed file size from the last valid compression dictionary and the corresponding stored CCS value. In embodiments where dictionaries stored in named stream are not inclusive compression module may initialize its current working compression dictionary from the set of stored dictionaries up to and including the last valid compression dictionary.

Subsequent to initialization computation of the compressed size of given file may be interrupted block . For example a higher priority system activity may occur and compression module may detect the higher priority activity or may receive a software interrupt generated by such an activity. It is noted that in some embodiments compressed size computation may be interrupted at any point subsequent to detection of the modified file in block however for simplicity of illustration such an interruption is shown only after the initialization step.

If an interruption occurs computation of the compressed size of modified given file may be suspended block and processing may resume at a later time from block for example when the interrupting activity ceases and given file is again detected to be modified by compression module . If no interruption has occurred processing may proceed from the current working chunk of given file and a compression dictionary and a cumulative compressed size corresponding to the current working chunk of given file may be computed and stored block . For example in one embodiment compression module may be configured to compress the current working chunk K of given file and upon reaching the end of the current working chunk K to store the current working compression dictionary and current working compressed size within named stream as dictionary K and CCS K respectively. Alternatively compression module may be configured to store only the difference between the current working compression dictionary and the previously stored dictionary as dictionary K.

Subsequent to processing the current working chunk the current working chunk may be tested to determine whether it is the final chunk of the file block . If so the final compressed size of the file may be stored and processing of given file may terminate block . For example compression module may be configured to store the current working compressed size in named stream as the compressed size of given file . If the current working chunk is not the final chunk of the file the next chunk may be selected as the current working chunk block and processing may proceed to block where an interruption may be detected although as noted above in some embodiments an interruption may be detected at any aforementioned processing step.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

