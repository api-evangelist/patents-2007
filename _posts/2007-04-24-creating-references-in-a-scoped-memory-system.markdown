---

title: Creating references in a scoped memory system
abstract: A method for creating a reference in a scoped memory system, the scoped memory system including a scope graph of scoped memory areas, wherein each scoped memory area is suitable for the allocation of objects therein for access by software threads and has associated a thread count for indicating that the scoped memory area is discardable, the method comprising the steps of: allocating a target object in a target scoped memory area; storing an index associated with the target object of a depth of the target scoped memory area in the scope graph; allocating a source object in a source scoped memory area; storing an index associated with the source object of a depth of the source scoped memory area in the scope graph; in response to a determination that the source scoped memory area is at the same depth as or deeper than the target scoped memory area by comparing the index associated with the source object and the index associated with the target object, creating a reference from the target object to the source object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08140598&OS=08140598&RS=08140598
owner: International Business Machines Corporation
number: 08140598
owner_city: Armonk
owner_country: US
publication_date: 20070424
---
The present invention relates to the creation of a reference in a scoped memory system. More particularly it relates to reducing processing overhead during the creation of a reference.

Scoped memory areas are areas of memory suitable for the allocation and deallocation of objects without some of the disadvantages of garbage collected heaps. A software thread can enter a scoped memory area and all object allocations by the thread will then be made within the scoped memory area. The thread can also enter multiple scoped memory areas in a nested fashion. For example the thread can enter a second scoped memory area which becomes the default allocation area. Scoped memory areas are organised in a scope graph with each scoped memory area having a parent being the previously entered scoped memory area. A first scoped memory area has a primordial scoped memory area as its parent.

A thread count is maintained for each scoped memory area of a number of active threads in the area. The thread count coupled with the scope graph indicates when a scoped memory area including any objects allocated in the scoped memory area is discardable. For example a scoped memory area may be discardable when an associated thread count is decremented from one to zero and the scoped memory area is not a parent for any other scoped memory area. In this way scoped memory areas offer alternative allocation spaces for objects in an otherwise garbage collected object oriented environment such as Java Java is a registered Trademark of Sun Microsystems . The use of such scoped memory areas can address the problem of delays in application execution caused by garbage collection algorithms since all objects in scoped memory areas become discardable at the same time defined in terms of thread usage of the memory area and the organisation of a scope graph.

A first object in a first scoped memory area can reference a second object in a second scoped memory area. However since individual scoped memory areas can become completely discardable it is necessary to enforce strict rules regarding valid and invalid references between objects in different scoped memory areas. These rules are necessary to guarantee that a parent scoped memory area has a lifetime that is at least that of its child scoped memory areas so that objects in descendant memory areas can reliably reference objects in ancestor memory areas. In this way dangling references can be avoided. This is described in Efficient Memory Reference Checks for Real time Java Corsaro and Cytron ACM SIGPLAN Volume 38 Issue 7 Jul. 2003 .

One such rule is that a scoped memory area has at most one parent. This is known as the single parent rule . The single parent rule provides that the order of entry into scoped memory areas by different threads is always the same because the order of entry of threads into scoped memory areas defines the structure of the scoped memory areas in the scope graph. Further a source object allocated in a source scoped memory area can only reference target objects in the same or ancestral scoped memory areas. An ancestral scoped memory area is a memory area which is entered by a thread before the source scoped memory area. The source scoped memory area is said to have inner scope with respect to that of the target object. This criterion ensures that the source object will always be de allocated before the target object. Attempts to create references which do not satisfy the criterion must fail according to the Real Time Specification for Java Bollella et al Addison Wesley 2000 . Thus the criterion must be checked in an efficient manner whenever a new reference to a target object is created.

One way to determine whether this criterion is satisfied for the creation of a reference between objects is to iterate through scoped memory areas in a scope graph. Iteration starts at the source scoped memory area and progresses through each parent scoped memory area checking for the target scoped memory area. If the target scoped memory area is encountered within the scope graph during the iterations then it can be concluded that the criterion is satisfied because the target area is an ancestor of the source area. If the iterations reach the primordial scoped memory area the root of the scope graph then it can be concluded that the criterion is not satisfied because the target scoped memory area is not an ancestor of the source scoped memory area.

An alternative approach is to determine an index of the distance between the scoped memory area of the target object and the primordial scoped memory area. This distance can be considered to be a depth of the target scoped memory area. Additionally an index of the distance between the scoped memory area of the source object and the primordial scoped memory area can be determined as a depth of the source scope. The term depth here is used to indicate that scoped memory areas exist at levels which are some distance from the primordial scoped memory area. Deeper scoped memory areas are located at a level in the scope graph which is further from the primordial scoped memory area. A comparison of these indices of depth will determine whether the target scoped memory area is an ancestor of the source scoped memory area because descendent areas will always be deeper further from the primordial scoped memory area than ancestor areas. Thus if the source scoped memory area is deeper than the target scoped memory area then the criterion is satisfied and a reference can be created.

While these approaches may be effective in applying the criterion for the creation of new references they involve time consuming iterations through a scope graph at the point of reference creation. These iterations are required either to scan the entire scope graph for the target scoped memory area or to determine the depth indices.

Thus it would be advantageous to determine whether the rule that a source object allocated in a source scoped memory area can only reference target objects in ancestral scoped memory areas is satisfied without requiring undesirably high processing overhead due to iterations through a scope graph.

The present invention accordingly provides in a first aspect a method for creating a reference in a scoped memory system the scoped memory system including a scope graph of scoped memory areas wherein each scoped memory area is suitable for the allocation of objects therein for access by software threads and has associated a thread count for indicating that the scoped memory area is discardable the method comprising the steps of allocating a target object in a target scoped memory area storing an index associated with the target object of a depth of the target scoped memory area in the scope graph allocating a source object in a source scoped memory area storing an index associated with the source object of a depth of the source scoped memory area in the scope graph in response to a determination that the source scoped memory area is at the same depth as or deeper than the target scoped memory area by comparing the index associated with the source object and the index associated with the target object creating a reference from the target object to the source object.

Thus the storage of an index of the depth of a scoped memory area associated with an object allocated in the scoped memory area at the time of creation of the object it is not necessary to undertake to determine the depth of the scoped memory area at the time of creation of a reference. In this way the arduous iterations of the prior art in checking for satisfaction of the criteria for scoped memory systems when creating a reference between scoped memory areas are avoided. In this way processing overhead during the creation of a reference is reduced.

Preferably the step of creating a reference from the target object to the source object is further responsive to a determination that the target scoped memory area and the source scoped memory area lie in a common branch of the scope graph.

The present invention accordingly provides in a second aspect an apparatus for creating a reference in a scoped memory system the scoped memory system including a scope graph of scoped memory areas wherein each scoped memory area is suitable for the allocation of objects therein for access by software threads and has associated a thread count for indicating that the scoped memory area is discardable the apparatus comprising means for allocating a target object in a target scoped memory area means for storing an index associated with the target object of a depth of the target scoped memory area in the scope graph means for allocating a source object in a source scoped memory area means for storing an index associated with the source object of a depth of the source scoped memory area in the scope graph means for in response to a determination that the source scoped memory area is at the same depth as or deeper than the target scoped memory area by means for comparing the index associated with the source object and the index associated with the target object creating a reference from the target object to the source object.

The present invention accordingly provides in a third aspect an apparatus comprising a central processing unit a memory subsystem an input output subsystem and a bus subsystem interconnecting the central processing unit the memory subsystem the input output subsystem and the apparatus as described above.

The present invention accordingly provides in a fourth aspect a computer program element comprising computer program code to when loaded into a computer system and executed thereon cause the computer to perform the steps of the method described above.

Scoped memory area is a defined area of memory in storage suitable for the allocation and reference of software objects hereinafter referred to as objects . Objects can be allocated and accessed in an allocated objects part of the scoped memory area by software threads which execute in the context of the scoped memory area . The scoped memory area further includes a thread count as a count of a number of software threads executing in the context of the scoped memory area . A thread executes in the context of the scoped memory area by explicitly entering the scoped memory area such as by calling of an application programming interface function. Once a thread has entered the scoped memory area allocations of objects will be undertaken within the scoped memory area unless specifically allocated elsewhere by the thread such as in the general heap or another scoped memory area.

Scoped memory area further includes a parent field which includes a reference to a parent scoped memory area. As described above a scoped memory area has at most one parent. An arrangement of scoped memory areas defined by way of a parental relationships therebetween defines the scope graph . An initial scoped memory area having no particular parent will refer to a primordial scoped memory area as its parent by way of a placeholder.

Thus illustrates by way of example only a possible arrangement of scope graph arising due to the behaviour of software threads in entering scoped memory areas during execution. Notably each scoped memory area can be viewed as being aligned at a particular distance through the scope graph from the primordial scoped memory area . For example scoped memory area A is at a level which is in closest proximity to the primordial scoped memory area. Scoped memory area B is at a level . Scoped memory areas C and D are both at a level and scoped memory areas E and F are both at a level . These levels to can be considered to be depths within the scope graph and represent a distance of a scoped memory are from the primordial scoped memory area . Level and scoped memory area A is the least deep level within the scope graph because it is in closest proximity to the primordial scoped memory area whilst level and scoped memory areas E and F is the deepest level.

The criterion for the operation of a scoped memory system described above that a source object allocated in a source scoped memory area can only reference target objects in the same or ancestral scoped memory areas can be described in terms of the depth of a scoped memory area within the scope graph . In these terms the criterion is that a source object can only reference a target object where the depth of the source scoped memory area containing the source object is the same as or deeper than the depth of the target scoped memory area containing the target object.

The depth indices and can be determined at the time of allocation of the objects and respectively. This early determination is possible because the depths of a scoped memory areas cannot change during the life of an object allocated within that area due to the single parent rule of scoped memory systems which requires that the a scoped memory area retains the same position within a scope graph until it is discardable. For example the depth of the source scoped memory area cannot change during the life of the source object . Thus in this way a determination of the depth of the source and target scoped memory areas and can be made as part of the object allocation process for objects and . It is therefore not necessary to undertake such arduous determination at a later stage such as at the point of reference creation.

Step can alternatively include additional steps such as steps to determine that the target scoped memory area is an ancestor of in the parentage of the source scoped memory area before allowing the creation of the reference. This ancestral relationship between the source and target scoped memory areas can be determined where the source and target scoped memory areas lie in a common branch of the scope graph where the scope graph is branched . For example referring to scoped memory areas F and C lie in a common branch of the scope graph because there is an ancestral relationship between them scoped memory area C is the parent of scoped memory area F . However scoped memory area F and scoped memory area D do not lie in a common branch because scoped memory area D is not an ancestor of scoped memory area F and vice versa.

By way of the storage of an index of the depth of a scoped memory area associated with an object allocated in the scoped memory area at the time of creation of the object it is not necessary to undertake to determine the depth of the scoped memory area at the time of creation of a reference. In this way the arduous iterations of the prior art in checking for satisfaction of the criteria for scoped memory systems when creating a reference between scoped memory areas are avoided.

Insofar as embodiments of the invention described are implementable at least in part using a software controlled programmable processing device such as a microprocessor digital signal processor or other processing device data processing apparatus or system it will be appreciated that a computer program for configuring a programmable device apparatus or system to implement the foregoing described methods is envisaged as an aspect of the present invention. The computer program may be embodied as source code or undergo compilation for implementation on a processing device apparatus or system or may be embodied as object code for example.

Suitably the computer program is stored on a carrier medium in machine or device readable form for example in solid state memory magnetic memory such as disk or tape optically or magneto optically readable memory such as compact disk or digital versatile disk etc and the processing device utilises the program or a part thereof to configure it for operation. The computer program may be supplied from a remote source embodied in a communications medium such as an electronic signal radio frequency carrier wave or optical carrier wave. Such carrier media are also envisaged as aspects of the present invention.

It will be understood by those skilled in the art that although the present invention has been described in relation to the proceeding example embodiments the invention is not limited thereto and that there are many possible variations and modifications which fall within the scope of the invention.

The scope of the present invention includes any novel features or combination of features disclosed herein. The applicant hereby gives notice that new claims may be formulated to such features or combination of features during prosecution of this application or of any such further applications derived therefrom. In particular with reference to the appended claims features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the claims.

For the avoidance of doubt the term comprising as used herein throughout the description and claims is not to be construed as meaning consisting only of .

