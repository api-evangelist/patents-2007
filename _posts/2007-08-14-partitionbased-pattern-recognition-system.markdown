---

title: Partition-based pattern recognition system
abstract: Methods, apparatuses and systems directed to pattern identification and pattern recognition. In some particular implementations, the invention provides a flexible pattern recognition platform including pattern recognition engines that can be dynamically adjusted to implement specific pattern recognition configurations for individual pattern recognition applications. In some implementations, the present invention also provides for a partition configuration where knowledge elements can be grouped and pattern recognition operations can be individually configured and arranged to allow for multi-level pattern recognition schemes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07966277&OS=07966277&RS=07966277
owner: Neural ID LLC
number: 07966277
owner_city: San Mateo
owner_country: US
publication_date: 20070814
---
The present application claims priority to U.S. Provisional Application Ser. Nos. 60 837 824 and 60 837 825 both filed on Aug. 14 2006 both of which are incorporated by reference herein.

The present disclosure relates to pattern identification and pattern recognition including for example machine vision and surveillance using computer vision.

Pattern recognition involves classification of data patterns based on either a priori knowledge or on statistical information extracted from the patterns. The patterns to be classified are usually groups of measurements or observations vectors defining points in a multidimensional space. A pattern recognition system may include a sensor that gathers the observations to be classified or described a feature extraction mechanism that computes numeric or symbolic information from the observations and a classification or description scheme that performs the actual function of classifying or describing observations relying on the extracted features.

The classification or description scheme is usually based on the availability of a set of patterns that have already been classified or described. This set of patterns is termed the training set and the resulting learning strategy is characterized as supervised learning. Learning can also be unsupervised in the sense that the system is not given an a priori labeling of patterns instead it establishes the classes itself based on the statistical regularities of the patterns.

A wide range of algorithms can be applied for pattern recognition from very simple Bayesian classifiers to neural networks. An artificial neural network ANN often just called a neural network NN is an interconnected group of artificial neurons that uses a mathematical model or computational model for information processing based on a connectionist approach to computation. An ANN can be an adaptive system that changes its structure based on external or internal information that flows through the network. Artificial neural networks can be used to model complex relationships between inputs and outputs or to find patterns in data. For many years academia and industry have been researching pattern recognition based on artificial neural networks. However this research has yielded very few practical real world applications.

Typical applications for pattern recognition are automatic speech recognition classification of text into several categories e.g. spam non spam email messages the automatic recognition of handwritten postal codes on postal envelopes or the automatic recognition of images of human faces. The last two examples form the subtopic image analysis of pattern recognition that deals with digital images as input to pattern recognition systems.

Programmable logic devices PLDs are a type of digital integrated circuit that can be programmed to perform specified logic functions. One type of PLD the field programmable gate array FPGA typically includes an array of configurable logic blocks CLBS surrounded by a ring of programmable input output blocks IOBs . Some FPGAs also include additional logic blocks with special purposes Digital Signal Processing DSP blocks Random Access Memory RAM blocks Phase Lock Loops PLL and so forth . FPGA logic blocks typically include programmable logic elements such as lookup tables LUTs flip flops memory elements multiplexers and so forth. The LUTs are typically implemented as RAM arrays in which values are stored during configuration i.e. programming of the FPGA. The flip flops multiplexers and other components may also be programmed by writing configuration data to configuration memory cells included in the logic block. For example the configuration data bits can enable or disable elements alter the aspect ratios of memory arrays select latch or flip flop functionality for a memory element and so forth. The configuration data bits can also select interconnection between the logic elements in various ways within a logic block by programmably selecting multiplexers inserted in the interconnect paths within CLB and between CLBs and IOBs.

The present invention provides methods apparatuses and systems directed to pattern identification and pattern recognition. In some particular implementations the invention provides a flexible pattern recognition platform including pattern recognition engines that can be dynamically adjusted to implement specific pattern recognition configurations for individual pattern recognition applications. In some implementations the present invention also provides for a partition configuration where knowledge elements can be grouped and pattern recognition operations can be individually configured and arranged to allow for multi level pattern recognition schemes. In some implementations the present invention provides a concurrent or near concurrent matching system providing real time pattern identification and recognition via a parallel or nearly parallel architecture. In one implementation the present invention provides a virtual pattern recognition system where virtual decision elements map to a smaller number of physical implementers or physical decision elements that operate in parallel. In some implementations the system is also data agnostic and can handle any type of data image video audio chemical text binary etc. . Still further some implementations provide systems capable of providing proximity fuzzy recognition or exact matching via a recognition engine which is autonomous once it has been taught.

Generally pattern recognition involves generation of input vectors potentially through feature extraction and comparison of the input vectors to a set of known vectors that are associated with categories or identifiers. One finds example logic for pattern identification and pattern recognition in the following five patents whose disclosures are hereby incorporated by reference U.S. Pat. Nos. 5 621 863 5 701 397 5 710 869 5 717 832 and 5 740 326.

A vector in one implementation is an array or 1 dimensional matrix of operands where each operand holds a value. Comparison of an input vector to a known vector generally involves applying a distance calculation algorithm to compute the individual distances between corresponding operands of the input vector and the known vector and in accordance to the distance calculation algorithm in use to combine in some fashion the individual distances to yield an aggregate distance between the input vector and the known vector s . How the aggregate distances are used in recognition operations depends on the comparison technique or methodology used to compare input vectors to known vectors. There are a variety of ways to compare vectors and to compute aggregate distance. In some implementations the resulting aggregate distance may be compared to a threshold distance such as in the case of Radial Basis Functions . In other implementations the aggregate distance can be used to rank the respective matches between the input vector and the known vectors such as in the case of K Nearest Neighbors KNN . Selection of vector layout comparison techniques and or distance computation algorithms may affect the performance of a pattern recognition system relative to a variety of requirements including exact or proximity matching overall accuracy and system throughput.

Using pattern identification and recognition it is possible to recognize unknowns into categories. A system can learn that multiple similar objects as expressed by one or more vectors are of a given category and can recognize when other objects are similar to these known objects. In some implementations input vectors having known categories can be provided to a pattern recognition system to essentially train the system. In a particular implementation a knowledge element is at a minimum a combination of a vector and an associated category. As discussed in more detail below a knowledge element may include other attributes such as arbitrary user data and influence field values. The knowledge elements may be stored in a memory space or knowledge element array which as discussed below may be partitioned in a configurable manner. A knowledge map is a set of knowledge elements. In some implementations a knowledge element in addition to defining a vector and a category may further be instantiated as a physical processing element Implemented for example in a logic processing unit of a Field Programmable Gate Array FPGA that encapsulates processing logic that returns a match result in response to an input data vector.

Data vectors form the basis for the knowledge elements stored in the knowledge map as their operands are the coordinates for the center of the element in n dimensional space. These data vectors can be derived from analog data sources such as sensors or can be based on existing digital data computer database fields network packets etc. . In the case of all analog data sources and some digital data sources one or more feature extraction processes or techniques can be used in order to provide a data vector compatible with the knowledge map used by the pattern recognition system.

Pattern recognition systems can determine the category of an unknown object when it is exactly the same or close to objects they already know about. With a Radial Basis Functions RBF based or similar technique for example it is possible for a machine to recognize exact patterns compared with the existing knowledge or similar close patterns given the objects defined by knowledge elements in the knowledge map. Further the systems can expand their knowledge by adding a new instance of a knowledge element in a category as defined by one or more input vectors if it is sufficiently different from existing knowledge elements in that category.

For didactic purposes pattern recognition using Radial Basis Functions RBFs is described. As disclosed in the patents identified above there exists a class of algorithms termed Radial Basis Functions RBFs . RBFs have many potential uses one of which is their use in relation to Artificial Neural Networks ANNs which can simulate the human brain s pattern identification abilities. RBFs accomplish their task by mapping learning training a knowledge instance knowledge vector to the coordinates of an n dimensional object in a coordinate space. Each n dimensional object has a tunable radius influence distance initially set to a maximum or minimum allowed value which then defines a shape in n dimensional space. The influence distance spread across all n dimensions defines an influence field. In the case of a spherical object the influence field would define a hypersphere with the vector defining the object mapped to the center. The combination of a vector the influence distance and a category makes up the core attributes of a knowledge element.

Multiple knowledge elements of the same or differing categories can be learned or mapped into the n dimensional space. These combined knowledge elements define an n dimensional knowledge map. Multiple knowledge elements may overlap in the n dimensional space but in some implementations are not allowed to overlap if they are of different categories. If such an overlap were to occur at the time of training the influence distance of the affected existing knowledge elements and the new knowledge element would be reduced just until they no longer overlapped. This reduction will cause the overall influence fields of the knowledge elements in question to be reduced. The reduction in influence distance can continue until the distance reaches a minimum allowed value. At this point the knowledge element is termed degenerated. Also at this point overlaps in influence fields of knowledge elements can occur.

For pattern recognition an unknown input vector computed in the same fashion as the vectors of the previously stored knowledge elements is compared against the n dimensional shapes in the knowledge map. If the unknown data vector is within the influence fields of one or more knowledge elements it is termed recognized or identified. Otherwise it is not identified. If the unknown vector is within the influence field of knowledge elements within a single category it is termed exact identification . If it falls within the influence fields of knowledge elements in different categories it is termed indeterminate identification .

As discussed above to process object influence fields and to determine which one of the three result types exact recognition not recognized indeterminate recognition occurred in recognition operations a distance can be calculated to facilitate the required comparisons. The data vector format should be compatible and linked with the distance calculation method in use as is indicated by the formulas shown below. In practice it is computationally more expensive to use hyperspheres Euclidian distances to map the knowledge elements as the corresponding distance calculations require more time consuming operations. In these cases the knowledge element can be approximated by replacing a hypersphere with a hypercube in order to simplify the distance calculations.

The classic approach focuses on two methods Land L. to approximate the hypersphere with a value easier to compute a hypercube . Lis defined as

A pattern recognition engine can be built to implement a RBF or other comparison technique to define knowledge maps as described above and different recognition system configurations. Besides comparison technique key determinates of such an engine are the number of knowledge elements available width of the data vector supported by the objects the width and type of the vector operands the distance calculation methods supported and the number of possible categories the machine can support. Moreover a computerized machine can be built to define knowledge maps using Bayesian functions linear functions etc as the comparison techniques. The pattern recognition system described here can be implemented using any such functions. That is the RBF implementations described here are only representative.

Particular implementations of the present invention provide a highly configurable pattern recognition system where a set of pattern recognition system attributes such as vector attributes comparison techniques and distance calculation algorithms can be configured as a so called partition and selected as needed by a pattern recognition application. In some implementations the memory space that stores knowledge elements can be partitioned and a variety of pattern recognition system attributes can be dynamically defined for one or more of the partitions. In one implementation a pattern recognition engine such as hardware or a separate software module maintains the knowledge maps and partitions while a pattern recognition application accesses the knowledge maps by passing commands to the partition such as configure learn and recognize commands. In one implementation the pattern recognition engine provides a set of application programming interfaces APIs that allow applications to define and configure partitions as well as invoke corresponding partitions for learn and recognize commands.

A partition may include one or more of the following configuration parameters 1 number of vector operands 2 vector operand type 3 vector operand width 4 comparison technique 5 distance calculation technique and 6 maximum number of knowledge elements. A partition may also include additional parameter attributes that depend on one of the foregoing attributes. For example if RBF is selected as the comparison technique the initial influence field can be a capped maximum value MAX Influence the largest hypersheres or hypercubes or a smaller value which is the distance to the nearest neighbor of the same category or another category. These influence fields can be reduced as additional knowledge is learned which is not in the same category but within the current influence field of an existing knowledge element. In addition since a partition identifies a comparison type one or more learning operations may also be affected. For example if KNN is selected for the comparison type learned vectors may be simply stored in the knowledge map without checking to determine whether a new knowledge element vector overlaps an influence field of an existing vector as influence fields are not part of the KNN algorithm.

As discussed above a pattern recognition engine maintains a knowledge element array which is a memory space for one or more knowledge maps. Each knowledge map includes one or more knowledge elements which itself includes a vector and a category identifier. The system allows for partitioning of the number of available knowledge elements to enable concurrent sharing of the pattern recognition resources. This supports multiple users of the knowledge map functionality or supports a knowledge map application that wants to use it in different ways e.g. different feature extraction techniques different initial maximum influence value different minimum influence value different distance calculation method . For example in a vision application one partition might be used for gradient analysis whereas another partition of the knowledge element array might be used for histogram analysis. The results returned from each partition might be combined in several application specific ways to achieve a final recognition result.

A pattern recognition application can invoke a particular partition by identifying the partition when passing a learn configure or recognize command to the knowledge element array. The pattern recognition functionality may return results including an identified category as well as other data configured or associated with the category or a matching knowledge element s . In one implementation the pattern recognition engine can be configured to remember the partition identifier of the last command passed to it and apply the last identified partition to subsequent commands until a new partition is identified.

An overall pattern recognition process may be defined or configured as a series or set of individual pattern recognition operations each associated with a configured partition. In one implementation the pattern recognition application can include decisional logic that effectively arranges the partitions in a serial or hierarchical relationship where each partition can be included in a decisional node including other logic or operations that is traversed during a pattern recognition operation. Traversing the partitions can be done by a host processor or can be offloaded to a co processor or even programmed into a programmable logic circuit such as an FPGA.

In the prior art the width of the knowledge vector was fixed. This causes two problems. First in situations where the input knowledge is smaller than this fixed width resources are wasted as the full width of the neuron array is not used for each neuron. In some cases this can be dramatic e.g. a 5 byte input vector being stored in a 64 byte vector width which is fixed . Second in other situations the input knowledge might have a natural width wider than the fixed vector width. This could cause loss of fidelity as the data must be scaled down to fit into the vectors. In the pattern recognition system described herein the width of the knowledge vector of the knowledge elements and test vectors is not fixed. Multiple vector widths such as 1 2 4 32 64 128 256 byte words are available to suit the knowledge provided by the application or feature extraction processes. With smaller vector widths more knowledge elements are available using the same memory resources.

Still further the pattern recognition system can be used with a variety of supported data types. Knowledge elements and test vectors can be represented with a data vector having operands or vector elements of a variety of widths as described above and data types such as unsigned bytes signed bytes unsigned N bit integers signed N bit integers floating point values and the like . A given data vector can be generated from already digitized information or information that being fed directly from a sensor. The sensor based information may be first processed by a feature extraction process as well as other processes as shown in . illustrates a plurality of feature extraction processes and can process a given input data set such as in image captured by an image sensor to yield corresponding n dimensional vectors positioned in their respective feature spaces. For example a color histogram feature extraction process may yield an n dimensional vector where n is defined by the number of color bins of the color histogram and the value of each operand is the number of pixels that fall into each respective color bin. Other feature extraction processes may yield or require vectors having a different number of operands and operand types such as different widths and data types . As illustrates each of the resulting data vectors can be applied to a corresponding pattern recognition network and each contained within a partition and each including a knowledge map for training learning and or pattern recognition operations. In one implementation a partition may be configured for each feature extraction process where the number and type attributes of the vector elements are defined based on the requirements or properties of each feature extraction process. For example the wavelet transform process may require that a data vector having 15 elements or operands each having an 8 bit width are configured. The color histogram process may require a data vector with 30 operands or elements each having a 32 bit width.

As discussed above a partition may be configured that identifies a comparison technique used to compare an input test data vector and a known vector of a knowledge element. Selectable comparison techniques include Radial Basis Functions K Nearest Neighbor functions Bayesian functions as well as many others described in scientific literature Additionally after a comparison technique is selected one or more technique specific parameters may be configured such as maximum and minimum influence fields for RBF comparisons . Further an interface is defined so that users of the pattern recognition system can build their own pluggable comparison technique modules if those provided by the pattern recognition system are not sufficient. Additionally if one or more applications with different needs are using the knowledge element array one could set up each partition to use different pluggable comparison technique modules.

Still further the algorithm for computing the distance between an input vector and a known vector can also be configured. For example one from a variety of algorithms can be selected such as Euclidian distance L1 Lsup linear distance and the like. As discussed above however L1 and Lsup are approximations of the true hyper spatial distance which would be calculated using Euclidian geometry. In the pattern recognition system according to various embodiments of the invention the math for doing distance calculation is pluggable. This means that a given application can determine which math modules are available and request the one appropriate for its needs in terms of natural distance calculation e.g. a module that uses Euclidian geometry and floating point numbers. Further an interface is defined so that users of the pattern recognition system can build their own pluggable distance calculation modules if those provided by the pattern recognition system are not sufficient. In this manner a user can set the width of the individual components of their input vectors treat them as the appropriate data type integer floating point or other and can apply any distance calculation algorithm that they desire or that the pattern recognition system chooses to provide. Additionally if one or more applications with different needs are using the knowledge element array one could set up each partition to use different pluggable distance calculation modules.

In the prior art there was no way to mask off portions of the existing knowledge of a vector or to weight different parts of the trained knowledge element vector as might be needed on subsequent recognition operations. For example a set of knowledge elements might be trained on an entire image but in some subsequent recognition operations only the center of the images might need to be taken into consideration. In the pattern recognition system according to one implementation mask vectors and or weighting vectors can be used when matching against an existing knowledge base. In one implementation masking and weighting of operand vectors is part of a recognition operation. In one implementation an application may cause the pattern recognition engine to mask a vector operand by identifying a partition and the operand s to be masked in a mask command. An application may cause the pattern recognition engine to weight vectors operands by issuing a weight command that identifies a partition the operands to be weighted and the weighting values to be used. In one implementation the active influence field of a knowledge element may be temporarily increased or decreased to account for masking vectors or weighting vectors that may be currently in use.

Partitions can be configured and arranged in a hierarchy or other structured relationship series parallel branching etc. to provide for solutions to complex pattern recognition operations. A pattern recognition application for example may define an overall pattern recognition operation as a set of individual pattern recognition operations and include decisional logic that creates a structured relationship between the individual pattern recognition operations. In such an implementation the results returned by a first set of partitions can be used as inputs to a second higher level partition. For didactic purposes the decisional logic can be considered as a set of decisional nodes and a set of rules and processing operations that define relationships between decisional nodes.

A decisional node in a particular implementation may comprise configured logic such as computer readable instructions that includes 1 operations applied to one or more inputs prior to calling a pattern recognition engine 2 calls to one or more partition based recognition operations implemented by a pattern recognition engine and or 3 operations applied to the results returned by the pattern recognition engine. The decisional node may make calls to one or more partitions maintained by the pattern recognition engine. The additional logic of a decisional node can range from simple Boolean operations to more complex operations such as statistical analysis and time series analysis. Furthermore the operations responding to the results of pattern recognition operations can select one or more additional decisional nodes for processing.

In particular implementations a decisional node can be implemented as a decisional node object which is an instantiation of a decisional node class in an object oriented programming environment. In such an implementation the class can encapsulate one or more partition operations as corresponding API calls to the pattern recognition engine . The decisional nodes can be sub classed to develop a wide array of decisional nodes. As discussed above additional logic can be developed to establish relationships between decisional nodes as well and can be configured to interact with other decisional nodes or user level applications to achieve complex high order processing that involves pattern recognition. For example in one implementation a decisional node could be implemented as a finite state machine whose output could change as inputs are provided to it and the results of recognition operations are returned. The resulting state of the finite state machine at any given time can be an input to a higher level decisional node which itself may encapsulate one or more partition operations as well as additional processing logic.

Processing operations associated with a decisional node or a configured set of decisional nodes can be implemented in a variety of manners. Partition operations can be performed by a pattern recognition engine implemented as a separate thread or process of a general purpose computer offloaded to a co processor and or implemented in a programmable logic circuit while the decisional nodes can be implemented as a series of programming instructions associated with a user level application. In other implementations processing of the decisional nodes can also be offloaded to a co processor and or implemented in a programmable logic circuit.

In the prior art either a single recognition machine is used to identify a certain category of object or multiple recognition machines are used to identify an object when a majority vote wins. For example if two out of three recognition machines returned the same result the object would be identified as that result. Further in the existing prior art and scientific literature RBF machines are used in a flat arrangement as shown in . However there are large numbers of pattern identification problems where a flat arrangement cannot provide the desired results. These are normally situations where there is a large amount of detail background and foreground of different data types that must be processed in order to determine a final pattern recognition result. For example one might apply a certain technique to input data and if a match is found then one might feed different data based on the first match calculated by a different technique into another recognition operation to determine a higher level recognition result.

Using the foregoing a pattern recognition application can be configured to support a set of pattern recognition operations arranged in a hierarchy or other structured relationship that can be traversed to achieve a final recognition result. For example a hierarchical configuration of pattern recognition operations can be configured where each decisional node of the hierarchy pattern recognition partition s along with optional control temporal logic can identify a subsequent path to take. The results associated with one operational node of the hierarchy can be used to decide the next operational node to be executed and or can be an input to a subsequent operational node. For examples the results of a first set of partition operations can become through combinational techniques the input vector to a second higher level partition or node operation.

The opaque user data of multiple recognition operations could be used as an input vector via combinatorial logic to a higher level partition node or could also be used to lookup a data vector that could be used as an input vector via combinatorial logic to a higher level partition node. In other implementations the opaque user data could be used to look up a partition or decisional node to be processed next in a multiple layer pattern recognition application. For example one recognition stage could use a first partition to provide a result. Via the use of opaque user data a subsequent recognition stage using the same or a different input vector could be performed in a different partition based on the opaque user data returned by the first recognition stage. This can continue for several levels. Additionally once a higher level recognition result is achieved it could be used to weight or mask additional recognition operations at lower levels in the hierarchy such as to bias them toward the current top level recognition.

Thus a pattern recognition application may use multiple partitions or nodes to create the layers or it may create multiple independent layers and connect them as needed. The application decides which partitions nodes are to be in which layers. To use such a pattern recognition system the application trains specific knowledge elements with corresponding opaque user data see above and below into specific partitions. In the more simplistic case a given unknown pattern may be presented to the appropriate partitions and the recognition result of each partition combination of category recognized and or opaque user data and or derived data from the opaque user data if any would be fed to higher layers in the hierarchy. This process would repeat until a final recognition result was derived at the top of the hierarchy.

An example of this would be the lowest level of the hierarchy recognizing edges of a shape or sub samples of a sound. Further up in the hierarchy lines with intersecting angles would be recognized from image data along with tones from sound data. Still further up in the hierarchy a four legged mammal would be recognized from the image data and the sound woof would be recognized from the sound data. Finally at the top of the hierarchy dog could be the final recognition result.

Or consider the following example. An image sensor might be pointed at a scene which includes a wall upon which a TV is mounted. First level pattern recognition might detect the corners and edges of the TV in the middle of their field of view. Once the individual elements were recognized data associated with this recognition operation e.g. the opaque user data in the pattern recognition system might contain data on the position of the recognition in the overall scene e.g. corner located at 2 4 8 and 10 o clock . Similar results might be obtained for the edges. A higher level of recognition might conclude that these patterns in their respective positions formed a box. Recognition techniques using other different approaches might plot color changes. When these results are combined with all other techniques a final result of TV might be the determination at the top of the hierarchy. Once the TV is recognized masking or weighting might be applied to lower levels in the hierarchy to focus only on the TV and ignore other objects in the scene being recognized such as paintings on the wall flying insects books on a bookshelf etc. A practical application of this example would be airport security where once a wanted person was identified by the facial patterns tone of speech type of clothing fingerprint etc. a computerized system could then follow this person throughout the facility continuously recognizing the person while somewhat ignoring the surrounding scene. In addition to the spatial examples defined above additional levels in the hierarchy could use temporal times series pattern recognition operations to define their outputs. The input to these levels would be spatial recognitions that are then trended over time to produce a temporal recognition result.

A permutation on this case is that instead of just using one partition s or node s results to feed to a higher level partition or node multiple lower level partitions could be combined into recognition units or nodes . In this fashion probabilistic results can be feed further into the hierarchy. An example would be the lower level results are that there is an 80 probability as opposed to a binary result in the simpler hierarchy.

Through experimentation the correct numbers of levels are determined along with what to train recognize in each level and what to feed up to higher levels. A starting point can be to use different knowledge vector feature extraction techniques at the lowest level and map these different techniques to different partitions nodes. Next one would feed unknown knowledge vectors to the trained lower level to determine what was recognized. Based on these recognition results the connection to the next level in the hierarchy would be created along with determining suitable feature extraction algorithms and associated logic for that level. In some cases the original training data would be used with different nth order feature extraction algorithms to train higher levels or the output from the lower level opaque user data or derived from opaque user data would be used to train the higher level or a combination of the two. Each recognition problem domain may require experimentation to determine what the proper number of levels is what the levels should be trained with and how they should be connected.

In the previous example high fidelity recognition results can be obtained by feeding up through a recognition hierarchy. For time series or temporal recognition problems it is also useful to feed a result from higher levels back to lower levels to bias them for the object being recognized and tracked. As an example once a dog is recognized as barking it can be advantageous to focus on the barking dog as opposed to blades of grass blowing in the background. The opaque user data could also be used to bias one or multiple levels of the recognition hierarchy once sub recognitions occurred at lower levels in the hierarchy to allow them to help focus the desired result.

In order to accomplish this as each level recognizes a specific pattern it could provide a bias to its own inputs or feed a bias to a lower level in the hierarchy to bias its inputs. This feedback would be accomplished the same way as the feed forward approach namely use 1 the recognition results opaque user data or 2 what that data points to to provide a bias to the same or a lower level. This would be accomplished by using the masking or weighting functionality described earlier.

As described in the paragraphs below the system enhances pattern recognition functionality in a variety of manners in one implementation making the logic more useful to real world applications.

In the recognition phase input test data vectors are presented to the knowledge map and in one implementation with a partition identifier. below shows an example of these three recognition result types. The recognition result can be one of three types 

In the prior art an input vector presented for learning would be rejected if it falls within the influence field of an existing knowledge element in the same category. Yet a subsequent learning operation might allocate a knowledge element in another category which could cause the influence field of the original matched knowledge element to be reduced such that if the initial input vector was then presented it would cause a new knowledge element to be allocated.

In the pattern recognition system according to certain implementations of the invention all vectors presented for learning that match against existing knowledge elements are remembered and are tried again if a subsequent learning operation reduces the influence field of any knowledge element in the array. In this way knowledge density can be maximized to aid in increasing the sensitivity of subsequent recognition operations. This learning process is shown pictorially in for an example in a hypothetical 2 D space. illustrates a method directed to the foregoing. illustrates a learned vector v in category A and a learned vector v in category B. As illustrates the knowledge element corresponding to vector v has an influence field set to the maximum Maxif see . Vector v is the next learned input vector . As illustrates the influence fields of the knowledge elements for vectors v and v are adjusted to not overlap since they have been assigned different categories . In one implementation the influence fields of each of the knowledge elements are adjusted equally to prevent the overlap. Other modes can be implemented as well. For example the influence fields of a selected category can be favored by some weighting factor that causes the favored category to have a larger influence field. As illustrates vector v in the same category A as vector v lies within the influence field of an existing vector again v . Accordingly vector v is initially omitted from the knowledge map in that no knowledge element is allocated but saved for later processing . illustrates a vector v in Category B which as illustrates causes the influence field associated with vector v to be further reduced . As shows in one operational mode the influence field associated with vector v can also be reduced however in another operational mode influence fields are adjusted only for overlapping knowledge elements in different categories. The selection of mode in one implementation can be another partition configuration attribute. illustrates the addition of vector v which causes the influence field associated with vector v to reduce to the minimum allowed value . As shows vector v no longer lies within the influence field associated with vector v and is allocated a knowledge element in the knowledge map see .

In many cases additional input knowledge is not meant to be learned e.g. allocated a knowledge element but rather is only used to adjust the influence fields of existing knowledge elements to make sure they would not match the input data on a subsequent recognition operation. The pattern recognition system described here does allow this it is termed half learning . With half learning influence fields may be adjusted but no new knowledge elements are allocated to preserve memory resources. As shown in with each input to be learned the pattern recognition engine checks whether the learn command is a half learn command or a regular learn command . If a regular learn command the pattern recognition engine allocates a knowledge element if the vector is not within the existing influence field of a knowledge element in the knowledge map and adjusts one or more influence fields as required . If a half learn command the pattern recognition engine simply adjusts one or more existing influence fields as required .

In the pattern recognition system the specific identifier e.g. number of the matched knowledge element e.g. array index is returned for all matched knowledge elements. Thus if an application keeps track of which knowledge element identifiers are allocated when training the knowledge element array these identifiers can be used when matches occur to reference back to the source of the initial training knowledge possibly in conjunction with the opaque user data as described above. The ability to determine the precise knowledge elements which caused a match can be quite useful to a variety of applications. For example the knowledge elements that did not cause a match may possibly be excluded when developing a knowledge map for the same application in order to save memory space and processing power.

Still further the pattern recognition system may also maintain user and system counters for each knowledge element. A system counter is incremented each time a knowledge element is matched to an input vector. A user counter is incremented each time a knowledge element is matched to an input vector and when one or more user defined rules are satisfied. In this manner the significance of the trained knowledge elements can be assessed. For example when developing a pattern recognition system for a specific application such as machine vision in a auto assembly line the system may be initially trained with 250 000 knowledge elements. Use of the system in a testing environment and analysis of the system and user counters may reveal for example that only 100 000 knowledge elements were ever matched and that many of the matched knowledge elements had an insignificant number of matches. An engineer may use this knowledge when implementing the field version of the pattern recognition system to exclude large numbers of knowledge elements thereby reducing resources processing and memory for the given machine vision application.

In the prior art it was not possible to delete existing knowledge if it was determined that that knowledge was in error. The only approach was to delete all the knowledge and retrain the knowledge element array again and not include the errant knowledge. This took time and required that the original knowledge be retained for subsequent training operations. The pattern recognition system according to some implementations of the invention allows individual knowledge elements to be deleted cleared and marked as available if it is determined that the knowledge they represent is in error. In addition subsequent learning operations will use the knowledge elements previously deleted if any before the free knowledge element block at the end of the knowledge element array is used. When a knowledge element is deleted it also triggers a reapplication of the not learned knowledge if any see Section D.1. above .

In addition the pattern recognition system can also support configurable weighting values that can be selectively applied to knowledge elements of one or more categories to bias selection of for or against that category as to one or more input vectors. For example the weighting factor can be used to increase the influence fields of RBF knowledge elements or to adjust the resulting aggregate distance computed between an input vector and a knowledge element vector. Again this may be another configuration parameter for a partition.

In one implementation the pattern recognition system supports a mode where a knowledge map is held static. For example in a first dynamic mode a given knowledge map can be augmented and changed as it is trained with new knowledge. The pattern recognition system also supports a static mode that disables further leaning as to a select knowledge map. The fixed size or further learning disabled mode can be used to disallow knowledge updates which could cause non deterministic results when two similarly configured machines are modified independent of one another. In one implementation the commands to enter and exit this mode may require an administrative password to allow for periodic updates while protecting the knowledge map from updates by unauthorized personnel or applications.

As noted above the pattern recognition system is implementation agnostic and can be implemented using software in a general purpose computing platform. Moreover as noted above the pattern recognition system is also amenable to implementation in firmware hardware FPGA or ASIC combinations thereof etc.

Additionally as shown in the pattern recognition system may include an archiver where the system stores locally or remotely among other things results from the inspection server and sensor readings from the sensor server . Also as shown in the pattern recognition system may optionally include a video output device of some type for display to a human user.

The pattern recognition system includes logic for pattern identification and pattern recognition which logic is described in detail in this document. That logic in one implementation resides in the inspection server shown in . In some embodiments the pattern recognition system is a scalable system whose resources can be increased as needed. Also in some embodiments the pattern recognition system is an extendable system whose functionality can be readily extended via the use of general purpose and special purposes components. In one embodiment the pattern recognition system is extendable using a set of plug in components relevant to the task at hand e.g. machine vision utilizing feature extraction. By choosing the order a particular plug in component is used during task performance it is possible to control when invocation occurs with respect to the system logic for pattern identification and pattern recognition. illustrates an example implementation including a sensor data pre processing component a feature extraction component and a pattern recognition component . See also which illustrates that the pattern recognition system may take inputs from several feature extraction components during a machine vision task. Preprocessing of the sensory data may be performed prior to attempting pattern recognition and feature extraction. For example if the task at hand is machine vision this preprocessing might include filtering to reduce noise improve resolution convert to grayscale etc.

A pattern recognition system can be hardware or software implementation agnostic. That is to say one can implement the pattern recognition system using 1 software on an existing processor e.g. Pentium PowerPC etc. as indicated by the API in Appendix A 2 HDL code for an FPGA e.g. Xilinx Virtex 4 Altera Cyclone 3 3 HDL Code in a semi custom area of an existing generic processor e.g. IBM Cell REF and 4 full custom Application Specific Integrated Circuit ASIC . In the case of chip level implementations e.g. 2 4 above the chip might be mounted on a printed circuit board PCB . This PCB could be on the main PCB for a computing machine or as an expansion PCB which would plug into a interconnect bus PCI PCI Express etc. .

Further in hardware system includes processor and a cache memory coupled to each other as shown. Cache memory is often of two levels one which is contained as a part of processor and one which is external to processor . Additionally hardware system includes a high performance input output I O bus and a standard I O bus . Host bridge couples processor to high performance I O bus whereas I O bus bridge couples high performance I O bus and standard I O bus to each other.

Coupled to bus are sensor controller such as a camera system controller and system memory . A sensor is operably connected to sensor controller . The hardware system may further include video memory not shown and a display device coupled to the video memory not shown . Coupled to standard I O bus bus are storage device and I O ports . Collectively these elements are intended to represent a broad category of computer hardware systems including but not limited to general purpose computer systems based on the Pentium processor manufactured by Intel Corporation of Santa Clara Calif. as well as any other suitable processor.

The elements of hardware system perform their conventional functions known in the art. Storage device is used to provide permanent storage for the data and programming instructions to perform the above described functions implemented in the system controller whereas system memory e.g. DRAM is used to provide temporary storage for the data and programming instructions when executed by processor . I O ports are one or more serial and or parallel communication ports used to provide communication between additional peripheral devices which may be coupled to hardware system . For example one I O port may be a PCI interface to which an FPGA implementation of the pattern recognition system hardware is operably connected.

Hardware system may include a variety of system architectures and various components of hardware system may be rearranged. For example cache may be on chip with processor . Alternatively cache and processor may be packed together as a processor module with processor being referred to as the processor core. Furthermore certain implementations of the claimed embodiments may not require nor include all of the above components. For example storage device may not be used in some systems. Additionally the peripheral devices shown coupled to standard I O bus may be coupled instead to high performance I O bus . In addition in some implementations only a single bus may exist with the components of hardware system being coupled to the single bus. Furthermore additional components may be included in system such as additional processors storage devices or memories.

As noted above in connection with there are a series of application and driver software routines run by hardware system . These software routines comprise a plurality or series of instructions to be executed by a processor in a hardware system such as processor . Initially the series of instructions are stored on a storage device such as storage device . However the series of instructions can be stored on any conventional storage medium such as a diskette CD ROM ROM EEPROM flash memory etc. Furthermore the series of instructions need not be stored locally and could be received from a remote storage device such as a server on a network. The instructions are copied from the storage device such as storage device into memory and then accessed and executed by processor .

An operating system manages and controls the operation of hardware system including the input and output of data to and from software applications not shown . The operating system and device drivers provide an interface between the software applications being executed on the system and the hardware components of the system. According to one embodiment of the described embodiments the operating system is the LINUX operating system. However the described embodiments may be used with other conventional operating systems such as the Windows 95 98 NT XP Vista operating system available from Microsoft Corporation of Redmond Wash. Apple Macintosh Operating System available from Apple Computer Inc. of Cupertino Calif. UNIX operating systems and the like. Of course other implementations are possible. For example the functionality of the pattern recognition system may be implemented by a plurality of server blades communicating over a backplane in a parallel distributed processing architecture. The embodiments discussed in this disclosure however are meant solely as examples rather than an exhaustive set of possible implementations.

As indicated above the pattern recognition engine can be implemented as software on a standard processor or in connection with a semiconductor circuit including a programmable logic circuit such as a field programmable gate array. In such an implementation a driver layer see above allows an application to pass commands e.g. learn recognize etc. to the FPGA which implements the pattern recognition engine that maintains the knowledge maps and partitions. The benefits of the semiconductor version is the speed of pattern identification for larger knowledge maps real time or near real time and to off load the host processor. Also in some cases the semiconductor implementation can be used for embedded applications where a standard processor could not.

In one possible FPGA implementation the pattern recognition engine is installed on a printed circuit board or PCB which will normally be connected via an interconnect bus e.g. PCI PCI Express etc. . In one implementation the FPGA unit is operative to receive an input or test vector and return an identifier corresponding to a matching knowledge element or a category and possibly opaque user data associated with the matching knowledge element. In one implementation each FPGA pattern recognition unit is a PCI device connected to a PCI bus of a host system.

Sensor reading or polling sensor data processing and feature extraction operations could be offloaded to a co processor or developed as an FPGA or other programmable logic circuit implementation and installed on a programmable logic circuit. Feature extraction is discussed above. Sensor data processing may involve one or more operations performed prior to feature extraction to condition the data set prior to feature extraction such as pixel smoothing peak shaving frequency analysis de aliasing and the like.

Furthermore as discussed above the comparison techniques RBF KNN etc. distance calculation algorithms L L Euclidian etc. can be user configurable and plugged in at runtime. In one programmable logic circuit implementation the selected pluggable algorithms can be stored as a set of FPGA instructions developed using VERILOG or other suitable SDK and dynamically loaded into one or more logic units.

The PCI Registers and control logic module includes registers that are used to configure the chip and return the status of the chip. The module in one implementation includes a memory space for storing data such as knowledge maps and configuration information such as partition information . In one implementation the memory space is divided or allocated for different aspects of the pattern recognition system. A first memory space includes a set of registers used in the learning and recognition phases for the input vector status information configuration information as well as information on matched knowledge elements or setting of a newly created knowledge element in a learning operation . The matching knowledge element information can include a knowledge element identifier an actual influence field a minimum influence field knowledge element status information including whether it fired relative to an input vector a category identifier a partition a distance value and the like.

A second memory space provides for a knowledge element KE memory space for virtual decision elements allocated among the physical knowledge element engines. In one implementation a second memory space is for knowledge element information. In one implementation this memory space is divided into banks. Each bank is further divided into areas for knowledge element registers and knowledge element vectors. One to all the banks may also include an area for storing one or more input vectors or portions of input vectors. Each virtual knowledge element in one implementation has its own set of registers in the knowledge element register including for example knowledge element identifiers actual influence field minimum influence field partition identifier category identifier one or more distance field register that indicates the distance between an input vector and the corresponding learned vector of the virtual knowledge element. Each bank of the second memory space also stores the learned vectors for each of the virtual knowledge elements allocated to it. The maximum number of learned vectors and knowledge elements in each bank is determined by the vector width. The control module in one implementation provides a memory address conversion for the knowledge element memory as well as the de multiplexer for read back. In one implementation the second memory space also provides for storage of one or more input test vectors. Of course the memory space may be divided and arranged in a variety of configurations.

In one implementation a learning module performs various learning operations such as scanning all the existing knowledge elements adjusting the existing knowledge element influence fields setting category identifiers finding the minimum distance to different category knowledge elements and creating a new knowledge element if needed. In one implementation the learning module can implement the learning functionality described above. The circuit may also include a multiplexer that provides a given test vector to the respective physical knowledge element engines. In one implementation a physical knowledge element includes logic to compute the distance between a test vector and the learned vectors corresponding to the virtual knowledge elements to which the physical knowledge element has been assigned. In one implementation each physical knowledge element engine is further operative to search for the minimum computed distance among the virtual knowledge elements to which it has been assigned. In one implementation each physical knowledge element operates on an input vector to identify an assigned virtual knowledge element having the minimum distance to the input vector. In one implementation the FPGA is a parallel processor in that the physical knowledge elements operate in parallel. In one implementation each physical knowledge element computes a distance using an input vector and writes the computed distance to a distance register of the corresponding virtual knowledge element. The logic of the physical knowledge element is operative to return the knowledge element information corresponding to the virtual knowledge element having the minimum distance to the input vector. In one implementation the control logic is operative to identify the virtual knowledge element having the overall minimum distance identified across the multiple physical knowledge element engines. In one implementation the pattern recognition system provides results at each interconnect bus cycle. That is on one interconnect bus clock cycle the input data vector or vectors are loaded across the bus and on the next bus cycle results are ready.

Given this bus clock cycle overhead 100 parallelism in the knowledge elements is no longer required. Rather the pattern recognition system leverages the limited FPGA resources to implement the virtual knowledge elements. Using a virtual knowledge element approach a plurality of physical knowledge element engines are implemented in the FPGA each of which may relate to multiple virtual decision elements. Specific knowledge element contents would be stored in the FPGA memory to allow many hundreds of virtual knowledge elements to be implemented across a lesser number of physical knowledge element engines. These virtual KEs operate in a daisy chain or round robin approach on the FPGA memory blocks to implement the total KE count coupled with the real physical knowledge elements that are constructed in the FPGA s gate array area. Each virtual knowledge element has its own influence field. When learning causes a new virtual knowledge element to be allocated the allocated virtual knowledge element number is returned. When a match occurs in the recognition phase the firing virtual knowledge element number is returned. A 32 bit register can be implemented in each virtual knowledge element. This register can be written in learning phase. The value will be returned in the recognition phase unchanged. An application has full access to the virtual knowledge element memory space. The application can save the knowledge element network to hard disk and later reload the knowledge element network into the FPGA. The user can modify the knowledge element network according to their special need at anytime except while a learning or recognition operation is in process. Through this interface knowledge elements can also be deleted if desired.

Additionally in the FPGA implementation the pattern recognition system can be implemented using a pipeline approach as many data vectors can be loaded in a single interconnect bus clock cycle thus further speeding the overall result time for many data vectors needing identification. That is the pipeline may increase the effective speed of recognition performed by the FPGA.

As shown in the pipeline has 3 stages 1 search and sort 2 distance calculation and 3 vector buffers. Four input vectors can be stored in the FPGA. The vectors are processed first in first out. When the Buffer Ready flag is set it means that vector buffer is empty. The user e.g. the programmer can write a vector into the FPGA. The input vector written into the FPGA in one implementation is written into buffer . After the last byte of the vector is written vector buffer will be locked not ready . When the next stage is empty the vector will move forward and Buffer will be empty ready again. Writing a vector into the FPGA while buffer is not ready will cause an error. Setting NEXT VECTOR flag will push the vector at the search and sort stage out of the pipeline. The other vectors in the pipeline will move forward.

The RESET flag can be used to remove all the vectors in the FPGA. With this mechanism two vectors can be processed at same time where a distance calculation is performed relative to one input vector while a search and sort operation can be performed relative to a second input vector. In addition while waiting for the result software can write other vectors into the FPGA. In addition while waiting for the minimum distance to be read out a next minimum distance can be searched.

For the application software reading results and writing vectors can be performed in two separate threads. When the Buffer Ready is set the application can write a vector into the FPGA. When the Ready flag is set the application can read the result out. Read knowledge element number and distance will trigger hardware to search for the next matched knowledge element. To process the next vector the application can set the NEXT VECTOR flag. The first input vector just flows through to the end and sets the status flag when the results are ready. This is shown in .

When the application needs to process vectors one by one the user can write the vector in and wait for the result. After this vector has been processed the application can set the NEXT VECTOR flag to remove this vector from the pipeline and then write the next vector in. The next vector will flow through to the end just like the first vector. If the user doesn t set the NEXT VECTOR flag to remove the front end vector the second input vector will flow through to the distance calculation stage and the third vector will wait in the vector buffer . They will not push the first vector out as illustrated in .

When the pipeline is full the application sets the NEXT CONFIG flag to remove the front end vector out of the pipeline before writing another vector in. All the other vectors will move forward. For example as shown in vector will be pushed out vector will move into search and sort stage the vector in buffer will move to the distance calculation stage. Buffer will be empty. The Buffer Ready flag will be set again.

To recapitulate with respect to pipelining vectors can be written into the vector buffer when vector buffer is empty. When the distance calculation stage is free the vector in the vector buffer will be moved forward and vector buffer will be left free for next vector. When the distance calculation is finished and the search sort stage is free the vector will be moved forward actually it will be discarded . The minimum distance will be searched and copied to the output buffer. Next the minimum distance will be searched while waiting for the minimum distance to be read. The vector at Search Sort stage will be discarded when software writes another vector into the FPGA.

As is relevant to the partitions discussed above given the structure of the FPGA block RAM according to one possible implementation four different vector widths 32 64 128 256 bytes can be supported which in turn result in four different virtual KE counts 672 400 224 112 . Thus an application can choose the width and count most appropriate to the task at hand. Of course other FPGA implementation may allow for different vector widths and

Finally physical knowledge elements might be loaded with different distance calculation algorithms for different requirements. Thus the FPGA can be configured to allow all physical knowledge elements to use the same recognition math or algorithm. Alternatively each physical knowledge element can be configured to use a different math e.g. L1 or LSUP. Or further still the math for the physical knowledge elements can be swapped in out based on the partition chosen for pattern identification and the partition s associated math requirements.

While a number of exemplary aspects and embodiments have been discussed above those of skill in the art will recognize certain modifications permutations additions and sub combinations thereof. It is therefore intended that the scope of the invention includes all such modifications permutations additions and sub combinations. For example the use of virtual knowledge elements in connection with physical engines can be implemented in other programmable logic circuits and in application specific integrated circuits ASICs . An additional example would be where external memories host based or local to the pattern recognition machine are used to supplement the FPGA or ASIC on chip memory to provide for larger numbers of knowledge elements. It is therefore not intended that the invention be limited except as indicated by the appended claims.

