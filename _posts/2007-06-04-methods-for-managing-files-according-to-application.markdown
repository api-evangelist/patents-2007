---

title: Methods for managing files according to application
abstract: The present invention discloses systems for managing files according to an application. A method for accessing files in a digital storage device, the method including steps of: providing an application having an application identity; and adjusting a storage mode of a file according to the application identity upon the application accessing the file. Preferably, the step of providing includes providing a process identifier (PID) that is an indicator of the application identity. Preferably, the step of adjusting includes adjusting the storage mode according to a storage command associated with an application scenario of the application. Preferably, the step of adjusting is performed using a storage attributes table (SAT). Preferably the step of adjusting is performed using an application scenario table (AST).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08627029&OS=08627029&RS=08627029
owner: SanDisk IL Ltd.
number: 08627029
owner_city: Kfar Saba
owner_country: IL
publication_date: 20070604
---
This patent application claims priority under 35 U.S.C. 119 e to U.S. Provisional Application No. 60 893 635 filed Mar. 8 2007 which is hereby incorporated by reference in its entirety.

This patent application is related to U.S. patent application Ser. No. 11 806 704 of the same inventors which is entitled METHOD FOR MANAGING FILES ACCORDING TO APPLICATION and filed on the same day as the present application. This patent application also claiming priority to U.S. Provisional Application No. 60 893 635 is incorporated in its entirety as if fully set forth herein.

File storage management is a well known function in the art of computer engineering. Substantial effort is made to optimize the way files are stored and managed in non volatile storage systems in order to optimize the speed reliability power consumption and security level of the stored files.

Traditional storage devices are unable to discriminate between different storage circumstances and therefore treat the stored files in a generally optimal way without adapting the file management to parameters that may vary among different storage access scenarios.

Two patent applications U.S. patent application Ser. No. 10 849 234 and U.S. patent application Ser. No. 10 952 837 both of SanDisk IL Ltd. Kefar Saba Israel significantly improve the performance of storage devices by making the flash management attributes dependent upon the content of the stored data. Such an approach is clearly described in detail in the abovementioned applications. The abovementioned prior art indeed teach how to adapt the storage management of a file based on attributes derived from the file type such that a streaming music file e.g. MP3 extension for example is treated differently than a text file e.g. DOC extension .

However according to the prior art a file is always treated in the same way regardless of which application accessed the file. Such a situation leaves much to be desired in terms of optimal storage management.

The following example shows how a file type e.g. MP3 file has different storage requirements when accessed by one application e.g. music player application versus another application e.g. a file copying application . A music rendering application e.g. Microsoft Windows Media Player requires that an MP3 file be treated with a fixed reading bit rate and low power consumption but could tolerate a lower reliability.

In contrast a file copying application e.g. Microsoft ActiveSync would prefer to have the same MP3 file be treated with a fast reading speed and a high reliability but could tolerate an unstable bit rate.

Therefore it is clear that different applications would be optimally served by application specific file management with respect to read and write performance reliability level e.g. error correction algorithms security housekeeping wear leveling and the mapping of the logical files to physical pages and blocks in flash memory for example. Unfortunately in the prior art systems the identity of an application that accesses a file is not taken into consideration by flash management systems.

It would be desirable to have methods for taking into consideration the application that issues a storage access command when fulfilling the command.

It is the purpose of the present invention to provide methods for managing files according to application.

For the purpose of clarity several terms which follow are specifically defined for use herein. The term file is used herein to refer to a digital data file or any data object that is managed by a storage system. The term block is used herein to refer to a basic storage sub area that can be read written and erased. Some storage technologies enable some of the three operations i.e. read write and erase to be performed on parts of a block e.g. pages .

The terms digital rights management and DRM are used herein to refer to a secure technology that enables the copyright owner of a piece of intellectual property e.g. music video and text files to specify what a user is allowed to do with the property. In DRM a DRM entity e.g. a song file is associated with a rights object file or header.

The terms operating system and OS are used herein to refer to a software program executed by a host system capable of providing file system services via API application programming interfaces to other applications e.g. Windows . The terms file system and FS are used herein to refer to a software module included in OS software. The FS is responsible for managing memory both non volatile and volatile using logical addresses that index files using an FS specific format. APIs for deleting creating renaming reading and writing files and directories by their names without knowing the storage device type the data format of the FS and the physical locations of the files in the memory are exported by the FS to applications.

The term application launch is used herein to refer to a process that occurs when an OS e.g. Windows Mobile by Microsoft Seattle Wash. USA reads an application file from an NVM non volatile memory converts the application file format to an OS specific process format and writes the newly formatted application file into the NVM. When the application launch is completed the file is ready to be executed by the OS. The term application identity is used herein to refer to a name of an application that specifies what the application is.

The terms single level cell and SLC are used herein to refer to a memory that stores one bit in each cell. A bit can be stored in a cell by charging the cell at one out of two available voltage levels. One voltage level represents one logic and the other voltage level represents zero logic. An SLC device provides faster transfer speeds lower power consumption and higher cell endurance. SLC flash memory technology is used in high performance memory cards.

The terms multi level cell and MLC are used herein to refer to a flash memory that stores two or more bits in each cell. Two or more bits can be stored in one cell by charging the cell in one of four or more available voltage levels. For example if the MLC stores two bits per cell then one voltage level of the combined two bits in the cell represents zero logic the second voltage level represents one logic the third voltage level represents two logic and the fourth voltage level represents three logic. By storing more bits per cell an MLC memory card achieves slower transfer speeds higher power consumption and lower cell endurance than an SLC memory card. However MLC manufacturing costs are lower than SLC manufacturing costs. MLC flash memory technology is mostly used in standard memory cards.

The term storage sub area is used herein to refer to a collection of logical blocks in a storage device. The term physical sub area is used herein to refer to a collection of contiguous physical block addresses having uniform storage attributes. The term logical sub area is used herein to refer to a collection of sequential logical block addresses having uniform storage attributes. The term virtual sub area is used herein to refer to a not necessarily sequential collection of logical block addresses having uniform storage attributes.

The term storage attributes is used herein to refer to parameters that describe the performance of sub areas in a storage device. Examples of such storage attributes include read speed endurance power consumption and reliability. The terms storage attribute table and SAT are used herein to refer to a table that lists attributes of sub areas in a storage device.

The term application scenario is used herein to refer to a combination of 1 one or more application identities 2 one or more file types and 3 one or more storage operations or commands that are associated with specific storage requirements in a storage system. Each of these three elements is called an application scenario parameter e.g. the identity of an application is an application scenario parameter . Any application has an application scenario under which operations and commands are executed. The terms storage operation and storage command are used herein to refer to a command that involves a host system accessing one of its storage devices.

The terms application scenario table and AST are used herein to refer to a table that matches application scenarios with storage requirements. The term storage mode is used herein to refer to a collection of parameters that determine the way a file is read from and written to an NVM. These parameters include the priority of the execution of the storage operation the timing punctuality required the buffer size for accessing the storage device the need to run or suspend housekeeping operations during read write operations the use of DMA direct memory access and the need to save power in the storage device. The storage mode also determines a preferred storage sub area and the writing mode such as sequential writing i.e. writing to sequential logical or physical addresses .

The present invention teaches methods for optimizing a flash memory management system based on the recognition of the application scenario or at least the identity of the application that issues a storage access command and accesses files stored in the flash memory.

An essential feature of the present invention is the use of application related information when processing storage access commands. In preferred embodiments of the present invention the storage sub areas and storage modes allocated to the data are selected in accordance with the identity of the application or the application scenario.

For clarity the description below refers to a narrow application scenario which is combining one application one file type and one storage command. However it should be noted that application scenario is defined to cover any combination of values for each of the application scenario parameters including the combination of one application with any file type and any storage command.

Tables 1A and 1B highlight the differences between the present invention and the prior art mentioned in the Background section by showing how a file is handled differently in different application scenarios. Details are provided in the Description section below.

In preferred embodiments of the present invention the storage device exports an SAT which lists the relevant attributes of its storage sub areas to the FS of the host system. Such an SAT is shown in Tables 1A and 1B. The FS uses such an SAT to allocate an optimal storage sub area in the storage device for each application scenario. In order to do accomplish such a task the host system has an AST database that specifies the preferred storage attributes for each application scenario.

Such an AST database can be generated during development or customized during use in any of the following situations 

In a preferred embodiment of the present invention when an application uses the FS services API of the OS to access the storage device the OS carries out the following process 

At this stage the storage requirements for the current storage operation are known to the FS. The process continues according to one of two alternative methods. In the first method the storage device provides the SAT information to the host system and in the second method the host system provides the AST information to the storage device. The next step according to the first method is the following 

The step of 7a is preferred when predetermined physical and logical areas are used and the SAT is not dynamic.

The second method does not export the SAT to the host system. Thus the host system does not specify the storage sub area. The next step according to the second method is the following 

The step of 7b is preferred when the storage device selects the appropriate storage sub areas internally without the knowledge of the host system. It should be noted that such a method is not transparent to the host system i.e. the host system must know that the storage device is managing an SAT and must provide the storage requirements with every storage command . It should be noted that the FS is executed in the storage device as in object oriented storage using MTP media transfer protocol by Microsoft and that both the AST and the SAT are managed on the storage device. The host system only needs to provide the application name with the storage command.

It should be noted that the present invention does not require the use of all three application scenario parameters i.e. application file type storage operation . The system can take into consideration only the application the file type the storage operation or any combination thereof. This is performed when populating the AST.

Therefore according to the present invention there is provided for the first time a method for accessing files in a digital storage device the method including the steps of a providing an application having an application identity and b adjusting a storage mode of a file according to the application identity upon the application accessing the file.

Preferably the step of providing includes providing a PID that is an indicator of the application identity.

Preferably the step of adjusting includes adjusting the storage mode according to a storage command associated with an application scenario of the application.

These and further embodiments will be apparent from the detailed description and examples that follow.

The present invention relates to methods for managing files according to application. The principles and operation for managing files according to application according to the present invention may be better understood with reference to the accompanying description and the drawings.

Referring now to the drawings is a schematic block diagram of a storage system having application access to a storage device according to the prior art. An application is executed on a host system and tries to access a storage device . Application calls the FS services API of an operating system in order to send an access request to storage device through a file system . The operations of application are executed on host system .

The role of operating system in host system is to manage all the software executed on host system including applications and device drivers . Host system is responsible for executing the processes and allocating CPU time to each process when multiple processes are executed simultaneously e.g. multi threading and multi tasking . In order to do so operating system maintains a list of all current live processes on host system . Such live processes are processes that have been launched and have not yet been terminated.

The processes list includes the process ID or PID a number that a process gets every time it is launched by operating system the application file name from which the process was generated during application launch the priority according to which operating system allocates CPU time to the process the number of threads in the process the stack the heap size and other parameters. All of these parameters enable operating system to execute the process in a system that handles more than one process.

Operating system is responsible for executing all the software modules known in the art as software applications and software device drivers . Device drivers such as file system which communicates with storage device by sending commands via a physical interface I are responsible for accessing hardware peripherals known in the art as hardware devices or drives connected to host system . Operating system is also responsible for providing an interface between applications and drivers that are executed on host system . In order to provide this capability every call to a driver is received by operating system and is directed to the relevant driver. It will be appreciated that device drivers such as file system might be implemented as software or firmware e.g. a program stored on one or more computer readable media which are non transitory in an example embodiment.

When application tries to access storage device the FS services API of operating system is called and exported by file system to operating system . Operating system which is responsible for executing processes on host system receives the PID of the currently executed process. Operating system then attaches the PID to the request received from application and sends the request to file system .

Application which uses the FS services API of operating system designates a file or directory to be deleted renamed created read or written and provides the file name or directory name as an input parameter. When file system gets a request from operating system to open a file to read or write file system finds the location of the file in storage device reads the file attributes and collects relevant information about the file e.g. size and security attributes .

File system creates a specific data structure for the open file from the collected data. A pointer to the data structure known in the art as a file handle is passed to application through operating system . The next time that application tries to access e.g. read or write the open file application sends the file handle as opposed to the file name as an input parameter.

The above description is a typical and well known data management process of the prior art and is presented as background for understanding the present invention and the terminology that is used herein.

Tables 1A and 1B above help to highlight problems with methods of the prior art that determine storage attributes of a command based solely on file type. Tables 1A and 1B show two examples in which a single file type should be handled differently by the host system in different application scenarios.

Table 1A shows how two different application scenarios that need to read the same file would preferably differ from each other in buffer size DMA use and reading sequence. The ActiveSync application executed on a handset PDA is responsible for moving data from handset PDA local storage to PC local storage. ActiveSync is executed from the handset PDA and communicates with the PC via a USB connection. In Table 1A the ActiveSync application scenario includes reading an MP3 data file located on the handset PDA local storage and sending the file to the PC. ActiveSync prefers from a user perspective to read an MP3 file as fast as possible and send the file as fast as possible to the PC. As a result ActiveSync prefers high speed reading from the handset PDA local storage.

The Windows Media Player WMP application scenario includes accessing the same MP3 file. The WMP application is executed on a handset PDA. The WMP application is responsible for reading MP3 and MPEG files from handset PDA local storage and sending the files to an audio video player. Since MP3 playing performance requires 16 KB sec the WMP would expect a very low read performance unlike ActiveSync but may require a constant bit rate from the handset PDA local storage so that the user will not hear hiccups e.g. skips and pauses when the song is playing.

Hiccups occur if the storage is performing a housekeeping operation while the WMP requests new data. Such a conflict causes the WMP to get the data with a delay until the storage completes or suspends the housekeeping operation . Due to such delays the WMP is unable to provide the player with the content on time and the missing data sounds to the user like an undesirable noise or hiccup. In this scenario the WMP would greatly prefer prior to reading the MP3 file to request that the storage refrain from performing any housekeeping operation until the WMP completes the reading of the MP3 file. When the WMP completes reading the MP3 file the WMP sends the storage a release to continue the housekeeping operation.

Table 1B shows another example of an application dependent storage requirement. The ActiveSync application scenario includes receiving a Microsoft Word document from the PC via a USB connection and trying to write the data as fast as possible into the handset PDA local storage requiring fast write performance.

The MS Word application scenario includes executing the Word editor on the handset PDA local storage. The Word editor tries to write only a part of the document at a time e.g. the modified part that has just been updated by the handset user . Since Word documents are frequently updated the Word editor would prefer to write the partial Word document to a storage sub area that supports high endurance i.e. a high number of erase cycles and a low error probability . Storing Word document to a low endurance storage sub area might cause unrecoverable errors in the file. In contrast since the user s input is manual and slow a high write speed is not needed in the Word application scenario.

Table 2 is an exemplary SAT for two storage sub areas provided by a storage device. Table 2 presents the different attributes e.g. read performance endurance and security of the virtual or logical sub areas of the storage device. Storage sub area A called cache sub area is intended for cache data i.e. data that is written to the storage device at a very high speed . Examples of cache data applications include capturing multi shot images in a digital camera and storing the images without any delay. In some cases the storage device cannot meet the high write performance required of the application scenario but can overcome the problem by trading storage density for storage speed performance.

Writing x bytes of data at a very high speed can be done if 2 bytes are allocated for the data e.g. by using an SLC sub area instead of an MLC sub area . Using the example of an SLC sub area the virtual cache sub area is limited to 8 MB which are derived from 16 MB by allocation of 2 bytes for every x bytes that are actually written . Consequently when an application scenario needs to write data at high speed the data can be directed to the cache sub area. When the storage operation is completed the storage device can move the data internally from the cache sub area to a different storage sub area e.g. to economize on storage space . Reading or writing to the cache sub area is a very intensive operation i.e. the storage resources are working at full speed . Therefore storage power consumption is very high. An application scenario that seeks a low power consuming operation would avoid using the cache sub area.

Table 2 indicates that the cache sub area is not used for read operations. The cache sub area also provides high endurance typically 10 000 erase cycles as compared to 1 000 erase cycles in low endurance storage sub areas . The cache sub area is typically a low security storage sub area because encryption processes are not fast and because the cache sub area is typically accessible by many applications.

Storage sub area B in Table 2 called multimedia sub area is used for reading and writing data to storage at a low speed but with a constant bit rate and for a long period of time e.g. from a few minutes up to two hours . Video capture and playback each require a bit rate performance of 250 KB per second. MP3 playback requires a bit rate performance of up to 16 KB per second.

In the example of storage sub area B of Table 2 the multimedia sub area includes two sequential logical sub areas. The first logical sub area starts with sector and ends in sector the second sequential logical sub area starts with sector and ends in sector . These properties make the multimedia sub area suitable for writing and reading multimedia files. The storage device manages the multimedia sub area without hiccups by ensuring that the read and write operations are not interrupted by housekeeping operations.

Since multimedia files are typically written once and archived for playing and are never updated or modified until they are deleted the multimedia sub area provides low endurance e.g. 1 000 erase cycles compared to 10 000 for high endurance while still enabling the life expectancy of multimedia content on a storage device to be relatively long. Furthermore since multimedia files are recorded and played back repeatedly requiring as mentioned above a very low read write performance the multimedia sub area provides the feature of very low power consumption e.g. by decreasing the clock frequency of the storage controller to a magnetic disk or flash memory . A multimedia sub area that handles DRM files would be required to provide a higher security level e.g. encryption decryption of written read data .

Table 2 exemplifies how two different storage sub areas in the same storage device differ significantly in storage attributes and are used in different application scenarios according to preferred embodiments of the present invention. Methods of the prior art do not provide any ability to customize a storage sub area to an application scenario.

Table 3 shows the data structure of an exemplary AST according to a preferred embodiment of the present invention The rows of Table 3 represent individual application scenarios e.g. MS Word running in Office Pro for writing documents and ActiveSync for receiving data from a PC and writing the data into a storage device .

The columns of Table 3 are divided into three sections a section A contains line numbers used for administrative purposes and a list of PIDs that link the running processes to the associated applications since there can be more than one instance of an application running at the same time for each application scenario e.g. lines 2 and 3 are multiple processes of the same application a section B contains the three application scenario parameters that determine the application scenario and a section C contains the required attributes of the application scenario for optimal access of the storage device.

Application scenario parameters required by the application scenario of the storage mode that are exemplified in the AST of Table 3 are 

It is important to note that the PID field is the only dynamic field in Table 3. The PID field is updated once during application run time as described in .

Table 3 includes an application scenario generated during application launch from the Office Pro version of MS Word line 1 . PID is added to the PID field that already contains PID from a concurrent instance of the application. This application scenario is characterized by the application Word in Office Pro by the operation write and by the content type a Word document with the DOC file extension .

As described in Table 1B above such an application scenario does not require high read performance. The application scenario requires low write performance small buffer size for document updates due to the possibility of frequent minor update scenarios and high endurance. Word Office Pro is used by organizations that require enforcement of a security policy with regard to updating and distributing Word documents. Therefore such an application scenario requires a high security level.

Table 3 includes an application scenario generated during application launch from ActiveSync line 2 . The application has a PID . This application scenario is characterized by the application ActiveSync the operation write and the content type a picture file with the JPEG file extension .

As described in Table 1B above such an application scenario requires no read performance high write performance a large buffer size during document updates due to large sequential data writing operations with no minor updates and low endurance. ActiveSync is used to synchronize PCs with handsets PDAs and therefore requires enforcement of a security policy with regard to personal data transfer operations to ensure that not every handset can move personal data to every PC . As a result the application scenario requires a high security level.

Table 3 includes an application scenario generated during application launch from ActiveSync line 3 . This instance of ActiveSync has the same PID as specified in line 2. This application scenario is characterized by the application ActiveSync the operation write and the content type a PST e mail database file .

As described in Table 1B above such an application scenario requires no read performance high write performance However in contrast to the application scenario specified in line 2 this application scenario uses a small buffer size during database updates due to small data writing operations caused by frequent updates and a very high endurance due to massive updates of the e mail database. Due to the security policy of synchronizing e mails from PCs to handsets PDAs as mentioned with regard to line 2 the application scenario requires a high security level.

Table 3 includes two application scenarios generated during application launch from Windows Media Player WMP lines 4 and 5 each having the same PID . Both applications are characterized by the WMP application and by the same content type an MPEG video file . However the application scenario in line 4 is characterized by the write operation whereas the application scenario in line 5 is characterized by the read operation.

The application scenario in line 4 represents a scenario of downloading a video file from the network and writing the file into storage as fast as possible read performance is not applicable in this case . Due to the requirement that the process of downloading and storing the file into storage should be completed as fast as possible storage of the file cannot be performed in a power saving mode but rather with high write speed. Storage of the file requires large buffers due to the large amounts of data received from the network. Since an MPEG file is not usually modified during its lifetime until deleted neither updates nor modifications to the file are expected. For this reason the application scenario can tolerate low endurance. The WMP application scenario that deals with DRM video files line 4 should meet DRM protocols requiring a high security level.

The application scenario mentioned in line number 5 describes an application scenario generated during application launch from the WMP application with PID . This application scenario consists of reading a file from storage and sending the data to an audio speaker. The application scenario is characterized by the operation read and the content type an MPEG file with the MPG file extension . It requires a low read speed of about 16 KB sec write performance is not applicable in this case low endurance high power saving and a large buffer size. This application scenario requires a high security level for the same reason as the application scenario of line 4.

Table 3 includes an application scenario generated during application launch from Video Recorder VR with PID line 6 . This application scenario is characterized by the application VR the operation write and the content type an MPEG file with the MPG file extension . The VR application is executed on a handset PDA. The VR application scenario is responsible for capturing video from a camera module displaying video on the handset display converting the data received from the camera module into MPEG format and writing the MPEG data into the storage. The performance of video recording for MPEG is 8 KB sec per frame with 30 captured frames per second. As a result the VR application requires a very low write performance unlike the application scenario in line 4 but may require a constant bit rate from storage to prevent the user from noticing hiccups when watching the video. Consequently the VR application requires the storage to disable housekeeping operations until the VR application completes capturing the MPG file.

According to the above details the VR application scenario uses a small 8 KB buffer size and can operate in high power saving mode since the storage device can change the clock frequency from frame to frame read performance is not applicable in this case . Since amateur video capture does not require any security policy the application scenario requires a low security level i.e. no encryption at all .

Table 3 includes an application scenario generated during application launch from Photo Album PA with PID line 7 . This application scenario is characterized by the application PA the operation read and the content type a JPEG file with the JPG file extension . This application scenario reads picture files from storage and displays them on a handset display as fast as possible. Therefore the application scenario requires high read performance write performance is not applicable in this case uses a large buffer size and requires very low endurance since updates and modifications are not made to the pictures until they are deleted . There is no security policy for displaying pictures on a handset display. Thus the application scenario requires a low security level i.e. no encryption at all .

Every time a process sends a storage request through the FS services API of the OS Step the OS sends the FS a request with an attached PID as described above with regard to . The FS checks if the PID is listed in the PID field of one of the application scenarios in the AST Step . If the PID appears the FS executes the process request Step and the registration process comes to an end Step . If it does not appear then the FS sends a request to the OS responsible for the processes list as described above with regard to to get the application name according to the PID Step . Once the FS gets the application name from the OS the FS registers the process by updating the PID field in all application scenario entries that include the relevant application name Step . If the FS does not find any entry that corresponds to the application name it does not update any field.

The FS then executes the request according the application scenario parameters retrieved from the relevant application scenario entries located in the AST described in or according to default parameters if corresponding entries are not found Step . The registration process then comes to an end Step .

Once the application is launched as described above with regard to Step the process sends the application scenario parameters to the FS through the FS services API of the OS Step . The OS sends the request attached with the PID as described above with regard to to the FS. The FS sends a request to the OS responsible for the processes list as described above with regard to to get the application name according to the PID Step . Once the FS gets the application name from the OS the FS checks in the AST if there are any application scenario entries with an application name field identical to the application name that the FS received from the OS Step .

If there are no application scenario entries in the AST with the same application name then the FS adds the application scenario parameters into the AST Step . At the same time the FS updates the PID in the new application scenario entries. The process of updating application scenario parameters into the AST then comes to an end Step .

If there are application scenario entries in the AST as verified in Step with the same application name then the FS just updates the PID by updating the appropriate PID field in the AST in the relevant application scenario entries Step . The process of updating application scenarios parameters into the AST then comes to an end Step .

The FS then reads the relevant application scenario parameters from the AST Step . Next the FS checks if the request is a write command or not Step . If the request is a write command the FS looks in the SAT sub area parameters and tries to find an available storage sub area with attributes that best match the attributes that were read from the AST Step . If the request is a read command then the FS continues to the next step in the procedure.

The FS then determines a storage mode according to the desired AST parameters described in Table 3 and the matching SAT sub area parameters described in Table 2 provided by the storage sub area Step . Lastly the FS executes the command received from the process in Step Step and the data request by the FS comes to an end Step .

While the invention has been described with respect to a limited number of embodiments it will be appreciated that many variations modifications and other applications of the invention may be made.

