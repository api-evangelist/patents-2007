---

title: System and method for improved visualization and debugging of constraint circuit objects
abstract: Features are provided for graphically representing constraints on design objects in an Electronic Design Automation tool. A particular constraint on one or more circuit objects is displayed as a highlighted region that extends to each visible circuit object to which the constraint applies. Attributes of the highlighted region, such as density and thickness, may proportionally represent attributes of the constraint, such as a strength or distance specified by the constraint. The highlighted region is superimposed on or around circuit objects. The highlighted region may be a halo, which is a partially transparent region filled with a color. Multiple regions that represent the same type of constraint or relationship are connected by line segments, providing the ability to visualize groups of constrained objects, including groups that span levels of a hierarchical design. Intersecting highlighted regions are blended together using techniques such as alpha blending.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865857&OS=07865857&RS=07865857
owner: Cadence Design Systems, Inc.
number: 07865857
owner_city: San Jose
owner_country: US
publication_date: 20070123
---
The invention relates to the design of electronic circuits and more particularly to methods for visualizing constraints in electronic circuit designs.

Electronic Design Automation EDA tools allow circuit designers to define constraints on the objects in a circuit design such as transistors and wires. A constraint is associated with one or more design objects and may represent relationships among design objects. For example in the context of the EDA domain constraints are ordinarily associated with design objects such as devices pins terminals instance terminals and interconnect wires to represent design parameters for the design objects and to represent relationships or requirements imposed by the design specification on the objects.

Constraints allow designers to bring consistency into the design flow and achieve structures which are known to the designer to be viable but which sometimes cannot be directly captured in design parameters and which are generally beyond the process design rules. For instance constraints help reduce second order effects such as parasitics and increase the chance that a design will meet design specifications in a small number of design iterations. A simple constraint example is that of symmetry when two symmetrically constrained objects are placed in a circuit layout they generally should be placed symmetrically about some axis with respect to each other. Effectively one object has to be the mirror image of the other. The symmetrical placement greatly increases the chances of these devices operating more identically in a practical integrated circuit manufacturing process that tends to include variations from one device to the next. Symmetrical placement is used to reduce the manufacturing variations and is one of many constraint relationships that can be used to achieve high yielding well performing designs.

With the increasing complexity of circuit design technology concepts such as constraint driven connectivity driven and design rule aware layout have been adopted by EDA tools in both the integrated circuit and printed circuit board domains. This capability allows multiple designers to encode and respect design constraints at various stages of design flow ensure correct connectivity and prevent design rule errors automatically. However smaller geometries growth in complexity design rules and constraints all contribute to a deluge of information too much to be managed manually.

To address the increasing number of constraints a mechanism may be used to manage constraints from a central location and distribute them to different tools. However as constraints may store and depict relationships between design objects these constraint relationships often are not presented in a manner that makes such relationships readily apparent. In particular constraints often are portrayed in a manner that does not sufficiently aid the designer in visualizing the relationships imposed. This inability to readily perceive what constraints have been annotated on the design may result in a designer s decision to run through and iterate on the design s physical realization in order to understand the constraint.

Thus there is a need for an effective visualization mechanism that allows design constraints to be effectively visualized on the design canvas along with the design objects to illustrate relationships between objects or groups of objects so as to facilitate analysis and understanding of the circuit even when the constraints are not being used to drive automated tools. The design objects should be clearly visible and accurately displayed along with the constraints. Visualization is especially important for analog designs where sizes shapes spacing and relative positioning of design objects in the circuit layout are especially important.

Prior approaches to visualizing constraints have involved the use of table based widgets which display the names of constraints and the names of design objects associated with the constraints in a tree or table format. These have been appreciated by users and are effective in listing constraints and their members. However often this list is very long and difficult to unravel and as constraint names are insufficient by themselves a mental leap is required to locate the corresponding constraint members in the design. In addition as the constraint relationships are not specially rendered or visualized on the canvas the table based widget approach also requires the designers to simultaneously keep track of the location and orientation of the actual design object and its proximity to other objects during interactive design editing. This problem becomes more severe as the number of design constraints increases making it more difficult for the designer to manually locate the design objects and then keep track of them.

Unfortunately there have been shortcomings with prior constraint highlighting techniques. For example in the above prior method highlighting occurs on a separate graphics drawing plane over i.e. above the drawing plane used for rendering the design objects. Therefore the prior highlighting approach often causes the actual device shapes to be obscured. If there are additional highlight objects e.g. textual annotations for constraint and member names in use to impart special meaning to highlighted design objects they too obscure the visible design areas. This is often a problem when the constraint has to be visualized for a prolonged duration. Further an attempt to highlight an object associated with multiple constraints in more than one color generally causes the object to be highlighted with the last applied color which makes it difficult for the designer to see what other constraints apply to a design object. Moreover the prior highlighting method typically draws the highlighted object shape in the same width as the un highlighted object which is often too narrow to visually stand out. Other limitations include the inability to visualize other forms of interconnection between devices or group relationships in a way that does not obscure the spatial and electrical relationships. The prior technique also fails to adequately show relationships that involve objects not displayed in the current view such as relationships between objects on different levels of the design hierarchy. For example a relationship that matches a transistor at the top level with a transistor several levels down a schematic hierarchy may coerce logic designers into either unnecessarily flattening a hierarchy or moving a first device which should be placed at a certain level for logical or electrical reasons to some other level so that the first device can be spatially close to a second device on the other level to which its properties are to be closely matched.

With reference to the prior highlighting method of if multiple constraints are associated with a single design object the design object will be displayed in only one of the colors. Therefore the circuit designer will not see a visual indication that multiple constraints are associated with a single design object. For example the association of the label Constr  with two diodes is represented by changing the color of the diodes to the same color as the constraint Constr  text label . If the Constr  text label is displayed in blue then the diodes may be displayed in blue to indicate that Constr  is associated with the diodes . If a second constraint ConstrO of a different type than Constr  is also associated with the diodes then the color of the diodes will again be changed to the color associated with Constr  replacing the color associated with Constr  so that at most one associated constraint is visualized at a time. Note that changing the colors of the design objects interferes with the appearance of the circuit design and may result in loss of information or confusion. If the original non highlighted color of the design object conveys visual information about that design object then replacing the color will result in loss of that visual information.

Other visual aspects of the prior highlighting method typically interfere with the appearance of the circuit design. The displayed design objects may be obscured and modified by for example rectangular boxes drawn around the devices to indicate association with a constraint. The constraint names such as Constr  may overlap and obscure portions of the displayed design objects. For example the constraint name Constr  partially overlaps a solder dot near the transistor and the constraint name Constr  partially overlaps a wire thereby partially obscuring the wire .

Thus there is a need for improved constraint visualization in the Electronic Design Automation context. The present invention meets the need.

In general in a first aspect the invention features a computer enabled method to produce a display of a design constraint on a computer screen in an Electronic Design Automation tool. The method includes producing a display of a first highlight feature on the screen in the proximity of a first design object where the first highlight feature represents the association of a constraint with the first design object at least a portion of the first design object remains visible while the first highlight feature is displayed and the visual appearance of the first highlight feature indicates an attribute of the constraint. Embodiments of the invention may include one or more of the following features. The first highlight feature may have a color that indicates the type of the constraint and the first highlight feature may be transparent. The first highlight feature may have a fill style that indicates the type of the constraint. The fill style may include cross hatching randomized stippling a dashed line style or a combination thereof. The first highlight feature may be displayed as a transparent overlay on top of the design object. The first highlight feature may be displayed as a transparent underlay under the design object. The first highlight feature may be displayed adjacent to the design object. The first highlight feature may be superimposed on the design object and may appear as a transparent underlay under the design object. The first highlight feature may surround the design object. The first design object may include a representation of a transistor wire resistor diode pin terminal net or combination thereof. The first design object may include an active electrical component a passive electrical component a geometric shape a representation of the physical form of an object in a circuit design or a combination thereof. The first design object may include a cell instance that contains a constrained design object where the constrained design object is associated with the constraint.

In general in a second aspect the invention features a computer enabled method to produce a display of multiple design constraints on a computer screen in an Electronic Design Automation tool. The method includes generating a highlight feature on the screen in the proximity of a design object where the highlight feature indicates that multiple constraints apply to the design object.

In general in a third aspect the invention features a computer enabled method to produce a display of multiple design constraints on a computer screen in an Electronic Design Automation tool. The method includes generating a merged highlight feature on the screen in the proximity of a design object where the merged highlight feature represents a first constraint and a second constraint the first constraint and the second constraint are associated with the design object and at least a portion of the design object remains visible while the merged highlight feature is displayed. The method also includes setting the color of the merged highlight feature by blending a first color that indicates the type of the first constraint with a second color that indicates the type of the second constraint. Embodiments of the invention may include one or more of the following features. Blending may include alpha blending the individual colors. The method may include producing a display of a second highlight feature on the screen in the proximity of a second design object where the second highlight feature represents the association of the constraint with the second design object at least a portion of the second design object remains visible while the second highlight feature is displayed. The method may also include generating an interconnect halo segment that visually connects the first highlight feature to the second highlight feature where the visual appearance of the second highlight feature and the visual appearance of the segment indicate the type of the constraint. The second design object may include a representation of a transistor wire resistor diode pin terminal net or a combination thereof. The first design object may include an active electrical component a passive electrical component a geometric shape a representation of the physical form of an object in a circuit design or a combination thereof.

The second design object may include a cell instance that contains a constrained design object wherein the constrained design object is associated with the constraint. A first end of the segment may connect to a first interconnection point of the first design object and a second end of the segment may connect to a second interconnection point of the second design object. The segment may include a horizontal line a vertical line a diagonal line or a combination thereof. The first highlight feature may be generated in response to selection of the constraint from a list of constraints presented in a constraint list user interface component of the Electronic Design Automation tool. The thickness of the first highlight feature may be proportional to a strength attribute of the constraint. The fill density of the first highlight feature may be inversely proportional to a strength attribute of the constraint. The method may include if the constraint is associated with a second design object wherein the second design object is on a higher level of the design hierarchy than the first design object producing a display of an up connector on the screen where the up connector represents an association with the higher level of the design hierarchy displaying the name of the constraint in association with the up connector and generating an interconnect halo segment that visually connects the first highlight feature to the up connector where the visual appearance of the up connector and the visual appearance of the segment indicate the type of the constraint. The method may also include if the up connector is selected by a user displaying the higher design hierarchy level.

The method may also include if the constraint is associated with a second design object and the second design object is on a lower level of the design hierarchy than the first design object producing a display of a second highlight feature on the screen in the proximity of an instance that contains the second design object where the second highlight feature represents the association of the constraint with the second design object and at least a portion of the instance remains visible while the second highlight feature is displayed. The method may also include generating an interconnect halo segment that visually connects the first highlight feature to the second highlight feature where the visual appearance of the second highlight feature and the visual appearance of the segment indicate the type of the constraint.

In general in a fourth aspect the invention features a computer enabled method of generating an interconnect halo segment to join design objects in an Electronic Design Automation tool. The method includes determining a first set of interconnect points for a first design object determining a second set of interconnect points for a second design object generating line segments between each point in the first set and each point in the second set. The method further includes if a first line segment between two points is the shortest line segment between those points and the line segment is horizontal or vertical choosing the first segment otherwise if a second segment between two points is the shortest line segment between those points and the second segment does not pass over a pin choosing the second segment otherwise choosing a third segment between two points wherein the third segment is the shortest line segment between the first design object and the second design object and drawing the chosen line segment.

In general in a fifth aspect the invention features a computer enabled method of generating highlight features and interconnect halo segments to represent a relationship between design objects in an Electronic Design Automation tool. The method includes acquiring an input list of design objects computing a bounding box of objects in the input list generating a first list of objects fully inside a first portion of the box wherein the first portion is separated from a second portion of the box by a bisector line that bisects the bounding box generating a second list of objects fully inside the second portion of the box generating a split list of objects wherein the split list includes objects intersected by the bisector line generating highlighted interconnect halo segments between objects in the split list setting a first optimum object to an object fully inside the first portion of the box setting a second optimum object to an object fully inside the second portion of the box if the split list is empty generating an interconnect halo segment to join the first optimum object to the second optimum object if the split list is not empty generating an interconnect halo segment to join the first optimum object with a nearest split object in the split list where the nearest split object is the member of the split list closest to the first optimum object. The method also includes recursively invoking the method on the first list and recursively invoking the method on the second list.

Embodiments of the invention may include one or more of the following features. If the length of the box is greater than the width of the box bisecting the box vertically otherwise bisecting the box horizontally to produce a bisector line. Generating a split list may include sorting the split list so that the objects in the split list are ordered based upon their positions in the split direction. Generating highlighted interconnect halo segments may include for each split object in the split list generating an interconnect halo segment between the split object and a nearest neighbor object where the nearest neighbor object is the split list member closest to the split object. The method may further include highlighting each generated interconnect halo segment and highlighting each object in the split list.

In general in a sixth aspect the invention features a system for producing a display of a design constraint on a computer screen in an Electronic Design automation tool. The system includes a first highlight producer to produce a display of a first highlight feature on the screen in the proximity of a first design object where the first highlight feature represents the association of a constraint with the first design object at least a portion of the first design object remains visible while the first highlight feature is displayed and the visual appearance of the first highlight feature indicates an attribute of the constraint.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of particular applications and their requirements. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover in the following description numerous details are set forth for the purpose of explanation. However one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances well known structures and devices are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

In the color or shading of a highlight feature may indicate a particular type of design constraint that applies to i.e. is associated with a design object . The highlight feature which is displayed on a computer screen by an EDA tool software program helps the designer to quickly comprehend the types of design constraints that apply to particular design objects by looking at the circuit design using the EDA tool. A highlight feature is ordinarily a shape that highlights a design object to indicate that the design object is associated with a particular design constraint . Design constraints typically include attributes and establish an association between those attributes and one or more design objects. An attribute is typically a data value provided by a designer to specify information such as fabrication process parameters and layout hints for use in fabricating the circuit.

In this example the constraint is a symmetrical placement constraint which specifies that the associated design objects are to be placed symmetrically in the placement phase of generating the circuit layout. A diagonal line fill style is associated with the constraint in . Note that the constraints shown in are displayed for illustrative purposes and are not necessarily shown on the canvas of the EDA tool. However the designer knows through some user interface feature that design objects that have a diagonal line highlight feature such as the feature are subject to the symmetrical placement constraint.

In one aspect the highlight feature is displayed in the proximity of the design object . The term proximity specifies that the highlight feature is displayed near or at the location of the design object . In one aspect the term proximity means that the highlight feature overlaps the design object on the screen or that the highlight feature overlaps a bounding box defined by the outermost points of the design object . In another aspect proximity means that the highlight feature appears to be adjacent to the design object or that the highlight feature is superimposed on the design object.

The visual appearance of the highlight feature e.g. the color or fill pattern represents the particular type of design constraint with which the design object is associated. shows diagonal fill lines to illustrate the color or fill pattern. On a computer screen colors may be used to represent the design constraints so that a first constraint would be represented by a corresponding color such as a green color. The color may be partially or fully transparent. Transparency and alpha blending are two separate attributes both achieved by using image processing techniques. Transparency is a see through effect used in displaying images such as halos as described below. Transparency allows underlying design objects to be clearly visible.

Displaying the highlight feature in a partially transparent color allows the highlight feature be displayed without obscuring other design objects. This display technique is known as an overlay. In one aspect the highlight feature is displayed as a halo. Halos are drawn on a drawing plane which is above the drawing plane on which design objects are rendered. The halo color is alpha blended at different places with the different colors of the design objects. Partial transparency causes the underlying objects to be made partially visible. Displaying the highlight feature in a fully transparent color allows the highlight feature be displayed without obscuring other design objects. This display technique is known as an underlay. The halos are either drawn on a drawing plane that is below the normal drawing plane on which design objects are rendered or more preferably the halos are drawn on a drawing plane which is above the normal drawing plane on which design objects are rendered but made to appear as if they drawn on a drawing plane that is below the normal drawing plane on which design objects are rendered. Generating an underlay is computationally more expensive as it requires use of expensive image processing operation but is still preferred as it avoids the need for a separate drawing plane which is even more expensive to render underlay.

Transparency allows the design object and other design objects such as wires connected to the design object to remain substantially visible in the presence of the highlight feature . The highlight feature may overlap some design objects in which case the overlapped design objects will be displayed in a slightly different color that has been filtered by the transparent highlight feature . Transparency allows the highlight feature to be superimposed on the design object so that aspects of both the highlight feature and the design object are visible. Transparency is described in more detail below.

A highlight feature that is displayed in a particular color where the color is partially transparent is referred to herein as a transparent halo or simply a halo. When more than one halo is displayed in the same location the colors of the halos are blended together using a blending technique such as alpha blending. As is known to those skilled in the art of computer graphics alpha blending is a combination of two colors to produce a third color that appears to be a transparent rendition of one of the original colors superimposed on the other original color.

Alpha blending is used to combine two different halos to produce a third halo that appears to be a combination of the first two. Alpha blending may also be used to blend the halo or a combination of blended halos with design objects on the circuit design such as wires or transistors to produce a resulting image in which the halo appears to be partially transparent and overlaid on the design objects. Alternatively rendering the halo image as an underlay i.e. on a graphics plane below the design object or as an overlay i.e. on a graphics plane above the design object may also be employed. With the alpha blending technique the design object remains clearly visible in the presence of the halo and the color of the original design object does not change. Since the color of the design object also conveys certain visual semantics to the user the preferred embodiment uses this latter overlay or underlay approach with respect to design objects. Halos that overlap each other are alpha blended with each other and halos that overlap design objects are overlaid on or underlaid below the design objects.

Alpha blending combines two colors C and C to produce a blended color C where C C and C represent a single red green or blue value of a red green blue combination that defines a color. C C and C may also be vectors with red green and blue components. A factor named alpha is used to scale each of the colors. As the value of alpha varies from 0 to 1 the blended color ranges from an opaque C through a blend of C and C to an opaque C. C appears to be a background color and C appears to be a foreground color blended onto C. For example in some embodiments the value of the blended color C is given by the following formula 32 alpha 1 1 alpha 

Because of their transparency which may be implemented using underlay overlay or alpha blending techniques halos may be superimposed on the design objects without obscuring the design objects or otherwise hiding design information. Fill patterns such as the diagonal fill pattern shown in are used herein for illustrative purposes to represent colors of highlight features. However such fill patterns e.g. lines dashes or stipples may also be displayed on the computer screen to indicate design constraints in place of or in addition to colors.

The design object may be associated with more than one design constraint in which case a highlight feature for each constraint is displayed in the proximity of the design object . Such multiple highlight features are typically displayed in the same location and superimposed so that the presence of all features can be discerned by the user.

To achieve transparency the highlight feature may be displayed as an underlay or an overlay of the design object. In the highlight feature is displayed as an underlay under the design object i.e. on a graphics plane below the design object so that the highlight feature appears to be behind the design object and does not obscure or hide portions of the design object that the highlight feature overlaps. Underlay display is suitable for schematic displays since the design objects are typically displayed using narrow lines that appear to be one dimensional. The highlight feature is displayed as an overlay above the design object i.e. on a graphics plane above the design object so that the highlight feature appears to be in front of the design object and so that the design object appears to be less prominent than the highlight feature . Overlay display is suitable for layout displays since the design objects are generally two dimensional shapes i.e. relatively wide rectangles or polygons.

The thin lines of the design objects in a schematic view may be drawn directly on top of the thicker halos and both the lines and the halos will be clearly visible. That visual effect may be achieved by drawing the halos as underlays on a drawing plane below the schematic objects. The thin lines of the schematic objects are not obscured because the lines are drawn on top of the halos. Conversely for layout views the design objects are typically displayed as rectangles or polygons and the halo images are displayed using thin lines. The halo images in layout diagrams are typically displayed as thin lines that correspond to the outline or perimeter of the rectangles that form the design objects in the layout view. In the layout view the halos are drawn as an overlay i.e. thin lines that form the halo are drawn on top of the wider design object rectangles. Consequently both the halos and the design objects are ordinarily clearly visible. Both schematic objects and layout objects can be clearly seen in the presence of halos and the original colors of the schematic and design objects are preserved when the halos are displayed.

A further technique to achieve transparency between highlight features and design objects would be to alpha blend the resultant halo color of the highlight feature with the color of the design object and display the overlapping regions in the blended color. However this technique is not chosen in the preferred embodiment because it may change the perceived color and therefore possibly the perceived semantics of the design object .

The shape of the highlight feature is typically an outline around the corresponding design object where the outline has rounded corners. For example the highlight feature is a square with rounded edges which is an outline of the square highlight feature . A highlight feature for a transistor object is shaped as an outline of the transistor object . The highlight feature visually indicates that the symmetrical placement constraint applies to the transistor object . Note that highlight features appear as constraints are applied to displayed design objects by the user of the EDA tool and disappear as constraints are removed from design objects. The highlight feature is displayed as an underlay while a highlight feature is displayed as an overlay superimposed upon the design object .

Another example of a highlight feature being displayed as an outline of the shape of a design object is shown with respect to a wire design object . The wire object is shown with a highlight feature with a vertical line fill style which indicates that a shielding level constraint applies to the wire object . Note that the value 2 is an example of an attribute value of the constraint and shielding is the type of the constraint .

In one example when a design object is associated with multiple constraints the highlight features for the constraints are displayed in the same location so that multiple highlight features are superimposed. In this superimposed highlighting can be seen on a transistor object which is associated with two constraints the symmetrical placement constraint and the shielding level constraint . The highlighting feature for the transistor object is displayed by superimposing vertical line fill style for the constraint on the diagonal line fill style for the constraint . Similarly for color halos the color associated with the constraint would be blended with the color associated with the constraint using a technique such as alpha blending. For example if the color associated with the constraint were blue and the color associated with the constraint were green the color of the highlight feature would be a shade of purple. Any number of colors can be blended together so any number of overlapping constraints can be displayed as a blended color.

An interconnect halo segment indicates that the two design objects at either end of the segment are associated with the same constraint. An interconnect halo segment is ordinarily not an electrical connection or other actual circuit design object. When a constraint applies to multiple design objects highlight features or halos are produced and displayed around i.e. overlapping or in the proximity of each of those design objects. An interconnect halo segment is then drawn between the highlight features to indicate that the design objects are associated with the same constraint. The interconnect halo segment is drawn in the same style as the highlight features or halos. Therefore a single larger halo appears to cover each of the design objects and the interconnect halo segment . A designer can clearly see the design objects that are associated with a particular constraint because the larger halo covers the design objects . Furthermore if some of the design objects associated with the constraint are not displayed on the screen e.g. because the circuit is too large to fit in the display window or because some of the objects are located on different levels of the design hierarchy the interconnect halo segments indicate that the unseen design objects are present because the segment connection leads from the visible design objects toward the unseen design objects. The designer can follow the segment connection to find the unseen objects e.g. by scrolling panning or zooming the window or by switching the display to the hierarchy level on which an unseen object is located. Although halos represent constraints in this example other types of relationships could be visualized using halos in a similar manner.

In although the design object D and the design object B are connected by a design object C and the halo connects those design objects the object C is not associated with the same constraint symmetrical placement as object D so a separate interconnect halo segment is drawn between object D and object B . The halo segment indicates that those objects are both associated with the same symmetrical placement design constraint as illustrated by the use of the same diagonal shading pattern for objects and .

In one aspect for highlight regions that are displayed as transparent halos the halo outline is generated by applying two two dimensional transformations in order on the image of objects to be highlighted. The first transformation is called dilation and results in the objects appearing thicker or inflated. The second transformation is called box blurring and results in smoothing of the jagged boundary of the dilated image. The smoothing happens in a controlled and non uniform way such that the outer regions of the halos are less dense as compared to the inner regions. This density variation generates a fadeout effect. The two transformations produce a halo image outline. Next the halo image is imposed onto the image displayed on computer screen. In one embodiment a bit blitting process is used to impose the halo image. In the process alpha blending overlay drawing or underlay drawing techniques may be used as described above to generate the transparent effect. The halo may be imposed or drawn by invoking a graphics application programming interface API . In the graphics API the transparency is defined by defining a drawing pen. The drawing pen is actually a graphics context through drawing attributes such as fill color line style alpha for transparency and the like may be set. The halo type and the halo color are set by setting these attributes.

The types of design objects that may be highlighted include devices such as transistors and diodes wires nets and terminals. An example net includes three pins on the wire . The pins are associated with the device names MP4 MP1 and MP5. The term net ordinarily refers to a single connecting wire. The term net has a broader meaning as well which is an abstract object that stores connectivity information. For example a net may store the name of the net signals of a net different unique and single bit members shapes or figures associated with the net instance pins associated with the net and the like. Design elements that depict connectivity on the design canvas are shapes e.g. the lines that represent wires and the rectangles and polygons that represent pins. Each net may be associated with more than one shape so a net may include more than one connecting wire. When a user selects a constraint that has a net member some or all associated shapes or figures of the net are haloed and grouped together i.e. joined with interconnect halo segments.

In one aspect a terminal is an abstract object that is associated with a net in a hierarchical design module. A terminal is typically exported for use in establishing connections between the associated net and other nets or design objects. A terminal may also be associated with a pin. A pin may in turn be associated with a shape and the shape may be displayed on the design canvas to represent the pin. A terminal may be understood as a connector on a net to which a pin may be connected. A terminal has a name and the terminal s name may be different from the associated net s name. If a terminal is a member of a constraint the terminal s membership in the constraint is visualized using an indirect procedure. Because the terminal is an abstract object the only perceivable entities are the pins that are associated with the terminal. Thus to visualize terminal type constraint members the highlighting method highlights and interconnects the shapes or figures that represent each of the terminal s pins to generate a transparent halo around the terminal pins.

In one aspect a pin is a design object that is ordinarily associated with a terminal. The pin may be further associated with a shape or figures that may be drawn on the design canvas to represent the pin. A pin also has a name which can be different from the associated terminal s name. If a pin is a member of a constraint the associated figures of the pin with the specified pin name may be interconnected and visualized using halos.

A cell is in one aspect a template from which a set of design objects called instances can be replicated on the design canvas multiple times. A cell is typically stored in a cell library which contains a set of commonly used or standardized cells. The pins of cells are referred to as design pins and the pins of cell instances are referred to as instance pins.

In one aspect the halos are transparent and are displayed as an underlay. That is the transparent highlight occurs below the design object in order to preserve the displayed image of the design object. As can be seen in the image of devices have been specially highlighted using transparent halos which do not obscure the design objects such as wires instances text annotations and the like. The shapes for the highlighted objects such as its pins are clearly visible because the halos are partially transparent. For example the instance name label D for the diode overlaps with the interconnect halo segment between the diode and the transistor but is clearly visible and has not been obscured because of the transparency of the interconnect halo segment. Note that the effect is not completely illustrated in because the drawing is not in color. On a computer screen where thousands or millions of different colors can be displayed the transparent effect achieved by drawing on multiple graphics planes or by color blending allows design objects and text labels to be visible simultaneously with the halo effect. Similarly the label w 8u on transistor is also clearly visible. The fact that the halos do not obscure the actual design objects prevents loss of displayed information which may be of use to the designer during design creation and debugging of circuit designs. The fact gains more importance when the degree of constraint relationship is strong and the halo width is proportionately increased. The device pins and shapes are clearly visible through the halo and so are the wires that connect these haloed transistors.

In some embodiments while visualizing constraints the thickness or density of the halo shape and connecting segments is used to indicate the degree or strength of the relationship represented by a constraint visualized through the halo. Different halo densities are typically achieved during the dilation and box blurring transformations used to produce the halo shapes. Wider dilations result in wider or lower density halos.

In one aspect a design object halo is drawn around each design object. For example the halo around the transistor design object extends around the design object and covers the three pins of the design object but does not extend to other design objects. That is the design object halo around the design object does not include the interconnect halo segments those segments join the design object halo around the transistor to other design object halos around a transistor and a diode . The combination of the design object halos around the design objects and the interconnect halo segments is referred to in this specification as a larger halo. Furthermore a halo around a design object refers to the design object halo and does not include any interconnect segments joined to that design object halo. These terms are used for explanatory purposes. Alternatively a halo that covers multiple related design objects and connects the design objects may be referred to as a single halo and may be formed by methods other than those described herein.

The interconnect halo segments and join the transistors and diodes as described above to form a larger halo that represents the constraint C. The interconnect halo segments and are drawn in blended colors of purple green and purple cyan respectively to indicate that the associated transistors or diodes are also associated with the constraints C and C respectively.

The halos around the diodes and are drawn in a purple green blended color because those two diodes are associated with constraints C purple and C green . The interconnect halo segment which joins those two diodes is also drawn in the purple green color. The interconnect halo segment therefore connects the halos around the diodes to a form a larger halo that represents design objects associated with both constraints C and C.

The halos around the transistors are drawn in a purple cyan blended color because those two transistors are associated with constraints C purple and C cyan . The interconnect halo segment which joins those two transistors is also drawn in the purple cyan color. The interconnect halo segment therefore connects the halos around the transistors to form a larger halo that represents design objects associated with both constraints C and C.

In one aspect care is taken to draw a minimum number of interconnect halo segments as described in more detail below. The number of interconnect halo segments is substantially minimized by drawing an interconnect halo segment from each design object to the design object s neighbor design object s so that all design objects associated with the halo are interconnected. Therefore as shown in the segment has been drawn from the transistor to the nearest neighbor of the transistor . Similarly the segment has been drawn from the transistor to the nearest neighbor of the transistor and so on for each design object associated with the constraint. To avoid visual clutter no interconnect segment has been created between transistor device and diode device .

In a halo is displayed around each design object . The halos around the design objects are joined together by interconnect halo segments . The halo around each design object is joined by an interconnect halo segment to a halo around a nearest neighbor design object . The group of halos joined by the interconnect segments appears to be a single larger halo. A halo of a single uniform color is drawn around every transistor shown in which means that every transistor shown is associated with the same constraint. The interconnect halo segments are calculated and created dynamically depending on the constraints that are shown and depending on the current design level being displayed in the EDA tool.

There are exceptions to the rule that interconnect halo segments join nearest neighbor objects. In one aspect if the design objects are instances of symbols the connecting segments do not begin from and end at instance pins. In addition care is taken that the interconnect halo segment does not overlap with the instance pins of the two constraint objects if any as shown in . Overlapping is avoided where possible to avoid coincidence of device instance interconnect halo segments with electrical connectivity wires which typically tend to run from instance pin to instance pin but may not be part of the constrained group of objects. Visual separation of instance interconnect halo segments from electrical wire interconnects that are part of the constrained set is beneficial because it avoids the improper perception that unconstrained wires are part of a constraint group. A segment generation process automatically computes a set of optimum join points other than the pin locations and draws an optimum connecting segment by drawing a segment between the optimum join points.

The up connector is connected to the design object by an interconnect halo segment to indicate that the design object is associated with a constraint. A name of the constraint may be shown near or in association with the up connector . To improve ease of use a menu may be displayed when the user clicks the mouse over the up connector. The menu may allow the user to traverse or navigate to a reference point such as the location of the higher level design object not shown to which the up connector refers.

A constraint may be associated with multiple design objects and design objects may be placed on different levels of a design hierarchy. The EDA tool typically displays the design objects that are located on a currently selected hierarchy level. If a displayed design object is a member of i.e. associated with a constraint that is also associated with other design objects not shown on one or more other levels of the design then an up connector will be displayed for the design object to indicate that the constraint associated with the design object crosses hierarchy levels. In one aspect if constraints are being visualized in a window that only shows some of the design objects associated with the constraint the an up connector is attached to the top most visualized design object in the window.

The location of the automatically generated and placed up connector is not fixed. In some embodiments an up connector is dynamically placed on the design canvas and is ordinarily connected by a segment to the topmost rightmost design object in the set of design objects associated with the constraint. The up connector is placed just above the object or towards its right if there is enough free space. A region query operation is employed in the database to produce instances shapes in a given area. If enough free space is not present the up connector may be placed on the top or right extreme of the design boundary depending upon which position generates a shorter joining segment.

The up connector may be used to show that a constraint on a design object in the currently displayed hierarchy level also applies to another design object in a higher level. The design objects may be any type of design object such as a net pin terminal transistor or the like.

Constraint names may be displayed on the design canvas. In one aspect a constraint name is ordinarily displayed as a separate label in the same style or color as the constraint s highlighting or halo features. With reference to a label appears adjacent to an up connector if an up connector is present. If no up connector is present a different approach may be used to display the name label. In one aspect legend symbols are used to avoid the need to find free space near the design object s for label placement. If an interconnect halo segment is present on the constraint halo a circular legend symbol is placed over the interconnect halo segment. If there is no interconnect halo segment the legend symbol is placed at the interconnect point at the top right of the design object. A similar circular legend symbol is placed in a legend area on the right side of the design along with a label that describes the constraint. In one aspect each location where a circular legend symbol has been placed is remembered and if more than one circle is to be placed on a segment the label generation process searches for available locations on alternate interconnect halo segments or interconnect points of the top right constraint object so that the circular legend symbols are non overlapping.

Circular legend symbols that have the same appearance e.g. color and shape as the circular legend symbols are shown in a legend area which is typically displayed along the periphery of the design canvas. Each circular legend symbol is shown in the same color as the corresponding halo over which the symbol is displayed. The constraint name Constr  is displayed adjacent to the symbol . Similarly the constraint name Constr  is displayed adjacent to the symbol . The phrase displayed over expresses one possible way in which the circular legend symbols may be displayed in association with halos. The symbols need not be displayed over the halos. Instead the symbols could be drawn or displayed as part of the halos or displayed under the halos.

Different styles may be used for highlighting nets because when displaying a halo around a net and in particular joining haloed nets together with connecting segments it becomes difficult to visually distinguish net halos from halos of other design objects such as transistors. Also since nets tend to be vertical or horizontal straight lines two nets are likely to be co linear and the halo around the two nets will appear to be around a single net. Furthermore the interconnect halo segments between two instances may actually run along a net giving the net the appearance of being a net halo. Therefore in one aspect the net halos use a different line style e.g. dashes or randomized highlighting and the joining segments between them are replaced by arcs which may also be displayed using dashed or randomized highlighting.

In one aspect when a constraint applies to a currently displayed net object and to a member higher in the design hierarchy than the currently displayed net object an up connector is drawn. The up connector may be a pin like up connector joined by arcs or a circle of a fixed size or other symbol of similar intent. When a constraint applies to a currently displayed net object and to a member deeper in the design hierarchy than the currently displayed net object the instances which contain the members are haloed and joined to the net via an arc in a similar manner to it being part of an instance constraint.

Referring to the user may apply a constraint between for example x and x in all instances of lib.cell view. In that case the constraint s storage will be in lib.cell.view. The member names x and x are not fully qualified i.e. the names do not begin with a character. That is an example of a cell constraint. Note that a constraint member is an object such as a design object to which a constraint applies. When a cellview that has a cell constraint is instantiated all instances of that cellview i.e. master inherit the cell constraints. That is the cell constraint applies to all occurrences of the objects in the master design. In such as case if the user opens a window displaying the top cellview then descends into either i or i they will see the same constraint being visualized using transparent halos either displayed as an overlay or as an underlay . The Constraint Visualization Engine also supports the visualization of cell constraints which apply to all occurrences of the objects in design. A cell constraint can be associated with a cell. As described above with respect to a cell is in one aspect a template from which a set of design objects can be replicated on the design canvas multiple times. A cell constraint constrains instances inside the cell. The cell constraint automatically applies to any other instance of the cell that appears in the of design hierarchy and constrains the design objects inside each such instance. For example a cell constraint that constrains two instances inside a cell may be represented as a tuple sub constraint cell instance a instance b . For each instance of the cell in the design the sub constraint will be applied to both instance a and instance b.

In addition if a user specifies a second constraint of different type between i x and i x such that the storage of the constraint is within the top level cellview lib.cell.view and the member names e.g. i x and i x are fully qualified i.e. begin with a character then this constraint is an example of an occurrence constraint. If a user opens two windows both starting from the top level with one window descending into i and the other window descending into i for the window on i the user will see two constraints while the other window on i will only display one constraint.

Given that the constraints can be placed on either specific occurrences an occurrence of instances nets terminals or pins in a design or on all occurrences of objects in a design the constraint visualization technique is able to support occurrence specific figures. If the user has created a constraint for one particular occurrence then it will only appear in windows opened on the design which have that particular occurrence.

The name in braces is the Cell where the constraint is defined i.e. where the constraint has its storage. For example Const is defined in Cell B. For the sake of simplicity references to the Library which contains the Cell have been omitted.

In the symbolic diagram shown in each of the constraints has been drawn as a separate box around the instances with interconnect halo segments shown crossing the boundaries and with a different color for each constraint as would occur when each constraint is of a different type . However this appearance might not be the way that the constraints will be visualized in a schematic. A user typically may not see multiple levels simultaneously and the overlay boxes would be overlapping and alpha blended halos around the instances. is shown for explanatory purposes and like the other figures is not necessarily an exact representation of a display view generated by an EDA tool. Multiple design levels such as A B and Care generally not displayed simultaneously in an EDA tool and the overlay boxes would be overlapping and alpha blended halos around the instances. Note that in layout views or schematic views when the user has performed an edit in place or set has the display stop levels interconnect halo segments typically will be displayed as shown in . As before the boxes would be the composite of the transparent halos.

There is computer program code to support visualization of occurrence constraints and there is computer program code to support visualization of cell constraints. An occurrence constraint is a constraint that is defined on a particular design object. A cell constraint is a constraint that is defined on a cell and applies to instances of that cell. Unlike occurrence constraints in which the visualization only appear in windows opened on the designs which have the desired occurrence for cell constraints all occurrences of the cell constraint are searched in all windows and each occurrence is then visualized separately.

Computer readable code such as code for implementing the interconnect halo segment generation process of or the highlight generation process of and can be stored in the storage memory and used to control the CPU . The computer program instructions can cause the CPU to produce highlighted regions such as the transparent halos of C and D in the user interface of an EDA tool.

The constraint manager is for example a table based widget that uses the constraint API to allow accelerated constraint entry plus constraint browsing and editing capabilities. The browser allows the designers to specify constraint members by way of canvas selections. It invokes the constraint visualization engine described next to display constraints and constraint members selected in the constraint browser.

The constraint visualization engine allows the constraints to be displayed on the canvas using transparent halos. Transparent halos are a graphics technique provided by a Graphics Layer GL library and are made available by a Graphics Editor GE package through a hilight infrastructure which allows design objects placed at various levels of design hierarchy to be highlighted. The GL GE API draws on the highlight plane with a special pen to produce the halo effect. In addition the GL GE API provides routines for setting the halo attributes such as its transparency 0 100 position underlay or overlay color and width thin normal thick or any other width . Other graphics libraries such as OpenGL could be used to equal effect without departing from the spirit of the present invention.

The visualization engine includes an application programming interface API an initialization module an object generation module a hierarchy traversal module an object grouping module a segment generation module a label generation module an object highlight module and constraint visualization triggers. The Constraint Visualization Engine exports its capabilities through an API and is best used in conjunction with another widget such as a Constraint Manager. Selections made in the Constraint Manager or explicit Constraint Visualization API calls cause the constraint to be visualized on the EDA tool s design canvas. The API includes routines for performing the following operations visualization of constraints in a display window removal of visualized constraints from a display window visualization of all or only some members of a constraint and specifying values for the display attributes width transparency color of transparent halos. The initialization module processes a constraint specified by an identifier ID by calling the constraint API to generate information about the constraint and its members. The initialization modules verifies the API arguments registers the constraint name and storage information to be accessed later and also calls the GE API to create empty highlight sets which will be populated by the Object Grouping Module.

As the constraint information is represented internally by textual data constraint name member name hierarchy path etc. the Object Generation Module uses the textual data e.g. constraint member names such as MP12 to generates actual design object identifiers that correspond to constraint members. The object generation module may map constraint member type to various design objects. For example if the constraint member type is instance the modules generates the corresponding design instance object and if the constraint member is of type net terminal or pin then the object generation module generates all the images corresponding to that net terminal or pin. 

For names that are hierarchical in nature such as TOP INV MP0 the object generation module parses the entire name string and attempts to generate the design object s as per the visible hierarchy. For example if the constraint member to be visualized is TOP INV MP0 where TOP is the top level schematic and INV is an inverter schematic instantiated inside TOP the object generation module would generate the instance ID of MP0 in INV and would return the ID and the hierarchical path and the effective transformation. The transformation would include a location an orientation and a magnification. However if INV is an inverter symbol instead of an inverter schematic the module would return the instance ID of the symbol instance INV inside TOP and the associated hierarchical path and transformation.

To support the visualization of both cell constraints and occurrence constraints the object generation module works in conjunction with the hierarchy traversal module. For cell constraints which are recognized as constraint member names that do not begin with a leading and are not fully qualified e.g. I0 I1 I2 the hierarchy traversal module searches for all possible occurrences of the constraint cell in a given hierarchy. For each such occurrence the hierarchy traversal module prefixes the occurrence path ahead of the constraint member name to make a fully qualified member name string to generate actual object identifiers.

For occurrence constraints recognized by constraint member names that begin with a leading and thus are fully qualified e.g. TOP I0 I1 I2 the hierarchy traversal module searches for design objects for which the constraint storage location matches the top of the design hierarchy. For both cell and occurrence constraints the hierarchy traversal modules generates occurrence path strings on the basis of the design that is currently visible in a given window. For example if the constraint member name is TOP MID I0 and the window is showing design TOP the search for I0 would start from the TOP cellview. However if the window is showing the occurrence of design TOP MID the search starts from MID. Object filtering on the basis of hierarchy display start and stop levels is also done by these two modules.

After the constraint design objects have been generated the object grouping module partitions the design objects depending upon their locations and decides how the design objects get connected to each other. The main task of this module is to generate the non intersecting interconnect halo segments. The object grouping module uses the segment generation module to generate optimum interconnect halo segments between constraint design objects. The object grouping process is recursive. The object grouping process takes a list of constraint objects as an input and is responsible for generating interconnect halo segments for that group of objects. The object grouping process is also responsible for calling the appropriate API to display halos around objects and interconnect halo segments. The object grouping module may also draw an up connector on the constraint design objects and may place the up connector in the top right position of the display window.

The Segment Generation Module generates optimum interconnect halo segment between any two given constraint design objects. In case of constraint objects that are instances of symbols the connecting segments do not begin and end at instance pins. Instance pins are avoided so that they will be free for devices interconnections with wires. In addition care is taken that the interconnect halo segment does not overlap with the instance pins of the two constraint objects if any. The Segment Generation Module automatically computes a set of optimum interconnect points for a given design object other than the pin locations.

The Label generation Module is responsible for showing the constraint name labels. The constraint name is displayed as a separate label in same style color as the object halo. The label appears on the up connector if it is present. If there is no up connector a different sophisticated approach is adopted while displaying constraint name label.

The Object Hilight Module which includes a set of wrapper API functions over the GE Hilight API is called to generate halos around the constrained design objects interconnect halo segments constraint labels etc.

Interactive editing of the design is handled by Constraint Visualization Triggers. The engine has its own database trigger which it registers with the design database to keep itself aware of edits being done to the design in order to generate a list of constraints that need to be invalidated after edits of the circuit design have been performed. The engine also has its own display trigger which it registers with the GE. The display trigger is responsible for invalidating the constraints in the invalidate constraint list generated by the database trigger. In addition the engine also registers an application trigger and a post install trigger with the design editor layer which is a layer that enables various sub tools that allow editing of different abstractions such as schematic and layouts. The design editor layer also allows various triggers to be specified during the abstraction registration which are responsible for various actions including the opening of design database and creation of window contexts that can be viewed and descended etc. . The application trigger is called in order to do destroy the existing visualizations before a window is closed and the post install trigger allows the registered constraints to be visualized in new window which get opened up.

Block determines a set of interconnect points for each constraint member. If the constraint member is a simple geometric shape such as a line rectangle polygon or the like the interconnect points are chosen based upon the type of shape. For example if the shape is a line the interconnect points are the line s two endpoints. If the shape is a rectangle the interconnect points are the rectangles four corners. If the shape is a polygon the interconnect points are the polygon s vertices. In the set of interconnect points for a wire represented by a line shape are encircled.

If the constraint member is an instance of a device symbol then a set of interconnect points for the instance are generated based upon the constituent geometric shapes that make up the device representation. The interconnect points are generated for the instance master so that the points can be cached and re used after applying a simple geometric transformation for all instances of the master without being recomputed for each instance. To determine the interconnect points of an instance a subset of the constituent geometric shapes that make up the device symbol but do not directly connect its pins is generated. The interconnect points of the constituent geometric shapes form the interconnect points for the symbol. In the set of interconnect points for the transistor are shown encircled such as a point . The points that were excluded are shown as squares . For a symbol such as a symbol for a pin if all shapes happen to be directly connected to pin shapes then the points from those are cumulated to get the interconnect points for the symbol. In the interconnect points of a pin symbol are encircled. To prevent discernible delays when displaying constraints the interconnect points of a given symbol are calculated once and cached. To determine the interconnect point for an instance the points are transformed according to the instance transform before use. An instance transform is a matrix that includes instance location orientation and magnification attributes.

If the constraint member is an instance of a schematic design then a set of interconnect points for the instance are generated by generating the interconnect points for the instance master i.e. for the master schematic. The interconnect points for the master schematic are the four corners of its bounding box. To prevent discernible delays when displaying constraints the interconnect points of a schematic are calculated once and cached. To get the interconnect point for an instance the points are transformed according to the instance transform before use.

The process then considers all segments that could be generated between the two design objects by choosing a point on each of the two design objects to be connected. Block generates all possible line segments that can be formed between an interconnection point on the first member and an interconnection point on the second member. Block determines if there are two points for which the corresponding line segment is a horizontal vertical line with shortest distance. If two such points exist block chooses those points. Otherwise if no such pair of points exists block determine if there are two points for which the connecting line is a shortest segment that does not pass over the pins of either design object. If two such points exist block chooses those points. Otherwise if no such pair of points exists block chooses a pair of points for which the connecting line is a shortest segment between the two design objects to be connected.

Block acquires an input list of design objects for which a halo is to be generated. The design object list may be acquired from a data structure that associates design objects with the constraint identifier. Block computes the bounding box of all objects in the design object list. The bounding box is a rectangular region that encloses the graphical representation of the objects in the design object list as displayed on the design canvas. In one aspect a bounding box is the smallest rectangle which entirely encloses the objects in the design object list as those objects are displayed on the design canvas. Block calls the splitAndJoinGroup subroutine which is illustrated in . Block passes the design object list the bounding box and a split position value of 1 to the splitAndJoinGroup subroutine. The value 1 indicates that this call to splitAndJoinGroup is the initial call.

The object grouping process splits a region of the circuit design into two halves and recursively processes each half. The process may split a region either horizontally or vertically into two regions separated by a bisector line. The process uses a split direction state variable to represent the direction horizontal or vertical of a split and the side of the bisector line left right or top bottom of the split. In one example the split direction indicates whether the split is horizontal e.g. 0 or 1 or vertical 2 or 3 . A split direction value of 0 indicates interconnection in the upper half and a value of 1 indicates interconnection in the lower half. Similarly a value 2 indicates interconnection in the left half and a value of 3 indicates interconnection in the right half.

When the object grouping process is initially invoked there is one set of objects to be processed. The initial set is not a result of a prior split. Therefore the split direction is set to a negative value 1 in the first invocation of the process. The object grouping process returns an optimum object from the input list of objects. The optimum object is decided based upon the split direction as explained below. The object grouping process invokes itself recursively supplying a list of objects as an input. The list of objects is generally smaller for each recursive invocation. The recursion terminates when the process is invoked with two or fewer objects in the input list.

The object grouping process represented as a subroutine named splitAndJoinGroup. The splitAndJoinGroup subroutine begins at block by acquiring an object list a bounding box and an initial split direction value. Block determines if the input list contains one object. If the input list contains more than one object block transfers control to block . If the input list contains a single object block highlights i.e. halos the object. That is a halo is drawn around under or over the object as shown for example in . Block then transfers control to block . Block determines if the call is an initial call. If so block returns NULL and processing is complete. Otherwise if the call is not an initial call block returns the object as a result i.e. output value.

Block determines if the input list contains two objects. If not then the input list contains more than two objects and Block transfers control to block . If the input list contains just two objects block highlights i.e. halos and interconnects the two objects by generating a segment using the segment generation process of . Block determines if the currently executing call of splitAndJoinGroup is an initial call. If the value of splitPos is 1 then the call is an initial call and block returns NULL to complete the currently executing call. Otherwise if the call is not an initial call execution continues at block .

Block returns the optimum object from the object list based on the splitPos which is set in the invocations of splitAndJoinGroup at blocks and as described below. At block if splitPos has the value top then block sets the optimum object to the geometrically bottom most object in the object list as the object would be seen on the design canvas. Similarly if split Pos has the value bottom then the optimum object is the top most object in the object list. If splitPos has the value left then the optimum object is the right most object in the object list. If splitPos has the value right then the optimum object is the left most object in the object list. Block returns the optimum object. That is if block is reached it returns the optimum object and the currently executing call ends.

Block sets a variable named L to the length and a variable named W to the width of the overall bounding box. Block determines if L W. If L W block bisects the bounding box vertically .and block sets the variables boxl and box to refer to sub bounding boxes on the top and bottom side of the bisector line respectively. Otherwise if L

Block generates a list named list of objects that are fully inside i.e. enclosed within boxl. Block generates a list list of objects that are fully inside box.

Block generates a list named splitList that contains objects that are intersected by the bisector line. Block stores the split direction which is either vertical or horizontal in a variable for later reference. The split direction is vertical if block bisected the bounding box vertically. The split direction is horizontal if block bisected the bounding box horizontally. Block determines if the split is vertical. If so block sets a variable pos to 2 left and a variable pos to 3 right . Otherwise if the split was horizontal block sets pos to 0 top and pos to 1 bottom .

Block invokes the splitAndJoinGroup subroutine recursively passing list boxl and pos as arguments to split and join design objects in the left half for a vertical split direction or top half for a horizontal split direction of the bounding box. Block sets a variable optObjA to the result returned by the splitAndJoinGroup invocation. The result returned by splitAndJoinGroup is either NULL or a single design object that can be highlighted. If the result is a design object block draws a halo around the design object.

Block invokes the splitAndJoinGroup subroutine recursively a second time passing list box and pos as arguments to split and join design objects in the right half vertical split or left half horizontal split of the bounding box. Block sets a variable optObjB to the result returned by the second splitAndJoinGroup invocation. If the result is a design object block draws a halo around the design object.

Block determines if the split list generated at block is empty. If the split list is empty and if block determines that optObjA and optObjB are not NULL block joins optObjA and optObjB with an interconnect halo segment and execution ends. If the splitList is not empty block sorts the objects in splitList so that they are ordered based upon their physical positions in the vertical or horizontal direction. Block iterates over the sorted objects list and joins the objects in the list with interconnect halo segments. Block calls the GE GL API to draw a halo around the segments and around the objects in the sorted split list.

Block determines whether optObjA is not null. If block determines that optObjA is not null block joins optObjA with the nearest neighbor object of optObjA in the split list. If block determines that optObjB is not null block joins optObjB with the nearest neighbor object of optObjB in the split list. Block returns the optimum object from the object list. Block uses the same process as bloc to determine the optimum object and execution ends.

In summary the constraint visualization features help designers to more quickly understand the constraint relationships in a circuit and to more efficiently debug problems related to the constraints. The visualization system concurrently improves both the front end and back end designer s understanding of the design and improves design for manufacture ability leading to higher yielding designs.

The above description is exemplary only and it will be apparent to those of ordinary skill in the art that numerous modifications and variations are possible. For example various exemplary methods and systems described herein may be used alone or in combination with various other computer and computer peripheral systems and methods. Additionally particular examples have been discussed and how these examples are thought to address certain disadvantages in related art. This discussion is not meant however to restrict the various examples to methods and or systems that actually address or solve the disadvantages.

