---

title: Method, apparatus, and system for implementing caching of view custom options in a framework to support web-based applications
abstract: In one implementation, a system caches view custom options in a framework to support web-based applications. A set of server-side objects is managed by an object manager (OM) running on a server. A set of browser-side objects runs on a browser running on a client. A remote procedure call (RPC) mechanism enables re-targeting of methods from browser-side objects to server-side objects. A notification mechanism facilitates transmission of notifications from server-side objects to browser-side objects. A cache on the client stores custom options of views.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07603677&OS=07603677&RS=07603677
owner: Siebel Systems Inc.
number: 07603677
owner_city: San Mateo
owner_country: US
publication_date: 20070410
---
This application is a continuation of U.S. patent application Ser. No. 09 969 966 which is now U.S. Pat. No. 7 203 948 entitled Method Apparatus and System for Implementing Caching of View Customer Options in a Framework to Support Web Based Applications filed on Sep. 29 2001 and naming Anil Mukundan John Coker William E. Coppens as inventors. This application is incorporated by reference herein in its entirety and for all purposes.

The present invention relates generally to the field of data processing. More specifically the present invention relates to a method apparatus and system for implementing caching of view custom options in a framework to support web based applications.

As technology continues to advance and the business environments have become increasingly complex and diverse more and more companies have relied on various customer relationship management CRM software and eBusiness applications to conduct and manage various aspects of their enterprise business. In general eBusiness applications are designed to enable a company or enterprise to conduct its business over an interactive network e.g. Internet Intranet Extranet etc. with its customers partners suppliers distributors employees etc. eBusiness applications may include core business processes supply chain back office operations and CRM functions. CRM generally includes various aspects of interaction a company has with its customers relating to sales and or services. At a high level customer relationship management is focused on understanding the customer s needs and leveraging this knowledge to increase sales and improve service. CRM application and software is generally designed to provide effective and efficient interactions between sales and service and unify a company s activities around the customer in order to increase customer share and customer retention through customer satisfaction.

Generally eBusiness applications are designed to allow organizations to create a single source of customer information that makes it easier to sell to market to and service customers across multiple channels including the Web call centers field resellers retail and dealer networks. Advanced eBusiness applications are typically built on a component based architecture and are designed to be Web based and to deliver support for various types of clients on multiple computing platforms including mobile clients connected clients thin clients and handheld clients etc.

With the recent proliferation of the Web it is desirable to provide the functionalities of the eBusiness applications in a Web based environment. Furthermore it is desirable for the eBusiness applications operating in a Web based environment to retain the look and feel of desktop based eBusiness applications with which the users are already familiar.

In the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be appreciated by one skilled in the art that the present invention may be understood and practiced without these specific details.

In one embodiment a system in which the teachings of the present invention are implemented can be logically structured as a multi layered architecture as shown in . In one embodiment the logical multi layered architecture as shown in provides a platform for common services to support the various applications. These services may include a user interface layer an object manager layer a data manager layer and a data exchange layer .

In one embodiment the user Interface layer may provide the applets views charts and reports etc. associated with one or more applications. In one embodiment various types of clients can be supported via the user interface layer . These various types of clients may include traditional connected clients remote clients thin clients over an intranet Java thin clients. or non Windows based operating systems and HTML clients over the Internet etc.

In one embodiment the object manager layer is designed to manage one or more sets of business rules or business concepts associated with one or more applications and to provide the interface between the user interface layer and the data manager layer . In one embodiment the business rules or concepts can be represented as business objects. In one embodiment the business objects may be designed as configurable software representations of the various business rules or concepts such as accounts contacts opportunities service requests solutions etc.

In one embodiment the data manager layer is designed to maintain logical views of the underlying data and to allow the object manager to function independently of underlying data structures or tables in which data are stored. In one embodiment the data manager may also provide certain database query functions such as generation of structure query language SQL in real time to access the data. In one embodiment the data manager is designed to operate on object definitions in a repository file that define the database schema. In one embodiment the data storage services provide the data storage for the data model associated with one or more applications.

In one embodiment the data exchange layer is designed to handle the interactions with one or more specific target databases and provide the interface between the data manager layer and the underlying data sources.

In one embodiment the multi layered architecture allows one or more software layers to reside on different machines. For example in one embodiment the user interface the object manager and the data manager can all reside on the dedicated web clients. For other types of clients such as the wireless clients in one embodiment the object manager and data manager can reside on a system server. It should be appreciated and understood by one skilled in the art that the system configuration shown in is for illustrative and explanative purposes and may vary depending upon the particular implementations and applications of the teachings of the present invention.

In one embodiment the system environment illustrated in may include more than one database . One or more subsets of the database can be created or replicated by a replication manager. In addition mobile web clients can have additional remote databases also called local databases . In one embodiment unless the remote or local databases associated with the mobile web clients are defined as read only databases these mobile web clients can create and update data locally that will be ultimately propagated up to the primary database when each mobile web client synchronizes with the system server.

In one embodiment the database is designed to store various types of data including predefined data schema e.g. table objects index objects etc. repository objects e.g. business objects and components view definitions and visibility rules etc. and user s or customer s data. In one embodiment dedicated web clients and server components including those that operate in conjunction with the other types of clients can connect directly to the database and make changes in real time. In one embodiment mobile web clients can download a subset of the server s data to use locally and periodically synchronize with the server database through the system server to update both the local and the server database.

In one embodiment various tables included in the database may be logically organized into the following types data tables interface tables and repository tables etc.

In one embodiment data tables may be used to store user business data administrative data seed data and transaction data etc. In one embodiment these data tables may be populated and updated through the various applications and processes. In one embodiment data tables may include the base tables and the intersection tables etc. In one embodiment base tables may contain columns that are defined and used by the various applications. In one embodiment the base tables are designed to provide the columns for a business component specified in the table property of that business component. In one embodiment intersection tables are tables that are used to implement a many to many relationship between two business components. They may also hold intersection data columns which store information pertaining to each association. In one embodiment intersection tables provide the data structures for association applets.

In one embodiment interface tables are used to denormalize a group of base tables into a single table that external programs can interface to. In one embodiment they may be used as a staging area for exporting and importing of data.

In one embodiment repository tables contain the object definitions that specify one or more applications regarding 

In one embodiment the file system is a network accessible directory that can be located on an application server. In one embodiment the file system stores the physical files created by various applications such as files created by third party text editors and other data that is not stored in the database . In one embodiment physical files stored in the file system can be compressed and stored under various naming conventions. In one embodiment dedicated web clients can read and write files directly to and from the file system . In one embodiment mobile web clients can have a local file system which they synchronize with the server based file system periodically. In one embodiment other types of client such as the wireless clients and the web clients can access the file system via the system server.

In one embodiment the enterprise server is a logical grouping of the system servers that share a common table owner or a database point to a common gateway Server and can be administered as a group using server manager . In one embodiment the connection to the gateway server can be established via TCP IP. In one embodiment the enterprise server can be scaled effectively by deploying multiple system servers in the enterprise server thus providing a high degree of scalability in the middle tier of applications.

In one embodiment the server runs one or multiple server programs. It handles the incoming processing requests and monitors the state of all processes on the server. In one embodiment server programs are designed and configured to perform one or more specific functions or jobs including importing and exporting data configuring the database executing workflow and process automation processing to support mobile web clients for data synchronization and replication and enforcing business rules etc. In one embodiment the server can be an NT Service under Windows NT operating system or a daemon e.g. a background shell process under UNIX operating system. In one embodiment the server supports both multi process and multi threaded components and can operate components in batch service and interactive modes.

In one embodiment the server manager is configured as a utility that allows common control administration and monitoring across disparate programs for the servers and the enterprise server . In one embodiment the server manager can be used to perform the following tasks start stop pause and resume servers components and tasks monitor status and collect statistics for multiple tasks components and servers within an enterprise server and configure the enterprise server individual servers individual components and tasks etc.

In one embodiment the gateway server can be configured as a logical entity that serves as a single entry point for accessing servers. In one embodiment it can be used to provide enhanced scalability load balancing and high availability across the enterprise server. In one embodiment the gateway server may include a name server and a connection brokering component. In one embodiment the name server is configured to keep track of the parameters associated with the servers. For example the availability and connectivity information associated with the servers can be stored in the name server. The various components in the system can query the name server for various information regarding the servers availability and connectivity. In a Windows NT environment the name server can be run as a NT service. In a UNIX environment the name server can run as a daemon process. In one embodiment the connection brokering component is used to perform load balancing function such as directing client connection requests to an appropriate server e.g. the least busy server .

In one embodiment as illustrated in the various types of clients that can be supported by the system may include the following clients dedicated web clients mobile web clients web clients wireless clients and handheld clients etc.

In one embodiment dedicated web clients also called connected clients are connected directly to a database server for data access via a LAN or WAN connection. In one embodiment these connected or dedicated web clients do not store data locally. These dedicated web clients can also access the file system directly. In one embodiment the user interface the object manager and the data manager layers of the multi layered architecture reside on the dedicated web client.

In one embodiment the mobile web clients are designed and configured for local data access and thus can have their own local database and or local file system. In one embodiment mobile web clients can interact with other components within the system via the gateway server. Through synchronization the modifications from the local database and the server database can be exchanged. Mobile web clients are described in more detail below.

In one embodiment a web client runs in a standard browser format from the client s machine. In one embodiment the web client can connect to a system server through a web server. In one embodiment the system server is designed and configured to execute business logic and access data from the database and file system . In one embodiment the web client described herein is designed and configured in accordance with the teachings of the present invention to operate in an interactive mode. In one embodiment the interactive web client framework as described herein utilizes dynamically created objects implemented in JavaScript on the browser side that correspond to objects on the server side. In one embodiment these dynamically created objects on the browser side may include the current view and its corresponding applets the current business object and the corresponding business components etc. The web client is described in more details below.

In one embodiment wireless clients are essentially thin clients enabled on wireless devices. The wireless clients can use a wireless application protocol WAP based user interface to communicate and exchange information data with the system server. The system configuration illustrated in is described in more details below with references to various structures databases tables file systems etc. as illustrating examples.

In one embodiment the presentation services may be designed and configured to support various types of clients and may provide them with user interface applets views charts and reports etc. As described above a large variety of clients may be supported including wireless clients handheld clients web clients mobile web clients and dedicated connected clients etc.

In one embodiment the application services may include business logic services and database interaction services. In one embodiment business logic services provide the class and behaviors of business objects and business components. In one embodiment database interaction services may be designed and configured to take the user interface UI request for data from a business component and generate the database commands e.g. SQL queries etc. necessary to satisfy the request. For example the data interaction services may be used to translate a call for data into DBMS specific SQL statements.

In one embodiment data storage services may be designed and configured to provide the data storage for the underlying data model which serves as the basis of the various applications. For example the data model may be designed and configured to support various software products and applications including call center sales services and marketing etc. as well as various industry vertical products and applications such as eFinance eInsurance eCommunications and eHealthcare etc.

In one embodiment the core services are are designed and configured to provide the framework in which the applications execute. In one embodiment the core services may include the following 

In one embodiment application integration services may be designed and configured to allow the various applications built in accordance with this framework to communicate with the external world. In one embodiment the various types of services in this logical grouping may be designed and configured to provide for real time near real time and batch integration with external applications. For example these integration services may be used to enable communications between external applications and the internal applications using available methods technologies and software products. In one embodiment application integration services allow the systems or applications to share and replicate data with other external enterprise applications. Accordingly these services allow a particular application or system to be both a client requesting information and a server having information requested from it.

In one embodiment business processes services are designed and configured to allow the client to automate business processes through the application. In one embodiment these various business process services may include the following 

In one embodiment creation of these business processes can be done through Run Time tools such as Personalization Designer Workflow Designer SmartScript Designer Assignment Administration Views and the Model Builder etc.

In one embodiment integration services may be designed and configured to provide the client with user interface and thin client support. In one embodiment these may include capabilities for building and maintaining web based applications providing web support facilities such as user Profile Management Collaboration Services and Email and Fax services as well as advanced Smart Scripting etc.

In one embodiment design time tools may be designed and configured to provide the services to customize design provide integration points and maintain the application. These various tools provide one common place to define the application.

In one embodiment admin services are designed and configured provide one place to monitor and administer the application environment. In one embodiment these services allow the user to administer the application either through a graphic user interface GUI or from a command line etc.

The framework or infrastructure can support the interactive web client shown in and the mobile web client also shown in and is capable of meeting certain criteria such as increasing the interactivity and performance of the web client and the mobile web client and reducing the number of page refreshes for common actions.

The framework or infrastructure can include objects that can be dynamically created on the browser to mimic corresponding objects managed by the object manager. In one embodiment the objects managed by the object manager OM can be built using a programming language such as C supporting the object oriented paradigm.

As shown in exemplary objects managed by the OM can include an object representing a view CSSWEView . A view is generally a display panel consisting of a particular arrangement of applets. In one embodiment one active view can be displayed at any given time. Another exemplary object managed by the OM can be an object representing an applet CSSWEApplet . An applet is generally a visual application unit that appears on the screen as part of a view. Other exemplary objects managed by the OM can include an object representing a business component CSSBusComp an object representing a business object CSSBusObj and an object representing a frame CSSWEFrame . In one embodiment the business object may be designed as configurable software representations of the various business rules or concepts such as accounts contacts opportunities service requests solutions etc. In this embodiment the business components typically provide a layer of wrapping over tables and the applets reference business components rather than the underlying tables. In addition a frame is generally a sub component of a view and may comprise of one or more applets.

In one embodiment objects on the browser can be built using JavaScript. As shown in exemplary objects on the browser side may include JSSBusObj JSSBusComp JSSView and JSSApplet to respectively mirror CSSBusObj CSSBusComp CSSWEView and CSSWEApplet which are objects managed by the OM.

Objects on the browser and objects managed by the OM can be configured to reside and operate on one computing device or multiple computing devices. illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on multiple computing devices including a client and a server . illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on one computing device .

Returning to objects on the browser are generally synchronized with corresponding or mirrored objects managed by the OM. Synchronization can be accomplished through a remote procedure call RPC mechanism and a notification mechanism . The RPC mechanism and the notification mechanism will be described below in more details.

Of the objects on the browser the JSSApplication object typically exists throughout a user session. The JSSApplication object should be initially loaded when the user starts an application. An application would generally be started when the user invokes a subset of the application from an icon on the desktop or from the Start menu. The JSSApplication object generally performs a role similar to that of the CSSModel object . The CSSModel object is generally a global session object that provides access to repository objects that are in use the current business object instance in memory the relationships between the current business object and the business components contained in it and the user s global state information. The CSSModel object generally accesses a repository to obtain needed information. The repository is generally a set of object definitions used to define an application or a suite of applications. However the JSSApplication object is generally scaled down to track one view applets associated to the tracked view one business object and the business components that are in use in the view.

Unlike the JSSApplication object the JSSView object the JSSApplet object the JSSBusObj object and the JSSBusComp object are typically temporary or impermanent entities and are generally replaced when a page refresh occurs. For example a request to navigate to a new view may cause a new set of JSSView JSSApplet JSSBusObj and JSSBusComp objects to be created to run on the browser.

Accordingly objects on the browser can be generally described as lightweight representations of mirrored or corresponding objects managed by the OM. Each object on the browser would typically include a subset of the functionalities included in corresponding objects managed by the OM. For example the JSSView object similar to a CSSView object generally represents a collection of applets. The JSSBusObj object similar to a CSSBusObj object generally manages the various one to many relationships between active business components so that correct relationships are employed when these active business components are populated via queries. The JSSBusObj object generally exists on the browser for the life of the current view and should be kept in sync with the corresponding CSSBusObj object .

In one embodiment when the browser submits a request to navigate to a new view to the web engine the web engine would send a response containing the view layout that is devoid of data. Then the web engine would send a response containing a string of data to populate the view.

The JSSApplication object generally manages communications flowing into and out from objects on the browser. In one embodiment a method invoked on an object on the browser would typically be directed to the JSSApplication object if the invoked method should be retargeted to an object managed by the OM. The JSSApplication object would generally use the RPC mechanism to route the invoked method through the web engine to the appropriate object managed by the OM. The web engine would typically be employed to send return notifications and data from objects managed by the OM to objects on the browser. The web engine would generally use the notification mechanism to route notifications and data through the JSSApplication object to objects on the browser.

The browser objects generally use the remote procedure calls to invoke methods on the objects managed by the OM. These remote procedure calls are generally packaged as HTTP requests. Responses from the objects managed by the OM are packaged as HTTP responses containing notifications and associated status information and data. In one embodiment remote procedure calls are made with blocking enabled to ensure synchronization between the objects on the browser and the objects managed by the OM. With blocking enabled control would typically not be passed back to the calling code until the called remote procedure finishes executing.

The RPC model generally uses the same procedural abstraction as a conventional program but allows a procedure call to span the boundary between two computers. illustrates an example of how the RPC paradigm can be used to divide a program into pieces that can be executed on separate computing devices . This figure generally shows a distributed program having multiple procedures. Main proc  proc  proc  proc  proc  and proc  reside and operate in the first computing device or the client and proc  and proc  reside and operate in the second computing device or the server . A solid line from procedure n to procedure m denotes a call from n to m. A dashed line shows how control passes from one computing device to another computing device during a remote procedure call.

As such a remote procedure call generally executes a procedure located in a separate address space from the calling code. The RPC model is generally derived from the programming model of local procedure calls and takes advantage of the fact that every procedure contains a procedure declaration. The procedure declaration defines the interface between the calling code and the called procedure. The procedure declaration defines the call syntax and parameters of the procedure. Calls to a procedure should typically conform to the procedure declaration.

Applications that use remote procedure calls look and behave much like local applications. However an RPC application is divided into two parts a server which offers one or more sets of remote procedures and a client which makes remote procedure calls to RPC servers. A server and its client s generally reside on separate systems and communicate over a network. RPC applications depend on the RPC runtime library to control network communications for them. The RPC runtime library generally supports additional tasks such as finding servers for clients and managing servers.

A distributed application generally uses dispersed computing resources such as central processing units CPU databases devices and services. The following applications are illustrative examples of distributed applications 

Distributed applications include tasks such as managing communications finding servers providing security and so forth. A standalone distributed application needs to perform all of these tasks itself. Without a convenient mechanism for these distributed computing tasks writing distributed applications is difficult expensive and error prone.

RPC software typically provides the code called RPC stubs and the RPC runtime library that performs distributed computing tasks for applications. The RPC stubs and the RPC runtime library should be linked with client and server application code to form an RPC application.

Table 1 generally shows the basic tasks for the client and server of a distributed application. Calling the procedure and executing the remote procedure shown in italicized text are performed by the application code Oust as in a local application but here they are in the client and server address spaces. As for the other tasks some are performed automatically by the stubs and RPC runtime library while others are performed by the RPC runtime library via API calls in the application code.

The RPC client or the RPC server typically contains RPC application code segments and RPC interfaces and stubs and and the RPC runtime libraries and . The RPC application code segments are generally the code written for a specific RPC application by the application developer. The RPC application code segments generally implement and call remote procedures and also calls needed routines or procedures in the RPC runtime library. An RPC stub is generally an interface specific code module that uses an RPC interface to pass and receive arguments. A client and a server typically contain complementary RPC stubs for each shared RPC interface . The RPC runtime library generally manages communications for RPC applications. In addition the RPC runtime library should support an Application Programming Interface API used by RPC application code to enable RPC applications to set up their communications manipulate information about servers and perform optional tasks such as remotely managing servers and accessing security information.

RPC application code segments usually differ for clients and servers. RPC application code on the server typically contains the remote procedures that implement one RPC interface. RPC application code on the corresponding client typically contains calls to those remote procedures.

RPC stubs generally perform basic support functions for remote procedure calls. For instance RPC stubs prepare input and output arguments for transmission between systems with different forms of data representation. RPC stubs use the RPC runtime library to handle the transmission between the client and server . RPC stubs on the client can also use the local RPC runtime library to find appropriate servers for the client .

Marshalling generally converts input or call arguments into a byte stream format and packages them for transmission. Upon receiving call arguments a server RPC stub unmarshalls them. Unmarshalling is generally the process by which a stub disassembles incoming network data and converts it into application data using a format that the local system understands. Marshalling and unmarshalling both occur twice for each remote procedure call. The client RPC stub marshalls input arguments and unmarshalls output arguments . The server RPC stub unmarshalls input arguments and marshalls output arguments . Marshalling and unmarshalling permit client and server systems to use different data representations for equivalent data. For example the client system can use ASCII data and the server system can use Unicode data as shown in .

The IDL compiler a tool for application development generates stubs by compiling an RPC interface definition written by application developers. The compiler generates marshalling and unmarshalling routines for platform independent IDL data types. To build the client for an RPC application a developer links client application code with the client stubs of all the RPC interfaces the application uses. To build the server the developer links the server application code with the corresponding server stubs.

In addition to one or more RPC stubs each RPC server and RPC client should be linked with a copy of the RPC runtime library. The RPC runtime library generally provides runtime operations such as controlling communications between clients and servers and finding servers for clients on request. RPC stubs in the client and the server typically exchange arguments through the RPC runtime library that is respectively local to the client and the server. The RPC runtime library on the client typically transmits remote procedure calls to the server. The RPC runtime library on the server generally receives the remote procedure calls from the client and dispatches each call to the appropriate RPC stub on the server. The RPC runtime library then sends the results of each call to the RPC runtime library on the client.

RPC application code on the server must also contain server initialization code that calls routines in the RPC runtime library on the server when the server is starting up and shutting down. RPC application code on the client can also call RPC runtime library routines for initialization purposes. Furthermore RPC application code on the server and RPC application code on the client can also contain calls to RPC stub support routines. RPC stub support routines generally allow applications to manage programming tasks such as allocating and freeing memory.

In one embodiment remote procedure calls are made with blocking enabled to ensure synchronization between the objects on the browser and the objects managed by the OM shown in . With blocking enabled control would typically not be passed back to the calling code until the called remote procedure finishes executing.

Traditionally calling code and called procedures share the same address space. In an RPC application the calling code and the called remote procedures are not linked rather they communicate indirectly through an RPC interface. An RPC interface is generally a logical grouping of operations data types and constants that serves as a contract for a set of remote procedures. RPC interfaces are typically compiled from formal interface definitions written by application developers using the Interface Definition Language IDL .

In developing a distributed application an interface definition should be defined in IDL. The IDL compiler generally uses the interface definition to generate a header file a client stub file and a server stub file. The IDL compiler can produce header files in a standard programming language and stubs as source files or as object file. For some applications an Attribute Configuration File ACF accompanying the interface definition may be defined. If an ACF exists the IDL compiler interprets the ACF when it compiles the interface definition. Information in the ACF is used to modify the code that the compiler generates.

The header of each RPC interface typically contains a Universal Unique Identifier UUID which is a hexadecimal number that uniquely identifies an entity. A UUID that identifies an RPC interface is generally known as an interface UUID. The interface UUID ensures that the interface can be uniquely identified across all possible network configurations. In addition to an interface UUID each RPC interface contains major and minor version numbers. Together the interface UUID and version numbers form an interface identifier that identifies an instance of an RPC interface across systems and through time.

Returning to objects on the browser are generally synchronized with corresponding or mirrored objects managed by the OM so that changes can be reflected. Synchronization can be accomplished through a remote procedure call RPC mechanism and a notification mechanism .

The notification mechanism generally provides the means by which data in an object on the browser e.g. JSSBusComp can be updated when data or status is changed in a corresponding object managed by the OM e.g. CSSBusComp . In one embodiment the CSSSWEView object would collect one or more notifications and send them to the objects on the browser at the end of a view show cycle.

In one embodiment the following exemplary or illustrative notifications can be transmitted. It should be noted that some of the notifications listed below require parameters. In other cases the framework can understand the context for these notifications by simply knowing its current state.

As stated above objects on the browser and objects managed by the OM can be configured to reside and operate on one or multiple computing devices. As shown above illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on multiple computing devices and including a client and a server . illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on one computing device .

When a browser side applet JSSApplet calls the server through the RPC the browser side applet typically looks at the status flag in the response and then handles it block . If the returned status is Error the browser side applet would show an error page. If the returned status is Completed the server is generally indicating that it had already handled the invoke method and that there s nothing left for the browser to do. If the returned status is Continue the server is generally indicating that it is not handling the invoke method. The browser side applet would generally respond to a returned status of Continue by redirecting the method to a JSSBusComp object by invoking the method directly on a JSSBusComp object. The JSSBusComp object may be able to satisfy the invoke method request or may have to send its own RPC call through the JSSApplication to its corresponding server side business component.

In block the client side business component JSSBusComp examines the returned status flag and responds appropriately. It should be noted that the server will be contacted if an invoke method call performs actions that would require synchronization between the browser and server business components. It should be further noted that there could be circumstances where the JSSBusComp object may be able to handle the request locally without needing to contact the server. An example of such circumstances is when the user performs a next record operation and then a previous record operation without changing any data.

In one embodiment the methods which can be potentially supported by the browser side objects can be divided into the following categories base object methods application methods business component methods service methods and applet methods. For illustrative purposes exemplary methods in each category will be listed and general described below.

In one embodiment each browser side application object can typically support the following application methods 

In one embodiment each browser side business component object can typically support the following business component methods 

In one embodiment each browser side service object can typically support the following service methods 

In one embodiment various user interface items or controls such as toolbars menus keyboard controls also called keyboard shortcuts or keyboard accelerators herein etc. are used to provide the means for the user to initiate various actions or commands. In one embodiment toolbars may be designed and configured to appear in their own frame near the top of the application in the browser window and the application menus e.g. File View and Help etc. may be designed and configured to appear beneath the primary tab e.g. 1st level navigation bar. In one embodiment the applet level menus can be invoked from the applet menu button in the control banner at the top of an applet. and illustrate examples of toolbars application level menus and applet level menus respectively. In one embodiment each user interface item or object in a toolbar application level menu applet level menu or a particular keyboard shortcut or keyboard accelerator e.g. CRTL N can be configure to be associated or mapped to a particular command to be executed in response to the user s selection or activation of the respective user interface item e.g. clicking on a menu item pressing a keyboard combination such as CTRL N etc. . In one embodiment each command can be defined and configured to invoke one or more particular methods to perform one or more particular functions or actions requested by the user. In one embodiment a data structure referred to herein as a command object can be defined and configured to represent a particular command the execution of which may result in the invocation of one or more particular methods associated with the respective command object. Command objects are described in more details below.

In one embodiment a selection or activation of a toolbar icon or menu item e.g. user s clicking on a toolbar icon or menu item etc. is normally translated into a call to an invoke method which may reside in a service on the browser or server or in classes in the browser application or server infrastructure e.g. applet or business component classes SWE frame manager or model etc. . In one embodiment a user interface item such as a toolbar icon a menu item or a keyboard shortcut may be configured to target a method name a method handler from which it may be automatically re targeted if not found and optionally a service.

In one embodiment application level items which may include both toolbar icons application level menus and keyboard shortcuts etc. can be implemented through the use of command object definitions in Tools which are then mapped to Toolbar Item or Menu Item object definitions. In one embodiment applet level menus do not utilize command object definitions but the set of properties used for targeting and invoking the corresponding method are similar to those found in the command object type.

In one embodiment in the web engine templates the toolbar tag can be used to specify a named toolbar where the name corresponds to the Name property in the Toolbar object definition in the repository and the toolbaritem tag between the toolbar start and end tags recursively retrieves all of the toolbar items for that toolbar from the repository.

In one embodiment a design time menu activation suppression feature is provided for applet level menus. This feature provides the capability to make a menu item available globally for applets of a given class and its subclasses and then suppress it in particular applets where it is not desired. In one embodiment the design time menu activation suppression feature can be implemented using the Class Method Menu Item object type which can be used to implement the menu item in the applet level menu of all applets of the specified applet class except where suppressed as defined by the Suppress Menu Item property. Applet method menu item class method menu item and the suppression of menu item are described in greater details below.

In one embodiment a command object definition is created and configured to specify which invoke method is called when a toolbar icon or application level menu item associated with the command is executed. Furthermore a command object definition may be used to specify which bitmap appears on the toolbar icon for toolbar items. In one embodiment command object definitions are referenced by Toolbar Item or Menu Item object definitions. As illustrated in a Command object definition generally has the following properties 

In one embodiment for each toolbar in the application a Toolbar object definition can be created in the Object List Editor. This provides a named toolbar that the user can activate or deactivate in various applications and to which toolbar icons e.g. Toolbar Item object definitions can be associated or removed. Toolbar functionality for applications can be implemented using HTML toolbars. In one embodiment in an HTML toolbar the buttons are static images which may be dimmed to indicate unavailability but otherwise are not manipulated by program logic on the browser. In contrast CTI computer telephony integration applications may require toolbar icons that can be altered in response to events such as blinking a particular toolbar icon when a call is incoming. In one embodiment this may require the use of Java toolbars. In one embodiment to specify that a toolbar is of the Java type a class name is entered in the Class property. As shown in a toolbar object may include the following properties 

In one embodiment a Toolbar Item object is defined and configured to associate a Command object definition which is identified by name as a property in the Command property of the toolbar item object with a Toolbar object definition which is the parent of the Toolbar Item object . In one embodiment this association places a toolbar icon whose bitmap image invoke method and target are specified in the Command object definition on the specified toolbar in a given location e.g. a position relative to the other toolbar icons on that toolbar . In one embodiment as illustrated in a toolbar item object may be defined to include the following properties 

In one embodiment a menu object can be defined and configured for each application level menu. In one embodiment a menu object is considered a parent of corresponding menu item objects. A menu item object is used to define an application main menu or menu item within the parent menu object definition.

In one embodiment an applet method menu item object is used to define a menu item in the applet level menu for the parent Applet object definition. In one embodiment unlike application level menus applet menus are not based on Command objects. However the set of properties used for targeting the method are similar to those found in the command object type. shows a flow diagram of one embodiment of a process for creating an applet method menu item object in accordance with the teachings of the present invention. Creating an applet method menu item object can generally include defining an applet method menu item object at block and specifying the properties for the defined applet method menu item object at block .

In one embodiment of the present invention menu items e.g. both application level and applet level and toolbar items can be enabled or disabled at runtime by using the CanInvokeMethod mechanism. In one embodiment CanInvokeMethod for the method specified in the Command Applet Method Menu Item or Class Method Menu Item object etc. will be called automatically for each item prior to displaying the menu or toolbar. If CanInvokeMethod returns FALSE the toolbar item or menu item disabled e.g. is not displayed . The CanlnvokeMethod logic generally is retargeted from the browser application to the applet class hierarchy on the server and from there to the business component class hierarchy. The targeting sequence is described in more details below.

As described herein in one embodiment suppression and activation of individual applet level menu items at design time is supported by using the Suppress Menu Item property in the Class Method Menu Item and Applet Method Menu Item object types. In one embodiment this mechanism or feature is applicable to applet level menus not application level menus or toolbars in which the item is added or removed explicitly. Design time menu activation suppression for applet level menus provides the mechanism to make a menu item available globally for applets of a given class and its subclasses and then suppress it in particular applets where it is not desired. For example various applet level menu items appear in virtually all applets such as Copy Edit and Delete etc. others appear in virtually all list applets such as Columns Displayed and so on but there can be some cases in which a standard menu item for the applet s class needs to be suppressed for a specific applet.

In one embodiment to add applet class level menu items a Class Method Menu Item is added for a standard menu item for a given applet class. In one embodiment this menu item would not need to be re included as Applet Method Menu Item object definitions in applets in which the menu item is to appear. In one embodiment Applet Method Menu Item object definitions are created in two circumstances to add a menu item not already provided by the applet s class to the applet or to suppress display of an applet class level item that the applet would normally inherit. In the latter case an Applet Method Menu Item object definition is created with the same name as the applet class level menu item which is to be suppressed and a value of FALSE is entered for the Suppress Menu Item property.

According to one embodiment of the present invention as described herein the Method Business Service and Target properties are included in the Command object type for use in toolbars and application level menus and in the Class Method Menu Item and Applet Method Menu Item object types for use in applet level menus . In one embodiment two settings or options are available for the Target property with the following behavior 

If a service is specified in the Service property the method handler is the specified service. This targeting is also dependent on whether the calling menu item or toolbar icon is applet level or application level as follows 

The following matrix or table illustrates the results of the possible settings of the Target and Business Service properties at the applet and application levels in accordance with one embodiment of the present invention 

Typically the value of a particular field may depend upon the value of another field. The dependency or inter dependency between field values may exist in various ways. For example assuming that a user wishes to enter an address which typically includes various fields the value that the user enters for a particular field e.g. State field may determine the set of valid values that the user can enter in another field e.g. City field . As another example a particular field may become disabled or read only when the value in another field changes. Furthermore there may be cases where the type of user interface control or format used to show a particular field may change based on the value entered in another field. For example the user interface control for a particular field may be configured to change from a text box in which a user can enter any value into a combo box where the user has to choose from a list of existing values.

Conventionally in a client server environment the client waits for the user to finish entering a set of changes post the changes to the server for processing and then shows the user another page with the dependent information between field values. For example in a convention application or system the client waits for the user to finish entering all the address information such as STATE CITY etc. and then posts all the changes to the server. The server will then send a new page to the client for display to the user which may include the relevant dependent information between fields. This conventional method or conventional way of handling and processing dependency or inter dependency between field values is not effective because changes due to the inter dependency between field values are not seen by the user immediately thus making the user interface environment much less interactive. For example after the user has changed the value of a particular field upon which the value and or layout of another field depends the user will not recognize or see the effect of the change until after all the changes have been posted to the server and a new page is displayed.

To solve the problem described above according to one aspect of the present invention a method is provided in which a change in value of a field upon which the values format or functionality of other fields depend will be immediately posted to the server for processing also referred to as the immediate post when change feature or immediate post when change mechanism herein .

According to one embodiment of the present invention the fields upon which the other field s depend are marked for immediate post when change in the repository. This information is therefore available as part of the meta data. In one embodiment the client side framework uses this information to decide when to send changes to field values to the server for processing. The server will then respond using the notification mechanism described above to send back dependent changes as a result of the changes processed by the server. For example upon detecting that the value of a particular field has changed this particular field is marked for immediate post when change the client will immediately submit the value of this particular field and the values of other client side fields that have changed to the server for processing. The server will then respond using the notification mechanism to send back the dependent changes for the client to take appropriate actions based on the dependent changes. For example if the change of value of a first field causes the value and or format of a second field to be changed upon receiving the notifications from the server the client will change the value and or the format of the second field accordingly. In one embodiment the logic to perform the immediate post when change process is implemented as part of the Javascript code running on the client side.

One of the problems experienced in a traditional HTML or web based application is that once a client e.g. the browser sends a request to a server for processing it will time out if the server does not respond within a certain period of time. This time out condition occurs in spite of the fact that certain requests may take a long time to process depending upon various factors such as the type of the request the available resources on the server and the number of requests being processed or waiting to be processed by the server etc. For example a client in a traditional web based or HTML application may submit a request that involves a very time consuming query operation in a large database. This request may not be finished before the time out condition occurs.

According to one embodiment of the present invention a mechanism is provided so that when a client submits a request to a server that involves long running or time consuming operations on the server side the server can inform the client accordingly using the notifications mechanism described above. Based upon the information provided by the server regarding the request the client can take appropriate actions to inform a user of the status of the request e.g. by displaying a progress bar showing how much of the task has been completed thus far etc. . In one embodiment the communications regarding the status and progress of the request can be managed as described in more details below.

In one embodiment upon determining that the request received from the client may take a long time to process e.g. the request involves long running server operations etc. the server will notify the client accordingly. In one embodiment once the client is informed by the server that the request may take a long time to process the client can inform the user that the request processing has started and lock the user interface during the time the request is being processed by the server. In one embodiment the server will continue to inform the client of the progress of the request and the client can take appropriate actions to inform the user accordingly until the request processing is finished. For example upon receiving the progress information from the server via the notifications the client can update a progress bar to show the user how much of the task has been completed at that point in time. In one embodiment the user interface will continue to be locked until the request processing is completed.

As stated above objects on the browser and objects managed by the OM can be configured to reside and operate on one or multiple computing devices. As shown above illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on multiple computing devices and including a client and a server . illustrates an exemplary configuration in which objects on the browser and objects managed by the OM reside and operate on one computing device .

A view or JSSView object and a plurality of applets or JSSApplet objects . . . where N is a positive integer are shown to be running on the browser . The JSSView object generally represents a view. As stated above a view is generally a display panel consisting of a particular arrangement of applets. As previously discussed an applet is generally a visual application unit that appears on the screen as part of a view. Each applet or JSSApplet object . . . represents an applet that is associated to the view represented by the view or JSSView object.

The client includes a cache to generally store views to improve performance. At times the user can navigate or switch to new views causing the client to submit corresponding requests to navigate to new views to the server . As previously discussed when the client submits a request to navigate to a view to the server the server would send a response or notification containing the view layout that is devoid of data. Accordingly a round trip to the server including a request from the client to the server and a response or notification from the server to the client would typically be needed to retrieve the view layout and the view custom options from the server . The view layout and the view custom options will be generally shown in and generally described below in the text that accompanies . It should be noted that each round trip would take up valuable computing resources and would cause time delays. After sending the view layout and the view custom options to the client the server would then send a response containing data to populate the view.

To improve performance one or more view layouts and view custom options can be stored in the cache. Once its layout and customer options are stored in the cache the view can generally be referred to as a cached view. If the user navigates to a cached view the client can retrieve the view layout and view custom options from the cache instead of the server. By retrieving the view layout and the view custom options from the cache a round trip to the server can be eliminated thereby improve system performance.

In one embodiment each cache entry . . . can also be designed to customized options associated with the view. In one embodiment the view customized options can include keyboard accelerators and preferences . A keyboard accelerator is generally a sequence of keys or keystrokes that is mapped to a command object. An exemplary command object is shown and generally described above. Preferences are generally either default or user selected display options. Exemplary preferences can include font font size font colors width of columns and rows etc.

If the view is currently saved in the cache the client retrieves the view layout and the view custom options from the cache block . It should be noted that the client would save a round trip to the server by retrieving the view layout and the view custom options from the cache thereby improving system performance. After retrieving the view layout and the view custom options the client displays the view using the view layout block and applies the view custom options to the view . After displaying the view the client retrieves data for the view from the server block . After receiving the data from the server the client populates fields in the view with the retrieved data block .

It should be noted that functional components as shown above in the figures and described in the text accompanying the figures could be implemented using software code segments. If the aforementioned functional components are implemented using software code segments these code segments can be stored on a machine readable medium such as floppy disk hard drive CD ROM DVD tape memory or any storage device that is accessible by a computing machine.

The invention has been described in conjunction with the preferred embodiment. It is evident that numerous alternatives modifications variations and uses will be apparent to those skilled in the art in light of the foregoing description.

