---

title: Exposing storage resources with differing capabilities
abstract: Tracking storage resources includes providing a table containing storage resources along with capabilities and statuses thereof, updating the table in response to a change of status of a storage resource, updating the table in response to a change in capabilities of a storage resource and, in response to an inquiry for a storage resource having a particular capability, searching the table for a storage resource having the particular capability. Tracking storage resources may also include adding an element to the table in response to a new resource being added to the system. The capabilities may include RAID striping, data deduplication, and green operation. The status may be one of: on-line, off-line, and full.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122397&OS=09122397&RS=09122397
owner: EMC Corporation
number: 09122397
owner_city: Hopkinton
owner_country: US
publication_date: 20071026
---
This application relates to the field of storing data and more particularly to the field of data storage services in a scalable high capacity system.

It has been estimated that the amount of digital information created captured and replicated in 2006 was 161 exabytes or 161 billion gigabytes which is about three million times the information in all the books ever written. It is predicted that between 2006 and 2010 the information added annually to the digital universe will increase more than six fold from 161 exabytes to 988 exabytes. The type of information responsible for this massive growth is rich digital media and unstructured business content. There is also an ongoing conversion from analog to digital formats film to digital image capture analog to digital voice and analog to digital TV.

The rich digital media and unstructured business content have unique characteristics and storage requirements that are different than structured data types e.g. database records for which many of today s storage systems were specially designed. Many conventional storage systems are highly optimized to deliver high performance I O for small chunks of data. Furthermore these systems were designed to support gigabyte and terabyte sized information stores.

In contrast rich digital media and unstructured business content have greater capacity requirements petabyte versus gigabyte terabyte sized systems less predictable growth and access patterns large file sizes billions and billions of objects high throughput requirements single writer multiple reader access patterns and a need for multi platform accessibility. Conventional storage systems have met these needs in part by using specialized hardware platforms to achieve required levels of performance and reliability. Unfortunately the use of specialized hardware results in higher customer prices and may not support volume economics as the capacity demands grow large a differentiating characteristic of rich digital media and unstructured business content.

Some of the cost issues have been addressed with tiered storage which attempts to reduce the capital and operational costs associated with keeping all information on a single high cost storage tier. However tiered storage comes with a complex set of decisions surrounding technology data durability functionality and even storage vendor. Tiered storage solutions may introduce unrelated platforms technologies and software titles having non zero operational costs and management requirements that become strained as the quantity of data increases.

In addition tiered storage may cause a data replica incoherence which results in multiple disjoint copies of information existing across the tiers of storage. For example storage management software handling data backup and recovery may make multiple copies of information sets on each storage tier e.g. snapshots backup sets etc . Information Life cycle Management ILM software dealing with information migration from one tier to another may create additional and often overlapping copies of the data. Replication software may make an extra copy of the information set within a particular tier in order to increase performance to accessing applications. Each of these functions typically runs autonomously from one another. The software may be unable to realize and or take advantage of the multiple replicas of the same information set.

In addition for large scale unstructured information stores it may be difficult to maintain a system and manage the environment as components fail. For example a two petabyte information store may be comprised of eight thousand 250 gigabyte disk drives. Disk failures should be handled in a different manner in a system of this scale so that the system continues to operate relatively smoothly whenever one or only a few of the disk drives fail.

Thus it would be desirable to provide a storage system that addresses difficulties associated with high cost specialized hardware storage tiering and failure management.

According to the system described herein tracking storage resources includes providing a table containing storage resources along with capabilities and statuses thereof updating the table in response to a change of status of a storage resource updating the table in response to a change in capabilities of a storage resource and in response to an inquiry for a storage resource having a particular capability searching the table for a storage resource having the particular capability. Tracking storage resources may also include adding an element to the table in response to a new resource being added to the system. The capabilities may include RAID striping data deduplication and green operation. The status may be one of on line off line and full. The storage resources may be disk drives. The disk drives may be managed by data storage servers that present an OSD interface for the disk drives. The table may be maintained by a resource manager server that receives information about storage resources from other servers.

According further to the system described herein computer software provided in a computer readable storage medium tracks storage resources. The software includes a table that contains storage resources along with capabilities and statuses thereof executable code that updates the table in response to a change of status of a storage resource executable code that updates the table in response to a change in capabilities of a storage resource and executable code that searches the table for a storage resource having a particular capability in response to an inquiry for a storage resource having the particular capability. The software may also include executable code that adds an element to the table in response to a new resource being added to the system. The capabilities may include RAID striping data deduplication and green operation. The status may be one of on line off line and full. The storage resources may be disk drives. The disk drives may be managed by data storage servers that present an OSD interface for the disk drives. The table may be maintained by a resource manager server that receives information about storage resources from other servers.

According further to the system described herein a resource manager that manages storage resources for a storage system includes a processing device and a computer readable memory coupled to the processing device the computer readable memory having a table provided in a data structure and containing storage resources along with capabilities and statuses thereof the computer readable memory also having executable code that updates the table in response to a change of status of a storage resource executable code that updates the table in response to a change in capabilities of a storage resource and executable code that searches the table for a storage resource having a particular capability in response to an inquiry for a storage resource having the particular capability. The computer readable memory may also contain executable code that adds an element to the table in response to a new resource being added to the system. The capabilities may include RAID striping data deduplication and green operation. The status may be one of on line off line and full. The storage resources may be disk drives. The disk drives may be managed by data storage servers that present an OSD interface for the disk drives.

According further to the system described herein a data storage system includes a plurality of clients and a plurality of servers coupled to the clients where a subset of the servers manage storage resources using a table containing storage resources along with capabilities and statuses thereof where the subset updates the table in response to a change of status of a storage resource updates the table in response to a change in capabilities of a storage resource and searches the table for a storage resource having the particular capability in response to an inquiry for a storage resource having a particular capability. The subset of servers may add an element to the table in response to a new resource being added to the system. The storage resources may be disk drives.

According further to the system described herein providing information to a resource manager of a data storage system includes providing information to the resource manager in response to a change in capabilities of a storage resource providing information to the resource manager in response to a change in status of a storage resource and providing information to the resource manager in response to adding a new storage resource. The storage resources may be disk drives.

Referring to a diagram illustrates servers coupled to a plurality of clients . Each of the clients represents one or more processing devices that receives file services from the servers . Each of the clients may or may not be independent of other ones of the clients . One or more of the clients may be a multiprocessing multiuser system and possibly have multiple independent users. The clients are meant to represent any number of clients.

The file services provided by the servers may include data storage and retrieval as well as related operations such as data mirroring cloning etc. The servers may be implemented using a plurality of services and or interconnected file servers including SAN components that are provided by interconnected processing and or storage devices. In an embodiment herein each of the clients may be coupled to the servers using the Web possibly in conjunction with local TCP IP connections. However it is possible for one or more of the clients to be coupled to the servers using any other appropriate communication mechanism and or combinations thereof to provide the functionality described herein.

Referring to the client is shown as being coupled to the servers and to one or more other network s . The other network s may include a local area network LAN . Thus the client may be a gateway between the servers and a LAN to which one or more other devices not shown may also be coupled. The client may act as a local file server to the one or more other devices coupled to the LAN by providing data from the servers to the one or more other devices. Of course it is possible for one or more other clients to simultaneous act as gateways to the same or different other network s . Generally for the discussion herein reference to a particular one of the clients may be understood to include reference to any or all of the clients coupled to the servers unless otherwise indicated.

Referring to a diagram shows the client being coupled to the servers and one or more other network s e.g. a LAN in a configuration that is different from that shown in . In the configuration of a router is coupled between the servers and the client . The router may be any conventional router that may be accessed by the client . In the configuration of the client uses only a single connection point to both the servers and to the other network s . In the configuration of the client may act as local file server and gateway between the servers and one or more other devices not shown coupled to the other network s . Of course any other appropriate connection configurations may be used by any of the client coupled to the servers and or to other network s .

Referring to the client is shown in more detail having server operations software client software and an interface layer that includes a plurality of interfaces between the server operations software and the client software . The server operations software facilitates the exchange of information data between the client and the servers to provide the functionality described herein. The server operations software is described in more detail elsewhere herein. The client software represents any software that may be run on the client including application software operating system software Web server software etc. that is not part of the server operations software or the interface layer . As described in more detail elsewhere herein it is possible to have the client software interact with the servers through different ones of the interfaces at the same time.

The file services described herein may be implemented by the servers using a set of file objects where a file that is accessed by the client software includes a metadata file object which points to one or more data file objects that contain the data for the file. Accessing the file would involve first accessing the metadata file object to locate the corresponding data file objects for the file. Doing this is described in more detail elsewhere herein. Note however that any appropriate file object mechanism may be used for the system described herein.

Referring to a file is shown as including a metadata file object and a plurality of data file objects. The metadata file object contains information that points to each of the data file objects . Accessing the file includes first accessing the metadata file object and then using information therein to locate the appropriate one or more of the corresponding data file object .

Referring to the metadata file object is shown in more detail as including an object attributes section and a Layout Storage Object LSO tree section . The object attributes section contains conventional file type attributes such as owner id group id access control list last modification time last access time last change time creation time file size and link count. Many of the attributes are self explanatory. The last modification time corresponds to the last time that the data for the data objects had been modified while the last change time corresponds to when the object metadata had last been changed. The link count indicates the number of other objects that reference a particular file e.g. aliases that point to the same file . In an embodiment herein a file and its related objects are deleted when the link count is decremented to zero.

The LSO tree section includes a data structure that includes one or more maps for mapping the logical space of the file to particular data file objects. The LSO tree section may also indicate any mirrors for the data and whether the mirrors are synchronous or asynchronous. LSO trees and mirrors are described in more detail elsewhere herein.

Referring to a simple LSO tree is shown as including an LSO root node and a single map . The LSO root node is used to identify the LSO tree and includes links to one or more map s used in connection with the file corresponding to the LSO tree . The map maps logical locations within the file to actual data storage location. A process that accesses logical storage space of a file represented by the LSO tree first uses the LSO root node to find the map and then uses the map to translate logical addresses within the file to an actual data storage locations.

Referring to an LSO tree is shown as including an LSO root node and a plurality of maps . Each of the maps may represent a different range of logical offsets within the file corresponding to the LSO tree . For example the map may correspond to a first range of logical offsets in the file. The map may map logical locations in the first range to a first actual storage device. The map may correspond to a second range of logical offsets in the file different than the first range which may be mapped to a different actual storage device or may be mapped to the same actual storage device as the map . Similarly the map may correspond to a third range of logical offsets in the file different than the first range and the second range which may be mapped to a different actual storage device or may be mapped to the same actual storage device as the map and or the map .

Referring to an LSO tree is shown as including an LSO root node and a pair of replication nodes which indicate that the underlying data is to be mirrored replicated and which indicate whether the mirror is synchronous or asynchronous. Synchronous and asynchronous mirrors are discussed in more detail elsewhere herein. The node has a plurality of children maps associated therewith while the node has a plurality of children maps associated therewith. The replication nodes indicate that the data corresponding to the maps is a mirror of data corresponding to the maps . In some embodiments the nodes may be implemented using a single node to indicate replication.

A process accessing a file having the LSO tree would traverse the tree and determine that data is mirrored. As discussed in more detail elsewhere herein depending upon the type of mirroring the process accessing the LSO tree would either write the data to the children of both of the nodes or would provide a message to another process server e.g. the servers that would perform the asynchronous mirroring. Mirroring is discussed in more detail elsewhere herein.

For the system described herein file objects are accessed by one of the clients by first requesting and obtaining a lease from the servers . The lease corresponds to the file objects for the particular file being accessed and to the type of access. A lease may be for reading writing and or more some other operation e.g. changing file attributes . In an embodiment herein for objects corresponding to any particular file the servers may issue only one write lease at a time to any of the clients but may issue multiple read leases simultaneously and may issue read lease s at the same time as issuing a write lease. However in some embodiments it may be possible to obtain a lease for a specified logical range of a file for operations only on that range. Thus for example it may be possible for a first client to obtain lease for writing to a first logical range of a file while a second client may independently obtain a lease for writing to a second and separate logical range of the same file. The two write leases for different logical ranges may overlap in time without violating the general rule that the system never issues overlapping write leases for the same data.

The lease provided to the clients from the servers includes security information security token that allows the client appropriate access to the data. The security token may expire after a certain amount of time. In an embodiment herein a client accesses data by providing an appropriate security token for the data as well as client users ownership information. Thus for example a user wishing to access data would first obtain a lease and then would provide the access request to the servers along with the security token and information identifying the owner client accessing the data. The servers would then determine whether the access requested by the client was permissible. After the lease expires the security token expires the user requests the lease again. Data security may be implemented using conventional data security mechanisms.

After obtaining a lease for accessing a file a client may then cache the corresponding metadata including the LSO tree into local storage of the client. The client may then use and manipulate the local cached version of the metadata and may use the metadata to obtain access to the data. As described in more detail elsewhere herein a client does not directly modify metadata stored by the servers but instead sends update messages to the servers to signal that metadata for a file may need to be modified by the servers .

Referring to a flowchart illustrates steps performed by a client in connection with requesting a lease for a file objects associated with a file for performing operations thereon. Processing begins at a first step where the client requests the lease for the file. As discussed in more detail elsewhere herein a client requesting a lease includes specifying the type of access e.g. read write etc. . Following the step is a test step where it is determined if the request has been granted. If not then control transfers from the test step to a step where processing is performed in connection with the lease not being granted to the client. The particular processing performed at the step may include for example providing an error message to the client process requesting access to the file corresponding to the lease and or waiting for an amount of time and then retrying the request. Note that it is possible that a lease for a particular file is not available at one time is subsequently available at another time because for example the lease is released by another client in between the first request and the second request. In any event any appropriate processing may be performed at the step . Following the step processing is complete.

If it is determined at the test step that the least requested at the step has been granted then control transfers from the test step to a step where the client performs an operation using the file for which the lease was granted. Operations performed at the step include reading data and or writing data. Different types of processing that may be performed at the step are described in more detail elsewhere herein.

Following the step is a test step where it is determined if the operations performed at the step require an update. In some instances a client may obtain a lease and perform operations that do not affect the file or the underlying file objects. For example a client may acquire a lease for reading a file and the operation performed at the step may include the client reading the file. In such a case no update may be necessary since the file and corresponding file objects metadata data objects etc. have not changed. On the other hand if the client obtains a lease for writing data the file and the operation performed at the step includes writing data to the file then the underlying file objects will have been changed and an update message needs to be sent the servers . If it is determined at the test step that an update is necessary then control passes from the test step to a step where an update message is sent by the client to the servers .

Following the step or following the step if no update is necessary control passes to a test step where it is determined if the client is finished with the file. In some instances the client may perform a small number of operations on the file after which the client would be finished with the file at the step . In other cases the client may be performing a series of operations and may not yet have completed all of the operations.

If it is determined at the test step that the client is not finished with the file then control passes from the test step to a test step where it is determined if the lease for the file has expired. Note that a lease may be provided by the servers to the client with a particular expiration time and or the associated security token may expire. In addition it may be possible for the servers to recall leases provided to clients under certain circumstances. In either case the lease may no longer be valid. Accordingly if it is determined at the step that the lease has expired and or has been recalled by the servers then control passes from the test step back to the step request the lease again. Otherwise if the lease has not expired then control passes from the test step back to the step to perform another iteration.

If it is determined at the test step that the client is finished with the file then control passes from the test step to a step where the client releases the lease by sending a message to the servers indicating that the client no longer needs the lease. Once the client releases the lease it may be available for other clients. Following the step processing is complete.

In an embodiment herein data file objects may be indicated as having one of four possible states current stale immutable or empty. The current state indicates that the data object is up to date and current. The stale state indicates that the data is not valid but instead requires updating perhaps by some other process. In some instances the stale state may be used only in connection with mirror copies of data explained in more detail elsewhere herein . Data may be stale because it is a mirror of other data that was recently written but not yet copied. The immutable state indicates that the corresponding data is write protected perhaps in connection with a previous clone snapshot operation. The empty state indicates that no actual storage space has yet been allocated for the data.

Referring to a flow chart illustrates steps performed by a client in connection with performing read operations after obtaining a read lease for a file. Processing begins at a first test step where it is determined if the data object being read is in the current state. If not then control transfers from the test step to a step where it is determined if the data object being read is in the immutable state. If it is determined at the step that the data object being read is in the immutable state or if it is determined at the test step that the data object being read is in the current state then control transfers to a step where the read operation is performed. A client reads file data by providing the appropriate data file object identifier to the servers as well as providing appropriate security credentials. Accordingly the read operation performed at the step includes the client sending an appropriate request to the servers and waiting for a result therefrom.

Following the step is a test step where it is determined if the servers have returned a result indicating that the data file object is unavailable. In some cases a data file object that is otherwise current or immutable may nevertheless become unavailable. For example the physical storage space that holds the data file object may become temporarily disconnected and or temporarily busy doing some other operation. If it is determined at the test step that the data file object is available then control transfers from the test step to a test step where it is determined if the read operation was successful. If so then control transfers from the test step to a step where the result of the read operation is returned to the process at the client that caused the read operation to be performed. The result may include the data that was read and a status indicator. Following the step processing is complete.

If it is determined at the test step that the read operation performed at the step was not successful then control transfers from the test step to a step where error processing is performed. The particular error processing performed at the step is implementation dependent and may include for example reporting the error to a calling process and or possibly retrying the read operation a specified number of times. Following the step processing is complete.

If it is determined at the test step that the data object being read is not in the immutable state then control transfers from the test step to a test step where it is determined if the data object is in the stale state. If not then by virtue of the test steps and process of elimination the data object is in the empty state. In an embodiment herein reading a data object in the empty state causes zeros to be returned to the calling process. Accordingly if it is determined at the test step that the data object is not in the stale state then control transfers from the test step to a step where zeros are returned in response to the read operation. Following the step processing is complete.

If it is determined at the test step that the data file object is in the stale state or if it is determined at the test step that the data file object is not available then control transfers to a test step to determine if an alternative version of the data file object is available for reading. As discussed in more detail elsewhere herein there may be multiple versions of the same data file objects that exist at the same time due to mirroring. Accordingly if the data file object being read is in the stale state or otherwise unavailable it may be possible to read a mirror copy of the data file object that may be in the current state. The test performed at the step is described in more detail elsewhere herein.

If it is determined at the test step that an alternative version of the data file object is available then control transfers from the test step to a step where the alternative version of the data file object is selected for use. Following the step control transfers back to the test step for another iteration with the alternative data file object.

If it is determined at the test step that an alternative version of the data file object is not available then control transfers from the test step to a step where the client process waits. In an embodiment herein it may be desirable to wait for a data file object to become current and or available. Following the step control transfers back to the step for another iteration. Note that instead of waiting at the step processing may proceed from the step to the step to perform error processing if there is no alternative data file object available. In other embodiments it may be possible to perform the step a certain number of times and then if the data file object is still unavailable or in the stale state and there is no alternative data file object then perform the error processing at the step .

Referring to a flow chart illustrates steps performed by a client in connection with performing write operations after obtaining a write lease for a file. Processing begins at a first test step where it is determined if the data file object to which the write is being performed is in the immutable state. If so then control transfers from the step to a step where new actual storage space is allocated for the data file object to avoid overwriting the immutable data. Allocating new storage space for a data object may include providing an appropriate request to the servers . Following the step control transfers back to the step to begin the processing for the write operation again.

If it is determined at the step that the data file object to which the write is being performed is not in the immutable state then control transfers from the step to a step where it is determined if the data file object to which the write is being performed is in the stale state. If not then control transfers from the test step to a test step where it is determined if the data file object to which the write is being performed is in the empty state. If so then control transfers from the step to the step discussed above where new physical storage space is allocated. Following the step control transfers back to the step to begin the processing for the write operation again.

If it is determined at the step that the data file object to which the write is being performed is not in the empty state then control transfers from the test step to a step where the write operation is performed. Note that the step is reached if the data file object to which the write operation is being performed is not in the immutable state not in the stale state and not in the empty state and thus is in the current state . A client writes file data by providing the appropriate data file object location identifier to the servers as well as providing appropriate security credentials. Accordingly the write operation performed at the step includes the client sending an appropriate request to the servers and waiting for a result therefrom.

Following the step is a test step where it is determined if the write operation performed at the step was successful. If so then control transfers from the test step to a test step where it is determined if there are synchronous mirrors of the data file object to which the write is being performed. The test performed at the step may include for example determining if a parent node of the data file object in the file LSO tree indicates replication. If not then control transfers from the test step to a step where an update message is sent to the servers indicating that the write had been performed. Following the step processing is complete.

If it is determined at the test step that there are synchronous mirrors of the data file object to which the write is being performed then control passes from the test step to a step where the data that was written at the step is also written to the synchronous mirror s . The processing performed at the step is discussed in more detail elsewhere herein. Following the step control transfers to the step discussed above where an update message is sent to the servers . Following the step processing is complete.

If it is determined at the test step that the write operation performed at the step was not successful or if it is determined at the test step that the data file object to which the write operation is being performed is in the stale state then control transfers to a step where the data file object to which the write is attempting to be performed is removed from the client s local copy of the LSO tree. At the end of the write operation illustrated by the flow chart the client may inform the servers at the step of the difficulty in writing to the data object so that the servers can take appropriate action if necessary.

Following the step is a test step where it is determined if an alternative version of the data is available. As discussed in more detail elsewhere herein there may be multiple versions of the same data file objects that exist at the same time due to mirroring. Accordingly if the data file object to which the write operation is being performed is stale or otherwise cannot be written to it may be possible to write to a mirror copy of the data. The test performed at the step is like the test performed at the step and is described in more detail elsewhere herein. If it is determined at the test step that an alternative version of the data corresponding to the data file object is available then control transfers from the test step to a step where the alternative version is selected for writing. Following the step control transfers back to the test step for another iteration with the alternative data file object.

If it is determined at the test step that an alternative version of the data corresponding to the data file object is not available then control transfers from the test step to a step to perform error processing if there is no alternative available. The particular error processing performed at the step is implementation dependent and may include for example reporting the error to a calling process and or possibly retrying the write operation a specified number of times before reporting the error. Following the step control transfers to the step discussed above to send update information to the servers . Following the step processing is complete.

Referring to a flow chart illustrates in more detail steps performed in connection with the alternative available test step of and or the alternative available test step of . Processing begins at a first test step where it is determined if the file has any mirror data file objects at all. In some instances a file may not use mirrors in which case there would be no alternative copy available. Accordingly if it is determined at the test step that the file does not have any mirror data file objects then control transfers from the test step to a step where a value is returned indicating that no alternative copies are available. Following the step processing is complete.

If it is determined at the test step that mirror copies are available then control transfers from the test step to a step where a pointer is made to point to a first mirror data file object. For the processing discussed herein a pointer may be used to iterate through mirror data file objects to find a useable data file object. Following the step is a test step where it is determined if the pointer is past the end of the list of mirror data file objects has iterated through all of the mirror data file objects . If so then control passes from the test step to the step discussed above to return a value that indicates that no alternatives are available.

If it is determined at the test step that the pointer is not past the end of a list of mirror data file objects then control transfers from the test step to a test step where it is determined if the pointer points to a data file object in a stale state. If so then control transfers from the test step to a step where the pointer is made to point to the next data file object to be examined. Following the step control transfers back to the step discussed above for another iteration. If it is determined at the test step that the pointer does not point to a data file object in the stale state then control transfers from the test step to a step where the data file object that is pointed to by the pointer is returned as an alternative data file object that may be used by the calling process. Following the step processing is complete.

Referring to a flow chart illustrates in more detail operations performed in connection with the step of the flow chart of where data that has been written is copied to a number of synchronous mirrors mirror data file objects . Processing begins at a first step where a pointer that is used to iterate through the mirror data file objects is set to point the first one of the mirror data file objects. Following the step is a test step where it is determined if the pointer used for iterating through the mirror data file objects points past the end i.e. if all of the mirror data file objects have been processed . If so then processing is complete. Otherwise control transfers from the test step to a test step where it is determined if the status of the mirror data file object pointed to by the pointer indicates that the mirror data file object is current. If not then control passes from the test step to a test step where it is determined if the status of the mirror data file object pointed to by the pointer indicates that the mirror data file object is in the stale state. If so then control passes from the test step to a step where the mirror data file object is removed from the client s local copy of the LSO tree. In an embodiment herein a synchronous mirror data file object should not be in a stale state and if that occurs it may indicate an error condition. Accordingly following the step is a step where information about the stale mirror is sent to the servers which may perform recovery processing in response thereto.

Note that if a mirror data file object is neither in the stale state nor in the current state then the mirror data file object is either in the empty state or in the immutable state. In either case it may be necessary to allocate new space for a data file object to which the data is to be written. Accordingly if it is determined at the test step that the data file object is not in the stale state then control passes from the test step to a step where new space is allocated for the mirror data file object. Following the step is a step where the data that is being copied across synchronous mirror data file objects is written to the mirror data file object pointed to by the pointer used to iterate through the mirror data file objects. Note that the step may also be reached from the test step if it is determined that the mirror data file object is current. Following the step is a step where the pointer used to iterate through the mirror data file objects is made to point to the next one. Note that the step is also reached following the step . Following the step control transfers back to the test step for another iteration.

The system described herein may access file objects using object identifiers. In an embodiment herein each file object that is stored among the servers may be assigned a unique object identifier that identifies each file object and distinguishes each file object from other file objects in the system. However many applications use a file naming structure and or a hierarchical directory to access files and data therein. For example a file name C ABC DEF GHI.doc indicates a file called GHI.doc stored in a sub directory DEF that is stored in another directory ABC located on a root volume C . A nested directory structure may be provided by implementing directories as special files that are stored in other directories. In the example given above the sub directory DEF may be implemented as a file stored in the directory ABC .

The system described herein may present to applications a conventional naming structure and directory hierarchy by translating conventional file names into file object identifiers. Such a translation service may be used by other services in connection with file operations. In an embodiment herein each directory may include a table that correlates file names and sub directory names with file object identifiers. The system may examine one directory at a time and traverse sub directories until a target file is reached.

Referring to a flow chart illustrates steps performed in connection with providing a file name translation service file name service that translates a conventional hierarchical file name into a file object identifier. The file name service may receive a conventional hierarchical file name as an input and may return an object identifier or in some cases an error . Processing begins at a first step where the file name service receives a file name such as a conventional hierarchical file name. Following the step is a test step where it is determined if the syntax of the file name is OK. Checking the syntax of a hierarchical file name is know and includes for example checking that only appropriate characters have been used. If it is determined at the test step that the syntax is not OK then control transfers from the test step to a step where an error indicator error message is returned to the calling process. Following the step processing is complete.

If it is determined at the test step that the syntax of the provided name is OK then control transfers from the test step to a step where the root directory is read. In an embodiment herein all file name paths begin at a single common root directory used for all file objects stored in the servers . In other embodiments there may be multiple root directories where specification of a particular root directory may be provided by any appropriate means such as using a volume identifier specifically selecting a particular root directory etc.

Following the step is a test step where it is determined if the target file or sub directory that is part of the file name path is in the directory that has been read. If not then control passes from the test step to the step discussed above where an error is returned. In some embodiments the file not found error that results from the test at the step may be different from the syntax error that results from the test at the step .

If it is determined that the target file or a sub directory that is part of the file name path is in the directory that has just been read then control passes from the test step to a test step where it is determined if the directory that has just been read contains the target file as opposed to containing a sub directory that is part of the file name path . If so then control passes from the test step to a step where the object identifier of the target file object is returned to the calling process. Following the step processing is complete.

If it is determined at the test step that the directory that has just been read contains a sub directory that is part of the file name path then control transfers from the test step to a step where the sub directory is read so that the sub directory becomes the directory being examined. In effect processing at the step traverses the chain of subdirectories to eventually get to the target file. Following the step control transfers back to the step discussed above for a next iteration.

Referring to a diagram shows the client as including user address memory space and kernel address memory space. In an embodiment herein user address memory space is memory space that is generally used by user applications and related processes while kernel address memory space is memory space that is generally accessible only by system processes such as an operating system kernel and related processes. As discussed in more detail herein it is possible to have different portions of the system described herein reside and operate in the user memory space and or the kernel memory space. In addition it is possible for the client to have multiple different interfaces to access file objects at the servers.

In the client is shown as including an application in the user memory address space and a virtual file system VFS file name services kernel I O drivers a layout manager and a communication interface in the kernel memory address space. The VFS is an abstraction layer on top of a more concrete file system. The purpose of a VFS is to allow client applications to access different types of concrete file systems in a uniform way. The VFS allows the application running on the client to access file objects on the servers without the application needing to understand the details of the underlying file system. The VFS may be implemented in a conventional fashion by translating file system calls by the application into file object manipulations and vice versa. For example the VFS may translate file system calls such as open read write close etc. into file object calls such as create object delete object etc.

The VFS may use the file name services described elsewhere herein to translate file names into object identifiers. The kernel I O drivers provide an interface to low level object level I O operations. The kernel I O drivers may be modeled after and be similar to Linux I O drivers. The layout manager may perform some of the processing on LSO trees corresponding to files as discussed in more detail elsewhere herein. The communication interface provides communication between the client and the servers . The communication interface may be implemented using any appropriate communication mechanism. For example if the client communicates with the servers via an Internet connection then the communication interface may use TCP IP to facilitate communication between the servers and the client .

The application of may correspond to the client software of . The VFS of may correspond to one of the interfaces of . The file name services kernel I O drivers layout manager and communication interface of may correspond to the server operations software of . Similar correlation between components of and other figures may also be found.

Referring to a flow chart illustrates steps performed by a VFS to provide file services in connection with an application running on the client . Processing begins at a first step where a file system operation requested by an application may be translated into one or more object operations. For example a file operation to open a file for reading may be converted to object operations that include obtaining an object lease for reading as discussed elsewhere herein. Following the step is a step where the VFS translates the file name into an object identifiers using the file name services discussed above in connection with . Operations that follow may be performed using the object identifiers obtained at the step .

Following the step is a test step where it is determined if the requested operation requires the LSO tree. As discussed elsewhere herein operations such as read write etc. use LSO trees corresponding to file objects. However some possible file operations may not require accessing a corresponding LSO tree. If it is determined at the test step that the LSO tree is needed then control transfers from the test step to a step where the VFS accesses the LSO manager to perform the necessary operations. For example for a read operation the LSO manager may perform processing like that illustrated in the flow chart of . Following the step or following the step if the LSO is not needed is a step where the operations are passed to low level kernel I O drivers e.g. via one or more appropriate API s . The kernel I O drivers use the communication module to communicate between the client and the servers in connection with performing the requested operation s . In instances where the application running on the client has requested data and or other information from the servers the data and or information may be passed back up through the communication interface kernel I O drivers etc. to the VFS and ultimately to the application.

Referring to the client is shown as having an application file name services user level I O drivers and a layout manager all provided in user memory address space. The functionality of the VFS that was shown in and described above may be performed instead by library routines linked to the application and thus are part of the application. These routines would provide functionality like that discussed above in connection with . Accordingly it is the application that uses the file name services and makes calls to the user level I O drivers like the kernel I O drivers and to the layout manager. The communication interface is still maintained in the kernel memory address space.

Note that for the configuration of modifications are provided by modifying system processes the operating system which is disadvantageous for a number of reasons. For example if the client is a multiuser computing system then modifying the operating system may involve restarting the entire system and thus disrupting all of the users. In contrast the configuration of is advantageous since it allows modification of the system in the application user memory address space so that the operating system of the client does not need to be modified. However the configuration of does not use a VFS and thus does not obtain the advantageous separation of the application from the file system that is provided by the VFS in .

Referring to the client is shown as having an application in user memory address space that accesses file objects through a VFS in kernel memory address space like that illustrated in . However the file name services I O drivers and the layout manager all reside in the user memory address space like the system illustrated in . The VFS communicates with components in the user memory address space through a bridge between kernel memory address space and user memory address space such as a FUSE or similar interface. The bridge allows file system components to be provided in user memory space instead of kernel address memory space while still preserving the VFS in the kernel address memory space. Thus the configuration illustrated by provides the advantages of using a VFS as illustrated in the configuration of along with the advantages of having file system components in the user address memory space as illustrated in the configuration of .

It is possible in some instances to have applications and or other processing in the user memory address space of the client access file objects directly rather than through a file services layer like the VFS and or equivalent functionality provided by user linkable libraries e.g. the configuration illustrated in . Accessing file objects directly may include invoking routines that create objects read objects modify objects delete objects etc. In such a case the application would need to know how to interpret and or manipulate the object data which may not always be desirable. For example an application that accesses file objects through the VFS may not need to take into account or even know about the structure of an LSO tree while an application that accesses objects directly may need to use the LSO tree. On the other hand removing the file services layer may provide an opportunity for optimizations not otherwise available. Note that since the servers exchange object information operations with the clients the servers may not need to distinguish or be able to distinguish between application on the clients using a file system interface file services like the VFS and those that are not.

Referring to the client is shown as including an application in the user memory address space and kernel I O drivers a layout manager and file name services in the kernel memory address space. The configuration illustrated in is like that illustrated in except that the VFS is not used. In the configuration illustrated in the application could directly access the file name services the kernel I O drivers and the layout manager. The communication interface in the kernel memory address space communicates with the servers just as in other configurations. The direct access illustrated in allows applications to manipulate file objects via for example appropriate API s while access via the VFS or similar allows applications to accesses file objects indirectly through file system calls to the VFS.

Referring to the client is shown as having an application user level I O drivers a layout manager and file name services all provided in user memory address space. The configuration shown in is like that shown in . However as set forth above the configuration of includes file service libraries that are linked into and thus part of the application. In contrast in the configuration of FIG. the application is not linked into libraries with extensive file services. Instead like the application of the configuration illustrated in the application in the configuration of uses minimal file services and instead uses and operates upon file objects directly using the user level I O drivers the layout manager and if a file name translation is needed the file name services.

Referring to the client is shown as having an application in user memory address space and a bridge in the kernel memory address space. File name services user level I O drivers and a layout manager are provided in user memory address space. However unlike the configuration of the application does not make direct calls to the file system components in the user memory address space. Instead the application calls the file system components indirectly through the bridge. Just as with the configuration illustrated in the configuration of advantageously locates file system components in the user memory address space and at the same time provides a kernel memory address space layer between the application and the file system components.

Referring to the client is shown as having an application in user memory address space and a Web Services module in kernel memory address space. The application may be a Web server application or any application that handles communication with the Web. In an embodiment herein the application allows communication with the client which acts as a Web server to other computing devices not shown that access the client through a Web connection.

The configuration illustrated in provides Web Services in a manner similar to the file services and or file object access provided by other configurations. However the Web Services receives requests data via a Web data protocol such as HTML and provides responses data also in a Web data protocol which may be the same or different from the protocol used for requests data. Operations handled by the Web Services may include object level operations such as create object delete object read object modify object modify object metadata etc. It is also possible to provide more file system level operations via the Web Services that open files read data from files etc. by including at least some of the functionality of the file services described elsewhere herein with the Web Services. The Web Services may present to the other computing devices a conventional well known Web Services protocol such as REST or SOAP or may provide any other appropriate protocol.

Referring to the client is shown as having an application Web Services user level I O drivers and a layout manager in user memory address space. The application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. The configuration of is like that of and . The advantages of the configuration shown in over the configuration shown in is that generally changes to the configuration shown in do not require reconfiguring kernel memory address space processes.

Referring to the is shown as having an application Web Services user level I O drivers and a layout manager in user memory address space. The application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. A bridge is provided in the kernel memory address space. The configuration of has similar advantages to the configuration shown in but also has the advantages provided by providing the bridge discussed elsewhere herein.

Referring to the client is shown as having a plurality of applications in user memory address space each of which may use a different interface to access file objects of the servers . Each of the applications shown in is meant to represent one or more applications. Accordingly APP1 may present one or more applications that access file objects at the servers using a Web Services interface. The APP1 application may include a Web connection that allows communication with the client which acts as a Web server to other computing devices not shown that access the client through the Web connection. APP2 may represent one or more applications that access file objects at the servers using the VFS and APP3 may represent one or more applications that directly operate on file objects at the servers . The different interfaces may operate at the client at the same time.

Note that may other combinations of configurations including illustrated configurations are possible so that the client may simultaneously present to applications thereon different interfaces. For example it is possible to combine the configurations illustrated in and and or combine the configurations of and . Other combinations including combinations of only two illustrated configurations are also possible. The servers provide the file objects to the clients provided 1 the requesting client has appropriate authorization for whatever operation is requested for the file objects and 2 there is no conflict with any previous request. For example in systems where only one client is allowed to write to an object at any one time the servers would not allow one of the clients to modify a particular object while another one of the clients is also modifying the object.

Referring to the servers are shown in more detail as including one or more policy manager servers one or more security manager servers one or more audit servers one or more metadata servers one or more resource manager servers one or more data storage servers and one or more metadata location servers . Each of the servers may be implemented as one or more unitary processing devices capable of providing the functionality described herein. For the discussion herein reference to servers should be understood as a reference to one or more servers. The servers may be interconnected using any appropriate data communication mechanism such as TCP IP and may be coupled to the clients not shown in using any appropriate data communication mechanism such as TCP IP.

The servers may include a user management interface that facilitates system management. The user management interface exchanges data with the policy management servers the security management servers and the audit servers to affect how the servers interact with the clients and corresponding users. The data may be provided through the user management interface in any one of a number of ways including conventional interactive computer screen input and data file input e.g. a text file having user management commands . The data may include information that correlates classes of users and storage parameters such as Quality of Service QOS RAID protection level number and geographic location s of mirrors etc. For example an administrator may specify through the user management interface that users of a particular class users belonging to a particular group store data file objects on storage devices having a particular RAID level protection.

The servers also include physical storage coupled to the data storage servers . Although the physical storage is shown as a single item in there may be any number of separate physical storage units that may be geographically dispersed. In addition there may be different types of physical storage units having different capabilities. Accordingly the physical storage generically represents one or more instances of physical data storage for the system that is managed by the data storage servers as explained in more detail below.

Data modifications including modifications of metadata file objects and or policies that affect handling creation of metadata file objects require appropriate security credentials. Accordingly the security manager servers may restrict inhibit the ability of certain administrators users to modify and or create policies for classes of users.

Referring to a flow chart illustrates steps performed by the user management interface to obtain and use security credentials for accessing the policy manager servers . Processing begins at a first step where the user management interface sends a request to the security manager servers to obtain a token or other appropriate security credentials for the operation to be performed by the user management interface . Following the step is a test step where it is determined if the token has been granted provided . In some instances the security manager servers may not issue a security token at all. For example if the administrator user does not have sufficient rights to perform the desired function.

If the security token is not granted then control passes from the step to a step where processing is performed in connection with the security token not being granted. The operations performed at the step may including providing a message to the administrator user through the security management interface indicating that the administrator does not have sufficient rights to perform the desired operation. Following the step processing is complete.

If it is determined at the test step that a security token has been granted provided by the security manager servers then control passes from the test step to a step where the user management interface provides the security token and user id information to the policy manager servers . Of course information indicating the desired operation modification may also be provided at the step . Following the step is a test step where it is determined if the policy manager servers have allowed the requested operation. Note that in some instances the policy manager servers may not allow a particular operation even though the security manager servers have provided a security token. For example if the user id and the user indicated by the security token do not match and or if the requested operation and the operation indicated by the security token do not match.

If it is determined at the test step that the requested operation is not allowed then control passes from the test step to the step described above where processing is performed to indicate that there are security issues. The processing performed at the step may include providing a message to an administrator user indicating that the operation cannot be performed because of insufficient security rights. The message provided when the step is reached from the step may be different than the message provided when the step is reached from the step .

If it is determined at the test step that the requested operation is allowed then control passes from the test step to a step where the operation is performed. Performing the operation at the step may include modifying policy data as described in more detail elsewhere herein. Following the step processing is complete.

Thus an administrator user accessing the policy manager servers would first provide identification information to the security manager servers that would return a security token perhaps having an expiration time . The administrator presents the token and identification information to the policy manager servers which would decide to grant or deny access based on the token and the identification information. Note that the security mechanism illustrated by the flow chart of may be extended to be used in connection with accessing any of the servers and or other data. For example one of the clients could obtain modify file objects by first requesting a security token from the security manager servers prior to performing an operation that includes operations with file objects. Accordingly for the discussion herein it can be assumed that access to file objects servers etc. includes appropriate security procedures like those illustrated in .

The policy manager servers handle placement and protection of file objects. An administrator user may input through the user management interface different policy templates that may be assigned to different ones of the clients different users different classes of users or any other appropriate group. For example a policy template may indicate that for a particular group of users whenever a new file is created a mirror will be created that is geographically farther from the initial data set by at least a certain distance. In such a case when a first user of the group creates an initial data set in New York a mirror may be automatically created in Los Angeles while when a second user creates an initial data set in Los Angeles a mirror may be created in New York.

The audit servers may be used to provide system auditing capability. A user may communicate to the audit servers through the user management interface . The user may indicate the type of information to be audited tracked .

The resource manager servers keep track of available system resources. In some instances the resource manager servers may interact with the policy manager servers in connection with establishing policy templates and or assigning policy templates. In some cases a user may attempt to construct a policy template that is impossible to fulfill if assigned to a group. For example if all of the physical data storage is in a single geographic location then it would not be appropriate to have a policy template indicating that new files should include a mirror that is geographically distant from the initial data set.

The resource manager servers receive information from other components of the system in order to be able to keep track which resources are available. Whenever a resource is added to the system the resource or another component reports that information to the resource manager servers . For example if new physical storage is added to the system the new physical storage itself or a corresponding one of the data storage servers sends a message to the resource manager servers . Similarly if a resource becomes full e.g. a physical disk is full or is removed from the system planned removal or unplanned resource failure information is provided to the resource manager servers . In an embodiment herein system resources may correspond to portions of the physical storage and or data servers that manage the physical storage .

Referring to a resource table is shown as including a plurality of entries each of which corresponds to a particular storage resource. Although only three entries are shown the table may contain any number of entries. The table may be implemented using any appropriate technique including an array linked list etc.

Each of the entries includes a resource field identifying a particular resource corresponding to the entry. In an embodiment herein each of the entries may correspond to a particular one of the data storage servers and or a portion thereof. Each of the entries includes a status field corresponding to the status of the corresponding resource. In an embodiment herein the status field may indicate that a resource is on line available or off line unavailable . The status field may also indicate the percentage of used space of a resource and perhaps indicate any performance degradation.

Each of the entries may also include a capabilities field that indicates the capabilities of the corresponding resource. In an embodiment herein when the resources represent storage areas the capabilities field may indicate particular capabilities of a corresponding storage area. Particular capabilities may include the resource being green low energy use through for example spinning disks down when not in use capable of data deduplication maintaining only a single copy of data that is otherwise duplicated capable of various RAID configurations etc. The capabilities field may indicate any appropriate data storage capabilities.

Referring to a flow chart indicates operation of the resource manager servers in connection with maintaining information about system resources. Processing begins at a first step where the resource manager servers are initialized with information about resources. The initialization processing performed at the step may take any form including loading a fixed table of initially available resources having the resource manager servers poll system resources etc.

Following the step is a test step where the resource manager servers wait for new information to be provided. In an embodiment herein after initialization the resource manager servers wait to receive information from other system components. In other embodiments it may be possible to have the resource manager servers periodically poll system components to see if anything has changed. If it is determined at the test step that no new information is available control loops back on the test step to continue polling.

Once it is determined at the test step that new information is available then control transfers from the test step to a test step where it is determined if the new information relates to a new resource added to the system. If so then control transfers from the test step to a step where the new entry is added to the resource table that is managed by the resource manager servers . Following the step control transfers back to the step to continue waiting for new information.

If it is determined at the step that the received resource information does not related to a new resource and thus relates to a change of an existing resource then control transfers from the step to a step where the existing entry is located in the resource table. Following the step is a test step where it is determined if the capability is being changed for the modified resource. The capability of a resource may change under many different circumstances. For example a resource may degrade and lose capabilities a resource may be modified enhanced and gain capabilities a local manager of a resource may decide to make certain capabilities available unavailable etc.

If it is determined at the step that the capabilities of a resource have changed then control transfers from the test step to a step to change the capabilities field for the resource being modified. Otherwise control transfers from the test step to a step to change the status field of the resource being modified e.g. resource is full resource is off line resource is on line etc. . Following either the step or the step control transfer back to the step discussed above for another iteration.

Note that the resource manager servers may represent a plurality of separate computing devices that may be dispersed throughout the system. Furthermore each of the separate computing devices may maintain its own copy of the resource table. The separate computing devices that are used to implement the resource manager servers may or may not share resource information and may or may not receive the same resource status messages. In instances where information sharing and or receipt of status messages is not perfect then each of the computing devices may have a somewhat different version of the resource table and it is possible for no one version of the resource table to reflect a completely accurate picture of the exact state of all of the resources of the system.

The physical storage may be provided using relatively inexpensive off the shelf mass produced storage hardware. In an embodiment herein at least some of the physical storage may be implemented using serial ATA disk drives which are available from a number of manufactures such as Seagate and Western Digital. As discussed elsewhere herein the physical storage may be geographically dispersed. However each portion of the physical storage may be managed controlled by at least one of the data storage servers which may be implemented using conventional computing devices local to the corresponding portion of the physical storage .

In an embodiment herein the data storage servers may present an OSD Standard interface to the system. Thus the servers and or the clients may access physical storage through the data storage servers using OSD calls and may receive information data according to the OSD protocol. In addition the data storage servers may handle managing posting the capabilities and status of different portions of the physical storage . Thus for example when a portion of the physical storage is managed by a particular server of the data storage servers the particular server may send a message to the resource manager servers indicating the new status.

Referring to a flow chart illustrates steps performed by the resource manager servers in connection with servicing an inquiry for a resource with particular capabilities i.e. finding a resource with particular capabilities . Processing begins at a first step where a pointer used to iterate through each entry of the resource table is set to point to the first entry. Following the step is a test step where it is determined if the pointer points past the end of the table i.e. all entries have been examined . If so then control passes from the test step to a step where a result indicating no match for the requested capabilities is returned by the resource manager servers . Following the step processing is complete.

If it is determined at the test step that the pointer used to iterate through the entries does not point past the end of the table then control transfers from the test step to a test step where it is determined if the entry currently indicated by the pointer is a match for the requested capability. Note that the test at the step may include checking the status of a resource to ensure that the resource is on line and not full or otherwise unusable. If it is determined at the step that the resource indicated by the pointer has the requested capability then control transfers from the test step to a step where the resource manager servers return an indicator indicating the matching resource. Following the step processing is complete.

If it is determined at the step that the resource indicated by the pointer does not have the requested capability or is off line full etc. then control transfers from the test step to a step where the pointer is incremented. Following the step control transfers back to the step discussed above for another iteration.

The system described herein may be used with any server or any group of servers capable of providing file objects to clients. The particular form of the file objects may vary without departing from the spirit and scope of the invention. In some instances the order of steps in the flow charts may be modified where appropriate. The system described herein may be implemented using a computer program product software provided in a computer readable storage medium.

While the invention has been disclosed in connection with various embodiments modifications thereon will be readily apparent to those skilled in the art. Accordingly the spirit and scope of the invention is set forth in the following claims.

