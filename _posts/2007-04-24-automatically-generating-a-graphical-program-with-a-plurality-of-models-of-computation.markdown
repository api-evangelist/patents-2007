---

title: Automatically generating a graphical program with a plurality of models of computation
abstract: A system and method for automatically generating a graphical program or a portion of a graphical program in response to receiving user input. The user input may specify functionality of the graphical program or graphical program portion to be generated. In response to the user input, a graphical program (or graphical program portion) that implements the specified functionality may be automatically generated. The graphical program may include a plurality of computational models. Thus, different graphical programs may be generated, depending on the user input received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08271943&OS=08271943&RS=08271943
owner: National Instruments Corporation
number: 08271943
owner_city: Austin
owner_country: US
publication_date: 20070424
---
The present invention relates to the field of graphical programming and more particularly to a system and method for automatically generating a graphical program with a plurality of models of computation in response to user input specifying desired functionality of the graphical program.

Traditionally high level text based programming languages have been used by programmers in writing application programs. Many different high level programming languages exist including BASIC C Java FORTRAN Pascal COBOL ADA APL etc. Programs written in these high level languages are translated to the machine language level by translators known as compilers or interpreters. The high level programming languages in this level as well as the assembly language level are referred to herein as text based programming environments.

Increasingly computers are required to be used and programmed by those who are not highly trained in computer programming techniques. When traditional text based programming environments are used the user s programming skills and ability to interact with the computer system often become a limiting factor in the achievement of optimal utilization of the computer system.

There are numerous subtle complexities which a user must master before he can efficiently program a computer system in a text based environment. The task of programming a computer system to model or implement a process often is further complicated by the fact that a sequence of mathematical formulas mathematical steps or other procedures customarily used to conceptually model a process often does not closely correspond to the traditional text based programming techniques used to program a computer system to model such a process. In other words the requirement that a user program in a text based programming environment places a level of abstraction between the user s conceptualization of the solution and the implementation of a method that accomplishes this solution in a computer program. Thus a user often must substantially master different skills in order to both conceptualize a problem or process and then to program a computer to implement a solution to the problem or process. Since a user often is not fully proficient in techniques for programming a computer system in a text based environment to implement his solution the efficiency with which the computer system can be utilized often is reduced.

Examples of fields in which computer systems are employed to interact with physical systems are the fields of instrumentation process control industrial automation and simulation. Computer measurement and control of devices such as instruments or industrial automation hardware has become increasingly desirable in view of the increasing complexity and variety of instruments and devices available for use. However due to the wide variety of possible testing and control situations and environments and also the wide array of instruments or devices available it is often necessary for a user to develop a custom program to control a desired system.

As discussed above computer programs used to control such systems traditionally had to be written in text based programming languages such as for example assembly language C FORTRAN BASIC etc. Traditional users of these systems however often were not highly trained in programming techniques and in addition text based programming languages were not sufficiently intuitive to allow users to use these languages without training. Therefore implementation of such systems frequently required the involvement of a programmer to write software for control and analysis of instrumentation or industrial automation data. Thus development and maintenance of the software elements in these systems often proved to be difficult.

U.S. Pat. Nos. 4 901 221 4 914 568 5 291 587 5 301 301 and 5 301 336 among others to Kodosky et al disclose a graphical system and method for modeling a process i.e. a graphical programming environment which enables a user to easily and intuitively model a process. The graphical programming environment disclosed in Kodosky et al can be considered a higher and more intuitive way in which to interact with a computer. A graphically based programming environment can be represented at a level above text based high level programming languages such as C Basic Java etc.

The method disclosed in Kodosky et al allows a user to construct a diagram using a block diagram editor. The block diagram may include a plurality of interconnected icons such that the diagram created graphically displays a procedure or method for accomplishing a certain result such as manipulating one or more input variables and or producing one or more output variables. The diagram may have one or more of data flow control flow and or execution flow representations. In response to the user constructing a diagram or graphical program using the block diagram editor data structures may be automatically constructed which characterize an execution procedure which corresponds to the displayed procedure. The graphical program may be compiled or interpreted by a computer.

Therefore Kodosky et al teaches a graphical programming environment wherein a user places or manipulates icons and interconnects or wires up the icons in a block diagram using a block diagram editor to create a graphical program. A graphical program for measuring controlling or modeling devices such as instruments processes or industrial automation hardware or for modeling or simulating devices may be referred to as a virtual instrument VI . Thus a user can create a computer program solely by using a graphically based programming environment. This graphically based programming environment may be used for creating virtual instrumentation systems modeling processes control simulation and numerical analysis as well as for any type of general programming.

In creating a graphical program a user may create a front panel or user interface panel. The front panel may include various user interface elements or front panel objects such as controls and or indicators that represent or display the respective input and output that will be used by the graphical program or VI and may include other icons which represent devices being controlled. The front panel may be comprised in a single window of user interface elements or may comprise a plurality of individual windows each having a user interface element wherein the individual windows may optionally be tiled together. When the controls and indicators are created in the front panel corresponding icons or terminals may be automatically created in the block diagram by the block diagram editor. Alternatively the user can place terminal icons in the block diagram which may cause the display of corresponding front panel objects in the front panel either at edit time or later at run time. As another example the front panel objects e.g. the GUI may be embedded in the block diagram.

During creation of the block diagram portion of the graphical program the user may select various function nodes or icons that accomplish his desired result and connect the function nodes together. For example the function nodes may be connected in one or more of a data flow control flow and or execution flow format. The function nodes may also be connected in a signal flow format which is a subset of data flow. The function nodes may be connected between the terminals of the various user interface elements e.g. between the respective controls and indicators. Thus the user may create or assemble a graphical program referred to as a block diagram graphically representing the desired process. The assembled graphical program may be represented in the memory of the computer system as data structures. The assembled graphical program i.e. these data structures may then be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the block diagram.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program or from a file. Also a user may input data to a graphical program or virtual instrument using front panel controls. This input data may propagate through the data flow block diagram or graphical program and appear as changes on the output indicators. In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators. Alternatively the front panel may be used merely to view the input and output or just the output and the input may not be interactively manipulable by the user during program execution.

Thus graphical programming has become a powerful tool available to programmers. Graphical programming environments such as the National Instruments LabVIEW product have become very popular. Tools such as LabVIEW have greatly increased the productivity of programmers and increasing numbers of programmers are using graphical programming environments to develop their software applications. In particular graphical programming tools are being used for test and measurement data acquisition process control man machine interface MMI supervisory control and data acquisition SCADA applications simulation machine vision applications and motion control among others.

As graphical programming environments have matured and grown in popularity and complexity it has become increasingly desirable to provide high level tools which help a user create a graphical program. Recently some products allow users to automatically generate a graphical program in response to user input specifying functionality of the graphical program. However this automatic generation of graphical programs is limited to one model of computation e.g. data flow graphical programming. In many instances a program may be more intelligently represented by a plurality of models of computation. Thus automatic generation of graphical programs or portions thereof which include a plurality of computational models is desirable.

One embodiment of the present invention comprises a system and method for automatically generating a graphical program or a portion of a graphical program which is specified in a plurality of computational models. The graphical program may be automatically generated in response to user input. The plurality of computational models are presented to the user on a display and are used to provide a more intuitive representation of the program.

The user input may specify functionality of the graphical program or graphical program portion to be generated. The user input may comprise any type of information that specifies functionality of or aspects of the graphical program desired to be created. Additionally the user input may specify different functionality for different portions of the graphical program that is to be automatically generated. For example the user may specify first functionality for a first portion of the graphical program e.g. corresponding to a first computational model and second functionality for a second portion of the graphical program e.g. corresponding to a second computational model . The method may display a first GUI for specifying functionality for the first portion and a second GUI for specifying functionality of the second portion.

A graphical program generation program referred to herein as a GPG program may be executed wherein the GPG program may be operable to receive the user input. In other words the GPG program for example may include a plurality of GUIs for specifying portions of the graphical program e.g. corresponding to various computational models. Alternatively the GPG program may allow the user to select a single computational model and specify functionality for that computational model.

In response to the user input the method e.g. the GPG program may automatically generate a graphical program or graphical program portion that implements the specified functionality. Additionally the generated graphical program may include may be specified in a plurality of computational models e.g. two or more of graphical data flow synchronous data flow state diagram control flow diagram text based code execution flow and or simulation diagram among others. The GPG program may automatically determine which computational models to use e.g. by analyzing the user input or may use computational models specified by the user. Thus the GPG program may generate different graphical programs with different computational models depending on the user input received. Alternatively or additionally the GPG program may generate a graphical program with a specified computational model or with two or more specified computational models.

Note that the graphical program e.g. with a plurality of computational models may be limited to a single window or a single document e.g. within for example a graphical programming development environment such as LabVIEW . The computational models may therefore be restricted to within a single graphical program. Thus the plurality of computational models of the graphical program may be displayed within a single window or document after automatic generation.

In automatically generating a graphical program the method e.g. the GPG program may automatically generate a block diagram portion comprising a plurality of connected icons or nodes wherein the connected icons or nodes may visually or graphically indicate the functionality of the graphical program. In the present application the term automatically generating comprises automatically generating the graphical program without user input specifying the nodes or connections between the nodes. Thus the user is not required to select and place nodes in the diagram or draw connections lines or wires between the nodes. Thus the automatic generation is contrasted with manual creation of a graphical program which requires that the user manually select nodes and establish connections between the nodes to create the graphical program.

The GPG program may generate underlying non visible graphical code which implements the plurality of computational models that are displayed to the user. Thus in some embodiments the plurality of computational models are displayed to provide an intuitive and natural representation of the program to the user while the automatically generated graphical program having the plurality of visible computational models may be actually specified in a single underlying non visible graphical programming language. As one example the method may automatically generate a LabVIEW graphical program having a first portion of graphical code according to a first model of computation data flow where the LabVIEW graphical program has a simulation window structure containing a second portion of graphical code represented in a second different model of computation e.g. continuous time simulation data flow wherein the second portion of graphical code is actually specified under the hood invisibly to the user with the first model of computation. As another example the method may automatically generate a LabVIEW graphical program having graphical code according to a first model of computation data flow where the LabVIEW graphical program has a window structure containing text based code e.g. MathScript or MATLAB code . The text based code may be implemented in or converted to graphical code invisibly or visibly to the user.

The GPG program may also automatically generate a user interface panel or front panel which may be used to provide input to and or display output from the graphical program. In automatically generating a user interface panel the method may automatically create various input controls and output indicators that correspond to inputs outputs to from the diagram e.g. including controls and indicators that correspond to parameters of blocks in the automatically generated graphical program.

The GPG program that generates the graphical program may be constructed using any of various programming languages methodologies or techniques. For example the GPG program may itself be a graphical program or the GPG program may be a text based program or the GPG program may be constructed using a combination of graphical and text based programming environments.

Also the GPG program may have any of various purposes or applications. In one embodiment the GPG program may include or be associated with a program or application that directly aids the user in creating a graphical program. For example the GPG program may be included in a graphical programming development environment application. In this case the graphical programming development environment application may be operable to receive user input specifying desired functionality and the GPG program may automatically i.e. automatically add a portion of graphical program code implementing the specified functionality to the user s program. The user input may be received for example via one or more wizard graphical user interface GUI input panels or dialogs enabling the user to specify various options. Such graphical program code generation wizards may greatly simplify the user s task of implementing various operations. As an example it is often difficult for developers of instrumentation applications to properly implement code to analyze an acquired signal due to the inherent complexity involved. By enabling the developer to easily specify the desired functionality through a high level user interface the GPG program can receive this information and automatically create graphical code to implement the signal analysis. Furthermore since the graphical code is generated automatically the code may be optimized resulting in an efficient program and a readable block diagram without unnecessary code.

In various embodiments an association between a generated graphical program and the received user input used in generating the graphical program may be maintained. For example this association may enable the user to return from the automatically generated graphical program or portion to the GUI input panel s originally used to specify the user input e.g. in order to modify the automatically generated graphical program or portion . In one embodiment a generated graphical program may be locked requiring the user to explicitly unlock the graphical program before the graphical program can be modified.

In various embodiments the GPG program may be operable to generate any of various types of graphical programs. For example as discussed above a generated graphical program may be targeted toward a particular graphical programming development environment application. The GPG program may thus utilize proprietary features or create files that are formatted in a manner expected by the graphical programming development environment. This may be desirable or necessary when the graphical programming development environment includes a runtime environment that is required for the created graphical program to execute. Examples of graphical programming development environments include LabVIEW BridgeVIEW DasyLab and DiaDem from National Instruments VEE from Hewlett Packard Simulink from The MathWorks Softwire from Measurement Computing Inc. Sanscript from Northwoods Software WiT from Coreco and Vision Program Manager from PPT Vision among others.

In various embodiments the graphical program may be automatically generated using any of various methods or techniques. Generating the graphical program may include generating one or more files or data structures defining the graphical program. When a user interactively develops a graphical program from within a graphical programming environment the graphical programming environment may create one or more program files. For example the program files may specify information such as a set of nodes contained in the graphical program interconnections among these nodes structures such as looping and conditional branching models of computation etc. In other cases the program files may store various data structures e.g. in binary form which the graphical programming environment uses to directly represent the graphical program. Thus in automatically generating the graphical program the GPG program may automatically generate one or more files or data structures representing the graphical program wherein these files may be structured or formatted appropriately for a particular graphical programming environment. Additionally the GPG program may automatically generate different portions of the graphical program which correspond to each of the computational models included in the graphical program. Thus the generated graphical program may include a plurality of portions each corresponding to a plurality of computational models.

In one embodiment a graphical programming development environment may provide an application programming interface API which the GPG program can use to automatically generate the graphical program. For example for each node user interface element or other object of the graphical program the API may be called to automatically add the object to the graphical program connect the object to other objects of the graphical program etc. Thus any necessary files or other constructs needed by the graphical programming environment in order to use the generated graphical program may be automatically created as a result of calling the API.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternative following within the spirit and scope of the present invention as defined by the appended claims.

The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein.

U.S. Pat. No. 5 481 741 titled Method and Apparatus for Providing Attribute Nodes in a Graphical Data Flow Environment issued on Jan. 2 1996.

U.S. Pat. No. 6 064 812 titled System and Method for Developing Automation Clients Using a Graphical Data Flow Program issued on May 16 2000.

U.S. Pat. No. 6 102 965 titled System and Method for Providing Client Server Access to Graphical Programs issued on Aug. 15 2000.

U.S. Pat. No. 6 437 805 titled System and Method for Accessing Object Capabilities in a Graphical Program filed Aug. 18 1998.

U.S. patent application Ser. No. 10 869 656 published as U.S. Publication No. 20050257195 titled Creating and executing a graphical program with first model of computation that includes a structure supporting second model of computation whose inventors were Gregory O. Morrow John C. Limroth Jeffrey L. Kodosky Steven W. Rogers Kevin Hogan and Hugo A. Andrade 

Ser. No. 09 595 003 titled System and Method for Automatically Generating a Graphical Program to Implement a Prototype filed Jun. 13 2000.

U.S. patent application Ser. No. 09 745 023 published as U.S. Publication No. 2001 0020291 titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information filed Dec. 20 2000.

U.S. Pat. No. 6 173 438 titled Embedded Graphical Programming System filed on Aug. 18 1997 whose inventors were Jeffrey L. Kodosky Darshan Shah Samson DeKey and Steve Rogers.

U.S. Pat. No. 6 219 628 titled System and Method for Converting Graphical Programs Into Hardware Implementations filed on Aug. 18 1997 whose inventors were Jeffrey L. Kodosky Hugo Andrade Brian Keith Odom and Cary Paul Butler.

U.S. Pat. No. 7 120 876 titled System and Method for Programmatically Generating a Graphical Program in Response to User Input filed Jun. 20 2001 whose inventors were Jeffrey D. Washington Ram Kudukoli Robert E. Dye and Paul F. Austin.

Memory Medium Any of various types of memory devices or storage devices. The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM DDR RAM SRAM EDO RAM Rambus RAM etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory medium may comprise other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide program instructions to the first computer for execution. The term memory medium may include two or more memory mediums which may reside in different locations e.g. in different computers that are connected over a network.

Carrier Medium a memory medium as described above as well as a physical transmission medium such as a bus network and or other physical transmission medium that conveys signals such as electrical electromagnetic or digital signals.

Programmable Hardware Element includes various hardware devices consisting of multiple programmable function blocks connected via a programmable interconnect. Examples include FPGAs Field Programmable Gate Arrays PLDs Programmable Logic Devices FPOAs Field Programmable Object Arrays and CPLDs Complex PLDs . The programmable function blocks may range from fine grained combinatorial logic or look up tables to coarse grained arithmetic logic units or processor cores . A programmable hardware element may also be referred to as reconfigurable logic .

Medium includes one or more of a memory medium and or a programmable hardware element encompasses various types of mediums that can either store program instructions data structures or can be configured with a hardware configuration program. For example a medium that is configured to perform a function or implement a software object may be 1 a memory medium or carrier medium that stores program instructions such that the program instructions are executable by a processor to perform the function or implement the software object 2 a medium carrying signals that are involved with performing the function or implementing the software object and or 3 a programmable hardware element configured with a hardware configuration program to perform the function or implement the software object.

Program the term program is intended to have the full breadth of its ordinary meaning. The term program includes 1 a software program which may be stored in a memory and is executable by a processor or 2 a hardware configuration program useable for configuring a programmable hardware element.

Software Program the term software program is intended to have the full breadth of its ordinary meaning and includes any type of program instructions code script and or data or combinations thereof that may be stored in a memory medium and executed by a processor. Exemplary software programs include programs written in text based programming languages such as C C Pascal Fortran Cobol Java assembly language etc. graphical programs programs written in graphical programming languages assembly language programs programs that have been compiled to machine language scripts and other types of executable software. A software program may comprise two or more software programs that interoperate in some manner.

Hardware Configuration Program a program e.g. a netlist or bit file that can be used to program or configure a programmable hardware element.

Graphical Program A program comprising a plurality of interconnected blocks or icons icons connected by lines or wires wherein the plurality of interconnected blocks or icons visually indicate functionality of the program.

The following provides examples of various aspects of graphical programs. The following examples and discussion are not intended to limit the above definition of graphical program but rather provide examples of what the term graphical program encompasses 

The blocks in a graphical program may be connected in one or more of a data flow control flow and or execution flow format. The blocks may also be connected in a signal flow format which is a subset of data flow.

Exemplary graphical program development environments which may be used to create graphical programs include LabVIEW DasyLab DiaDem and Matrixx SystemBuild from National Instruments Simulink from the MathWorks VEE from Agilent WiT from Coreco Vision Program Manager from PPT Vision SoftWIRE from Measurement Computing Sanscript from Northwoods Software Khoros from Khoral Research SnapMaster from HEM Data VisSim from Visual Solutions ObjectBench by SES Scientific and Engineering Software and VisiDAQ from Advantech among others.

The term graphical program includes models or block diagrams created in graphical modeling environments wherein the model or block diagram comprises interconnected blocks or icons that visually indicate operation of the model or block diagram exemplary graphical modeling environments include Simulink SystemBuild VisSim Hypersignal Block Diagram etc. The term graphical program is intended to include a program where at least a portion of the program is a graphical program while other portions may have various other models of computation.

A graphical program may be displayed to the user as a plurality of interconnected nodes nodes connected by lines . Alternatively a graphical program may be not displayed i.e. may not be visible to the user. Thus the term graphical program includes a program having a syntax that is stored as a graph nodes and edges rather than stored as a tree in the memory of the computer system wherein the stored graph could optionally be but is not necessarily displayed as a plurality of nodes or icons connected by lines. A graphical program e.g. these data structures and or program instructions may be compiled or interpreted or converted to another form such as C and then compiled to produce machine language that accomplishes the desired method or process as shown in or represented by the graphical program.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program a database or from a file. Also a user may input data to a graphical program or virtual instrument using a graphical user interface e.g. a front panel.

A graphical program may optionally have a GUI associated with the graphical program. In this case the plurality of interconnected blocks are often referred to as the block diagram portion of the graphical program.

Block In the context of a graphical program an element that may be included in a graphical program. A block may have an associated icon that represents the block in the graphical program as well as underlying code or data that implements functionality of the block. Exemplary blocks include function blocks sub program blocks terminal blocks structure blocks etc. Blocks may be connected together in a graphical program by connection icons or wires.

The blocks in a graphical program may also be referred to as graphical program nodes or simply nodes not to be confused with the nodes that connect components in a circuit diagram .

Graphical Data Flow Program or Graphical Data Flow Diagram A graphical program or diagram comprising a plurality of interconnected blocks wherein at least a subset of the connections among the blocks visually indicate that data produced by one block is used by another block. A LabVIEW VI is one example of a graphical data flow program.

Graphical User Interface this term is intended to have the full breadth of its ordinary meaning. The term Graphical User Interface is often abbreviated to GUI . A GUI may comprise only one or more input GUI elements only one or more output GUI elements or both input and output GUI elements.

The following provides examples of various aspects of GUIs. The following examples and discussion are not intended to limit the ordinary meaning of GUI but rather provide examples of what the term graphical user interface encompasses 

A GUI may comprise a single window having one or more GUI Elements or may comprise a plurality of individual GUI Elements or individual windows each having one or more GUI Elements wherein the individual GUI Elements or windows may optionally be tiled together.

A GUI may be associated with a graphical program. In this instance various mechanisms may be used to connect GUI Elements in the GUI with nodes in the graphical program. For example when Input Controls and Output Indicators are created in the GUI corresponding nodes e.g. terminals may be automatically created in the graphical program or block diagram. Alternatively the user can place terminal nodes in the block diagram which may cause the display of corresponding GUI Elements front panel objects in the GUI either at edit time or later at run time. As another example the GUI may comprise GUI Elements embedded in the block diagram portion of the graphical program.

Front Panel A Graphical User Interface that includes input controls and output indicators and which enables a user to interactively control or manipulate the input being provided to a program and view output of the program while the program is executing.

A front panel is a type of GUI. A front panel may be associated with a graphical program as described above.

In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators.

Graphical User Interface Element an element of a graphical user interface such as for providing input or displaying output. Exemplary graphical user interface elements comprise input controls and output indicators.

Input Control a graphical user interface element for providing user input to a program. An input control displays the value input the by the user and is capable of being manipulated at the discretion of the user. Exemplary input controls comprise dials knobs sliders input text boxes etc.

Output Indicator a graphical user interface element for displaying output from a program. Exemplary output indicators include charts graphs gauges output text boxes numeric displays etc. An output indicator is sometimes referred to as an output control .

Computer System any of various types of computing or processing systems including a personal computer system PC mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system grid computing system or other device or combinations of devices. In general the term computer system can be broadly defined to encompass any device or combination of devices having at least one processor that executes instructions from a memory medium.

Measurement Device includes instruments data acquisition devices smart sensors and any of various types of devices that are operable to acquire and or store data. A measurement device may also optionally be further operable to analyze or process the acquired or stored data. Examples of a measurement device include an instrument such as a traditional stand alone box instrument a computer based instrument instrument on a card or external instrument a data acquisition card a device external to a computer that operates similarly to a data acquisition card a smart sensor one or more DAQ or measurement cards or modules in a chassis an image acquisition device such as an image acquisition or machine vision card also called a video capture board or smart camera a motion control device a robot having machine vision and other similar types of devices. Exemplary stand alone instruments include oscilloscopes multimeters signal analyzers arbitrary waveform generators spectroscopes and similar measurement test or automation instruments.

A measurement device may be further operable to perform control functions e.g. in response to analysis of the acquired or stored data. For example the measurement device may send a control signal to an external system such as a motion control system or to a sensor in response to particular data. A measurement device may also be operable to perform automation functions i.e. may receive and analyze data and issue automation control signals in response.

Model of Computation or Computational Model a model for visually specifying or visually representing program code to a user. A model of computation may also be considered as a set of program semantics of a programming language. Examples of models of computation include various forms of graphical data flow such as data driven data flow e.g. LabVIEW demand driven data flow synchronous data flow state diagram control flow diagram simulation diagram models continuous time simulation data flow and or various forms of text based code such as Matlab and MathScript C C etc. among others. A program portion may be visually represented on a display in a first computational model but may in fact be actually implemented in the computer using a different computational model that may be hidden from the user. For example Matlab is a text based scripting language that is implanted in the C programming language. As another example MathScript is a text based scripting language implemented in the LabVIEW graphical programming language. A program portion may be represented in a first model of computation to provide a more intuitive visual representation of the functionality of the program portion e.g. to allow the user to more readily understand and or edit the program portion.

The computer system may include or store a computer program referred to herein as a graphical program generation program or a GPG program that is operable to receive program information and automatically generate a graphical program e.g. with a plurality of models of computation based on the program information. One embodiment of a method for automatically generating a graphical program is described below.

In one embodiment the GPG program may be implemented as a self contained program or application that includes all necessary program logic for generating the graphical program. In another embodiment the GPG program may comprise a client portion and a server portion or client program and server program wherein the client portion may request or direct the server portion to generate the graphical program. For example the client portion may utilize an application programming interface API provided by the server portion in order to generate the graphical program. In other words the client portion may perform calls to the API provided by the server portion and the server portion may execute functions or routines bound to these calls to generate the graphical program. In one embodiment the server portion may be an instance of a graphical programming development environment application. For example the LabVIEW graphical programming development environment provided by National Instruments application enables client programs to interface with a LabVIEW server in order to automatically generate or modify graphical programs.

As used herein the term GPG program is intended to include any of various implementations of a program or programs that are executable to automatically generate a graphical program based on received program information. For example the term GPG program is intended to include an embodiment in which the GPG program is a self contained program or application not implemented as a client server program that includes all necessary program logic for automatically generating a graphical program. The term GPG program is also intended to include an embodiment in which a combination of a client portion or client program and server portion or server program operate together to automatically generate the graphical program. The term GPG program is also intended to include other program implementations.

In an embodiment in which a client program interfaces with a server program to generate the graphical program the server program may execute on the same computer system as the client program or may execute on a different computer system e.g. a different computer system connected via a network. For example in the client program may execute on the computer system and the server program may execute on the computer system . In this case the graphical program e.g. files representing the graphical program may be created on the computer system or or on a different computer system.

It is noted that the GPG program may be implemented using any of various programming technologies or methodologies. Where the GPG program is implemented as client and server programs each of these programs may utilize procedure based techniques component based techniques and or object oriented techniques among others. The programs may be written using any combination of text based or graphical programming languages. Also the programs may be written using distributed modules or components so that each program may reside on any combination of computer system computer system and other computer systems connected to the network . Also in various embodiments the client program may interface with the server program through a proxy software component or program.

The one or more instruments may include one or more of a GPIB instrument and associated GPIB interface card a data acquisition board and associated signal conditioning circuitry a VXI instrument a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card and or one or more computer based instrument cards among other types of devices.

The GPIB instrument may be coupled to the computer via the GPIB interface card comprised in the computer . In a similar manner the video device may be coupled to the computer via the image acquisition card and the motion control device may be coupled to the computer through the motion control interface card . The data acquisition board may be coupled to the computer and may interface through signal conditioning circuitry to the UUT. The signal conditioning circuitry preferably comprises an SCXI Signal Conditioning eXtensions for Instrumentation chassis comprising one or more SCXI modules .

The GPIB card the image acquisition card the motion control interface card and the DAQ card are typically plugged in to an I O slot in the computer such as a PCI bus slot a PC Card slot or an ISA EISA or MicroChannel bus slot provided by the computer . However these cards and are shown external to computer for illustrative purposes.

The VXI chassis or instrument may be coupled to the computer via a VXI bus MXI e.g. MXI 3 bus or other serial or parallel bus provided by the computer . The computer preferably includes VXI interface logic such as a VXI MXI or GPIB interface card not shown which interfaces to the VXI chassis . The PXI chassis or instrument is preferably coupled to the computer through the computer s PCI bus.

A serial instrument not shown may also be coupled to the computer through a serial port such as an RS 232 port USB Universal Serial bus or IEEE 1394 or 1394.2 bus provided by the computer .

In typical instrumentation control systems an instrument will not be present of each interface type and in fact many systems may only have one or more instruments of a single interface type such as only GPIB instruments. The one or more instruments are coupled to the unit under test UUT or process or are coupled to receive field signals typically generated by transducers. The system may be used in a data acquisition and control application in a test and measurement application a process control application a man machine interface application or other types of applications.

The one or more devices may include a data acquisition board and associated signal conditioning circuitry a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card a fieldbus device and associated fieldbus interface card a PLC Programmable Logic Controller a serial instrument and associated serial interface card or a distributed data acquisition system such as the Fieldpoint system available from National Instruments among other types of devices.

The DAQ card the PXI chassis the video device and the image acquisition card are preferably connected to the computer as described above. The serial instrument is coupled to the computer through a serial interface card or through a serial port such as an RS 232 port USB or IEEE 1394 or 1394.2 provided by the computer . The PLC couples to the computer through a serial port Ethernet port or a proprietary interface. The fieldbus interface card is preferably comprised in the computer and interfaces through a fieldbus network to one or more fieldbus devices. Each of the DAQ card the serial card the fieldbus card the image acquisition card and the motion control card are typically plugged in to an I O slot in the computer as described above. However these cards and are shown external to computer for illustrative purposes. In typical industrial automation systems a device will not be present of each interface type and in fact many systems may only have one or more devices of a single interface type such as only PLCs. The devices are coupled to the device or process .

Referring again to the computer system s preferably includes a memory medium s on which one or more computer programs or software components according to one embodiment of the present invention are stored. For example the memory medium may store a GPG program which is executable to receive program information and automatically generate a graphical program based on the information. The same or a different memory medium may also store a server program with which a client portion of the GPG program interfaces in order to generate the graphical program. The memory medium may also store an automatically generated graphical program. The memory medium may also store a graphical programming development environment application operable execute or edit the automatically generated graphical program. It is noted that various of these software programs may be stored on different computer systems as described above with reference to . Also in various embodiments various of the above software programs may be implemented or combined in different ways. For example a graphical programming development environment application may implement the server program with which a client program interfaces to automatically generate a graphical program.

In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide the program instructions to the first computer for execution. Also the computer system may take various forms including a personal computer system mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system or other device. In general the term computer system can be broadly defined to encompass any device having at least one processor which executes instructions from a memory medium.

In one embodiment the GPG program and or the resulting graphical program that is automatically generated may be designed for data acquisition generation analysis and or display and for controlling or modeling instrumentation or industrial automation hardware. For example in one embodiment the National Instruments LabVIEW graphical programming development environment application which provides specialized support for developers of instrumentation applications may act as the server program. In this embodiment the client program may be a software program that receives and processes program information and invokes functionality of the LabVIEW graphical programming development environment. The client program may also be a program involved with instrumentation or data acquisition.

However it is noted that the present invention can be used for a plethora of applications and is not limited to instrumentation or industrial automation applications. In other words are exemplary only and graphical programs for any of various types of purposes may be generated by a GPG program designed for any of various types of purposes wherein the programs are stored in and execute on any of various types of systems. Various examples of GPG programs and generated graphical programs are discussed below.

The computer includes at least one central processing unit or CPU which is coupled to a processor or host bus . The CPU may be any of various types including an x86 processor e.g. a Pentium class a PowerPC processor a CPU from the SPARC family of RISC processors as well as others. Main memory is coupled to the host bus by means of memory controller .

The main memory may store computer programs according to one embodiment of the present invention such as described above with reference to . The main memory may also store operating system software as well as other software for operation of the computer system as well known to those skilled in the art. Computer programs stored in the main memory may implement one or more of the methods described below.

The host bus is coupled to an expansion or input output bus by means of a bus controller or bus bridge logic. The expansion bus is preferably the PCI Peripheral Component Interconnect expansion bus although other bus types can be used. The expansion bus includes slots for various devices such as the data acquisition board of and a GPIB interface card which provides a GPIB bus interface to the GPIB instrument of . The computer further comprises a video display subsystem and hard drive coupled to the expansion bus .

As shown a reconfigurable instrument may also be connected to the computer . The reconfigurable instrument may include configurable logic such as a programmable logic device PLD e.g. an FPGA or a processor and memory which may execute a real time operating system. According to one embodiment of the invention an automatically generated graphical program may be downloaded and executed on the reconfigurable instrument . For example a graphical programming development environment with which the graphical program is associated may provide support for downloading a graphical program for execution on configurable logic in a real time system. In various embodiments the configurable logic may be comprised on an instrument or device connected to the computer through means other than an expansion slot e.g. the instrument or device may be connected via an IEEE 1394 bus USB or other type of port. Also the configurable logic may be comprised on a device such as the data acquisition board or another device shown in .

In prior systems a user interactively or manually creates or edits a graphical program. For example the user may interactively add various objects or icons to a graphical program block diagram connect the objects together etc. In contrast one embodiment of the present invention comprises a system and method for automatically generating a graphical program or portion of a graphical program without requiring this type of user interaction. As indicated above the automatically generated graphical program may include a plurality of computational models and or may include a specified computational model.

In a graphical program generation GPG program may be created wherein the GPG program is operable to automatically generate a plurality of graphical programs e.g. with a plurality of computational models based on received information. As described below the GPG program may be associated with any of various purposes or applications. Also as discussed above the GPG program may be implemented in various ways e.g. using graphical and or text based programming environments. For example the GPG program may be a text based program such as a program written using C C Java Basic Visual Basic FORTRAN Pascal or another text based programming language. Also the GPG program may itself be a graphical program. For example the GPG program may be a graphical program interactively created in response to user input. In some embodiments a GPG program may refer to any type of program that produces as a part of its execution a graphical program or portion thereof. For example the GPG program could be a compiler interpreter and or translator among others .

As described below the GPG program may be implemented based on a client server programming model. The client portion may call an application programming interface API provided by the server portion usable for automatically creating the new graphical program. For example a text based GPG program may include text based code for calling various API functions or methods while a graphical GPG program may include various graphical nodes which are operable to invoke functions of the API. The creation of the GPG program may be performed by a developer wherein the GPG program may then be used as a tool for the automatic creation of graphical programs by users or other developers. As noted above the GPG program may be used to automatically generate a graphical program with a plurality of computational models and or automatically create a graphical program with a specified computational model.

In program information for the new graphical program or graphical program portion to be generated may be specified. In some embodiments the program information for the new graphical program may be received from a user and or in response to user input. For example the user may specify functionality of the graphical program by entering information into a graphical user interface GUI e.g. of the GPG program. In some embodiments the user may simply enter specifications for the graphical program to be generated in a single user input to a GUI or via a series of GUIs or windows thereof e.g. in a wizard. Alternatively or additionally the user may specify functionality for various portions of the graphical program e.g. using a different GUI for each portion. In one embodiment each of the portions may correspond to a different computational model. Thus in one embodiment the user may specify functionality for respective ones of a plurality of computational models. In other words user input specifying functionality of the graphical program may include receiving a plurality of user inputs e.g. to different GUIs each specifying desired functionality of respective portions of the graphical program.

For example in one embodiment first user input may be received specifying first desired functionality of a first portion of the graphical program and second user input may be received specifying second desired functionality of a second portion of the graphical program. In this example the first portion may correspond to a first computational model and the second portion may correspond to a second computational model. The computational models may include graphical data flow synchronous data flow state diagram control flow diagram execution flow text based code and or simulation diagram among others. In various embodiments the user may explicitly specify computational models for the graphical program e.g. corresponding to portions of the graphical program or may only specify functionality of the graphical program and allow the GPG to analyze and or determine e.g. automatically appropriate computational models as desired.

In some embodiments the user may choose one or more template graphical programs or portions of graphical programs and specify functionality of the graphical program or portion thereof for the one or more templates. In other words the user may choose a template graphical program and provide details regarding the template for automatic creation of the desired graphical program. Thus the specified program information may comprise any of various types of information and may specify functionality of the new graphical program.

In step the GPG program may be executed. The GPG program may be executed in any type of computer system such as those described above among others.

In step the GPG program may receive the program information specifying the functionality for the graphical program or graphical program portion. As described below the GPG program may receive any type of information from any type of source.

In step the GPG program may automatically generate a graphical program or graphical program portion to implement the functionality specified by the received information. As indicated above the automatically generated program may include a plurality of computational models e.g. graphical data flow synchronous data flow state diagram execution flow control flow diagram text based code and or simulation diagram computational models among others. In other words in response to receiving the information in the GPG program may automatically generate a new graphical program or program portion a plurality of computational models based on the information e.g. received from the user. In particular the automatically generated graphical program may include a first portion e.g. a data flow portion which includes a plurality of interconnected nodes which visually indicate functionality of the first portion of the graphical program.

Note that the graphical program e.g. with a plurality of computational models may be limited to a single window or a single document e.g. within for example a graphical programming development environment such as LabVIEW . The computational models may therefore be restricted to within a single graphical program. Thus the plurality of computational models of the graphical program may be displayed within a single window or document after automatic generation.

Thus the term graphical program is intended to include a program where at least a portion of the program is a graphical program while other portions may have various other models of computation such as text based code etc. For example in one embodiment one of the computational models may include graphical programming computational models described above e.g. including graphical data flow execution flow etc. while other portions of the program are represented in other non graphical program computational models.

In alternate embodiments the high level program can be represented as a graphical program but one or more of or all of the nodes in the graphical program may represent sub programs that are specified in non graphical program computational models may not include graphical programming computational models. For example the graphical program may comprise 2 nodes connected by one wire where each of the 2 nodes references different text based computational models. In these cases the two computational models may be represented as nodes in the generated graphical program which are interconnected by at least one wire that indicates a dependency invocation or other connection between the two portions of the graphical program. Thus the graphical program may provide a framework to interconnect two different computational models when the plurality of computational models does not include a graphical program computational model.

In the present application the term automatically generating comprises automatically generating the graphical program without user input specifying the nodes or connections between the nodes. Thus the user is not required to select and place nodes in the diagram or draw connections lines or wires between the nodes. Thus the automatic generation is contrasted with manual creation of a graphical program which requires that the user manually select nodes and establish connections between the nodes to create the graphical program.

Following the descriptions above the graphical program may be automatically generated with little or no user input received during this creating. In one embodiment the graphical program is automatically generated with no user input required. In another embodiment the user may be prompted for certain decisions during automatic generation such as the type of graphical program the look and feel of a user interface for the graphical program the number or degree of comments contained within the graphical program the types of computational models to be used specific implementations of program portions in various ones of the computational models confirmation of the computational models being used etc.

In automatically generating the graphical program the GPG program may process the information received in in order to determine how to generate the graphical program. For example the GPG program may process the information in order to determine the plurality of computational models to include in the graphical program and possibly portions of the graphical program associated therewith appropriate underlying graphical code for the program an appropriate user interface for the program etc. Thus the GPG program may analyze and or determine which computational models should be included in the desired graphical program using the provided information received in . As indicated above the computational models may be defined explicitly by the received program information and or implicitly by the specified functionality among other methods . As described below the determination of how to generate the graphical program may depend on a combination of the received information and or the program logic of the GPG program i.e. what the GPG program is operable to do with the received information .

In automatically generating the determined graphical program the GPG program may specify the inclusion of various objects in the new graphical program. For example the new graphical program may have a diagram portion including a plurality of interconnected nodes which visually indicate functionality of the new graphical program e.g. in a first portion of the graphical program possibly corresponding to a first computational model e.g. data flow . However as indicated above the new graphical program may include or be specified in other computational models such as those enumerated above among others. For example the GPG program may automatically include text based code e.g. in one of the plurality of computational models of the graphical program. More specifically in automatically generating the graphical program the GPG program may include or select a program or script in text based code that implements at least a portion of the desired functionality. Alternatively or additionally the text based code may be automatically generated from a template or de novo. Said another way the GPG program may automatically generate a portion of the graphical program by generating or including text based code via a variety of methods e.g. generation and or selection among others. Note that a graphical program that includes text based code e.g. in a window or node of the graphical program may still be referred to as a graphical program. In some embodiments the text based code may be specified in one of the plurality of computational models of the graphical program.

The new graphical program may also have a user interface portion including various user interface objects such as one or more user interface panels having controls for specifying user input to the graphical program and or indicators for displaying output from the graphical program. The GPG program may also specify other aspects of the graphical program such as interconnections between diagram objects connections between diagram objects and user interface objects positions of objects sizes of objects input output terminals or terminal names for diagram objects comments for diagram objects and properties or configuration of objects e.g. configuration of data types parameters etc. among other aspects of the graphical program.

In various embodiments the GPG program may generate a graphical program of any of various types and or with various computational models. In some embodiments the GPG program may generate the graphical program specifically so that a particular graphical programming development environment is operable to edit and or execute the graphical program. As discussed the automatically generated graphical program may be specified in a plurality of computational models. However the graphical program may include underlying graphical code that represents the graphical program. In other words the underlying graphical code may implement the functionality of the various portions specified in the plurality of computational models.

For example the GPG program may automatically generate underlying non visible graphical code which implements the plurality of computational models that are displayed to the user. Thus in some embodiments the plurality of computational models are displayed to provide an intuitive and natural representation of the program to the user while the automatically generated graphical program having the plurality of visible computational models may be actually specified in a single underlying non visible graphical programming language. As one example the method may automatically generate a LabVIEW graphical program having a first portion of graphical code according to a first model of computation data flow where the LabVIEW graphical program has a simulation window structure containing a second portion of graphical code represented in a second different model of computation e.g. continuous time simulation data flow wherein the second portion of graphical code is actually specified under the hood invisibly to the user with the first model of computation. As another example the method may automatically generate a LabVIEW graphical program having graphical code according to a first model of computation data flow where the LabVIEW graphical program has a window structure containing text based code e.g. MathScript or MATLAB code . The text based code may be implemented in or converted to graphical code invisibly or visibly to the user.

As one example where the graphical program includes text based code or a node for inputting text such as the exemplary graphical programs illustrated in the graphical program may actually include underlying graphical code for the text based code. Thus when the user changes the text based code one of the computational models in the graphical program the graphical programming environment and or the GPG program may modify the underlying graphical code automatically and in response to the user changes. Thus the plurality of computational models may allow the user to easily modify and visually understand different portions of the graphical program without necessarily seeing the underlying graphical code. This may allow the user to view and edit the graphical program in a more user friendly or intuitive manner. Thus the automatically generated graphical program may be specified in a plurality of computational models that are implemented using underlying graphical code e.g. the LabVIEW graphical programming language referred to as the G language provided by National Instruments Corporation.

The GPG program may also automatically generate a user interface panel or front panel which may be used to provide input to and or display output from the graphical program. In automatically generating a user interface panel the method may automatically create various input controls and output indicators that correspond to inputs outputs to from the diagram e.g. including controls and indicators that correspond to parameters of blocks in the automatically generated graphical program.

In one embodiment the GPG program may be a self contained program that includes all executable logic necessary for automatically generating the new graphical program. However in the preferred embodiment the GPG program utilizes a client server programming model in which the client portion processes the program information and determines the graphical program to be generated based on the program information i.e. determines the function nodes or other objects to be included in the program the interconnections among these nodes objects etc. . The client portion may then call an API provided by the server portion to request the server portion to perform the actual creation of the new graphical program e.g. by creating files and or other data structures representing the new graphical program. The server portion may execute on the same computer system as the client portion or may execute on a different computer system e.g. a different computer system connected by a network. In one embodiment the server portion may be an instance of a graphical programming development environment application which provides an API enabling client programs to automatically create and or edit graphical programs.

The method of is illustrated and is described above in terms of generating a new graphical program. It is noted that a similar method may be used to modify an existing graphical program e.g. in order to add functionality to the program such as functionality specified by user input received by a user interface wizard. In other words instead of specifying creation of a new graphical program the GPG program may specify the modification of an existing graphical program. When executed the GPG program is then operable to automatically modify the existing graphical program. For example the GPG program may include a reference to the existing graphical program and may perform various API calls to modify the graphical program e.g. by adding one or more objects to the graphical program changing connections between graphical program objects changing various properties of graphical program objects etc.

It is noted that represents one embodiment of a method for automatically generating a graphical program and various steps may be added reordered combined omitted modified etc. For example as described above the GPG program may include or may be associated with an application that the user uses to specify the program information. For example such an application may enable the user to specify a state diagram a test executive sequence a prototype etc. on which to base the graphical program. Thus executing the GPG program in step may comprise invoking a routine or program associated with this application e.g. in response to the user selecting a menu option included in the application s user interface. In other embodiments the user may launch the GPG program as an independent application.

In the method may execute the generated graphical program having the plurality of computational models . In one embodiment the generated graphical program may be compiled for execution where different compiler technologies may be used for the various program portions having different computational models. For example in one embodiment different compilers may be used for different computational models. For example a graphical data flow compiler may be used for a data flow computational model portion and a text based compiler may be used for a text based portion of the graphical program e.g. one represented in a text based computational model . More specifically in an automatically generated graphical program that includes C based textual code and a graphical data flow diagram compilation of the graphical program may include compilation of the graphical data flow diagram to machine instructions using the LabVIEW compiling engine and compilation of the C based textual code using a C compiler. Alternatively some of the portions of the graphical program may be compiled and other portions may be interpreted. For example the graphical program may include a state diagram computational portion that may be compiled and a MATLAB script that is interpreted according to various embodiments. Thus the execution of the graphical program may include interpretation of code and execution of compiled machine code. In alternate embodiments all of the code may be interpreted upon execution.

In some embodiments execution of the graphical program with a plurality of computational model may include determination of targets for portions of the graphical program. For example in a computer system with a processor that includes a plurality of cores compilation or execution of the graphical program may include selection of portions of the graphical program to various ones of the cores. As a more specific example a graphical program that includes a data flow section computational model and a sequential computational model e.g. a sequential text based computational model compilation and execution of the graphical program may include selection of various cores for each computational model. If the computer system includes four cores the cores may be split among the computational models according to the respective complexity of the portions of the graphical program. Alternatively or additionally they may be split according to the ability of the computational model to support parallel processing. For example the graphical data flow portion may more easily support multiple cores while the sequential text based portion may more easily operate on a single core. Thus in one embodiment a plurality of cores may be assigned to the graphical data flow portion while only one or a few cores may be used by the text based portion.

Assignment of the cores may be performed automatically e.g. based on an analysis of the graphical program and its portions or in response to user input. For example in one embodiment the user may specify how many cores should be assigned to each portion of the graphical program. Alternatively an analysis of the graphical may be performed for relative complexity of each of the portions or data dependencies of the portions e.g. if there are several portions within a computational model that may execute relatively independently . Thus selection of cores may be performed automatically e.g. after an analysis of the graphical program or portions thereof or manually specified by the user or some combination thereof among others.

Execution and or compilation may include deploying the various portions e.g. corresponding each of the plurality of computational models or the entirety of the graphical program to one or more targets. The targets may include the cores of processors described above or other targets. For example the targets may include various programmable hardware elements such as FPGAs Field Programmable Gate Arrays or various measurement devices or computer systems such as those described above among others . Thus compilation and execution of the graphical program may include deploying various portions of the graphical program to various targets. Note that the above examples are exemplary only and that other targets determinations computational models compilation methods and analyses are envisioned. For example deploying the graphical program to various targets may be performed automatically e.g. based on devices targets compiled to the host computer and or the abilities of the devices targets.

In another embodiment the compilation stage comprises converting the various program portions having the various different computational models into a single computational model e.g. converting the various program portions into a graphical data flow computation model. For more information on this please see U.S. Patent Publication No. 20050257195 incorporated by reference above. Various analyses of the single graphical data flow computation model may be performed to determine execution targets assignment of cores for various portions in the newly generated modified graphical data flow program e.g. similar to the above descriptions.

In some embodiments the GPG program may include or be coupled with a program or application which a user utilizes to construct or characterize a computational process. In response to the specified computational process the GPG program may automatically generate a graphical program to implement the computational process.

For example a state diagram editor may be used to construct a state diagram characterizing a computational process e.g. in response to user input. As shown in the GPG program may then receive state diagram information A and use this state diagram information to automatically generate the graphical program. For example the automatically generated graphical program may implement functionality specified by the state diagram created by the user. In some embodiments the automatically generated graphical program may convert the state diagram to another computational model or may include the state diagram as a computational model in the automatically generated graphical program. Additionally or alternatively the state diagram editor may be one of a plurality of user inputs in specifying the functionality of the desired graphical program. Thus in one embodiment the state diagram editor may be used as a GUI or one step in a wizard in specifying the functionality of the graphical program.

As another example the GPG program may include or be coupled with a program or application which a user utilizes to construct a prototype e.g. in order to characterize an algorithm at a high level. The constructed prototype may be represented as prototype information B. In this case the GPG program may then automatically generate a graphical program that implements the prototype based on the prototype information B. Similar to above the prototype editor may be one or more windows or GUIs in a wizard for specifying functionality of the graphical program. Additionally or alternatively the automatically generated graphical program may include a computational model similar to the prototype or a computational model that includes functionality corresponding to the information entered by the user into the prototype editor. For more information on automatically generating a graphical program to implement a prototype please see U.S. patent application Ser. No. 09 595 003 incorporated by reference above.

As another example the GPG program may include or be coupled with a program or GUI which a user utilizes to construct a test executive sequence e.g. to perform a series of tests on a unit under test. In this case the GPG program may then automatically generate a graphical program operable to perform the series of tests when executed based on test executive sequence information C. Similar to above the test executive sequence program or GUI may be one or more windows or GUIs in the wizard for specifying functionality of the graphical program. Additionally or alternatively the automatically generated graphical program may include a computational model similar to the test executive sequence or a computational model e.g. execution flow that includes functionality corresponding to the information entered by the user to specify the text executive sequence.

In other embodiments the GPG program may be associated with a program or application that directly aids the user in creating a graphical program. For example the GPG program may be associated with a graphical programming development environment application. In this case the GPG program may be operable to receive user input specifying desired functionality indicated as user interface wizard information D in and may automatically i.e. automatically add a portion of graphical source code to the user s graphical program implementing the specified functionality. For example the user interface wizard information D may be received via one or more wizard graphical user interface GUI panels or dialogs enabling the user to specify various options. Such graphical program code generation wizards may greatly simplify the user s task of implementing various operations. As an example it is often difficult for developers of instrumentation applications to properly implement code to analyze an acquired signal due to the inherent complexity involved. By enabling the developer to specify the desired functionality through a high level user interface the developer can quickly and easily request appropriate graphical source code for implementing the signal analysis to be automatically included in the graphical program. Furthermore since the graphical source code is generated automatically the code may be optimized resulting in an efficient program and a readable block diagram without unnecessary code. Additionally various ones of the methods for entering the program instructions may be included as individual windows or portions of the wizard for specifying functionality of the graphical program.

In other embodiments the GPG program may be operable to automatically translate an existing program into a graphical program. The GPG program may examine the existing program and automatically generate a graphical program. In one embodiment the GPG program may include or interface with different front end plug in modules wherein each plug in module is operable to analyze a particular type of program e.g. a program written in a particular language or used by a particular development environment and generate existing program information E usable by the GPG program for creating a graphical program that implements functionality of the existing program. The automatically generated graphical program may perform the same or substantially the same functionally as or a subset of the functionality of the existing program. Additionally as indicated above the automatically generated graphical program may include a plurality of computational models such as those described above among others.

In one embodiment the existing program may be a text based program such as a C program. In another embodiment the existing program may itself be a graphical program. For example although graphical programs created using different graphical programming development environments are similar in some respects the graphical programs typically cannot be easily transferred across different graphical programming environments for editing or execution. For example different graphical programming development environments provide different nodes for inclusion in a block diagram store program files in different formats etc. Thus if an existing graphical program associated with one programming environment is desired to be ported to a new programming environment the GPG program may examine the existing graphical program or may examine abstract information specifying the existing graphical program and may automatically generate a new graphical program associated with the new programming environment.

In another embodiment the GPG program may be operable to automatically generate a graphical program in response to algorithm information F.

In addition to the examples given above a GPG program may receive any other type of information and automatically generate a graphical program with a plurality of computational models based on the received information.

It is noted that in various embodiments the GPG program may receive the information used in generating the graphical program in any of various ways. The information may be received from the user from another program or from other sources such as a file or database. The information may comprise information of any type including text or binary information structured in any of various ways. The information may be self describing and or the GPG program may include knowledge of how to interpret the information in order to generate the appropriate graphical program.

As an example consider a state diagram editor application usable for constructing a state diagram. In this example the GPG program may be or may be included in the state diagram editor application itself. For example the state diagram editor application may receive user input specifying state diagram information. The state diagram editor application may then automatically generate a graphical program to implement functionality specified by the state diagram information e.g. in response to the user selecting a menu option to generate the graphical program. In some cases the automatically generated program including a plurality of computational models may include the specified state diagram or one corresponding to the specified state diagram as one of the computational models. In other embodiments the GPG program may be separate from the state diagram editor application. For example when the user selects the menu option to generate the graphical program the state diagram editor application may provide the state diagram information to another application i.e. the GPG program which then generates the graphical program based on this information. In another embodiment a user may invoke the GPG program separately and request the GPG program to generate a graphical program e.g. by specifying a state diagram file. The GPG program may receive the state diagram information in any of various ways formats e.g. as binary data XML data etc.

In most of the examples given above functionality of the graphical program to be generated is specified explicitly by the received information. For example a state diagram user input specified via a wizard interface a prototype a test executive sequence and an existing program all explicitly specify to varying degrees functionality which the graphical program should implement.

It is noted that in other embodiments the received information by itself may not explicitly or inherently specify functionality of the graphical program to be generated. In a case such as this the functionality of the generated graphical program may be determined mainly by the GPG program. Thus one embodiment may include different types of GPG programs wherein each type of GPG program is configured to generate graphical programs of a certain type. For example consider two different GPG programs program A and program B which are both operable to receive numeric data from a database and create a graphical program based on the numeric data. Program A may be operable to create a graphical program which when executed performs one type of operation on the numeric data and program B may be operable to create a graphical program which when executed performs a different type of operation on the numeric data. Thus in these examples the functionality of the graphical program is determined mainly by the GPG program that generates the graphical program.

Thus in various embodiments the functionality of the graphical program may be determined by the received program information and or the GPG program. In some cases the functionality may be specified almost entirely by the received information. For example in a case where the GPG program automatically translates an existing program to a new graphical program the functionality of the new graphical program may be specified entirely by the existing program. In other cases the received information and the GPG program may each determine a portion of the functionality. For example in a case where the GPG program generates a graphical program to implement a test executive sequence the test executive sequence information may determine the body of the program which includes the code for executing the tests but the GPG program may be operable to add additional functionality to the graphical program e.g. by adding code operable to prompt the user for a log file and save test results to the log file code to display a user interface indicating the current unit under test and the current test being performed etc.

In a typical case the implementation of the source code for the graphical program is determined mainly or entirely by the GPG program although the received information may influence the manner in which the GPG program generates the code or the GPG program may receive separate information influencing the code generation. For example consider a GPG program operable to translate an existing graphical program to a new graphical program e.g. in order to port the existing graphical program to a new programming environment. In one embodiment the GPG program may be operable to generate the new graphical program in such a way as to match the existing graphical program as closely as possible in appearance. In other words the new graphical program may be generated so that when the user sees the block diagram of the new graphical program the block diagram appears substantially the same as the block diagram of the existing graphical program e.g. in terms of the number of block diagram nodes the layout and interconnections among the block diagram nodes etc. However it should be noted that the newly generated graphical program may include a plurality of computational models so that in cases where the existing graphical program is specified in only one computational model e.g. data flow the newly generated graphical program may differ visually from the existing graphical program. In another embodiment the GPG program may be operable to implement the source code for the new graphical program differently e.g. by optimizing the code where possible e.g. by using different computational model s . In this example the functionality of the generated graphical program may be the same in either case but the graphical program may be implemented in different ways.

The GPG program may also receive input specifying how to implement the graphical program. For example in the case above the user may specify whether or not to perform optimizations when translating an existing graphical program. For example the new programming environment may support downloading the generated graphical program to a hardware device for execution. If the user desires to download the generated graphical program to a hardware device e.g. for use in a real time application then it may be important to optimize the new program. Otherwise it may be more important to implement the generated graphical program similarly as the existing graphical program is implemented. As another example the user may be able to specify a subset of the computational models of the graphical program.

In one embodiment the GPG program may provide extended support for specifying graphical program code implementation beyond the ability to specify simple options. For example the GPG program may support plug ins specifying code generation information for various cases. Referring again to the program translation example above each plug in may specify how to generate code intended for execution on a particular hardware device. For example if the generated program is to be run on an FPGA the generation of the code may be optimized depending on the number of gates available on that particular FPGA.

In various embodiments an association between a generated graphical program and the received program information used in generating the graphical program may be maintained. For example after the graphical program has been automatically generated this association may enable a user to recall the program information or return to an application from which the program information originates e.g. in order to view or edit the program information. For example consider a prototyping environment application which enables a user to develop a prototype characterizing an algorithm. The prototyping environment application may automatically generate a graphical program implementing the developed prototype. The user may then execute the graphical program and if a problem with the program is discovered the association may enable the user to return to the prototyping environment application in order to view or modify the prototype used to generate the program. The graphical program may then be automatically modified or re generated accordingly.

In one embodiment a generated graphical program may be locked requiring the user to explicitly unlock the program before the program can be modified within the graphical programming environment. Locking the graphical program may facilitate the retrieval or recreation of the program information that was used to generate the graphical program.

In various embodiments the GPG program may be operable to generate any of various types of graphical programs. For example as discussed above a generated graphical program may be targeted toward a particular graphical programming development environment application e.g. to utilize proprietary features or to create files that are formatted in a manner expected by the graphical programming development environment. Examples of graphical programming development environments include LabVIEW BridgeVIEW DasyLab and DiaDem from National Instruments VEE from Hewlett Packard Simulink from The MathWorks Softwire from Measurement Computing Inc. Sanscript from Northwoods Software WiT from Coreco and Vision Program Manager from PPT Vision among others.

In various embodiments the graphical program may be generated using any of various methods or techniques. Generating the graphical program may comprise generating one or more files defining the graphical program. When a user interactively develops a graphical program from within a graphical programming environment the graphical programming environment may create one or more program files. For example the program files may specify information such as a set of nodes that the graphical program uses interconnections among these nodes automatic structures such as loops etc. In other cases the program files may store various data structures e.g. in binary form which the graphical programming environment uses to directly represent the graphical program. Thus in automatically generating the graphical program the GPG program may automatically generate one or more files representing the graphical program wherein these files are structured or formatted appropriately for a particular graphical programming environment.

In various cases a graphical program generated by a GPG program in response to program information may be a fully working program. Thus the user may load the generated graphical program into the graphical programming environment execute the program etc. In other cases the generated graphical program may not be a complete program. As an example if an existing program is translated to a graphical program it may not be possible to translate the entire program. For example the existing program may utilize functions which do not exist in the graphical programming environment to which the program is to be ported. However the GPG program may still create a partial graphical program making it relatively easy for the user to complete the graphical program. In still other cases it may be desirable to automatically generate only a graphical code portion e.g. as discussed above in the case of user interface wizard tools that aid the user in program development.

As discussed above in one embodiment a graphical program or portion of a graphical program may be automatically generated in response to program information received as user input. As also discussed above the graphical portion or the portion may include a plurality of computational models. is a flowchart diagram illustrating one embodiment of a method for automatically generating a graphical program in response to user input received via a graphical user interface GUI . The GUI may be any type of GUI and the user input may be received via the GUI in any of various ways. In one embodiment the GUI may comprise one or more GUI input panels. The GUI input panels may take any of various forms including a dialog box or window and may include any of various means for receiving user input such as menus GUI input controls such as text boxes check boxes list controls etc. The GUI input panels may comprise textual and or graphical information and may be able to receive textual and or graphical user input. Note that the GUI may include or implement all of the functionality described above with respect to the GPG program.

In step the GUI may be displayed e.g. one or more graphical user interface GUI input panels may be displayed wherein the GUI input panels comprise information useable in guiding a user in creation of a program. For example the GUI may include various code generation wizards i.e. tools that enable a user to specify desired program functionality at a high level via GUI input panels. The GUI input panels may be displayed in response to user input indicating a desire to specify program functionality. For example the GUI input panels may be invoked in response to user input to various menu options e.g. of the GUI .

In step user input specifying desired program functionality may be received via the one or more GUI input panels. For example as described above the GUI input panels may comprise various GUI input controls such as text boxes check boxes list controls etc. and the user may configure these GUI input controls to indicate the desired program functionality. As an example consider a case where the GUI input panels enable the user to specify program functionality for generating waveform data. In this example the GUI input panel may include a list GUI control for choosing whether to generate the data as a sine wave square wave etc. a numeric GUI control for specifying the desired amplitude for the wave a numeric GUI control for specifying the desired frequency for the wave etc. Thus in this example the user input received may specify the desired waveform type the desired amplitude and frequency etc.

In step a graphical program or graphical program portion to implement the specified desired functionality may be automatically generated in response to the received user input. As described above automatic generation of the graphical program may include little or no user input. In particular automatically generating the graphical program is performed without user input specifying the nodes or connections between the nodes. Thus the user is not required to select and place nodes in the diagram or draw connections lines or wires between the nodes. As also indicated the graphical program or graphical program portion may include a plurality of computational models. Additionally the method may include automatically including graphical source code e.g. the underlying graphical code described above in the graphical program. For example the automatically generated graphical source code may comprise a plurality of nodes that are interconnected in one or more of a data flow control flow and or execution flow format so as to implement the specified functionality. The nodes may have input output terminals terminal names comments or other aspects that are automatically generated. Additionally the automatically generated graphical program or portion may include various other computational models e.g. synchronous data flow state diagram text based code or simulation among others. Thus the GPG program may be operable to generate various graphical programs or portions depending on the received user input. For example in the waveform generation example discussed above the GPG program may include a sine wave node in the graphical program if the user specifies to generate sine wave data in or may include a square wave node in the graphical program if the user specifies to generate square wave data.

It is noted that in and a plurality of GUI input panels may be displayed and user input may be received from each of these panels. For example a first panel may be displayed on the display e.g. corresponding to a first computational model and the first panel may include one or more first fields adapted to receive first user input specifying first functionality of the graphical program. User input specifying first functionality of the graphical program may be received via the first panel. A second panel may then be displayed for receiving second user input specifying second functionality of the graphical program e.g. corresponding to a second computational model. In one embodiment the second panel that is displayed may be based on the first user input. In other words in one embodiment the GUI input panels may be displayed in a wizard based manner that guides the user in specifying the desired functionality.

As also shown the graphical program includes a first computational model data flow a second computational model continuous time simulation data flow and a third computational model text based code . More specifically the for loop and nodes outside represent data flow computation the formula node represents text based computation and the remaining portion inside represents continuous time simulation data flow. Thus the graphical program includes three computational models.

Thus illustrate exemplary graphical programs with a plurality of computational models which may be created using the methods described above among others .

In a graphical user interface GUI may be displayed on a display. The GUI may be one of a plurality of possibly GUIs such as those described above among others. For example the GUI may include a plurality of windows that each correspond to steps along the process in specifying desired functionality of the graphical program. Additionally or alternatively the GUI may be or be included in the GPG program described above. In some embodiments the GUI may include different windows associated with different possible computational models. Thus the GUI may be any of a variety of GUIs such as those described above among others and may be used for specifying desired functionality of the graphical program.

In user input may be received to the GUI specifying desired functionality of the graphical program. Similar to descriptions above the user input may vary from graphical program to graphical program. In other words the user may specify the functionality of the graphical program via a variety of methods such as those described above among others . For example the user input may directly specify functionality of the graphical program e.g. by entering information or interactively creating various diagrams or configurations. Alternatively or additionally the user input may specify various template programs or already created programs to be used to generate the graphical program.

In user input specifying a first computational model may be received. As described above the computational model may be selected from a plurality of computational models e.g. graphical data flow synchronous data flow execution flow state diagram control flow diagram text based code and or simulation diagram among others. In some embodiments the user input specifying the first computational model may be received to the GUI as a part of . In other words the user input specifying the desired functionality of the graphical program may also specify the first computational model. For example if the user specifies functionality of the graphical program by creating for example a state diagram the GUI e.g. the GPG program may not ask the user to specify the computational model but instead may determine that the computational model is a state diagram. Alternatively the GUI may suggest a computational model to the user based on the user input and the user may have the option to accept the suggested computational model or specify a new computational model as desired. In one embodiment the GUI may analyze the user input specifying the desired functionality and determine an appropriate computational model. Where the user s specification and the determined computational model differ the GUI may indicate the determined computational model to the user. The user may then have the opportunity to accept the suggested computational model or specify a different computational model.

In the graphical program may be automatically generated with the first computational model in response to the user input specifying the functionality of the graphical program. Similar to descriptions above the graphical program may be automatically generated via a variety of methods such as those described above among others. As also described above the graphical program may be implemented via underlying graphical code. Thus in one embodiment the graphical program may be specified in the specified computational and be implemented in an underlying graphical code e.g. G from National Instruments Corporation.

The above discussed examples of automatically generating a graphical program or graphical program portion may be implemented in any of various ways. For more information on one embodiment of a system and method for automatically generating a graphical program please refer to the above incorporated patent applications. In particular refer to the above incorporated patent application titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information .

Using the methods described above various graphical programs may be automatically generated including two or more computational models. Automatic generation of these graphical programs may allow the user to more easily and intuitively view and understand the functionality of the graphical program. For example where the graphical program implements an algorithm using for example a series of ordinary differential equations the graphical program may include a first portion having a plurality of interconnected nodes and a second portion comprising a text based script. Thus it may be more intuitive for the user to view and modify the algorithm in a text based sequential computational model such as in a MathScript script. As another example the automatically generated graphical program may have a first portion having a plurality of interconnected nodes and a second portion comprising a state diagram representation. In this instance it may make more sense for the user to modify a state diagram when editing a machine vision process rather than trying to analyze or modify a normal graphical data flow diagram.

Additionally where the user computer or GUI for automatically generating the graphical program includes or is aware of already existing diagrams algorithms program instruction files etc. the current method may be particularly advantageous as this legacy code can be reused e.g. to efficiently generate new sophisticated programs. Thus various information or diagrams that have already been programmed or specified in different computational models may be used or included in a single graphical program. In this manner the graphical program can utilize the advantages of each of the different computational models and or reuse legacy code to implement new or additional functionality.

Although the system and method of the present invention has been described in connection with the preferred embodiment it is not intended to be limited to the specific form set forth herein but on the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the spirit and scope of the invention as defined by the appended claims.

