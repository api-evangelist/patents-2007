---

title: Legacy application decommissioning framework
abstract: A legacy application decommissioner provides developers a tool to decommission and migrate legacy application functionality in a phased approach. The decommissioner identifies core web services that invoke legacy applications through an accessibility layer that monitors operator interaction with the application. The decommissioner then defines, creates, and deploys a web service that provides control over the operation of the legacy application. As a result, the functionality of the legacy application may be migrated to a new platform and architecture and the legacy application decommissioned so that organizations may continue to realize a return on their significant investment in the creation of the legacy application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08122444&OS=08122444&RS=08122444
owner: Accenture Global Services Limited
number: 08122444
owner_city: Dublin
owner_country: IE
publication_date: 20070802
---
This disclosure concerns a system and method for decommissioning legacy applications by migrating functionality of legacy applications to new platforms and architectures. In particular this disclosure relates to an efficient and non invasive way to decommission legacy applications using a phased migration approach.

A strong demand exists for a system and method to decommission legacy applications in the course of migrating legacy applications to new platforms and architectures. When an organization initiates the decommissioning of a legacy application by migrating functionality to a new platform or architecture organizations spend a great deal of time and money recreating the functionality of legacy applications from scratch. Often system integrators desire to reuse existing assets of a legacy application targeted for decommissioning e.g. legacy applications processes and software components by simply providing a new interface or platform in which to interact with these assets. One such example includes migrating legacy applications to web services in a Service Oriented Architecture SOA . Unfortunately developers have identified only a limited number of ways to migrate legacy applications to new platforms and architectures without giving rise to lengthy project schedules and excessive budgets often forcing companies to reengineer systems and applications from scratch.

Developers often use legacy application migration approaches that do not allow for the phased migration of functionality. Migration approaches that impose a non phased approach take longer to complete increase the complexity of testing and impose a burden on users to adapt to an entire suite of migrated functionality all at once. Even phased migration approaches can be plagued with inefficiencies. For example one phased migration approach actually expose users to two disparate systems e.g. the legacy application and the new migration during the migration until developers complete the entire migration and force users to interact with the two disparate systems through separate interfaces.

Legacy applications often incorporate Graphical User Interface GUI APplications GAPs implemented in a closed and monolithic manner. System integrators find migrating existing GAPs a particularly difficult technical challenge especially for closed and monolithic GAPs because GAPs do not interoperate e.g. exchange information with other systems. Because closed and monolithic GAPs do not interoperate with other systems phased migrations present extremely technical challenges. Given the complexity of GAPs and the cost to efficiently and non invasively make GAPs interoperable presents one of the fundamental technical problems of migrating legacy applications.

While newer technology such as web services can provide flexible functionality organizations have invested heavily in legacy GAPs that developers consider difficult to add to an existing framework of web services and modify to enable interoperability because of brittle legacy architectures poor documentation significant programming effort and subsequently the large cost of such projects. Great difficulties and enormous expenses associated with migrating legacy applications into integrated interoperable applications exist. Beyond migrating legacy applications into integrated applications components system integrators and applications programmers must define protocols and implement functionality required to enable information exchanges between the components of integrated applications which may include GAPs and web services.

Organizations tend to use legacy GAPs as long as possible in business operations primarily to realize the return on investment for the legacy GAPs. However system integrators consider the vast majority of GAPs encountered as closed and monolithic and prefer to use legacy GAPs as long as possible to avoid the burden of re writing the functionality from scratch because of the difficulty of enabling GAPs to interoperate. Most GAPs do not expose programming interfaces or data in known formats. Thus while system integrators desire to incrementally migrate GAPs components into integrated applications often the original implementation of a GAP makes migration without re writing logic impossible.

Further exacerbating the problem is that organizations often do not have access to the source code of third party GAPs which prevents organizations from migrating third party GAPs to new platforms and architectures. In such instances developers must locate old and often inaccurate requirements documents observe the third party GAPs during user sessions and write functionality from scratch. The inability to review legacy source code forces developers to employ extensive testing but does not ensure that all the developer has captured all the third party GAPs functionality correctly.

The extraordinary technical challenges associated with decommissioning a legacy application and migrating legacy applications to new platforms and architectures include implementing controlled phased migrations that allow organizations to introduce migrated functionality in manageable portions over time. The technical challenges also include decommissioning and migrating third party GAPs without the ability to review the legacy source code of the third party GAPs.

A need has long existed for a system and method that migrates legacy applications to new platforms and architectures in a phased migration approach efficiently and non invasively.

Migrating legacy GAPs to new platforms and architectures allow organizations to improve their business processes and extend the usability of legacy GAP functionality. The legacy application decommissioning framework Decommissioner provides developers a way to implement phased migrations of legacy applications to new platforms and architectures. The decommissioner allows organizations to control the migration of legacy applications at a granular level by providing a web service wrapper for GAPs e.g. functionality of an interoperable legacy application that allows a developer to incrementally decommission the legacy application. The decommissioner builds a core web service that includes a core web service identifier and legacy application invocation logic that interacts with the legacy application and invokes the legacy application logic. The decommissioner produces a web service wrapper that includes the core web service identifier and legacy application invocation logic e.g. a call to a proxy or a dispatcher . The decommissioner uses the dispatcher as a central point for coordinating proxies in a distributed environment. The proxy registers with the dispatcher under a unique name collects GAP identification data and information about GAPs and sends the collected GAP identification and information about GAPs to the dispatcher. The dispatcher uses the information collected from the proxies to route web service requests. The dispatcher acts as a request handler and receives a web service functionality request for legacy application logic and responsively invokes the decommissioning framework. The developer may introduce decommissioning replacement logic into the web service wrapper to allow a user to interact with the legacy application and new application transparently using a common interface e.g. a client program . The decommissioning replacement logic maps legacy application features into the web service wrapper that the decommissioner can eventually decommission in the legacy application. The decommissioner tracks the legacy application logic e.g. features implemented in the web service wrapper and notifies the developer when the features identified for decommissioning have been replaced and or decommissioned in the legacy application.

The decommissioner may incrementally introduce decommissioning replacement logic into the web service wrapper over a transition period during which the developer incrementally migrates the legacy application functionality to the new application so that the legacy application can be completely decommissioned at the end of the transition period. The organization may vary the transition period for each of the discrete features e.g. legacy application logic implementing particular functionality of the legacy application depending on the complexity of the legacy application logic providing the functionality the migration dependencies and impacts to other legacy application features and the readiness of the new application to inherit the decommissioned functionality from the legacy application.

The decommissioner can replace legacy application logic with decommissioning replacement logic at a very granular level. For example the decommissioner may provide zero degrees of coverage for the legacy application logic implementing a particular feature. The decommissioner may provide a non zero degree of coverage so that a blended combination of legacy application logic and decommissioning replacement logic provide the features of the legacy application. The decommissioner may provide 100 percent decommissioning replacement logic e.g. 100 degree of coverage where the decommissioner has completely migrated the legacy application logic to a new application. The decommissioner sends a decommissioning request to the developer when the degree of coverage provided by the decommissioner meets a decommissioning threshold. The decommissioner may designate a default decommissioning threshold and or the developer may specify the decommissioning threshold. The degree of coverage may meet the decommissioning threshold even though the decommissioner has not implemented all the features of the legacy application. For example a developer may assign legacy application logic a weight from 1 to 10 where a weight of 10 indicates a critical feature and a weight of 1 indicates an optional and or non critical feature. The degree of coverage may meet the decommissioning threshold when the features assigned a weight over 7 have been implemented by the decommissioning framework. When the degree of coverage meets the decommissioning threshold the decommissioner sends a decommissioning request to the developer and inserts default decommissioning replacement logic to replace features not included in the degree of coverage.

The decommissioner solves the extraordinary technical challenges associated with decommissioning a legacy application and migrating legacy applications to new platforms and architectures. The decommissioner solves these extraordinary challenges by providing developers a tool to implement controlled phased migrations that allow organizations to introduce migrated functionality in manageable portions over time. The decommissioner also solves the technical challenges of decommissioning and migrating third party GAPs where a developer does not have the ability to review the legacy source code of the third party GAPs.

Other systems methods and features of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the following claims.

The decommissioner addresses the technical challenge of enabling GAPs to exchange information i.e. interoperate with each other and web services. The decommissioner solves the technical problem of implementing controlled phased migrations of legacy applications e.g. GAPs that allow organizations to introduce migrated functionality in manageable portions over time efficiently and non invasively. The decommissioner also solves the technical challenges of migrating third party GAPs where the organization does not have access to review the legacy source code of the third party GAPs.

Phased migrations allow organizations to introduce migrated legacy application functionality over time minimize the complexity of and isolate testing and allow users time to become comfortable with the migrated functionality. Migration approaches that impose a non phased approach take longer to complete increase the complexity of testing and impose a burden on users to adapt to an entire suite of migrated functionality all at once.

In contrast to GAPs developers design web services as software components that flexibly exchange information over networks including the Internet. Consequently business industry demands for applications that easily and inexpensively exchange information has partly caused widespread acceptance of web services. Employing web services unlike GAPs enables organizations to quickly build integrated systems by composing i.e. configuring the web services for information exchange. Web services allow organizations to quickly migrate functionality from one application to another

A developer may connect UI elements of a GAP with properties of the web service by placing logic that invokes the functionality of the GAP into a core web service. The logic specifies how the web service interacts with the legacy GAP. The developer selects a method for the web service and determines how to invoke the web service. For example an end user performing some action on a UI element e.g. clicking a button on a GAP screen invokes the method. The developer defines whether to pass the values of the UI elements as parameters to the invoked method or use the values to set properties of the web service before invoking the method. In addition the developer specifies how to use the return values of the invoked method for example whether to update selected UI elements of the GAPs with the values or display the values in message dialogs. The developer creates core web services for GAPs and defines web service parameter relationships between web service parameters and UI elements of a GAP. The developer creates and deploys core web services based on web service definitions user interface interaction specifications and web service parameter relationships. The developer may define an action in response to certain return values of the invoked method. Once the developer creates the core web service making the legacy application interoperable the developer may use the decommissioner to build an immutable web service wrapper to insert decommissioning replacement logic that can be used to incrementally replace the legacy application logic.

The decommissioner uses proxies to command and control GAPs and UI elements of GAPs to fulfil web service requests. When a proxy receives a response from a GAP the proxy extracts data from the GAP and forwards the extracted data to one or more web services. Proxies use hooks to perform various actions on UI elements and GAPs programmatically through accessibility API calls. Accessibility technologies allow hooks to register for different events produced by UI elements and GAPs monitored by accessibility APIs. One or more GAPs may run with a proxy and corresponding hooks on a single designated GAP host computer along with a accessibility API.

The decommissioner uses a dispatcher as a central point for coordinating proxies in a distributed environment. A proxy registers with the dispatcher under a unique name collects GAP identification data and information about GAPs running with the proxy on a GAP host computer and sends the collected GAP identification and information about GAPs to the dispatcher. The dispatcher uses the information collected from the proxies to route web service requests to proxies. The dispatcher routes web service request components of web services to GAP host computers where corresponding proxies ultimately command and control GAPs and UI elements. The dispatcher acts as an intermediary that enables web services and GAPs to run on separate computers while presenting a common view to client programs. Because organizations may move web services and GAPs around the enterprise computing environment for various reasons e.g. to improve business processes efficiencies or the performance of applications the dispatcher provides web services and GAPs migration and location transparency to client programs.

The elements illustrated in the Figures interoperate as explained in more detail below. Before setting forth the detailed explanation however it is noted that all of the discussion below regardless of the particular implementation being described is exemplary in nature rather than limiting. For example although selected aspects features or components of the implementations may be depicted as being stored in memories all or part of systems and methods consistent with the decommissioner may be stored on distributed across or read from other machine readable media for example secondary storage devices such as hard disks floppy disks and CD ROMs a signal received from a network or other forms of ROM or RAM either currently known or later developed.

Furthermore although specific components of the decommissioner will be described methods systems and articles of manufacture consistent with the system may include additional or different components. For example a processor may be implemented as a microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other type of circuits or logic. Similarly memories may be DRAM SRAM Flash or any other type of memory. Logic that implements the processing and programs described below may be stored e.g. as computer executable instructions on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. Flags data databases tables and other data structures may be separately stored and managed may be incorporated into a single memory or database may be distributed or may be logically and physically organized in many different ways. Programs may be parts of a single program separate programs or distributed across several memories and processors and may be implemented or distributed as shared libraries application programming interfaces APIs or in other forms. Furthermore the programs or any portion of the programs may instead be implemented in hardware.

In one implementation when proxy receives a web service request component the proxy interacts with one or more UI elements of the GAP with UI elements through the hook in response to the web service request component. The accessibility layer may support hook to perform various actions on GAP with UI elements programmatically. Proxy in communication with GAP host computer for GAP with UI elements and hook may register the GAP with UI elements with the dispatcher resulting in a second composite web service request component of the composite web service to route through the dispatcher to the GAP host computer . In one implementation when proxy receives the second web service request component the proxy interacts with one or more of the UI elements of the GAP with UI elements through the hook in response to the second web service request component. The accessibility layer may support hook to perform various actions on GAP with UI elements programmatically. The dispatcher may use a load balancer to route web service requests to multiple GAP host computers.

In one implementation of the Integrated System multiple instances of a GAP e.g. Acme Expense GAP AEG run concurrently on separate GAP host computers e.g. GAP host computer GAP host computer and GAP host computer . The dispatcher assigns each instance of AEG a unique GAP identifier enabling the dispatcher to coordinate parallel execution of multiple instances of AEG so that when the composite web service sends a composite web service request component to the dispatcher in response to a request from a client program the dispatcher routes the composite web service request component to the correct instance of AEG.

In one implementation the accessibility layer supports hook and hook to perform various actions programmatically on GAP GAP UI elements and GAP and GAP UI elements respectively. The accessibility layer may also assist with capturing a structural representation of GUIs of a GAP and UI elements of the GAP as a result of interactions with the GAP. The structural representation of GUIs of a GAP and UI elements of the GAP may provide the proxy hook and hook comprehensive information to locate control and manipulate GAP GAP GAP UI elements and GAP UI elements . The structural representation of GUIs of a GAP and UI elements of the GAP may be implemented as objects e.g. an XML file that capture depth first traversals of the GUI breadth first traversal of the GUI or that otherwise stores the interface elements and screen sequences of the GUI. The proxy may analyze the structural representation of GUIs of a GAP and UI elements of the GAP to locate a GAP UI element in the GAP GUI.

The proxy may include registration logic an accessibility layer command coordinator and a GAPs identification table . The proxy may use the registration logic to register GAP and GAP with the dispatcher. The accessibility layer command coordinator may control GAP and GAP UI elements through hook in response to a web service request component. To that end the accessibility layer command coordinator may receive web service request components extract the graphical user interface element identifiers a structural representation of a GAP and the requested action on the identified graphical user interface element. The accessibility layer command coordinator may then traverse the structural representation to determine where the identified graphical user interface element resides in the GAP user interface and make calls to the hook to navigate the GAP to the interface that includes the identified graphical user interface element. Once at the appropriate interface the accessibility layer command coordinator may then exercise the graphical user interface element through the hook to perform the requested action.

In another implementation proxy uses an accessibility layer command coordinator running on and dedicated to GAP host computer to control GAP with UI elements through hook in response to a web service request component. The proxy may collect GAP identification data and information about GAPs e.g. GAP and GAP hosted with proxy on the multiple GAPs host computer and stores the collected GAP identification data and information about the GAPs in the GAPs identification table . In one implementation the proxy may store GAP Identifiers for multiple locally hosted GAPs e.g. GAP and GAP in the GAP identification table . The proxy may periodically send the collected GAP identification data and information about the GAPs to the dispatcher . The multiple GAPs host computer may use the external storage to store the GAP exe and GAP exe programs.

In an alternative implementation the dispatcher receives a web service request message from the web service that includes a GAP UI element Identifier and an action request identifier for a specific GAP UI element e.g. GAP UI elements . The GAP UI element may correspond to a GAP e.g. GAP executing in memory . The dispatcher may send the web service request message to proxy which extracts the GAP UI element identifier and action request identifier from the web service request message. The proxy may perform an action against the GAP UI elements specified in the action request identifier through hook . The action request identifier may include a GUI element data setting action or a GUI element data retrieval action that the proxy performs through hook against the GAP UI elements specified in the action request identifier.

In one implementation when a client program invokes a method of a web service or composite web service the web service or composite web service to which the method belongs sends a web services registration request to the dispatcher . The dispatcher may identify the GAPs required to fulfil a method of a web service or a composite web service . The dispatcher may use registration logic to receive GAP registration requests from GAPs and web services registration requests from web services and composite web services . The dispatcher may also use the registration logic to control GAPs to web services assignments logic to analyze the proxy GAPs identification tables to assign GAPs and UI elements to methods of web services and methods of composite web services . In one implementation the registration logic instantiates the proxy GAPs identification table e.g. proxy GAPs identification table and proxy GAPs identification table in response to a GAP registration request from a GAP. The dispatcher may include a GAPs request queue to store web service requests and web service request components when a web service requests an unavailable GAP which will be explained in further detail below.

The interaction logic captures one or more GAP UI elements and one or more GAP UI elements using the accessibility layer . In other words the Interaction logic may capture a structural representation of GUIs of a GAP and UI elements of the GAP through the accessibility layer using the hook logic to communicate with the GAPs e.g. GAP GAP and corresponding GAP UI elements and GAP UI elements . Proxy logic may control the GAPs through the hook logic and the proxy logic may use the registration logic to send GAP registration requests to the dispatcher . The structural representation of GUIs of a GAP and UI elements of the GAP may include a GAP UI element label a UI element Identifier and location information in the GAP GUI for the GAP UI elements e.g. GAP UI elements and GAP UI elements and may also include a GAP GUI screen sequence representation for each GAP GUI screen sequence.

The design tool user interface logic may generate the design tool user interface that includes the input parameter area and a screen sequence area monitor and determine an operator s selection of at least one of the GAP UI elements in the GAP GUI represented in the structural representation of GUIs of a GAP and UI elements of the GAP and add the selected GAP UI elements to the input parameter area . The definition logic may establish the web service definition with at least one of the web service parameters e.g. WS parameter WS parameter and WS parameter that will interact with the at least one of the GAP UI elements . The relation logic may establish a web service parameter relationship between at least one of the web service parameters e.g. WS parameter WS parameter and WS parameter and at least one of the GAP UI elements . The relations logic may establish multiple web service parameter relationships with multiple web service parameters e.g. WS parameter WS parameter and WS parameter and each of the GAP UI elements .

In one implementation the web service wrapper and web service wrapper include core web service CWS identifiers ID and CWS ID respectively corresponding to core web services WS and core WS . Core WS and core WS invoke GAP GAP and GAP using legacy application invocation LAI logic and LAI logic . The web service wrapper and web service wrapper include LAI logic and LAI logic respectively and decommissioning replacement DR logic and DR logic and exception handler and exception handler .

In one implementation the decommissioning framework uses the web service wrapper to replace the core WS so that the client program directs service requests to the web service wrapper and LAI logic executes instead of LAI logic . The DR logic may be introduced into the web service wrapper to replace portions and or all of the LAI logic so that the web service wrapper invokes GAP a combination of the GAP and the new application NA logic or the NA logic only. The combinations of DR logic and LAI logic implemented in the decommissioning framework will be presented in further detail below.

In one implementation the decommissioning logic identifies DR logic and DR logic for GAP GAP and GAP that the decommissioning system uses to decommission the legacy application . The decommissioning logic builds web service wrapper and web service wrapper that include the CWS ID and CWS ID from core WS and core WS and inserts DR logic and DR logic into web service wrapper and web service wrapper respectively to establish the decommissioning framework for the legacy application . The decommissioning system may coordinate communication with the legacy application new application core WS and core WS web service wrapper and web service wrapper dispatcher logic and proxy logic through the communications interface to process service requests from the client program .

In one implementation the dispatcher logic and proxy logic coordinate communication between core WS core WS web service wrapper web service wrapper and legacy application . The dispatcher logic and proxy logic communicate with the dispatcher and proxy respectively where the dispatcher operates as a central point for coordinating proxies e.g. proxy in a distributed environment. For example proxy registers with the dispatcher collects information about GAP GAP and GAP running with the proxy and sends the information to the dispatcher . The dispatcher uses the information from the proxy to route service requests from the client program core WS and core WS and web service wrapper and web service wrapper to the proxy . In one implementation the decommissioning logic builds the decommissioning framework with web service wrapper and web service wrapper using information received via communication with the dispatcher logic and proxy logic . Web service wrapper and web service wrapper may use LAI logic and LAI logic to communicate with the dispatcher and or proxy . In one implementation LAI logic and LAI logic and LAI logic and LAI logic communicate with the dispatcher and or proxy through the dispatcher logic and proxy logic respectively.

In one implementation the decommissioning threshold represents an amount e.g. a percent of functionality coverage the developer desires the decommissioning framework to provide before the legacy application is decommissioned. The decommissioning evaluation logic evaluates the degree of coverage the decommissioning framework provides to determine whether the degree of coverage meets the decommissioning threshold . The developer may assign weights to features e.g. legacy application logic that the decommissioning evaluation logic uses to determine whether the degree of coverage meets the decommissioning threshold . For example a developer may assign legacy application logic a weight from 1 to 10 where a weight of 10 indicates a critical feature and a weight of 1 indicates an optional and or non critical feature. The degree of coverage may meet the decommissioning threshold when a selected subset or all of the features assigned a specific weight or weights e.g. a weight of 10 or weights above 7 have been implemented by the decommissioning framework . As another example the degree of coverage may meet the decommissioning threshold when the sum of the weights for features implemented in the decommissioning framework exceeds the value set as the decommissioning threshold . The decommissioning may be qualitative and or quantitative in nature.

In one implementation the decommissioning evaluation logic sends a decommissioning request when the degree of coverage meets the decommissioning threshold . The decommissioning request may take many forms such as an email voice or instant message to a developer manager or other authority. The decommissioning request may also take the form of an interprocess request signal or other message to an automated process e.g. an operating system that deactivates terminates or otherwise decommissions the legacy application . In response to meeting the decommissioning threshold the decommissioning system may automatically implement default DR logic and DR logic for functionality of the legacy application not already covered by the decommissioning framework .

For example where the developer sets the decommissioning threshold to 50 and the decommissioning evaluation logic evaluates the degree of coverage to indicate that the decommissioning framework provides 66 of the legacy application logic e.g. GAP and GAP through web service wrapper the decommissioning evaluation logic sends the developer a decommissioning request because the degree of coverage meets the decommissioning threshold . The degree of coverage for example represents coverage for GAP and GAP . The decommissioning evaluation logic automatically implements DR logic for functionality of the legacy application not represented by the degree of coverage e.g. GAP . The automatically implemented DR logic may provide default processing error handling or other response to substitute for the remaining functionality not actually implemented by replacement logic.

Table 1 shows a core web service with a method submitExpense that accepts input parameters used to submit expenses and includes legacy application invocation logic that interacts with a GAP used to insert expense information into a legacy application. The executor shown in Table 1 may be configured to represent the legacy application invocation logic based on the values given the host and port variables indicating the legacy application logic to invoke.

Table 2 shows a web service wrapper that includes decommissioning replacement logic. A web service wrapper may combine the Table 1 and Table 2 logic to implement a web service wrapper that includes LAI logic and DR logic. Accordingly a single web service wrapper may replace any one or more core web services or any amount of legacy functionality. There need not be a one to one correspondence between web service wrappers and core web services and the wrappers may implement any distribution of logic.

The decommissioning evaluation logic may compare the degree of coverage to the decommissioning threshold and issue a decommissioning request to deactivate the legacy application when the degree of coverage meets the decommissioning threshold . The decommissioning threshold indicates the percent of functionality coverage the developer desires the decommissioning framework to provide before a legacy application may be decommissioned. For example the decommissioning threshold may be set to 50 so that when 5 of the 10 functionality identified for decommissioning have been implemented in the decommissioning framework the decommissioning evaluation logic may issue a decommissioning request . The decommissioning request may indicate a flag or other indicator that provides the developer information regarding outstanding tasks to complete and or optional functionality that the developer may decide to decommission without migrating to the new application before fully decommissioning the legacy application .

The decommissioning evaluation logic may further evaluate whether the decommissioning framework has decommissioned 100 of the legacy application functionality when the degree of coverage meets the decommissioning threshold and automatically implement additional decommissioning replacement logic for legacy application functionality not represented by the degree of coverage . In other words when the decommissioning framework meets the decommissioning threshold but decommissions less than 100 of the legacy application logic the decommissioning evaluation logic may automatically implement additional decommissioning replacement logic so that the legacy application can be fully decommissioned. The automatically implemented decommissioning replacement logic may provide default processing error handling or other responses to substitute for the remaining legacy application functionality not covered by the degree of coverage .

The decommissioning logic may identify additional decommissioning replacement logic to include in the decommissioning framework either inserting the decommissioning replacement logic into an existing web service wrapper or implementing a new web service wrapper. The decommissioning evaluation logic may evaluate the degree of coverage when the decommissioning framework includes additional decommissioning replacement logic until the desired functionality of the legacy application has been introduced into the decommissioning framework .

The decommissioner provides developers a tool to decommission and migrate legacy application functionality in a phased approach. The decommissioner identifies core web services that invoke legacy applications and defines creates and deploys a web service wrapper that provides control over the operation of the legacy application. As a result the functionality of the legacy application may be migrated to a new platform and architecture and the legacy application decommissioned so that organizations may continue to realize a return on their significant investment in the creation of the legacy application.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other implementations are within the scope of the following claims.

