---

title: Managing a deployment of a computing architecture
abstract: Embodiments are provided to deploy a number of computing devices based in part on a deployment file, but the embodiments are not so limited. In an embodiment, a dispatch application can be used to deploy a number of computing devices, wherein the deployment includes a number deployment parameters and functions associated with a configuration of the number of computing devices. The dispatch application can be used to deploy a number of computing devices, including virtual devices, logical devices, and other devices and systems. Other embodiments are available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010777&OS=08010777&RS=08010777
owner: Microsoft Corporation
number: 08010777
owner_city: Redmond
owner_country: US
publication_date: 20070702
---
This application is related to U.S. patent application Ser. No. 11 824 505 filed Jun. 29 2007 and entitled MANAGING A COMPUTING ENVIRONMENT which is hereby incorporated by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or patent disclosure as it appears in the U.S. Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Reference models and blueprints are useful for building and recreating reliable computing architectures. For example a blueprint can be used to configure hardware and software components for an enterprise computing environment. A reliable blueprint can be used to build secure architectures which can include network server and storage functionality. However some blueprints can be unreliable and contradictory. For example a blueprint may designate a particular hardware configuration for a server that is incompatible with a particular purpose. Human error can compound the issue. For example a number of administrators and associated support personnel may be tasked to manually deploy aspects of an enterprise system in accordance with a particular blueprint. The configuration and deployment can take hours and often days and may include starting the process over when a blueprint is misinterpreted or otherwise mismanaged. Correspondingly a deployment process using an unreliable blueprint can end up being inefficient and costly for an enterprise or other organization.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended as an aid in determining the scope of the claimed subject matter.

Embodiments are provided to deploy a number of computing devices based in part on a deployment file but the embodiments are not so limited. In an embodiment a dispatch application can be used to deploy a number of computing devices wherein the deployment includes a number deployment parameters and functions associated with a configuration of the number of computing devices. The dispatch application can be used to deploy a number of computing devices including virtual devices logical devices and other devices and systems.

These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of the invention as claimed.

Embodiments are provided to deploy a number of computing devices based in part on a number of deployment requirements. In an embodiment a dispatch component can use a deployment file to deploy a number of computing devices associated with a defined computing architecture. A deployment file can include a number of deployment parameters and associated functions which can be used when deploying the computing architecture. The dispatch component can be used to quickly efficiently and reliably deploy computing devices for testing debugging and other operations.

In one embodiment a dispatch application can be configured as a software application including executable instructions and used to deploy a computing architecture based in part on a deployment file. The deployment file can include a number of computing devices and associated configurations including virtual devices logical devices and other devices. For example the dispatch application can use an XML based deployment file to configure a cluster of servers according to a defined deployment environment. The dispatch application can use a deployment file which can include a number of deployment parameters and associated functions including but not limited to computing device names deployment packages computing device roles dependencies sequences certificates configuration information port and wires etc. The dispatch application can use an XML based deployment file to efficiently deploy and or reconfigure a computing architecture.

The dispatch component can be configured to deploy a number of computing devices based in part on information associated with a deployment file. As described below a deployment file can include information associated with the configuration of a number of computing devices. In an embodiment a deployment file can include a number of parameters and associated functions which define a deployment blueprint or architecture. The dispatch component can use a deployment file when deploying a defined computing architecture as part of a deployment process. For example the dispatch component can use an XML based deployment file that includes test cluster configuration parameters and functions when deploying the test cluster.

As used herein computing device is not intended to be limiting and can refer to any computing device system or component including servers desktops handhelds laptops software implementations logical devices virtual devices and other computing devices and systems. A logical device can refer to a number of devices or systems which can be grouped as a cluster wherein one cluster can be defined as a deployment unit. In an embodiment an XML based deployment file can be associated with each deployment unit. For example for a domain of 100 computing devices a user can create 10 clusters having 10 corresponding XML based deployment files.

Devices in each cluster can be described as logical devices even though they may coupled on a LAN and domain. Virtual devices can refer to devices or systems that are expecting or configured to accept a type of package. Virtual devices that are expecting the same type of package s can be grouped together to define one unit for deployment. As such one plan can be defined for each unit including incorporating an associated audit for each unit. As used herein the term network encompasses any configuration of computing devices which are transferring and manipulating information and can be implemented as a wired network a wireless network a combination of a wired and a wireless network and or other types of communication networks. While depicts a networked configuration other configurations are available.

As shown in the computing environment includes a network a network and a networks where x is some integer . Each network can include any number of computing devices and networking elements. The computing environment can also include other computing devices that may or may not be associated with a particular network. For example network may represent a first number of servers associated with a first serving pool and network may represent a second number of servers associated with a second serving pool. Continuing with the example the dispatch component can be used to deploy any number of computing devices associated with the first serving pool the second serving pool and or one or more of a number of computing devices D Dwhen deploying according to defined blueprint such as an XML based deployment file.

As described above the dispatch component includes functionality to deploy a number of computing devices as defined by a deployment blueprint. In an embodiment the dispatch component is configured to use an XML based deployment file when deploying a number of computing devices. The XML based deployment file can be created and or edited using a manager component described further below. As shown the manager component is associated with computing device but other configurations are available.

A database component includes one or more deployment files such as one or more XML based deployment files for example. The deployment files can include a number of parameters and associated functions that can be used by the dispatch component to deploy a computing architecture. As described further below and in accordance with an embodiment the dispatch component includes a number of functions that can be used when deploying a computing architecture. One or more functions associated with the dispatch component can be called to perform various operations associated with one or more operations of a particular deployment.

In one embodiment the dispatch component can be configured as a software application see dispatch application and can be employed on a client device for use in the deployment of computing devices according to a defined deployment blueprint which can be in the form of an XML based deployment file. Correspondingly the dispatch component can use an XML based deployment file when deploying a number of computing devices according to a defined deployment blueprint. For example a user can use the dispatch component to consume an XML based deployment file to deploy computing devices packages certificates etc. to include as part of a deployment architecture.

In another embodiment the dispatch component can be configured as a user interface UI and accessed using a computing device such as the computing device for example. The dispatch component can be accessed locally or remotely. Correspondingly a user can use the dispatch component configured as a UI to deploy a computing architecture as defined by a deployment blueprint. In one embodiment the UI can be configured as part of a web based service that users can access after providing proper authentication credentials. The UI can be configured to present deployment options to a user in different ways. For example the dispatch component can be configured to graphically display deployment options in a user friendly manner so that users can quickly and efficiently locate an XML based deployment file when deploying a computing architecture.

With continuing reference to and as described briefly above the manager component can be configured to create and or edit a deployment file that includes a number of deployment parameters and associated functions. The manager component can be configured to provide a consistent user experience when creating and maintaining deployment blueprints. A user can use the manager component to easily and quickly create update and otherwise interact with deployment blueprints. As described above once defined the dispatch component can be used to deploy the computing architecture defined by a particular blueprint.

In one embodiment the manager component can be configured as a software application and can be used in defining a deployment blueprint that is associated with a deployment of a number of computing devices. The manager component can be used to create and maintain an XML based deployment file associated with a blueprint. The XML based deployment file can be used by the dispatch component when deploying a number of computing devices according a defined deployment blueprint. For example a user can use the manager component to create an XML based deployment file including identifying computing devices packages certificates etc. to include as part of a deployment blueprint. The XML based deployment file can also be accessed or otherwise communicated to determine the number of computing devices associated with a deployment including the configuration of each computing device the software packages associated with each computing device etc.

The manager component can also be configured as a user interface UI and accessed using the computing device . The manager component can also be accessed locally or remotely. A user can use the manager component configured as a UI to interactively define a deployment blueprint such as a deployment blueprint for a testing cluster or debugging cluster for example. In one embodiment the UI can be configured as part of a web based service that users can access after providing proper credentials e.g. authentication etc. . The UI can be configured to present deployment parameters to a user in different ways. For example the UI can be configured to provide a graphical blueprint view allowing a user to drag and drop or cut and paste packages computing devices and other infrastructure as part of an interaction with a deployment blueprint.

As described above the manager component can be used to create an XML based deployment file that can include a number of deployment parameters and associated functions. For example a user can create an XML based deployment file for a test cluster wherein the XML based deployment file identifies a number of computing devices to be used for testing software packages to be included on each computing device certificates to use during various testing operations etc. The manager component can be further configured to enable a user to open view and validate XML based deployment files. For example a user can use the manager component to validate an XML based deployment file associated with a number of rule and or schema changes.

The manager component can also be configured to suggest corrective actions when an XML based deployment file is determined to be invalid or otherwise defective in some way. The manager component can also be configured to automatically take corrective actions when an XML based deployment file is found to be invalid or otherwise defective. Moreover certain procedures can be employed to control a check in and check out process associated with the use of an XML based deployment file. For example certain users may have check in and check out permissions while others do not. Once a XML based deployment file has been checked in the dispatch component can be used to deploy the computing architecture defined by the XML based deployment file.

In certain situations the manager component can be used to prevent a user or users from manually updating or changing an XML based deployment file. The manager component can also be used to include versioning and or historical information as part of the maintenance of an XML based deployment file. For example the XML based deployment file can include information associated with users who have opened and edited an associated deployment blueprint.

The manager component can be used to define an XML based deployment file for a number of computing devices to include different hardware and or software configurations. The dispatch component can then use or consume the XML based deployment file to deploy the computing devices to include the defined hardware and or software configurations. For example the dispatch component can use an XML based deployment file to deploy servers having different hardware and software configurations according to a number of deployment types. As further example the dispatch component can deploy common server types include SQL servers Content servers and web servers. The dispatch component can also be called to deploy middle tier and other components according to an associated blueprint.

In one embodiment the manager component can be used to define a kind of platform software that can be installed on an associated computing device. The manager component can also define a number of functions to be associated with a computing device. For example a user can use the manager component to define a number of functions which are used by the dispatch component when deploying one or more computing devices that include but are not limited to front end server for a web service with or without authentication front end server for a redirect service including client server redirect front end server for a research and reference service back end database server e.g. SQL server content server a search server a web server for certain tools e.g. IPO tools etc.

With continuing reference to the database component can be associated and in communication with the dispatch component and the manager component but is not so limited. The database component may be co located or remotely located. The database component or other repository e.g. file server s can be used to store information associated with a deployment blueprint and or users associated therewith. In one embodiment the database component includes a number of deployment files such as a number of XML based deployment files for example. For example a stored deployment blueprint in the form of an XML based deployment file can be called or otherwise accessed by the dispatch component from the database component when deploying a particular computing architecture. Deployment files can also be stored at other locations such as in a file server or in an associated network or networks for example.

The database component can also include a dynamic link library dll that includes a number of functions that are associated with a particular deployment file and or dispatch component. For example the dispatch component can access certain functions from the dll file when deploying a number of computing devices according to a particular XML based deployment file. The database component can also include information associated with reservation status deployment status availability status access credentials authentication information etc. In one embodiment the database component can also include the location e.g. stored as a path etc. of an associated XML based deployment file and any associated shipment files if available. In another embodiment the dll can be included on a computing device associated with the dispatch component .

Referring now to and according to an embodiment a block diagram depicts various functions that can be associated with and used by a dispatch application . The functions can be implemented as a number of APIs which are included as part of a data link library dll e.g. dispatch.dll . For example a user can use a Net programming language to consume and leverage the APIs. The dispatch application facilitates seamless automations including customizable UIs and or reporting. For example a user can use the dispatch application to monitor and save device states create and save plans create reports etc.

The various functions associated with the dispatch application can be implemented as a number of application programming interfaces APIs that can be used when deploying or preparing to deploy a particular computing architecture. In an embodiment various API functions described below can be exposed using a public class of a dll e.g. dispatch.dll . A dll can be consumed by the dispatch application and use user readable XML to perform various deployment and other actions. A number of functions related to deployment can be leveraged using a dispatch object model. Correspondingly and in accordance with an embodiment a number of functions can be associated with the dispatch application using an object model as follows 

A user or application can use the dispatch application in conjunction with a deploydb object when deploying a computing architecture according to a particular deployment file such as a Machine XML file for example. The deploydb object can be used to perform a variety of operations and a number of functions 

Impersonate function e.g. DPInst.deploydb.impersonate the impersonate function enables a user to pass a username and password with required access to override default access credentials such as a default username for example. For example the impersonate function can be used to enable a user to have multiple service accounts which can be used for different computing environments. Based on user requirements and a desired implementation an appropriate username and password combination can be selected and or created using the impersonate function . In one embodiment parameters associated with the impersonate function can include domain username and password. Default username and password will be used if not impersonated.

Load function e.g. DPInst.deploydb.load the load function can be used to load a deployment file e.g. a Machine XML file described below from a specified location. The load function can be used as part of validation to validate using a prescribed schema. The load function can also be used to validate designated device connections. In one embodiment parameters associated with the load function can include machine.xml and path.

Setlogging function e.g. DPInst.deploydb.logging the setlogging function can be used to set a type of logging required for a particular application. In an embodiment three logging settings are available basic medium and all verbose . Using the load function can be a prerequisite to performing logging including the use of a bike component. A bike component can be described as an agent that can be executed on each computing device in a network. In an embodiment the dispatch application can communicate a deployment plan to the bike component. The bike component can then download bits e.g. code content etc. from a centralized location to a local computing device and then can run an actual deployment. The bike component can create a log file termed a bike log to record deployment activities on the associated computing device. In one embodiment parameters associated with the setlogging function can include set and Bikelogatserver boolean . The bikelogatserver parameter can be used to communicate bike logs from agent machines to a dispatch device.

Instantiate function e.g. DPInst.deploydb.instantiate the instantiate function can be used to perform an instantiation action. Using the load function can be a prerequisite to performing instantiation. The instantiate function or instantiator can operate to add detail to a deployment specification. The instantiate function interacts with a configuration database. In one embodiment basic deployment directives include Install Property Genre Record Port and Wire. The use of the basic deployment directives included as XML is illustrated in the following example 

The configuration database can be included with a database component e.g. database component and can include data for multiple versions of packages so that the packages may be detected and managed concurrently. The configuration database can also be included on a dedicated computing device.

If the Version attribute is omitted from an Install element the instantiate function can select the highest version in the database. For example the versionless directive 

Instead of omitting the Version or defining an exact Version a user can restrict the Version by setting the MinVersion and MaxVersion attributes.

Savedatabase function e.g. DPinst.deploydb.savedatabase the savedatabase function can be used when saving one or more databases including all include files. A saved database can be evaluated before performing final deployment operations. Using the load function can be a prerequisite to saving a database. In one embodiment a parameter associated with the savedatabase function is file path including local and UNC along with target file type e.g XML .

Audit function e.g. DPInst.deploydb.audit the audit function or auditor can be used to identify which packages from the library exist on target computing devices. After identifying any packages the audit function operates to write the detected package identities back to a database. The dispatch application can use packages as an abstract container for changes to a state of a computing device. Packages can include identity including name version and language which can be used when planning or preparing a deployment. The audit function can use detection data provided as part of the package data.

That detection data can be used to specify how to detect a particular version of a package allowing each version of the package in the database to provide independent detection data. The detection data can be specific to an install handler for the associated package. For example the WINDOWS Installer handler uses the ProductCode GUID for detection. The audit function can operate to collect Detect elements for the entire library sort by handler and send the sorted Detect elements to the associated handlers on the target computing devices. Each handler can operate to reply with a list of Detected elements which the audit function can use to insert into a database under the audited computing device.

The audit function operates to read detection information from a loaded configuration database and can write results back to the database. The audit function can operate to communicate with target computing devices without altering a state of the computing device. Moreover the audit function can be run in isolation wherein the results may then be fed into subsequent runs using the dispatch application . In such an implementation the results may be persisted in an external database and extracted before running dispatch again. Alternatively an independent mechanism may be used to assess the state of a computing device. The results provided can be phrased in terms of package identities and added to the database provided to the dispatch application .

As described above the audit function can be used to audit devices listed in an associated deployment file e.g. Machine XML file . When used the audit function can operate to 1 create a delta of an actual state and a desired state and 2 create a plan to apply a delta on a target topology. Alternatively the audit function can be used to output an audit result as an XML file. Using the load function can be a prerequisite to using the audit function . In one embodiment an output parameter associated with the audit function is XML file path.

Allfunctions function e.g. DPInst.deploydb.allfunctions the allfunctions function can be used to synchronously execute the impersonation function load function setlogging function instantiate function and or the audit function . The allfunctions function can also be used to perform all associated executions therewith. In one embodiment the parameters associated with the allfunctions function include parameters associated with the impersonation function load function setlogging function instantiate function and or the audit function .

Execmdline function e.g. DPInst.deploydb.execmdline the execmdline function can be used to execute various functions as a command line by passing required parameters and or switches. In one embodiment the execmdline function uses the allfunctions function to perform the associated operations.

Clean function e.g. DPInst.deploydb.clean the clean function can be used to clean up parameters and other aspects associated with a deployment.

GetPlan function e.g. DPInst.deploydb.GetPlan the GetPlan function can be used to obtain plan outputs as XML. For example the dispatch application can create a deployment plan which is sent to a bike component for the actual deployment. The deployment plan can include a list of downloads and what action s to implement. Actions may be copy files execute msi etc. In one embodiment an output parameter associated with the GetPlan function is an XML file.

Execute function e.g. DPInst.deploydb.execute the execute function or executor can be used to deploy a computing architecture based in part on information associated with the deploydb object . Accordingly the execute function can execute a deployment plan. The format of the plan includes flexibility when generating plans.

In an embodiment a Run element provides a control structure and serves as a context for executing one or more tasks. Tasks can be ordered serially or run in parallel. Moreover tasks can be nested inside of other Run tasks to provide an elaborate control structure. For example the structure below downloads everything first and then performs an install 

The above context also can be used to include preconditions and thresholds to test before and or during execution. In an embodiment the execute function can be used to track maintenance windows failure rates network traffic machine performance etc. The execute function can then operate to make certain deployment decisions based on the tracked parameters. Moreover the execute function can be controlled to execute actions in any order and or one at a time so that certain tasks may be executed even though others are blocked.

The execute function can also operate to translate tasks in the execution plan into messages e.g. BMCP messages to send to target servers. For example tasks can be translated into the BMCP protocol to tune the SOAP XML according to the XPI expected by a bike handler. Alternatively a generic control structure may be used for dispatching messages to various targets. As noted above additional remote actions can be implemented. For example an implementation may communicate with load balancers run smoke tests to validate a deployment or trigger a notification and wait for an acknowledgment. The execute function can also operate to provide options for logging each remote action. For example the WINDOWS Installer handler can send back an entire install log as the install occurs. In one embodiment the impersonation function load function and setlogging function can be used before using the execute function .

As shown in a user or application can also use the dispatch application in conjunction with a plan object . The plan object can be used to load an existing plan from a specified directory wherein the plan can be based on a XML based deployment file e.g. Machine XML . The plan object can be used to perform a variety of operations which include a number of functions 

Uploadplan function e.g. DPInst.plan.uploadplan the uploadplan function can be used to upload a plan from a specified location or plan file such as a plan.xml file for example. In one embodiment a parameter associated with the uploadplan function is the plan xml parameter.

Executeplan function e.g. DPInst.plan.executeplan the Executeplan function can be used to deploy a computing architecture based in part on information associated with the deploydb object .

An application that is consuming the dispatch object model and associated functions may have access to the devices being deployed and to a definitive software library located on a file server or other location where the bits to be deployed can be located.

At the user can elect to choose another XML based deployment file for the deployment. The flow returns to if the user would like to add another XML based deployment file as part of the deployment. If the user does not want to add another XML based deployment file the flow proceeds to and the dispatch application can call dispatch.dll to use the associated dispatch functions see discussion of above . At the dispatch application operates to deploy the associated devices including the deployment parameters and associated functions as defined by the selected number of XML based deployment files.

At the user can assess the devices associated with the deployment to verify that the deployment is correct and what the user intended. If the deployment is not correct at the user can use a managing application and or dispatch application to correct any issues associated with the incorrect deployment and the flow returns to . If there are no issues with the deployment the flow ends and the user can use the deployed computing architecture for an intended use or uses.

Referring now to a flow diagram illustrates using a managing application to create a deployment blueprint for a computing architecture under an embodiment. In one embodiment a deployment blueprint is configured as an XML based deployment file that includes a number of deployment parameters associated with the particular blueprint. The term machine includes physical computing devices logical computing devices virtual computing device and other devices systems software and logical components.

As shown in the flow can begin from two starting points and but is not so limited. At a user can use the managing application to update a deployment blueprint for an associated computing architecture. As shown in the deployment blueprint file is referred to as a Machine XML file. The Machine XML file may be stored locally or remotely and accessed accordingly. In one embodiment the Machine XML file defines a number of deployment parameters and functions that are associated with a defined blueprint. The Machine XML file can include parameters associated with a number of defined elements attributes values etc. The Machine XML file can be used as a blueprint when deploying a number of computing devices according to a defined computing architecture.

At the user can use the managing application to locate and open also referred to as check out the associated Machine XML file. For example the managing application can present a number of Machine XML files to the user where certain Machine XML files are accessible have permissions and others are not no permissions . At the managing application checks to see whether the user has the proper access permissions to update the Machine XML file. For example the managing application can compare a user s credentials to credentials stored in a database or other repository. If the user does not have permission to update the Machine XML file at the managing application can operate to terminate the update session with an error message that informs the user that access is not permitted based on the user credentials or other permission parameters. Alternatively the user may view the Machine XML file as read only. If the user does have permission to update the Machine XML file the flow proceeds to described below.

A user can also use the managing application to create a deployment blueprint e.g. Machine XML file for an associated computing architecture at . At the user from as well can select from two different interactive views using the managing application. At the user has opted to use a drag and drop view to interact with the Machine XML file. Using this view the user can drag and drop select objects according to a desired computing architecture. For example a user can drag and drop machines dependencies sequences packages groups etc. using this view.

Alternatively at the user can opt to use a tree view to interact with the Machine XML file. Using the tree view the user can add and remove nodes such as machines dependencies sequences packages groups etc. for example. In one embodiment the managing application is configured to switch from the drag and drop view to the tree view by clicking a button or using CTRL and an associated key. In the views described above available computing devices packages etc. can be graphically presented to an authorized user for use in creating and or edited a deployment blueprint. Other views and interactive presentations are available and the embodiments and examples described herein are not intended to be limiting.

Once a user has elected a preferred view the flow proceeds to and the user has a number of available options to select from which results in the creation or generation of a deployment blueprint in the form of a Machine XML file. In one embodiment the number of available options corresponds with the creation or generation of a number of application programming interface API functions. Correspondingly the API functions can be encapsulated in a dll that can be installed on or included as part of a computing device wherein a number of applications including hosted applications can consume the associated functions. As shown in the user has a number of available API functions to select from which include but are not limited to Add Machine Remove Machine Add Dependency Remove Dependency Add to Sequence Remove from Sequence Add include File Remove include File Add Group Remove Group Update Machine Update Package Add Package Dependency Remove Package Dependency Delete Package Delete Include Add Group Genre Delete Group Genre Update Group Genre Add Group Wire Update Group Wire and Delete Group Wire etc.

Using the managing application a use can select from one or more of the available API functions which can be presented to the user based on the selected view. Once the user has selected one or more API functions for the deployment file the flow proceeds to and the number of selected API functions and other user actions are designated and saved to an associated Machine XML file. The Machine XML file can be stored locally or remotely for future use. At the Machine XML file is validated against an associated validation schema. As part of the validation process the Machine XML file can also be checked for other errors and inconsistencies. For example a number of validation scenarios can include validating to determine if string values are compatible with prescribed formats validating schema compatibility e.g. determine if defined machine XML is compatible with defined XML schema and validating to determine existence of packages e.g. can be defined by path to package . An example of a validating schema is described further below.

If the Machine XML file passes the validation process the flow proceeds to and the Machine XML file can be checked in for use in deploying the parameters and functions associated therewith and the flow ends at . If the Machine XML file does not pass the validation process the flow proceeds to and if enabled the managing application can apply an autocorrect process. If the autocorrect process is disabled the flow returns to and the managing application can operate to present a number of issues associated with the validation process to the user.

Correspondingly a user does not have to wait for a deployment to begin to determine if there are issues with a deployment blueprint. Thus the above described deployment process provides a preemptive solution which can ultimately save users time and operate to reduce issues when deploying a computing architecture. As an example the managing application can operate to suggest a number of corrective actions that a user can take to overcome one or more issues. The user can then use a suggested action for a validation issue. Once the user is satisfied with the changes including any corrections the flow again proceeds to as described above. On the other hand if the autocorrect process is enabled the managing application can operate to automatically correct any issues associated with the validation process and pass the changes on and repeat validation at .

In an embodiment various API functions described above can be exposed using a public class of a dll e.g. machinexml.dll . A dll can be consumed by the managing application e.g. as a UI to present user readable machine XML to perform various actions. A number of functions related to deployment can be leveraged using a machine XML object model.

In one embodiment a number of functions can be created or generated by the managing application using an object model as follows 

The open function e.g. MXM.open can be used to open any existing machine.xml files. A user may pass a local path universal naming convention UNC path or other designated path.

The validation function e.g. MXM.validation can operate to conform an XML file with a defined schema. For example the validation function can be used to ensure that machine XML files conform to a defined schema. In one embodiment the function returns a true indication if the file conforms with the defined schema otherwise the function operates to return a false indication and associated details. The validation function can be used in a variety of scenarios. For example the validation function can be used to validate whether string values are compatible with prescribed formats validate schema compatibility such as whether a deployment file is compatible with a defined schema and validate the existence of certain packages.

The update function e.g. MXM.update allows a user to save updated machine XML files after a required validation. In one embodiment the update function uses the machine path as a string parameter with an option to replace file or create a new file.

The add function e.g. Mxm.machine.add enables users or parent applications to add a machine to a machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The update function e.g. Mxm.machine.update enables users or parent applications to update existing machine information for an associated machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The delete function e.g. Mxm.machine.delete enables users or parent applications to delete a machine from an associated machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The add function e.g. Mxm.package.add enables users or parent applications to add a package to an associated machine. In one embodiment any dependency packages should be added before adding a main package. As described below once a dependency package is added a dependency function can be used to update the dependency package. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The update function e.g. Mxm.package.update enables users or parent applications to update a package of an associated machine. In one embodiment any dependency packages should be added before adding a main package. As described below once a dependency package is added a dependency function can be used to update the dependency package. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The dependency function e.g. Mxm.package.dependency enables users or parent applications to update a dependency in a package of an associated machine. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The remove dependency function e.g. Mxm.package.removedependency enables users or parent applications to remove a dependency in a package of an associated machine. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The delete function e.g. Mxm.package.delete enables users or parent applications to delete a package of an associated machine. In an embodiment one or more dependency packages are automatically deleted once an associated parent package is dropped. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The add function e.g. Mxm.include.add enables users or parent applications to add an include path to a machine XML file. The function can be called in conjunction with machine XML file update functions. The include path can then be incorporated into the resultant machine XML file. In one embodiment when the machine XML file is consumed for deployment an include path is expanded in a main XML file which contains all such includes and machine XML files. The main XML file is the source file for a deployment engine. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The update function e.g. Mxm.include.update enables users or parent applications to update an include path to a machine XML file. The function can be called in conjunction with machine XML file update functions. The include path can then be incorporated into the resultant machine XML file. In one embodiment when the machine XML file is consumed for deployment an include path is expanded in a main XML file which contains all such includes and machine XML files. The main XML file is the source file for a deployment engine. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The delete function e.g. Mxm.include.delete enables users or parent applications to delete an include path from a machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The group object provides for the grouping of machines from a configuration perspective. In one embodiment a configuration applied to a group will be applied to all the machines associated with the group.

The add function e.g. Mxm.group.add enables users or parent applications to add a group to a machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The update function e.g. Mxm.group.update enables users or parent applications to update a group of an existing or new machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The delete function e.g. Mxm.group.delete enables users or parent applications to delete a group from a machine XML file. Users can create a machine XML object and assign a machine XML file thereto before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

The add function e.g. Mxm.group.genre.add enables users or parent applications to add a genre that is to be associated with one or more machines. The genre can be described as an indexed array of records which hold data. Records are only necessary in the package to provide default values. A genre is a configuration item that may be applied on multiple machines. In an embodiment the genre can be stored in a registry and surfaced using a number of APIs such as Jukebox APIs for example. Users can create a machine XML object and assign a machine XML file thereto followed by a genre object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The update function e.g. Mxm.group.genre.update enables users or parent applications to update a genre that is associated with one or more machines. Users can create a machine XML object and assign a machine XML file thereto followed by a genre object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The remove function e.g. Mxm.group.genre.remove enables users or parent applications to delete a genre that is associated with one or more machines. Users can create a machine XML object and assign a machine XML file thereto followed by a genre object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameter for this function 

When instantiating the associated records can be given Index attributes unless explicitly provided and default values from the package are provided for any values not given at the Machine or Group levels. In one embodiment genres that are explicitly declared for a package are copied from a Group declaration.

In the above example records in the levels genre are taken from the delivery group. The DomainName record was defined at the Machine level and overrides a default given in the package and the verbose record assumed the default specified in the package.

The add function e.g. Mxm.group.wire.add enables users or parent applications to create a new wire or connection string information associated with a component such as a backend component for example of an associated machine XML file. In one embodiment the connection string information can be stored in a registry and surfaced using a number of APIs such as Jukebox APIs for example. Users can create a machine XML object and assign a machine XML file thereto followed by a wire object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The update function e.g. Mxm.group.wire.update enables users or parent applications to update an existing wire or connection string information associated with a component of an associated machine XML file. Users can create a machine XML object and assign a machine XML file thereto followed by a wire object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

The remove function e.g. Mxm.group.wire.remove enables users or parent applications to remove an existing wire or connection string information associated with a component of an associated machine XML file. Users can create a machine XML object and assign a machine XML file thereto followed by a wire object for an associated group before calling this function otherwise the function may result in error. In one embodiment the managing application is configured to pass the following parameters for this function 

Ports and wires can be referred to as connection strings which can be set at runtime through Jukebox for example . For example the settings can be accessed through the Jukebox as incoming ports include an indexed array of wires including connection strings to other machines.

Ports are similar to genres. Ports can be indexed can include default values defined in the package and can be specified at the Machine or Group level. Ports differ from genres in that they have additional attributes including Protocol Server External and Postfix attributes. The attributes can be used to generate content in intelligent ways.

In one embodiment any given port is either a client or a server of a protocol. When server ports are instantiated they get populated with a connection element that contains the connection string by which clients access an associated port. These strings can be built according to the Protocol attribute see Table below and a machine name wherein the Postfix attribute can be appended to the text.

The Connection element can be used internally for a subsequent phase of the process in which client ports can be instantiated and wired up to server ports. In one embodiment when a client port is instantiated the Wire elements within it are resolved into connection strings according to following rules 

3. If the Server attribute is omitted search machines in the Group hierarchy for the given ServerPort.

The backend.unc port inherited its connection string from the setting in the delivery Group. Without that setting it can inherit the default string provided in the package data. The backend.sql port was matched to the server port on delivery1 and the connection dropped into its Wire element.

In one embodiment a wiring algorithm can first search in the current Group. If no matches are found the algorithm can search for a match in the hierarchy including all matches at an associated depth.

Ports can be placed at the Machine or Group levels. Ports placed at the Group level are inherited by Machines with Packages that include those Ports. In that inheritance any Wire elements inside the Group can be inherited as well.

Wire elements can also be placed outside of Ports directly beneath a Machine or Group element. In the Machine case the Wire applies to all Ports instantiated on that Machine. In the Group case the Wire applies to all Ports instantiated on all Machines in the Group. An empty Wire in the global group shown below can cause Wires to be inferred for all ports.

According to one embodiment the following schema can be used to present a number of deployment parameters and or options to a user when defining a deployment blueprint for an associated purpose. For example the manager component can use the schema when presenting deployment options to a user. As further example the manager component can include the schema for use in validating a deployment blueprint e.g. Machine XML files .

A number of examples described below illustrate using a deployment blueprint file such as an XML based deployment file.

Richard a tester wants to add a couple of computing devices to his test cluster TC. The computing devices have been prepped and are ready for deployment. He launches the manager component and opens the XML based deployment file for TC. After opening the deployment file for TC Richard adds computing device IPOIWTST and computing device IPOIWTST and also designates the associated packages to be installed on each computing device. The manager component updates the deployment file for TC with the associated modification. When deployment begins computing device IPOIWTST and computing device IPOIWTST will receive new bits and configured roles based on the information contained in the modified deployment file for TC.

Julia would like to add a new eight box cluster for an online service package. She launches the manager component and adds eight boxes using the associated setup wizard. Thereafter Julia creates a machine mapping package a dependency mapping package defines installation sequencing and defines installation dependency. Thereafter Julie clicks Create and a browser create and save file dialogue map appears that allows her to save the deployment blueprint as an XML based deployment file e.g. machine.xml .

Peter has just updated a production machine XML Prod.xml file to add a couple of new packages. He launches the manager component opens the Prod.xml file and clicks a Validate button of the user interface. Thereafter the manager component returns a validation message that an attribute is missing from one of the machine tags including the pertinent information so that Peter can correct the issue. Armed with the knowledge of the validation issue Peter uses the manager component to edit the Prod.xml file and makes the appropriate change. Peter clicks the Validate button again and the manager component returns a validation message of no errors. Once validated Peter is ready for deployment using the validated Prod.xml file for his blueprint.

An application online test team wants to automate deployment on their test clusters. They need to control deployment related functions like scheduling logging based on configuration etc. and pick a job from a particular location. They also want to customize the dispatch application UI for reporting and secure it just for their management. To accomplish the aforementioned functionality they use the dispatch object model described above to create a tool that enables them to visually control deployment store deployment history job tracking and several other customized functions. Now for deployment instead of engaging their ops team they use the created tool. They also use the tool for automatic and bulk deployment and in build verification test BVT to find issues at an early stage of service development.

Embodiments described herein can be used when defining and or using a blueprint associated with the deployment of a number of computing devices. Various embodiments provide a quick and efficient way to define and or use a blueprint associated with a computing architecture. For example a user can define a blueprint for a cluster of servers wherein the cluster can be deployed according to the defined blueprint. A user can define a blueprint which then can be used to deploy computing devices for testing code and programs debugging code and programs and or performing other configuration testing and computing operations. For example a number of computing devices can be deployed according to a defined blueprint including a defined operating system OS defined middleware and or defined test bits in accordance with particular deployment parameters.

Embodiments enable users and applications to create and deploy a blueprint of a logical cluster edit view existing blueprints suggest corrective actions take corrective actions validate packages and perform other deployment actions. An associated schema that is compatible with service modeling language SML and other schema types can be used in conjunction with the XML based schema described above. In one embodiment an XML based schema can be used to transition to an SML based schema thereby providing an avenue for integration with a dynamic systems initiative DSI such as when defining a design state of a data center for example. Accordingly an SML based deployment file can be derived from an XML based deployment file by using an XML based schema to transition to an SML based schema. The dispatch application can use the SML based file when deploying a computing architecture.

Referring now to the following discussion is intended to provide a brief general description of a suitable computing environment in which embodiments of the invention may be implemented. While the invention will be described in the general context of program modules that execute in conjunction with program modules that run on an operating system on a personal computer those skilled in the art will recognize that the invention may also be implemented in combination with other types of computer systems and program modules.

Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

Referring now to an illustrative operating environment for embodiments of the invention will be described. As shown in computer comprises a general purpose desktop laptop handheld or other type of computer capable of executing one or more application programs. The computer includes at least one central processing unit CPU a system memory including a random access memory RAM and a read only memory ROM and a system bus that couples the memory to the CPU . A basic input output system containing the basic routines that help to transfer information between elements within the computer such as during startup is stored in the ROM . The computer further includes a mass storage device for storing an operating system application programs and other program modules.

The mass storage device is connected to the CPU through a mass storage controller not shown connected to the bus . The mass storage device and its associated computer readable media provide non volatile storage for the computer . Although the description of computer readable media contained herein refers to a mass storage device such as a hard disk or CD ROM drive it should be appreciated by those skilled in the art that computer readable media can be any available media that can be accessed or utilized by the computer .

By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer .

According to various embodiments of the invention the computer may operate in a networked environment using logical connections to remote computers through a network such as a local network the Internet etc. for example. The computer may connect to the network through a network interface unit connected to the bus . It should be appreciated that the network interface unit may also be utilized to connect to other types of networks and remote computing systems. The computer may also include an input output controller for receiving and processing input from a number of other devices including a keyboard mouse etc. not shown . Similarly an input output controller may provide output to a display screen a printer or other type of output device.

As mentioned briefly above a number of program modules and data files may be stored in the mass storage device and RAM of the computer including an operating system suitable for controlling the operation of a networked personal computer such as the WINDOWS operating systems from MICROSOFT CORPORATION of Redmond Wash. The mass storage device and RAM may also store one or more program modules. In particular the mass storage device and the RAM may store application programs such as a dispatch application a word processing application a spreadsheet application e mail application drawing application etc.

It should be appreciated that various embodiments of the present invention can be implemented 1 as a sequence of computer implemented acts or program modules running on a computing system and or 2 as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the invention. Accordingly logical operations including related algorithms can be referred to variously as operations structural devices acts or modules. It will be recognized by one skilled in the art that these operations structural devices acts and modules may be implemented in software firmware special purpose digital logic and any combination thereof without deviating from the spirit and scope of the present invention as recited within the claims set forth herein.

Although the invention has been described in connection with various exemplary embodiments those of ordinary skill in the art will understand that many modifications can be made thereto within the scope of the claims that follow. Accordingly it is not intended that the scope of the invention in any way be limited by the above description but instead be determined entirely by reference to the claims that follow.

