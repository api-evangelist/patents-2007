---

title: Management of drawing resources in a native code portion using cached drawing parameters
abstract: Techniques for management of drawing resources are described. In an implementation, a reference count numeral may be associated with a drawing resource stored in cache memory. One may be added to the reference count numeral each time a new drawing resource is added to memory. In addition, one may be removed from the reference count each time an existing drawing resource is removed from the memory. Also, the drawing resource may be maintained in the cache memory when the reference count numeral is greater than zero.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802056&OS=07802056&RS=07802056
owner: Microsoft Corporation
number: 07802056
owner_city: Redmond
owner_country: US
publication_date: 20070702
---
This application is a divisional of and claims priority to U.S. patent application Ser. No. 10 293 448 now U.S. Pat. No. 7 240 346 filed on Nov. 13 2002 the disclosure of which is incorporated by reference herein.

When executing code in a virtual machine VM environment a user application program can run on different platforms. In such VM computer environments native resources are typically allocated using system calls. In many computer based drawing programs a new drawing resource such as a brush or a pen is produced each time a new drawing object is created. Often it is easy for developers to neglect the effects on the processor speed of producing a large number of drawing resources in drawing programs.

Managing each drawing resource generates system calls across a VM native boundary between the managed code portion and the native code portion. System calls across this VM native boundary demand considerable processor effort due to the varied code translations that may be necessary for virtual machines to comply with different computer platforms and languages as well as the considerable amount of data that precisely describes each drawing resource. The garbage collection associated with removing the large number of drawing resources is considerable since each drawing resource has to be consciously removed individually or alternately the drawing resources are removed after some prescribed period. If the drawing resources are removed after some period then there may be a considerable number of drawing resources waiting for their duration to be removed. Storing such a considerable number of drawing resources may make such tasks as drawing programs slow in drawing programs. Additionally present computer drawing programs typically produce multiple concurrently saved copies of the drawing resource. For example as the drawing resource is transferred between the VM the native OS and the OS itself a copy of each drawing object is stored in memory associated with each location.

Drawing programs that run on such computer environments as stand alone computers networked computer environments and computer devices typically inefficiently manage such drawing resources but such inefficiency is typically ignored due to the large processing abilities of these computer environments. Smaller and less powerful memory constrained and processor constrained devices i.e. resource constrained devices such as PDA s cellular telephones computer devices embedded devices microprocessor devices and microcomputer devices are becoming increasingly popular. Resource constrained devices rely on more limited software and operating systems than those applied to full size computers. Applying a large number of system calls to resource constrained devices commonly makes the system prohibitively slow to perform many drawing functions. The code transitions necessary for system calls in resource constrained devices that have been produced between the native code portion and the managed code portion in virtual machines especially for demanding programs as drawing programs are so processor intensive that the processor and memory resources become highly strained.

It would therefore be beneficial to improve the management of drawing resources within computer environments.

This disclosure relates to a method and associated system for drawing within a computer environment with a drawing resource.

In one aspect the computer environment includes a managed code portion and a native code portion. The computer environment compares a draw call value being passed from the managed code portion to the native code portion with a stored drawing resource value stored in the native code portion. If the draw call value is the same as the stored drawing resource value then the system is already configured to draw using the stored drawing resource onto a native drawing surface included in the native code portion using the stored drawing resource. If the draw call value is not the same as the drawing resource value then a new drawing resource is created in the managed code portion and that new drawing resource is selected into the native drawing surface.

In another aspect a method of communicating between the managed code portion and the native code portion includes transmitting a drawing resource feature portion from the managed code portion to a native code portion. The data associated with the entire drawing resource does not have to be transmitted. Managing the drawing resources in native code reduces the number of native drawing resources needed to be managed by the native OS and reduces the number of system calls across the VM native boundary between the managed code portion and the native code portion. This reduction in the number of system calls results in increases in efficiency and speed.

Often software developers wish to allow users to draw objects bar charts figures etc. using drawing resources in an efficient manner. In drawing programs drawing resources draw using drawing primitives such as lines rectangles etc. Drawing resources such as pens or brushes each have drawing parameters that may include one or more of color weight style and gradient. The drawing resource parameters relating to text include for example color font size and style. This disclosure describes a drawing resource in which the user can control color though it is understood that using other parameters in any drawing resource is within the scope of the parameters. One embodiment of drawing resource that is managed within a computer environment is illustrated in which creates a drawing image on a drawing surface that is described subsequently relative to .

In this disclosure the term drawing refers to programs and processes e.g. software and or firmware such as drafting font painting graphics etc. that allow users to generate and or manipulate displayed objects.

The embodiment of computer environment utilizes a virtual machine VM architecture to run on different platforms i.e. interface having different operating systems and different application programs . The VM uses a network framework such as included in Java or the .NET computer software produced and distributed by Microsoft Corporation . The computer environment comprises an operating system OS and a computer or hardware as described below. In one embodiment a cache which forms part of the native portion stores data from the system calls that is associated with one or more varied drawing resources. The user interface of the VM is intended to be small and performance directed as to user input and how it displays information on the screen. The goals of the VM include enhancing the size performance and flexibility of the drawing program.

Though the concepts described here are applicable to all computer environments in general including laptops personal computers networks mainframes etc. they are especially beneficial to such resource constrained devices that have a relatively small processor and or memory as PDA s cellular telephones computer devices embedded devices microprocessor devices and microcomputer devices. To provide some scale such resource constrained devices are less than 1 20of size of many desktop or laptop computers and often less than 1 60 . The relatively small size and somewhat simplified operation of the resource constrained devices dictate that the designers program effectively and in a manner that complies with platform guidelines.

The computer environment includes a virtual machine VM which includes an application program and a managed code portion a native code portion and an operating system OS . The managed code portion and the native code portion contribute to a managed execution process for the drawing program. The native code portion sits directly on the OS and communicates using the native code language of the OS. Therefore the native code portion compiles for the OS directly. As such the native code portion codes in such native computer languages as C C Basic etc. which the OS can handle. The native code portion contains such features for example as a just in time JIT compiler a class loader a garbage collector an execution environment and or an interpreter.

The managed code portion sits on top of the native code portion . The managed code portion contains a variety of class libraries that are utilized by the application program. One example of a class library that is included in the managed code portion is a graphic user interface GUI code library which may be coded in byte code language BCL which is an intermediate language between the language of the application program and that of the native code portion . The GUI library largely determines the characteristics of the interaction between the user of the computer environment and the computer environment and also determines the types of experience that the user will have when using any particular application program.

One embodiment of the disclosure relates to decreasing the amount of data associated with signal calls and more particularly draw calls. Instead of each system call containing the full amount of data necessary to describe the drawing resource one embodiment of the system call contains a brief description of one characteristic of the drawing resource such as color. as described below illustrates storage of the red green and blue RGB color values. In this disclosure brief system parameter calls are system calls that contain characteristic parameter information relating to color width and or other characteristics of the drawing reference. For example a brief draw call is called a draw parameter call. In general system parameter calls are easier to formulate than system calls due to their shorter length. Additionally characteristic values e.g. RGB values stored in system parameter calls are easier to compare with other values process and or store than the values stored in system calls due to the smaller data size often 32 bit or less . By comparison complete system calls are often four 32 bit integers with each integer representing one of red green blue and alpha. It is the overhead of the custom marshalling non base system type e.g. color vs. integer that is actually the cost. It is especially beneficial to have system parameter calls traverse the boundary between the native code portion and the managed code portion due to the smaller dimensions and ease of translating between the different codes compared to system calls.

The user interface UI libraries commonly call code using system codes from a managed code portion through to the native code portion to the operating system. Such system codes can be used to perform relatively low level functionality as drawing and window management. The managed code portion is in the language of the user application program and the intermediate language.

The identity of certain VMs is evident from the output. For example when a Java applet runs a skilled user or developer can positively identify it as a Java applet. Other embodiments of VMs by comparison are seamless and consistent with the native device application program. A pocket PC application running on the same VM therefore looks and feels differently from a smart phone application or an embedded controller application. As such the appearance and characteristics of each application program that runs on each respective OS is primarily determined by the developer of that particular application program and not the particular VM. Each application program looks and feels like the application program as developed by the developer for the OS .

The application or application program is typically programmed by a code developer to provide the functionality of the computer environment . The developer typically programs the code for the application program and has the program compiled loaded and linked to create the executable file .exe for the application program. The .exe file is executed by the user of the computer environment to run the application program and therefore causes the application program to perform as desired by the user.

As illustrated in the GUI library the abstract graphics layer AGL and a user interface UI code layer are contained within and associated with the managed code portion the native code portion and the operating system respectively. As such system parameter calls that are generated by the application program e.g. by user input or program libraries are transmitted through the GUI library of the managed code portion to the AGL of the native code portion and to the UI layer of the OS . Similarly certain system parameter calls that are generated by the OS are transmitted through the UI layer to the AGL in the native code portion to the GUI library of the managed code portion and to the application program .

Greater interoperability between networked computer devices and or environments enhances the users and developers experience of drawing programs and increase the acceptance of drawing programs that run on stand alone computers and on such networks as the Internet intranets local area networks LAN and wide area networks WAN . The computer environment generally allows for such interoperability for many different networked computer devices such as personal computers telephones workstations PDAs embedded controller devices etc. that have different operating systems and do not necessarily communicate or interface well. Additionally the computer environment effectively displays data originating from different drawing programs that run on the same or different computers. As such much of the data prepared by one application program or operating system and then processed and or stored by many network servers can be considered images which should be able to be effectively used by another application program or OS.

A user or software developer of the computer environment shown in can create a drawing resource within the AGL in the following exemplary manner. A drawing resource that is created has to go through certain processes as described below before it can be drawn . The drawing resource has to be drawn to be visible over a display of the computer environment . In the computer environment the drawing resources are drawn in the native code portion and or the OS . An application drawing surface is initially created by the user or developer interfacing with the application program e.g. in source code XML or another programming language . Each application drawing surface can be considered as a window or analogous to a piece of paper with similar attributes to a window that will be displayed over the window based OS . At the level of the OS the drawing resource is positioned to draw at a location on the OS drawing surface .

For the purpose of this disclosure it is important to differentiate creating a drawing resource from drawing with a drawing resource. A drawing resource is created when it is initiated in the managed code portion . During creation if the drawing resource is created it will neither be realized in the OS nor will it appear on the display of the computer environment. When a drawing resource is used described in a draw parameter call being sent from the managed code portion to the native code portion the drawing resource can be displayed on the display of the computer environment because it is contained in the native code portion .

One embodiment of the managed code portion as illustrated in includes a VM drawing specification object and a VM drawing object which are both in the managed code . The VM drawing specification object contains sufficient information to produce the drawing specification object in managed code and a native drawing object . The native code portion includes the native drawing object which is in the native code. When the user code creates a drawing resource in the managed code portion as shown in the object characterizing the drawing resource exists in the managed space. Once the drawing resource is used in a draw parameter call the value of the object is passed to native code portion and the native drawing object is not marshaled. The VM drawing specification object as illustrated by the information contained in indicates that a rectangle will be drawn with brush b with coordinates 0 0 10 10. The draw parameter call that transfers data from the managed code portion to the native drawing object of the native code portion extracts a color value and conveys the color value to the AGL of the native code portion. The native drawing object in the AGL contains the characteristic parameter e.g. color information and not other information that clearly defines the characteristics of the drawing resource. As such draw parameter calls convey color information but not the other information about the drawing resources.

The cache in the AGL that contains one or more drawing surfaces exists in native code portion . In one embodiment the cache contains a first cached value for the last used drawing resource e.g. a red pen while the cache contains a second cached value for each recently used drawing resource that contains different information e.g. red pen and black pen . The cached value stored within the AGL may be null if the particular drawing resource is being used for the first time.

To illustrate more about system parameter calls and drawing using drawing resources within one embodiment of the drawing program run on the computer environment assume that the following commands are the requested inputs by the user of the computer environment 

These three commands cause one red rectangle and two red circles to be drawn on the OS drawing surface . Instead of drawing with three distinct drawing resources e.g. red brushes or pens using the associated draw parameter calls to produce the one rectangle and two circles the AGL in the native code portion creates a single red drawing resource that is used by the OS to draw the rectangle and the two circles on the OS drawing surface .

The draw parameter call travels from the application program via the managed code portion and the native code portion and to the operating system each time a drawing resource is drawn. Transmitting a large amount of data as associated with the prior art system calls compared to the smaller amount of data associated with the system parameter calls or draw parameter calls between the managed code portion and the native code portion is a processor taxing event considering the code difference and the associated language translation between the managed code portion and the native code portion . As such reducing the data contained in at least some of the draw parameter calls diminishes the processor and memory load applied to the computer environment which is especially important for resource constrained devices.

In general data relating to the drawing resources drawing surfaces and the associated system draw parameter calls migrate from the application program to the operating system as illustrated in . Such migration of data in system parameter calls flow from the respective application drawing surface and application drawing resource in the application program to the respective managed drawing resource and the managed drawing surface not shown in the managed code portion and to the respective native drawing resource and the native drawing surface not shown in the AGL of the native code portion . The characteristic data e.g. color information of the native drawing resource is applied to the respective OS drawing surface and the OS drawing resource within the operating system . System parameter calls that travel from the operating system to the application program pass through similar components in the reversed direction.

To reduce the amount of data traveling between the application program and the native code portion the number of system calls is reduced in system parameter calls and or the amount of data contained within each system call is reduced for each system parameter call. In one embodiment one integer packed that represents the color value 8 bits r g and b potentially alpha as well 32 bits is passed instead of a custom type that needs to be marshaled to the native representation ie 

Such reduction in the amount of data transferred in system parameter calls is especially important to improve operational characteristics of resource constrained devices. Though less data is transferred across a VM native boundary between the managed code portion and the native code portion the data transferred within the system parameter call is sufficient to determine whether the drawing resource being transmitted within the system parameter call contains the same or a similar parameter e.g. is red in color to the drawing resource presently contained in a memory cache location. The term similar is used since slightly different parameter values that likely appear identical on the display of the computer environment are within the scope of the present invention. For example two slightly different RGB values while literally different from each other may be close enough to produce indiscernible differences when displayed and therefore be considered substantially the same. Additionally different computers that are communicating with each other or different application programs may not be capable of transmitting the same value and therefore approximate values can be used.

If the drawing resource in the system parameter call does result in a similar parameter within a drawing resource stored in the cache in the AGL then the system parameter call and the associated data corresponding to the drawing resource will not migrate to the OS and the logical representation of the drawing resource within the cache more specifically the current cache value shown in in the AGL will be maintained in the cache. If by comparison the drawing resource in the system parameter call does not contain a similar parameter to the drawing resource in the AGL then the system parameter call and its associated data will migrate to the OS and the logical representations of the two drawing resources will be stored as the current cache value within the AGL .

During the system parameter call the managed code portion in byte code language system parameter calls across the VM native boundary to the AGL to draw the red rectangle and two red circles. The managed code portion parameter calls to the AGL to draw a red rectangle when the managed code portion attempts to draw using the first red drawing resource in the OS . The AGL then initiates logical representations of both the AGL drawing surface and the AGL drawing resource within the AGL . The AGL drawing resource is the logical representation of the OS drawing resource and contains e.g. color information that can be utilized by the OS drawing resource. The OS drawing resource can be considered as the actual drawing resource residing within the OS . The characteristics of the OS drawing surface are provided by the logical representation of the AGL drawing surface in the AGL .

For each drawing resource that is created and is used to draw as the OS drawing resource the computer environment follows the following method. If the user wishes to create a drawing resource of the same color as one already created the previously created drawing resource of the same color which is logically stored in the AGL as the logical representation of the drawing resource can be used to create the OS drawing resource .

During the drawing resource control method the language relating to the parameter calls is maintained in native code portion . As such the code representing the drawing resource object need not be translated as the drawing resource object is transferred between locations under the control of the VM within the native code portion and the native OS within the native code portion . The translation effort and time is thus reduced as the drawing object is transferred between the influence of the VM and the influence of the native OS. The drawing resource control method as shown as a method in and and also relative to the AGL in occurs at draw time i.e. run time .

The functionality of multiple drawing resources can be provided using a single drawing resource provided at least one parameter of the large number of drawing resources matches that of the single drawing resource. As such for each drawing surface if you use the same drawing parameter e.g. color in different drawing resources the program does not have to re create the drawing resource each time a new drawing resource is created. Instead a single drawing resource can provide the functionality of all of the drawing resources in any drawing surface that has the same parameter. The functionality of the drawing resource is provided by caching the parameter s of the drawing resource in the cache located in the AGL . At run time the drawing resource exists as a lightweight process model. In a single process of one execution environment multiple application programs can run. If multiple application programs are running at a single instant then the computer environment can share drawing resources.

The drawing resource control method of and as read in conjunction with the embodiment of the AGL shown in provides one embodiment by which drawing resources are efficiently created and maintained so a drawing program can be utilized without creating an excessive number of drawing resources to store in the OS .

The description of the drawing resource control method relates to and . As illustrated in there are two locations that serve as the cache that are both contained within the AGL. First there is a current RGB cache that contains the current characteristic value e.g. color of the OS drawing resource . Second there is a global cache that contains the stored characteristic value of the drawing resources that can be accessed and used to draw without requiring another draw call from the managed code portion to the native code portion . A pointer to the global cache provides one embodiment by which the plurality of drawing resources within the AGL can be accessed. In the drawing resources and are displayed as being stored in the global cache in the form of a linked list that uses pointer technology. The global cache however can be arranged in any manner that permits storage retrieval and other management of the drawing resources and such as database tabular and other known data storage techniques.

In and if a drawing resource can be located within the current RGB cache in the AGL that is sufficiently similar to a new drawing resource that is transmitted from the managed code portion then the existing drawing resource in the native code portion can be used and a new drawing resource does not have to be created.

One embodiment of the drawing resource control method which occurs primarily in the native code portion starts with a draw parameter call value being passed from the managed code portion to the native code portion during the draw parameter call. In the current cached value which is stored in the current RGB cache that represents the characteristic color of the currently used drawing resource is compared to the draw value received in the draw parameter call. If the current cached value in the current RGB cache is the same as the received draw value in decision then the drawing resource control method performs a draw operation in using the drawing resource defined by the cached characteristic color value contained in the OS drawing resource as reflected by the current RGB cache .

If in decision the cached value in the current RGB cache differs from the received draw value contained in the draw parameter call the drawing resource control method continues to . In the portion of the drawing resource control method that follows decision an AGL drawing resource as shown in either has to be found in the global cache or generated. In the AGL looks in the global cache within the AGL for a stored cached value that contains characteristic parameter information that is stored in a configuration similar to as shown in corresponding to all the drawing resources that can be accessed within the native code portion.

The drawing resource control method continues to decision . If the AGL determines in decision that there is a cached value within the global cache that equals or is suitably close to the received draw value contained in the draw parameter call then the AGL uses the value stored in the global cache to find the drawing resource. The process of finding the drawing resource uses the value stored in the global cache to access the corresponding OS drawing resource in which the drawing resource control method continues to as described below. If it is determined within the decision that there is no cached value within the global cache that equals or is suitably close to the received draw value contained in the draw parameter call then the drawing resource control method continues to in which the computer environment starts to create a new AGL draw resource. Following the drawing resource control method then continues to in which the AGL draw resource created in is added as the current cached RGB value shown in . As such any further draw resource creations will detect the draw resource created in and as having current cached RGB value .

The drawing resource control method continues to following either or as described above in which the reference count of the item in the cache is increased to comply with the addition of the native draw object in the global cache . In one embodiment the reference count is used to indicate whether a particular drawing resource is being actively utilized within a reasonable time frame and therefore whether the system should allocate the necessary memory resources to maintain the drawing resource or whether the drawing resource should be destroyed. There are a variety of other embodiments of counting mechanisms that may be used to accomplish the same result. When a particular drawing resource is no longer needed it should be destroyed so that the system can use that memory for other purposes. The particular time frame selected to return a drawing resource as active can vary depending on the particulars of the drawing program the designer s wishes and the particulars of the computer environment . Associating the reference count with drawing resources such as pens brushes and fonts acts to ensure that similar drawing resources don t have to be created and or stored for each drawing resource object.

An object s reference count relates to the number of times that a similar object has been requested. Each time an object is requested the reference count is incremented. An application releases an object when that object is no longer needed thereby decrementing the reference count shown in . As long as the reference count is greater than zero the object remains stored in the memory. An AGL object reference count is decremented when the managed object counterpart is finalized during GC or manually disposed of. That s the only time the reference count goes down. In one embodiment the AGL object is often maintained with a reference count equal to 0 until the application reaches the UI idle state defined to be the app state when there s no message pending in the message queue or there s GC memory pressure. The user does not need to know the reference count of an object. As long as the object s interfaces are obtained and released properly the object will have the appropriate lifetime.

The number of drawing resources stored in the native code portion can be controlled by cleaning each drawing resource from the native code portion i.e. the cache in the AGL when the reference count equals zero. In one embodiment each drawing resource in the native code portion can be removed if the user does not perform some action indicating user activity relative to the drawing resource for example the user does not touch the keyboard and or use the mouse for a second .

The drawing resource control method continues to decision in which an OS drawing resource is accessed or created using the draw value contained within the stored or created AGL draw resource . The draw value is contained as the characteristic RGB value stored in the global cache in the AGL draw resource . The characteristic RGB value can be stored as a 32 bit value as illustrated in and therefore the ease of transfer of the characteristic RGB value is relatively easy. The OS drawing resource by comparison is a full drawing resource compared to the drawing resource parameter string used in the AGL and described below relative to since it contains the necessary data to draw on the OS drawing surface .

The drawing resource control method continues to in which the OS drawing resource is selected by the user to draw on the OS drawing surface as illustrated in and . Each OS drawing surface may be associated with a plurality of OS drawing resources that have a different color or other characteristic value . Each OS drawing surface may appear on the display of the computer environment as a window that may be similarly interfaced with such as other word processing spreadsheet or other application programs. A single brush pen or font stored in the global cache in the AGL can be accessed and selected to draw into multiple drawing surfaces simultaneously.

The drawing resource control method continues to in which the characteristic RGB color stored in the current RGB cache which contains the draw characteristic value stored in the AGL is updated with the new RGB characteristic value. This ensures that the current RGB cache in the AGL contains the RGB characteristic value corresponding to the most recently selected OS drawing resource .

The updated cached RGB characteristic value can be communicated between the managed portion and the native portion or within either portion as a single cached red green blue RGB value which may be 32 bits 64 bits etc. . The data size of the cached RGB value which stores characteristic information of the drawing resource is considerably less than the data size that would store the OS drawing resource itself. For example each time a user generates a system parameter call relating to a drawing resource before a new drawing resource object is created the drawing resource control method determines whether a sufficiently similar drawing resource which would provide a similar drawing operation has previously been created and is stored within the native code portion .

If a sufficiently similar OS drawing resource has been created and is stored within the native code portion then that previously created drawing resource is used instead of creating a new OS drawing resource from scratch. As such the number of system parameter calls associated with creating a new drawing resource is reduced. As illustrated in the AGL includes the pointer that points to the location in the global cache where one or more native drawing resource objects and are stored. Each native drawing resource objects and includes a reference count location.

Since the logical representation of the drawing resource containing the RGB value can be fully described with considerably less data than the full OS drawing resource using this technique results in a quicker production of the OS drawing resource once the managed code portion requests the production of the OS drawing resource than in prior systems that must create an entirely new drawing resource in the operating system and transfer the data associated with creating the pen . As such the present system can use a just in time JIT compiler to transmit the draw parameter call. The performance of the JIT compiler is improved when only a limited amount of data is being transferred and the transferred data is associated with a previously compiled drawing resource. The effective use of JIT compilers not only improves the performance of resource constrained devices such as PDAs embedded devices microprocessor based devices and the like but also provides a considerable performance enhancement in personal computers laptops and other full size computer environments .

By storing only one drawing resource for each one of or a plurality of the drawing resource of the same color that were created in the managed code portion in the cache of the AGL the amount of data contained in each of the system parameter calls from the managed code portion to the native code portion is greatly reduced compared with system calls.

Garbage collection is simplified by the use of drawing resource control method due to limiting the actual number of OS drawing resources that are created. In prior systems each draw call to the OS would result in the creation of a new OS drawing resource regardless of whether there is already an OS drawing resource of the same color in the OS . As such there may be hundreds or even thousands of OS drawing resources of the same color stored in the OS . The drawing resource control method limits the number of OS drawing resources of the same RGB color value to one. In even memory constrained devices there is no need to garbage collect one OS drawing resource for each color which represents a relatively small amount of data. As such the garbage collection task is considerably simplified.

Considering that in complex drawing programs such as CAD CAM many users create hundreds or even thousands of drawing resources across multiple OS drawing surfaces the reduction in the number of system calls by the use of system parameter calls which contain less data greatly diminishes the number of code transitions across the VM native boundary between the managed code portion to the native code portion . This diminution in the number of code transitions often reduces the processor load and improves the user s experience or the designer s expectations with the drawing programs especially in resource constrained devices.

This storage i.e. caching of drawing resources contained in the native code portion or the operating system is performed in a manner that allows signal parameter calls that describe the parameters of other drawing resources contained within the application program or the managed code portion prior to sending the other drawing resources to the native code portion while limiting the amount of data transmitted between the managed code portion and the native code portion .

Caching the drawing and other resources associated within the AGL in the native code portion reduces the number of native resources that must be accessed from remote locations e.g. from a server during the course of a UI based application s lifetime and thereby reduces the number of system calls across the VM native boundary between the VM and the native OS . Limiting the amount of data contained in each system call across the VM native boundary between the virtual code portion and the native code portion acts to reduce the requisite data type marshaling overhead associated with such system calls compared to system parameter calls.

During the drawing resource idle method that is run in the AGL code is run at for each drawing resource that looks at the reference count for the drawing resource. The AGL drawing resource can be considered a node. The drawing resource idle method continues to decision in which the computer environment considers whether the reference count of each AGL drawing resource equals zero.

For each respective AGL drawing resource if the answer to decision is yes the drawing resource idle method continues to and the drawing resource is deleted from the cache i.e. a memory location in the AGL of the native code portion . If by comparison the answer to decision is no then the drawing resource idle method continues to in which the drawing resource is maintained in the cache in the native code portion more particularly the global cache . The drawing resource idle method therefore provides an effective technique to remove any drawing resource that is not being used for a reasonable period of time from the global cache by the native code portion . This action may be considered as a form of garbage collection.

The methods described in this disclosure that are illustrated in and are intended to streamline the computer processing and therefore provide an efficient method to allocate and to manage certain UI related OS resources. Such methods are especially suited to resource constrained devices. Even with the more powerful computers though it would still be desirable to follow good programming techniques to reduce the number of system calls and use system parameter calls to make the computers run faster and more reliably thereby increasing the user s enjoyment and use of such application programs. Such reduction of the number of system parameter calls across the VM native boundary within any computer environment is within the intended scope of the present invention. One embodiment of a managed execution process of the present invention that is performed by the managed code portion and the native code portion as shown in follows these guidelines 

a Choose a compiler to associate with the application program . To obtain the benefits provided by the common language runtime a developer can select one or more language compilers that target the runtime.

b Compile the code to an intermediate language code e.g. Microsoft intermediate language . This compiling translates the source code XML or other application program into the intermediate language and also generates associated metadata. The intermediate language is a CPU independent set of instructions that can be efficiently converted to the native code to ease the transition of data across the VM native boundary between the managed code portion and the native code portion . The intermediate language includes instructions for loading storing initializing and calling methods on objects as well as instructions for arithmetic and logical operations control flow direct memory access exception handling and other operations. The metadata describes such parameters as the types in the code including the definition of each type the signatures of each type s members the members that the code references and the data that the runtime uses at execution time.

c Compile the intermediate level code into native code. The native code portion creates a native draw resource from a managed assembly and installs it into the native code portion on the local computer. A native draw resource that is a file containing compiled processor specific machine code is produced. In this disclosure the logical representations of the drawing resources are referred to as being stored in the cache that is located in the AGL of the native code portion . The actual drawing resource resides as the OS drawing resource in the OS drawing surface . In different embodiments the cache can be a physically distinct memory device that is set aside to store and retrieve drawing resources. Alternatively the native code portion cache can be a portion of random access memory RAM contained in the computer environment as described below that is typically used to store and or retrieve other data.

In this embodiment of execution of the VM at execution time the just in time JIT compiler in the native code portion translates the intermediate language into the native code. During this compilation the code passes a verification process that examines the intermediate language code and metadata to find out whether the code can be determined to be type safe. Before the intermediate language can be executed it must be converted by the just in time JIT compiler of the VM to the native code. The native code is a CPU specific code that runs on the same computer architecture as the JIT compiler. Developers can write a set of instructions for the intermediate level language that can be JIT compiled and executed on computers with different architectures. The managed code will run only on a specific operating system if it calls platform specific native application programming interfaces API or a platform specific class library.

d Execute the code. The common language runtime provides the infrastructure that enables the code execution as well as a variety of services that can be used during execution to take place. During execution the OS drawing resource is displayed on the OS drawing surface and responds to use input. As such user input to the keyboard or mouse of the computer environment is mirrored by motion of the OS drawing resource across the OS drawing surface. Before a process can be executed by the computer environment it must be compiled to processor specific code. Each process for which the intermediate language has been generated is JIT compiled when it is called with a system parameter call for the first time and then executed. The next time the process is executed the existing JIT compiled native code is executed. The process of JIT compiling and then executing the code is repeated until execution is complete.

During execution managed code receives services such as automatic memory management security interoperability with unmanaged code cross language debugging support and enhanced deployment and versioning support. After a native draw resource is generated for an assembly program the runtime automatically attempts to locate and use this native image each time it runs the assembly. If it is unable to find a suitable native image the runtime reverts to a standard compiled program.

In the resource constrained computer environment e.g. certain networks and OS reducing the number of resources used and increasing the efficiency and retrieval rate of data is important. Certain OS architectures such as .NET and JAVA involve the use of VMs or managed code portions that are capable of interfacing with the software from more than one native machine or native code portion . When executing code in the environment of the managed code portion the user interface UI components often represent hierarchical data structures that typically allocate native resources to realize the drawing resources. Executing code in the managed code portion necessitates that the drawing resources in the native code portion are synchronized with their counterparts in the managed code portion . Synchronization between the managed code portion and the native code portion should be frequently performed to reduce any differences between the code describing the drawing resources in the managed code portion and the native code portion . Executing code in the native code portion as is the case with the embodiment of drawing resource control method shown in and limits the necessity for such synchronization.

In a network environment including the computing environment and the remote computer as described later relative to each one of the plurality of computers that form the computer environment may be running different application programs and operating systems and may have different capabilities and purposes. The VM has the capability of interfacing with a plurality of computers simultaneously to affect such networked activities as parallel processing with what appears to the user of the VM as a non networked computer environment. One of the greatest challenges in creating an operating networked environment is to configure different computers having different operating systems to permit effective communication and data usage.

The embodiment of virtual machine shown in combines multiple computer environments having the same or different operating systems e.g. Microsoft Windows Unix and Apple OS to function as a single computer environment. Also eXtensible Markup Language XML is a computer language that permits one application program to utilize and or modify the data produced by another application program. XML is an open industry standard managed by the World Wide Web Consortium. The VM includes a first computer having a first OS and a second computer with a second OS . The first computer may be remote from the second computer necessitating the user of a network to provide data communications. A user can access the VM in a similar manner as a user would interface with the computing environment or the remote computer .

The embodiment of VM as shown in most evidently interacts with the native OS in the client server configuration within the network environment when for example a first OS associated with a first computer is interfacing with a second OS associated with a second computer . Where there are a variety of different native OS it is important that the VM native boundary between the VM and the computers be configured in an operating system such as JAVA that can interface with a variety of native operating systems.

One embodiment of the VM is considered as an operating system that runs the drawing resource e.g. a computer pen a computer paintbrush or a computer font as illustrated in within the managed code portion to create a drawn portion . The computer environment performs the method performed by the embodiment of computer environment shown in by which the drawing resource can be controlled by the user interface UI to the VM in the managed code portion . Data corresponding to the drawing resources can be stored in one embodiment of the virtual cache memory which configures the user of the VM to access the drawing resource using system parameter calls having limited system latency compared to system calls between the VM and the native OS and .

When executing code in the native code portion i.e. the VM environment the UI libraries use the system parameter calls to perform low level functionality such as drawing and window management. In such systems drawing resources within the native code portion are allocated based on one or more UI library system parameter calls. When the VM managed code is finished with the resource the drawing resource is then freed.

In one aspect it would be desirable to store the codes i.e. of the system parameter calls of the drawing resource that are transmitted to the native code portion in a VM managed memory included in the managed code portion such as the cache memory . The code representing the drawing resources should be stored as native code in the native code portion . A computer language such as XML can be used to store the drawing resources in the managed code portion . XML is desired because it allows different application programs to display organize program edit and transfer data relating to drawing resources between different web devices and application programs while maintaining the ability to maintain the data characteristics.

XML separates the underlying data from the manner in which the data is displayed and which may be controlled by the user . The data relating to the drawing resources may be accessed and unlocked by each web device so that the underlying program may be displayed organized programmed edited and transferred between web devices. Additionally the web device that access the data can format to display the underlying data as desired.

The red value portion the green value portion and the blue value portion each contain data that together define the RGB characteristic value which can describe the OS drawing resource . The combination of the red value portion the green value portion and the blue value portion the RGB characteristic value can be contained within 32 bits or 64 bits of data. As such the amount of data that has to be transmitted by the system parameter calls in transferring data relating to colors of drawing resources is relatively small and is considerably smaller than the amount of data necessary to create an entire drawing resource which is contained in system calls.

Additionally the amount of processor effort and memory storage space e.g. storage space in the cache allocated to comparing these 32 or 64 bit color values including the red value portion the green value portion and the blue value portion of the RGB characteristic value for drawing resources is much less than the respective processor effort and memory storage necessary to compare the larger amount of data describing the entire drawing resource. As such the drawing resource control method illustrated in and as well as the drawing resource idle method illustrated in can be performed quicker and more reliably by resource constrained devices.

In certain embodiments the drawing resource parameter string includes the drawing resource dimension portion . The drawing resource dimension portion can be used to describe the dimensions of the drawing object and is used to manage e.g. create destroy and or maintain drawing resources between the managed code portion and the native code portion in a similar manner using an additional criterion as described for each of the red value portion the green value portion and the blue value portion . The drawing resource dimension portion can be used to measure thickness of a primitive line dimension of a primitive object font of a primitive letter or number etc. The drawing resource dimension portion can therefore be used to provide a considerable amount of information about a drawing resource utilizing a relatively small amount of data.

The computer environment illustrated in is a general computer environment which can be used to implement the techniques described herein. The computer environment is only one example of a computer environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computer environment be interpreted as having any dependency relating to any one or combination of components illustrated in the exemplary computer environment .

The computer environment includes a general purpose computing device in the form of a computer . The computer can be for example one or more of a stand alone computer a networked computer a mainframe computer a PDA a telephone a microcomputer or microprocessor or any other computer device that uses a processor in combination with a memory. The components of computer can include but are not limited to one or more processors or processing units optionally including a cryptographic processor or co processor a system memory and a system bus that couples various system components including the processor and the system memory .

The system bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example such architectures can include an Industry Standard Architecture ISA bus a Micro Channel Architecture MCA bus an Enhanced ISA EISA bus a Video Electronics Standards Association VESA local bus and a Peripheral Component Interconnects PCI bus also known as a Mezzanine bus.

The computer typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer and includes both volatile and non volatile media and removable and non removable media.

The system memory includes computer readable media in the form of non volatile memory such as read only memory ROM and or volatile memory such as random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in the ROM . The RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by the processing unit .

The computer may also include other removable non removable volatile non volatile computer storage media. By way of example illustrates a hard disk drive for reading from and writing to a non removable non volatile magnetic media not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . Alternatively the hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by one or more interfaces not shown .

The disk drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computer . Although the example illustrates a hard disk within the hard disk drive a removable magnetic disk and a non volatile optical disk it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electrically erasable programmable read only memory EEPROM and the like can also be utilized to implement the exemplary computing system and environment.

Any number of program modules can be stored on the hard disk contained in the hard disk drive magnetic disk non volatile optical disk ROM and or RAM including by way of example the OS one or more application programs other program modules and program data . Each OS one or more application programs other program modules and program data or some combination thereof may implement all or part of the resident components that support the distributed file system.

A user can enter commands and information into the computer via input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad satellite dish serial port scanner and or the like. These and other input devices are connected to the processing unit via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the monitor other output peripheral devices can include components such as speakers not shown and a printer which can be connected to computer via the input output interfaces .

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computing device . By way of example the remote computing device can be a personal computer portable computer a server a router a network computer a peer device or other common network node game console and the like. The remote computing device is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .

Logical connections between computer and the remote computing device are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When implemented in a LAN networking environment the computer is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the wide network . The modem which can be internal or external to computer can be connected to the system bus via the input output interfaces or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link s between the computers and can be employed.

In a networked environment such as that illustrated with computer environment program modules depicted relative to the computer or portions thereof may be stored in a remote memory storage device. By way of example remote application programs reside on a memory device of remote computer . For purposes of illustration application programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computing device and are executed by the data processor s of the computer. It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Although the systems and methods have been described in language specific to structural features and or methodological steps it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather the specific features are disclosed as preferred forms of implementing the claimed invention.

