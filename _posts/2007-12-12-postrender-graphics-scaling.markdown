---

title: Post-render graphics scaling
abstract: An apparatus, method, and computer program product for scaling a rendered surface. The apparatus includes a graphics processor configured to render a surface at a source resolution, wherein a scaling parameter is associated with the surface, the scaling parameter defining the source resolution and a destination resolution. The apparatus further includes a display processor configured to scale the rendered surface to the destination resolution. Preferably, the scaling parameters are EGL surface attributes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08681180&OS=08681180&RS=08681180
owner: QUALCOMM Incorporated
number: 08681180
owner_city: San Diego
owner_country: US
publication_date: 20071212
---
This application claims the benefit of provisional U.S. Application Ser. No. 60 870 348 filed Dec. 15 2006 which is incorporated by reference herein.

This disclosure relates to graphics processing and more particularly relates to the scaling of graphics surfaces after a rendering process.

A graphics processing unit GPU is a dedicated graphics rendering device utilized to render manipulate and sometimes display computerized graphics. GPUs are typically built with a highly parallel structure that provides more efficient processing than typical general purpose central processing units CPUs for a range of complex graphics related algorithms. For example the complex algorithms may correspond to representations of three dimensional computerized graphics. A GPU may implement a number of so called primitive graphics operations such as forming points lines and triangles to create complex three dimensional images on a display more quickly than drawing the images directly to the display with a CPU.

GPUs and other graphics hardware are often limited in terms of available memory and power resources. In particular graphics hardware used in mobile devices is typically very limited with regard to these resources. Since graphics hardware embedded in a mobile device is typically powered by a battery the amount of power that can be dedicated to graphics hardware is often limited in order to ensure a desirable amount of battery life for the mobile device. As such maximum frame rates for mobile graphics hardware is often limited when compared to graphics hardware for desktop computers since an increase in frame rate also demands an increase in power usage.

Large amounts of internal memory available for mobile graphics hardware are typically limited as it is often desirable to keep the silicon area of mobile devices small. Most current mobile graphics architectures implement a binning algorithm to reduce the amount of internal memory that is needed. A binning algorithm essentially separates a graphics frame into two or more different areas. A graphics frame is the display area for a particular scene that is to be rendered. Each of these areas is separately rendered using a small amount of memory internal to a graphics processor. In this way the amount of internal memory needed is reduced. This increases the computation and memory bandwidth required to render an entire scene. However binning algorithms are typically optimized for a predetermined display resolution. Current mobile graphics hardware typically renders scenes to a Video Graphics Array VGA resolution of 640 480 pixels or lower. If a scene is to be displayed at a resolution other than the predetermined resolution the benefits of the binning algorithm may not be realized.

Alternatively when pixel quality is of maximum importance GPUs typically perform anti aliasing techniques. The most common methods of anti aliasing involve multi sample rendering multi pass accumulation or expensive per primitive edge computations. However such techniques often require more memory power and or silicon area than is typically available for graphics hardware in mobile devices. As such these techniques are typically not performed in the mobile setting.

The need for increased and varying display resolutions across different mobile devices is often incompatible with the abilities of current graphics hardware given their limitations in mobile settings. As such the quality of graphics including 3D graphics available to be displayed on mobile devices has been difficult to improve and as such the ability to take advantage of higher resolution displays employed in mobile devices has largely been unrealized.

In view of the foregoing this disclosure presents methods apparatuses and computer program products for improving power consumption and sustainable frame rate performance for graphics processing by reducing the number of pixels rendered by a GPU and or reducing the number of bins needed for a binning algorithm in situations where the desired display resolution for a graphics frame is larger than the resolution at which a GPU renders the graphics frame. This is accomplished by using a processor other than the GPU to scale a rendered graphics frame to a desired resolution.

In addition the methods apparatuses and computer program products may be used to improve pixel quality by having a GPU render a scene to a resolution that is larger than actually displayed and then downscaling the scene with another processor as it is copied to the display. In some scenarios this downscaling operation achieves similar results as multi pass accumulation buffer techniques without the associated hardware costs.

According to one embodiment an apparatus for scaling a rendered graphics frame includes a graphics processor configured to render a surface at a source resolution wherein a scaling parameter is associated with the surface the scaling parameter defining the source resolution and a destination resolution. The apparatus further includes a display processor configured to scale the rendered surface to the destination resolution. Preferably the scaling parameters are EGL surface attributes.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

GPU may carry out instructions that are stored in memory . Memory may include any permanent or volatile memory capable of storing instructions. In addition GPU may execute instructions that are received over an air interface e.g. CDMA 1x EV DO WiFi . Graphics frames rendered by GPU are stored in buffer . Buffer may be any permanent or volatile memory capable of storing data.

In this context a graphics frame is the entire scene that is to be displayed. A graphics frame may be made up of one or more surfaces that may be individually rendered by GPU . A surface is either a 2 D image or a rendered 2 D representation of a 3 D object from a certain viewpoint. Multiple rendered surfaces that are displayed in the graphics frame may be combined through overlay and or blending operations.

Surfaces rendered by GPU are rendered to a particular resolution. In graphics terms resolution is the number of pixels shown on a display. For example VGA resolution is 640 pixels by 480 pixels. Resolution does not refer to the physical size of the display but rather to the number of pixels displayed. The resolution to which GPU renders a surface is not necessarily the resolution of the display. To distinguish this fact the resolution to which GPU renders is called the source resolution. The source rectangle source rect specifies a rectangular subset or region of interest ROI of the source resolution which is the input to the scaling operation. The origin of this rectangular subset may or may not coincide with the origin of the source resolution. For the purposes of this disclosure the origin of the rects the source buffer and the display is defined as the lower left corner. The resolution that is actually displayed is referred to as the destination resolution. The destination rectangle dest rect specifies a rectangular subset of the display to which the output of the scaling operation is written. The origin of this rectangular subset may or may not coincide with the origin of the display. The dest rect may be predetermined based on the characteristics of the display or may be determined by a program making use of the GPU. The value of the source rect and dest rect may be stored in memory for use by GPU and display processor .

In particular the source rect and dest rect may be stored as parameters associated with a surface that is to be rendered and displayed. As one example these parameters may be attributes included in an Embedded System Graphics Library EGL description of the surface. EGL is an interface between APIs such as OpenGL ES or OpenVG and an underlying native platform window system. In this way third party developers of applications may define scaling factors in a familiar programming language without having to develop separate commands for instructing a particular display processor to perform a scaling process. shows an example of EGL surface attributes including the source rect and dest rect scaling parameters.

Display processor is a processor for driving display i.e. sending the pixel color values to the display and for performing post rendering processes on the rendered surfaces. Display processor may be any type of processor. As one example display processor may be a Mobile Display Processor MDP embedded in Mobile Station Modems designed by Qualcomm Inc. of San Diego Calif. An MDP is a processor that has been dedicated to and optimized for driving a display and performing post render functions on a rendered surface. Such functions may include scaling rotation blending and overlaying. Display processor may be constructed to execute instructions stored in memory .

When GPU has rendered a surface in the source rect and stored it in buffer display processor retrieves the rendered surface from buffer and scales the surface to the dest rect of the display. The dest rect may be obtained from memory or may be predetermined based on the characteristics of display . In particular dest rect may be retrieved from a dest rect attribute included with the EGL description of the rendered surface. By using a different processor for scaling processing overhead which as described above is often expensive in mobile settings is saved for the GPU.

Source rect and dest rect may be each defined with a width and height value that indicates the number of pixels in each direction. The source rect may also include an x y coordinate that defines an offset relative to some location in the buffer rendered by the GPU. As seen in source rect is defined by an x y coordinate that is relative to the lower left corner of buffer . In this example the lower left corner of buffer is defined as 0 0. The x y coordinate of source rect may be defined from any location in buffer . By defining the lower left corner of source rect in addition to identifying the height and the width of the source rect specific portions of the image rendered in buffer up to the entire buffer may be selected for eventual display.

Dest rect may also be defined by an x y value. The dest rect x y value defines an offset relative to some point on display . As seen in dest rect is defined by an x y coordinate that is relative to the lower left corner of display . In this example the lower left corner of display is defined as 0 0. The x y coordinate of dest rect may be defined from any location on display . By defining the lower left corner of dest rect the desired image defined by source rect may be offset to any location in display .

As shown in dest rect is the maximum resolution capable for display . However display processor need not always scale the rendered surfaces from the source rect to the maximum resolution of a display. Display processor may be configured or instructed to scale the rendered surface from a source rect to any resolution at or below the maximum resolution of the display. Preferably the scaling ratio of source rect to dest rect is between 0.25 and 4.00. However any scaling ratio may be used. One measure of scaling ratio can be determined by dividing the width of the source rect in the x direction by the width of the dest rect in the x direction. Another measure of scaling ration can be determined by dividing the height of the source rect in the y direction and the height of the dest rect in the y direction. The scaling ratio for the width or height may be handled independently to effect horizontal or vertical stretching or may be made the same in order to preserve the same aspect ratio from source rect to dest rect. Examples of scaling processes will be discussed in more detail with reference to below.

Utilizing EGL scaling attributes enables resealing an EGL window surface as the surface contents are copied to the target display device while posting the buffer. Both upscaling and downscaling are supported. The initial dimensions of the EGL surface will match the target display. The user specifies one or two rectangular regions known as the source and dest rects. The source rect is scaled as required to the size specified in the dest rect. Usually the source rect will be less than or equal to the size of the EGL surface. However a larger source rect up to the implementation limit may be specified when downscaling is desired. Downscaling can be used to achieve an approximation of anti aliasing for rendering engines which have no internal anti aliasing capability. Preferably the rendering engine i.e. the GPU renders a surface which is at least twice the desired size in both dimensions.

Using smaller window surface dimensions can save render time or equivalently increase sustainable frame rate. On platforms where a memory constrained rendering engine cannot operate on surfaces of the desired dimension upscaling smaller window surfaces can produce full sized surfaces on the target display.

The destination rect specifies the dimensions to which the entire possibly resized EGL window surface will be scaled as a post rendering operation. The destination rect may be passed as NULL if the original full display size is the desired output. The destination rect must be less than or equal to the size of the target display device.

For power reduction and frame rate improvement the 3D graphics pipeline in GPU may be setup to render to a smaller surface than the actual display area e.g. VGA 640 480 rather than WVGA 800 480 . This reduces both the pixel count and the number of bins required to render the surface. Once the 3D pipeline has completed rendering the surface at the lower resolution the display processor is used to upscale it to the actual display resolution while it is being transferred to the actual display. For improved pixel quality the 3D pipeline may be setup to render at a larger resolution than the display e.g. VGA 640 480 instead of QVGA 320 240 . For color images for example this technique effectively calculates 4 color values which are combined to determine each final pixel color. The combination of the 4 color values is performed by the display processor while downscaling the 3D surface as is it is transferred to the actual display.

In the rasterization load reduction scenario the number of pixels rendered and bins required to render the scene are both reduced. This reduces the computation load on the GPU and the associated power consumption. The display processor requires fewer computations to upscale the 3D surface on the way to the display than would typically be required by the GPU to render the 3D scene at full resolution. In the image quality improvement scenario a simple GPU with no special purpose hardware for multi sampling or buffer accumulation may be used to generate an oversized surface. The surface is then downscaled on the way to the display which achieves similar results with accumulation style anti aliasing.

In step a destination resolution is selected. Again the destination resolution may be selected based on the desired resolution of a user program utilizing the GPU e.g. a video game the resolution capabilities of the GPU the resolution capabilities of the display or a combination of these factors. The destination resolution selected may be stored as a parameter associated with the rendered surface. For example the destination resolution may be stored as a dest rect attribute in an EGL surface description.

In step a surface is rendered to the source resolution. Then in step the rendered surface is scaled to the destination resolution.

Memory may also be used to store Application Programming Interface API . API serves as the conduit between user program and MDP . When GPU has rendered a surface to buffer user program may execute an instruction to display that surface. Such a display instruction may be a function that calls API . API then instructs control processor to control MDP to scale the rendered surface in buffer to the selected dest rect stored as control parameters . Control processor may be an Advanced RISC reduced instruction set computer Machine ARM processor such as the ARMprocessor embedded in Mobile Station Modems designed by Qualcomm Inc. of San Diego Calif. MDP may be a mobile display processor embedded in Mobile Station Modems designed by Qualcomm Inc. of San Diego Calif. MDP retrieves the rendered surface from buffer scales the surface to the desired dest rect and drives display to display the scaled rendered surface.

The examples shown in show scenarios in which the disclosed apparatuses methods and computer program products may help to improve power consumption provide for a constant frame rate or reduce memory usage when compared to other conventional rendering methods.

The examples shown in show scenarios in which the disclosed apparatuses methods and computer program products may help to improve power consumption provide for a constant frame rate or reduce memory usage when compared to other conventional anti aliasing and rendering methods.

The apparatuses methods and computer program products described above may be employed various types of devices such as a wireless phone a cellular phone a laptop computer a wireless multimedia device e.g. a portable video player or portable video gaming device a wireless communication personal computer PC card a personal digital assistant PDA an external or internal modem or any device that communicates through a wireless channel.

Such devices may have various names such as access terminal AT access unit subscriber unit mobile station mobile device mobile unit mobile phone mobile remote station remote terminal remote unit user device user equipment handheld device etc.

Any device described above may have a dedicated memory for storing instructions and data as well as dedicated hardware software firmware or combinations thereof. If implemented in software the techniques may be embodied as instructions on a computer readable medium such as random access memory RAM read only memory ROM non volatile random access memory NVRAM electrically erasable programmable read only memory EEPROM FLASH memory magnetic or optical data storage device or the like executable by one or more processors. The instructions cause one or more processors to perform certain aspects of the functionality described in this disclosure.

The techniques described in this disclosure may be implemented within a general purpose microprocessor digital signal processor DSP application specific integrated circuit ASIC field programmable gate array FPGA or other equivalent logic devices. Accordingly components described as modules may form programmable features of such a process or a separate process.

Various embodiments described herein may be combined in whole or in part. These and other embodiments are within the scope of the following claims.

