---

title: Virtual machine communication
abstract: The present disclosure includes, among other things, systems, methods and program products for virtual machine communication. For example, one or more aspects of the subject matter described in this disclosure can be embodied in one or more methods that include constructing a first message on behalf of a first program executing in a first virtual machine. A second virtual machine is selected from one or more virtual machines. Security information for the first program is communicated to the second virtual machine. The first message is communicated from the first virtual machine to the second virtual machine, the first message to be processed by the second virtual machine with regard to the security information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08505029&OS=08505029&RS=08505029
owner: Adobe Systems Incorporated
number: 08505029
owner_city: San Jose
owner_country: US
publication_date: 20071126
---
A program executing in a virtual machine e.g. a Java virtual machine that needs to send a message to a program executing in another virtual machine may be able to access inter process communication mechanisms provided in an underlying operating system. However this approach assumes that the communication mechanisms provided by the sender s operating system are compatible with those of the receiver s operating system. Another technique is remote method invocation RMI such as Java RMI which allows methods on an object in one virtual machine to be invoked by a program executing in a different virtual machine. A drawback of Java RMI is that its use can require altering existing classes to work within a stub skeleton paradigm which can be cumbersome for programmers.

In general one or more aspects of the subject matter described in this specification can be embodied in one or more methods that include constructing a first message on behalf of a first program executing in a first virtual machine. A second virtual machine is selected from one or more virtual machines. Security information for the first program is communicated to the second virtual machine. The first message is communicated from the first virtual machine to the second virtual machine the first message to be processed by the second virtual machine with regard to the security information. Other embodiments of this aspect include corresponding systems apparatus and computer program products.

These and other embodiments can optionally include one or more of the following features. The security information can include a domain of the first program. The first message is received by the second virtual machine a second program is selected to process the first message and the second program is invoked. A second message is communicated from the second virtual machine to the first virtual machine the second message is received by the first virtual machine a second program is selected to process the second message and the second program is invoked. Selecting a second virtual machine can be based on a status of the second virtual machine. The status can indicate whether the second virtual machine is able to accept a message. The message can include a set of name and value pairs. The first program does not need take part in the transferring.

Particular implementations of the subject matter described in this specification can realize one or more of the following advantages. Two or more virtual machines or executing programs within the virtual machines can communicate without the hassle of setting up RMI mechanisms. Messages can also be exchanged through an intermediate process or through inter process communication mechanisms even if the underlying operating systems are different. Security information is communicated between virtual machines to allow message processing in a receiving virtual machine to be performed with regard to security settings of a sending virtual machine. A sending virtual machine can select a receiving virtual machine based on the status of the receiving virtual machine.

The details of one or more implementations of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims.

In order to facilitate RMI a stub object and a skeleton object are created to implement communication between the client virtual machine and the server virtual machine . The stub object resides in the client virtual machine and the skeleton object resides the server virtual machine . The stub object is a client side proxy for the remote server object . The stub object forwards method calls to the skeleton object . The skeleton object is a server side proxy for the server object and forwards method calls to the server object .

As indicated by reference a program executing in client can invoke a method on the client object such as a getTotal method which can return the total of an order. The getTotal method call is forwarded to the stub object . As indicated by reference the stub object marshals parameters by encoding parameters in a format suitable for transport across a network. As indicated by reference the stub object forwards the method call request and marshaled parameters to the skeleton object . The skeleton object unmarshals parameters e.g. decodes as indicated by reference and then invokes the desired method for the server object with the decoded parameters.

The skeleton object can receive a return value from the server object when the method call completes as indicated by reference . The skeleton object marshals the return value as indicated by reference . That is the return value is encoded in a format suitable for transport over a network. The return value is sent to the client virtual machine as indicated by reference . The stub object receives and unmarshals the return value . The client object then receives the return value from the stub object as indicated by reference .

The supervisor components enable executing programs or processes such as Java programs to run in execution components respectively. Generally speaking a supervisor component provides services needed in order for processes to run but does not execute the processes. The execution component includes three example processes shown here as P P and P . The execution component includes two example processes shown as P and P . Each example process has an associated runtime stack and program counter. By way of illustration the supervisor component can include a compilation component and a runtime support component . Similarly the supervisor component includes a compilation component and a runtime component . The compilation components include support for parsing and translating source code e.g. Java loading and verifying byte code e.g. Java byte code and translating byte code into machine code. The runtime support components include support for memory management garbage collection job scheduling and type management for example.

A stubs component on the client virtual machine includes the stub object as discussed previously with respect to . Likewise a skeletons component resides on the server virtual machine and includes the skeleton object . The RMI runtime components manage connections between the client virtual machine and the server virtual machine that facilitate RMI e.g. connections between the stubs component and the skeleton component . The RMI runtime component includes a registry or state which indicates remote objects that are available to provide services. The server virtual machine can register objects e.g. the server object . The client process e.g. P can perform a lookup to determine which remote objects it can access and to obtain an IP Internet Protocol address and port number of a virtual machine e.g. server virtual machine which offers a desired service.

A process e.g. P running on the client virtual machine can communicate with a process e.g. P running on the server virtual machine . For example the P process can perform operations associated with the client object discussed previously with respect to . For example the client object can invoke a method of the server object in server process P. The P and P processes can communicate with each other using the stub object and the skeleton object as discussed previously with respect to . For example code running in the P process can invoke a method on the stub object . The stub object invokes code in the RMI runtime component to marshal data such as parameters and a method identifier. The RMI runtime component then submits a message to the host OS to deliver to the server virtual machine across the network . The host OS passes the message to the RMI runtime component which unmarshals parameters and a method identifier and invokes a method on the skeleton object through process P.

The client virtual machine includes a supervisor component and an execution component . Similarly the server virtual machine includes a supervisor component and an execution component . The supervisor components enable processes to run in the execution components respectively. Similar to the execution component of the execution component includes three example processes here shown as P P and P and the execution component includes two example processes shown as P and P . Each example process has an associated runtime stack and program counter.

The supervisor component includes a compilation component and a runtime support component . Similarly the supervisor component includes a compilation component and a runtime component . In various implementations the compilation components can include one or more of support for parsing and translating source code loading and verifying bytecode and translating bytecode into machine code. In various implementations the runtime support components can include support for one or more of memory management garbage collection job scheduling and type management.

The system allows for communication between the client virtual machine and the server virtual machine . Virtual machine to virtual machine communication can take place through a general purpose interface without a need for other components i.e. without the stub component the skeleton component or the RMI runtime components discussed previously with respect to . Messages can be sent between the client virtual machine and the server virtual machine on behalf of processes or the supervisor components 

For example a message can be constructed by a process e.g. P executing in the client virtual machine . In various implementations a message can include a collection of name and value pairs. Other message formats are possible however. The server virtual machine can be selected as a recipient of the message from a group of one or more virtual machines based on an identifier provided by the sending process or some other means. In some implementations the server virtual machine is selected based on the result of determining the status of the supervisor component . For example the supervisor component can indicate its status e.g. busy idle able or not able to process the message finished or not finished processing the message . As another example the supervisor component can indicate whether the server virtual machine includes application code configured to process the message .

After selecting the server virtual machine as the recipient of the message a message transfer interface is established between the supervisor component and the supervisor component . The message transfer interface is programmatically accessible to processes in the client virtual machine and the server virtual machine by way of an application programming interface for example. In some implementations the message transfer interface is able to communicate messages over one or more networks. The message is transferred by the supervisor component to the supervisor component using the message transfer interface. For example the message can be sent to a message queue or other storage associated with the supervisor component . In some implementations the storage is realized as a file or shared memory. Other storage means are possible. In some implementations application code e.g. P in the client virtual machine does not take part in the transferring. In other implementations the message is sent to an intermediate process which is operable to provide the message to the server virtual machine on behalf of the client virtual machine

Upon receipt of the message the supervisor component can select application code to process the message . For example the supervisor component can select application code running in the P process. The application code selection may be based on the contents of the message such as a message identifier and or a message type. For example the supervisor component can determine application code which is configured to process particular messages or message types. The selected application code is invoked and may for example process the message .

The supervisor component can respond to the message for example on behalf of application code running on the server virtual machine . The supervisor component can send a message to the supervisor component . The supervisor component can select and invoke application code running on the client virtual machine e.g. P to process the message .

The compilation component includes a loader component bytecode verifier component a parser component and a JIT Just In Time compiler . The loader component loads program code such as source code e.g. ActionScript Java or bytecode into the virtual machine . The parser component parses the source code and generates bytecode which generally speaking is an intermediate language not specific to a particular microprocessor. The bytecode verifier component receives bytecode from the loader component or the parser component and validates the bytecode to determine whether the bytecode is executable. The JIT compiler translates bytecode into executable machine code.

The runtime support component includes a type system component a scheduler component a garbage collector component a memory manager component a security component and a messaging component . The type system component manages types e.g. object types in the system. The type system can for example keep track of classes interfaces and object types loaded into the virtual machine by the loader and is used by the parser component and by the execution component . The scheduler component schedules and coordinates execution of programs. The garbage collector component identifies objects that are no longer being referenced so that the memory being used by those objects can be freed and placed back onto a heap memory area . The heap memory area is a part of the data area used for dynamic memory allocation e.g. memory allocated for object instances . The memory manager component manages memory e.g. memory allocation and deallocation in the heap memory area as well as in other parts of the data area .

The security component is responsible for ensuring that processes e.g. do not perform operations that would jeopardize the security of the virtual machine . In various implementations program code is contained in Adobe Flash SWF format files and the security component assigns a SWF file or SWF depending upon its origin to one of the four so called security sandboxes . A remote sandbox applies to SWFs that originated from non local Uniform Resource Locators URLs . SWFs in this sandbox are not allowed access to any local file they can load and access data within SWFS from non local URLs provided they pass the cross domain and cross movie scripting verifications. A local with networking sandbox applies to SWFs that are on the local file system but will use networking. SWFs in this sandbox can access remote data but cannot read from local files. A local with filesystem sand box applies to SWFs that are on the local file system. These SWFs have access to local files but cannot communicate over the network. This is the default sandbox for SWFs. Finally a local trusted sand box is for privileged SWFs that have no restrictions. These SWFs can access local files as well as communicate remotely over the network.

In further implementations in addition to the notion of a SWF being assigned to one of the four sandboxes each SWF can also have a domain associated with it. An associated domain is the domain name of the location from where the SWF was loaded SWFs from local file system belong to a single unnamed domain . For example www.adobe.com is considered a different domain from labs.adobe.com. Cross domain security restrictions come into play when a SWF that tries to load data or a SWF from another domain. Normally such a loading operation across different domains is not permitted. To facilitate cross domain loading of data files a policy file e.g. at the destination location should grant access to the requesting domain.

Another aspect of security is implicated when a SWF references data e.g. variables objects and functions within another SWF. This is known as cross movie scripting. Cross movie scripting is generally permitted between SWFs that belong to the same domain. To facilitate cross movie scripting between SWFs from different domains the destination SWF SWF which data is to be scripted should to grant special permission to the source or requesting SWF s domain. The restrictions described with regards to cross domain loading apply to cross movie scripting as well. In other words a SWF from non secure domain should have a special permission to script a SWF in a secure domain.

In various implementations the first SWF that is loaded to a virtual machine is called a root SWF. The URL of the root SWF is known as the URL or the root URL. When a SWF including root SWF is downloaded the SWF will be assigned one of the four sandbox types and a security domain identifier depending upon the SWF s domain of origin. The domain identifier maps to a domain context instance that is unique for each domain. The domain context instance will contain information such as the domain address and list of other domains that a SWF can access. In some implementations script objects script variables created for this SWF will have the same domain identifier and sandbox type as their parent SWF. At any instance during SWF playback the virtual machine will have a current security domain which is the domain identifier and sandbox of the SWF whose frame is being processed. Security checks can be performed assuming the current security domain as the requesting domain sandbox. The current security domain is the domain context and sandbox of the current execution context s target.

In various implementations cross movie scripting security validation requires that every get or set operation on a script object or script variable will have to pass a security check. The security check will consist of two tests 1 matching the sandbox of the source requester SWF against the sandbox of the current security domain SWF being scripted and 2 verifying that the domain context of the SWFs are the same or that the source SWF has proper permissions to script the target SWF.

In further implementations for a SWF loaded into the virtual machine security information deemed a security context will be provided that in some implementations consists of set of permissions a base domain for the SWF a sandbox identifier or combinations of these. A security context can include other information as well. The virtual machine associates the security context with the corresponding SWF. Permissions grant or deny access to data or the ability to perform an operation for example. By way of illustration a permission can grant or deny access to a mobile phone address book. In some implementations permissions are provided by a process outside of the virtual machine such as a web browser or other client that hosts the virtual machine. SWFs belonging to the same library as a given SWF can inherit that SWF s permissions. When a process e.g. sends a message to a target virtual machine or at some other time the security context is communicated to the target virtual machine. For example a process in the target virtual machine that receives the message can be required to conform to the permissions sandbox domain or combinations of these of the sending process. In some implementations the security context represents the operating permissions domain and sandbox of the sending process.

The data area includes in addition to the heap memory area a method area a PC program counter registers and process state area a native method stack area a registry area a process stacks area a message InQ i.e. in queue and a message OutQ i.e. out queue . The method area includes code for class methods. The PC registers and process state area includes program counter and process state information for each process running in the execution component . The native method stack area is used by supervisor code when supervisor code methods are called. The process stacks area is used for holding data e.g. local variables object instances used by processes running in the execution component .

The execution component includes three example processes and shown as Process P Process P and Process P respectively . Each of the processes includes intermediate bytecode or native machine code for a corresponding program. The process includes an interpreter the process includes an interpreter and the process includes an interpreter . Each of the interpreters include an execution engine which executes code for the respective process in a runtime loop. For example the interpreters can interpret and execute bytecode execute native code etc.

Each process and the supervisor can communicate with the messaging component . The messaging component implements the messaging subsystem of the virtual machine . In various implementations the messaging component is exposed as a class and associated methods that user programs e.g. Process P can utilize to send and receive messages. The messaging component can receive messages e.g. from other virtual machines and security information in the message InQ . The message OutQ can hold messages and security information to be sent to other virtual machines. Messages can include a set of name value pairs for instance.

When the messaging component processes a message in the InQ it can invoke one or more callback methods for processes e.g. or other code that is registered to receive messages. A process e.g. can send a message by providing the message to the messaging component . In response to receiving a message from a process the messaging component can place the received message in the OutQ . The messaging component can periodically send messages from the OutQ to one or more virtual machines configured as destinations of outgoing messages over a network .

An Internet Protocol IP address and port number of the destination virtual machine can be looked up in the registry .

In some implementations the messaging component can marshal and demarshal message information. For example the messaging component can encode message information into a machine independent format before sending a message. Also upon receipt of a message i.e. upon processing a message from the InQ the messaging component can decode encoded machine independent message information into a machine dependent format.

Messages can be sent for example from the client virtual machine to the server virtual machine or vice versa. For example the messaging component e.g. of of the supervisor component can receive the message from a process running in the execution component . The supervisor component can place the message and optionally security information into an out queue e.g. of . A message transfer mechanism can take the message and the security information out of an out queue associated with the supervisor component and place the message and the security information into an in queue e.g. of associated with the supervisor component . The supervisor component can then invoke a callback method in the execution component and the callback method can process the message as permitted by the security information if such information was provided. In some implementations the message transfer mechanism is realized as a common memory area accessible to the virtual machines or by a communication protocol that optionally uses network services provided by the host OS . Other message transfer mechanisms are possible.

In a second scenario includes a client virtual machine and a server virtual machine . The client virtual machine includes a supervisor component and an execution component . The server virtual machine includes a supervisor component and an execution component . The client virtual machine runs on a host OS and the server virtual machine runs on a host OS . The client virtual machine and the server virtual machine reside on different physical devices.

The network can be one or more wired or wireless networks such as the Internet a LAN Local Area Network a WAN Wide Area Network or some other kind of network.

By way of illustration a message is sent from the client virtual machine to the server virtual machine . The supervisor component can receive the message from a process running in the execution component . The supervisor component can place the message into an out queue e.g. of with optionally security information. The messaging component in the supervisor can invoke a host level transfer process which can invoke an OS command in the host OS to send the message and the security information to the server virtual machine across the network . For example the host OS can open a socket and perform a write command. The message is sent over the network to the server virtual machine and is read by a host OS on the server virtual machine . The message and the security information is received by a host level transfer process which can place the message into an in queue associated with a messaging component of the supervisor component . The supervisor component can invoke a callback method to be run in the execution component and the callback method can process the message as permitted by the security information if such information was provided.

By way of illustration the virtual machine can connect to the network through the access device . The access device can be for example a set top box a mobile device a router a bridge or a personal computer e.g. the access device can be the physical computing device which the virtual machine runs on . The virtual machine can connect to the wireless network . The virtual machines and can connect to the network using a wired and or wireless connection. Messages can be sent to and from the virtual machines . The virtual machines can look up an IP Internet Protocol address and port number associated with a destination virtual machine using a registry service for example. A service can receive messages from and or send messages to the virtual machines i.e. the sender or recipient of a message can be a service e.g. process rather than a virtual machine .

Computing device includes a processor memory a storage device a high speed interface connecting to memory and high speed expansion ports and a low speed interface connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as display coupled to high speed interface . Such instructions can implement techniques and systems described above for example. In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In one implementation the memory is a computer readable medium. In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. The memory can store user code such as code associated with the object and supervisor code associated with a virtual machine such as the client virtual machine .

The storage device is capable of providing mass storage for the computing device . In one implementation the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device or memory on processor . The storage device can store user code such as code associated with the object and supervisor code associated with a virtual machine such as the client virtual machine .

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of duties is exemplary only. In one implementation the high speed controller is coupled to memory display e.g. through a graphics processor or accelerator and to high speed expansion ports which may accept various expansion cards not shown . In the implementation low speed controller is coupled to storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In addition it may be implemented in a personal computer such as a laptop computer . Alternatively components from computing device may be combined with other components in a mobile device not shown such as device . Each of such devices may contain one or more of computing device and an entire system may be made up of multiple computing devices communicating with each other.

Computing device includes a processor memory an input output device such as a display a communication interface and a transceiver among other components. The device may also be provided with a storage device such as a microdrive or other device to provide additional storage. Each of the components and are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can process instructions for execution within the computing device including instructions stored in the memory . The processor may also include separate analog and digital processors. The processor may provide for example for coordination of the other components of the device such as control of user interfaces applications run by device and wireless communication by device .

Processor may communicate with a user through control interface and display interface coupled to a display . The display may be for example a TFT LCD display or an OLED display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may be provide in communication with processor so as to enable near area communication of device with other devices. External interface may provide for example for wired communication e.g. via a docking procedure or for wireless communication e.g. via Bluetooth or other such technologies .

The memory stores information within the computing device . In one implementation the memory is a computer readable medium. In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. Expansion memory may also be provided and connected to device through expansion interface which may include for example a SIMM card interface. Such expansion memory may provide extra storage space for device or may also store applications or other information for device . Specifically expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example expansion memory may be provide as a security module for device and may be programmed with instructions that permit secure use of device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or MRAM memory as discussed below. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory expansion memory memory on processor or a propagated signal.

Device may communicate wirelessly through communication interface which may include digital signal processing circuitry where necessary. Communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. Such communication may occur for example through radio frequency transceiver . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition GPS receiver module may provide additional wireless data to device which may be used as appropriate by applications running on device .

Device may also communication audibly using audio codec which may receive spoken information from a user and convert it to usable digital information. Audio codex may likewise generate audible sound for a user such as through a speaker e.g. in a handset of device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on device .

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium computer readable medium refers to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

While this specification contains many implementation details these should not be construed as limitations on the scope of the invention or of what may be claimed but rather as descriptions of features specific to particular implementations of the invention. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular implementations of the invention have been described. Other implementations are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

