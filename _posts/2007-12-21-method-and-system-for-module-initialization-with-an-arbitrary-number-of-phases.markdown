---

title: Method and system for module initialization with an arbitrary number of phases
abstract: A method for initializing a module that includes identifying a first module for initialization, and performing a plurality of processing phases on the first module and all modules in a dependency graph of the first module. Performing the plurality of processing phases includes, for each module, executing a processing phase of the plurality of processing phases on the module, determining whether the processing phase has been executed on all modules in a dependency graph of the module, and when the processing phase has been executed for all modules in the dependency graph of the module, executing a subsequent processing phase of the plurality of processing phases on the module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07934084&OS=07934084&RS=07934084
owner: Oracle America, Inc.
number: 07934084
owner_city: Redwood City
owner_country: US
publication_date: 20071221
---
This application is related to U.S. application Method and System for Module Initialization with U.S. application Ser. No. 11 962 949 filed on Dec. 21 2007 which is incorporated by reference in its entirety.

Software development and support costs are driven by many factors including increasing software complexity and the need to support multiple hardware platforms and operating systems. To help reduce these costs there is an increasing emphasis on creating modular software solutions to allow reuse of software components i.e. modules . Many different frameworks to support dynamic use of software components have been developed to meet these needs. Examples of such frameworks include the Java Module System JAM the OSGi Service Platform the Microsoft .NET Framework the Apache Software Foundation Maven and the Sun Microsystems NetBeans . Java and NetBeans are trademarks of Sun Microsystems Inc. OSGi is a trademark of The OSGi Alliance.

While specific implementation details and programming languages supported may vary module frameworks share a number of common features. Functionality included in a module framework may include a runtime engine module life cycle management one or more module repositories and module version management. This functionality allows off the shelf software modules to be reused and integrated into applications coherently and to be dynamically added updated and removed from the framework. In addition modules may dynamically discover and cooperate with each other.

In module frameworks a given module may be defined to depend on multiple other modules which may in turn depend on yet other modules. More specifically a module may export one or more interfaces that may be imported by other modules. As a result when a module is instantiated by the framework some initialization may need to be performed to ensure among other things that any modules on which that module depends are present i.e. that the imported interfaces are available and can also be instantiated and that there are no conflicts among these modules e.g. two modules export a class having the same name . This initialization process typically varies depending on the framework and the composition of the modules.

In general in one aspect the invention relates to a method for initializing a module. The method includes identifying a first module for initialization and performing a plurality of processing phases on the first module and all modules in a dependency graph of the first module. Performing the plurality of processing phases includes for each module executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module.

In general in one aspect the invention relates to a module system. The module system includes module storage configured to store a plurality of module definitions and a module initialization engine configured to initialize a first module created from a module definition of the plurality of module definitions by performing a plurality of processing phases on the first module and all modules in a dependency graph of the first module. Performing the plurality of processing phases includes for each module executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module.

In general in one aspect the invention relates to a computer readable medium. The computer readable medium includes executable instructions to initialize a module by identifying a first module for initialization and performing a plurality of processing phases on the first module and all modules in a dependency graph of the first module. Performing the plurality of processing phases includes for each module executing a processing phase of the plurality of processing phases on the module determining whether the processing phase has been executed on all modules in a dependency graph of the module and when the processing phase has been executed for all modules in the dependency graph of the module executing a subsequent processing phase of the plurality of processing phases on the module.

Other aspects of the invention will be apparent from the following description and the appended claims.

Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.

In the following detailed description of embodiments of the invention numerous specific details are set forth in order to provide a more thorough understanding of the invention. However it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail to avoid unnecessarily complicating the description.

In general embodiments of the invention provide a method and system for initializing a module in a module system. More specifically in one or more embodiments of the invention when a module is selected for execution the selected module and all modules on which the selected module directly or indirectly depends i.e. dependent modules are initialized by executing a sequence of processing phases on each of these modules i.e. the selected module and the dependent modules . Each processing phase performs an operation on a module e.g. identifying modules on which the module depends verifying constraints etc. .

Further each processing phase on each module is followed by a graph walking phase. The graph walking phase walks a graph of the transitive closure of the dependent modules of the module to verify that each of the dependent modules have completed the immediately preceding processing phase. The initialization of the module is not allowed to progress to the next processing phase until all of the dependent modules of that module have completed at least the same processing phase as the module. The originally selected module is successfully initialized when a graph walking phase executed on the selected module indicates that all modules in the dependency graph of the selected module have successfully progressed through all of the processing phases.

As shown in the system includes a module system a runtime environment and an operating system . The operating system provides hardware interfaces and system functionality to software such as the runtime environment and the module system executing on a specific hardware platform not shown . The operating system may be any suitable operating system including for example Solaris UNIX Linux and the operating systems available from Microsoft and IBM. Solaris is trademark of Sun Microsystems Inc. UNIX is a registered trademark of The Open Group. Linux is a registered trademark of Linus Torvalds.

The runtime environment provides a software interface for executing applications such as the module system and the modules included in the module system . In one or more embodiments of the invention the runtime environment may be a software library for a specific programming language that provides functionality for interfacing with the underlying operating system e.g. operation system when an application e.g. the module system is executed. In such embodiments the module system is implemented in the programming language and the runtime environment may be linked as a part with the compiled code of the module system . In one or more embodiments of the invention the runtime environment may be a virtual machine that abstracts the underlying operating system and hardware platform. Further in one or more embodiments of the invention the module system may be implemented in Java and the runtime environment may be a Java Virtual Machine.

The module system is a framework for the development and deployment of module based applications and libraries. The module system provides for example a distribution format i.e. a module definition for packaging collections of functions or classes and any related resources along with information i.e. metadata describing the module to the framework a versioning scheme for the modules and runtime support for discovering loading integrity checking and initializing modules. The module system includes an application programming interface API a module manager module storage a module initialization engine a module cache and a module initialization queue . Each of these components of the module system is described in more detail below. Further in one or more embodiments of the invention the module system may be the Java Module System as described in the Java Specification Request JSR JSR 277 available from the Java Community Process website www.jcp.org.

The API provides an interface for requesting various services from the module system . The module initialization queue holds those modules that are currently being initialized by the module system . The module queue may be implemented as any suitable data structure including for example a linked list an array and a circular buffer. The module cache stores fully initialized and instantiated modules and modules that are in the process of being initialized. In one or more embodiments of the invention the module cache may be implemented in any form suitable for storing modules including for example one or more data structures in the memory of a computer system one or more databases and one or more files in a file system.

Module storage stores module definitions for the modules configured for use with the module system. In one or more embodiments of the invention the module definitions stored in module storage may include module definitions provided by a vendor of the module system module definitions developed by one or more users of the module system and or module definitions from third party vendors. A module definition is used to instantiate i.e. create an instance of the module it describes. In one or more embodiments of the invention a module definition for example specifies what classes and resources are provided by a module what functionality the module imports and exports and the version of the module. A module definition is described in more detail below in reference to . In one or more embodiments of the invention module storage may be for example one or more databases file systems file or database servers any other suitable storage medium and combinations thereof.

In one or more embodiments of the invention module storage may include one or more module repositories. A module repository is a mechanism for storing discovering and retrieving module definitions in the module system . Module repositories may include a bootstrap repository that exposes core platform module definitions a global repository that exposes module definitions that may be shared by multiple processes an application repository that exposes module definitions specific to an application a URL repository that exposes module definitions stored on a server and or other user defined repositories. A more detailed description of one example of module repositories may be found in JSR 277.

The module manager includes functionality to receive requests from the API interact with other parts of the module system to fulfill the requests and provide any results of fulfilling the requests to the API . The module manager further includes functionality to manage the initialization of modules whose module definitions are stored in module storage . For example in one or more embodiments of the invention a request is made to the module system through the API to locate a specific module definition in module storage using for example the module name or other information that identifies the module. A second request is then made to the module system through the API to request a module corresponding to the module definition from the module manager . The module manager first checks the module cache to see if the requested module has already been initialized or is in the process of being initialized. If the requested module is not in the module cache the module manager causes a module object to be created from the module definition and added to the module cache and to the module initialization queue .

The module initialization engine includes functionality to initialize the modules in the module initialization queue . More specifically the module initialization engine performs a multi phase initialization process on each module in the module initialization queue . As is explained in more detail in reference to below the multi phase initialization process includes both processing phases and graph walking phases. In one or more embodiments of the invention in the initialization process each processing phase on a module is followed by a graph walking phase on the module. In addition once a specific processing phase is performed on a module the next processing phase in the initialization process is not executed on the module until all dependent modules of the module have successfully completed at least the specific processing phase. Further in some embodiments of the invention the processing phases in the initialization process are required to be executed in a specific order.

While the number of processing phases is not necessarily limited in one or more embodiments of the invention the number of processing phases may be predetermined. For example some embodiments of the invention may include only two processing phases while other embodiments of the invention may include three processing phases four processing phases etc. In some embodiments of the invention the number of processing phases performed may be application or module dependent. For example the multi phase initialization process may include some number of required processing phases and allow for one or more optional processing phases. In such embodiments an optional processing phase may be performed upon request by an application that requests a module from the module system and or if indicated in a module definition. Thus the number of processing phases performed on a module and its dependent modules may be dynamically determined at run time.

A processing phase is a phase in which some initialization operation is performed on a module. An initialization operation may be for example identifying those modules on which a module depends and adding those dependent modules to the initialization queue if the dependent modules have not been initialized. An initialization operation may also be for example checking for namespace conflicts between dependent modules. In one or more embodiments of the invention there are two possible outcomes to a processing phase the module progresses to the graph walking phase or the module is marked to indicate that the processing phase did not complete successfully e.g. the module is marked as being in an error state .

The graph walking phase that follows each processing phase is used to determine whether the next processing phase can be performed on the module i.e. that all dependent modules of a module have successfully completed at least the same processing phase as the module. In one or more embodiments of the invention a graph walking phase walks the graph of the transitive closure of a module s dependent modules to verify that each of the dependent modules has successfully completed at least the same processing phase as the module.

In one or more embodiments of the invention there are four possible outcomes of a graph walking phase 1 if any processing phase was not successfully completed on a dependent module the module is marked to indicate that the module cannot be successfully initialized e.g. the module is marked as being in an error state and initialization of the module is aborted 2 if all dependent modules have completed at least the same processing phase as the module the next processing phase is performed on the module 3 if all dependent modules have completed at least the same processing phase as the module and all processing phases have been completed on the module the module is marked to indicate successful initialization and is removed from the module initialization queue and 4 if all dependent modules have not completed at least the same processing phase the module is marked to indicate that the processing phase has been completed on the module the module initialization engine selects the next module in the module initialization queue to process and the graph walking phase is repeated the next time the module initialization engine selects the module from the module initialization queue for processing.

Module metadata includes information about the module that may be needed for initialization and instantiation of the module and or for other modules to be able to use the module. In one or more embodiments of the invention module metadata may include a name of the module the imports and class exports of the module and the members of the module. The name may be a text string or any other suitable identifier for the module. The imports specify the modules that are imported by the module. More specifically the imports identify those modules on which a module instantiated from the module definition directly depends. In one or more embodiments of the invention the imports are used by the module initialization engine of to identify the direct dependent modules of a module during a processing phase.

The class exports specify which of the classes in the module classes are visible to other modules i.e. may be called by other modules. In one or more embodiments of the invention the class exports may also identify classes that are re exported by the module i.e. classes that are imported from another module and then exported by the module. In one or more embodiments of the invention the class exports are used by the module initialization engine of to check for naming conflicts between modules during a processing phase. The members identify the classes that are part of the module.

In one or more embodiments of the invention the module metadata may also include a version a main class attributes and resource exports . The version specifies the version of the module represented by the module definition . The main class identifies a class of the module classes that is an entry point for the module i.e. the initial class to be called to start execution of the module. The resource exports identify those resources of the module resources that are exported i.e. made visible by the module. In one or more embodiments of the invention a resource may be identified by a path name of the file storing the resource. In one or more embodiments of the invention the resource exports may also identify resources that are re exported by the module i.e. resources that are imported from another module and then exported by the module.

The attributes are used to specify extensions to the module metadata . In more or more embodiments of the invention an attribute may be a name value pair of text strings that uniquely identify the attribute and provide a value for the attribute. The attributes may be defined and used by other modules in the module system of . Further the presence of a particular attribute defined by another module in the module metadata indicates that the module provides a feature of interest to the other module. For example a service loader module may define a service provider attribute that is to be included in modules that contain service providers. At run time when a service is requested by the service loader the module system of can then discover the available service providers by looking in the module storage of for those modules that include the service provider attribute in their module metadata.

As previously mentioned module initialization is a multi phase initialization process that is performed on a module and all modules in a dependency graph of the module i.e. all modules on which the module may directly or indirectly depend. Further the multi phase initialization process includes processing phases and graph walking phases that are performed on each of these modules. In one or more embodiments of the invention each module may include or have associated with it a status indicator that indicates the initialization status of the module. More specifically the status indicator may indicate which phase of the initialization process has most recently been completed on the module. In one or more embodiments of the invention each phase is identified by an integer e.g. 0 1 2 3 4 . . . with the processing phases assigned odd integers the graph walking phases assigned even integers and a phase number of 0 indicating that no processing phase has been performed. Accordingly the status indicator of a module may store the number of the phase most recently completed. For simplicity of explanation the flow diagram of may be described below assuming that the phases are so identified. However other approaches for indicating the initialization status of a module may be used without departing from the scope of the invention and the focus on one particular approach should not be interpreted as limiting the scope of the invention in any way.

In one or more embodiments of the invention a module that is to be initialized is added to a module initialization queue e.g. the module initialization queue of . More specifically in one or more embodiments of the invention a module definition e.g. module definition of may be retrieved from a module repository in module storage e.g. module storage of a module object i.e. a module instance may be created using the module definition and the module instance i.e. the module may be added to the module initialization queue to be initialized. Further an initialization status may be associated with the module. More specifically a status indicator for the module may be set to 0 to indicate that no processing phase has been performed on the module.

The initialization process for the module begins when the module is retrieved from the module initialization queue Step . When a module is retrieved from the module initialization queue a check is made to determine whether the initial processing phase has been performed on the module Step . In one or more embodiments of the invention if the status indicator of the retrieved module is 0 the initial processing phase has not been performed.

If the first processing phase has not been performed on the module that first processing phase is performed Step . In one or more embodiments of the invention in the initial processing phase any modules on which the module directly depends are identified. In one or more embodiments of the invention the dependent modules are the modules imported by the module. Each dependent module that has not been previously initialized or that is not currently undergoing initialization is added to the module initialization queue with a status indicator of 0. Any of the dependent modules that have already been initialized or are currently being initialized may be stored in a module cache e.g. the module cache of with status indicators indicating the initialization phase last completed on those modules. Further in one or more embodiments of the invention the status indicator of the module is set to 1 to indicate that the first phase has been completed on the module.

Upon successful completion of the first processing phase a graph walking phase is performed Step . Further when a module is retrieved from the module initialization queue that has already had the first processing phase performed on it Step a graph walking phase is performed Step . The graph walking phase walks the transitive closure of the dependency graph of the module to determine if the dependent modules of the module have progressed sufficiently to allow the next processing phase if any to be performed on the module. More specifically the graph walking phase walks the dependency graph to determine whether the dependent modules have successfully completed at least the last processing phase that was successfully completed on the module. For example if processing phase has been successfully completed on the module then the graph walking phase checks the dependent modules to determine if at least processing phase has been successfully completed on those modules. In one or more embodiments of the invention more processing phases may have been completed on a dependent module than on the module that depends on it.

If all of the dependent modules have completed at least the processing phase previously completed on the module Step then the initialization process for that module may advance to the next processing phase if any. If all of the processing phases have been successfully completed on the module step the status indicator of the module may be set to indicate that the module is completely initialized and the module may be removed from the module initialization queue. In one or more embodiments of the invention the status indicator is set to the integer representing the final graph walking phase of the initialization process to indicate successful initialization. Further if the module initialization queue is not empty step another module is retrieved from the module initialization queue step and processed.

If all processing phases have not been completed on the module step the next processing phase is performed on the module. Upon completion of the processing phase the status indicator of the module is set to indicate completion. In one or more embodiments of the invention the status indicator is set to the integer representing the processing phase completed. For example if processing phase is performed the status indicator is set to 3. Another graph walking phase is then performed on the module Step . The cycle of performing a graph walking phase and a processing phase on the module Steps continues until either there are no more processing phases to be performed Step or the processing phase performed on the module prior to the graph walking phase has not been completed on the dependent modules Step .

If all of the dependent modules have not completed at least the processing phase previously completed on the module Step then module is returned to the module initialization queue and another module is retrieved from the module initialization queue for processing Step . In one or more embodiments of the invention the status indicator of the module is set to indicate that a graph walking phase should be performed on the module the next time the module is retrieved from the module initialization queue.

In one or more embodiments of the invention a module is successfully initialized when all phases of the multi phase initialization process have been successfully performed on the module and any modules on which the module directly or indirectly depends. Further in one or more embodiments of the invention the number of processing phases in an initialization process is arbitrary. More specifically the above described methods and systems for initialization do not limit the number of processing phases that may be included in embodiments of the invention. However in some embodiments of the invention the number of processing phases may be predetermined.

The example in illustrates the application of the multi phase initialization process in initializing module A . shows the dependencies of module A . Module A imports module B and module C so module A directly depends on module B and module C . Module B imports module A so module B directly depends on module A. Further the dependency of module B on module A and vice versa creates a cycle in the dependency graphs of module A and module B . Module C imports module D so module C directly depends on module D and module A indirectly depends on module D . Module D does not import another module so module D has no direct dependencies.

As is shown in when initialization of module A is requested the status indicator labeled as Phase in of module A is set to 0 to indicated that no phase of the initialization process has been performed module A . In addition module A is added to the module initialization queue . At this point in the initialization process the dependent modules of module A have not been identified so the dependency graph of module A includes only module A .

Subsequently the initialization process removes module A from the module initialization queue and phase a processing phase is successfully performed on module A followed by the first graph walking phase phase . As is shown in after phases and are performed the direct dependent modules of module A i.e. module B and module C have been identified and placed in the module initialization queue to be initialized. Further the status indicators of both module B and module C have been set to 0 to indicate that no phase of the initialization process has been performed on these modules. In addition the status indicator of module A has been set to 1 to indicate that phase was successfully completed on module A .

After the execution of phase the dependency graph of module A now includes module B and module C . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module A the outcome indicates that phase has not yet been performed on either module B or module C . Therefore module A is not permitted to advance to the next processing phase in the initialization process. Accordingly module A is put back on the module initialization queue .

The initialization process then retrieves the next module module B from the module initialization queue . Phase is successfully performed on module B followed by the first graph walking phase phase . As is shown in after phases and are performed the direct dependent module of module B i.e. module A is identified. Module A is already being initialized so it is already in the module initialization queue . Further the status indicator of module B has been set to 1 to indicate that phase was successfully completed on module B .

After the execution of phase the dependency graph now indicates the cyclic dependency relationship between module B and module A . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module B the outcome is that phase has been performed on module A a direct dependent module of module B but not on module C an indirect dependent module of module B . Therefore module B is not permitted to advance to the next processing phase in the initialization process. Accordingly module B is put back on the module initialization queue .

The initialization process then retrieves the next module module C from the module initialization queue . Phase is successfully performed on module C followed by the first graph walking phase phase . As is shown in after phases and are performed the direct dependent module of module C i.e. module D is identified and added to the module initialization queue for initialization. The status indicator for module D has also been set to 0 to indicate that no phase of the initialization process has been performed on module D . Further the status indicator of module C has been set to 1 to indicate that phase was successfully completed on module C .

After the execution of phase the dependency graph now includes module D . When the graph walking phase phase is performed on the transitive closure of the dependency graph of module C the outcome is that phase has not been performed on module D . Therefore module C is not permitted to advance to the next processing phase in the initialization process. Accordingly module C is put back on the module initialization queue .

The initialization process then retrieves the next module module A from the module initialization queue . The status indicator of module A indicates that the last processing phase performed on module A was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module A again to determine whether module A is permitted to progress to the next processing phase. The outcome of performing the graph walk is that the direct dependent modules of module A module B and module C have completed phase but the indirect dependent module of module A module D has not completed phase . Therefore module A is not permitted to advance to the next processing phase in the initialization process. Accordingly module A is put back on the module initialization queue .

The initialization process then retrieves the next module module B from the module initialization queue . The status indicator of module B indicates that the last processing phase performed on module B was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module B again to determine whether module B is permitted to progress to the next processing phase. The outcome of performing the graph walk is that the direct dependent module of module B module A has completed phase but one of the indirect dependent modules of module B module D has not completed phase . Therefore module B is not permitted to advance to the next processing phase in the initialization process. Accordingly module B is put back on the module initialization queue .

The initialization process then retrieves the next module module D from the module initialization queue . Phase is successfully performed on module D followed by the first graph walking phase phase . As is shown in after phase is performed the dependency graph is unchanged as module D has no direct dependent modules. When the graph walking phase phase is performed on the transitive closure of the dependency graph of module D the outcome is clearly that phase has been performed on all dependent modules of module D as module has no dependent modules. Therefore module D is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module D in which any direct dependent modules of module D are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module D . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module D . As phase is the last phase of the initialization process the status indicator of module D is set to 4 to indicate successful completion of all phases of the initialization process. Further module D is not returned to the module initialization queue as module D is completely initialized.

The initialization process then retrieves the next module module C from the module initialization queue . The status indicator of module C indicates that the last processing phase performed on module C was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module C again to determine whether module C is permitted to progress to the next processing phase. The outcome of the graph walking phase is that the direct dependent module of module C module D has successfully completed the last processing phase performed on module C i.e. phase . Therefore module C is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module C in which any direct dependent modules of module C are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module C . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module C . As shown in because phase is the last phase of the initialization process the status indicator of module C is set to 4 to indicate successful completion of all phases of the initialization process. Further module C is not returned to the module initialization queue as module C is completely initialized.

The initialization process then retrieves the next module module A from the module initialization queue . The status indicator of module A indicates that the last processing phase performed on module A was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module A again to determine whether module A is permitted to progress to the next processing phase. The outcome of the graph walking phase is that all of the direct and indirect dependent modules of module A have completed the last processing phase performed on module A i.e. phase . Therefore module A is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module A in which any direct dependent modules of module A are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module A . The outcome of the phase graph walk is clearly that phase has not been performed on all dependent modules of module A as only phase has been performed on module B . Therefore module A cannot progress to completion of the initialization process. As shown in the status indicator of module A is set to 3 to indicate successful completion of phase of the initialization process. Further module A is returned to the module initialization queue as module A is not yet completely initialized.

The initialization process then retrieves the next module module B from the module initialization queue . The status indicator of module B indicates that the last processing phase performed on module B was phase so the first graph walking phase phase is performed on the transitive closure of the dependency graph of module B again to determine whether module B is permitted to progress to the next processing phase. The outcome of the graph walking phase is that all direct and indirect dependent modules of module B have successfully completed the last processing phase performed on module B i.e. phase . Therefore module B is permitted to advance to the next processing phase in the initialization process phase .

Phase is performed on module B in which any direct dependent modules of module B are checked for name conflicts. Upon successful completion of phase the second graph walking phase phase is performed on the transitive closure of the dependency graph of module B . The outcome of the phase graph walk is clearly that phase has been performed on all dependent modules of module B . As shown in because phase is the last phase of the initialization process the status indicator of module B is set to 4 to indicate successful completion of all phases of the initialization process. Further module B is not returned to the module initialization queue as module B is completely initialized.

The initialization process then retrieves the next module module A from the module initialization queue . The status indicator of module A indicates that the last processing phase performed on module A was phase so the second graph walking phase phase is performed on the transitive closure of the dependency graph of module A again to determine whether module A is permitted to progress to completion of the initialization process. The outcome of the graph walking phase is that all direct and indirect dependent modules of module A have successfully completed the last processing phase performed on module A i.e. phase . As shown in because phase is the last phase of the initialization process the status indicator of module A is set to 4 to indicate successful completion of all phases of the initialization process. Further module A is not returned to the module initialization queue as module A is completely initialized.

Embodiments of the invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system may be connected to a network e.g. a local area network LAN a wide area network WAN such as the Internet or any other similar type of network via a network interface connection not shown . Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the aforementioned computer system may be located at a remote location and connected to the other elements over a network. Further embodiments of the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention e.g. module system module storage module cache etc. may be located on a different node within the distributed system. In one embodiment of the invention the node may be a computer system. Alternatively the node may be a processor with associated physical memory. The node may alternatively be a processor with shared memory and or resources. Further software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape a file or any other computer readable storage device.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly the scope of the invention should be limited only by the attached claims.

