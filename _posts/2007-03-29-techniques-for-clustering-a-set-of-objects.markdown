---

title: Techniques for clustering a set of objects
abstract: Described are techniques for clustering a data set of objects. Divide phase processing is performed to partition the data set into two or more partitions forming a hierarchy of the objects. Merge phase processing may be performing using the hierarchy to determine one or more disjoint clusters of objects of the data set. Optional preprocessing may be performed to determine weights for one or more features of an object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07752233&OS=07752233&RS=07752233
owner: Yale University
number: 07752233
owner_city: New Haven
owner_country: US
publication_date: 20070329
---
This application claims priority from U.S. Provisional Application No. 60 787 064 filed Mar. 29 2006 EIGENCLUSTER A DIVIDE AND MERGE METHOD FOR FINDING INNATE CLUSTERINGS ON THE FLY which is incorporated herein by reference.

This invention was made with Government support under Grant Number CCR 0312339 awarded by NSF. The Government has certain rights in the invention.

This application generally relates to techniques for information organization and more particularly to techniques used in connection with clustering a set of objects so that similar objects are in a same group and dissimilar objects are in different groups.

Data may be stored in an electronic form for use with computerized techniques. A large amount of computerized data used in connection with a variety of different applications presents a challenge for how to locate and organize relevant information. Clustering refers to the process of classifying a set of data objects such as documents included in the computerized data into groups so that each group includes similar objects and objects belonging to other groups are dissimilar. In other words objects of a first group are similar to one another but are also dissimilar with respect to other objects belonging to other groups. Existing techniques for clustering objects include a hierarchical clustering approach or a partitional approach. Hierarchical algorithms proceed successively by either merging smaller clusters into larger ones or by splitting larger clusters. In contrast partitional algorithms determine all clusters at once by decomposing the data set into a set of disjoint clusters. Hierarchical clustering algorithms can be further described as either a divisive method i.e. top down or an agglomerative method i.e. bottom up . A divisive algorithm begins with the entire set and recursively partitions that data set it into two or more pieces forming a tree. An agglomerative algorithm starts with each object in its own cluster and iteratively merges clusters.

In accordance with one aspect of the invention is a method for clustering a data set of objects comprising performing divide phase processing to partition the data set into two or more partitions forming a hierarchy of the objects and performing merge phase processing using the hierarchy to determine one or more disjoint clusters of objects of the data set. The divide phase processing may further comprise partitioning the data set into two partitions and repeatedly partitioning each of the two partitions wherein the hierarchy has a number of levels in accordance with a number of times the data set or a portion thereof is partitioned. The divide phase processing may partition a portion of the data set into two pieces each of said two pieces have a number of objects determined in accordance with one or more dividing criteria. Merge phase processing may further comprise merging objects of the data set into one or more clusters in accordance with one or more merging criteria and in accordance with nodes of the hierarchy each node being associated with one or more objects of the data set. An input to the divide phase may be a matrix of pairwise similiarities between pairs of objects in the data set. A pairwise similarity between a pair of objects may be expressed as an inner product of a first vector of features characterizing a first object of the pair and a second vector of features characterizing a second object of the pair. The divide phase may further comprise normalizing each row of the matrix of similarities based on a sum of each row computing a second largest eigenvector of the matrix sorting eigenvector elements in increasing order the eigenvector having n elements evaluating n 1 cuts in accordance with one or more divide phase criteria each of said n 1 cuts indicating one way in which the objects are partitioned with a first portion of objects included in a first partition and a second portion of remaining objects included in a second partition selecting one of said n 1 cuts in accordance with the divide phase criteria and performing said normalizing said computing said sorting said evaluating and said selecting steps recursively on each of said first partition and said second partition. The selecting step may select one of the n 1 cuts resulting in two partitions S and T of objects in the data set that minimizes conductance represented as a sum of similarities between each pair of objects wherein a first object in said each pair is in S and a second object in said each pair is in T divided by a smaller of a size of S and a size of T and wherein each similarity is expressed as a product of a first feature vector for said first object and a second feature vector for said second object. The hierarchy may be a tree having a root node at a top level one or more leaf nodes at a bottom most level and one or more non leaf nodes at one or more levels between said top level and said bottom most level wherein said merge phase may recursively perform bottom up processing of said tree to merge objects associated with nodes of the tree starting with the one or more leaf nodes and progressing upward toward the root node and merging objects of the data set into one or more clusters in accordance with one or more merging criteria and in accordance with nodes of the hierarchy each node being associated with one or more objects of the data set. The merge phase may further comprise performing for each leaf node at a bottom most level in said tree evaluating in accordance with one or more merging criteria one or more clustering configuration options used in forming k clusters for each value of k 1 k n n representing a maximum number of clusters formed for the bottom most level selecting a best clustering configuration option for each value of k and performing said evaluating and said selecting for each ancestor node of each leaf node. The method may also include performing said evaluating and said selecting for each ancestor node after evaluating the clustering configurations for the children of each ancestor node until said evaluating and said selecting has been performed for said root node. The one or more merging criteria may include an objective function evaluated using dynamic programming. The merging criteria may include a k means objective function generating a return value for a clustering configuration of one or more clusters by determining a sum of squared distances of objects in each cluster of the clustering configuration to a centroid of the cluster and then adding the sums for each of the clusters to determine a final sum as said return value and said selecting selects a clustering configuration having a smallest return value determined by the k means objective function wherein a distance of an object is a difference between a first value associated with the object and the average of the first values for objects in said each cluster. The merging criteria may include a min diameter objective function generating a return value for a clustering configuration of one or more clusters by determining for each cluster a diameter determined as a maximum distance between any pair of objects in said each cluster of the clustering configuration and then determining as said return value a maximum of the diameters for each of the clusters and said selecting selects a clustering configuration having a smallest return value determined by the min diameter objective function wherein a distance between a pair of objects is a difference between values associated with each object of the pair. The merging criteria may include a min sum objective function generating a return value for a clustering configuration of one or more clusters by determining for each cluster in the clustering configuration a sum of pairwise distances within said each cluster and adding said sums for each cluster to determine a final sum as said return value and said selecting selects a clustering configuration having a smallest return value determined by the min sum objective function wherein a distance between a pair of objects is a difference in between values associated with each object of the pair. The merging criteria may include a correlation clustering objective function generating a return value for a clustering configuration of one or more clusters the method may further comprise receiving an indicator for each pair of objects in the data set said indicator indicating whether the pair of objects is similar or dissimilar determining a first sum for each of the one or more clusters the first sum representing the number of similar pairs of objects in said each cluster determining a second sum representing a number of dissimilar pairs of objects wherein a first object of each pair is in a different cluster than a second object of said each pair and determining a final sum as said return value by adding said first sum for each of the one or more clusters and said second sum and wherein said selecting selects a clustering configuration having a largest value determined by the correlation clustering objective function. Each object in the data set may be described by a vector of one or more feature values for corresponding one or more features characterizing said each object and the method may further comprise prior to said divide phase processing performing preprocessing to determine weights for each of said one or more features. The divide phase may use a matrix of pairwise similarities between pairs of objects in the data set similarity between two objects being represented as a product of feature values for said two objects and the method may further comprise determining weighted similarities between pairs of objects as a product of the weights for said one or more features a first vector of feature values for a first object in a pair and a second vector of feature values for a second object in the pair and using said weighted similarities in said divide phase processing to partition the data set into two or more partitions.

In accordance with another aspect of the invention is a method for clustering a data set of objects comprising repeatedly dividing the data set to form a tree structure based on similarities between pairs of objects and one or more divide phase criteria each node of the tree structure being associated with one or more objects of the data set wherein a level is formed in the tree structure each time the data set or a portion thereof is partitioned and starting with leaves of the tree structure and progressing toward a root of the tree structure merging nodes of the tree structure to form one or more clusters in accordance with one or more merging criteria each of said one or more clusters being a subtree of the tree structure wherein the subtree has a root at a node of the tree structure generated by said repeatedly dividing wherein objects in a same cluster are determined to be similar to one another and objects in a different cluster are determined to be dissimilar from one another. The tree structure may include one or more leaf nodes each of the one or more leaf nodes being associated with a single object in the data set. The merging criteria may be used to determine a best way to cluster objects in accordance with the tree structure.

In accordance with another aspect of the invention is a computer readable medium comprising code stored thereon for clustering a data set of objects the computer readable medium comprising code stored thereon for performing divide phase processing to partition the data set into two or more partitions forming a hierarchy of the objects and performing merge phase processing using the hierarchy to determine one or more disjoint clusters of objects of the data set. The code for performing the divide phase processing may further comprise code for partitioning the data set into two partitions and repeatedly partitioning each of the two partitions wherein the hierarchy has a number of levels in accordance with a number of times the data set or a portion thereof is partitioned. The code for performing the divide phase processing may partition a portion of the data set into two pieces each of said two pieces have a number of objects determined in accordance with one or more dividing criteria. The code for performing merge phase processing may further comprise code for merging objects of the data set into one or more clusters in accordance with one or more merging criteria and in accordance with nodes of the hierarchy each node being associated with one or more objects of the data set and wherein an input to the divide phase is a matrix of pairwise similiarities between pairs of objects in the data set a pairwise similarity between a pair of objects is expressed as an inner product of a first vector of features characterizing a first object of the pair and a second vector of features characterizing a second object of the pair. The code for performing the divide phase processing may further comprise code for normalizing each row of the matrix of similarities based on a sum of each row computing a second largest eigenvector of the matrix sorting eigenvector elements in increasing order the eigenvector having n elements evaluating n 1 cuts in accordance with one or more divide phase criteria each of said n 1 cuts indicating one way in which the objects are partitioned with a first portion of objects included in a first partition and a second portion of remaining objects included in a second partition selecting one of said n 1 cuts in accordance with the divide phase criteria and performing said normalizing said computing said sorting said evaluating and said selecting steps recursively on each of said first partition and said second partition. The code for said selecting may select one of the n 1 cuts resulting in two partitions S and T of objects in the data set that minimizes conductance represented as a sum of similarities between each pair of objects wherein a first object in said each pair is in S and a second object in said each pair is in T divided by a smaller of a size of S and a size of T and wherein each similarity is expressed as a product of a first feature vector for said first object and a second feature vector for said second object. The hierarchy may be a tree having a root node at a top level one or more leaf nodes at a bottom most level and one or more non leaf nodes at one or more levels between said top level and said bottom most level wherein said merge phase recursively performs bottom up processing of said tree to merge objects associated with nodes of the tree starting with the one or more leaf nodes and progressing upward toward the root node and said merge phase merges objects of the data set into one or more clusters in accordance with one or more merging criteria and in accordance with nodes of the hierarchy each node being associated with one or more objects of the data set. The code for performing the merge phase processing may further comprise code for performing for each leaf node at a bottom most level in said tree evaluating in accordance with one or more merging criteria one or more clustering configuration options used in forming k clusters for each value of k 1 k n n representing a maximum number of clusters formed for the bottom most level selecting a best clustering configuration option for each value of k and performing said evaluating and said selecting for each ancestor node of each leaf node. The computer readable medium may also include code for performing said evaluating and said selecting for each ancestor node after evaluating the clustering configurations for the children of each ancestor node until said evaluating and said selecting has been performed for said root node. One or more merging criteria may include an objective function evaluated using dynamic programming. Each object in the data set may be described by a vector of one or more feature values for corresponding one or more features characterizing said each object and the computer readable medium further comprising code for prior to said divide phase processing performing preprocessing to determine weights for each of said one or more features. The divide phase may use a matrix of pairwise similarities between pairs of objects in the data set similarity between two objects being represented as a product of feature values for said two objects and the computer readable medium may further comprise code for determining weighted similarities between pairs of objects as a product of the weights for said one or more features a first vector of feature values for a first object in a pair and a second vector of feature values for a second object in the pair and using said weighted similarities in said divide phase processing to partition the data set into two or more partitions.

Referring now to illustrated is an example of a suitable computing environment in which embodiments utilizing the techniques described herein may be implemented. The computing environment illustrated in is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the techniques described herein for clustering a set of objects. Those skilled in the art will appreciate that the techniques described herein may be suitable for use with other general purpose and specialized purpose computing environments and configurations. Examples of well known computing systems environments and or configurations include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The techniques set forth herein may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Included in are a computer and a network . The computer may include a standard commercially available computer or a special purpose computer that may be used to execute one or more program modules. Described in more detail elsewhere herein are program modules that may be executed by the computer in connection with clustering a set of objects using techniques described herein. The computer may operate standalone as well as in a networked environment and communicate with other computers not shown in .

It will be appreciated by those skilled in the art that although the computer is shown in the example as communicating in a networked environment the computer may communicate with other components utilizing different communication mediums. For example the computer may communicate with one or more components utilizing a network connection and or other type of link known in the art including but not limited to the Internet an intranet or other wireless and or hardwired connection s .

Referring now to shown is an example of components that may be included in a computer as may be used in connection with performing the various embodiments of the techniques described herein. The computer may include one or more processing units memory a network interface unit storage one or more other communication connections and a system bus used to facilitate communications between the components of the computer .

Depending on the configuration and type of computer memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. Additionally the computer may also have additional features functionality. For example the computer may also include additional storage removable and or non removable including but not limited to USB devices magnetic or optical disks or tape. Such additional storage is illustrated in by storage . The storage of may include one or more removable and non removable storage devices having associated computer readable media that may be utilized by the computer . The storage in one embodiment may be a mass storage device with associated computer readable media providing non volatile storage for the computer . Although the description of computer readable media as illustrated in this example may refer to a mass storage device such as a hard disk or CD ROM drive it will be appreciated by those skilled in the art that the computer readable media can be any available media that can be accessed by the computer . Computer readable media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data as may be used in connection with the techniques herein. Computer readable media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer .

The computer may also contain communications connection s that allow the computer to communicate with other devices and components such as by way of example input devices and output devices. Input devices may include for example a keyboard mouse pen voice input device touch input device etc. Output device s may include for example a display speakers printer and the like. These and other devices are well known in the art and need not be discussed at length here. The one or more communications connection s are an example of communication media.

In one embodiment the computer may operate in a networked environment as illustrated in using logical connections to remote computers through a network. The computer may connect to the network of through a network interface unit connected to bus . The network interface unit may also be utilized in connection with other types of networks and or remote systems and components.

One or more program modules and or data files may be included in storage . During operation of the computer one or more of these elements included in the storage may also reside in a portion of memory such as for example RAM for controlling the operation of the computer . The example of illustrates various components including an operating system a preprocessing module a divide phase module a merge phase module and other components inputs and or outputs . The operating system may be any one of a variety of commercially available or proprietary operating systems. The operating system for example may be loaded into memory in connection with controlling operation of the computer. The modules and may be used in connection with techniques described herein for clustering of a set of objects. The techniques herein combine a top down divide phase as may be performed by the divide phase module with a bottom up merge phase as may be performed by the merge phase module. The preprocessing phase module may be used to perform optional preprocessing for determining a set of weights used to accordingly weight inputs used with the subsequent divide phase processing. The foregoing components included in as well as other inputs and outputs are described in more detail in following paragraphs.

Although the components such as the different modules and are shown as being included in a single computer system the components may be included on different computer systems and operate in accordance with the techniques described herein. For example a preprocessor module may be included and operate on a first computer. The divide phase module and merge phase module may be included and operate on another computer system connected to the first computer such as through the network as illustrated in . During operation the first computer may execute code of the module to generate output that may be optionally used by the divide phase module on the other computer system. The foregoing and other variations of the exemplary embodiments described herein will be appreciated by those of ordinary skill in the art.

Described herein are techniques that may be used in connection with a divide and merge methodology for clustering a set of objects. As mentioned above the divide and merge methodology may also be used in combination with a preprocessing phase to generate weights for the different features associated with the objects of a data set. Although the preprocessing phase is illustrated in connection with the divide and merge methodology the preprocessing phase may also be used in connection with other techniques. Additionally an embodiment does not have to perform preprocessing and may perform the divide and merge phase processing without preprocessing.

Referring now to shown is an example of components that may be included in an embodiment utilizing the techniques described herein. The example illustrates a preprocessing phase a divide phase and a merge phase . The preprocessing phase divide phase and merge phase may be performed respectively by the modules and of . In this example the optional preprocessing phase utilizes a feature selection component to generate a set of weights based on a subset of objects for which similarity ratings are provided. The similarity ratings may be user specified. The divide phase uses the weights which include a weight for each feature of an object and the data set as inputs. The divide phase generates a binary tree representing a hierarchical clustering of the data set of objects . The merge phase takes as an input the binary tree and performs bottom up processing on the tree to determine one or more clusters or groups of similar objects in the data set as represented by clusters . Each of the clusters in may include objects of the data set which have been grouped together in accordance with specified criteria. For example an embodiment may determine a configuration of clusters which minimizes the degree of dissimilarity between objects in a same cluster and also minimizes the degree of similarity between objects of different clusters. Each of the foregoing phases inputs and outputs and criteria that may be included in an embodiment are described in more detail herein.

The data set may be characterized as a set of objects. Each object has a set of features describing that object. For example the data set may include a collection of web pages that are text based documents having features characterizing each web page. Features may include for example the different words in each page and the number of occurrences of each word. The data set of objects that may be used in connection with the techniques described herein may vary. The techniques described herein may be used in connection with varying types of data sets including for example medical data financial data images and the like. Data sets of a same type may use the same features.

Referring now to shown is an example illustrating a representation of features for a data set of objects. In the example a matrix may be used to represent the feature values of each object. Each row in the matrix includes a set of feature values for an object. Each column of the matrix represents values of the same feature for all objects in the data set. In the representation there are n features for each object.

The preprocessing phase may be used to determine weights for each of the features associated with an object. In one embodiment a weight denoted was the weight of the ith feature can be a value between 0 and 1 inclusively. As described elsewhere herein in more detail the weights may vary with the type of data set and may be recomputed for different data sets. A same set of weights may also be used in connection with the same data set as well as different data sets of the same type. A similarity function S may be used to determine a value representing a weighted degree of similarity between two objects a and b of a data set for n features 

Referring now to shown is an example representation of the input of . A user may select a subset of objects from the data set . For this subset the user may input a similarity value S for each pair of objects in the subset. In the example an entry g h in the user input matrix wherein g row identifier and h column identifier for the entry is the value of S representing the similarity between object g and object h in the subset of objects. It should be noted that the user input may be in a variety of different forms besides as illustrated in .

T may represent the matrix of user input similarities for the subset as illustrated in . The goal of preprocessing is to determine values for w . . . w so that the similarity function S e.g. WEIGHTED SIMILARITY FUNCTION S above is as close as possible to T. The goal of preprocessing may be represented as minimizing a function F W 

What will now be described is a technique that may be used in connection with determining the weights by solving a system of linear equations as illustrated in . The example includes an n n matrix A an n 1 vector and an n 1 vector where n is the number of features.

In the example the unknown weights being solved for in the system of equations are represented by element . The values of the Matrix A and the vector of constants may be determined by taking the derivative of the function F W as set forth above for each w with respect to w k assuming values from 1 . . . n inclusively and setting the derivative of the function F W to 0 zero . The foregoing may be represented as 

Using the resulting linear system of equations as illustrated in the example the weights may be solved for using known techniques such as for example Gaussian elimination. Following is additional detail regarding the equations used in connection with the techniques herein for determining the weights.

Once the values for the matrix A and the vector of constants have been determined the system of equations may be solved using for example Gaussian elimination. A variety of different programming routines and software packages may be used in connection with solving the system of linear equations such as for example MATLAB by MathWorks.

The divide phase is described in more detail in following paragraphs. As also described elsewhere herein the phases and may be used alone or in combination with the preprocessing phase . In other words the phases and may use features which are not weighted e.g. without preprocessing phase or weighted e.g. with preprocessing phase . An embodiment using weights also does not have to compute the weights with each execution of the phases and . An embodiment may utilize a previously computed and stored set of weights for a particular data set of objects such as documents. For example an embodiment may determine weights for each of one or more varying types of data sets that may be used with phases and . The weights may be determined offline from the divide phase and merge phase . At some later point after multiple sets of weights for different data sets are determined a selected one of the weights may be used in connection with the divide phase and the merge phase in accordance with the particular data set.

In one embodiment the divide phase takes as an input the data set . The input data set may be represented in a variety of different forms. In one embodiment the input data set may be in the form of a matrix A similar to that as described in connection with in which a row represents the features of a particular object. The row index corresponds to a particular object and the column index corresponds to one of the features for each object. Thus the ith object may be denoted as a row vector of the matrix. As an additional input to what is described elsewhere herein the divide phase may also optionally take as an input the set of weights as determined by the preprocessing phase . In an embodiment utilizing weights generated by the optional preprocessing phase the similarity function S of two objects i and j may be defined as a product of the inner product of their term or feature vectors Ai and Aj and the corresponding weight for each of the features as described elsewhere herein in connection with the preprocessing phase. In an embodiment not utilizing weights the similarity function S of two objects i and j may be defined as the inner product of their term vectors Ai and Aj. The similarity matrix may be represented as AA in which Arepresents the transpose of matrix A. The similarity matrix may also be characterized as a complete graph where the vertices are formed by the set of objects with edge weights corresponding to the similarity or weighted similarity between two vertices.

An example representation of divide phase processing is illustrated in . In the example a data set of objects is repeatedly or recursively partitioned into two portions. In one embodiment input data set may be represented in a tree structure of as objects of the root of a tree. In a first instance the divide phase may partition all the objects of the root into multiple pieces such as two pieces and represented as left and right child nodes respectively of their parent node . Data associated with each of the nodes and corresponds to those objects included in each of the two pieces based on the partitioning. As represented in each of the nodes and may be further partitioned in a next step into two portions. The process of repeatedly partitioning objects represented by a node of the tree into two pieces may continue until each leaf node corresponds to a single object in the data set. At the end of the divide phase the resulting tree of may be characterized as a hierarchical clustering of the objects of the input data set . Following paragraphs set forth an exemplary embodiment of the divide phase in which a set of objects of a node of the tree is recursively cut or divided using a spectral algorithm which makes use of the spectrum of the similarity matrix of the data to cluster data points. The cut or partitioning selected at each hierarchical level of the tree may be determined using a quantity called conductance to define a measure of good clustering based on the graph of pairwise similarities. As described above the similarity of two objects is defined as the inner product of their respective feature vectors which may optionally be weighted in accordance with preprocessing. Conductance is described in following paragraphs and the cut selected at each hierarchical level is the cut having the smallest conductance.

It should be noted that a particular technique is described herein for illustrating the divide phase when the objects are represented using the matrix of and the similarity between the objects is the inner product between the corresponding vectors. However it will be appreciated by those skilled in the art that any one of a variety of different divisive techniques may be used to generate a tree whose leaves are the objects themselves and each of the non leaf nodes of the tree represents a subset of the objects including the leaves in the subtree below.

In following paragraphs for purposes of illustration reference may be made to an embodiment in which no weighting is performed.

What will be described is a graphical illustration of processing that may be performed in an embodiment to determine how to make a cut or partition the data elements included in a non leaf node of the tree structure for example as illustrated in . As described above the similarity matrix may also be characterized as a complete graph where the vertices are formed by the set of objects with edge weights corresponding to the similarity between two vertices.

Referring now to shown is a representation as a graph of a set of data objects that may be associated with the root of the tree. Element is an example graphical representation including 4 vertices A B C and D corresponding to 4 different objects as included in . The edge between any two vertices has an edge weight as indicated in representing the similarity between the objects corresponding to the two vertices. The similarity may be determined as described above. It should be noted that elements and are utilized in connection with illustrating further processing steps.

Processing may be performed using techniques herein to determine how to cut or partition the set of data objects of into two partitions or pieces. In connection with of seven 7 different partitionings or cuts are possible as indicated in . In connection with techniques herein a quantity called conductance may be determined for each partitioning or cut. The conductance may be represented as 

Referring to consider the first row of the example in which a first partition consists of A and the second partition consists of BCD. With reference to element a cut may be made representing the partitioning of the first row to segregate A into a grouping separate from BCD. With this cut the numerator of EQUATION 2 evaluates to 3 and the denominator evaluates to 1 since the size of the smallest partition is 1 e.g. partition including element A . The conductance as represented in EQUATION 2 may be determined for each partitioning or cut having values indicated in the third column of table of .

In accordance with techniques herein the cut that minimizes the conductance is selected. With reference to the row has the smallest conductance and is graphically represented in of . The partitioning as represented by row is selected as the partitioning of the vertices. With reference to a tree structure vertices A B C and D may represent objects in a node such as the root node of . The selection of the cut corresponding to row results in the generation of 2 children and of the root in which the left child includes AB and the right child includes CD. Subsequently determining the cut which has the minimum conductance value is determined for each of the children of the root node may be recursively performed for each grouping of vertices included in a tree node until the nodes each contain a single vertex e.g. object .

Referring now to shown is an example of a tree representation formed by selecting a cut among data elements of each non leaf node having a minimum conductance value as determined in accordance with EQUATION 2.

EQUATION 2 may be formally represented as finding a cut for a set of n data elements such that the cut partitions the n data elements into two partitions S and T 1 . . . 1 . . . that minimizes the conductance 

It should be noted that the foregoing determination of a conductance value for each possible cut may become impractical to compute as the number of data elements or objects increases since the computation time scales exponentially with respect to the number of objects.

As a result techniques may be used to approximate the best cut in accordance with the conductance. As will be described in following paragraphs the cut may be determined by computing v an approximation of the second largest eigenvector of the similarity matrix AAnormalized so that all row sums are 1. The ordering of the objects in v gives a set of n 1 cuts n being the number of objects and the best of these cuts is selected based on the minimal conductance value. The foregoing may be performed recursively on each of the partitions determined for the selected cut. To compute the approximation of the second eigenvector the power method may be used. As known in the art the power method is an iterative technique for which it is not necessary to compute the normalized similarity matrix which converges to the second largest eigenvector.

Referring now to shown is a flowchart of processing steps that may be performed in an embodiment using the techniques herein for generating the output of the divide phase. As described elsewhere herein the output of the divide phase in one exemplary embodiment may be a tree in which each leaf node corresponds to a single object in the data set. The steps of repeatedly partitioning each non leaf node in the tree. It should be noted that more detailed processing of the steps of are described in following paragraphs. At step each row of the similarity matrix AA is normalized based on the sum of each row. Each element in a row in the similarity matrix is divided by the sum of the elements in the row. As a result each row of the normalized similarity matrix sums to 1. At step the second largest eigenvector is computed for the similarity matrix. As described in following paragraphs the power method may be used to approximate the second largest eigenvector. At step the elements of the eigenvector are sorted in increasing order. The objects corresponding to each element in the eigenvector are also accordingly ordered and used in forming the subset of possible cuts for evaluation. The ordering of the objects forms a sequence of n 1 cuts for which the conductance value is determined in step . For example if the objects corresponding to the sorted eigenvector elements are ACBD the conductance is determined for the following n 1 cuts n 4 forming 2 partitions 

It should be noted that conductance is only one criterion that may be used for selecting the best cut when repeatedly dividing objects of a node. An embodiment may utilize other criterion criteria and other processing steps to repeatedly divide a data set to form the tree structure or other hierarchical representation of the objects of the data set.

Referring now to shown is a flowchart of more detailed processing steps that may be performed in an embodiment using the techniques herein for generating the output of the divide phase. Flowchart may be characterized as a more detailed implementation of the steps of . As part of normalizing the similarity matrix steps and are performed. At step let be a vector of the row sums of the similarity matrix AA and let

At step the second largest eigenvector v of the following matrix Q is determined Q DRAAD In one embodiment the power method may be used to approximate the second largest eigenvector since the power method converges to the second largest eigenvector. The matrix Q is symmetric and therefore using the power method Q may be iteratively determined using matrix vector multiplication. As known in the art the power method is an iterative technique. The power method is described for example in Howard Anton Elementary Linear Algebra Third Edition John Wiley Sons Inc. 1981. The power method for use herein may be summarized as follows 

It should be noted that the repetition of steps 2 4 in the foregoing power method may be performed O log n times since the iterative power method technique will converge within this time. Step 2 ensures that the vector computed is the second largest eigenvector. As known in the art the second largest eigenvector is orthogonal to the largest eigenvector. As such the power method is performed with a starting vector chosen uniformly over vectors orthogonal to the top or left eigenvector Dwith an eigenvalue of 1 and the power method converges to the second largest eigenvector.

It should be noted that in practice the representation of objects as row vectors in the matrix A may be sparse having many more zeroes than non zero entries so that an embodiment may perform calculations in connection with processing steps herein using sparse matrix multiplications. For example performing step 3 e.g. normalize and step 4 above for setting v Qv may be performed using four sparse vector matrix multiplications as follows represented as follows 

At step v Dv wherein v is the second largest eigenvector from step . Also as part of step the vector v is sorted in increasing order so that v v. Based on this sorted ordering in step a sequential ordering of corresponding objects is specified indicating a set of n 1 cuts to be considered. If v. . . vrepresents the ordering of the elements of the vector v then we want to find the value t that minimizes the conductance of the cut for data elements or objects e.g. rows of the matrix A corresponding to each v.

In connection with calculating the conductance for example as represented using EQUATION 2 associated with each of the n 1 cuts of a vector entry v the numerator portion of the conductance may be represented as uand the denominator portion may be represented as l. The numerator portion for the ith element may be calculated based on the preceding numerator portion for the i 1element.

with the numerator portion being uand the denominator portion represented as l. Each uand lmay be computed using preceding values respectively using uand l.

The denominator may be similarly computed for the n 1 cuts with a single pass through matrix A so that computation time is O M .

Once the cut having the minimum conductance for the n 1 cuts considered in step is determined control proceeds to step to accordingly partition the current set of data elements into two sets S and T and proceed with recursively performing processing of steps and on each of these partitions. Execution of step may be performed recursively using submatrices of A for each partition. The recursive processing may be performed until a submatrix contains only a single row indicating a leaf node of a single object. As such the processing may complete with a tree resulting from the recursion representing a complete hierarchical clustering of the rows of A.

As described herein an embodiment may perform sparse matrix calculations so that the techniques herein may execute in linear time.

Once the divide phase processing has completed generating a tree for example as illustrated in the merge phase is performed. The merge phase is described in more detail in following paragraphs.

Referring back to the merge phase finds a clustering for nodes of the tree produced by the divide phase . The merge phase may be characterized as performing a bottom up processing or traversal of nodes in the tree using dynamic programming techniques in which clustering for the leaf nodes is performed first and then for interior nodes of the tree . The merge phase determines the clusters starting with each leaf node of the tree in its own cluster and merges clusters going up the tree from the leaves to the root. The final clusters form the partitioning or clusters of the data set . In one embodiment using the dynamic programming techniques described herein optimal clustering may be determined for the leaf nodes first and then for the interior nodes. Optimal clustering determinations may be made in accordance with criteria including one or more selected objective functions as well as other criteria such as for example specifying an upper bound on the number of clusters for the solution set. Any one of a variety of different objective functions may be used. Described in following paragraphs are criteria including several objective functions that may be used in an embodiment although an embodiment may also utilize other objective functions than as described herein. The objective function s may be used in evaluating the clustering options for example to determine a number of clusters as well as the best or optimal clustering of objects in accordance with the particular objective function.

Referring now to shown is an example of a tree as may be generated as a result of the merge phase . The tree in the example may be partitioned into clusters in accordance with line . The merge phase determines where to draw a line such as which determines the best possible clusters of proper disjoint subtrees of the tree . In other words the merge phase determines the best way to group or form clusters from the clusters determined in the divide phase as reflected in the tree. In this example there are 5 clusters determined as labeled C C in accordance with line . Processing of the merge phase may determine a number of clusters e.g. 5 as in example as well as the objects in each cluster in accordance with the hierarchical clustering structure produced by the divide phase. As described in more detail in following paragraphs and elsewhere herein the number of clusters determined may be in accordance with criteria including a specified upper bound.

Referring now to shown is a further example illustrating use of the merge techniques described herein in which clustering configuration options may be evaluated in accordance with an objective function. In the example let there be a specified upper bound of 3 clusters and a single objective function. The objective function is evaluated in connection with a subtree having node as a root forming 1 cluster e.g. entire subtree is 1 cluster and also for 2 clusters e.g. right child of is one cluster and left child of is second cluster . Similarly the objective function is evaluated in connection with a subtree having node as a root forming 1 cluster and also for 2 clusters. The objective function is also evaluated in connection with the root node forming 1 cluster e.g. entire tree is 1 cluster and 2 clusters e.g. right child of root is one cluster and left child of root is second cluster . Once the foregoing has been determined a determination is made to select both the number of clusters and the partitioning of objects into particular clusters in accordance with the objective function. In this example let an objective function value be determined for each cluster and let a rating of a configuration be determined as a sum of the objective function values for each cluster in the configuration. In this example assume that configurations for partitioning the entire tree into 3 clusters are more optimal e.g. have higher sums than configurations for partitioning the entire tree into 1 and 2 clusters. Element illustrates one possible partitioning of the tree into 3 clusters and element illustrates the other possible partitioning of the tree into 3 clusters. The objective function values determined for each of C C and C in and may be used in selecting the best illustrated partitioning of the entire tree into 3 clusters by determining which configuration e.g. or has the maximum sum of objective function values for the clusters C C and C therein. The foregoing example may be characterized as relatively simplistic to illustrate use of the objective function in determining an optimal clustering in accordance with specified criteria or constraints. In the foregoing example the constraints or criteria include an upper bound on the number of clusters and an objective function although as described herein others may utilized in an embodiment.

In accordance with techniques herein criteria used in determining an optimal clustering configuration may include any of a variety of different standard objective functions known in the art. In connection with the merge phase processing dynamic programming techniques may be used to compute the optimal clustering for a tree for a given objective function. As will be described in following paragraphs existing techniques known in the art may be used to compute the optimal clustering for selected objective functions using dynamic programming.

Dynamic programming is a technique or class of solution methods for solving a problem exhibiting a particular property in that subproblems have optimal solutions that can be used to then find optimal solutions of the overall problem. A classic example of a problem which may be solved using dynamic programming techniques is the shortest path problem. Using dynamic programming techniques the problem may be broken down into smaller subproblems and optimal solutions determined for the subproblems. Subsequently these optimal subproblem solutions may be used to construct an optimal solution for the original problem. As known in the art recursive programming techniques may be used to compute such solutions.

In connection with techniques herein a bottom up dynamic programming technique may be used for one or more objective functions included as criteria for determining the optimal clustering configuration. An example of the merge processing will now be described with reference to the tree of and the associated edge weights of of using a particular objective function. However the particulars of this example are for purposes of illustration of the techniques herein and should be construed as a limitation.

For the merge phase we want to determine a clustering configuration that minimizes or maximizes as appropriate a selected objective function used with the binary tree output by the divide phase. With reference to merge processing starts at the leaf nodes in the tree and considers clustering options while progressing up the tree to the root node. For this example consider criteria based on two parameter values. An embodiment may use a first parameter k specifying an upper bound on the number of clusters to be formed and a second parameter specifying an objective function to be used in evaluating each clustering configuration. The first parameter k may indicate that the hierarchical clustering e.g. such as the binary tree produced as an output of the divide phase may be partitioned by the merge phase into no more than k clusters. The second parameter the objective function may be used in evaluating the different clustering configurations for each of the no more than k clusters. For each interior e.g. non leaf node the best possible clustering configuration of the subtree formed with the interior node as the subtree root is determined when the subtree is partitioned into 1 cluster e.g. entire subtree as 1 cluster 2 clusters e.g. 2 clusters formed for each of the left and right children of the interior node and so on up to at most k clusters. The best possible clustering configuration for each of the number of clusters e.g. 1 . . . k is determined using the objective function. Using the foregoing information the merge phase determines the best clustering configuration in which the tree is partitioned into no more than k clusters. For this example in addition to specifying an upper bound on the number of k clusters let the objective function be to select the clustering option which maximizes the sum of the edge weights e.g. similarities expressed previously as the edge weights within each cluster. The objective function value for a given cluster configuration may be determined by adding the edge weights of the edges in each of the clusters being considered e.g. weights of those edges having endpoints in the same cluster . Processing is performed at each level in the tree where the best clustering configurations and associated objective function values are maintained for each value of k. In this example k 3 is the maximum or upper bound on the number of clusters.

Reference will now be made to in connection with performing the merge phase processing using the tree structure of as may be generated by the divide phase.

Referring back to and starting at the leaf nodes clustering configurations are determined for possible values of k which is k 1 since there is only one possible clustering option at the leaf nodes. With reference to corresponding edge weights in of the objective function value is 0 for each of the four leaf nodes e.g. A B C D .

At the next level up in the tree examining the parent nodes AD and BC possible values for k indicating a number of clusters are k 1 or 2.

Referring now to shown is an example illustrating clustering configuration options evaluated for node AD. With reference to node AD in k 1 keeps A and D in the same cluster and k 2 is a configuration in which each A and D are in separate clusters. Similar configurations are possible for the node BC. In connection with the node AD for k 1 as illustrated by the objective function is the edge weight of AD 2 as included in . With node AD for k 2 illustrated in with two clusters and the objective function evaluates to 0 as included in since there are no edges within each of the two clusters e.g. each cluster is a single node or vertex . The value of the objective function for AD k 2 can be determined using previously computed values from the child nodes A and D.

Referring now to shown is an example illustrating clustering configuration options evaluated for node BC. As illustrated in in connection with node BC for k 1 the single cluster is considered having the objective function value the edge weight of BC 2 as included in . As illustrated in with node BC for k 2 with the 2 clusters and the objective function evaluates to 0 since there are no edges within teach of the two clusters e.g. each cluster consists of a single node or vertex. The objective function value is included in . The value of the objective function for node BC k 2 can be determined using previously computed values from the child nodes B and D.

Progressing up to the next level in the tree processing is performed for the root node for possible values of k 1 2 3 or 4 as illustrated in .

Referring now to shown is an example illustrating clustering configuration options evaluated for the root node for k 1 and 2. If k 1 the single clustering configuration of is evaluated in which all vertices are in a same cluster. The objective function which is the sum of the weights of all edges in the clustering is 6 as included in e.g. 6 sum of all edge weights in . If k 2 as illustrated in there is one possible configuration of 2 clusters and a first cluster of AD and a second cluster of BC. For k 2 the objective function value is 4 as included in based on the sum of the edge weights for AD 2 and BC 2.

Referring now to shown is an example illustrating clustering configuration options evaluated for the root node for k 3. If k 3 in which three clusters are formed there are two possible configurations to be evaluated. In a first configuration for k 3 as illustrated in 2 clusters may be formed from the left child of the root node and a single cluster formed from the right child of the root node. In a second configuration of for k 3 2 clusters may be formed from the right child of the root node and a single cluster formed from the left child of the root node. For the first configuration of the three clusters are A D and BC. The objective function for this first configuration has a value of the edge weight of BC 2 as indicated in . For the second configuration of the three clusters are AD B and C. The objective function for the second configuration has a value of the edge weight of AD 2 as also indicated in . Note that in this example the objective function evaluates to the same for both clustering configuration options and . In one embodiment if one of these two clustering configurations had a higher objective function value only information for that best clustering configuration needs to be stored for possible use by subsequent levels higher in the tree e.g. moving upwards towards the root .

Referring now to shown is an example illustrating clustering configuration options evaluated for the root node for k 4. As illustrated in if k 4 there is only one possible configuration with 4 clusters each having a single node A B C D with an objective function value of 0 as included in since each vertex or node is in a separate cluster.

In connection with the techniques herein the optimal or best solution for each clustering configuration e.g. best possible solution for each value of k is saved. With this example an upper bound of k 2 is specified in the optimal solution criteria but the best solutions for values of k 1.4 inclusively may be saved and used in computing subsequent objective function values. The best solution for our example is k 1 having the objective function value of 6.

When evaluating possible clustering configurations using the tree structure only a particular subset of all possible clustering options is considered in accordance with the tree structure. For example in accordance with the tree structure of AB or AC is not considered as a possible cluster in any clustering configuration due to the tree structure. In other words there is no node in the tree which consists only of nodes AB or AC. As such the foregoing are not considered as a possible cluster in any clustering configuration. When at level n in the tree possible groupings of clusters considered are those at level n or a level lower in the tree e.g. lowest tree level being the leaf nodes and the highest tree level being at the root node .

As will be appreciated by those skilled in the art dynamic programming can be performed using any one of a variety of different objective functions. Depending on the objective function existing techniques may be used to determine the optimal clustering configuration.

The foregoing example illustrates optimal clustering criteria with two parameters. A first parameter indicates a maximum or upper bound of k clusters and a second parameter specifies a single particular function to be evaluated for each clustering configuration. In the foregoing example the function evaluates the sum of the edge weights within each cluster in the configuration. The higher the foregoing second parameter value for a clustering configuration the better or more optimal the solution.

Rather than specify an upper bound for k an embodiment may also use criteria including two parameters. Rather than specify a first parameter which is an upper bound of k clusters and a second parameter that is an objective function the criteria may specify two objective functions to be evaluated for each clustering configuration. For example a first function may be to compute for a clustering configuration a sum total weight for all edges across clusters in the configuration. In other words if a clustering configuration includes 3 clusters the first function value is determined as the sum of the weights of all edges having different end points in different clusters. The goal of this function may be to minimize this first function value so that the lower the first function value the better the clustering configuration. The criteria may also include a second function as described in connection with the example above illustrated with e.g. maximizes the sum of the edge weights within each cluster in the configuration .

It should be noted that an embodiment may specify any one or more criteria for use in determining an optimal clustering configuration. For example rather than specify criteria including two objective functions or an upper bound for k and a single objective function an embodiment may specify three or more objective functions or a single objective function as the criteria.

What will now be described in following paragraphs are other possible objective functions that may be used alone or in combination with other criteria such as an upper bound for k. Described in following paragraphs are the k means objective function the min diameter objective function and the min sum objective function and correlation clustering function although others may be used in connection with the techniques described herein. If the function is trying to maximize the objective function g the dynamic program will find a clustering Cin the tree such that g C g C for any clustering C in the tree. Note that the best clustering as determined in accordance with specified criteria may not be the best possible clustering. The particular clustering configuration evaluated as best may vary with the specified criteria used in an embodiment.

It should be noted that the running time of the merge phase depends on both the number of times the various criteria such as the various objective functions are evaluated as well as the evaluation time of the objective function itself.

The k means objective function seeks to find a k clustering such that the sum of the squared distances of the points in each cluster to the centroid pof the cluster is minimized 

Let OPT TREE C i be the optimal tree respective clustering for C using i clusters. Let Cand Cbe respectively the left and right children of C in the tree T. The following recurrence may be specified OPT TREE 1 since we are constrained to only use 1 cluster. When i 1 we have OPT TREE OPT TREE OPT TREE where OPT TREE OPT TREE .

Using the dynamic programming technique the optimal clustering for the leaf nodes may be determined first and used in connection with determining the optimal clustering efficiently for any interior node so that OPT TREE root k gives the optimal clustering.

The min diameter function may be specified as an objective function for use with techniques herein. For this function we wish to find a k clustering for which the cluster with maximum diameter is minimized max diam . The diameter of any cluster is the maximum distance or largest difference in values between any pair of objects in the cluster. The above seeks to find a minimum of these values for all clusters. As in connection with the centroid and distance this objective function may use the user defined quantity associated with each object in computing the objective function. A similar dynamic program to that as described above can find the optimal tree respective clustering. Techniques for computing this objective function using dynamic programming are known in the art such as for example by C. Chekuri T. Feder and R. Motwani Incremental clustering and dynamic information retrieval Proceedings of the 29th Annual ACM Symposium on Theory of Computing pages 626 635 1997.

Another objective function that may be used in connection with the techniques herein is the min sum function which seeks to minimize the sum of pairwise distances within each cluster 

An embodiment may also use correlation clustering in which a first function is used to determine the similarity within each cluster and a second function is used to determine the similarity between different clusters. Each function specifies a different criterion or constraint used in determining an optimal configuration and number of clusters. An aggregate or composition function may be used in evaluating the foregoing two functions in combination. In this example the composition function may be defined as minimizing the dissimilarities within clusters plus the similarities between clusters.

For correlation clustering suppose there is a graph where each pair of vertices is either deemed similar red or dissimilar blue . Let R and B respectively be the set of red and blue edges. Correlation clustering seeks to find a partition that maximizes the number of agreements between a clustering and the edges. In other words correlation clustering seeks to maximize the sum of the number of red edges within clusters plus the number of blue edges between clusters 

Referring now to shown is a flowchart of processing steps that may be performed in an embodiment for merge processing. The steps of summarize processing as described above. At step the optimal clustering criteria criterion is selected. As described herein the criteria may include single objective function multiple objective functions an upper bound for the number of clusters into which the entire data set is partitioned and the like. At step the optimal clustering configuration for each possible value of k for each of the leaf nodes is determined. Step may include performing steps and . In step processing is performed to evaluate the criteria of step for each clustering configuration option for each value of k. In step the best of the one or more clustering configurations is selected for each value of k. For example referring back to for the root node k 3 had two clustering configuration options which are evaluated as in step and a selection is made in step to determine the best of the options evaluated in step . With reference to both configuration options are equally good in terms of the objective function value so an embodiment may select one of these randomly or using other selection criteria to be saved as the best. After the leaf nodes are processed control proceeds to step to process parent nodes in a bottom up ordering in the tree towards the root. Each ancestor node is recursively processed after evaluating the clustering configurations for the children of each ancestor node until the root node has been processed. At step the best clustering configuration is determined in accordance with the criteria criteria of step .

In one embodiment fixed selections for the criteria used to evaluate clustering configurations may be utilized. For example an embodiment may use a same objective function along with a fixed upper bound on k the number of clusters in the final partitioning of the data set for each data set evaluated in the merge processing. Alternatively an embodiment may present a user as with a GUI graphical user interface with multiple objective functions and or values for k that may be used. A user may select a value for k and or one or more of the objective functions for use in connection with the techniques described herein. An embodiment may also utilize other techniques such as callback functions which allow the user to provide one or more user defined objective functions. The callback functions may be invoked in connection with performing the merge phase as described herein.

It should be noted that in some applications utilizing the divide phase as described herein knowledge about the dataset can be used to halt the spectral algorithm of the divide phase before a complete tree is constructed. For instance if the number of clusters k desired is small k being included in the criteria for merge phase processing the recursive step of e.g. also step of does not need to be applied after depth k since all k clusterings in the tree use nodes above depth k. As used in the foregoing the depth k refers to the depth or level from the root the root having a depth of 1 and the leaf nodes having the greatest depth level. Consider for example if a node t at depth k 1 is a cluster then no node along the path from t to the root is also a cluster. Since each node along this path has two children and each leaf node must be covered by an interior node there are at least k 1 other nodes that need to be covered by distinct clusters contradicting the use of only k clusters. With reference to the example with divide phase processing of if the criteria for merge phase processing includes an objective function and also specifies an upper bound on the number of clusters k 2 then the divide phase processing does not have to perform processing to generate the leaf nodes A D B and C since at most 2 clusters are included in the final partitioning of the data set. In other words each element of the data set must be included in the same cluster k 1 or in one of two clusters k 2 .

Described herein are techniques for clustering a data set of objects utilizing both a top down and bottom up approach to create both a hierarchy and a flat clustering. In the divide phase a divisive algorithm may be applied to the data set to form a tree T whose leaves are the objects. Divide phase criterion criteria may be specified to determine the best way to repeatedly divide a set of objects associated with a node in the tree. The divide phase is followed by the merge phase in which processing starts with each leaf of T in its own cluster and merges clusters going up the tree. The final one or more clusters form a partition of the dataset and are tree respecting clusters i.e. they are subtrees rooted at some node of T. Merge phase criterion criteria may be specified to determine the best way to cluster the objects in accordance with the tree structure. The final one or more clusters form a partitioning of the dataset and are tree respecting clusters i.e. they are subtrees rooted at some node of tree generated as an output of the divide phase.

The techniques described herein may be used in connection with a variety of different types of data sets and uses. The techniques described herein may be used in connection with clustering or grouping such data sets into smaller similar subsets. As one example the techniques described herein may be used in connection with clustering medical related data. Clustering diseases from data involving diagnoses procedures and drugs can provide an organization of medical knowledge. The clustering techniques described herein may be used for example in predicting which patients will develop an illness or progress to a more advanced stage of an existing illness to assess the quality of patient healthcare and the like. The techniques described herein may be used with data sets from health care insurers medical management companies and patient records such as from doctors and or hospitals.

One application of the techniques herein is in connection with data mining to provide predictions in medical and or healthcare costs. The clustering techniques herein when applied to a set of sample data may be used to automatically detect patterns in the data and cluster together health care members who are similar. The techniques herein may be used to first cluster members of the sampled data together using only their cost data. The result places members within a particular cluster who all have similar cost characteristics. Then for each cost similar cluster the clustering techniques herein may be applied on member medical data to create clusters whose members both have similar cost characteristics as well as medical conditions. We then assign a forecast for a particular cluster based on the known result period s costs of the learning sample. To illustrate a group of members may be clustered using the techniques herein using cost characteristics only. Through experimentation of the inventors it was found that all members have relatively low cost until the last six months of the observation period but a greater cost in the last months of the period. A key observation is that when using cost information only the techniques herein did not distinguish between the members in the cluster. The algorithm uses medical information to identify subgroups within the cost cluster and partitions the members into two sub clusters. The table below shows some of the medical characteristics with the greatest difference in prevalence between the two groups. The first two columns show the percentage of members in each cluster who have a certain diagnosis have had a procedure or are taking a drug.

The techniques herein may be used to perform data mining of medical data to extract medical insights by identifying patterns in the data based on clustering. For example the inventors used the techniques herein to analyze medical data on a sample set of women between 45 and 65. It was observed that there was a strong association between estrogens and antidepressants so that the probability of a member being on a depressant increased by 166 if the member was taking estrogen.

As another example using medical data the following table shows information on two additional clusters that both contain cardiac patients.

The foregoing shows the top ten most distinguishing features of two clusters of cardiac patients. Cluster 1 contains members that have significantly higher health care costs in the result period compared to the observation period while Cluster 2 s members have significantly lower health care costs in the observation period. A distinguishing feature of a cluster is a diagnosis procedure or drug that has more prevalence among members of the cluster than in the general population.

The members of the first cluster have significantly higher health care costs in the result period while members of the second cluster have significantly lower health care costs. Comparing the characteristics of each cluster the inventors observed that they are very similar except for the fifth factor of the first cluster the presence of nonsteroidal anti inflammatory agents. This observation together with recent reports of increased cardiac risk in patients taking Cox 2 inhibitors led the inventors to analyze the costs and cardiac outcomes of members taking Cox 2 drugs. The inventors compared overall costs and the prevalence of CAD between patients of the study sample who had taken only Cox 1 drugs and patients who had taken only Cox 2 drugs as presented in the table below providing anti inflammatory comparisons. In particular the table below shows a comparison of costs and cardiac outcomes in the result period for members taking Cox 1 and Cox 2 drugs in an observation period.

The foregoing are illustrative examples of how the techniques herein may be used in connection with medical data.

The techniques described herein may be used in connection with clustering financial data. For example the techniques described herein may be used in connection with clustering financial returns from various asset classes to guide asset allocation decisions as may be utilized by large financial institutions.

The techniques described herein may be used in connection with clustering email and or desktop files e.g. including text and non text files such as images . For example email may be clustered at an enterprise level to detect varying types of spam. Based on features associated with these different types of spam new rules may be determined for spam filtering of subsequent emails of the same spam types. The techniques herein may be used to locate related files emails and the like on a computer system for example based on user entered keywords.

The techniques described herein may be used in connection with clustering transactions for fraud detection. For example credit card companies can search customer transactions reflecting the behavior of customers to detect fraudulent activity by clustering transaction data.

In one embodiment the techniques herein may be utilized in a search engine that discovers the clustered structure for queries and identifies each cluster by its three most significant terms. In one embodiment this search engine may utilize output from another search engine such as Google. The user inputs a query which is then used to find 400 results from Google a standard search engine. Each result contains the title of the webpage its location and a small snippet from the text of the webpage. A document term matrix representation of the results may be constructed as described and illustrated in . Each result is a document and the words in its title and snippet make up its terms. The document term matrix may include a row for each document. Each element in a row may correspond to a particular word in the document snippet having a value for example corresponding to the number of times the word appears in the snippet. The snippet may be preprocessed or filtered for example to remove stopwords. As known in the art stopwords may be characterized as common words i.e. a of the on that have little or no meaning by themselves. The similarity between two results is the inner product between their two term vectors. The divide phase may be implemented using the spectral algorithm as described herein for example in . For the merge phase the following objective function may be used which may be referred to herein as relaxed correlation clustering 

In this embodiment each row A u is normalized to have Euclidean length 1 to ensure that the maximum similarity between any pair of rows is 1. A value of 0.2 and 0.8 may be used. The first term in EQUATION E1 measures the dissimilarity within a cluster i.e. how far a cluster is from a set in which every pair is as similar as possible for all u v A u A v 1 . Note that the first term is a relaxed notion of the blue edges within a cluster from correlation clustering as described elsewhere herein. The second term in EQUATION E1 measures the amount of similarity the clustering fails to capture since it occurs across clusters. Similarly the second term is a relaxed notion of the red edges outside clusters. The benefit of using the relaxed correlation clustering objective function is that it does not depend on a predefined number of clusters k. This is appropriate for the particular application for searching since the number of meanings or contexts of a query is not known beforehand. Based on results observed by the inventors the foregoing objective function in this application produces results including large interesting subsets of the data while also placing unrelated results each in their own cluster.

The techniques herein may be used on different types of data for example text data gene expression data and categorical data. Each type of data may come from a variety of different sources. For example for text data the techniques herein may be used to group related documents together based on text words in each document. The document may be a news article web page abstract from a journal and the like. Categorical data is similar to text data in that it does not naturally have a defined ordering for example as with numerical data. However in contrast to text data each categorical data object is not a document containing terms but rather a vector of characteristics each of which takes on non numerical labels. One example of categorical data may be the Congressional voting dataset in which each data object is a Congressman and the vector of characteristics is how he she voted on every bill or law put through Congress. The true clustering of Congressmen may be their political party affiliations and the way in which each Congressman voted may be used with the techniques herein to group like Congressman having the same political party affiliation together in a cluster. As another example of categorical data each data object may be data about a particular mushroom described by a number of features such as for example odor habitat and the like. Each mushroom may be either poisonous or edible based on the values of the features and the techniques herein may be used to accordingly group mushrooms into these two classifications.

The techniques herein may be applied for use with gene expression data. In one embodiment a microarray chip may be a solid surface upon which spots of DNA are attached in a matrix like configuration. By exposing the chip to RNA the expression level e.g. activity of the gene can be determined for each gene on the microarray chip. The techniques herein may be used to discover new subtypes of cancer by clustering microarray data. The approach is to cluster gene expression data from several patients with a certain type of cancer. If a strong clustering exists the clustering may designate different subtypes of cancer. This relies on the hypothesis that gene expression levels can distinguish different subtypes of cancer. Using the techniques herein in one embodiment the spectral algorithm as described in may be run on the gene expression data which is preprocessed as follows. First the data is normalized. For example the expression level of each gene may be normalized over a number of samples such that the mean is zero and the standard deviation is 1. In this example there may be 7 000 human genes in each sample. A matrix may be created having a row for each sample. Each row contains 14 000 elements so that the first 7 000 elements are used if the sample has positive values e.g. standard deviation 0 and the second 7 000 elements of a row may be used if the sample has negative values e.g. standard deviation 

As described above an embodiment may optionally utilize weights as generated in connection with the preprocessing phase. It should be noted that although the preprocessing phase is described in connection with the divide and merge phases herein the preprocessing phase may be used more generally in connection with feature selection and weighting with other techniques. For example the preprocessing phase for weighting features may be used in connection with feature selection for learning algorithms prediction algorithms and the like. The preprocessing phase may be used for example in connection with determining which features are important for trending.

It should be noted that an embodiment may also perform other processing phases or steps such as other preprocessing of the data set than as described herein. For example an embodiment may preprocess or filter text based documents to remove occurrences of certain common words such as the and a . The particular preprocessing may vary with the particular data set.

It should also be noted that although the merge phase processing is described herein in connection with particular techniques used in the divide phase processing to generate the binary tree an embodiment may use different techniques in the divide phase processing to generate a hierarchical clustering. For example an embodiment may utilize other recursive partitioning techniques known in the art to generate a hierarchical clustering which is used an input to the merge phase. As described herein an embodiment of the divide phase may generate as an output a binary tree as a hierarchical clustering arrangement used as an input to the merge processing. An embodiment of the divide phase may also generate other hierarchical clustering arrangements. For example divide phase processing may generate a tree structure which is more generally an n ary tree structure n representing the number of possible child nodes of a parent node in the tree. An embodiment may also represent the hierarchical clustering generated as an output of the divide phase using other data structures than as described herein.

Although particular examples and types of data sets have been utilized for illustration those skilled in the art will appreciate that the techniques described herein may be used in connection with many other types of data sets and applications.

In one exemplary embodiment described herein a spectral algorithm has been described e.g. for the divide phase and any one or more different criteria including one or more different objective functions may be used in connection with the merge phase. However it will be appreciated by those skilled in the art that different techniques may be used in an embodiment. For example an embodiment may the same objective function for the divide phase as the merge phase. In other words for the divide phase recursively find the optimal clustering according to the objective function resulting in a hierarchical clustering tree. Rather than use the conductance as the divide phase criteria an embodiment may use other criteria for example such as an objective function as described elsewhere herein as used with the merge phase. In the merge phase the same objective function may be used to find the best clustering. In such an implementation using an objective function in the divide phase dynamic programming techniques may be utilized as described for the merge phase as well as other techniques in connection with computing the appropriate function values

While the invention has been disclosed in connection with preferred embodiments shown and described in detail their modifications and improvements thereon will become readily apparent to those skilled in the art. Accordingly the spirit and scope of the present invention should be limited only by the following claims.

