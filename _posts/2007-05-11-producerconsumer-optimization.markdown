---

title: Producer/consumer optimization
abstract: Systems and methods facilitate efficient data processing in a computer environment. Data producers and consumers are considered in aggregate rather than in isolation. In one instance, interaction between data producers and consumers is improved by integrating producers and consumers. Optimization can subsequently be performed over the combination to produce synergistic results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08352456&OS=08352456&RS=08352456
owner: Microsoft Corporation
number: 08352456
owner_city: Redmond
owner_country: US
publication_date: 20070511
---
Computer programs are groups of instructions that describe actions to be performed by a computer or other processor based device. When a computer program is loaded and executed on computer hardware the computer will behave in a predetermined manner by following the instructions of the computer program. Accordingly the computer becomes a specialized machine that performs the tasks prescribed by the instructions.

A programmer using one or more programming languages creates the instructions comprising a computer program. Typically source code is specified or edited by a programmer manually and or with help of an integrated development environment IDE . Subsequently the source code can be compiled or otherwise transformed by another program into computer instructions executable by a computer or like device.

In software engineering a plurality of design patterns are conventionally utilized in program development. A design pattern provides a framework for describing a particular issue and solutions thereto. More specifically a design pattern is a general repeatable solution for common issues that occur in software design. Among other things use of design patterns speeds up development helps prevent subtle issues and improves program readability and comprehension by those familiar with the pattern.

One basic design pattern is producer consumer. A producer consumer relationship is one in which a producer generates data and the consumer uses the data. This pattern is utilized in a myriad of different environments for a number of processes including at a higher level data warehousing for cleansing and transforming data and image processing for iterative refinement. In fact the pattern can apply to any situation in which data is produced and consumed. One particularly prevalent use case pertains to queries.

Query execution can be seen as a traditional client server or consumer producer model where an entity A requests a service from another entity B in this case the retrieval of some data that satisfies criteria and is in the shape requested. Some bi directional communication mechanism is required such that A can instruct B about its desire and so that B may respond to A with the results. The entire result set is returned in some form and thereafter consumed for some purpose. Conventional relational database management software RDBMS employs cursors for the output interface with which to stream query output to the consumer. A cursor is a single stream of data that facilitates supply of data in some definite sequential ordering.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to optimization of producer consumer code. Instead of treating producers and consumers as black boxes activities of a producer and one or more associated consumers can be analyzed and employed to facilitate efficient execution. In other words optimization can be performed on a producer consumer aggregate rather than on the producer and consumer in isolation. Furthermore the producer and or consumer can be an aggregate of some other producer and or consumer such that the optimization can be recursive.

In accordance with one aspect of the disclosure consumer activity can be merged or integrated with producer activity. In this case consumer activity can simply be considered an extension of producer activity. As a result an execution strategy can be generated over the integration or aggregate to implement parallelism among other things. By way of example if the producer corresponds to a query novel and or conventional query optimization approaches can be utilized that cross the producer consumer boundary.

According to another aspect of the disclosure consumer activity can be analyzed and employed to streamline producer execution alone or in conjunction with other optimization techniques. More particularly a producer can be specialized to produce data solely of interest to one or more associated consumers.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods are described hereinafter concerning data processing. Processing efficiency can be improved by optimizing interactions between producers and consumers. More particularly producers and consumers can be considered en masse rather than as isolated atomic processes. Optimizations can then be performed with respect to both data production and consumption resulting in a synergistic result. Such optimization can be accomplished via direct program specification an application programming interface a compiler and or a query processor amongst other mechanisms.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a code optimization system is illustrated in accordance with an aspect of the claimed subject matter. The system includes programmatic code comprising one or more producer components and consumer components . The producer component produces or generates data that is consumed or utilized by one or more consumer components . As will be described further infra consumer components can also act as or include functionality of producer components or vice versa for example where there is a sequence of components that receive data perform some action and pass the data to the next component. Further yet the producer component and consumer component can operate with respect to arbitrary data types including streams graphs and trees among others.

Interface component is operable to receive retrieve or otherwise obtain or identify related producer components and consumer components within programmatic code . These components or identities thereof can be provided to or made accessible by optimization component . The interface component therefore acts as a conduit between the programmatic code and the optimization component . Accordingly it is also to be noted that the interface component and or portions thereof can facilitate modification of the code by optimization component .

The optimization component facilitates improving data processing by optimizing producer components consumer components and or interaction between the components. Conventionally producer components and consumer components are treated as isolated atomic processes. Such treatment is likely a function of traditional modular program design and or presumed communication latency or low throughput. However the conventional treatment can result in sub optimal execution in many cases. For instance this is quite limiting for scenarios with small distances or high throughput including in memory in the same process and or on the same machine. Further with an increase in availability of parallel hardware and decrease in communication latency it is important that software evolve to do more things in parallel. That includes consuming items from a producer.

Rather than treating consumer components as black boxes the optimization component is operable to analyze consumer activity to facilitate optimization of the producer component the consumer component or both. In one instance consumer activity associated with a producer can be utilized to refine data produced by a producer. Additionally or alternatively at least a portion of consumer activity can be merged within a producer or at least treated as such for optimization purposes.

In essence structure of a producer component and at least one associated consumer component is known or can be determined. Based thereon the producer component and the consumer component are matched up in a way to optimize performance parallelism and or data communication. Furthermore it is to be appreciated that once consumer activity is exposed optimizations can be performed recursively thereon providing deeper optimizations than would otherwise have been possible. By way of example where there is a sequence of producers and consumers the consumers can also be producers that can be optimized.

The interface component and or optimization component can be embodied in any number of systems or mechanisms. By way of example the interface component and optimization component can be embodied in an application programming interface API associated with producers and consumers. Additionally or alternatively the components and can form part of a compiler such that generated code including producers and consumers is optimized for execution. Further yet the components can form part of a query processor and or associated components. However the claimed subject matter is not limited to these exemplary embodiments. Other embodiments are also possible and are to be deemed with in the scope of innovation.

Turning attention to a representative optimization component is depicted in accordance with an aspect of the disclosure. The optimization component includes an integration component to integrate or merge consumer activity with producer activity. By integrating producers and consumers a bottleneck can be removed from the process wherein generated data is merged or packaged into a data structure and transmitted or otherwise identified to the consumer for processing.

Integration component can operate over a plurality of consumers and producers. By way of example a sequence of producers and consumers can exist where data is transformed and passed to the next element that transforms that data and passes it on to the next etc. Essentially there can be a pipeline of consumers that are producers themselves. The integration component can integrate or aggregate all these consumers and producers together into one big group such that optimization can be applied across all consumers and producers. For instance suppose there is a process that takes an image and performs successive transformations thereon. These transformations can be glued together into one big process such that optimization can be performed with respect to the image as a whole instead of separate parts where intermediate values are sent to the next black box. More specifically the integration component can support intra and or inter component optimizations.

Execution strategy component is operable to optimize execution of an integrated producer and consumer. In particular the execution strategy component can identify an optimized execution strategy and or modify the code in accordance therewith. For instance the execution strategy component can employ conventional optimization approaches across a producer consumer boundary including without limitation common sub expression elimination and operation reordering. While these optimizations are similar to what compilers do everyday they are different in that the execution strategy component can take advantage of rich semantic knowledge to rewrite higher level operations in addition to lower level program statements.

Various parallelism approaches can also be employed by the execution strategy component including partitioning and pipelining. In partitioning code is replicated and the replicas execute simultaneously over disjoint subsets of data. In one particular instance multistreaming can be employed between producers and consumers to permit parallelism to extend from core production operations into consumption operations without any superfluous merge operation or other bottleneck for example. Pipelining or pipeline parallelism divides processing tasks into a set of tasks connected in series. Tasks in each pipeline are often parallelized for example utilizing partitioning. This approach can be employed instances where partitioning alone is not efficient because of varying costs associated with task execution.

Cost component identifies execution cost associated with producer and or consumer operations. This information can be determined or inferred and supplied to the execution strategy component to facilitate identification of an appropriate parallel execution strategy or degree of parallelism given the costs and available resources for instance.

Further optimization component can include a query plan component that can generate and or optimize a query plan. A query plan defines a query execution strategy for retrieving data. In accordance with an aspect of the claimed subject matter the query plan component can generate and or optimize plans as a function of consumer activity. In other words consumption action can be incorporated into query planning optimization itself. Particular plans can be generated or modified as a function of execution cost associated with producer and or consumer costs provided by the cost component .

In one implementation the query plan component can generate an abstract syntax tree or graph that represents the query itself wherein nodes identify query operations and edges identify flow between operators. Consumer activity can be incorporated therein and represented as another node in the graph or tree. Conventional and or novel optimization techniques can be applied to the integrated representation and subsequently employed during execution via a query processor engine component or the like not shown . By way of example and not limitation such optimization techniques can include standard relational algebra based rewrite rules as most relational databases are employed against tree based representations of queries.

The following exemplary code pertains to a consumer processing situation in the context of a language integrated query 

Referring to a conventional approach to executing the above exemplary query is depicted. More specifically illustrates what might occur in a traditional approach executing on a four central processing unit CPU machine with a partition parallelism approach. As shown data is retrieved from a store and split or partitioned across the four CPUs for parallel query processing Where Select . Results are captured from the parallelized query merged and subsequently provided to the consumer. Note the loss of parallelism as soon as the end of the producer is reached via the explicit merge. While the query processing is executing across four processors all produced data needs to be merged prior to delivery to the consumer which is then executed without parallelism. The merge is a bottleneck in this process.

In the code the semicolon between select c and for each identifies the split between producer and consumer. In that case a filtered object needs to be created and passed into the consumer loop as previously described. What is desired is to fuse the producer and the consumer so that the loop is integrated into the query. This can result be accomplished be removing the loop and altering the query such that select c becomes select ProduceConsumer c . Now the consumer activity can simply appear as another query operation. During query plan generation and or optimization consumers can be partitioned across the four CPUs and operate on a subset of data provided by the producers.

Turning to another optimization approach is illustrated utilizing pipelining. Just as a query plan component and or related components can peek inside of query operations such as Where and Select to determine and adaptively gather selectivity and cost using this data to make better judgments about query execution now and in the future it may also do so with a consumer. Therefore not only can consumer activities be run in parallel a query planner can make decisions based on this. For example pipelining is often used to balance a query with imbalanced costs. This assumes that the planner is aware of consumer costs as traditional approaches are limited to producer activity. With this approach a planner may choose to introduce new pipeline stages including running the consumer as its own pipeline simply because it knows about this extension of the query.

For example if the aforementioned exemplary query is to be executed on a multiple CPU machine and the consumer costs four times the cost of the Where which costs two times the cost of the Select portion of the query a reasonable expectation since production is often an expensive operation then pipelining can be used to balance the query as shown in . This style of optimization is simply not possible with conventional techniques and or approaches.

Referring to a representative optimization component is illustrated in accordance with an aspect of the claimed subject matter. As illustrated the optimization component includes a consumer analysis component . The consumer analysis component is a mechanism for analyzing activity across one or more consumers. Producer modification component is communicatively coupled to the consumer analysis component and operable to receive retrieve or otherwise obtain consumer information. The producer modification component can then modify producer activity as a function of consumer activity. By way of example consider a situation where the producer yields customers and the consumer processes customers. If the consumer analysis component can determine that a set of one or more consumers only ever utilizes a customer name the producer modification component can alter the query to produce only customer names rather than all customer information. Accordingly large portions of computation may be able to be eliminated as a function of consumer activity such as where the producer produces that which the consumer is not interested among other things.

It should be appreciated that by removing a black box distinction between producers and consumers various optimizations can occur. Here optimization component facilitates producer modification in light of consumer activity. This functionality can be provided alone or in combination with other optimizations including parallelism. For example the functionality captured by the consumer analysis component and producer modification component can be captured and or performed by execution strategy component of or query plan component of .

Referring to a database management system is illustrated in accordance with an aspect of the claimed subject matter. The database management system includes a database interface component query processor component and database for processing queries. The database interface component receives retrieves or otherwise obtains a database query and transmits it to the query processor component . The query processor component process the query against the database and returns results. In accordance with one aspect the query processor component can produce results in accordance with a particular query plan transmitted with the query or otherwise obtained. The results can be returned back to a requesting entity or process via the database interface component . Results need not be supplied in a single result object or one at a time as conventionally done. Alternatively portions of data satisfying the query can be returned as they are determined and or in accordance with a plan. In this manner a restrictive merge operation need not be executed to generate a single result package. Instead results can be returned in a manner that facilitates parallel consumption.

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems and methods may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation the optimization component can employ such mechanism to optimize execution of producer consumer code as a function of context including producer activity consumer activity operation cost execution environment and computational load among other things.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a method of optimizing producer consumer interaction is illustrated. At reference numeral a programmatic data producer and consumer are identified. The producer generates data and the consumer acts upon the data. In accordance with one embodiment the producer can correspond to a query wherein the consumer performs some action on query results. At reference number interaction between the producer and the consumer is optimized. Optimization can be based on the analysis of the activities of both the producer and one or more associated consumers. In one instance interactions can be parallelized. For example consumers can be replicated via partition parallelism and connected to a plurality of partitioned producer components. Accordingly multi streaming techniques can be employed to allow multiple independent consumers to attach to the output of a single producer without any merge bottleneck. Additionally or alternatively producers and or consumers can be modified in light of the activities of the other.

At reference numeral an execution strategy is established for the code. The execution strategy concerns how the code is to be executed to optimize performance among other things. In accordance with an aspect of the disclosure this can correspond to query plan generation and or optimization. Hence the strategy can be dependent upon a plurality of factors including but not limited to producer activity consumer activity execution costs execution environment and processing load. Consumer activity can be considered as an extension to the producer. Hence consumer operations can be inspected and utilized to facilitate generation of the execution strategy.

Furthermore conventional query optimization approaches can cross the producer consumer boundary. For example traditional query optimizations such as common sub expression elimination and reordering can be performed on the consumer which can lead to better query execution times even without any parallelism although combining the two leads to superior results.

At reference numeral the execution strategy is implemented or executed. For example where the execution strategy corresponds to a query plan a query execution engine can implement the plan. Alternatively a compiler or other optimization component can implement code changes in accordance with the execution strategy which can then subsequently be executed to perform in accordance therewith. It is also to be noted that the execution strategy can include a dynamic portion such that code execution can be responsive to runtime information. For instance if one or more processors are not available because they are bearing load of other processes then code execution can be modified for available resources.

Turning to a flow chart diagram of a method of code optimization is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral one or more consumers associated with a producer are identified. In other words all consumers that consume or otherwise utilize data output by a given producer are discovered. Activities associated with each of the one or more consumers are identified at numeral . Among other things this may include identification of particular data on which a consumer operates. At reference numeral modifications are made to an associated producer as a function of consumer activity. While consumer activity can be merged with a producer to facilitate parallelization the consumer activity can also be utilized to streamline producer code among other things. By way of example if it can be determined that one or more consumers are interested in particular data the producer can be augmented to provide solely that data without other superfluous data that will not be used.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

Here producers and consumers can exist on client s server s or distributed across client s and server s . For example consumer code can be resident on a client operable to utilized data produced by one or more servers . Assuming low latency communication producer consumer interactions can be optimized via parallelization e.g. partitioning pipelining . . . . Accordingly producer and consumer code resident on one or more of client s and server s can be executed in parallel across the communication framework . Additionally or alternatively consumer activity information can be employed to streamline a producer for more efficient execution independent of parallelism.

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

