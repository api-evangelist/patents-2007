---

title: Wireless remote firmware debugging for embedded wireless device
abstract: A method for debugging a read only memory (ROM) in a wireless target device is disclosed. A wireless communication link is established between the target device and a host computer. A debug mode change command is received from the host computer by the application program running on the target device via a wireless communication interface in the target device. The wireless communication interface is parsed with the monitor program. A debug instruction is received by the monitor program from a debugger in the host computer where the debug instruction includes an entry address and a jump address. The application program jumps to the received jump address upon reaching the entry address location. An acknowledgement is transmitted from the target device to the debugger in the host computer, and, in response to the acknowledgement, a second debug instruction is received from the debugger in the host computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07913121&OS=07913121&RS=07913121
owner: Broadcom Corporation
number: 07913121
owner_city: Irvine
owner_country: US
publication_date: 20071130
---
This is a continuation application that claims priority to U.S. patent application Ser. No. 10 930 577 filed Aug. 31 2004 entitled WIRELESS REMOTE FIRMWARE DEBUGGING FOR EMBEDDED WIRELESS DEVICE which is incorporated by reference for all purposes.

The present invention relates generally to wireless devices and more particularly to firmware debugging of wireless devices with its code stored in a read only memory ROM .

A principal aim in the debug process is to non intrusively capture the activity of a microprocessor execution unit embedded in a device under test DUT . Firmware development and debugging of the embedded microprocessor requires access to the firmware stored typically in a random access memory RAM . The final code is then committed to a memory. Typically a read only memory ROM is used in embedded devices because ROM by nature is not changeable or editable it takes up a smaller area than RAM therefore it is quite common for embedded device to commit the firmware code to ROM once system testing has completed. To achieve a firmware debugging a microprocessor must be controlled and observed via its external connections. However access to a microprocessor that is deeply embedded within a DUT can only be achieved via the external pins of the densely packaged and typically high speed embedded device. Therefore embedded devices have made the traditional in circuit emulator ICE ineffectual owing to the inaccessibility of the embedded microprocessor.

Moreover since the code in the ROM cannot be altered typically an image of the ROM is created in the RAM of the microprocessor by a debugger program and the image is used to perform firmware debugging. However many embedded devices do not have adequate RAM space for storing the entire image of their ROM code.

Software break points SWBP provide another mechanism to allow the debugging of microprocessor code and to evaluate performance. A SWBP is typically accomplished through code replacement provided the program resides in a writable memory module e.g. a RAM which allows the code at the stop point to be replaced in memory with the software break point code. In most devices when a SWBP code reaches an instruction execution it causes the application program to stop advancing and sets a debug status bit indicating the application program has stopped. To restart execution the application program can be restarted by simply refetching the code at the SWBP memory address after the code is replaced in memory with the original code.

However firmware debugging of a wireless device in its final form is challenging due to lack of observability into the execution of the firmware code stored in a ROM of the wireless device. For example to debug a Bluetooth device such as a Bluetooth keyboard or mouse the serial port of the processor will have to be brought out to a typically nine pin connector e.g. a serial port such as a universal asynchronous receiver transmitter UART connector through which a serial port cable can then connect to a personal computer PC host which runs the debugger program. The debugger program then passes various commands to a small monitor program that resides in the embedded device to facilitate the controlled execution of the target firmware.

Thus conventional methods for firmware debugging of a wireless device is intrusive and potentially destructive. Furthermore a test jig and or opening of the DUT is needed to provide a debug interface to probe the execution of the firmware. The conventional methods also need to have large external RAM space to allow von Neumann structure. This means that access is possible from data and code space to the RAM.

Therefore there is a need to a firmware debugging method and system for wireless devices that enables an efficient debugging of the DUT without the need for opening of the DUT.

The present invention provides an improved method and apparatus for a firmware debugging of wireless devices using the existing wireless protocol stack to facilitate status command communications between a host and DUT target device . The method and apparatus of the present invention uses the on device code patch resources to set break points and debug the ROM code.

In one embodiment the present invention is a method for debugging a ROM in a wireless target device running an application program and including a debug monitor program. After a wireless communication link is established with the target device by a host computer a debug mode change command is transmitted to the target device by the host computer. The debug mode change command is received by the application program via a wireless serial port in the target device and the monitor program is enabled to parse the serial port. A debug instruction from a debugger in the host computer is then received by the monitor program where the debug instruction includes an entry address and a jump address. The application program jumps to the received jump address upon reaching the entry address location in the application program. An acknowledgement package is transmitted to the debugger in the host computer and a second debug instruction can be received from the debugger responsive to the acknowledgement package.

In one embodiment the present invention is a method and apparatus for a firmware debugging of wireless devices using the existing wireless protocol stack to facilitate status and command communications between the host and target device. The invention takes advantage of the air link that is inherent in wireless such as Bluetooth devices to communicate commands and command status between a debugger residing in a host computer and the embedded target device.

In one embodiment the emulated serial port in Bluetooth RFCOMM is used to pass debug commands such as set break point single step read memory read register write memory etc. to a monitor program residing in the target device. The monitor program receives the debug commands from the host through the RFCOMM serial port and executes the debug commands and returns status to the host via the serial port.

For example to set a break point in an application program that is being debugged a user double clicks on a code line in the debugger running on the host the debugger then sends a break command via the RFCOMM serial channel application programming interface API the command and the instruction address are encapsulated into a packet and sent out via the Bluetooth RF link. The target device RFCOMM peer receives this command and passes the command to the monitor program that is running in the target device. The monitor program upon receiving this command modifies the patch entry in the ROM and directs lumps the break address once the application program reaches the break point. The monitor program detects that a break has occurred and sends a break response status to the local RFCOMM which then sends a break status packet back to the host. The host receives this response packet and notifies the debugger of the break status. The debugger reflects that fact by highlighting the breaking instruction on the debug display window.

Target device includes a BT communication interface for receiving data from host and a debug monitor . Target device also includes a CPU a memory an input block and an output block . Memory includes a ROM for storing firmware executed by the CPU and a RAM. The BT communication interface is coupled to CPU and receives debugging commands from debugger for execution on CPU . Further the debugger through the host transmits a debug mode change command which requests target device to stop the execution of an application program by CPU . Upon receipt of the debug mode change command from the debugger CPU executes a procedure and transfers control to debug monitor .

Debug monitor program is a small amount of code that resides in target device ROM within memory to provide control and observation of CPU and on board peripherals if any. The monitor software provides basic test and debug functions such as the setting of break points and inspection modification of the CPU registers when the CPU has been halted. The debug monitor can typically remain with the product embedded device to provide maintenance functions.

In operation CPU receives a communication channel allocation request signal transmitted from the host computer and then judges if the wireless communication can be established in the current condition of CPU . If the wireless communication is established CPU transmits a message allowing wireless access. Memory includes a RAM space for storing and executing the application program which can be downloaded from the host computer via the wireless communication link. Input block and output block are used for the operation of the target device . The target device maybe a wireless keyboard mouse printer other wireless peripherals and the like.

The RF layer corresponds to the physical layer of the Open Systems Interconnection OSI framework. Similar to the RF layer the baseband layer corresponds to the physical layer that establishes a physical connection. The HCI layer is an interfacing protocol between a Bluetooth module and a host.

The L2CAP layer corresponds to the data link layer of the OSI and is a protocol stack for interfacing a lower layer protocol stack with an upper layer application. The L2CAP layer has a similar role as the TCP layer of the Internet Protocol IP . The L2CAP layer is a layer located above the HCI layer for enabling the upper layer protocol or application for exchanging data packets.

The RFCOMM layer is an emulator for serial communications and a protocol replacing serial communication protocols such as the RS 232C interface. The PPP layer is a protocol for serial communication between two computers. The IP is an Internet communication protocol. The TCP is a protocol used with the IP for transmitting data in a message form on the Internet. The UDP is a communications protocol providing limited services when messages are communicated using the IP. The UDP is an alternative to the TCP and when used with the IP is also referred to as UDP IP.

Similar to the TCP the UDP uses the IP to enable a computer to receive an actual data unit datagram from the another computer. The socket is a communications method between a client program and a server program on a network. The socket is typically referred to as the end part of an access . The socket is sometimes referred to as an application programming interface API and is generated and utilized by a series of programming requests or function calls.

In one embodiment host computer will do a feature request on the remote device to find out whether the device can support remote ROM debug. Then the host computer is required to inform or instruct the target device that it intends to occupy the target device for executing the debug routines.

In block a debug mode change command is transmitted from the host to the target device. The debug mode change command is received by the application program running in the target device via a wireless serial channel in the target device as shown in block . Upon receipt of the debug mode change command the monitor program is enabled to parse the serial port. This may be accomplished by the monitor program calling a parser in the target device a code section such as a parser subroutine and a simplified version of a RFCOMM module within the monitor program. In other words the monitor program that is running on the CPU is extended to include code that performs the reading and parsing of the serial data which contains the debug command that is sent over the air. Specifically the monitor program includes a jump instruction to the code that performs reading from a receive hardware FIFO interprets the RFCOMM serial command from the debugger performs read write to hardware register memory locations stores results for example the content of a memory location to a transmit FIFO and instructs the transmit of the result packet back to the host etc.

In one embodiment the above functions are implemented in a hardware state machine. In this implementation a hardware module includes a state machine for issuing memory register content inquiries. The hardware module interacts with the monitor to exchange data received from the host and data to be transmitted to the host without requiring the application program to be running. When the break point in application code is hit the monitor program enables the hardware state machine to parse and check the content of the received packet from the host such that the received packet is not passed on up to the RFCOMM profile anymore. In one embodiment the hardware state machine emulates the RFCOMM profile in hardware. After recognizing the incoming debug command for example a memory peek at location 0x7000 from the host the hardware state machine sends the memory peek request at location 0x7000 to the monitor program which then peeks the content at memory location 0x7000 and returns a packet with that content to the host.

Alternatively the RFCOMM module part of the application program may be called by the monitor program. This scheme allows receiving and processing of the commands from the host while the target is in the debug mode and the application program in the target is stopped. Since the parser parses the various debug commands it needs to be independent of the application program which may be halted at times.

In block a debug instruction from the debugger in the host computer is received by the target device. The debug instruction is parsed and decoded by the parser and passed to the monitor program. In one embodiment the debug instruction includes an entry address and a jump address. The entry address is the start address of the ROM that the debugger wants to break away. The jump address is the address of the start of the monitor program. In one embodiment the debug instruction also includes a return address which is typically the next address to the entry address in the ROM code.

The monitor program control then jumps to the received jump address upon reaching the entry address location that is the start address of the ROM location that the debugger wants to debug in the firmware as depicted by block . The application program is running through the jump instruction. The jump instruction is part of the application program or more accurately the patched code. Initially only the monitor program is running when entering in debug mode. Then when the monitor program receives a run application command from the host it jumps to the start of the application code and starts executing the application code. Since the patch entry has been entered at this point for a break command for example it is time to run the application code to see if the break point is hit.

In block the target device transmits an acknowledgement package to the debugger in the host computer and receives a second debug instruction from the debugger responsive to the acknowledgement package. The acknowledgement package indicates that the firmware stored in the ROM has reached the break point therefore it is a break acknowledgement. After the acknowledgement the debugger can transmit any instruction to the monitor program for status memory content inquiry etc.

Once the device receives a debug command such as a break point command the device firmware code jumps to an extended monitor routine and accesses a hardware FIFO for received packet. The device then parses the received packet with RFCOMM and sets a break point with ROM patch facilities. ROM patch facilities works like the well known process of patching a ROM to correct data stored in the ROM. That is rather than reading data from a specific location in the ROM the program counter is pointed to a location which includes the new corrected data. The target device then sends a target break point set message back to the host.

The host sends another debug command run to the target device and the target device goes through similar routines describes above to send a target application code running message back to the host. The target device then executes the application code until the break point is hit. Once the break point is hit the device jumps to the extended monitor routine and accesses the hardware FIFO for transmit packet. In one embodiment the hardware state machine emulating the RFCOMM profile in hardware is implemented using a state diagram shown by the states represented by bubbles in .

It will be recognized by those skilled in the art that various modifications may be made to the illustrated and other embodiments of the invention described above without departing from the broad inventive scope thereof. It will be understood therefore that the invention is not limited to the particular embodiments or arrangements disclosed but is rather intended to cover any changes adaptations or modifications which are within the scope and spirit of the invention as defined by the appended claims.

