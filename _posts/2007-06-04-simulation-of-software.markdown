---

title: Simulation of software
abstract: Systems and methods facilitate accurate and rapid simulation of software by periodically saving simulation states and design stimuli for use as a replay model. Divergences from the stored information may be detected during subsequent re-executions, which can in turn be run using the saved stimuli and states.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08079022&OS=08079022&RS=08079022
owner: Carbon Design Systems, Inc.
number: 08079022
owner_city: Waltham
owner_country: US
publication_date: 20070604
---
The invention relates to the field of debugging software. In particular the invention relates to execution of software using pre stored object stimuli and states to accelerate the debugging process.

When verifying software it is often necessary to re run the same or similar simulations numerous times to identify understand and resolve problems in the software. For large or complex software systems such as simulation programs arriving at a point of interest e.g. the point where a bug manifests itself or is fixed or where the user wishes to observe the system s performance may take a significant amount of time. This is especially true when the simulation represents intricate hardware devices with timing requirements that must be modeled accurately.

The degree of accuracy required can cause software simulations of hardware to run slowly and create significant delays between the start of a simulation and arriving at the point of interest. Even when using simulation hardware it is not uncommon to encounter differences in speed between the actual electronic device and the simulation by factors on the order of tens of thousands to millions. For large simulations many software simulators can execute at a rate between 1 Hz and 100 Hz depending on the simulator and the electronic device being simulated whereas it is not uncommon for the physical device to run at clock speeds of 500 MHz or more. This means that it could take weeks or even months to simulate one second of the operation of an electronic device. Even a hardware based simulator which may execute a simulation at a rate of 1000 Hz to 1 MHz may still be hundreds or thousands of times slower than the actual device.

Simulations may also be used to debug software. However debugging software exclusively on a simulator can be problematic. As noted above running simulations and hence the debugging process may be very time consuming. That is if the problem s appear after running the software program on hardware for a significant time such as several minutes or hours the same problem s may not be encountered on a simulator for a translated significant time of hours or days.

Many simulators attempt to overcome this speed limitation by implementing a save and restore methodology that allows a complete simulation state to be saved at any point during execution of the simulation. This saved state can then be loaded at a later time to avoid re execution of the cycles that preceded the saved state. This technique is often used when a long boot process executes prior to the execution or use of other software components. Such methods have a fundamental limitation in that every component in the system including the software being debugged must support the state saving feature. Further in order to debug a system using this technique it is necessary to save the system state before the problem occurs. Since a system error may occur long before a problem manifests itself as a visible symptom however detecting the correct point in time to save a system state requires non trivial effort.

Thus software simulators may execute slowly and may be limited in their ability to exactly replicate hardware functionality. Accordingly a need exists for the ability to perform detailed software debugging less expensively and faster than current methods systems and devices allow.

The present invention provides systems and methods that facilitate accurate and rapid simulation of system software e.g. firmware that interacts with a hardware device. More specifically the invention facilitates the investigation of anomalies in the system software as it interacts with software objects that represent i.e. simulate the hardware device. Such anomalies often reveal themselves through successive executions of the hardware simulation either after modifications to the system software itself or following changes to the software objects with which it interacts. Embodiments of the invention utilize periodically saved hardware states design stimuli and design responses to replay the software object such that it responds to the same stimuli in the same manner and to detect instances in which the responses diverge from the stored simulation information. Subsequent interactions or portions thereof of the system software with the software object can be run using the saved stimuli essentially simulating execution of the object from certain object states forward thus allowing the simulation to proceed faster than an actual execution. The simulations can in some cases include re execution of the same software object to facilitate faster debugging or different software objects that share common code e.g. a system startup sequence used for multiple devices. 

Design stimuli include any signal which affects the software model of the hardware system regardless of its point of origin. This stimulus may be represented as a transaction if the software model of the hardware device has a transactional interface a transition on an input or bidirectional pin a deposit to an internal net or a signal originating from within the software model. Design responses may include pin transitions resulting from the design stimuli and may also include the execution of any models embedded within the software model as well as the updating of internal nets which are visible to the calling system.

In one aspect the invention provides a method for debugging software which may be system software that interacts with hardware devices and or software based simulations thereof. The method involves periodically saving input output I O information such as object stimuli and the responses resulting from the processing of the stimuli and hardware state information during the execution of the software object as it interacts with the system software. The software object is then re executed either in the same form or after some alteration to the system software and or the environment in which it is operating until a divergence is detected between the saved stimuli and the stimuli presented during the re execution. The saved I O information and hardware state information is then used to initiate a subsequent re execution of the software object starting at an execution point prior to where the divergence was detected.

The I O information may be saved at a frequency greater than the rate at which the hardware state information is saved. For example the I O information may be saved at each execution cycle of the software object corresponding to a clock phase of a software object that simulates a hardware device with which the software interacts whereas the hardware state information may be saved every n cycles where n is a configurable number greater than 1.

In some embodiments the software object includes simulated modules and non simulated modules which can be executed in parallel with each other. A non simulated module is a module such as pre compiled C code that does not allow its I O information or state information to be saved other than at the beginning and end of its execution. The execution of the non simulated modules can be halted at the point at which the divergence is detected while the simulated modules are re executed and when the re execution reaches the point at which the divergence was detected the non simulated modules can be reinstated in parallel with the re execution of the simulated modules. In this way processing time is not devoted to re execution of non simulated modules.

In the case of system software such as firmware the software may interact with software objects that simulate a hardware device on which the system software will operate i.e. firmware . In such cases the saved I O information may represent register transfer level pin values of a virtual hardware model representing a hardware device.

In another aspect the invention provides a system for debugging software that includes both storage and processing capabilities. The storage device stores I O information such as software stimuli and outputs resulting from processing the stimuli and hardware state information and the processing device is configured to periodically save the I O information and the hardware state information detect a divergence between the saved output and output resulting from a re execution of the software object as it interacts with the system software and initiate a subsequent re execution of the software object starting at an execution point prior to where the divergence was detected using the using the saved I O information and hardware state information.

In another aspect the invention provides software in computer readable form for performing the methods described herein.

The foregoing and other objects features and advantages of the present invention disclosed herein as well as the invention itself will be more fully understood from the following description of preferred embodiments and claims when read together with the accompanying drawings.

The present invention facilitates the simulation analysis and debugging of software. In certain implementations the software being analyzed represents system software such as firmware implemented on hardware devices. Such devices may themselves be modeled as software objects that represent coded descriptions of the electronic devices e.g. a Verilog RTL description . The system software may for example interact with the software objects in order to facilitate development and testing of the system software and its compatibility with the hardware device prior to device availability.

The following terms and corresponding definitions are used herein. A pin means a physical pin of a hardware device that represents an input output or in out element. A storage element refers to any element that retains a logical value even in instances in which certain non clock inputs change. In a physical hardware device examples of storage elements include latches and flip flops. A deposit is a method by which the value of a pin or storage element is changed.

Refer first to . Modem computing devices typically comprise both hardware e.g. circuitry and software embedded directly on the device e.g. system software or firmware that may be inserted into programmable read only memory programmable ROM thus becoming a permanent part of a computing device. In some implementations the firmware may include additional software components that do not interact directly with the device but may be used to interact with other devices. When a designing hardware device it is common for hardware designers to first describe the device in terms of a hardware description language e.g. as a Verilog register transfer level RTL file it being understood that the invention is compatible with essentially any hardware description or hardware description language . The electronic device may be for example an electronic chip a small functional block of a chip numerous chips that make up a complete system or any other combination of electronic components. The RTL description represents a complete functional characterization of the device specifying the registers of the device and the manner in which data is transferred among them this representation is preferable for performance purposes to a lower level e.g. gate level description. Interconnections within the hardware may be represented as vectors rather than requiring each wire of for example a wide bus to be defined explicitly. In any case the description contains sufficient detail to permit a software based simulation of the system to be generated and the description is processed by a compiler into a software simulation object . This object may be used to simulate the operation of the actual device in order for example to facilitate development and testing of system software that will be used with the device before it is physically available.

For example suppose the hardware being simulated is a network interface designed for use on a computer that supports a PCI bus interface a USB port interface and a PCMCIA interface. In this case the simulation object will simulate the functionality of all of these interfaces and may be used in conjunction with for example interface drivers that interact with the chip. Testing the system software involves applying to the object software representations of the data signals that would be applied to the terminals of the physical device. The simulation object in turn not only responds with data representative of the output signals that the device would generate but also maintains an internal representation of the register operations underlying the device output. These may be provided back to the system software and analyzed to investigate the behavior of the system software with respect to its interactions with the device thereby facilitating identification of potential design problems with the system software the hardware design or both.

In other words software representations of the data signals that emanate from the system software and that would be applied to the terminals of the device are provided to the object which not only responds with data representative of the output signals that the device would generate but also maintains an internal representation of the register operations underlying the device output. These may be analyzed to investigate device behavior and identify potential design problems allowing simulation of the system software to proceed in parallel with hardware development and thereby reducing overall time to market. In some embodiments in addition to the system software additional embedded code e.g. compiled C code or other software that runs simultaneously with the simulation object may also be included as part of the overall design.

In some embodiments the interactions between the system software and the software objects that represent the device are implemented using an application programming interface API that mediates between the internal object representation of the device and the system software. The API thereby provides an abstraction layer translating the functionality into inputs outputs and clock cycles that are handled by the simulation object . For example the simulation object may operate cycle by cycle whereas functions provided through the API may involve multiple cycles or operate on a transactional level.

When verifying the system software however it is often necessary to re execute the same or similar simulations of the software object with which it will interact to identify understand and resolve problems. Often such simulations may can be run dozens of times as the user hones in on a particular problem bug or design flaw. As such because software objects that model complex electronic devices are themselves complex and may require a long time to execute re execution can become quite time consuming. This is especially the case when the point of interest e.g. a point at which a bug was detected or some other anomaly occurred is far along the execution timeline. Indeed the problem is even more acute when interacting with a cycle accurate and RTL accurate virtual hardware model VHM .

In accordance with embodiments of the present invention a replayable model can be created and used to accelerate the re execution of the software object and its interaction with the system software using the API and information stored during previous executions. A replayable model as used herein refers to a software representation of the hardware device that based on recorded design stimuli and software states responds in exactly the same way to the same design stimuli in the same environment and detects any divergence in terms of the stimuli and or the resulting output relative to an earlier executions while maintaining correct functionality and a high level of transparency. Specifically model I O information such as VHM RTL pin values c model interface values values of certain registers etc. and hardware state information may be saved periodically during various executions of the software object and then used during subsequent simulations to identify faults and provide restart information to accelerate the simulation process.

In brief overview depicts a method for accelerating the execution of software during testing in accordance with an embodiment of the invention. Broadly the method includes executing the software object STEP and periodically e.g. every clock cycle or at every transaction storing both I O information STEP and hardware state information STEP as it interacts with the system software. Hardware state information is sometimes also referred to as checkpoint information. The software object can then be re executed by replaying the stored I O information STEP during which the I O information is compared to observed I O information STEP received from the system software. At some point during the playback a divergence may be detected STEP for example between the stored inputs and inputs generated by the system software during the replay of the software object. Optionally the cause of the divergence may be addressed and corrected STEP at which point the software object may be re executed. But instead of re executing the software object from its initial state saved I O data and saved state information can be loaded STEP thus simulating execution of the software object from a previously saved state typically but not necessarily the most recently saved state to the point of divergence and bringing the software object forward along its execution path as if it had been executing up to the checkpoint. As a result there is no need to actually execute the software object from its initial state to the checkpoint at which the state information was loaded significantly accelerating the execution process.

In some instances the divergence may occur at a checkpoint in which case loading the state information saved at that checkpoint is typically sufficient for debugging purposes to place the software object in the proper state for continued execution. However in some cases the divergence may occur between two checkpoints and as a result state information alone cannot bring the software object to the point where execution can resume. In such cases replaying the stored I O data STEP from the checkpoint up to the point of divergence permits the software object to resume execution from the divergence point forward.

Referring to a process for storing I O information and hardware state information is illustrated in greater detail. Execution of the software object can be represented by an execution timeline that generally flows forward as the software object executes though each cycle. At some periodicity the hardware state information which represents the state of the software model of the hardware device at the checkpoints is stored to a file or other memory device. The checkpoints may occur at a fixed periodicity e.g. every 1000 clock cycles and the state of each element of the software object at each checkpoint is stored. In addition I O information representing for example interactions between hardware components either actual or simulated and system software such as pin deposits etc. may be stored throughout the execution of the software object e.g. at each clock cycle or at some greater frequency than the rate at which state information is stored or at the rate with which higher level transactions are applied to the hardware device . The I O information and state information may be stored in a common file or in some cases separate files.

Suppose for example that the software is firmware that is to be loaded onto a hand held calculator for transferring data from the calculator s memory to a communications port. The simulation object meanwhile emulates the actual calculator device having for example functions for adding subtracting multiplying and dividing. To emulate actual system behavior the software object models the steps performed by a real calculator such as placing the inputs into physical registers within the system and performing a binary addition on the registers and thereupon placing the resulting values on a data bus to facilitate display and or further processing. In the context of the invention the system software interacts with the physical elements of the device to read data to and or write data from registers in the device. For example different states of the system software may include an initial state no inputs present a result state the result value on the data bus and a display state. The I O information may include a more granular representation of the process such as receipt of the inputs from an I O device e.g. a keyboard placement of the inputs at physical registers any intermediate pin deposits placement of the result on the data bus and display. The combination of stored software states and I O data may then be replayed to simulate the execution of the software without having to execute the software in its entirety.

The functionality of the systems and methods described above may be implemented as software on a general purpose computer such as a general purpose computer as shown in . The general purpose computer includes a processor a memory and I O devices . The processor the memory and the I O devices are interconnected by a bus .

The processor executes instructions that cause the processor to perform the functions dictated by the instructions. These instructions are typically read from the memory . In some embodiments the processor may be a microprocessor such as an Intel 80 86 microprocessor a PowerPC microprocessor or other suitable microprocessor.

The I O input output devices may include a variety of input and output devices such as a graphical display a keyboard a mouse a printer magnetic and optical disk drives network interface or any other input or output device that may by connected to a computer. The I O devices may permit instructions and data to be transferred from various computer readable media such as floppy disks hard disks or optical disks into the memory .

The memory may be random access memory RAM read only memory ROM flash memory or other types of memory or any combination of various types of memory e.g. the memory may include both ROM and RAM . The memory stores instructions which may be executed by the processor as well as data that may be used during the execution of such instructions. In particular in some embodiments the memory includes instructions that implement the API which is configured to save I O data and hardware state information for use during subsequent executions of the system software . API may be straightforwardly realized in accordance with the descriptions of its functionality set forth above.

The software implementing these modules may be written in any one of a number of high level languages such as C C C LISP or Java. Further portions of the software may be written as script macro or functionality embedded in commercially or freely available software. Additionally the software could be implemented in an assembly language directed to a microprocessor used in the general purpose computer such as an Intel 80 86 Sun SPARC or PowerPC microprocessor. The software may be embedded on an article of manufacture including but not limited to a computer readable medium such as a floppy disk a hard disk an optical disk a magnetic tape a PROM an EPROM or CD ROM.

It will be understood that the general purpose computer is for illustrative purposes only and that there are many alternative designs of general purpose computers on which software implementing the methods of the invention can be used.

While the invention has been particularly shown and described with reference to specific embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the appended claims. The scope of the invention is thus indicated by the appended claims and all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced.

