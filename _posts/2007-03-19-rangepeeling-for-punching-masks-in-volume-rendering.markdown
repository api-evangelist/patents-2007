---

title: Range-peeling for punching masks in volume rendering
abstract: Rendering with a punching mask is performed without voxelization. A plurality of sub-volumes are identified as a function of the punching mask. The sub-volumes are generally layered in range. Each sub-volume is rendered separately or independently. The renderings from multiple passes or sub-volumes are composited together.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07773086&OS=07773086&RS=07773086
owner: Siemens Medical Solutions USA, Inc.
number: 07773086
owner_city: Malvern
owner_country: US
publication_date: 20070319
---
The present patent document claims the benefit of the filing date under 35 U.S.C. 119 e of Provisional U.S. Patent Application Ser. No. 60 790 447 filed Apr. 7 2006 which is hereby incorporated by reference.

The present embodiments relate to volume rendering with masks. In particular a dataset representing a volume with one or more regions not to be rendered is volume rendered.

For volume rendering the user may specify one or more arbitrarily shaped regions for masking. Uninterested structures may be masked from the volume data. In typical applications the user draws 2D curves that are extruded or extrapolated along the viewing frustum to create the 3D geometric regions. The resulting regions are punching masks or regions.

The punching masks are used in volume rendering to avoid rendering these regions. The geometric punching information is converted to a punching volume defining for each voxel whether the voxel is masked out. This voxelization process transforms a contiguous geometric description into a discrete volume representation resulting in information loss. Typically the punching volume is treated as a discrete binary volume mask. Rendering of the binary mask generates staircase surfaces that do not exist in the original punching geometry. This voxelization process can also be time consuming and storing the punching volume requires extra memory.

Using a fuzzy volume instead of a binary mask may reduce the staircase artifacts. However the fuzzy volume requires even more memory and only renders visually smooth surfaces. There is no guarantee that the fuzzy volume approach accurately reproduces the original boundaries between punched and non punched regions.

By way of introduction the preferred embodiments described below include methods systems instructions and computer readable media for rendering with a punching mask. A plurality of sub volumes is identified as a function of the punching mask. The sub volumes are generally layered in range and do not include spatial locations of the punching mask. Each sub volume is rendered separately or independently. The renderings from multiple passes or sub volumes are composited together.

In a first aspect a computer readable storage medium has stored therein data representing instructions executable by a programmed processor for rendering a volume with a punching mask. The storage medium includes instructions for a plurality of acts. A viewer location is identified. A first far layer of locations is determined relative to the viewer location as a function of the punching mask such that the punching mask is behind the first far layer. A first near layer of locations is determined relative to the viewer location. A first sub volume bounded by the first far layer and the first near layer is rendered. A second far layer of locations is determined relative to the viewer location. A second near layer of locations is determined relative to the viewer location. The determination is a function of the punching mask such that the punching mask is in front of the second near layer. A second sub volume bounded by the second far layer and the second near layer is rendered. The second sub volume is free of locations for the first sub volume.

In a second aspect a method is provided for rendering a volume with a punching mask. The punching mask is identified. Data for a plurality of depth layers is determined where each depth layer includes data spaced along a viewing direction. The determination is a function of the punching mask. The plurality of depth layers are volume rendered separately.

In a third aspect a system is provided for rendering a volume with a punching mask. A memory is operable to store a dataset representing a three dimensional volume and operable to store the punching mask relative to the three dimensional volume. The punching mask defines a first sub volume. A processor is operable to volume render the three dimensional volume by multiple rendering passes for different sub volumes other than the first sub volume. The different sub volumes are determined as a function of the punching mask.

The present invention is defined by the following claims and nothing in this section should be taken as a limitation on those claims. Further aspects and advantages of the invention are discussed below in conjunction with the preferred embodiments and may be later claimed independently or in combination.

Punching masks are volume rendered as geometric meshes. Converting the mask to an additional volume may be avoided. The geometric punching information is directly used for rendering. To handle arbitrary complex punching geometries the voxels that fall into non punched range layers are rendered in multiple passes. This range peeling algorithm finds range layers for removing uninterested punch regions. The layers may not be thin surface layers for surface rendering but may be multiple voxel deep sub volumes.

For rendering of a geometrically punched volume the volume is divided into two types of regions punched and non punched. The volume renderer only renders the voxels lying in the non punched region. A set of depth ranges are found directly from the punch geometry. The depth ranges contain only the non punched regions. The rendering is restricted to these depth ranges. The rendering then becomes a multi pass process. The number of passes is equal to the number of range layers. The set of depth ranges are processed in sequence such as back to front or front to back compositing. By operating front to back the renderer can utilize early ray termination for acceleration.

This range peeling approach can be flexibly used in conjunction with a wide variety of volume rendering frameworks. For example the range peeling can be implemented on a graphics processing unit GPU to output the range layers which can subsequently be used in a volume renderer on a software or a different hardware platform in a multi pass fashion. Alternatively the entire range peeling can be integrated into a single volume rendering implementation. This range peeling method is compatible with bricking and brick based invisible space skipping minimizing the overhead of multi pass rendering.

The system is part of a medical imaging system such as a diagnostic or therapy ultrasound x ray computed tomography magnetic resonance positron emission or other system. Alternatively the system is part of an archival and or image processing system such as associated with a medical records database workstation. In other embodiments the system is a personal computer such as desktop or laptop a workstation a server a network or combinations thereof for rendering three dimensional representations.

The user input is a keyboard trackball mouse joystick touch screen knobs buttons sliders touch pad combinations thereof or other now known or later developed user input device. The user input generates signals in response to user action such as user pressing of a button.

The user input operates in conjunction with a user interface for context based user input. Based on a display the user selects with the user input a three dimensional region for punching. For example the user traces a two dimensional region. Other user controls may be provided for defining a punching region using one two or three dimensional input information. In alternative embodiments the processor determines the punching region automatically e.g. using boundary detection or semi automatically.

The memory is a graphics processing memory a video random access memory a random access memory system memory random access memory cache memory hard drive optical media magnetic media flash drive buffer combinations thereof or other now known or later developed memory device for storing data or video information. The memory stores one or more datasets representing a three dimensional volume for rendering.

Any type of data may be used for volume rendering such as medical image data e.g. ultrasound x ray computed tomography magnetic resonance or positron emission . The rendering is from data distributed in an evenly spaced three dimensional grid but may be from data in other formats e.g. rendering from scan data free of conversion to a Cartesian coordinate format or scan data including data both in a Cartesian coordinate format and acquisition format . The data is associated with different volume locations in a volume so is voxel data. The voxels are the same size and shape within the dataset. Voxels with different sizes shapes or numbers along a dimension may be included in a same dataset.

The dataset is provided in real time with acquisition. For example the dataset is generated by medical imaging of a patient. The memory stores the data temporarily for processing. Alternatively the dataset is generated from memory such as associated with rendering a virtual object or scene or from loading a previous scan of a patient.

The memory is operable to store the punching mask. The spatial locations relative to the volume to be rendered are stored. For example the spatial locations identified by the user are stored. The punching mask is a sub volume of contiguous or discontiguous voxels. The boundary of the punching mask is stored without associating each voxel as punched or not punched. Alternatively an identification of each voxel within the punching region is stored.

The processor is a central processing unit control processor application specific integrated circuit general processor field programmable gate array analog circuit digital circuit graphics processing unit graphics chip graphics accelerator accelerator card combinations thereof or other now known or later developed device for rendering with a punching mask. The processor is a single device or multiple devices operating in serial parallel or separately. The processor may be a main processor of a computer such as a laptop or desktop computer may be a processor for handling some tasks in a larger system such as in an imaging system or may be a processor designed specifically for rendering. In one embodiment the processor is a personal computer graphics accelerator card or components such as manufactured by nVidia e.g. Quadro4 900XGL or others ATI e.g. Radeon 9700 or others or Matrox e.g. Parhelia or others .

The range peeling algorithm may be executed efficiently by a graphics processing unit. The processor may be hardware devices for accelerating volume rendering processes such as using application programming interfaces for three dimensional texture mapping. Example APIs include OpenGL and DirectX but other APIs may be used independent of or with the processor . The processor is operable for volume rendering based on the API or an application controlling the API. The processor is operable to texture map with alpha blending minimum projection maximum projection surface rendering or other volume rendering of the data. Other types of volume rendering such as ray casting may be used. Other types of rendering may be used. For example in the scenario of applying masks to surface models range peeling and rendering geometry only within the depth ranges may be used.

The processor is operable to identify the punching mask. For example the processor receives the user indication as an output of the user input . The processor identifies the corresponding spatial locations or boundary. For example the user traces a two dimensional region and indicates which portion of the region relative to the trace is to be punched. The processor extrapolates the two dimensional region into a three dimensional volume such as extruding or extending the region along the viewing direction. Other extrapolations may be used. If the user defines more than one punching region the processor combines the punching regions.

The processor is operable to volume render the three dimensional volume. The processor identifies different sub volumes to be rendered in multiple rendering passes. The sub volumes are separate layers that do not include voxels for the punched region. The sub volumes are determined as a function of the punching mask. For example a far surface and then a near surface are identified for each of the sub volumes and corresponding rendering pass. The sub volume includes spatial locations between the two surfaces. The far and near surfaces are determined based on the punching mask and any previously rendered layers. The different layers are separately rendered in the multiple passes in a front to back or back to front order. The back and front are relative to the virtual view location the origin of the viewing direction .

The memory and or another memory stores instructions for operating the processor . The instructions are for rendering multiple layers with a punching mask. The instructions for implementing the processes methods and or techniques discussed herein are provided on computer readable storage media or memories such as a cache buffer RAM removable media hard drive or other computer readable storage media. Computer readable storage media include various types of volatile and nonvolatile storage media. The functions acts or tasks illustrated in the figures or described herein are executed in response to one or more sets of instructions stored in or on computer readable storage media. The functions acts or tasks are independent of the particular type of instructions set storage media processor or processing strategy and may be performed by software hardware integrated circuits firmware micro code and the like operating alone or in combination. Likewise processing strategies may include multiprocessing multitasking parallel processing and the like.

In one embodiment the instructions are stored on a removable media device for reading by local or remote systems. In other embodiments the instructions are stored in a remote location for transfer through a computer network or over telephone lines. In yet other embodiments the instructions are stored within a given computer CPU GPU or system.

In act the dataset for rendering is received with viewing parameters and a punch geometry. The dataset is received from a memory from a scanner or from a transfer. The dataset is isotropic or anisotropic. The dataset has voxels spaced along three major axes. The voxels have any shape and size such as being smaller along one dimension as compared to another dimension.

The viewing parameters determine a view location. The view location is a direction relative to the volume from which a virtual viewer views the volume. The view location defines a view direction. The viewing parameters may also include scale zoom shading lighting and or other rendering parameters. User input or an algorithm defines the desired viewer location. In one embodiment the view direction is used to initialize a near depth buffer and a far depth buffer. Both buffers are initialized to 0 nearest .

The punch geometry identifies spatial locations or voxels not to be used for rendering. The identification may be of voxels included or excluded from the rendering. In one embodiment the punch geometry is a polygon of an arbitrary shape and size such as shown in . A normal or other designation indicates which portion is to be punched. Without losing generality surface normals are assumed to always point towards the non punched region as shown in indicate the portion to be punched. The range peeling algorithm may be easily modified if the surface normals of the punching geometry point toward the puched region. A region of the surface with normals pointed towards the rendering view is considered as front facing. Contrarily a surface region with normals pointed away from the rendering view is considered as back facing. The examples of are front facing.

The punch geometry may be combined from a plurality of regions or define multiple regions. Since the user may specify multiple punching geometries and these geometries may be nested or intersect each other the spatial locations of the geometries are combined to form a unified punching mask. shows two examples. Each example has two punching geometries displayed as 2D curves or polygons. The punched region or punching mask for rendering is formed as the union of all regions defined by each individual punching geometry. In the punched region includes both the dashed and the solid bound areas. The normals indicate punching of regions inside each of the intersecting polygons. In the larger curve or polygon dashed indicates punching the inside region. The smaller curve or polygon solid line indicates punching the outside region. This may be used to define a hollow cylinder between the two polygons. Alternatively this defines the dashed area as the whole punched region i.e. a solid cylinder . Any representation for combining may be used.

In act data for a depth layer or sub volume is determined. Based on the loop back from act a plurality of depth layers are determined. Each depth layer includes data or voxels spaced along a viewing direction.

The sub volume for the depth layer is determined. By repeating sub volume identification different sub volumes are identified as depth layers. Each depth layer or sub volume includes only non punched spatial locations and spatial locations not included in other sub volumes. The multi pass rendering process uses depth ranges of voxels in each sub volume. For example range peeling is applied to find the first set of depth ranges containing the non punched region nearest to the rendering view. Range peeling is then applied to find the next depth range further from the rendering view than the last range. The sub volumes are identified as a function of depth location relative to other layers along the view direction.

The determination of the range of each layer is a function of the punching mask geometry. The view direction establishes the relative position of the punching mask to the non punched data. The non punched data is then layered for rendering in multiple passes.

To determine voxels included in each layer near and far surfaces of the layer are identified. The range peeling algorithm is a multipass approach that renders the punching geometry multiple times. Each pass outputs two depth buffers specifying the near and far surfaces of the layer. The far surface is a nearest front facing surface deeper than any previous far layer relative to the viewer location. For an example using the depth buffers of a GPU the depth of the nearest front facing surface that is farther than the current far depth buffer is identified according to the following. The depth of the frame buffer is initialized to 1 which is the farthest of the scene. The scene is set larger than the volume to avoid clipping but may be smaller. A standard depth test is enabled where a fragment is discarded if its depth is greater than the current depth value in the frame buffer. Back facing polygons are culled. In addition the depth value of each fragment is also compared with the depth of the corresponding pixel in the far depth buffer. A new far surface deeper than a the previous far depth stored in the far depth buffer is identified. Any fragment equal or closer than the previous far depth is discarded. The previous far depth is stored in the far depth buffer. Then the depth in the frame buffer is copied to the far depth buffer. Other approaches for identifying the far surface may be used.

The near surface is a farthest back facing surface closer than the corresponding far layer. The front edge or surface of the dataset or volume to be rendered is a first back facing surface. In a GPU example the near depth is identified according to the following after the far depth buffer is updated. In this stage the depth of the frame buffer is initialized to 0 and front face culling is enabled. In addition the depth test is reversed. Only fragments with greater depth values than the values in frame buffer can pass. A second depth test against the far depth buffer is also applied. Furthermore the stencil buffer records which pixels correspond to valid depth ranges in this step. If the near and far buffers are at a same location there is no data at those pixel locations for rendering. The stencil buffer is initialized to 0 and a pixel in the stencil buffer is set to 1 if a corresponding fragment passes the test. The depth contents of the frame buffer after the depth tests are treated as the near surface. Other approaches for identifying the near surface may be used.

In act whether a new layer was identified in the range peeling of act is determined. If no new layer is to be rendered the flow proceeds to act . In act the rendering is complete.

If a new layer is to be rendered the flow proceeds to act . In act valid depth ranges are determined. For some locations no spatial locations and corresponding data exist between the far and near surfaces. To avoid rendering inefficiently the rendering may be performed for only valid depth ranges. For example the stencil buffer identifies pixel locations associated with data for rendering. The sub volume between the near and far surfaces is rendered with the stencil mask enabled. Only pixels with stencil value greater than 0 are updated. Early stencil test may be enabled if it is available in hardware. If no data is provided in the layer for rendering at a given pixel the process returns to act . For pixels with valid depth ranges the data along the viewing direction is rendered in act .

In act the plurality of depth layers are rendered separately. By selecting sub volumes not excluded by the punching mask rendering may be performed without a binary mask. The stair step artifact may be avoided by directly rendering from the data set. The layering allows rendering in multiple passes while accounting for any shape of the punching mask. The geometry of the punch mask is encoded into continuous depth range values. In this way the range peeling method preserves rendering quality by avoiding the voxelization process as well as the associated inaccuracy. Memory may be saved since storage and processing of the intermediate punching volume is eliminated. The rendering is based on the original continuous geometric information preserving any details of the punching boundaries. If the punching boundary is smooth smooth surfaces are rendered in the images.

The different sub volumes are rendered to the same buffer. By compositing the sub volumes in the same buffer or image the final rendering or image includes information from each sub volume. The sub volume renderings are composited together.

For rendering a sub volume data along the range or depth dimension for each pixel location is combined. The data within the depth range of the sub volume is selected and used for rendering. The near and far surfaces or depth buffers define the voxels within the depth layer to be used for rendering. For any given pixel one or more voxels may be provided along the range dimension. For example the depth layer may be many voxels deep at a particular location. Different ranges of depth may be provided for the different pixel locations of the sub volume. The rendering is performed for each pixel location.

Volume rendering is performed with the dataset based on spatial locations within the sub volume. The rendering application is an API other application operating with an API or other application for rendering. In one embodiment the rendering is performed with a depth buffer of a GPU.

Any now known or later developed volume rendering may be used. For example projection or surface rendering is used. In projection rendering alpha blending average minimum maximum or other functions may provide data for the rendered image along each of a plurality of ray lines or projections through the volume. Different parameters may be used for rendering. For example the view direction determines the perspective relative to the volume for rendering. Diverging or parallel ray lines may be used for projection. The transfer function for converting luminance or other data into display values may vary depending on the type or desired qualities of the rendering. Other masking and or clipping may determine data to be used for rendering. Segmentation may determine another portion of the volume to be or not to be rendered. Opacity settings may determine the relative contribution of data. Other rendering parameters such as shading or light sourcing may alter relative contribution of one datum to other data. The rendering uses the data representing a three dimensional volume to generate a two dimensional representation of the volume.

In the GPU embodiment the identification of the near and far surfaces and the rendering use two depth tests for each fragment. If available the two depth tests are implemented by using direct hardware support. Alternatively one of the depth buffers is copied to a depth texture and the associated depth test is applied in the fragment program. Other implementations of the depth tests may be used.

The range peeling and rendering for sub volumes is repeated until no new layers remain in act . For each repetition another sub volume is identified and rendered.

In the near and far depth buffers are illustrated with solid and dashed curves or lines respectively. The viewing direction is shown as a vector relative to the volume. The volume to be rendered is shown two dimensionally for simplicity as a smaller box. The larger box specifies the view frustum or space being rendered with a near face far face and two sides along the viewing frustum. The punching geometry is shown extending outside the volume in this example but may be entirely within the volume.

The near layer of locations is also determined relative to the viewer location. For the first depth layer the near surface is determined as a front surface of the volume relative to the viewer location. The spatial locations between the near and far surfaces define the sub volume or near depth layer.

The sub volume bounded by the far layer and the near layer is rendered. The stencil extends across the volume from side to side since voxels are included in the sub volume for each pixel. Along each ray line for projection rendering or for each pixel a rendered value is determined based on the voxels as a function of depth.

The near layer of locations is determined relative to the viewer location as a function of the punching mask. Spatial locations between the far layer and the previous far layer not within the punching mask are identified. The near and far surfaces define the intermediate sub volume. The layer may be continuous or discontinuous. As represented in two dimensions the layer is discontinuous. In three dimensions the layer may be continuous such as cylindrical.

The sub volume bounded by the current or intermediate far and near layers is rendered. Each sub volume is free of locations for the other sub volumes. The near depth and far depths may coincide in some areas. As represented by the stencil boundaries voxels in these coinciding areas are not rendered. The rendering is performed for the stencil identified pixels.

The near layer of locations is determined relative to the viewer location. The near layer extends along the remaining portions of the punching mask. These portions are back facing or a back surface. The punching mask is in front of the near layer. The sub volume is free of locations for the other sub volumes.

The sub volume of the farthest depth layer is rendered. The voxels bounded by far and near layers are composited with other renderings. The stencil buffer indicates the pixels to be rendered for this layer.

After rendering each of the sub volumes a two dimensional representation of the volume without the data within the punching mask geometry is generated. The punching mask represents a void rather than an obstruction.

The rendering with range peeling may be performed on large volumes. For large volumes bricking may be used due to memory availability. Since multi pass rendering can induce some performance overhead range peeling may be used together with a bricked cache and with invisible space skipping techniques such as disclosed in U.S. Published Patent Application No. 2006 0164410 U.S. Ser. No. 11 235 408 filed Sep. 26 2005 the disclosure of which is incorporated herein by reference.

For bricking the entire volume is divided into bricks that are aligned with the major axes of the volume. Each brick represents a three dimensional region. shows one such brick. Only bricks containing visible voxels are rendered. Bricks not within a current layer are ignored removed from cache or not cached. Bricks including data within a current layer are cached for rendering. The brick cache system keeps frequently used bricks in graphics hardware memory to reduce the cost of transferring them.

To determine whether a brick is to be used for a given layer the brick boundaries are tested prior to volume rendering of the sub volume defined by the brick. When range peeling is applied a brick is first tested whether any of its voxels falls between the current near and far surfaces. Bricks outside of the depth ranges are simply skipped for rendering in the current rendering pass. A brick may be needed for multiple rendering passes if some of the punching geometry intersects the brick. In that case the brick cache system avoids the brick being swapped outside the graphics memory more likely ensuring that each brick is downloaded from system memory to graphic memory at most once for all the rendering passes of the current frame of image.

To reduce the cost of determining whether a brick is needed for the current depth layer the bounding box faces of the brick are rendered. For the rendering each fragment of the bounding box faces is tested against the two depth buffers and the stencil buffer. A brick may still intersect with a depth range layer even where all the face fragments are outside the range. As shown in the bounding box of the brick has no fragment between the two depth buffers. However voxels of the brick are visible for this depth layer. Only bricks that are completely closer than the near depth or completely farther than the far the depth are discarded. The bricks may be identified for discarding or no caching in a two pass rendering utilizing occlusion culling. In the first pass whether there is any boundary fragment that is farther than the near depth is checked. If no boundary fragment passes the whole brick is closer than the near depth and the second pass is skipped. Otherwise in the second pass the bounding box is rendered again. In this pass whether there is any boundary fragment that is closer than the far depth is tested. If so a voxel of the brick may be visible. Otherwise the whole brick is farther than the far depth. The utilization of invisible space skipping with depth range may reduce the overhead of multi pass rendering. All fragments are also tested against the stencil buffer so that only fragments in non zero depth range pass.

While the invention has been described above by reference to various embodiments it should be understood that many changes and modifications can be made without departing from the scope of the invention. It is therefore intended that the foregoing detailed description be regarded as illustrative rather than limiting and that it be understood that it is the following claims including all equivalents that are intended to define the spirit and scope of this invention.

