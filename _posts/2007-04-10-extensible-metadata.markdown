---

title: Extensible metadata
abstract: Systems and methods for extensible metadata are described. In one aspect, source code is compiled to generate an assembly. During assembly generating operations, metadata and extensible metadata is emitted into the assembly. The extensible metadata describes standard and non-standard metadata that presents an extension to the standard metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08104025&OS=08104025&RS=08104025
owner: Microsoft Corporation
number: 08104025
owner_city: Redmond
owner_country: US
publication_date: 20070410
---
This patent application is a continuation of U.S. patent application Ser. No. 10 608 986 filed on Jun. 26 2003 titled Extensible Metadata and hereby incorporated by reference.

Metadata is information describing a computer program that is stored either in a common language runtime portable executable PE or in memory. When program code type information and data is compiled into a PE file i.e. an assembly metadata is inserted into one portion of the file whilst code is converted into an intermediate language IL and inserted into another portion of the file. Every type all type members fields methods properties and events are defined and referenced in a module or assembly is described within metadata. For instance assembly metadata includes information to describe assembly identity name version culture public key etc. types name visibility base class exported types descriptive elements that modify types and members referenced assemblies security permissions needed to run interfaces implemented and so on.

A metadata consumer e.g. a browser linker compiler runtime integrated development environment IDE etc. performs its respective functions by loading metadata into memory to discover information about the consumer code s types members inheritance etc. Different consumers may use different metadata or share the same metadata for various purposes. Anyone building such a consumer must read and incorporate details of metadata layout the structure of which is fixed hardwired and enforced with a standardized schema and semantics or meaning of the metadata to use the metadata. For instance versions 1 and 1.1 of the Common Language Runtime CLR hard wire metadata content and structure stored in assemblies that s to say each assembly uses the same schema as documented in the well known ECMA 335 II document. Anyone building software that attempts to understand an assembly has no choice but to read and digest the details of layout and meaning defined in that document. Put another way the metadata is not self describing.

Entities such as computer programmers business development and so on often strive to create new useful products and to improve existing products for instance by adding features to computer languages the CLR and or other software tools to add a new table to change capabilities of a metadata consumer etc. Such product development enhancement typically requires changes or extensions to the kinds of metadata that are stored in existing assemblies. Use of custom attributes and or custom modifiers associated with already standardized data is not considered a metadata extension but rather a decoration of already standardized data . However since the layout of consumer metadata is hardwired with a fixed representation such extensions will be incompatible and almost guaranteed breaking to most existing metadata consumers i.e. applications that attempt to import the extended metadata used to support the new feature s . Execution of an unmodified consumer of the metadata may result in undesirable consequences such as application and or system crashes or lock ups data corruption etc. An unmodified consumer is a metadata importer e.g. a compiler tool common language interface CLI and or the like that has not been rewritten and recompiled to account for the newly added metadata.

To avoid undesirable runtime failures in view of newly added metadata extension s each and every importer of the extension typically needs to be rewritten and recompiled to successfully parse the extension. Requiring computer programmers to rewrite and recompile metadata consumer s can be substantially time consuming error prone and labor intensive. To make matters worse incompatible metadata consumer breaking behavior may occur with respect to every new feature added to metadata. This problem becomes even larger when the metadata extension is to be shared across multiple different types of metadata consumers.

Accordingly conventional systems and techniques make it substantially difficult to extend metadata to support new metadata consumer functionality without engaging in potentially time consuming labor intensive error prone and costly efforts to rewrite and recompile each and every metadata consumer that may use the modified metadata.

Systems and methods for extensible metadata are described. In one aspect source code is compiled to generate an assembly. Whilst converting a program written in an assembly level or higher level language metadata and extensible metadata is emitted into the assembly. The extensible metadata describes standard plus non standard metadata that presents an extension to the standard metadata.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Systems and methods for emitting and consuming extensible i.e. non standard metadata from an assembly are described. Extensible metadata describes metadata features constructs and or extensions to one or more source languages that cannot be stored or handled by standard metadata. Additionally extensible metadata is self describing with respect to its layout representation content and applicability to a metadata consumer. This self describing aspect of extensible metadata allows a metadata consumer a metadata importer to discover the presence properties and representation of the extensible metadata as well as a suggestion of whether the importer needs to understand and incorporate semantics of the extensible metadata for proper importer functionality.

In view of the above when a metadata consumer encounters unanticipated metadata i.e. a non standard metadata the consumer can selectively implement subjectively correct behavior by utilizing the self describing aspect of the extensible metadata to intelligently parse the extension s layout class information and so on. If the extension is not understood the consumer can selectively choose to display an error message gracefully exit and or perform some other operation response. This allows entities such as computer programmers to add a new feature to a metadata consumer e.g. linkers browsers compilers runtimes interfaces IDEs etc. wherein the new feature has a previously unanticipated layout or property without breaking previously shipped versions of the metadata consumer. Moreover the new feature can be added independent of potentially labor intensive and costly rewriting re compiling of the metadata consumer to parse a metadata extension associated with the new feature.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention is described in the general context of computer executable instructions such as program modules being executed by a personal computer. Program modules generally include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types.

The methods and systems described herein are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers server computers multiprocessor systems microprocessor based systems network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. Compact or subset versions of the framework may also be implemented in clients of limited resources such as handheld computers internet aware watches embedded controllers in vehicles or manufacturing equipment or other computing devices. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

As shown in computing environment includes a general purpose computing device in the form of a computer . The components of computer can include by are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor . The system bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Such media may be any available media that is accessible by computer and it includes both volatile and non volatile media removable and non removable media. In system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processor .

Computer may further include other removable non removable volatile non volatile computer storage media. For example illustrates a hard disk drive for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM R RW DVD ROM R RW R RAM or other optical media. Hard disk drive magnetic disk drive and optical disk drive are each connected to bus by one or more interfaces .

The drives and associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks random access memories RAMs read only memories ROM and the like may also be used in the exemplary operating environment.

A user may provide commands and information into computer through input devices such as keyboard and pointing device such as a mouse . Other input devices not shown may include a microphone joystick game pad satellite dish serial port scanner camera etc. These and other input devices are connected to the processing unit through a user input interface that is coupled to bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to bus via an interface such as a video adapter . In addition to monitor personal computers typically include other peripheral output devices not shown such as speakers and printers which may be connected through output peripheral interface .

Computer may operate in a networked environment using connections to one or more remote computers such as a remote computer . Remote computer may include many or all of the elements and features described herein relative to computer . Connections shown in are a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment computer is connected to LAN via network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means e.g. wireless communications for establishing communications over WAN . Modem which may be internal or external may be connected to system bus via the user input interface or other appropriate mechanism. Depicted in is a specific implementation of a WAN via the Internet. Here computer employs modem to establish communications with at least one remote computer via the Internet .

In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device. Thus e.g. as depicted in remote application programs may reside on a memory device of remote computer . It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including e.g. an operating system OS to provide a run time environment application programs for EM other program modules e.g. device drivers etc. and program data such as source code intermediate assemblies and or the like.

EM assembly includes metadata and platform processor independent intermediate language IL instructions . As such the EM assembly represents an intermediate stage in the conversion of the source code into platform specific native code for execution by a metadata consumer e.g. a browser linker compiler and or other computer program that imports the metadata portion of an EM assembly as well as execution of the native code by the processing unit s of . In contrast to conventional metadata metadata includes EM . EM is self describing in that it indicates its presence properties layout content and so on to a interrogating metadata consumer . All EM is substantially uniquely tagged or differentiated from all non EM to allow a metadata importer i.e. a consumer to discover the EM. Non EM is standard metadata which may also be represented in the metadata portion of the EM assembly . Each EM extension includes suggested action information. The suggested action information guides the metadata importer as to whether it must understand one or more features associated with the imported EM to properly function. Or whether the importer may safely ignore the feature with assurance that nothing catastrophic undesirable will result during runtime operations if the feature is ignored. The guiding information is defined by the designer s of each EM emitter . An EM emitter is an entity that generates the EM .

In one implementation the EM emitter is any computer program application that has been designed to emit EM such as a software tool that converts a Type Library or XML type definition file into a CLR assembly. In this implementation the EM emitter is the primary compiler . During source code compiling operations the primary compiler emits EM into the assembly by interfacing with an EM emitting Application Programming Interface API . The API is exposed by the runtime as unmanaged code and does not run under the control of the runtime .

After assembly has been generated by an EM emitter the assembly is available for loading and execution by one or more metadata consumers . Since a runtime is being utilized in this implementation the use of a runtime and all associated runtime interfaces is optional to generation and use of EM a metadata consumer utilizes a Just In Time JIT compiler component not shown of the runtime to covert the loaded assembly into native code . During this process the consumer calls EM discovery API to discover any EM that may be associated with the loaded native code . Upon identifying EM the consumer further interfaces with the API to interrogate and subsequently evaluate properties and or suggested guideline use of the discovered EM .

For example an importer calls EnumTypeDefs an API to retrieve details of all types defined in the current assembly . In contrast to existing techniques the importer must check whether the information returned is tagged extension . If so the importer must query for more information before proceeding for this it will use the new method GetFeatureUsed of the API to obtain a list of the features used by the assembly. In this implementation the API is managed code that is exposed and runs under control of the runtime . In an alternative implementation a method e.g. EnumGenericTypeDefs is used to retrieve only those type definitions that rely upon a particular feature for example the known Generics feature. In this alternative implementation multiple different species of EnumXXXTypeDefs are used by the importer to discover anything and or everything in the metadata .

In this implementation EM schema or MetaSchema table is stored in a new metadata stream called Schema that is different from other runtime streams e.g. Strings US Blob Binary Large Object GUID and . The MetaSchema table has the following features.

EM includes a new MetaStringHeap. It is modeled on the regular metadata String heap storing identifier names as null terminated UTF8 strings. It is stored in a new metadata stream called MetaString. The MetaStringHeap is used to store meta identifiers the name of a table eg NestedClassTable of a heap eg UserStringHeap the friendly name of a feature eg Generics and so on. These are in contrast to the names stored in regular metadata heaps for example the identifiers names of classes fields methods events etc for a user program.

It is suggested that the MetaStringHeap employ string interning but this is not mandated. Any consumer that builds dependencies upon whether a particular implementation of the MetaStringHeap interns strings is not portable.

Here is an example of the start of a MetaStringHeap. The first string is the null string at the byte offset 0x00 followed by TypeDef at byte offset 0x01 and so on. The terminating null is represented by the single glyph.

The following is an exemplary MetaHeapDef for metadata heaps. Items in italics are not stored as is they are simply helpful annotations for the reader .

EM includes a new EM MetaColDef with the following layout including layouts for extension features the FieldPtr table for uncompressed metadata. Note that assemblies need only include details for those tables present there is no need to include the definition of all possible metadata tables in all assemblies .

An EM token is a 4 byte value. The top byte records its kind i.e. the table number it indexes into . The lower 3 bytes represent the row number counted from 1 of that table. For example the token 0x0200003C is an index into row 0x3C of the TypeDef table whose table number is 0x02 . In general only those metadata structures indexed from the IL instruction stream are assigned a token. There is one kind of token assigned a high byte of 0x70 that supplies a byte offset counted from zero into the string heap.

Note that coded tokens are used in MetaColDef for the kind column. In this implementation and for purposes of backward compatibility values for the coded tokens are different from conventional token values which are restricted to the values 0x00 0xFF. This is done by starting coded token values at 0x0100.

As well as recording that 0x0101 is the tokenized representation for the coded token known as HasConst we record the set of tokens that it holds. And similarly for all other coded tokens. This is done in the MetaCodedVals table. Conceptually the MetaCodedValues table is as follows 

The values in the MetaCodedValues table are a list of uint16s. The first entry in the MetaCodeToks table is TypeDefOrRef with a set size of 3 so the first 3 uint16s in the MetaCodeVals table 0x0001 0x0002 0x001B TypeRef TypeDef TypeSpec are the members of the TypeDefOrRef coded token. And so on for all the remaining coded tokens. Uint16s are used rather than uint8s to accommodate the possibility in future that a coded token might have other coded tokens in its membership.

This is a new metadata not EM table. It holds information about every row in every metadata table that is tagged as extended . Its layout is 

For example a MustUnderstand mask of 0b0110 indicates that only CLR and Browsers can safely ignore the information in the table row defined by TableNum RowNum whilst Linkers and Compilers must understand the information to work correctly. A default MustUnderstand mask for example 0x0000 can be used to indicate all previous version features.

It s the UsesFeature table that a metadata importer queries when it reads an item of metadata marked with the extends bit. For performance reasons the UsesFeature table is sorted by TableNum RowNum columns eg for fast binary chop search .

As noted above each EM provided extension further includes suggested action information. The suggested action information guides a metadata importer consumer as to whether it must understand the feature associated with the imported EM to properly function or whether the importer may safely ignore the feature i.e. with an implied assurance that nothing catastrophic undesirable will result during runtime operations if the importer ignores the feature . For purposes of discussion software has to understand a feature if it needs to include code that explicitly checks for that feature s presence and takes some action based on that feature. Defining such guiding information for each feature presented by new EM implies careful thought by an EM emitter.

When it is substantially difficult to identify in advance how a particular type of consumer e.g. browser compiler runtime linker etc. should respond to an EM provided feature the emitter marks the feature as must understand for each type of importer.

As described above the emitted EM is self describing to an EM consumer including the runtime . The EM is tagged or differentiated such that is can be differentiated by a metadata consumer from the standard metadata. During compilation operations the primary compiler the compiler that converts a source language into Intermediate Language IL and generates a string heap e.g. see other data to store character strings associated with the EM . The primary compiler emits compiled source code as metadata which includes standard metadata and EM into the assembly .

At block a metadata consumer e.g. a browser a linker a compiler and or a runtime loads the assembly into memory. At block the metadata consumer interrogates one or more portions of the assembly to discover presence properties and or representation of the EM . This operation is completely independent of whether or not the metadata consumer was designed to parse the layout representation semantics and or use the one or more new features associated with the EM. In this implementation the metadata consumer performs these discovery and interrogation operations by interfacing with API exposed by the runtime . At block the metadata consumer uses information from the discovery and interrogation operations to determine whether it must understand the operations of the discovered EM to properly function may safely ignore the discovered metadata and or perform other implementation specific actions.

In one implementation a metadata consumer such as a browser uses information from assembly discovery and interrogation operations to navigate the corresponding EM . Responsive thereto the browser pretty prints at least a subset of the content described by the EM . The at least a subset may include metadata corresponding to a particular method new metadata feature and or so on. Since the browser is designed to interface with the EM the browser performs such navigating and pretty printing operations without being rewritten and recompiled i.e. completely independent of whether the assembly includes metadata extensions for features that at the time of the browser s development had not been defined .

In yet another example a metadata consumer is an assembly linker that uses information from assembly discovery and interrogation operations to successfully link merge multiple different assemblies together to generate a single output assembly. For purposes of discussion such an output assembly or any other metadata consumer output is represented by respective portions of other data of . At this point any metadata consumer i.e. in addition to the assembly linker can consume the output assembly without any need to rewrite and recompile the metadata consumer to resolve any conflicting use of metadata tables or heap use by respective ones of the merged assemblies. This is the case even when the input assemblies embed a same numbering of one or more metadata tables and or heaps to describe totally different features or constructs which may have been decided in isolation by their respective producers i.e. via proprietary implementations . Even in view of such diverse assembly characteristics a metadata consumer can parse the linked assembly output assembly to identify the meaning representation or interpretation of each such private metadata extension completely independent of whether the private metadata extension s had been defined at the time of the browser s development.

The described systems and methods provide for EM. Although the systems and methods have been described in language specific to structural features and methodological operations the subject matter as defined in the appended claims is not necessarily limited to the specific features or operations described. Rather the specific features and operations are disclosed as exemplary forms of implementing the claimed subject matter.

For example although the EM emitter of is described as interfacing with APIs to emit EM into EM assembly this description is only illustrative and other implementations could have been described. For instance in a different implementation the EM does not utilize the exposed API of the runtime to emit EM into the assembly but rather utilizes a different API exposed by a different computer program module or alternatively directly writes the EM into the assembly independent of any intermediate module and or API.

Additionally although metadata consumer of is described as interfacing with APIs to discover interrogate EM portions of the EM assembly this description is only illustrative and other implementations could have been described. For instance in a different implementation the EM does not utilize the exposed API of the runtime to emit EM into the assembly but rather utilizes a different API exposed by a different computer program module or alternatively directly writes and reads the EM into from the assembly independent of any intermediate module and or API.

