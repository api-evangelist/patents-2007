---

title: Pluggable merge patterns for data access services
abstract: Provided are techniques for storing data. Invocation of a data access service is received, wherein the invocation identifies a data structure storing one or more data elements having a data format. An update handler to be plugged into a data access framework is identified, wherein the update handler processes data elements having the data format. Under control of the update handler, data elements are accessed in the data structure; one or more statements for storing the data elements into the data store are determined; and the one or more statements are forwarded to the data access framework.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779047&OS=07779047&RS=07779047
owner: International Business Machines Corporation
number: 07779047
owner_city: Armonk
owner_country: US
publication_date: 20070622
---
Embodiments of the invention relate generally to pluggable merge patterns for data access services. In particular embodiments relate to using merge patterns to store data into data stores.

Relational DataBase Management System RDBMS software uses a Structured Query Language SQL interface. The SQL interface has evolved into a standard language for RDBMS software and has been adopted as such by both the American National Standards Institute ANSI and the International Standards Organization ISO .

RDBMS uses relational techniques for storing and retrieving data in a relational database. Relational databases are computerized information storage and retrieval systems. Relational databases are organized into tables that consist of rows and columns of data. The rows may be called tuples or records or rows. A database typically has many tables and each table typically has multiple records and multiple columns.

A majority of object relational persistence frameworks assume that objects are read from and stored into a database in a same transaction. A framework may be described as a reusable design for a software system. Examples of such frameworks include Java Data Objects JDO Enterprise JavaBeans EJB 2.0 which is a Java Application Programming Interface API that encapsulates business logic at a server Hibernate which is an object relational mapping solution for the Java programming language and Java Persistence API JPA which is a framework for managing relational data Java is a trademark of Sun Microsystems in the United States other countries or both . Therefore these frameworks require that each persistence capable object is augmented with code that allows a database engine to monitor how applications modify the object s state during a transaction. As objects are modified they are deemed dirty . At the end of a transaction the database engine scans all objects and stores each dirty object into the database. The database engine also keeps track of which objects were read from the database into the transaction and which objects were created or deleted during the transaction. Based on this lifecycle state information in order to update the objects state in the database the database engine determines whether to issue an SQL INSERT statement an SQL DELETE statement or an SQL UPDATE statement.

The model described above may be referred to as a stateful model and presents problems when applied in a web server environment. This stateful model in a web server environment requires that the server maintain the state of persistence across multiple client requests. This stateful model also requires that every request from a particular client is always routed to the server that also maintains the state. Maintaining the server side state for each client and bypassing a workload manager that routes requests to servers according to workload of the servers in order to route client requests to a fixed server limits scalability of services. Servers based on this stateful model can serve a finite number of clients in a closed corporate environment but they cannot scale up to serve the entire World Wide Web WWW in the open with a large number of clients especially as the number of clients is increasing rapidly.

A more natural and more scalable approach to operate in a web environment is to be stateless such that objects are read and stored in different transactions. When a server receives a client request the server reads the objects from the database serializes them and sends these serialized objects to the client. The server then forgets the request and any state associated with it. The client operates on the objects and later on may send another request to store some objects. The objects sent for storage may not necessarily be the same objects that the client originally read from the database. The objects sent for storage to the database may contain only a relevant subset of the data or may be entirely different types of objects probably derived from the originally read objects. This shows that maintaining the state of objects originally requested by clients provide no benefit if the objects that the client requests to store later on are not the same. Moreover there is no guarantee that the request for storing the object will be routed to the same server that served the original objects to the client. Therefore in a typical web application it is beneficial for the server to assume that requests for object storage are independent of requests for object reads. In other words even if the server could carry over the state from one request to another meaningful information might not be carried over.

The introduction of intelligent Asynchronous Java Script AJAX based clients makes the stateless server scenario even more challenging. AJAX may be described as a technique for developing interactive web applications. AJAX clients typically read graphs of data elements e.g. eXtensible Markup Language XML data elements Java Script Object Notation JSON data elements Java objects etc. and cache them for a period of time. For example a client may retrieve an existing order graph e.g. Order LineItem Product from the server. The client may add new line items modify existing line items and delete existing line items. Once the client is done with processing the order the client may want to merge the order graph back into the server. Now that the server is stateless the server needs sophisticated merge logic to determine how the database should be updated. There are a number of approaches for how the order graph may be merged into the database without any state information but which approach to use depends on the application. For example the merge logic may use an UPSERT SQL pattern to determine which line items need to be inserted or updated and a NOT IN SQL pattern to determine which line items should be deleted. Another pattern may be one in which line items that are determined to be deleted have a status field that is set to deleted rather than being physically deleted. Thus a merge pattern describes how data elements are to be merged into a database.

That is the prior art provides a number of different patterns suitable for a single use case. However the prior art does not provide a single pattern that could cover a wide range of use cases.

Moreover none of the available object relational frameworks supports stateless merge. At best conventional object relational frameworks provide mapping metadata that can include some qualifiers such as cascade delete but the actual pattern that may be used to store the objects is fixed and covers a very limited number of scenarios. Therefore the burden of implementing the stateless merge logic is always on the application side and is done by the application developer also referred to as a developer . This is very time consuming and error prone for the application developer.

Provided are a method computer program product and system for storing data. Invocation of a data access service is received wherein the invocation identifies a data structure storing one or more data elements having a data format. An update handler to be plugged into a data access framework is identified wherein the update handler processes data elements having the data format. Under control of the update handler data elements are accessed in the data structure one or more statements for storing the data elements into the data store are determined and the one or more statements are forwarded to the data access framework.

In the following description reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments of the invention. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of the invention.

The Web server includes a service i.e. a data access service . A service may be described as providing some capability. A service may also be described as a piece of application code that can be remotely invoked over a network by a client application or by another service. For example the service may be a web service e.g. provide a stock quote or a list of red toys or a Representational State Transfer REST service. A REST service may be described as one in which information content is retrieved from a Web site by invoking a service that returns an XML file that describes and includes the information content. In certain embodiments the service is a stateless data access service i.e. the service provides data access to a data store . . . such that objects are read and stored in different transactions .

The service includes server application code a data access framework one or more update handlers and a statement generator . The server application code a data access framework one or more update handlers and a statement generator in the service may be a same code unit e.g. one computer readable program or different code units e.g. different computer readable programs and separation in the illustration is for description purposes only.

The server application code executes to respond to a client request. A data access framework may be described as a set of pre built classes and their instances that collaborate with the application code to retrieve and store data from and to the data stores . . . . A data access framework may also be described as providing an abstraction that allows executing statements e.g. SQL statements against a data store . . . to retrieve results.

Some update handlers are predefined e.g. are pre built by a developer who has written the data access framework and are provided with the data access framework while other update handlers may be user defined. Predefined update handlers may also be referred to as system provided as they are provided with the data access framework .

The client and Web server may each comprise any computing device known in the art such as a server mainframe workstation personal computer hand held computer laptop telephony device network appliance etc.

The network may comprise any type of network such as for example a peer to peer network spoke and hub network Storage Area Network SAN a Local Area Network LAN Wide Area Network WAN the Internet an Intranet etc.

The Web server is coupled to data stores . . . where a and n and the ellipses are used to indicate that any number of data stores may be coupled to the Web server . In certain embodiments each data store . . . is a relational database. In certain embodiments each of the data stores . . . may be a different RDBMS and may be capable of executing a different version of an SQL statement. Each data store . . . may comprise of an array of storage devices such as Direct Access Storage Devices DASDs Just a Bunch of Disks JBOD Redundant Array of Independent Disks RAID virtualization device etc.

Embodiments provide a technique to merge a graph of data elements passed from the client to the Web server that is application dependent. In certain embodiments the pluggable merge patterns are implemented as update handlers . Pluggable merge patterns may be described as update handlers that may be plugged into a data access framework . Thus embodiments introduce a concept of pluggable merge patterns and a mechanism for plugging the merge logic into a data access framework e.g. a persistence framework . Embodiments provide the pluggable nature of the update handler to enable data having different data formats to be inserted or updated into a data store . . . using a single data access framework .

The update handlers may be described as black boxes that encapsulate the implementation details of the merge patterns. The update handlers may be generic and may be based on reflection. Reflection in the context of embodiments may be described as analyzing the data structure programmatically at runtime to determine how data elements in the data structure should be stored. The update handlers may be user defined i.e. written and provided by a user or system provided i.e. provided with the data access framework .

In certain embodiments the merge patterns are implemented using update handler objects sometimes referred to as UpdateHandler objects . The update handler objects may be comprised of straightforward Java code and JDBC calls JDBC is a trademark of Sun Microsystems in the United States other countries or both or might leverage another framework.

Although examples herein may refer to update handler objects update handlers may be implemented in various forms. There may be a separate update handler for JavaBeans data JavaBeans is a trademark of Sun Microsystems in the United States other countries or both map i.e. a data structure that stores key value pairs where each value is located in the structure based on an associated key XML JSON etc.

Also examples herein may refer to SQL statements however embodiments may be used with various types of statements e.g. statements written in other languages including XQuery XPath and XUpdate .

The UpdateHandler has two constructors 1 one in which users provide SQL statements and the parameters include an object to be inserted or updated and one or more SQL statements and 2 a constructor in which the SQL statements are automatically generated i.e. not provided by a user and the parameter includes an object to be inserted.

The following is an example of how users may perform an upsert using the UpdateHandler when one or more SQL statements are provided by the user 

The following is an example of how users may perform an upsert using the UpdateHandler interface when one or more SQL statements are to be automatically generated i.e. not provided by the user 

In certain embodiments an implementation of an UpdateHandler interface is instantiated and passed into an update method of a data object i.e. another object named data . In example 1 a BeanGraphUpdateHandler class which is a specialized class to handle updates to a graph of JavaBeans nodes performs an insert if a row does not exist in a data store . . . and performs an update to an existing row otherwise. In certain embodiments a developer provides the code of Example 1 .

In Example 1 data is an object and the update handler is passed to the data access framework as an argument. The order variable is a class that is the root parent of a hierarchy of data elements. A hierarchy may be described as a grouping of nodes with parent child relationships and a node in the hierarchy is a data element e.g. in a Department Employee Address hierarchy the departments employees and addresses are nodes . The BeanGraphUpdateHandler represents an object that understands these types of hierarchies of data elements and uses conventions e.g. such as using a method to get a value for a particular hostvariable to decipher the hierarchies. In Example 1 the BeanGraphUpdateHandler object is able to merge hierarchies of data elements. At runtime the data access framework calls back the user s implemented handler code in order to perform the merge technique.

A hierarchy of data elements often contains data of different types. As a default update handlers make use of conventions to determine the SQL statements needed. However it is often the case that customizations are made by assigning SQL statements to specific data types in the hierarchy. Embodiments provide overrides to enable such customizations. An override may be described as an interface that provides the update handler with SQL at a given node in the hierarchy. For instance code in Example 2 illustrates a user providing specific SQL to be executed when the BeanGraphUpdateHandler object encounters beans of type LineItem while traversing the graph of data elements. In certain embodiments a developer provides the code of Example 2 .

In Example 2 the BeanOverride implementation of the override provides hints to the BeanGraphUpdateHandler object through UPDATE and INSERT SQL statements that are to be utilized in the merge technique when nodes of type LineItem class are found.

In certain embodiments of update handlers overrides are not provided and the update handlers use reflection to analyze an input data structure to determine what type of statements should be generated to store the data elements. The generated one or more statements are executed to update the input data at the data store . . .

Different types of update handlers may be defined. For example a custom merge update handler may be built to take advantage of merge statements provided by different data stores . . .

Also update handlers may include features such as update only handler i.e. that updates without performing insertions UPSERT handler where if a row already exists in the data store . . . the row is updated otherwise a new row is inserted cascade delete handler that physically deletes rows of a table cascade mark delete handler that marks the rows to be deleted instead of physically deleting them and handlers primed with SQL that know how to mark rows.

Update handlers may combine reusable components for graph walking and sub graph updating. Graph walking is performed to walk through a graph of data elements i.e. to enumerate the data elements. The sub graph updating is performed to store the fields of data elements into columns of a table in the data store . . . . Storing the data elements includes knowing how to locate SQL statements to perform the storing or to generate the appropriate SQL statements to perform the storing. Update handlers are also able to extract data elements from the graph also referred to as decomposition .

Update handlers may take into account RDBMS constraints and order modifications to prevent constraint violations. For example inserts are performed before deletes for foreign key constraints.

In block the update handler forwards the one or more statements to the data access framework . In block the data access framework executes the statements received from the update handler to store the data elements in the data store . . . . Storing the data elements may be either inserting the data elements or using the data elements to update existing data elements in the data store . . .

Thus a stateless data access service invokes the data access framework and tells the data access framework which update handler to use. The data access framework invokes the update handler . The update handler returns one or more statements to the data access framework and the data access framework executes the one or more statements.

Thus an update handler includes logic for how a data structure is to be decomposed and logic for how data is to be stored. Different update handlers may be used for storing different data formats e.g. XML JSON Java objects etc. .

Thus pluggable merge patterns benefit application developers at the server end. Unlike general purpose persistence frameworks each merge pattern is specific to a particular use case and therefore can be highly optimized for that particular use case. The ability to customize and plug merge patterns according to specific requirements of an application comes from the fact that a library of merge patterns for the most common use cases can exist independently. Such pluggability eliminates the need to describe a complex mapping for each graph of data elements and to augment the application code in areas where the mapping languages lacks expressiveness. This capability allows developers to simply choose which merge pattern to use in order to merge the updated graph of data elements with the one that exists in the data store . . . .

The described operations may be implemented as a method computer program product or apparatus using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof.

Each of the embodiments may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. The embodiments may be implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the embodiments may take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium may be any apparatus that may contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The described operations may be implemented as code maintained in a computer usable or computer readable medium where a processor may read and execute the code from the computer readable medium. The medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a rigid magnetic disk an optical disk magnetic storage medium e.g. hard disk drives floppy disks tape etc. volatile and non volatile memory devices e.g. a random access memory RAM DRAMs SRAMs a read only memory ROM PROMs EEPROMs Flash Memory firmware programmable logic etc. . Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

The code implementing the described operations may further be implemented in hardware logic e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. . Still further the code implementing the described operations may be implemented in transmission signals where transmission signals may propagate through space or through a transmission media such as an optical fiber copper wire etc. The transmission signals in which the code or logic is encoded may further comprise a wireless signal satellite transmission radio waves infrared signals Bluetooth etc. The transmission signals in which the code or logic is encoded is capable of being transmitted by a transmitting station and received by a receiving station where the code or logic encoded in the transmission signal may be decoded and stored in hardware or a computer readable medium at the receiving and transmitting stations or devices.

A computer program product may comprise computer useable or computer readable media hardware logic and or transmission signals in which code may be implemented. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the embodiments and that the computer program product may comprise any suitable information bearing medium known in the art.

The term logic may include by way of example software hardware firmware and or combinations of software and hardware.

Certain implementations may be directed to a method for deploying computing infrastructure by a person or automated processing integrating computer readable code into a computing system wherein the code in combination with the computing system is enabled to perform the operations of the described implementations.

The logic of describes specific operations occurring in a particular order. In alternative embodiments certain of the logic operations may be performed in a different order modified or removed. Moreover operations may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel or operations described as performed by a single process may be performed by distributed processes.

The illustrated logic of may be implemented in software hardware programmable and non programmable gate array logic or in some combination of hardware software or gate array logic.

Input Output I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers .

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters .

The system architecture may be coupled to storage e.g. a non volatile storage area such as magnetic disk drives optical disk drives a tape drive etc. . The storage may comprise an internal storage device or an attached or network accessible storage. Computer programs in storage may be loaded into the memory elements and executed by a processor in a manner known in the art.

The system architecture may include fewer components than illustrated additional components not illustrated herein or some combination of the components illustrated and additional components. The system architecture may comprise any computing device known in the art such as a mainframe server personal computer workstation laptop handheld computer telephony device network appliance virtualization device storage controller etc.

The foregoing description of embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the embodiments the embodiments reside in the claims hereinafter appended or any subsequently filed claims and their equivalents.

