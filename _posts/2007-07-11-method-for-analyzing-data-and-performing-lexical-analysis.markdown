---

title: Method for analyzing data and performing lexical analysis
abstract: A system and method provide the ability to construct lexical analyzers on the fly in an efficient and pervasive manner. The system and method split the table describing the automata into two distinct tables and splits the lexical analyzer into two phases, one for each table. The two phases consist of a single transition algorithm and a range transition algorithm, both of which are table driven and permit the dynamic modification of those tables during operation. A third ‘entry point’ table may also be used to speed up the process of finding the first table element from state 0 for any given input character.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099722&OS=08099722&RS=08099722
owner: 
number: 08099722
owner_city: 
owner_country: 
publication_date: 20070711
---
This application is a divisional application of application Ser. No. 10 357 326 filed on Feb. 3 2003 titled SYSTEM AND METHOD FOR ANALYZING DATA which claims the benefit of U.S. Provisional Application Ser. No. 60 353 487 filed on Feb. 1 2002 titled INTEGRATED MULTIMEDIA INTELLIGENCE ARCHITECTURE both of which are incorporated herein by reference in their entirety for all that is taught and disclosed therein.

Lexical analyzers are generally used to scan sequentially through a sequence or stream of characters that is received as input and returns a series of language tokens to the parser. A token is simply one of a small number of values that tells the parser what kind of language element was encountered next in the input stream. Some tokens have associated semantic values such as the name of an identifier or the value of an integer. For example if the input stream was 

To implement a lexical analyzer one must first construct a Deterministic Finite Automaton DFA from the set of tokens to be recognized in the language. The DFA is a kind of state machine that tells the lexical analyzer given its current state and the current input character in the stream what new state to move to. A finite state automaton is deterministic if it has no transitions on input C epsilon and for each state S and symbol A there is at most one edge labeled A leaving S. In the present art a DFA is constructed by first constructing a Non deterministic Finite Automaton NFA . Following construction of the NFA the NFA is converted into a corresponding DFA. This process is covered in more detail in most books on compiler theory.

In a state machine that has been programmed to scan all incoming text for any occurrence of the keywords dog cat and camel while passing all other words through unchanged is shown. The NFA begins at the initial state 0 . If the next character in the stream is d the state moves to 7 which is a non accepting state. A non accepting state is one in which only part of the token has been recognized while an accepting state represents the situation in which a complete token has been recognized. In accepting states are denoted by the double border. From state 7 if the next character is o the state moves to 8. This process will then repeat for the next character in the stream. If the lexical analyzer is in an accepting state when either the next character in the stream does not match or in the event that the input stream terminates then the token for that accepting state is returned. Note that since cat and camel both start with ca the analyzer state is shared for both possible Lexemes . By sharing the state in this manner the lexical analyzer does not need to examine each complete string for a match against all possible tokens thereby reducing the search space by roughly a factor of 26 the number of letters in the alphabet as each character of the input is processed. If at any point the next input token does not match any of the possible transitions from a given state the analyzer should revert to state 10 which will accept any other word represented by the dotted lines above . For example if the input word were doctor the state would get to 8 and then there would be no valid transition for the c character resulting in taking the dotted line path i.e. any other character to state 10. As will be noted from the definition above this state machine is an NFA not a DFA. This is because from state 0 for the characters c and d there are two possible paths one directly to state 10 and the others to the beginnings of dog and cat thus we violate the requirement that there be one and only one transition for each state character pair in a DFA.

Implementation of the state diagram set forth in in software would be very inefficient. This is in part because for any non trivial language the analyzer table will need to be very large in order to accommodate all the dotted line transitions . A standard algorithm often called subset construction is used to convert an NFA to a corresponding DFA. One of the problems with this algorithm is that in the worst case scenario the number of states in the resulting DFA can be exponential to the number of NFA states. For these reasons the ability to construct languages and parsers for complex languages on the fly is needed. Additionally because lexical analysis is occurring so pervasively and often on many systems lexical analyzer generation and operation needs to be more efficient.

The following system and method provides the ability to construct lexical analyzers on the fly in an efficient and pervasive manner. Rather than using a single DFA table and a single method for lexical analysis the present invention splits the table describing the automata into two distinct tables and splits the lexical analyzer into two phases one for each table. The two phases consist of a single transition algorithm and a range transition algorithm both of which are table driven and by eliminating the need for NFA to DFA conversion permit the dynamic modification of those tables during operation. A third entry point table may also be used to speed up the process of finding the first table element from state 0 for any given input character i.e. states 1 and 7 in . This third table is merely an optimization and is not essential to the algorithm. The two tables are referred to as the onecat table and the catrange table. The onecat table includes records of type ET onecat that include a flag field a catalyst field and an offset field. The catalyst field of an ET onecat record specifies the input stream character to which this record relates. The offset field contains the positive possibly scaled offset to the next record to be processed as part of recognizing the stream. Thus the state of the lexical analyzer in this implementation is actually represented by the current onecat table index. The catrange table consists of an ordered series of records of type ET CatRange with each record having the fields lstat representing the lower bound of starting states hstat representing the upper bound of starting states kat representing the lower bound of catalyst character heat representing the upper bound of catalyst character and estat representing the ending state if the transition is made .

The method of the present invention begins when the analyzer first loops through the onecat table until it reaches a record with a catalyst character of 0 at which time the offset field holds the token number recognized. If this is not the final state after the loop the lexical analyzer has failed to recognize a token using the onecat table and must now re process the input stream using the catrange table. The lexical analyzer loops re scanning the catrange table from the beginning for each input character looking for a transition where the initial analyzer state lies between the lstat and hstat bounds and the input character lies between the lcat and hcat bounds. If such a state is found the analyzer moves to the new state specified by estat . If the table runs out denoted by a record with lstat set to or the input string runs out the loop exits.

The invention also provides a built in lexical analyzer generator to create the catrange and onecat tables. By using a two table approach the generation phase is extremely fast but more importantly it can be incremental meaning that new symbols can be added to the analyzer while it is running. This is a key difference over conventional approaches because it opens up the use of the lexical analyzer for a variety of other purposes that would not normally be possible. The two phase approach of the present invention also provides significant advantages over standard techniques in terms of performance and flexibility when implemented in software however more interesting applications exist when one considers the possibility of a hardware implementation. As further described below this invention may be implemented in hardware software or both.

The following description of the invention references various C programming code examples that are intended to clarify the operation of the method and system. This is not intended to limit the invention as any number of programming languages or implementations may be used.

The present invention provides an improved method and system for performing lexical analysis on a given stream of input. The present invention comprises two distinct tables that describe the automata and splits the lexical analyzer into two phases one for each table. The two phases consist of a single transition algorithm and a range transition algorithm. A third entry point table may also be used to speed up the process of finding the first table element from state 0 for any given input character i.e. states 1 and 7 in . This third table is merely an optimization and is not essential to the algorithm. The two tables are referred to as the onecat table and the catrange table.

Referring now to programming code illustrating a sample ET onecat record is provided. The onecat table includes records of type ET onecat that include a flag field a catalyst field and an offset field. The catalyst field of an ET onecat record specifies the input stream character to which this record relates. The offset field contains the positive possibly scaled offset to the next record to be processed as part of recognizing the stream. Thus the state of the lexical analyzer in this implementation is actually represented by the current onecat table index. The onecat table is a true DFA and describes single character transitions via a series of records of type ET onecat . A variety of specialized flag definitions exist for the flags field but for the purposes of clarity only kLexJump and kNeedDelim will be considered. The catalyst field of an ET onecat record specifies the input stream character to which this record relates. The offset field contains the positive possibly scaled offset to the next record to be processed as part of recognizing the stream. Thus the state of the lexical analyzer in this implementation is actually represented by the current onecat table index. For efficiency the various onecat records may be organized so that for any given starting state all possible transition states are ordered alphabetically by catalyst character.

The basic algorithm for the first phase of the lexical analyzer also called the onecat algorithm is provided. The algorithm begins by looping through the onecat table not shown until it reaches a record with a catalyst character of 0 at which time the offset field holds the token number recognized. If this is not the final state after the loop the algorithm has failed to recognize a token using the onecat table and the lexical analyzer must now re process the input stream from the initial point using the catrange table.

Referring now to sample programming code for creating an ET Catrange record is shown. The catrange table not shown consists of an ordered series of records of type ET CatRange . In this implementation records of type ET CatRange include the fields lstat representing the lower bound of starting states hstat representing the upper bound of starting states lcat representing the lower bound of catalyst character hcat representing the upper bound of catalyst character and estat representing the ending state if the transition is made . These are the minimum fields required but as described above any number of additional fields or flags may be incorporated.

A sample code implementation of the second phase of the lexical analyzer algorithm also called the catrange algorithm is set forth below.

As the code above illustrates the process begins by looping and re scanning the catRange table from the beginning for each input character looking for a transition where the initial analyzer state lies between the lstat and hstat bounds and the input character lies between the lcat and hcat bounds. If such a state is found the analyzer moves to the new state specified by estat . If the table runs out denoted by a record with lstat set to or the input string runs out the loop exits. In the preferred embodiment a small number of tokens will be handled by the catRange table such an numbers identifiers strings etc. since the reserved words of the language to be tokenized will be tokenized by the onecat phase. Thus the lower state values i.e. 

To illustrate the approach the table specification below is sufficient to recognize all required catRange symbols for the C programming language 

In this example the catRange algorithm would return token numbers 1 through 13 to signify recognition of various C language tokens. In the listing above which is actually valid input to the associated lexical analyzer generator the 3 fields correspond to the lstat hstat estat lcat and hcat fields of the ET CatRange record . This is a very compact and efficient representation of what would otherwise be a huge number of transitions in a conventional DFA table. The use of ranges in both state and input character allow us to represent large numbers of transitions by a single table entry. The fact that the table is re scanned from the beginning each time is important for ensuring that correct recognition occurs by arranging the table elements appropriately. By using this two pass approach we have trivially implemented all the dotted line transitions shown in the initial state machine diagram as well as eliminating the need to perform the NFA to DFA transformation. Additionally since the oneCat table can ignore the possibility of multiple transitions it can be optimized for speed to a level not attainable with the conventional NFA DFA approach.

The present invention also provides a built in lexical analyzer generator to create the tables described. CatRange tables are specified in the format provided in while oneCat tables may be specified via application programming interface or API calls or simply by specifying a series of lines of the form provided below.

As shown above in the preferred embodiment a first field is used to specify the token number to be returned if the symbol is recognized. This field is optional however and other default rules may be used. For example if this field is omitted the last token number 1 may be used instead. The next field is the token string itself which may be any sequence of characters including whitespace. Finally if the trailing period is present this indicates that the kNeedDelim flag the flags word bit for needs delimiter as illustrated in is false otherwise it is true.

Because of the two table approach this generation phase is extremely fast. More importantly however the two table approach can be incremental. That is new symbols can be added to the analyzer while it is running. This is a key difference over conventional approaches because it opens up the use of the lexical analyzer for a variety of other purposes that would not normally be possible. For example in many situations there is a need for a symbolic registration database wherein other programming code can register items identified by a unique name . In the preferred embodiment such registries are implemented by dynamically adding the symbol to a oneCat table and then using the token number to refer back to whatever was registered along with the symbol normally via a pointer. The advantage of this approach is the speed with which both the insertion and the lookup can occur. Search time in the registry is also dramatically improved over standard searching techniques e.g. binary search . Specifically search time efficiency the Big O efficiency to lookup a given word is proportional to the log base N of the number of characters in the token where N is the number of different ASCII codes that exist in significant proportions in the input stream. This is considerably better than standard search techniques. Additionally the trivial nature of the code needed to implement a lookup registry and the fact that no structure or code needs to be designed for insertion removal and lookup make this approach very convenient.

In addition to its use in connection with flat registries this invention may also be used to represent lookup and navigate through hierarchical data. For example it may be desirable to flatten a complete directory tree listing with all files within it for transmission to another machine. This could be easily accomplished by iterating through all files and directories in the tree and adding the full file path to the lexical analyzer database of the present invention. The output of such a process would be a table in which all entries in the table were unique and all entries would be automatically ordered and accessible as a hierarchy.

Referring now to a state diagram representing a directory tree is shown. The directory tree consists of a directory A containing sub directories B and C and files F1 and F2 and sub directory C contains F1 and F3. A function LX List is provided to allow alphabetized listing of all entries in the recognizer database. When called successively for the state diagram provided in it will produce the sequence 

Furthermore additional routines may be used to support arbitrary navigation of the tree. For example routines could be provided that will prune the list LX PruneList to save the list LX SaveListContext and restore the list LX RestoreListContext . The routine LX PruneList is used to prune the list when a recognizer database is being navigated or treated as a hierarchical data structure. In one embodiment the routine LX PruneList consists of nothing more than decrementing the internal token size used during successive calls to LX List . The effect of a call to LX PruneList is to remove all descendant tokens of the currently listed token from the list sequence. To illustrate the point assume that the contents of the recognizer DB represent the file folder tree on a disk and that any token ending in is a folder while those ending otherwise are files. A program could easily be developed to enumerate all files within the folder Disk MyFiles but not any files contained within lower level folders. For example the following code demonstrates how the LX PruneList routine is used to prune any lower level folders as desired 

In a similar manner the routines LX SaveListContext and LX RestoreListContext may be used to save and restore the internal state of the listing process as manipulated by successive calls to LX List in order to permit nested recursive calls to LX List as part of processing a hierarchy. These functions are also applicable to other non recursive situations where a return to a previous position in the listing navigation process is desired. Taking the recognizer DB of the prior example which represents the file folder tree on a disk the folder tree processing files within each folder at every level could be recursively walked non recursively by simply handling tokens containing partial folder paths. If a more direct approach is desired the recursiveness could be simplified. The following code illustrates one direct and simple process for recursing a tree 

These routines are only a few of the routines that could be used in conjunction with the present invention. Those in the prior art will appreciate that any number of additional routines could be provided to permit manipulation of the DB and lexical analyzer. For example the following non exclusive list of additional routines are basic to lexical analyzer use but will not be described in detail since their implementation may be easily deduced from the basic data structures described above 

LX Add Adds a new symbol to a recognizer table. The implementation of this routine is similar to LX Lex except when the algorithm reaches a point where the input token does not match it then enters a second loop to append additional blocks to the recognizer table that will cause recognition of the new token.

LX Sub Subtracts a symbol from a recognizer table. This consists of removing or altering table elements in order to prevent recognition of a previously entered symbol.

LX Set Alters the token value for a given symbol. Basically equivalent to a call to LX Lex followed by assignment to the table token value at the point where the symbol was recognized.

In addition to the above routines additional routines and structures within a recognizer DB may be used to handle certain aspects of punctuation and white space that may vary between languages to be recognized. This is particularly true if a non Roman script system is involved such as is the case for many non European languages. In order to distinguish between delimiter characters i.e. punctuation etc. and non delimiters i.e. alphanumeric characters the invention may also include the routines LX AddDelimiter and LX SubDelimiter . When a recognizer DB is first created by LX Init the default delimiters are set to match those used by the English language. This set can then be selectively modified by adding or subtracting the ASCII codes of interest. Whether an ASCII character is a delimiter or not is determined by whether the corresponding bit is set in a bit array Dels associated with the recognizer DB and it is this array that is altered by calls to add or subtract an ASCII code. In a similar manner determining whether a character is white space is crucial to determining if a given token should be recognized particularly where a longer token with the same prefix exists e.g. Smith and Smithsonian . For this reason a second array whitespace is associated with the recognizer DB and is used to add new whitespace characters. For example an Arabic space character has the ASCII value of the English space plus . This array is accessed via LX AddDelimiter and LX SubDelimiter functions.

A sample structure for a recognizer DB is set forth in . The elements of the structure are as follows onecatmax storing the number of elements in onecat catrangemax storing number of elements in catrange lexFlags storing behavior configuration options maxToken representing the highest token number in table nSymbols storing number of symbols in table name name of lexical recognizer DB Dels holds delimiter characters for DB MaxAccState highest accepting state for catrange whitespace for storing additional whitespace characters entry storing entry points for each character onecat a table for storing single state transitions using record type ET onecat and catrange a table storing range transitions and is record type ET CatRange .

As the above description makes clear the two phase approach to lexical analysis provides significant advantages over standard techniques in terms of performance and flexibility when implemented in software. Additional applications are enhanced when the invention is implemented in hardware.

Referring now to a sample implementation of a hardware device based on the OneCat algorithm henceforth referred to as a Single Transition Module or STM is shown. The STM module is preferably implemented as a single chip containing a large amount of recognizer memory combined with a simple bit slice execution unit such as a 2610 sequencer standard module and a control input . In operation the STM would behave as follows 

Referring now to another illustration of the operation of the STM is shown. As the figure illustrates once the Reset line is released the STM fetches successive input bytes by clocking based on the Next line which causes external circuitry to present the new byte to input port . The execution unit as shown in then performs the OneCat lexical analyzer algorithm described above. Other hardware implementations via a sequencer or otherwise are possible and would be obvious to those skilled in the art. In the simple case where a single word is to be recognized the algorithm drives the Break line high at which time the state of the Match line determines how the external processor circuitry should interpret the contents of the table address presented by the port . The Break signal going high signifies that the recognizer not shown has completed an attempt to recognize a token within the text . In the case of a match the contents presented by the port may be used to determine the token number. The Break line is fed back internally within the Lexical Analyzer Module or LAM see to cause the recognition algorithm to re start at state zero when the next character after the one that completed the cycle is presented.

Referring now to a logical representation of an internal STM implementation is shown. The fields memory described by the ET onecat structure is now represented by three registers two of 8 bits and one of at least 32 bits which are connected logically as shown. The Break signal going high signifies that the STM has completed an attempt to recognize a token within the text stream. At this point external circuitry or software can examine the state of the Match line in order to decide between the following actions 

The block 0 blocks and Add block in could be implemented using standard hardware gates and circuits. Implementation of the delim block would require the external CPU to load up a 256 1 memory block with 1 bits for all delimiter characters and 0 bits for all others. Once loaded the delim block would simply address this memory with the 8 bit text character and the memory output 0 or 1 would indicate whether the corresponding character was or was not a delimiter. The same approach can be used to identify white space characters and in practice a 256 8 memory would be used thus allowing up to 8 such determinations to be made simultaneously for any given character. Handling case insensitive operation is possible via lookup in a separate 256 8 memory block.

In the preferred implementation the circuitry associated with the OneCat recognition algorithm is segregated from the circuitry software associated with the CatRange recognition algorithm. The reason for this segregation is to preserve the full power and flexibility of the distinct software algorithms while allowing the OneCat algorithm to be executed in hardware at far greater speeds and with no load on the main system processor. This is exactly the balance needed to speed up the kind of CAM and text processing applications that are described in further detail below. This separation and implementation in hardware has the added advantage of permitting arrangements whereby a large number of STM modules can be operated in parallel permitting the scanning of huge volumes of text while allowing the system processor to simply coordinate the results of each STM module . This supports the development of a massive and scaleable scanning bandwidth.

Referring now to a sample hardware implementation for the range transition algorithm is shown. The preferred embodiment is a second analyzer module similar to the STM which shall be referred to as the Range Transition Module or RTM . The RTM module is preferably implemented as a single chip containing a small amount of range table memory combined with a simple bit slice execution unit such as a sequencer standard module. In operation the RTM would behave as follows 

In a complete hardware implementation of the two phase lexical analyzer algorithm the STM and RTM are combined into a single circuit component known as the Lexical Analyzer Module or LAM . Referring now to a sample LAM is shown. The LAM presents a similar external interface to either the STM or RTM but contains both modules internally together with additional circuitry and logic to allow both modules to be run in parallel on the incoming text stream and their results to be combined. The combination logic provides the following basic functions in cases where both modules are involved in a particular application either may be inhibited 

The final stage in implementing very high performance hardware systems based on this technology is to implement the LAM as a standard module within a large programmable gate array which can thus contain a number of LAM modules all of which can operate on the incoming text stream in parallel. On a large circuit card multiple gate arrays of this type can be combined. In this configuration the table memory for all LAMs can be loaded by external software and then each individual LAM is dynamically tied to a particular block of this memory much in the same manner that the ET LexHdl structure described above achieves in software. Once again combination logic similar to the combination logic utilized between STM and RTM within a given LAM can be configured to allow a set of LAM modules to operate on a single text stream in parallel. This allows external software to configure the circuitry so that multiple different recognizers each of which may relate to a particular recognition domain can be run in parallel. This implementation permits the development and execution of applications that require separate but simultaneous scanning of text streams for a number of distinct purposes. The external software architecture necessary to support this is not difficult to imagine as are the kinds of sophisticated applications especially for intelligence purposes for which this capability might find application.

Once implemented in hardware and preferably as a LAM module loaded and configured from software the following applications not exhaustive can be created 

Other applications. A variety of other applications based on a hardware implementation of the lexical analysis algorithm described are possible including but not limited to routing hierarchical text based address strings sorting applications searching for repetitive patterns and similar applications.

The foregoing description of the preferred embodiment of the invention has been represented for the purposes of illustration and description. Any number of other basic features functions or extensions of the foregoing method and systems would be obvious to those skilled in the art in light of the above teaching. For example other basic features that would be provided by the lexical analyzer but that are not described in detail herein include case insensitivity delimiter customization white space customization line end and line start sensitive tokens symbol flags and tagging analyzer backup and other features of lexical analyzers that are well known in the prior art. For these reasons this description is not intended to be exhaustive or to limit the invention to the precise forms disclosed. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto.

