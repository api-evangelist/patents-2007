---

title: Language neutral text verification
abstract: A resource string associated with output text is identified. A regular expression pattern is generated from the resource string. The regular expression pattern is matched to the output text. A verification result based on the matching of the regular expression pattern to the output text is provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07949670&OS=07949670&RS=07949670
owner: Microsoft Corporation
number: 07949670
owner_city: Redmond
owner_country: US
publication_date: 20070316
---
In many situations textual data needs to be verified and elements of interest within the text need to be extracted. Some common examples include verifying the output generated by an application and picking out variables that need to be validated in areas like software testing analyzing a log file generated by an application extracting diagnostic information for identifying reasons for failures in Product Support Services and extracting information from the output of an application while developing scripts for administrative Information Technology IT tasks.

Existing mechanisms for text verification are inadequate. First text is localized into many languages. Any verification code that depends on the specific text needs to be changed re implemented for each language making it costly. Such verification code also scales poorly as the number of languages text is localized to increases. Second the stability of such verification code is low because there can be ambiguity in where the elements of interest start and end in the text. In such situations the verification code will fail.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments of the invention provide language neutral text verification. A regular expression pattern is dynamically created from the resource string corresponding to the text to be verified. The text to be verified is matched with the generated regular expression. The pattern match accomplishes text verification and information extraction together. In one example embodiments of the invention may be used in software testing.

Many of the attendant features will be more readily appreciated as the same become better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However the same or equivalent functions and sequences may be accomplished by different examples.

Embodiments of the invention utilize resource strings and regular expression based pattern matching for text verification and information extraction. In short the problem of text verification and information extraction is reduced to one of pattern matching. From a resource string a regular expression pattern is dynamically generated. The text to be verified is matched with this regular expression pattern. The pattern match accomplishes text verification and information extraction together.

The term text refers to characters e.g. letter number punctuation mark etc. and or symbols that represent human speech. Text is often manipulated by computing devices using strings. A string includes a data structure composed of a sequence of characters usually representing human readable text.

Embodiments of language neutral text verification as described herein provide numerous advantages. First is language neutrality an implementation based on this approach will work irrespective of what language the text is localized into. Deriving the pattern from resource strings makes the solution language neutral. As text changes with localization the resource string also changes but the verification code itself remains unchanged.

Embodiments herein scale well when text is localized into more and more languages. Since the generation of the regular expression pattern is dynamic no changes to verification code are required. It automatically works on new languages. Also language neutral text verification is robust pattern matching with regular expressions handles ambiguous situations well.

Further embodiments herein are efficient regular expression pattern matching tools are highly optimized for text processing. Embodiments herein are also simple to implement. Text verification code based on techniques described herein is simpler to implement because it uses pattern matching tools to perform complex text comparisons and searches. The text verification code itself is very light weight.

Embodiments of the invention are described below in the context of software testing. The software testing examples presented below involve verifying output text generated by a command line application and extraction of information from the output text. However one skilled in the art having the benefit of this description will appreciate that embodiments of the invention may be used in other situations involving text verification.

Consider the command line application and its output text shown in . In the Command Line Interface CLI for backup application wbadmin is shown at . The output text is shown at .

The output text includes two parts static text and variables. As used herein static text includes text that comes straight from the resource string and is constant for a human language. It does not vary with application state or environmental factors for a given language. The non italicized text e.g. Version identifier shown at represents static text. This text may be verified for equivalence character by character.

As used herein a variable includes data generated at runtime by the application and varies from installation to installation time to time depending on state information and environment. In all the italicized text e.g. 4 30 2006 7 17 AM shown at are variables. A verification test may extract and use the variables for other further verifications. For example follow on tests may include restoring data from the backup taken at the variable 4 30 2006 7 17 AM shown at .

The following discusses existing approaches for text verification and their shortcomings in different circumstances. Approaches for verifying static text and extracting variable information from text are examined.

Verifying static text involves ensuring that static text is correct. For example verifying that the command s output should read wbadmin 1.0 Backup command line tool shown at instead of something else like aslkdfaldskf . Some of the existing techniques accomplish this by looking for some expected string in the text. For example static text like Backup Identifier may be tied to the verification code and the code would search for this string in the output. The problem with this approach is that it will not work across all languages that the application might be localized to. Referring to the output text is outputted in the German language from German CLI . Clearly a static text verification of looking for Backup Identifier it will definitely not work for German output text . There is no Backup Identifier string in German output text .

Extracting variable information in text involves extracting variables such as the Backup time from the output of the application. Existing techniques may accomplish this in several ways pick characters based on position within the text e.g. pick n characters starting at position m tokenize the output based on some separator e.g. a space and pick out the ntoken or pick characters based on relative position e.g. pick all characters after the and before n .

There are several problems associated with these approaches. For example if text is localized to a different language the position of the variable changes. In the backup application output in Backup time starts at the 13character in English shown at while Backup time starts at 20character in German shown at . Verification relying on position of variables will not work correctly in this case.

Where information extraction involves tokenizing text based on separators the variable itself might have the separator character. In such cases the variable will span many tokens. For example in Backup target comprises 4 tokens in English shown at while the backup target in German comprises 6 tokens shown at . Verification relying on tokenizing text will fail in such a case.

In another case the order in which variables appear in the output may vary from language to language. shows a resource string having variables 1 and 2 . The output text is displayed when some operation variable 1 could not be performed on a file variable 2 . In the English version of the resource string shown at the operation comes first followed by the file. In the Finnish version shown at the file comes first followed by the operation.

In another case there is a possibility of ambiguity where the variable ends and static text begins. In resource string shows the static text with the placeholder for the variable. In output shown at world following dear is part of the variable. In output shown at world following dear is part of static text. Thus there is ambiguity here. Approaches that extract variables based on their relative position such as extracting text between Hello and world will fail in such cases.

Turning to a flowchart shows the logic and operations of language neutral text verification in accordance with an embodiment of the invention. In one embodiment at least a portion of the logic of flowchart may be implemented as computer readable instructions. Embodiments of a computing device to execute such computer readable instructions are discussed below in conjunction with .

Starting in block the resource string s that comprise the text to be verified are identified. In most modern applications output text is generated from resource strings. Examples of textual output include textual output printed at a console text visible on a Graphical User Interface text written in log files for diagnosis and the like. For a given application it is possible to find which resource strings are being used to generate the text. For example in an application developed using Microsoft Visual Studio resource strings may be found in the application s resource file. Resource strings may also be found in a compiled resource file also called a Resource Dynamic Link Library DLL or a resource assembly installed with the application that can be examined using a binary resource editor. Referring to a resource string is shown for generating output text . In an embodiment discussed below in the output text and the corresponding resource string are passed as an input to a language neutral text verification application.

Proceeding to block a regular expression pattern is generated from the resource string s . In one embodiment the regular expression pattern is generated from the resource string by replacing format specifiers in the resource string with named captures. Format specifiers are placeholders in resource strings that would be replaced by variables at run time by the application. When the actual pattern matching happens in block the variables will get captured in the named captures of the regular expression.

Referring to for resource string the regular expression pattern generated after replacing format specifiers with regular expressions is shown. Resource string includes static text Backup time followed by a variable shown by placeholder static text Backup target followed by a variable shown by placeholder and static text Version identifier followed by a variable shown by placeholder . In generated regular expression pattern the symbol . causes one or more characters to be captured at the named capture such as capture . The symbol n caused the regular expression to refer to a new line.

It will be appreciated that the regular expression pattern is generated dynamically from the resource string. This enables the regular expression pattern to take into account variations from different languages after an application has been localized to a particular country or region. Also ambiguities between static text and variables are easily resolved when the regular expression pattern is built from the application s localized resource strings.

Generating the language neutral verification pattern from the resource string may involve various complexities. Cases where the resource string contains some special characters that can affect the pattern match and cases where the variables span multiple lines are some of the issues that need to be considered when generating the regular expression pattern. Consider the case where the resource string contains some special characters. In most regular expression parsers certain characters have special significance. For example in the Microsoft .NET Framework regular expression parser the character dollar is considered as an end of line marker. Now consider a resource string Pay me 1 . Consider the output text Pay me 100 . This output text is generated from the resource string and the language neutral text verification algorithm must succeed in matching the output and extracting the variable . However the .NET Framework regular expression parser considers the character as an end of line marker. Because of this the pattern matching fails because Pay me is not at the end of line. To avoid this the algorithm makes use of the escape character back slash to remove the special meaning of dollar . In the example resource string the dollar is preceded by a back slash like Pay me 1 . Now the regular expression parser performs the match correctly. In the case where a variable can span multiple lines a symbol . n can be used instead of . because the .NET Framework regular expression parser does not allow a . dot character to match a newline.

Continuing to block the regular expression pattern is matched with the output text. The pattern matching algorithm uses a regular expression based pattern matching tool and matches the text with the generated regular expression pattern. Also if the regular expression pattern includes any named captures values for variables are captured in the named captures. For example in output text which needs to be verified is matched against generated regular expression pattern . Example pattern matching tools that may be used include but are not limited to the Microsoft .NET Regular Expression class library or the Perl interpreter.

Next in block the verification results are provided. The verification results may be stored such as on a local or network storage or the results may be sent to an output device such as a printer or a display monitor.

In one embodiment if the match succeeds i.e. passes it means output is a valid instance of the resource string i.e. the logic of flowchart has verified that output has been generated from the resource string by the application the static text in the output matches the resource string verbatim and the variables have been extracted from the output. In short if the match succeeds the verification has passed output is validated and variable information has been extracted. For example in pattern matching will evaluate to true and the captures as shown at have been completed. In captured variable data is shown for capture capture and capture . If the pattern match fails it means the output text is not as expected. The pattern match may fail when the text to be verified is not a valid instance of the resource string or static text in the text to be verified does not match the resource string. Thus the text verification fails.

Turning to an embodiment of a language neutral text verification application is shown. Components of application may implemented as one or more computer readable modules executable by a computing device.

Language neutral text verification application includes a resource string finder a regular expression pattern generator and a pattern matching tool . Resource string finder finds the resource string s that are used to generate text . Text is the text to be verified. In the embodiment of resource string finder access the application resource file of the application that produced text . Application resource file may include a compiled resource file. Resource string finder extracts the relevant resource string s and passes them to regular expression pattern generator .

In one embodiment resource string finder receives user input to use in finding the resource string s . In one example user input may include a resource string identification ID for the resource string of interest. Resource string finder may then use the resource string ID to read the resource string from application resource file . In another embodiment user input includes at least a portion of the text from the text to be verified . Resource string finder uses the provided text to iterate through the resource strings in application resource file to find the matching resource string s .

Regular expression pattern generator takes the resource string s and outputs the regular expression pattern to be used for verification. Pattern matching tool compares text and the generated pattern received from regular expression pattern generator . Pattern matching tool outputs the verification result .

Embodiments herein provide language neutral text verification using resource strings and regular expressions. Generating a language neutral text verification pattern dynamically from the resource string provides language neutrality. As text changes with localization the resource string changes but the verification code itself remains unchanged. The use of pattern matching provides robustness efficiency and simplicity to the verification process. All the text processing such as comparisons extracting information dealing with ambiguous situations is handled by a pattern matching tool. The verification code implementation becomes simple but is still efficient and robust by virtue of using pattern matching.

Although not required embodiments of the invention are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement embodiments of the invention may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allow device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency infrared Near Field Communication NFC and other wireless media.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

In the description and claims the term coupled and its derivatives may be used. Coupled may mean that two or more elements are in contact physically electrically magnetically optically etc. . Coupled may also mean two or more elements are not in contact with each other but still cooperate or interact with each other for example communicatively coupled .

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments of the invention. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device . Those skilled in the art will also realize that all or a portion of the computer readable instructions may be carried out by a dedicated circuit such as a Digital Signal Processor DSP programmable logic array and the like.

Various operations of embodiments of the present invention are described herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment of the invention.

The above description of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments and examples of the invention are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the following claims are to be construed in accordance with established doctrines of claim interpretation.

