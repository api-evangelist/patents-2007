---

title: Automatic quality testing of multimedia rendering by software drivers
abstract: A method and system for automatically verifying the quality of multimedia rendering are disclosed. Specifically, one embodiment of the present invention sets forth a method, which includes the steps of directing a command intended for a first driver to both the first driver and a second driver in parallel as the multimedia application issues the command and in response to a condition indicative of having available data to compare, comparing a first output generated by a first processing unit associated with the first driver and a second output generated by a second processing unit associated with the second driver.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07987065&OS=07987065&RS=07987065
owner: NVIDIA Corporation
number: 07987065
owner_city: Santa Clara
owner_country: US
publication_date: 20070417
---
Embodiments of the present invention relate generally to quality assurance techniques and more specifically to a method and system for automatically verifying the quality of multimedia rendering.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

The robustness of a multimedia system depends in part on how rigorously and extensively the system is tested. However as the multimedia system and the applications running on the system become increasingly complex verifying these complex system and applications in a comprehensive and yet timely manner becomes more and more challenging. To illustrate is a simplified diagram of a conventional verification process for a graphics system. In this process a human operator visually inspects the image outputs of a computing device and a computing device to try to detect any image corruption. The hardware of this verification process is kept constant so that the graphics processing unit GPU and the GPU are the same. Some of the software components such as the application and the application are also kept constant but the other components such as the baseline driver and the test driver are varied. Because of the reliance placed on the human operator this process may be slow in delivering verification results and the verification results are prone to human errors.

Although some prior art attempts have been made to automate the verification process discussed above such efforts still fall short especially for handling highly interactive multimedia applications such as games. is a simplified diagram illustrating a conventional automated verification process for a graphics system. Here the process involves a single computing device running two sets of testing procedures at two different points in time namely timeand time without any intervention of a human operator. The first run of testing denoted as run time involves a baseline driver and the second run of testing denoted as run time involves a test driver . The computing device first stores the verification results from run time in a storage device and then retrieves the stored data to compare with the results from run time in a comparison operation . Unlike the process shown in either the GPU or another processing unit not shown in in the computing device performs the comparison operation .

Despite the automation there are still several drawbacks associated with this verification process. One due to the limited capacity of the storage device only a limited amount of verification results generated by the process can be stored and retrieved for comparison. Consequently instead of verifying an entire graphics application only a few representative frames of data from the graphics application are tested. This lack of extensive testing of the graphics application renders the application less stable. Two the automated verification process is unable to conduct multiple test runs such as run time and run time under identical testing conditions and potentially leading to meaningless verifications results. For instance suppose a newly developed test driver is to be tested against the baseline driver on how a ball bounces along a path in a display screen shown in . Suppose further that the bouncing pattern of the ball is generated according to a time based model. So even if the path stays constant in run time and run time any change in the testing conditions between the two runs may result in displaying the ball at a position in a particular frame in run time and displaying the ball at a completely different position such as a position in the same frame in run time . As has been demonstrated performing the comparison operation on the aforementioned two frames from the two test runs yields little to no useful information.

Moreover even if the testing conditions can be kept constant between test runs the test runs can still generate completely unrelated output data. For example suppose the test driver is to be tested against the baseline driver on displaying the explosion of the ball in the display screen . If the debris pieces from the explosion are designed to be randomly generated then having the same set of pieces in run time and run time to compare is nearly impossible and again leading to potentially meaningless verification results.

As the foregoing illustrates what is needed in the art is a verification process that is capable of extensively and efficiently verifying data generated by multimedia applications and addressing at least the shortcomings of the prior art approaches set forth above.

A method and system for automatically verifying the quality of multimedia rendering are disclosed. Specifically one embodiment of the present invention sets forth a method which includes the steps of directing a command intended for a first driver to both the first driver and a second driver in parallel as the multimedia application issues the command and in response to a condition indicative of having available data to compare comparing a first output generated by a first processing unit associated with the first driver and a second output generated by a second processing unit associated with the second driver.

One advantage of the disclosed method and system is that multiple test runs can be conducted in parallel in a single pass and under a set of deterministic testing conditions so that test results can be obtained efficiently and quickly.

Throughout this disclosure kernel mode software broadly refers to software having access to operating system structures all system memory and all processor instructions. One kernel mode component also implicitly trusts another kernel mode component. On the other hand user mode software only has access to user space and needs to make system calls to the kernel to access privileged instructions or data. To safeguard system security kernel mode software needs to validate data and addresses from user mode software. Also an operation is said to be performed in parallel with another operation when at least some portions of the two operations are performed at the same time. One embodiment of the present invention is implemented as a software component for use with a computer system. The software component defines functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive on which information is permanently stored ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention.

In one embodiment the RT test enabler is a runtime library which the application links with in the user mode of the operating system. The baseline driver and the test driver are both kernel mode drivers. is a simplified diagram of the driver infrastructure for the computing device according to one embodiment of the present invention. In particular the RT test enabler is designed to mimic a graphics Application Programming Interface API such as without limitation the Microsoft DirectX API. In one implementation the RT test enabler has the same file name and contains the same entry points as the graphics API . In addition the RT test enabler is placed in a particular file location e.g. in the same file directory as the application so that the application links to it as opposed to linking to the graphics API .

In one implementation referring back to the application issues a special command present after it queries the frame buffers in the video memory and video memory retrieves the processed image data from the frame buffers and places the retrieved data into two separate buffers in a system memory . In other words by the time the RT test enabler intercepts the present command in the step shown in not only has a frame of data been processed by the two graphics subsystems but the two sets of processed data have also been stored in the system memory . To perform the comparison operation in the step one implementation is for a processing unit other than the GPUs in the computing device to execute the programming instructions for implementing the comparison functionality. In one implementation the comparison instructions are a part of the programming instructions for the present command and are defined in the RT test enabler .

In an alternative implementation the application can issue other special commands which through the RT test enabler causing the GPU to copy the processed data stored in the video memory into the video memory and then to trigger the GPU to compare the two sets of processed data. Under this scenario the comparison algorithm is likely written in a low level programming language such as microcode for the GPU to execute. In one implementation the software containing this comparison algorithm may be kernel mode software. The GPU is also responsible for passing information related to the comparison results back to the user mode.

As has been demonstrated the RT test enabler enables the graphics subsystems and to receive and respond to the same set of commands in parallel and to conduct test runs under a deterministic set of testing conditions and in a single pass. In addition since different drivers can be easily loaded onto the two graphics subsystems in the computing device and can be tested against one another regression analysis can be efficiently performed ensuring the rapid development of a new driver according to one embodiment of the present invention. In one implementation a previous version of a driver is considered a baseline driver and a current version is considered a test driver.

Graphics drivers and stored within the system memory configures GPU and GPU respectively to take on the graphics processing workload performed by the computing device and to communicate with applications that are executed by the host processor . In one embodiment graphics drivers generate and place a stream of commands in a push buffer which is then transmitted to the GPUs. When the commands are executed certain tasks which are defined by the commands are carried out by the GPUs. At run time libraries and corresponding to the RT test enabler and the graphics API shown in are also loaded into the system memory . The graphics drivers and correspond to the baseline driver and the test driver and the GPUs and correspond to the GPUs and shown in .

In some embodiments of the computing device the chipset provides interfaces to the host processor memory devices storage devices graphics devices input output I O devices media playback devices network devices and the like. Some examples of the interfaces include without limitation Advanced Technology Attachment ATA bus Accelerated Graphics Port AGP Universal Serial Bus USB Peripheral Component Interface PCI and PCI Express . It should be apparent to a person skilled in the art to implement the chipset in two or more discrete devices each of which supporting a distinct set of interfaces. In yet other embodiments the host processor the GPUs the chipset or any combination thereof may be integrated into a single processing unit. Further the functionality of each or both of the GPUs and may be included in a chipset or in some other type of special purpose processing unit or co processor.

Connections and support symmetric communication links such as without limitation PCI Express . The connection can be any technically feasible scalable bus that provides a direct connection between the GPU and the GPU . In the computing device this direct connection is between two physically distinct graphics adapters or the graphics adapters and thus the connection is also referred to as an external video bridge. One embodiment of the connection can be implemented using the NVIDIA SLI multi GPU technology.

As shown the GPU within the graphics adapter is responsible for outputting image data to a display . The display may include one or more display devices such as without limitation a cathode ray tube CRT liquid crystal display LCD or the like. The GPU is also coupled to video memory which may be used to store image data and program instructions. The GPU within the graphics adapter is coupled to video memory which may also be used to store image data and program instructions.

Although the above paragraphs mainly focus on conducting test runs in parallel to compare graphics drivers it should be apparent to a person with ordinary skills in the art to apply the present invention to any multimedia drivers such as audio drivers. Moreover it should also be apparent to a person with ordinary skills in the art to conduct different types of test runs in the computing device of and yet still remain within the scope of the claimed invention. For instance instead of verifying one graphics driver against another these drivers are kept constant but one version of the GPU is compared with another according to one embodiment of the present invention. Furthermore if the tasks performed by one of the GPUs for example the GPU in can be performed by the a host processor then the verification becomes comparing the output data generated by the GPU with the output data generated by the host processor.

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples embodiments and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

