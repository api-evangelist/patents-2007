---

title: Streamlined declarative parsing
abstract: Programming mechanisms for data parsing facilitate both clear code specification and efficient execution. Declarative style code can be employed to enable clear and concise specification of data parsing. Further, an efficient parsing approach can be utilized that enables processing of a data structure without first materializing the entire structure to memory. More specifically, streaming and/or selective materialization of portions of data to memory can be employed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08005848&OS=08005848&RS=08005848
owner: Microsoft Corporation
number: 08005848
owner_city: Redmond
owner_country: US
publication_date: 20070628
---
The pervasiveness of computers and other processor based devices has resulted in data proliferation such that vast amounts of digital data are created and stored daily. Although originally the sole domain of well funded companies and research institutions technology advancements and cost reductions over time have enabled computers and other electronic devices to become commonplace in the lives of most everyone. As a result both businesses and consumers create and interact with large amounts of digital data.

Traditionally a database management system DBMS is employed to manage interaction with database data. The DBMS efficiently manages requests or queries from users and programs so that these entities are free from having to know specifics pertaining to how and where data is physically stored. Furthermore in handling requests the DBMS ensures integrity and security with respect to the data. The most common DBMS is a relational database management system RDBMS . In this system data is stored in a tabular format wherein data resides at intersections of rows and columns.

With the advent and growing popularity of the Internet and other networking technologies various other structured data languages or formats have been developed to facilitate storing and sharing of information across different technology systems. One such language is XML eXtensible Markup Language which is a standard language that allows entities and or groups to share information in a convenient fashion. This language uses tags or symbols to markup or describe content. Another format or scripting language that enables sharing of data is JSON JavaScript Object Notation . JSON is a lightweight data exchange format rather than a markup language that utilizes a collection of name value pairs and arrays of values to represent data. XML and JSON can capture various computer data structures e.g. objects lists trees . . . for storage and or transmission.

A myriad of application programming interfaces APIs and or language implementations can be employed to process structured data. For example XML data can be formatted queried and or transformed by XSLT XQuery and or XPath. These and other conventional mechanisms operate by loading an entire data structure in memory and subsequently performing operations over the materialized data structure.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to data parsing in a computer environment. More particularly data is parsed serially in accordance with declarative code. The size of a data structure that can be processed in memory is limited by available memory. As a result certain scenarios including those involving a large amount of data may not be feasible or affordable with in memory processing. In accordance with one aspect of this disclosure such issues can be remedied by parsing data without first requiring materialization of an entire structure to memory. Various streaming or serial parsing semantics can be employed alone or in combination with selective materialization of portions of data to facilitate efficient processing. Furthermore data parsing can be described clearly and concisely with declarative style code rather than lower level or imperative style code.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods are provided hereinafter for affording a declarative manner of parsing data without loading an entire structure to memory. In other words data can be described in a clear and concise manner and processed efficiently. Efficient processing is accomplished utilizing data streaming or and or selective materialization. Further various mechanisms are disclosed to confront specific processing circumstances. For example mechanisms are provided for efficiently processing nested queries and branch queries.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a data parsing system is illustrated in accordance with an aspect of the claimed subject matter. The data parsing system provides a mechanism for parsing a data structure in accordance with a particular specification thereof. Parsing refers generally to querying consuming or otherwise extracting data or information from an input. For example and not limitation the data parsing system can facilitate querying or retrieving data from a structured data source such as XML. The system includes an interface component and parse component .

The interface component receives retrieves or otherwise acquires or obtains code that describes data to be parsed. According to an aspect of this disclosure the code can be specified in a declarative style or fashion. Declarative specification relates to generally declaring what needs to be done rather than specifically outlining actual steps that need to be performed e.g. imperative specification . By way of example and not limitation a declarative specification can correspond to a SQL Structured Query Language select from where query FLWOR For Let Where Order Return expression or the like. In one implementation declarative code can be included as a language integrated query wherein query operations like SQL statements are natively supported as first class citizens of a programming language.

The parse component can receive or retrieve declarative code directly or indirectly from the interface component . Upon receipt or access the parse component can parse or process an identified data structure in accordance with the declarative code and optionally return a result dependent upon an operation. In one instance the declarative code can correspond to a query that returns a subset of data from the data structure which can include without limitation XML eXtensible Markup Language objects e.g. scripting language objects in JSON JavaScript Object Notation directories comma separated files CVS database tables data streams music and video.

Moreover parse component can process data efficiently without requiring an entire data structure to be materialized in memory. In many cases data structures are very large collections of data. As a result loading the entire structure to memory prior to performing any operations thereon may be impossible and or unaffordable. Furthermore even when a structure is smaller materialization of the whole structure may be inefficient in terms of processing and or resource allocation. The parse component addresses these concerns by utilizing data streaming alone or in conjunction with selective and or transient materialization. Data can be processed serially or iteratively one element at a time where possible. In this manner a memory footprint is limited substantially to the size of each element or a small group of elements. Memory space can also be reused or made available for recapture e.g. garbage collection after each element is processed. Additionally or alternatively portions of a data structure can be materialized to memory for example where an operation or group of operations is unable to be effectuated in a single pass or serial manner.

It is to be appreciated that the system can be implemented in many different manners. In one instance system and or components thereof can be implemented as an application programming interface API . For example functionality provided by the parse component and or interface component can be embodied as external program method calls e.g. stream materialize . . . . Alternatively the functionality can be incorporated within a program language e.g. XPath XQuery . . . among other things to facilitate efficient code generation and or query execution for instance.

For purposes of clarity and understanding consider a problem of consuming or parsing huge amounts of XML. For the sake of a concrete example consider the following book list 

One problem with conventional query enabled XML APIs as well as language implementations e.g. XPath XQuery XSLT . . . is that they assume an in memory representation for XML trees. However as previously mentioned an in memory representation may not be possible and or affordable. Accordingly more efficient query semantics or parsing approach is needed such that serialized input is processed say parsed more directly and smaller portions are materialized in memory transiently.

In principle low level parsing APIs can be employed to process XML without loading it into memory. However these low level APIs require special programming skills and are cumbersome as well as error prone. More specifically use of such technology requires developers write specialized and complicated code to keep track of what they have seen before against that for which they are looking essentially managing state. This becomes increasingly difficult as a function of data size so much so that it is essentially impossible to do complicated things because the complexity quickly overwhelms a developer.

The data parsing system provides a solution to identified issues with conventional technology. In particular declarative style code can be employed utilizing functional programming like idioms such as SQL Structured Language Query LINQ Language Integrated Query FLWOR For Let Where Order Return like queries over serialized and or selectively materialized data. As a result queries can be both efficiently written and executed.

In the example an XML data source can be open for parsing rather than loading the entire content. In this case the code segment var books XElement.Load Books.xml can be replaced with var books XElement.Open Books.xml or the like. The original in memory query provided above can be preserved as is if a suitable semantics is assumed of API members. Essentially the query should be executed as a single sequential pass over the input. The query in question is indeed simple enough to lend itself to such an execution. As a result the declarative style of an API for in memory XML queries is preserved where the input is not to be loaded into memory but instead serialized.

The above example pertains to a simple data structure and query conducive to a full streaming implementation. It is to be appreciated that a number of more complicated scenarios can be addressed with differing mechanisms can be to preserve both code and execution efficiency. In effect an optimal point can be located in a spectrum from fully serialized to fully materialized as a function of declarative code and or a data structure. Similarly degree of code declarativeness can also be impacted by the same or like factors.

Turning to a representative parsing component is illustrated in accordance with an aspect of the claimed subject matter. As described with respect to system of the parsing component can evaluate and or extract data from a structure in a memory efficient fashion as a function of declarative style code. In some instances queries or like code can be nested or chained. Nested queries are those queries that include at least one other query or sub query embedded within them. These queries are more complicated than un nested queries and do not lend themselves to straightforward serial processing. In fact nested queries by definition query into a data structure multiple times. This is works fine when a structure is fully materialized in memory. However it is problematic where single pass serial or streaming semantics are to be employed. To resolve this issue the parse component includes a load component and a stream component .

The load component provides a mechanism for shallow loading of data in memory e.g. cache RAM volatile storage . . . . In accordance with an aspect of the claimed subject matter portions of code can be explicitly or implicitly designated for streaming at each level of a structure or iteration. This designated code is also referred to as a payload. Information not identified as a payload can be referred to as a preamble. All or part of a preamble can be materialized to support serialization of a payload. Load component can open a file and perform shallow loading of memory with such information.

The stream component evaluates designated data serially. Elements are retrieved iteratively and materialized to memory . Once the element is evaluated from memory it can be replaced with subsequent element or alternatively made available for recapture by a garbage collector for example. It should be appreciated that the stream component can also utilize other information loaded to memory by the load component . Further yet the stream component can also employ the load component to perform shallow loading of data to facilitate nested evaluation.

The parse component can generate a serialized structure in memory as depicted in . The serialized structure can include a plurality of preamble components and payload components . The preamble components can include materialized data prior to a designated payload. This data can be completely materialized and parented such that elements thereof can be queried in a normal unrestricted manner. In other words it is not restricted to iterate once or serial interaction. The payload components can include a pointer or other identifier into a data structure to facilitate serialization or iteration across a portion of data such as a sub tree. Amongst other reasons the serialized structure is beneficial in that it occupies a relatively small amount of memory space as compared to complete structure materialization.

The load component and stream component effectively allow streaming or sliding over an input. During this process some data such as that corresponding to preamble information can be loaded to memory. Other data can be iteratively processed. Further yet the iterative processing of data can utilize preamble information loaded in memory among other things to aid data evaluation. Accordingly parse component is not limited to extremely rigid data. It can easily handle variations in structure such as where there is preamble information before elements of interest.

A concrete example is now provided to clarify aspects not to limit the claimed subject matter thereto. Consider the following XML tree for a product catalog e.g. a wine catalog whose products are further grouped in categories.

The trouble with this query is that there are no reasonable parsing semantics for executing the query in a single pass manner. The crux of the problem is that iteration is expressed over products of a category element while the id element of a category needs to be looked up. In general the same element should not be queried twice under a single pass parsing semantics. In addition one should not assume that both queries can be performed in a single pass in a sort of interleaved fashion although this may be possible because of order constraints on the results of the two queries. In the example the id element should be inspected first and then product elements filtered based thereon. The original query does not promise this particular order among id and product elements.

This problem can be solved by requiring a programmer to list up front element labels for iteration at each level of the tree when the XML data source is set up. Alternatively these labels may be able to be omitted where they can be inferred or otherwise determined automatically. The identified elements are also called the payload of parsing say streaming or simply payload whereas all elements before such payload elements compromise what is referred to as the preamble. In the example categories and products amount to the payload at the two levels under the rooting catalog element wherein the id element appears in the preamble of the category elements e.g. before the payload of the category elements which are the product elements .

The capability of nested iteration can be added to an existing in memory API as follows. Instead of a complete Load . . . a LoadStream . . . operation can be utilized which sets up the element labels for the payload 

In general preamble elements are materialized and parented. Hence preamble elements can be queried in a conventional manner. The payload is accessed by a designated Stream method a new axis so to say which parses the payload in its serialized form. Clearly one can iterate over the payload only once.

The earlier in memory query for printing selected product names evolves as follows queries for the payload based on the Elements axis are basically replaced by a new Stream axis and the query regarding the preamble remains unchanged as shown below 

Now consider execution and memory state of the above code. First the wines.xml file can be opened and some verification performed to unsure a valid starting state. The catalog element is then shallow loaded until it hits the first category element because that is a designated element over which iteration is to occur. At this point the memory state resembles 

The remainder of execution is driven by the query. The first line says iterate over the stream of category elements in the wine catalog. Elements returned by this streaming are again trees that subject to a new level of distinction between materialized preamble and iterate once payload. In this case the payload is the nested product element. Accordingly shallow loading can be performed loading preamble information up until the product element. The resulting memory state resembles 

Next or concurrently the data can be filtered by the where clause to identify only categories of including the id extra super. As a result categories that are not labled extra super can be thrown away or alternatively information pertaining thereto never materailized. The resulting memory state resembles 

Finally products for this single category can be iterated over and printed to a screen. The result identifies three wines Bordeaux Ch teau Mouton Rothschild Bordeaux Ch teau Brane Cantenac and Vinho Verde Alianca. Since there is no preamble information for products they can simply be materialized evaluated and thrown away one by one. Accordingly product element need only be transiently resident such that only one element is in memory at a time. For the first element the memory state can resemble 

As can be observed streaming processing of nested queries results in substantially less memory utilization than full materialization. Although a rudimentary statistic the above example results in a total of approximately twelve lines of code materailized compared to twenty eight for complete structure materialization. Furthermore memory state fluxates such that the average amount of code is even less. This translates to enormous memory savings for much larger structures.

To summarize XML trees are loaded into the memory in a shallow fashion such that loading stops at the previously identified payload of the XML input. While the preamble of the payload can be queried in the normal manner the payload is queried at most once by a special streaming member. The reliable distinction between preamble and payload rests on up front identification of labels for payload elements through all levels of nesting. Each element returned by the streaming member is again a shallow XML tree that is subjected to a new level of distinction between materialized preamble and iterate once payload. These shallow elements are never parented and hence can be easily recovered by garbage collection.

The previously described exemplary idiom may be limited in some ways. For instance the descendant axis and the provision of functional updates would require non trivial elaborations of the idiom. Additionally diverse use of the original XML tree type for preamble elements and non parented payload elements may count as pragmatic.

A more general and principled approach is to designate a new object type to serialize a data structure for example XElementReader to serialized XML trees. An instance of the object can denote a pointer to a serialized structure. Object methods and or functions can be similar to that of an in memory object except that a method can exist for opening streaming data rather than loading data into memory. Similarly rather than returning materialized sub trees pointers to serialized trees can be returned. In this manner very similar programming models can exist for both in memory and streaming semantics if there are two implementations. One that works in memory and the other that reads over serialized structures.

In terms of XML and the previous example an XElementReader instance can denote a pointer to a serialized tree 

In sum parsing semantics opens a data source and query execution seeks into the serialized structure driven by a downward query. Many of these axes can be executed under a parsing semantics. Essentially all axes for downward queries are conveniently enabled for the parsing semantics while some additional forward queries could also be enabled. However the parsing semantics can be limited such that at most one query can be applied to each given node. This restriction is implied by the single pass sequential nature of parsing semantics. The following is a table of typical XML queries and comments on serial parsing semantics 

Referring to another representative data parse component is illustrated in accordance with an aspect of the claimed subject matter. Similar to the parse component include the load component and stream component as previously described. In brief the load component provides a mechanism for shallow loading portions of a data structure in memory and stream component streams through data iteratively interacting with the load component and memory where necessary. In essence the components and facilitate serial processing of a data structure including nested iteration.

However in some instance serial or iterate once processing may not be desirable or even possible. Accordingly the parse component can include a native or interact with a foreign materialization component . The materialization component is a mechanism for materializing portions of a data structure to memory e.g. implicitly or explicitly to facilitate evaluation. In one instance the materialization component can be utilized as an escape from serial processing to richer in memory processing. However materialized portions need not be parented with other portions of structures thereby making them available for garbage collection after use. Further yet it should also be appreciated that materialization component can be employed to add in memory processing such that a portions of a structure are evaluated in memory and others serially.

To aid understanding consider the problem of listing all books on loan from an XML document of a large number of books. The following is a reference solution utilizing an in memory language integrated query.

The sample code evolves as follows note the use of the new object type XElementReader previously described 

The materialization component can also be utilized to facilitate specification of order constraints which normally are not done in in memory cases. More specifically the materialization component can interact with the load component memory and or stream component to materialize a portion of data up until a certain designated point e.g. MaterializeUntil x . Further yet a serialized structure can be constructed including a preamble and payload as previously described with respect to nested iteration.

The query axes as discussed so far for XElementReader for example cover chaining but branching is not valid. For instance the following code pattern is invalid an attempt is made to dot twice into the same XElementReader instance xre 

The distinction between preamble and payload that was already made for nested iteration can be re enabled here. To this end an original axis MaterializeUntil for ordered branching queries with parsing semantics is added. Here is the necessary revision of the branching query 

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems and methods may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation the parse component can utilize such mechanisms to infer element labels for payloads and or implicitly identify and initialize materialization of structure where need for code parsing that employs serial parsing semantics.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a method of data parsing is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral declarative code is identified for data parsing e.g. querying extracting consuming transforming . . . . Declarative code identifies what action should be taken rather than how an action is to be performed which is characteristic of imperative code. Examples of declarative style code can be found in SQL LINQ and FLWOR expressions. For instance a data source can be identified and elements of the source selected as a function of a description of the data such as products sold in the United States. At numeral the declarative code is processes serially over an input source. The input source can be opened and serial parsing semantics implemented to parse or process data elements one by one in a streaming fashion in accordance with the declarative code without first loading an entire relevant data source in memory. Accordingly method preserves overall convenience of writing declarative code while providing underlying semantics for memory efficient processing of data in a serial or iterative manner.

Turning attention to a method of parsing branching queries aggregations and or transformations is illustrated in accordance with an aspect of the claimed subject matter. Branching queries can be defined as multiple queries departing from the same node of a tree or other structure. By way of example if a data structure includes element nodes queries or other parsing semantics are to be performed with respect to two particular elements foo and bar a single pass problem can occur such that while looking for elements foo elements bar will be passed without identification. This problem can be solved by explicit ordering of queries and use of materialization.

At reference numeral a source is open for serial parsing. A select portion of data can be materialized in memory at for example of in accordance with a MaterializeUntil method. In one instance a serialized structure can be creates as described with respect to nesting such that a preamble is materialized up to a pointer to a payload to be iteratively processed. At reference a first branch query is processed utilizing the in memory data structure. At numeral a second branch query or the like can be serially evaluated. This scenario assumes that elements described by the first query appear in order before elements of the second query.

It is to be appreciated that the branch query method incorporates aspects described regarding nested queries including utilizing a serialized structure including preambles and payloads. Moreover it is to be noted that method can applied to nested query processing.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire port . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers . For example data housed in server store can be parsed on a client wherein the data is streamed from a server to a client over the communication framework .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

