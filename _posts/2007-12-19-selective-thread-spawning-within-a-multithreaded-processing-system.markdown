---

title: Selective thread spawning within a multi-threaded processing system
abstract: One embodiment of the present invention sets forth a technique for selectively spawning threads within a multiprocessing system. A computation work distributor (CWD), within the system, is responsible for performing the detailed work needed to spawn a thread grid. A request to the CWD to spawn a thread grid includes a predicate table, which includes an array of flags used to indicate which thread indices should have an associated thread block spawned and which should not. Greater efficiency is achieved by only spawning thread blocks that should perform useful computation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08413151&OS=08413151&RS=08413151
owner: NVIDIA Corporation
number: 08413151
owner_city: Santa Clara
owner_country: US
publication_date: 20071219
---
Embodiments of the present invention relate generally to parallel processing and more specifically to selective thread spawning within a multi threaded processing system.

Multi processor systems that include one or more single instruction multiple data SIMD processing units typically implement a mechanism to spawn thread blocks on the SIMD processing units. Thread blocks are conventionally spawned with a one two or three dimensional thread index per thread that uniquely identifies each executing thread. Each thread index is accessible to the associated thread through a mechanism such as a system variable or application programming interface API call.

Conventional SIMD programming models use the thread index of a given thread to determine the specific function of the thread. For example the thread index may be used by a given thread to determine which portion of the overall processing load should be processed by the thread. Furthermore a given portion of the overall processing load indicated by the thread index may or may not need additional processing in subsequent processing steps as determined by the requirements of the specific algorithm being executed. In conventional processing systems when no further processing is required for a given thread index an associated thread is launched nonetheless and terminates after determining that no further processing is required. Spawning threads that perform no additional computation towards a given computational goal reduces overall efficiency. Additionally each thread that does useful computation must perform overhead computation to determine if the thread should continue executing further reducing overall system efficiency.

Certain common SIMD algorithms make sparse use of a two dimensional or three dimensional index space. These algorithms commonly perform a mapping function within each thread to map a one dimensional thread index used to spawn each thread to a working thread index of two or three dimensions that may be used for computation. For certain algorithms this mapping function consumes a significant portion of the computation required for each pass thereby reducing the overall system efficiency.

As the foregoing illustrates what is needed in the art is a technique for more efficiently performing computation within a SIMD multi threaded processing system.

One embodiment of the present invention sets forth a method for selectively spawning threads in a multiprocessing system. The method includes the steps of receiving a request to execute a thread program where the request includes a reference to the thread program to be executed and a reference to a predicate table that includes a plurality of indices indicating which thread blocks of a thread grid should execute the thread program initializing one or more loop variables where each loop variable is associated with a different dimension of the predicate table and a value of each loop variable indicates an index into the predicate table in the associated dimension computing a thread index based on the one or more loop variables and reading the predicate table at the computed thread index to determine whether a thread block associated with the computed thread index should be spawned.

One advantage of the disclosed method is that greater computational efficiency is achieved by spawning only the thread blocks of a thread grid that perform useful work.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

As shown in detail for PPU each PPU includes a host interface that communicates with the rest of system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. Host interface generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path and directs them to appropriate components of PPU . For example commands related to processing tasks may be directed to a front end unit while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a memory interface . Host interface front end unit and memory interface may be of generally conventional design and a detailed description is omitted as not being critical to the present invention.

Each PPU advantageously implements a highly parallel processor. As shown in detail for PPU a PPU includes a number C of cores where C 1. Each processing core is capable of executing a large number e.g. tens or hundreds of threads concurrently where each thread is an instance of a program one embodiment of a multithreaded processing core is described below. Cores receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from a front end unit . Work distribution unit can implement a variety of algorithms for distributing work. For instance in one embodiment work distribution unit receives a ready signal from each core indicating whether that core has sufficient resources to accept a new processing task. When a new processing task arrives work distribution unit assigns the task to a core that is asserting the ready signal if no core is asserting the ready signal work distribution unit holds the new processing task until a ready signal is asserted by a core . Those skilled in the art will recognize that other algorithms may also be used and that the particular manner in which work distribution unit distributes incoming processing tasks is not critical to the present invention.

Cores communicate with memory interface to read from or write to various external memory devices. In one embodiment memory interface includes an interface adapted to communicate with local PP memory as well as a connection to host interface thereby enabling the cores to communicate with system memory or other memory that is not local to PPU . Memory interface can be of generally conventional design and a detailed description is omitted.

Cores can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local PP memories into internal on chip memory process the data and write result data back to system memory and or local PP memories where such data can be accessed by other system components including e.g. CPU or another parallel processing subsystem .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local PP memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments PP subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated PP memory device s or no dedicated PP memory device s .

In operation CPU is the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in which may be located in system memory PP memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and executes commands asynchronously with operation of CPU .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of PPU to the rest of system may also be varied. In some embodiments PP system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

A PPU may be provided with any amount of local PP memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment in such embodiments little or no dedicated graphics PP memory is provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory e.g. via a bridge chip.

As noted above any number of PPUs can be included in a parallel processing subsystem. For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of the PPUs could be integrated into a bridge chip. The PPUs in a multi PPU system may be identical to or different from each other for instance different PPUs might have different numbers of cores different amounts of local PP memory and so on. Where multiple PPUs are present they may be operated in parallel to process data at higher throughput than is possible with a single PPU.

Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and so on.

As is well known a SIMD core executes a single instruction on different data across a plurality of parallel processing engines included in the core . Thus for example the core is configured to execute a series of common instructions on the parallel processing engines within the core . The series of instructions to a single parallel processing engine constitutes a thread as defined previously and the collection of a certain number of concurrently executing threads among the parallel processing engines within a core is referred to herein as a thread group. Additionally a plurality of thread groups may be active in different phases of execution at the same time on a core . This collection of thread groups is referred to herein as a cooperative thread array CIA .

The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is also an integer multiple of the number of parallel processing engines in a core and m is the number of thread groups simultaneously active on the core . The size of a CTA is generally determined by the amount of hardware resources such as memory or registers available to the CTA.

In one embodiment each core includes an array of P e.g. 8 16 etc. parallel processing engines configured to receive SIMD instructions from a single instruction unit . Each processing engine advantageously includes an identical set of functional units e.g. arithmetic logic units etc. . The functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

Each processing engine uses space in a local register file LRF for storing its local input data intermediate results and the like. In one embodiment local register file is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each processing engine and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. In some embodiments each processing engine can only access LRF entries in the lane assigned to it. The total number of entries in local register file is advantageously large enough to support multiple concurrent threads per processing engine .

Each processing engine also has access to an on chip shared memory that is shared among all of the processing engines in core . Shared memory may be as large as desired and in some embodiments any processing engine can read to or write from any location in shared memory with equally low latency e.g. comparable to accessing local register file . In some embodiments shared memory is implemented as a shared register file in other embodiments shared memory can be implemented using shared cache memory.

In addition to shared memory some embodiments also provide additional on chip parameter memory and or cache s which may be implemented e.g. as a conventional RAM or cache. Parameter memory cache can be used e.g. to hold state parameters and or other data e.g. various constants that may be needed by multiple threads. Processing engines also have access via memory interface to off chip global memory which can include e.g. PP memory and or system memory with system memory being accessible by memory interface via host interface as described above. It is to be understood that any memory external to PPU may be used as global memory . Processing engines can be coupled to memory interface via an interconnect not explicitly shown that allows any processing engine to access global memory .

In one embodiment each processing engine is multithreaded and can execute up to some number G e.g. 24 of threads concurrently e.g. by maintaining current state information associated with each thread in a different portion of its assigned lane in local register file . Processing engines are advantageously designed to switch rapidly from one thread to another so that instructions from different threads can be issued in any sequence without loss of efficiency.

Instruction unit is configured such that for any given processing cycle the same instruction INSTR is issued to all P processing engines . Thus at the level of a single clock cycle core implements a P way SIMD microarchitecture. Since each processing engine is also multithreaded supporting up to G threads concurrently core in this embodiment can have up to P G threads executing concurrently. For instance if P 16 and G 24 then core supports up to 384 concurrent threads.

Because instruction unit issues the same instruction to all P processing engines in parallel core is advantageously used to process threads in SIMD thread groups. As used herein a SIMD thread group refers to a group of up to P threads of execution of the same program on different input data with one thread of the group being assigned to each processing engine . A SIMD thread group may include fewer than P threads in which case some of processing engines will be idle during cycles when that SIMD thread group is being processed. A SIMD thread group may also include more than P threads in which case processing will take place over consecutive clock cycles. Since each processing engine can support up to G threads concurrently it follows that up to G SIMD thread groups can be executing in core at any given time.

On each clock cycle one instruction is issued to all P threads making up a selected one of the G SIMD thread groups. To indicate which thread is currently active an active mask for the associated thread may be included with the instruction. Processing engine uses the active mask as a context identifier e.g. to determine which portion of its assigned lane in local register file should be used when executing the instruction. Thus in a given cycle all processing engines in core are nominally executing the same instruction for different threads in the same SIMD thread group. In some instances some threads in a SIMD thread group may be temporarily idle e.g. due to conditional or predicated instructions divergence at branches in the program or the like. 

Operation of core is advantageously controlled via a core interface . In some embodiments core interface receives data to be processed e.g. primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed from work distribution unit . Core interface can load data to be processed into shared memory and parameters into parameter memory . Core interface also initializes each new thread or SIMD thread group in instruction unit then signals instruction unit to begin executing the threads. When execution of a thread or SIMD thread group is completed core advantageously notifies core interface . Core interface can then initiate other processes e.g. to retrieve output data from shared memory and or to prepare core for execution of additional threads or SIMD thread groups.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing engines may be included. In some embodiments each processing engine has its own local register file and the allocation of local register file entries per thread can be fixed or configurable as desired. Further while only one core is shown a PPU may include any number of cores which are advantageously of identical design to each other so that execution behavior does not depend on which core receives a particular processing task. Each core advantageously operates independently of other cores and has its own processing engines shared memory and so on.

In some embodiments multithreaded processing core of can execute general purpose computations using thread groups. As described previously a thread group consists of a number nO of threads that concurrently execute the same program on an input data set to produce an output data set. Each thread in the thread group is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

In some embodiments the thread groups are arranged as cooperative thread arrays or CTAs. Each CTA is a group of threads that concurrently execute the same program referred to herein as a CTA program on an input data set to produce an output data set. In a CTA the threads can cooperate by sharing data with each other in a manner that depends on thread ID. For instance in a CTA data can be produced by one thread and consumed by another. In some embodiments synchronization instructions can be inserted into the CTA program code at points where data is to be shared to ensure that the data has actually been produced by the producing thread before the consuming thread attempts to access it. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program.

In some embodiments threads in a CTA share input data and or intermediate results with other threads in the same CTA using shared memory of . For example a CTA program might include an instruction to compute an address in shared memory to which particular data is to be written with the address being a function of thread ID. Each thread computes the function using its own thread ID and writes to the corresponding location. The address function is advantageously defined such that different threads write to different locations as long as the function is deterministic the location written to by any thread is predictable. The CTA program can also include an instruction to compute an address in shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA.

CTAs or other types of thread groups are advantageously employed to perform computations that lend themselves to a data parallel decomposition. As used herein a data parallel decomposition includes any situation in which a computational problem is solved by executing the same algorithm multiple times in parallel on input data to generate output data for instance one common instance of data parallel decomposition involves applying the same processing algorithm to different portions of an input data set in order to generate different portions of an output data set. Examples of problems amenable to data parallel decomposition include matrix algebra linear and or nonlinear transforms in any number of dimensions e.g. Fast Fourier Transforms and various filtering algorithms including convolution filters in any number of dimensions separable filters in multiple dimensions and so on. The processing algorithm to be applied to each portion of the input data set is specified in the CTA program and each thread in a CTA executes the same CTA program on one portion of the input data set. A CTA program can implement algorithms using a wide range of mathematical and logical operations and the program can include conditional or branching execution paths and direct and or indirect memory access.

For example as is known in the art an array of data values e.g. pixels can be filtered using a 2 D kernel based filter algorithm in which the filtered value of each pixel is determined based on the pixel and its neighbors. In some instances the filter is separable and can be implemented by computing a first pass along the rows of the array to produce an intermediate array then computing a second pass along the columns of the intermediate array. In one CTA implementation of a separable 2 D filter the threads of the CTA load the input data set or a portion thereof into shared memory then synchronize. Each thread performs the row filter for one point of the data set and writes the intermediate result to shared memory . After all threads have written their row filter results to shared memory and have synchronized at that point each thread performs the column filter for one point of the data set. In the course of performing the column filter each thread reads the appropriate row filter results from shared memory and a thread may read row filter results that were written by any thread of the CTA. The threads write their column filter results to shared memory . The resulting data array can be stored to global memory or retained in shared memory for further processing. Where shared memory can be accessed with lower latency and or greater bandwidth than global memory storing intermediate results in shared memory advantageously improves processor throughput.

In one embodiment a driver program executing on CPU of writes commands defining the CTA to a pushbuffer not explicitly shown in memory e.g. system memory from which the commands are read by a PPU . The commands advantageously are associated with state parameters such as the number of threads in the CTA the location in global memory of an input data set to be processed using the CTA the location in global memory of the CTA program to be executed and the location in global memory where output data is to be written. The state parameters may be written to the pushbuffer together with the commands. In response to the commands core interface loads the state parameters into core e.g. into parameter memory then begins launching threads until the number of threads specified in the CTA parameters have been launched. In one embodiment core interface assigns thread IDs sequentially to threads as they are launched. More generally since all threads in a CTA execute the same program in the same core any thread can be assigned any thread ID as long as each valid thread ID is assigned to only one thread. Any unique identifier including but not limited to numeric identifiers can be used as a thread ID. In one embodiment if a CTA includes some number n of threads thread IDs are simply sequential one dimensional index values from 0 to n 1. In other embodiments multidimensional indexing schemes can be used. It should be noted that as long as data sharing is controlled by reference to thread IDs the particular assignment of threads to processing engines will not affect the result of the CTA execution. Thus a CTA program can be independent of the particular hardware on which it is to be executed.

The CWD receives a request and a predicate table as input. The request includes a reference to a thread program to be executed and a reference to the predicate table which is used to determine which threads should be executed as instances of the thread program. The collection of threads that should be executed is referred to as a thread grid. A thread grid includes without limitation one or more thread blocks organized to execute in any technically feasible fashion. Each thread block includes one or more individual threads. In one embodiment a thread group previously described in conjunction with the system of implements a thread block and one or more CTAs implements a thread grid. A requested thread grid is a set of thread blocks specified by the predicate table to be executed on the thread processors . Request also specifies the number of dimensions for the thread indices and numeric ranges for each dimension. The CWD generates a list thread indices to the scheduler which maps the requests onto thread processors for execution. The thread processors are able to access memory a shared memory system which may include multiple memory storage units.

In one embodiment the CWD and scheduler are sub modules within the work distribution unit of and the thread processors are the processing engines of . Memory includes any memory subsystem within the PPU including local register file shared memory and global memory .

The method begins in step where the CWD receives a request including a reference to predicate table . In step the CWD initializes one or more loop variables for computing thread indices. If the requested thread grid is one dimensional then one loop variable is used. If the requested thread grid is two dimensional then two loop variables are used and so forth.

In step the CWD computes a thread index using the one or more loop variables. For example if a two dimensional thread block is requested then loop variables x and y may each be initialized to 0. In the first pass x is computed in step to be zero in the next pass x is computed as one and so forth. Similarly y is initially computed to be zero in the first pass and is incremented each time x increments through the range specified in request . The result is a set of x and y pairs that cover the range of x and y specified in request . When all of the index combinations have been elaborated then the process may complete and a done state is computed.

If in step the done state is computed then the method terminates in step . If in step the done state is not computed then the method proceeds to step where the CWD reads predicate table using the current loop variables to select a corresponding entry. If in step the entry read from predicate table indicates that the corresponding thread block should be spawned then the method proceeds to step where the CWD schedules the thread block for execution. In one embodiment each thread block is individually scheduled. In an alternate embodiment sets of two or more thread blocks are scheduled at a time. The method then returns to step .

Returning to step if the entry from the predicate table indicates that the corresponding thread index should not be spawn then the method proceeds to step .

In sum a system and method for selectively spawning threads using a predicate table within a SIMD system is disclosed. The predicate table is used as input to the computation work distributor CWD which is responsible for spawning threads within the SIMD system. Each potential thread index has a corresponding thread block and an associated flag within the predicate table. When the flag is set to true the CWD spans spawns an associated thread block. When the flag is set to false the CWD does not spawn an associated thread block thereby saving thread resources as well as initialization overhead within each thread. The resulting system makes more efficient use of available thread processor resources. Persons skilled in the art will recognize that the techniques described herein may be applied to alternate embodiments optimized to execute on multiple instruction multiple data MIMD computation architectures without diverging from the teachings of the invention.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the scope of the present invention is determined by the claims that follow.

