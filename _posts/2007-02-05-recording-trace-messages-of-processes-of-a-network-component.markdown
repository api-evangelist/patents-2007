---

title: Recording trace messages of processes of a network component
abstract: A method for tracking a process is disclosed. Requests are received from process threads according to a time order. A request requests a buffer entry operable to record a trace message from a process thread of a process. A first buffer entry is assigned to a first process thread associated with a trace message according to the time order. A second buffer entry is assigned to a second process thread according to the time order subsequent to the assignment of the first buffer entry. The trace message associated with the first process thread is written to the first buffer entry in response to the assignment of the first buffer entry.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07899878&OS=07899878&RS=07899878
owner: Cisco Technology, Inc.
number: 07899878
owner_city: San Jose
owner_country: US
publication_date: 20070205
---
This application is a continuation of U.S. application Ser. No. 09 948 316 filed Sep. 6 2001 and entitled Recording Trace Messages of Processes of a Network Component .

This application claims benefit under 35 U.S.C. 119 e of U.S. Provisional Application Ser. No. 60 231 831 filed Sep. 6 2000 entitled OPTICALL. 

This application is related to U.S. patent application Ser. No. 09 948 288 entitled PROCESSING A SUBSCRIBER CALL IN A TELECOMMUNICATIONS NETWORK to U.S. patent application Ser. No. 09 948 220 entitled DATA COMMUNICATION AMONG PROCESSES OF A NETWORK COMPONENT to U.S. patent application Ser. No. 09 948 314 entitled PROVIDING FEATURES TO A SUBSCRIBER IN A TELECOMMUNICATIONS NETWORK to U.S. patent application Ser. No. 09 947 743 entitled MANAGING PROCESSES OF A NETWORK COMPONENT to U.S. patent application Ser. No. 09 948 420 entitled COMMUNICATING MESSAGES IN A MULTIPLE COMMUNICATION PROTOCOL NETWORK to U.S. patent application Ser. No. 09 948 216 entitled DATA REPLICATION FOR REDUNDANT NETWORK COMPONENTS to U.S. patent application Ser. No. 09 948 474 entitled MANAGING REDUNDANT NETWORK COMPONENTS to U.S. patent application Ser. No. 09 943 318 entitled MEDIA GATEWAY ADAPTER and to U.S. patent application Ser. No. 09 948 315 entitled SOFTWARE UPGRADE OF REDUNDANT NETWORK COMPONENTS all filed Sep. 6 2001.

This invention relates in general to multiple process systems and more particularly to recording trace messages of processes of a network component.

Telecommunications networks are used to provide voice and data communication to an increasing number of subscribers. Conventional telecommunications architectures rely on switched circuit pathways. Newer architectures rely on routing of voice and data packets. The newer architectures however may need to satisfy a number of needs. For example the voice and data communication may be based on a number of different communication protocols which a telecommunications network may need to accommodate. Additionally telecommunications networks may be required to provide a variety of features to subscribers. Consequently newer telecommunications architectures creates challenges and opportunities for telecommunications networks.

In accordance with the present invention the disadvantages and problems associated with multiple process systems have been substantially reduced or eliminated.

In accordance with one embodiment of the present invention a method for tracking a process is disclosed. Requests are received from process threads according to a time order. A request requests a buffer entry operable to record a trace message from a process thread of a process. A first buffer entry is assigned to a first process thread associated with a trace message according to the time order. A second buffer entry is assigned to a second process thread according to the time order subsequent to the assignment of the first buffer entry. The trace message associated with the first process thread is written to the first buffer entry in response to the assignment of the first buffer entry.

Examples of the present invention may include none some or all of the following technical advantages. A technical advantage of one example is that trace functions may be provided for a multiple process system or multiple thread system for example a telecommunication network where there may be a number of processes that are single threaded or multi threaded. The embodiment may provide a centralized time ordered trace facility where trace messages output by the multiple threads of multiple processes may be collected together and placed in time sequence with minimal performance impact.

A technical advantage of another example is that trace messages that record the processing of a call may be efficiently stored in a shared memory that provides high execution speed as compared to other methods such as methods involving writing to a disk.

A technical advantage of another example is that a process thread of a process may be assigned a buffer entry of a trace buffer in a shared memory while another process thread may be writing to another buffer entry of the trace buffer which may provide for efficient writing of trace messages since one thread does not have to wait while another thread is writing to the trace buffer.

A technical advantage of another example may be that the time order of trace messages is preserved in an efficient manner. Threads of the same process or different processes make requests to record a trace message. These requests are processed according to a time order and each thread is allocated a buffer entry in a common shared memory table according to the time order. Accordingly the time order of the trace messages is preserved.

A technical advantage of another example may be an efficient manner of allocating buffer entries for recording trace messages. Buffers entries are allocated in sequence where one requesting thread has to wait while a buffer entry is being allocated to another thread. Once a buffer entry has been allocated each thread is free to record its message into its allocated buffer entry at its own pace without making other threads wait. Accordingly the embodiment may provide greatly enhanced performance in a multi thread and or multi process system.

A technical advantage of another example may be the use of shared memory for storing information that is shared by multiple threads or processes. The use of the shared memory may enhance the speed of generating trace messages because the threads or processes are not blocked during a disk access. The trace messages included in the shared memory are transferred to non volatile storage such as hard disk periodically by a transfer thread dedicated to performing this task. By organizing the shared memory in a circular fashion the total amount of memory allocated to trace can be kept within bounds. If the shared memory becomes full the trace messages may be simply discarded until there is room in the shared memory again. In an alternative embodiment existing trace messages may be overwritten by new trace messages.

Other technical advantages are readily apparent to one skilled in the art from the following figures descriptions and claims.

Referring to system includes telecommunications devices coupled to media gateways which are coupled to call agent and through a communication network . Call agents and are coupled to an element management system and any number of feature servers . Media gateways call agents and element management system and feature servers may communicate with each other using signaling messages based on any suitable communication protocol for example an Internet Protocol such as Session Initiation Protocol SIP .

Telecommunications devices may include for example any type of phone or any other device suitable for communicating with media gateway such as a computer personal digital assistant or facsimile machine. Telecommunications device may have a terminal identifier that serves to identify telecommunications device . A subscriber may use telecommunications device to access services provided by system . A subscriber may be identified by and associated with a subscriber identifier for example a telephone number or terminal identifier of telecommunications device or other suitable identifier.

Telecommunications device may have a point of presence. A point of presence may comprise a long distance carrier office of a local access and transport area where long distance lines are connected to local lines.

Media gateways provide an interface between telecommunications devices and the rest of system . Media gateways may perform switching services and protocol conversion between telecommunications devices and communication network . Media gateways may include for example a voice over IP gateway a voice over asynchronous transfer mode gateway a modem bank or any other suitable device that provides an interface between telecommunications devices and communication network . Media gateway may comprise for example a CISCO MGX 8260 media gateway.

Communication network may comprise a public switch telephone network a public or private data network the Internet a wired or wireless network a local regional or global communications network other suitable communication links or any combination of the preceding.

Call agent may comprise hardware software or any combination of hardware and software that provides an interface between system and the rest of a telecommunications network. Call agent may manage call signaling conversion between system and the rest of the telecommunications network and may also take part in the switching and routing of calls across the telecommunications network. Call agent may receive signals comprising signaling events comprising a call maintain the state of the call determine detection points of the call process the call in response to the detection points and report the detection points to for example feature server .

In general a call proceeds through various detection points that may be detected by call agent . Call agent may process the call or may report the detection points to other network components that may send instructions to process the call. For example a detection point for a call waiting feature may include a busy detection point which may be reported to feature server in order to trigger the call waiting feature.

A static detection point may routinely be reported to network component and a dynamic detection point may be reported to network component only if network component indicates affirmatively to call agent that network component needs to be informed of that event by subscribing to the detection point. Call agent may comprise for example a CISCO VSC 3000 media gateway controller or a CISCO SC 2200 media gateway controller.

Element management system allows an administrative user to manage system . Element management system may be used to for example configure monitor and operate network components of system . Element management system may comprise for example a CISCO 8100 element management system or a CISCO 6700 element management system. Feature server provides features to subscribers and is described in more detail in connection with .

A shared memory stores representations of calls and instructions for processing calls. A half call model representation is described in connection with . A network component may access shared memory to determine a state of a call and to obtain instructions for processing the call.

An example of system may include a network component that has a platform which is described in connection with . The platform may provide generic operations for any of a number of different network components which may allow for more efficient design and production of network components .

Another example of system may allow processes of a network component to communicate with each other using shared memory which is described in connection with . One process may write data to shared memory and another process may read the data from shared memory which allows for efficient communication between processes.

Another example of system may include redundant network components which are described in connection with . Redundant network components may have any of a number of configurations and may be placed in any of a number of locations which may provide for a flexible redundant system. A redundant network component may use a replication table to track data replicated to a mate network component which may allow for reliable data replication. Redundant network components may be upgraded while one of the network components is processing a stable call which may allow for a faster upgrade of system .

Another example of system may include a trace buffer which is described in of shared memory that records trace messages of the processes of network components . The trace buffer may allow for a more efficient manner of tracking process in system .

Another example of system may include network components that have a signaling adapter interface which is described in connection with . The signaling adapter interface may process messages communicated according to a number of communication protocols which may provide for a flexible system .

Another example of system may include network components that use media gateway adapters which are described in connection with to process messages between call agents and media gateways . Media gateway adapters may use distributed processing which allows for more efficient processor utilization.

Another example of system may include feature servers which are described in connection with . Feature servers may provide Class 5 4 features that typically require a public switch which allows for a more flexible system .

Network component includes one or more processes a shared memory platform and an operating system . Processes may comprise any number of software applications that perform the operations of network component . A process may access a designated process library or a process library for another process . A process library stores software code that may be used to perform the operations. A process may use one or more process threads to provide concurrent processing.

Shared memory may store data utilized by any number of processes and may be used to share information among processes . A source process Pmay communicate with a target process Pby writing data to shared memory . Target process Pmay access shared memory to read the data. Additionally a process thread of process may communicate with another process thread of process by writing data to shared memory . The other process thread may access shared memory to read the data. Communicating data among processes is described in more detail in connection with .

Platform includes a process manager a redundancy manager and a data replicator . Process manager starts monitors and restarts processes and may also create shared memory . Process manager is described in more detail in connection with . Process manager may also transfer trace messages from shared memory to a non volatile storage medium such as a disk file which is described in more detail in connection with .

Redundancy manager monitors network component and a mate network component either of which may be in an active state or a standby state. Redundancy manager manages switching the state of network component . For example redundancy manager may switch network component to an active state if mate network component is faulty. Redundancy manager is described in more detail in connection with . Redundancy manager also manages the operation of data replicator . Data replicator replicates data from an active network component to a standby network component . Data replicator is described in more detail in connection with . Redundancy manager and data replicator may also be used to upgrade software on network components as described in more detail in connection with .

Function libraries may provide common software functionality to processes including process manager . Indexed database library may be used to create shared memory . Inter process communication module may be used to communicate data among processes using shared memory . A generic operating system interface may be used to provide a common interface between processes and libraries of network component and operating system . Operating system may comprise any suitable system such as SUN MICROSYSTEMS OPERATING SYSTEM.

Memory configuration file includes data that is global to processes such as system information process information provisioning data and call related data. Memory configuration file may also store shared memory configuration information. Process management thread may use memory configuration file to configure shared memory .

Threads include timer thread a trace transfer thread a link health monitor thread a thread fault detection thread a network link fault detection thread and a resource fault detection thread . Timer thread stores the current system time in shared memory which is accessible to processes . Trace transfer thread transfers trace messages from shared memory to a non volatile storage medium link health monitor thread monitors the health of communication links thread fault detection thread detects thread faults network link fault detection thread detects network link faults and resource fault detection thread detects resource faults.

If process manager detects a dead process at step the method proceeds to step where process manager determines whether dead process is restartable. If dead process is restartable the method proceeds to step where process manager determines whether a maximum allowable restart rate for dead process has been exceeded. The maximum allowable restart rate which may be stored in platform configuration file may be specified as n m where n is the maximum allowed restarts per m hours. If the maximum has not been exceeded the method proceeds to step where process manager restarts process . The method then returns to step .

If dead process is not restartable at step or if the maximum allowed restart rate has been exceeded at step the method proceeds to step . Network component may be operating in a simplex or duplex mode at step . In duplex mode network component has a mate network component . The mate network component may for example operate in a standby mode while network component operates in an active mode. In simplex mode network component operates without a mate network component .

If network component is operating in a duplex mode at step the method proceeds to step where process manager determines whether to perform a switchover that will allow mate network component to take over the operations of network component . Platform configuration file may store information on whether a switchover is to be performed. If a switchover is not to be performed the method returns to step such that network component continues to operate without the dead process . If a switchover is to be performed the method proceeds to step where process manager performs the switchover to allow mate network component to take over the operations of network component .

If network component is operating in a simplex mode at step the method proceeds to step where process manager determines whether to continue the operations of network component without process or to bring down network component . Platform configuration file may provide information on whether to continue. If the operations of network component are to be continued the method returns to step . If the operations of network component are not to be continued the method proceeds to step . At step platform ends processes of network component . After ending processes the method terminates.

In one example network component may include platform . Platform allows for efficient design and production of network components by providing generic operations for any of a number of different network components . Platform may also access shared memory in order to process calls which provides for efficient call processing. Thus platform may allow for practical production and operation of system that stores representations of calls in shared memory .

Data communication system may comprise a shared memory a heap memory a number of memory queues and an application programming interface API library . Shared memory may be accessed by any number of processes and may be used to communicate data between two different processes . Shared memory may include message buffer pools . A message buffer pool includes message buffers and a free message queue . Message buffer pools may include message buffers of a specific size. For example message buffer pool may include message buffers of one size while message buffer pool may include message buffers of another size.

Message buffers store data that is to be communicated from a source process to a target process . A message buffer may include a header and a data block . Header provides the location of data block which may be used to store data. Free message queue maintains a list of available message buffers and provides a message buffer in response to a request by inter process communication module .

Heap memory includes process heap memories . A process heap memory may be accessible by only a specific process and may be used to communicate data among different process threads of the process . Process heap memory includes message buffers that may store data that is to be communicated from one process thread to another process thread of a process .

Message queues are used to provide data to a target process and may be designated to provide data to a specific process . A message queue may include a shared memory queue and a heap memory queue . Shared memory queue provides data stored in shared memory and heap memory queue provides data stored in heap memory .

API library provides an interface between data communication system and network component to allow platform to manage message buffer pools message buffers and and message queues . For example API library may allow platform to create message buffer pools and initialize message queues .

Shared memory queue includes a number of fields through . A first message field includes a pointer to the first message buffer of shared memory queue . A last message field includes a pointer to the last message buffer of shared memory queue . A message count field includes the total number of message buffers and of shared memory queue . A first heap field indicates whether the first message buffer of the sequence received by message queue is in heap memory queue . In the illustrated example the first message buffer is not in heap memory queue . A last heap field indicates whether the last message buffer of the sequence is in heap memory queue . In the illustrated example the last message buffer is in heap memory queue . Heap queue field includes a pointer to heap memory queue .

Heap memory queue includes a number of fields through . A first message field includes a pointer to the first message buffer of heap memory queue . A last message field includes a pointer to the last message buffer of heap memory queue . A message count field specifies the total number of message buffers and of heap memory queue .

Each message buffer and includes a next heap field and next message field . Next heap field indicates whether the next message buffer is in heap memory queue . In the illustrated example next heap field of message buffer indicates that the next message buffer is in heap memory queue . Next message field includes a pointer to the next message buffer of either shared memory queue or heap memory queue .

In the illustrated example the sequence of message buffers and is and as indicated by the fields of message queue . First heap field indicates that the first message buffer is in shared memory queue . First message field points to message buffer as the first message buffer of shared memory queue . Next heap field of message buffer indicates that the next message buffer is in heap memory queue .

First message buffer points to message buffer as the first message buffer of heap memory queue . Next heap field of message buffer indicates that the next message buffer is in heap memory queue . Next message field points to message buffer as the next message buffer of heap memory queue . Next heap field of message buffer indicates that the next message buffer is in shared memory queue . The next message buffer of shared memory queue is message buffer as indicated by next message buffer of message buffer

Next heap field of message buffer indicates that the next message buffer is in shared memory queue . Next message field points to message buffer as the next message buffer of shared memory queue . Next heap field of message buffer indicates that the next message buffer is in heap memory queue . Message buffer is the next message buffer of heap memory queue as indicated by next message buffer of message buffer . Message buffer is also the last message of heap memory queue as indicated by a last message field and the last message buffer of the sequence as indicated by last heap field of shared memory queue .

The method begins at step where inter process communication module creates message buffers and and message queues . The creation may be initiated by a request from platform . The request may specify the number of message buffer pools to be created and the size of message buffers to be included in message buffer pools . For each message buffer pool one portion may be created to include headers and another portion may be created to include data blocks . A linked list may be created from the message buffers .

At step inter process communication module receives an allocation request from a source process for a message buffer to communicate data to a target process . Message buffer may be in either shared memory or heap memory at step . If target process is different from source process the allocation request may request a message buffer from shared memory which may be accessed by both source process and target process . If target process is the same as source process the allocation request may request a message buffer from a process heap memory that is accessible by only the source target process .

If the request is for message buffer of shared memory the method proceeds to step . The allocation request may include a request for a message buffer of a specific message buffer size. At step inter process communication module selects a message buffer pool that includes message buffers of a sufficient size. If there are no message buffers of a sufficient size the method terminates.

If there is a message buffer of a sufficient size the method proceeds to step where inter process communication module allocates message buffer . To allocate message buffer inter process communication module may retrieve header of message buffer and set a pointer of header to point to data block . A source address of header may be set to the address of source process and data block may be initialized. During allocation free message queue may be locked in order to prevent other processes from accessing free message queue and obtaining message buffer . Data communicated by source process is stored in data block at step .

If at step the allocation requests a message buffer from heap memory the method proceeds to step where inter process communication module allocates a portion of process heap memory for message buffer . Message buffer is initialized and a source address of message buffer may be set to the address of source process . Data communicated by source process is stored in message buffer at step .

At step inter process communication module receives a dispatch request to deliver message buffer or to target process . Inter process communication module may check message buffer or to determine whether message buffer or is included in shared memory or heap memory . The validity and the availability of target process may also be verified.

Message queue associated with target process is retrieved at step . The most recently and the least recently arrived message buffers and of message queue may be retrieved in order to determine the head and tail of message queue . During the dispatch process message queue may be locked. A source address of message buffer or may be set to the address of source process and the destination address may be set to the address of target process .

If message buffer is in shared memory the method proceeds to step where inter process communication module inserts message buffer into shared memory queue . If message buffer is in heap memory inter process communication module inserts message buffer into heap memory queue at step .

At step target process is notified to check message queue associated with target process . Inter process communication module receives a retrieval request from target process at step . Message queue associated with target process is retrieved at step . A signal may indicate whether there is a message buffer or located in message queue .

If message buffer is in shared memory the method proceeds to step where message queue provides header and data block to the target process . Target process may read the data stored in data block . If message buffer is in heap memory the method proceeds to step where inter process communication module provides the header of message buffer to target process . Target process may read the data stored in message buffer .

At step message buffer or is freed to be made available for other processes . If message buffer is in shared memory inter process communication module includes a pointer to message buffer in free message queue to free message buffer . If message buffer is in heap memory process control module deletes data in message buffer to free message buffer . After freeing message buffer or the method terminates.

Processes of network component may communicate with each other using shared memory that stores representations of calls. Shared memory provides for efficient communication between processes by allowing one process to write data to shared memory and another process to read the data from shared memory .

Process communication typically involves copying a message from a source process to a target process. The use of shared memory however does not require copying of a message between two processes. Additionally process communication typically involves using kernel resources such as sockets or pipes. The use of shared memory however does not require kernel involvement. Avoiding copying and kernel involvement may improve the efficiency of process communication. Thus shared memory allows for efficient data communication in system that stores representations of calls in shared memory .

Network components may communicate with each other using any number of communication links comprising any number of communication networks and any number of interfaces . Multiple communication links allows for backup communication links if there is a failure of a communication link . Communication network may comprise for example all or a portion of the Internet and network components may communicate using for example any suitable Internet protocol. Communication network may be logically or physically separated from communication network such that failure of one communication network does not affect the operation of the other communication network .

A communication link may also be provided through a router . If standby network component cannot use communication links to detect whether network component is operating in an active mode standby network component may use communication link to detect the operation of network component

The ability of network components to communicate with each other through communication networks may allow network components to be located in different locations. For example network component may be located in one city and network component may be located in another city. Network components however may also be at the same location.

Mate network components may be located in different component sets . For example call agent is located in component set while its mate call agent is located in component set . Mate network components may be organized in a chain . For example feature server is located in component set while its mate feature server is located in component set . Call agent is located in component set while call agent is located in component set . Finally feature server is located in component set while its mate feature server is located in component set . Any number of component sets and any number of network components may be included in chain .

Organizing mate network components in a chain may allow for continued operation of system even in the event of the failure of a component set . For example if component set fails standby call agent of component set and feature server of component set may continue to operate.

Redundancy manager of local network component monitors the state of a mate network component and may direct the operations of the local network component in response to the state of the mate network component . For example redundancy manager of standby network component may determine that mate network component is no longer operating in an active mode. In response redundancy manager may change the state of network component from a standby mode to an active mode.

Redundancy manager may allow a user to force the states of network components . For example a user may use redundancy manager to force network component to operate in an active mode and network component to operate in a standby mode or vice versa. A user may force both network components to operate in a standby mode.

Redundancy manager may monitor the mate network component through interface and may send an alarm if the communication link through interface has failed. Redundancy manager may also initiate fault isolation procedures if communication with its mate network component is lost. Redundancy manager may manage data replicator which is described in more detail in connection with . Data replicator of a network component sends data to and receives data from mate network component . For example data replicator of active network component may send data to standby network component

The method begins at step where network component is operating in an active mode and mate network component is operating in a standby mode. Data replicator sends replication data to network component . Data replicator stops sending replication data at step and network component enters a transient standby mode.

At step network component sends an acknowledgement to network component . Data replicator stops expecting replication data at step and enters a transient active mode. At step network component enters an active mode and data replicator sends replication data to network component . By entering a transient active mode after network component has entered a transient standby mode network components may avoid a split brain situation with network component where mate network components are simultaneously in active modes.

The method begins at step where redundancy manager of standby network component tests a designated address of network component . Redundancy manager may for example ping the designated address by periodically bouncing a signal off of the designated address. If the test fails for example there is no return signal active network component may be faulty or may be unreachable using the designated address. Other tests may be conducted to determine whether network component is faulty or is merely unreachable using the designated address.

Network component may have a designated alternative address at step . If there is an alternative address the method proceeds to step where the alternative address is tested. If the test fails the method proceeds to step . Network component may have a designated serial port at step . If network component has a designated serial port the method proceeds to step where redundancy manager tests the serial port. If the test fails network component switches from a standby mode to an active mode at step and the method terminates.

If there is no designated alternative address at step or if there is no designated serial port at step the method proceeds to step where redundancy manager tests other available addresses of network component . If the tests fail the method proceeds to step . Network component may be accessible through a router at step . If there is a router the method proceeds to step where redundancy manager tests network component through router . If the test fails the method proceeds to step where network component switches from a standby mode to an active mode. If there is no router at step the method proceeds directly to step where network component switches from standby mode to active mode.

In one example system may include redundant network components . Redundant network components use shared memory to process calls and thus may be arranged in any of a number of configurations in any of a number of locations. Thus redundant network components may provide system with a flexible redundant system .

Data replicator includes modules such as a controller a transaction processor a database downloader an encoder a decoder and libraries . Controller controls the operations of the modules of data replicator in response to instructions from redundancy manager . Transaction processor retrieves data and sends the data to encoder . Database downloader sends all or a portion of a database including for example static and dynamic data to encoder . Database downloader may use a buffer to store data to be sent to encoder

Encoder encodes and sends data to standby network component and may test standby network component by sending test messages to standby network component . Decoder decodes messages received from network component and receives test messages from network component . Library may include application programming interfaces for replicating data. For example library may provide application programming interfaces that gather dynamic data such as call data from stable calls.

Shared memory database includes replication modules such as a call replication module and a data replication module . A replication module may include a buffer such as a first in first out FIFO buffer that stores replication requests and a replication table that tracks the requests stored in the buffer and the data sent to standby network component . For example call replication module includes buffer that stores replication requests for stable call data.

A call replication table tracks the requests stored in buffer and the data sent to network component . Data replication module includes buffer that stores replication requests for provisioning data. A data replication table tracks the requests stored in buffer and data sent to network component . Multiple buffers and may be used in a replication module to reduce competition for buffers and . Although the illustrated replication modules and store update requests for call data and provisioning data respectively replication modules may store update requests for any suitable type of data such as billing data.

Shared memory database also includes libraries and a static database and a dynamic database . Network components such as call agents may store data in databases or using libraries and may insert update requests into buffers and . Static database may store static data such as resource data. Dynamic database may store dynamic data such as call data or feature data.

A database manager DBM library includes application programming interfaces and functions that may be used to upgrade replicated data. Initialization API may be used to gather conversion functions . Conversion functions may be used to convert data from a format associated with one version to a format associated with a different version. Conversion may be performed from an older version format to a newer version format or from a newer version format to an older version format.

Standby network component includes modules substantially similar to the modules of active network component . As standby network component receives data from active network component data replicator stores the data in libraries of shared memory database

If the request is for replication of transaction data at step the method proceeds to step where the data to be replicated may be dynamic or static. If dynamic data is to be replicated at step the method proceeds to step where transaction processor assigns an entry of a replication table to a stable call. For example call replication table is used to track call data and feature data and data replication table is used to track provisioning data. The method then proceeds to step . If static data is to be replicated at step the method proceeds directly to step .

Messages associated with a stable call are stored in buffers at step . The update requests may be received from processes . Replication tables are updated at step . For example call replication table is updated when data is stored in buffers and data replication table is updated when data is stored in buffers . Transaction processor sends messages in buffers to encoder at step and the method proceeds to step .

At step encoder encodes and sends the messages to standby network component via communication links . At step if transaction data was replicated the method proceeds to step . At step the replication table may be updated to show that the data has been sent to standby network component . After updating the replication table the method terminates. At step if a database was replicated the method terminates.

A redundant network component may use a data replicator to replicate data to a mate network component . Data replicator allows for reliable data replication of data stored in shared memory database by using a replication table to track data replicated to a mate network component .

The method begins at step where software and data are installed on a standby network component . For example newer software and data may be installed to replace older software and data. The installed data may include static data tables and dynamic data tables. Data tables are described in more detail in connection with . Standby network component may be taken out of service in order to install the software and then may be brought up in standby mode after installation.

Data replicators exchange version identifiers describing the versions of data located at network components at step . The version identifiers for the data may be distinct from the software version in order to allow for upgrading the software without upgrading the data.

At step data replicator of active network component determines whether the data located at active network component is of a newer version than data located at standby network component . If the versions are different the method proceeds to step where data replicator converts the data to the version of the data located at standby network component . Data replicator may use conversion functions to perform the conversion. The method proceeds to step . At step if the versions are not different the method proceeds directly to step . At step active network component transfers the data to standby network component

At step data replicator of standby network component determines whether the data received from active network component is of an older version than data located at standby network component . If the versions are different the method proceeds to step where data replicator converts the received data to the version of the data located at standby network component . Data replicator may use conversion functions to perform the conversion. At step an audit upgrade is performed. Element management system may perform an audit of network components in order to verify that the data replication is correct. The method proceeds to step . At step if the versions are not different the method proceeds directly to step .

Active network component is switched from an active mode to a standby mode at step . Standby network component is switched from a standby mode to an active mode at step . The switching may be performed according to the method described in connection with . At step the upgrade may be cancelled. If the upgrade is cancelled the method returns to step where network components exchange version identifiers.

At steps through during the second iteration the active network component comprises network component and the standby network component comprises network component . Data originally on network component is replicated on network components . If the upgrade is continued the method proceeds to step where the software is installed on standby network component . After switching network component to an active mode the method terminates.

The method may be used to upgrade software on redundant network components while processing stable calls. By maintaining representations of calls in shared memory stable calls may be processed while the software is upgraded. As a result system allows for a faster and more secure upgrade of redundant network components .

Process manager includes a trace module which manages the processing of trace messages. Shared memory include traces interfaces a trace buffer and a trace file . Process threads may use trace interfaces to process trace messages. Trace message interface may be used by process threads to generate trace messages. Initialization control interface may be used to initialize and control data relating to trace messages such as data included in trace buffer . Trace buffer stores trace messages received from process threads in a trace message field . The trace messages may be stored in the order received from process threads . Trace file may be used to store trace messages transferred from trace buffer . Trace file may organize trace messages according to process .

A description may be added to a trace message. Description may include for example any number of fields. An importance level field describes the level of importance of the trace message. A topic field identifies one or more topics associated with the trace message. One or more topics and or importance levels may be selected to be recorded by trace message system . A process identifier identifies process and a thread identifier identifies process thread . A timestamp records the time the trace message is entered in trace buffer . A source code identifier identifies the source code file and line number of the trace message. A flag may be used to indicate that a buffer entry for a trace message has been assigned to a process thread .

The method begins at step where trace messages are generated by process threads . Process threads may use trace message interface to generate the trace messages. At step trace module receives a request for a buffer entry of trace buffer of shared memory from a process thread . The use of shared memory may enhance the speed of generating trace messages because process threads are not blocked during a disk access. The requests are received in a time order and each process thread is allocated a buffer entry in the time order.

Trace module assigns an available buffer entry of trace buffer at step . Trace module may track the last assigned buffer entry of trace buffer and may assign the next buffer entry of trace buffer as the next available buffer entry. The buffer entry may be assigned by marking flag of the buffer entry with a process thread identifier.

In order to prevent assigning a buffer entry to more than one process thread a process thread may be required to lock a mutual exclusion object in order to be assigned a buffer entry. A mutual exclusion object comprises a program object that allows multiple process threads to share trace buffer but not simultaneously. Process thread that requests a buffer entry locks the mutual exclusion object from other process threads while the buffer entry is being assigned. Once a buffer entry has been allocated each process thread is free to record its message its own pace without making other threads wait. After the buffer entry is assigned the method proceeds to step .

At step trace module determines whether there is a next buffer entry request. If there is a next buffer entry request the method returns to step where trace module assigns the next available buffer entry to the next buffer entry request. If there is no next buffer entry request the method terminates.

Step may be performed before simultaneous with or after step . For example a buffer entry may be assigned to a trace message while another trace message is being entered into trace buffer .

Trace module determines the importance level of the trace message at step . Importance levels may be selected such that trace messages of the selected importance levels are recorded. If the importance level is a selected importance level at step the method proceeds to step where the trace message is recorded in trace buffer . If the importance level is not a selected importance level the method proceeds to step where trace module determines the topic or topics of the trace message. Certain topics may be selected such that trace messages of the selected topics are recorded. If any of the topics are selected topics at step the method proceeds to step where the trace messages are recorded in trace buffer . If none of the topics are selected topics the method terminates.

At step process thread writes the trace message to the assigned buffer entry of trace buffer . At step trace module copies the trace message from trace buffer to trace file . The trace messages of trace file may be organized according to the process that generated the trace messages. By organizing shared memory in a circular fashion the total amount of memory allocated to trace messages can be kept within bounds. If shared memory becomes full the trace messages may be simply discarded until there is room in shared memory . In an alternative example existing trace messages may be overwritten. After the trace message is copied the method terminates.

Trace messages record the processing of a call in shared memory . The method allows for a process thread to be assigned a buffer entry of trace buffer while another process thread may be writing to another buffer entry of trace buffer . As a result the method may provide for more efficient recording of trace messages.

A technical advantage of one example is that trace functions may be provided for a multiple process or multiple thread system for example a telecommunication network where the processes may be single threaded or multi threaded. The example may provide a centralized time ordered trace module where trace messages output by the multiple threads of multiple processes may be collected together and placed in time sequence with minimal performance impact.

A technical advantage of another example may be that the time order of trace messages is preserved in an efficient manner. Threads of the same process or different processes make requests to record a trace message. These requests are processed in a time order and each thread is allocated a buffer entry in a common shared memory table in the time order. Accordingly the time order of the trace messages is preserved.

A technical advantage of another example may be an efficient manner of allocating buffer entries for recording trace messages. Buffer entries are allocated in sequence where one requesting thread has to wait while an buffer entry is being allocated to another thread. Once a buffer entry has been allocated each thread is free to record its message into the buffer entry at its own pace without making other threads wait. Accordingly the example may provide greatly enhanced performance in a multi thread and or multi process system.

A technical advantage of another example may be the use of shared memory for storing information that is shared by multiple threads or processes. The use of the shared memory may enhance the speed of generating trace messages because the threads or processes are not blocked during a disk access. The trace messages included in the shared memory are transferred to non volatile storage such as hard disk periodically by a transfer thread dedicated to performing this task. By organizing the shared memory in a circular fashion the total amount of memory allocated to trace can be kept within bounds. If the shared memory becomes full the trace messages may be simply discarded until there is room in the shared memory. In an alternative example existing trace messages may be overwritten.

Multiple communication protocol system includes any number of protocol based networks protocol stacks signaling adapters a signaling adapter interface and call agent . Protocol based networks may include devices and communication links operating according to any of a number of communication protocols. One protocol based network may operate according to one communication protocol and another protocol based network may operate according to another communication protocol. Protocol stack receives and processes messages based on a specific communication protocol. Protocol stack is described in more detail in connection with . Signaling adapter converts messages based on a specific protocol to a generic protocol and is described in more detail in connection with . Signaling adapter interface receives the messages based on a generic format and sends the messages to call agent . Signaling adapter interface may route the messages from specific signaling adapters to specific modules of call agent .

Call agent includes modules such as a basic control module a connection manager a maintenance manager and a registration admission module . Basic control module establishes monitors and clears calls. Basic control module may include a basic call state machine that responds to messages describing events occurring in protocol based networks . Connection manager dynamically creates and destroys a bearer path of a packet network. Connection manager may be required to receive messages from protocol based networks that use bearer paths. Maintenance manager provisions configures and provides fault management for signaling adapters and protocol stacks . Registration admission module registers addresses for processed calls.

Protocol stack includes several layers. A message transfer part MTP layer provides functions for basic routing of signaling messages for monitoring and controlling traffic within protocol based network . An integrated services digital network user part ISUP layer provides functions for setting up coordinating and taking down calls. ISUP layer may include for example functions for initializing the ISUP protocol registering with ISUP layer sending ISUP messages to protocol based network providing events from protocol based network providing ISUP configuration and signaling communication link failures.

A signaling connection control part SCCP layer provides routing and management functions for transferring messages. A transaction capabilities application part TCAP layer provides signaling functions for network databases. TCAP layer may provide functions for accessing advanced intelligent network AIN features provided by protocol based network .

Signaling adapter includes adapters such as call control message adapter and maintenance message adapter that convert messages based on a specific communications protocol to a generic protocol. The conversion may involve converting a message to a generic primitive. An adapter may convert messages for a specific module of call agent . Call control message adapter may convert messages for basic control module . The messages may be related to call establishment such as an initial address message call session such as a call progress message and call teardown such as a release message.

Maintenance message adapter may convert messages for maintenance manager of call agent . The messages may relate to bearer circuit validation such as a continuity check message bearer circuit reservation and status such as a circuit reserve message and bearer circuit maintenance such as a circuit circuit group block message. Adapters and may use a table for converting the messages to a generic format. Table may include entries that associate a message with a generic primitive of the generic format.

The messages are sent to modules and of call agent at step . Call control message adapter sends messages to basic control module and maintenance message adapter sends messages to maintenance manager . After sending the messages to call agent the method terminates.

A signaling adapter translates messages communicated according to any of a number of communication protocols to a generic protocol so that the messages may be processed by signaling adapter interface . Messages communicated according to a new communication protocol may be processed by adding a signaling adapter associated with the new communication protocol. Thus multiple communication protocol system may provide for a flexible mechanism for processing messages communicated according to a number of communication protocols.

An additional communication protocol control stack thread for performing other types of protocol processing may be added to thread pair . For example a communication protocol control stack thread may be added to perform MEGACO protocol processing. MCS thread determines the type of communication protocol of a message and routes the message to communication protocol control stack thread according to the type.

An MGA router receives a request for a thread pair and assigns a thread pair in response to the request. The request may be received from media gateway through a thread pair or from basic call module . MGA router may allocate a thread pair for an entire media gateway or for a specific termination depending upon the configuration of media gateway adapter and the message.

MGA router may allocate thread pair based on a processor utilization algorithm. MGA router may determine the relative processor utilization of each thread pair and assign the thread pair for which the relative process utilization is the lowest. The assigned thread pair may differ from the thread pair that received the request from media gateway . For example the thread pair that receives the request may be over utilized so MGA router may assign an underutilized thread pair . Accordingly media gateway adapter may allow for more efficient processor utilization.

BCM router allocates BCM threads for messages to be sent to basic call module . BCM router may allocate BCM threads based upon BCM thread load.

Media gateway sends a message which is received at MCS thread at step . MCS thread forwards the message to MGA thread . MCS thread may determine a communications protocol associated with the message and forward the message to an MGA thread corresponding to the communications protocol. MGA thread processes the message at step . BCM router is notified of the message at step . In response BCM router allocates a BCM thread to the message at step . MGA router sends the message to the assigned BCM thread at step . At step BCM thread sends the message to basic call module . After sending the message the method terminates.

Media gateway adapter may be used to communicate messages from media gateway to call agent . Media gateway adapter allows for more efficient processor utilization by using distributed processing.

A subscriber may subscribe to features of a telecommunications network such as call waiting or three way calling. Some subscribers may subscribe to a feature set including some features for example call waiting and three way calling while other subscribers may subscribe to a feature set including other features for example call waiting and selective call acceptance. Additionally feature server may provide subscribers of different points of presence with different feature sets. System provides the appropriate feature set selected by the subscribers.

Features may include Class 5 features that may typically be provided by a Class 5 office. Features may include a call waiting feature which provides a mechanism to notify a subscriber engaged in a first call of a second call and to allow the subscriber to receive the second call. A three way calling feature allows a subscriber engaged in a call with a second party to include a third party in the call and have a three party conference call. Additionally a selective call acceptance feature permits incoming calls only from telephone numbers predetermined by a subscriber. A selective call rejection feature blocks incoming calls from telephone numbers predetermined by a subscriber.

A feature may include providing a seven 7 digit map for collecting a seven digit telephone number from a subscriber making a local call. Different Class 5 features may be provided to different subscribers. For example a seven 7 digit map may be provided to a subscriber in a point of presence that uses seven 7 digit telephone numbers for local calls and a ten 10 digit map may be provided to a subscriber in a point of presence that uses ten 10 digit telephone numbers for local calls. Thus system provides a wide variety of features to a subscriber in a telecommunications network.

Feature server includes service logic programs coupled to a feature interaction mechanism which is in turn coupled to a database table and a communications stack . A service logic program provides instructions for a specific feature set or service. Feature sets or services may be identified by service identifiers. For example service logic program may provide instructions for call waiting three way calling and call transfer while service logic program may provide instructions for distinctive ringing and selective call rejection. A subscriber may subscribe to a feature set provided by a feature server . For example one subscriber may subscribe to a feature set provided by feature server and another subscriber may subscribe to a feature set provided by feature server

Feature interaction mechanism manages the process of providing features. Feature interaction mechanism identifies a subscriber making a call determines a feature set associated with the subscriber accesses a service logic program corresponding to a feature of the feature set and processes the call according to instructions provided by service logic program or database table . Feature interaction mechanism may access database table in order to determine the feature set associated with the subscriber. Database table may comprise a table of subscriber identifiers their associated feature sets identified by service identifiers and associated detection points. A database manager DBM may be used by feature interaction mechanism to access information from database table .

Communications stack translates communication protocol. For example communications stack may translate for example Session Initiation Protocol SIP Internet Protocol IP and Transmission Control Protocol Internet Protocol TCP IP .

Feature server allows a subscriber to subscribe to a particular feature set and then provides the feature set to the subscriber without any action from a switch of a PSTN. Thus system allows for a service provider to efficiently provide feature sets to subscribers.

Call segments represent communication paths between telecommunications devices. Each call segment includes a control leg and a passive leg . Each as used in this document means each member of a set or each member of a subset of the set. Control leg represents a communication path to telecommunications device. Passive leg represents a communication path from the control leg to other telecommunications devices. Basic call state machine detects the state of a call and may transmit the state information to feature server . Call segment association defines associations between call segments .

As illustrated in call segments and call segment associations and and basic call state machines and are created for telecommunications devices A and B respectively in response to the states of call objects and . Call segments and represent a communication path for a call between telecommunications devices A and B. Call segments and call segment associations and and basic call state machines and are generated for a call initiated by telecommunications device C to telecommunications device B.

Feature server provides a call waiting feature that notifies telecommunications device B which is engaged in a call with telecommunications device A of the call initiated by telecommunications device C. Telecommunications device B may select to accept the call from telecommunications device C. As illustrated in telecommunications device B has accepted the call from telecommunications device C. Call segments and represent a communication path for the call between telecommunications devices C and B.

The method begins at step . Steps through describe processing a call from telecommunications device A to telecommunications device B. At step call agent detects an origination attempt from telecommunications device A. The origination attempt may result from inputting a telephone number of telecommunications device B into telecommunications device A. Call agent creates originating call objects at step . Originating call objects include call segment call segment association and basic call state machine . Call agent creates terminating call objects at step . Terminating call objects include call segment call segment association and basic call state machine

At step call agent alerts telecommunications device B of the call from telecommunications device A. Call agent may alert telecommunications device B by sending a message to telecommunications device B that causes telecommunications device B to ring. B answers the call at step . The state of the call is active at step .

Steps through describe telecommunications device C calling telecommunications device B. At step call agent detects an origination attempt by telecommunications device C. Call agent creates originating call objects at step . Originating call objects include call segment call segment association and basic call state machine . Call agent creates terminating call objects at step . Terminating call objects include call segment call segment association and basic call state machine

Call agent detects that telecommunications device B is busy at step . Call agent selects a feature server at step using a user table. Call agent may select feature server according to a type of call waiting feature to which telecommunications device B subscribes. Alternatively call agent may select feature server according to a load balancing protocol to distribute calls among multiple feature servers . At step call agent notifies the selected feature server that telecommunications device B is busy and is using call segment association

At step feature server determines a feature appropriate for telecommunications device B with a detection point of busy. Feature server may use database table in order to determine a feature to which telecommunications device B subscribes. Feature server may also determine whether telecommunications device B may accept a feature. For example telecommunications device B may already be engaged in a call waiting process and is not able to accept a call from telecommunications device C. Telecommunications device B may also be prohibited from receiving a call waiting feature because for example a subscription fee for a call waiting feature has not been paid.

At step feature server determines whether call waiting is an appropriate feature. If call waiting is not an appropriate feature the method proceeds to step where another feature is provided or the call is continued with default processing. After step the method terminates. If call waiting is an appropriate feature the method proceeds to step .

At step feature server subscribes to dynamic detection points in order to be notified when call agent detects a subscribed detection point. Detection points may include for example a hookflash a disconnect an abandoned or an exception detection point. A hookflash detection point may occur when a hook switch of telecommunications device B is momentarily depressed. A disconnect detection point occurs when either telecommunications device A or B terminates the call. An abandoned detection point may occur when telecommunication device C terminates the call. An exception detection point occurs when for example there is a failure in the processing of the call such as a failure of a communication path.

At step feature server commands call agent to move terminating call segment generated for telecommunications device C from call segment association to call segment association generated for telecommunications device B. At step feature server sends a present call command to call agent . In response call agent creates a communication path between telecommunication devices B and C. Path creation is successful if telecommunications device B accepts the call. Feature server may perform steps through by sending one or more messages to call agent .

At step feature server commands call agent to play a tone to telecommunications device B to alert telecommunications device B of the call initiated by telecommunications device C. At step call agent determines whether a hookflash detection point is detected. If a hookflash detection point is not detected the method proceeds to step where the call between telecommunications device A and B is continued and monitored for a hookflash detection point. If a hookflash detection point is detected the method moves to step .

At step call agent reports the hookflash detection point to feature server . Call agent reports that a hookflash detection point has occurred at call segment . Feature server resubscribes to the dynamic detection points at step . At step feature server commands call agent to move control from call segment to call segment . When control is moved the state of call segment is an inactive state and the state of call segment is an active state.

Feature server sends an active command to call agent at step . At step the call between telecommunications devices B and C becomes active as call agent updates the call. At step call agent monitors the call to determine if the call between telecommunications devices B and C is released at step . If the call is released the method terminates. If the call is not released the method returns to step to determine whether a hookflash detection point has been detected.

The method begins at step . Steps through describe processing a call from telecommunications device A to telecommunications device B. Steps through may occur in a manner substantially similar to steps through as described with reference to .

At step call agent detects a hookflash from telecommunications device A or telecommunications device B. The telecommunications device that initiates the hookflash may be referred to as a controller . Steps through describe call agent selecting and notifying feature server of the hookflash and feature server determining a feature. Steps through may be performed in a manner substantially similar to steps through of .

Feature server determines whether the hookflash corresponds to a three way call at step . If the hookflash does not correspond to a three way call the method proceeds to step where another feature is selected or the call is continued according to a default processing and the method is terminated. If the feature is a three way call the method proceeds to step where feature server subscribes to dynamic detection points in order to be notified when call agent detects a subscribed detection point.

Feature server sends a split leg command to call agent at step . Call agent creates originating objects and breaks the voice path between telecommunications device A and telecommunications device B at step . Feature server sends a collect information command at step . In response call agent sends a dial tone to the controller at step .

At step call agent receives digits representing a telephone number for third party telecommunications device C from the controller before a timer expires. At step call agent reports the digits to feature server . Feature server sends a continue command at step . In response call agent creates terminating objects at step . Call agent alerts third party telecommunications device C of the call at step .

At step call agent receives a hookflash from the controller. At step call agent reports the hookflash to feature server . In response feature server sends a merge command to call agent at step . Call agent creates a three way call between telecommunications devices A B and C at step .

Call agent determines whether there is a hookflash or hang up from controller at step . If there is a hookflash call agent reports the hookflash to feature server at step . Feature server sends a disconnect command to disconnect telecommunications device C from the three way call at step . In response call agent disconnects telecommunications device C at step . After disconnecting telecommunications device C the method is terminated.

If a hang up is detected at step the method proceeds to step where call agent reports the hang up to feature server . In response feature server sends a release command to release the three way call at step . In response call agent releases the three way call at step . After releasing the call the method is terminated.

The method begins at step . Steps through describe processing a call from telecommunications device A to telecommunications device B and may be performed in a manner substantially similar to steps through of . At step call agent detects a termination attempt on telecommunications device B. Steps through describe determining whether selective call acceptance is an appropriate feature and may be performed in a manner substantially similar to steps through of .

Feature server determines whether selective call acceptance is an appropriate feature at step . If selective call acceptance is not an appropriate feature the method proceeds to step where another feature is selected or that call is continued with default call processing. The method is then terminated. If selective call acceptance is an appropriate feature the method proceeds to step where feature server subscribes to dynamic detection points.

At step feature server determines whether a telephone number associated with telecommunications device A is included in the selective call acceptance list associated with telecommunications device B. If the number is not included the method proceeds to step where feature server sends a furnish charge information command. At step feature server sends a disconnect command to call agent to disconnect the call with telecommunications device A. In response call agent disconnects the call at step . After disconnecting the call the method is terminated.

If the number is included in the selective call acceptance list at step the method proceeds to step where feature server sends a continue command to call agent to continue the call between telecommunications device A and telecommunications device B. In response call agent continues the call at step . After continuing the call the method is terminated.

The method begins at step . Steps through describe processing a call from telecommunications device A to telecommunications device B and may be performed in a manner substantially similar to steps through of . At step call agent detects a termination attempt on telecommunications device B. Steps through describe determining whether selective call rejection is an appropriate feature and may be performed in a manner substantially similar to steps through of .

Feature server determines whether selective call rejection is an appropriate feature at step . If selective call rejection is not an appropriate feature the method proceeds to step where another feature is selected or that call is continued with default call processing. The method is then terminated. If selective call rejection is an appropriate feature the method proceeds to step where feature server subscribes to dynamic detection points.

At step feature server determines whether a telephone number associated with telecommunications device A is included in the selective call rejection list associated with telecommunications device B. If the number is included the method proceeds to step where feature server sends a furnish charge information command. At step feature server sends a disconnect command to call agent to disconnect the call with telecommunications device A. In response call agent disconnects the call at step . After disconnecting the call the method is terminated.

If the number is not included in the selective call rejection list at step the method proceeds to step where feature server sends a continue command to call agent to continue the call between telecommunications device A and telecommunications device B. In response call agent continues the call at step . After continuing the call the method is terminated.

Feature servers may provide different feature sets to different subscribers. Feature servers may also provide Class 5 features that typically require a public switch. Thus features servers may allow for a more flexible system .

A technical advantage of one example of the present invention may is that calls are represented in a database such as a shared memory using for example a half call model representation. A network component may process a call by accessing the database to determine a state of the call and to retrieve instructions for processing the call which may allow for efficient call processing. Changes to call processing may be made by changing the instructions in the database which allows for flexible call processing.

Although the present invention has been described with several embodiments a myriad of changes variations alterations transformations and modifications may be suggested to one skilled in the art and it is intended that the present invention encompass such changes variations alterations transformations and modifications as fall within the scope of the appended claims.

