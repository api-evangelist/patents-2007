---

title: System and method for efficient storage of long-lived session state in a SIP server
abstract: A SIP server can be deployed in a two-tier architecture, including an engine tier for processing of SIP communications and a state tier for maintaining the state associated with these communications. The state tier can include RAM-based replicas that provide data to the engines. Some of the SIP session state can be moved to the database in order to reduce the memory requirements of the state tier. Upon determining that a transaction boundary has been reached where the session state is steady, the state replica can save the data to the database. A hint can be received from the engine tier by the state replica indicating that the state data is ready to be saved. Subsequently, the data can be removed from the state tier by nulling out the bytes of actual data, while preserving the primary key, locking and timer information so as not to impact latency.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08078737&OS=08078737&RS=08078737
owner: Oracle International Corporation
number: 08078737
owner_city: Redwood Shores
owner_country: US
publication_date: 20071213
---
The present application claims the benefit of U.S. Provisional Patent Application No. 60 869 873 entitled SYSTEM AND METHOD FOR EFFICIENT STORAGE OF A LONG LIVED SESSION STATE IN A SIP SERVER by Ioannis Cosmadopoulos et al. filed on Dec. 13 2006 which is incorporated herein by reference in its entirety.

The following commonly owned co pending United States Patents and Patent Applications including the present application are related to each other. Each of the other patents applications are incorporated by reference herein in their entirety 

U.S. Provisional Patent Application No. 60 869 871 entitled SYSTEM AND METHOD FOR PROTECTING AGAINST FAILURE THROUGH GEO REDUNDANCY IN A SIP SERVER by Ioannis Cosmadopoulos et al. filed on Dec. 13 2006 

U.S. application Ser. No. 11 956 094 entitled SYSTEM AND METHOD FOR PROTECTING AGAINST FAILURE THROUGH GEO REDUNDANCY IN A SIP SERVER by Ioannis Cosmadopoulos et al. filed on Dec. 13 2007 

U.S. patent application Ser. No. 11 545 648 entitled SIP SERVER ARCHITECTURE FAULT TOLERANCE AND FAILOVER by Anno R. Langen et al. filed on Oct. 10 2006.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The current invention relates generally to managing communications and more particularly to handling the storage of session state in a telecommunications network environment.

Conventionally telecommunications and network infrastructure providers have relied on often decades old switching technology to providing routing for network traffic. Businesses and consumers however are driving industry transformation by demanding new converged voice data and video services. The ability to meet these demands often can be limited by existing IT and network infrastructures that are closed proprietary and too rigid to support these next generation services. As a result telecommunications companies are transitioning from traditional circuit switched Public Switched Telephone Networks PSTN the common wired telephone system used around the world to connect any one telephone to another telephone to Voice Over Internet Protocol VOIP networks. VoIP technologies enable voice communication over vanilla IP networks such as the public Internet. Additionally a steady decline in voice revenues has resulted in heightened competitive pressures as carriers vie to grow data service revenues and reduce churn through the delivery of these more sophisticated data services. Increased federal regulation security and privacy issues as well as newly emerging standards can further compound the pressure.

However delivering these more sophisticated data services has proved to be more difficult than first imagined. Existing IT and network infrastructures closed proprietary network based switching fabrics and the like have proved to be too complex and too rigid to allow the creation and deployment of new service offerings. Furthermore latency has been an important issue in addressing the processing of telecommunications as more and more users expect seemingly instantaneous access from their devices.

The storage of session state associated with various telecommunications has become an important issue in this environment. Many types of telecommunication applications require very fast access to the data such as random access memory RAM based access while others can tolerate slower disk based speeds. At the same time RAM is typically significantly more expensive to maintain for an organization that manages thousands hundreds of thousands or even millions of telecommunications daily. What is needed is a way to efficiently store the session state data of these telecommunications such that various providers are able to provide low latency services and at the same time saving costs associated with fast memory access storage.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. References to embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

In the following description numerous specific details are set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail so as not to obscure the invention.

Although a diagram may depict components as logically separate such depiction is merely for illustrative purposes. It can be apparent to those skilled in the art that the components portrayed can be combined or divided into separate software firmware and or hardware components. For example one or more of the embodiments described herein can be implemented in a network accessible device or appliance. Furthermore it can also be apparent to those skilled in the art that such components regardless of how they are combined or divided can execute on the same computing device or can be distributed among different computing devices connected by one or more networks or other suitable communication means.

In accordance with embodiments there are provided systems and methods for efficient storage of long lived session state in a session initiation protocol SIP server. In various embodiments a SIP server can be deployed in a two tier architecture including an engine tier for high throughput processing of various SIP communications and a state tier for maintaining the session state associated with these communications. The state tier can be composed of a set of partitions having random access memory RAM based replicas that can respond to queries for data from the engine tier. In some embodiments at least some of the SIP session state that is long lived can be moved to the database in order to reduce the expensive memory requirements of the state tier. For example upon determining that a transaction boundary has been reached where the session state is steady the state replica can replicate at least some of the data to the database. Determining that a transaction boundary has been reached can include receiving a hint from the engine tier by the state replica that the state data is ready to be saved to the database. Subsequently the state data can be removed from the state tier. Removing the state data can include nulling out the byte representation of the actual data while preserving the primary key locking and timer information associated with the session state so as not to impact latency requirements of the SIP server.

In the embodiment illustrated the SIP Server is a carrier class Java Enterprise Edition J2EE application server that has been extended with support for the Session Initiation Protocol SIP and other operational enhancements that allow it to meet the demanding requirements of next generation internet protocol IP based communications networks. The SIP Server can be used to create deploy and manage various real time communications services and applications by telecom operators who wish to provide mobile and fixed multimedia services. As with any Java application server the SIP server can take advantage of the J2EE Platform Kernel and Services in order to compile execute and optimize the performance of various programs and applications. In one embodiment the SIP server is also extended with support for a multitude of standards and protocols such as SIP Diameter Hyper Text Transfer Protocol HTTP Lightweight Directory Access Protocol LDAP Simple Network Management Protocol SNMP Simple Object Access Protocol SOAP Java Database Connectivity JDBC and others.

As stated previously the SIP Server is enabled to support session initiation protocol SIP . SIP is a protocol used primarily for creating and terminating sessions with one or more participants such as setting up or tearing down voice or video calls. SIP is described in more detail in RFC 3261 of the IETF SIP Working Group which is incorporated herein by reference.

The SIP protocol specification defines different types of high level SIP roles namely user agents UA which include UA clients UA servers and Back to Back user agents B2BUA . The SIP protocol also defines the roles of Proxies Registrars and Redirect Servers. Accordingly the SIP Servlet API of the SIP server allows any of these roles to be coded as a SIP Servlet Application. Furthermore because SIP is an extensible protocol the API is also designed to allow developers to easily extend functionality. This can be accomplished by dividing up the SIP processing between the container functions and the applications. Most of the base protocol can be performed by the container leaving the higher level tasks for the applications to perform. This division of processing can lead to a great amount of flexibility to the SIP Servlet API.

As further illustrated in the SIP Server can include an Enterprise Java Bean EJB container an HTTP Servlet container and a SIP Servlet container . Each of these containers can provide an environment that supports the execution of applications developed using its corresponding technology. For example the EJB container manages enterprise beans contained within it which in turn provide the business logic for a J2EE application. This management can encompass services such as registering creating and destroying objects and their instances providing remote interfaces to objects managing the state of objects maintaining security and coordinating distributed transactions. Similarly the HTTP container and the SIP Servlet container can be responsible for managing HTTP and SIP servlets respectively.

The SIP stack of the SIP Server can be fully integrated into the SIP Servlet container and is more powerful and easier to use than a traditional protocol stack. For example the higher level abstraction of the SIP Servlet API can free the developer from the mechanics of handling of transaction timers syntactic evaluation of received requests generation of non application related responses generation of fully formed SIP requests from request objects which may involve correct preparation of system headers and generation of syntactically correct SIP messages and handling of lower layer transport protocols such as Transport Control Protocol TCP User Datagram Protocol UDP and Stream Control Transmission Protocol SCTP .

In one embodiment the Servlet container can provide a Shared Session Context and session application programming interface API in order to maintain awareness of the state of the larger converged SIP and HTTP application session. There are many use cases where a converged application using both SIP and HTTP functions is desirable. Some examples of these applications include conferencing and click to call applications as well as Presence and User Agent Configuration Management applications. The converged applications can also use other protocols e.g. Diameter to perform more advanced functions such as modifying subscriber profile data. Furthermore the container can provider a whole host of other services including distributing request and response objects to components in a structured way as well as managing the end to end object lifecycle including resource transaction and session state management.

In the embodiment illustrated the SIP server along with the various applications hosted thereon e.g. and can be used as a back to back user agent B2BUA in a typical telecommunications environment. A B2BUA can take the place of an intermediary between communications by user agents which may include various cellular phones wireless devices laptops computers applications and other components capable of communicating with one another electronically. The B2BUA can provide multiple advantages such as controlling the flow of communication between user agents enabling different types of user agents to communicate with one another e.g. a web application can communicate with a cellular phone as well as various security advantages. As one illustration the user agents can transmit to the SIP server instead of communicating directly to each other and thus malicious users can be prevented from sending spam and viruses hacking into other user agent devices and otherwise compromising security. It should be noted that the SIP Server need not necessarily take the role of a B2BUA as illustrated in but can also be used as a proxy a redirect server or some other role defined by the SIP protocol.

As illustrated various messages such as phone call requests or other transfers of data associated with the SIP protocol can come into the cluster from the internet such as over VOIP phone or some other type of outside network . This message can be received and handled by a load balancer which can be responsible distributing message traffic across the engines i.e. engine engine engine and engine in the cluster which handle the processing of the message traffic. The load balancer can be a standard load balancing appliance hardware device and it is not necessary that it be SIP aware there is no requirement that the load balancer support affinity between the engines and SIP dialogs or transactions. Alternatively the load balancer can be implemented as software that distributes the messages to the various engines. In the various embodiments the primary goal of the load balancer can be to provide a single public address that distributes incoming SIP requests to available servers in the SIP server engine tier cluster . Such distribution of requests can ensure that the SIP server engines are fully utilized. The load balancer can also be used for performing maintenance activities such as upgrading individual servers or applications without disrupting existing SIP clients.

In the embodiment illustrated the SIP server can provide a two tier cluster architecture model to handle the incoming messages. In this model a stateless engine tier cluster can process all signaling traffic and can also replicate transaction and session state to the state tier cluster which in turn can be divided into multiple partitions. Each partition can consist of any number of nodes replicas distributed across any number of hosts such as host and host which can be implemented as computers linked in a cluster type network environment. For example partition can include state replica and a state replica which can maintain copies of the call state information of the partition. The state tier cluster can be an n way peer replicated Random Access Memory RAM store that maintains various data objects which can be accessed by the engine nodes in the engine tier. In this manner engines can be provided a dual advantage of faster access to the data objects than retrieving data from a database while at the same time engines can be freed up from having to store the data onto the engine tier itself. This type of separation can offer various performance improvements. The state tier can also function as a lock manager where call state access follows a simple library book model i.e. a call state can be checked out by one SIP engine at a time .

On the other hand the engine tier cluster can be implemented as a cluster of SIP server instances that hosts the SIP servlets which provide various features to SIP clients. In one embodiment the engine tier is stateless meaning that the SIP session state information is not persisted in the engine tier but is obtained by querying the state tier cluster which can in turn provide replication and failover services for SIP session data.

In one embodiment the engine nodes write state data to all the replicas of the appropriate partition so that failover can be provided between the replicas in the event that one should crash or fail. However when retrieving state data from the partition the engine does not require all of the replicas to transmit the data. Thus in order to minimize the traffic and network load each partition can designate a primary replica in charge of responding to the engine queries with the appropriate data. This primary replica can be selected in a variety of ways. For example the first replica to boot up in a partition can be designated the primary replica and this will be designated as the replica that is in charge of returning data to the requesting engine. If multiple replicas boot up at the same time there can be a handshaking process during which the replicas themselves determine which one of them will be designated as the primary. Other algorithms can also be used to determine the primary replica and the invention is not intended to be limited to any one particular algorithm.

The primary overall goal of the engine tier can be to provide maximum throughput combined with low response time to SIP clients. As the number of calls or their duration increases more server instances can be added to the engine tier to manage the additional load. It should be noted however that although the engine tier may include many such server instances it can be managed as a single logical entity. For example the SIP servlets can be deployed uniformly to all server instances by targeting the cluster itself and the load balancer need not maintain affinity between SIP clients and individual servers in the engine tier.

In various embodiments the state tier cluster can be implemented as a cluster of SIP server instances that provides a high performance highly available in memory store for maintaining and retrieving session state data for SIP servlets. This session data may be required by SIP applications in the SIP server engine tier in order to process incoming messages. Within the state tier session data can be managed in one or more partitions e.g. partition and partition where each partition manages a fixed portion of the concurrent call state. For example in a system that uses two partitions the first partition could manage one half of the concurrent call state e.g. A M and the second partition can manage the other half e.g. N Z . With three partitions not shown each can manage a third of the call state and so on. Additional partitions can be added as needed to manage large number of concurrent calls or incoming messages.

In one embodiment within each partition multiple state servers can be added to provide redundancy and failover should the other servers in the partition fail. When multiple servers participate in the same partition those servers can be referred to as replicas because each server maintains a duplicate copy of the partition s call state. For example partition can maintain its state information in replica and replica . In some embodiments the replicas can be distributed over multiple hosts e.g. host and host in order to provide host to host failover services in cases where a computer crashes. Furthermore to increase the capacity of the state tier the data can be split evenly across a set of partitions as previously discussed. The number of replicas in the partition can be called the replication factor since it determines the level of redundancy and strength of failover that it provides. For example if one node goes down or becomes disconnected from the network any available replica can automatically provide call state data to the engine tier.

Replicas can join and leave the associated partition and each replica can serve as exactly one partition at a time. Thus in one embodiment the total available call state storage capacity of the cluster is a summation of the capacities of each partition.

In one embodiment each partition can peer replicated meaning that clients perform all operations reads writes to all replicas in the partition wherein the current set of replicas in the partition is called the partition view . This can provide improved latency advantages over more traditional synchronous primary secondary architecture wherein one store acts as a primary and the other nodes serve as secondaries. Latency is reduced because there is no wait for the second hop of primary secondary systems. The peer replicated scheme can provide better host to host failover characteristics as well since there does not need to be change propagation delay.

In one embodiment the engine nodes and which are distributed over multiple hosts can be responsible for executing the call processing. Each call can have a call state associated with it. This call state can contain various information associated with the call such as the ids of the caller callee where the caller is what application is running on the callee any timer objects that may need to fire in order to process the call flow as well as any other data that may be need to enable a SIP session between two entities. The state for each call can be contained in the state tier . The engine tier on the other hand could be stateless in order to achieve the maximum performance. In alternative embodiments the engine tier can have small amounts of state data stored thereon at selected periods of time.

In one embodiment a typical message processing flow can involve locking getting the call state processing the message and putting unlocking the call state. The operations supported by the replicas for normal operations can include 

The SIP server can also provide a way to efficiently persist long lived state data to a disk in order to avoid unnecessary consumption of cluster resources. The state tier can persist call state data to a relational database management system RDBMS after a call dialog session has been established and can also retrieve or delete the persisted data as needed to modify or remove the call state. The SIP server can also provide an API for application developers to provide hints as to when the state tier should persist the data as will be further discussed below.

As an illustration in the above described embodiments the state tier maintains call state in various data objects residing in the random access memory RAM of a computer. This can provide significant low latency advantages to the engine tier. However the SIP server can also provide a way for efficiently persisting long lived state information to a database disk storage . Since RAM is generally significantly more expensive than database memory it may be desirable to reduce the number of replicas in the state tier by storing at least some of the session state information to the database. In most cases database access to data is slower than RAM based replica access. However because some SIP communication sessions are not as latency sensitive as others the state for these communications can be persisted in the database in order to save the amount of random access memory required by the SIP server deployment. For example a telephone call setup stage can be extremely latency sensitive while a subscription by a cable box to receive infrequent updates or notifications can tolerate much slower access times. Thus the state data associated with such an ongoing subscription session can be stored in a database so as to save the amount of RAM needed for the deployment. As another illustration a standard telephone call can be viewed as having three stages a call setup stage an active call stage and the call teardown stage hanging up the call . The call setup stage is typically the most latency sensitive since users tend to expect immediate results from the server after pressing the call button. However the call teardown stage may not be as sensitive to latency because after the handset disconnects it may not matter from the user s perspective how long it will take for the server to complete call termination. As such session state for call termination can be maintained in a database. Similarly the active call stage may also be not as latency sensitive as the call setup stage since it mostly involves communication of voice bits between media servers. It should be noted that these examples are provided purely for purposes of illustration and are not intended to limit the invention in any way. Any state can be saved to a database if it can reasonably tolerate the access times required by database create read update or delete CRUD operations.

In various embodiments appropriate filtering and caching strategies may be employed in order to reduce the impact on transaction state and access times for session and transaction state that is likely to be needed in latency sensitive operations while allowing for the storage of large amounts of active sessions and timers on local disks as a means of reducing costs. The SIP server can use the RDBMS to supplement the state tier. To improve the latency of message processing when using the database timers and locking information can be maintained in memory on the state tier. Similarly the state tier can also maintain the call states being actively modified. In one embodiment the state is persisted only after a dialog has been established and the call is in progress or alternatively in response to hints provided by the application.

As previously discussed a load balancer can distribute various incoming messages to the engine nodes and of the engine tier in a round robin fashion. The engine nodes can be responsible for efficiently processing the various messages and transactions by obtaining any needed state data from the state tier . The state replicas and of partition can maintain the state data and associated with the various SIP sessions and provide it to the engine nodes upon request.

As illustrated at least some of the session state can also be stored in a persistent store or database such as an Oracle database. In one embodiment this persistent store is not intended to provide additional redundancy but is instead configured for reducing memory requirements in the state replicas and . This can enable un reliable writes to the database such that a failure to write does not compromise the correctness of the state tier even if it may cause the persistent store to be incorrect.

In one embodiment the database only stores a partial view of the state maintained in the state tier. For example various timer objects as well as locking information can still be maintained on the state tier while other data that is not as latency sensitive may be pushed to the database for later retrieval. This is done because the high throughput processing of the engine tier may not be met when saving all state changes and timer functionality upon every transaction to the database. Thus in order to improve latency the timer objects and lock data associated with a call session can be maintained in RAM based state replicas even while various other data associated with the call session is written to the database.

The persisting of session state in the database can be driven by hints provided by the engine tier. For example the engine node upon reaching a transaction boundary can provide a hint to the state replicas indicating that it is time for the state data to be replicated to the database. A transaction boundary can indicate to the state tier that no further transactions are likely to occur in the near future which would change the call state associated with the session. State replicas can follow the hint or alternatively they can choose to disregard it. In one embodiment a PutAndUnlock method such as AsyncResult putAndUnlock PartitionView clientView long clientID Key key int lockID byte data int version long time int flags throws ReplicaException RemoteException has an added integer flag flags which encodes a Boolean hint that the state should be persisted. Thus during the updating of the state and unlocking it in the partition the engine can provide a hint to save the data to the database.

The engines can determine when to hint to the state replicas in a multitude of ways. In one embodiment the engine can determine based on its processing of various transactions that the session state has reached a steady state i.e. that it is not expected that this particular call state will change within a specified period of time. For example once an ongoing subscription session has been established by a cable box that session state is unlikely to change until the configuration for that cable box needs to change i.e. for a significantly long period of time e.g. 24 hrs . Thus after this session has been established the engine can provide a hint to the replica to save session state data to the database. As another example after a telephone call has been established during the latency sensitive setup stage the session state is unlikely to change since most of the communication is being sent over the media servers. This point in time can also indicate a steady session state and may be a good candidate for placing a hint. In one embodiment the engine decision to save is controlled by the transaction manager. The following is an illustrative and non limiting list of SIP protocol actions upon which the engine can choose to transmit a hint to the state tier 

In various embodiments the engine can itself receive hints from the application or servlet deployed thereon and can merely relay that hint to the state replica. In some cases the application developer may be able to make the best estimation as to when the transactions will have reached a steady state and thus the engines can take advantage of this by reading hints from the application.

In various embodiments the state replicas can choose to follow it and copy the data to the persistent store or alternatively choose to disregard the hint. For example a state replica may receive a hint to persist the data from one engine but immediately following that hint and before it has had a chance to save the data to the database the replica may receive a new request from another engine for the same session state. In that case the state replica may choose to disregard the hint to save data and wait to receive the hint from that other engine. Similarly several servlets or applications may end up on the same session and while one may produce a hint to copy the state the state replica may choose to disregard that hint and wait to receive an aggregate view of a steady state across all of the applications on that session.

Furthermore the state replicas may be programmed with logic to optimize the following or disregarding of hints according to their own memory usage. For example a state replica may choose to ignore all hints to copy state to the database if only a small fraction of its RAM based memory is being currently used in order to provide faster overall services. Conversely if a large portion of the memory has already been taken up the state replicas may choose to follow most hints so as to take full advantage of memory reduction.

Once a decision has been made to persist the call state a single replica in the partition can be designated as the persister and this replica is configured to process the call state writes or deletes to the database. This persister replica can be designated in several ways. In one embodiment the primary replica responsible for answering queries from the engine tier as previously discussed is also responsible for placing writes and deletes to the persistent store. In alternative embodiments other replicas can be selected so as to remove the burden from the primary replica.

The persister replica in a partition is responsible for writing data. To avoid impacting latency the thread handling the putAndUnlock command can imply enqueue a task to perform the database insert update. A separate thread will then actually run that task. Thus an execute queue can be maintained by the replicas in order to provide asynchronous put and remove operations to the database. In this manner the caller is not blocked waiting for a thread to finish executing and can continue performing other actions as needed.

Subsequent to being persisted in the RDBMS the session state data can be safely removed from the state tier partition . The removal of the data in the state replica can include nulling out the byte array containing the actual call state data in the RAM data structure while preserving the primary key associated with that particular state. In one embodiment the entire call state storage need not be deleted since lock processing and timer processing is not stored to the persistent store. Thus in some embodiments a call state with null data and is different from missing call state which would lead to the creation of a new call state. However this is not intended to limit the invention and in alternative embodiments other methodology can be implemented to remove session state from the replicas upon saving it to the database in order to conserve RAM based storage space.

Given such asynchronous nature of the save operations a version identifier for the call state may be desirable so as to handle race conditions. The extant cacheVersion can be adjusted to be a call state versioning ID starting at 1 and incremented at each lock operation. In one embodiment this state version information can allow or disallow the nulling out of state data in the replica based on whether the version in the database is fresh.

After removing the state by the persister replica a notification can be sent to the other replicas in the partition. In one embodiment a method such as notifyPersisted Key key int version can be used to notify the other replicas that the call state has been saved to the persistent store and therefore can be safely removed from the RAM store. Upon receiving this notifications the other replicas in the partition can appropriately null out the state data while preserving the various timer and lock information as previously discussed.

Any available replica can be used to retrieve the call states from the persistent store as necessary for subsequent reads. For example during a lock and get request the primary replica can read the session state data from the database and return it to the engine if the state stored in the RAM of the replica is nulled out. In this manner significant storage costs can be reduced for the state tier layer while still allowing minimized latency for those SIP sessions and applications that require it.

As shown in step after an engine has finished processing a transaction it can place a putAndUnlock call to the state tier replica. At this point the state is saved to the random access memory as shown in step and the lock is released such that the state is capable of being accessed by other engines.

In step it is determined whether this particular replica is a persister in the partition. If it is not then no further action is required from this replica and it can safely return a signal indicating success of the putAndUnlock method to the engine tier as illustrated in step . If on the other hand this replica has been designated a persister then processing continues to step where it is determined whether a hint to persist the state was provided to the replica. This determination can be made by reading an integer flag variable of the putAndUnlock method for example. If a hint was provided the state replica can add a task to the Execute Queue for writing or updating the state data to the RDBMS as shown in step . After the task has been added or alternatively if no hint was provided the replica can return a success indication to the engine node that placed the putAndUnlock call as shown in step .

In step a thread executing separately from the thread that has enqueued the task dequeues a task from the execute queue. In step the CRUD operation such as an update is written to the database. If that operation is a success as determined in step the process can continue to step . If on the other hand the update operation does not return an indication of success the thread can proceed to dequeue another task or the same task from the execute queue. Since in some embodiments unreliable writes to the database are permitted no further processing need be required of the thread at this point. However it should be noted that various error checking and reliable writes are also possible and are within the scope of the present invention.

In step the state data in the RAM of the replica is attempted to be nulled. In other words the byte array containing the actual data stored is set to value null while maintaining the primary key lock and timer information within the replica. If this operation is allowed by the versioning ID as determined in step then a notify method can be called. AS shown in step this notify method can inform other replicas in the partition that the state data has been successfully saved to the database and that it is safe to null out the copies of that state information in the other replicas as well. After this the thread can loop back to step and proceed with dequeueing the next task from the execute queue.

In step an engine node may execute a lock and get method during the processing of a transaction. During this method a query is performed against the state tier requesting the state data associated with the transaction or call being processed. In step the state tier determines whether the replica receiving the query is a primary replica replica designated to provide state to the engines . If the replica is not a primary replica it can merely return null value to the engine as illustrated in step avoiding any redundant processing. If on the other hand the replica is a primary replica processing continues to step .

In step the state data is fetched from the RAM by the primary replica. In step a determination is made whether the state data has been nulled and whether this state replica is designated a persister. If both of these conditions evaluate to true the state replica can be configured to retrieve the state data from the database as illustrated in step . If on the other hand either condition evaluates to false the state data can be returned to the engine node as shown in step .

If the database retrieval is successful as determined in step the state replica may return the data to the engine that has executed the lock and get request. On the other hand if the database retrieval failed for some reason e.g. due to a database error the state replica can instead return a failure to the engine node as shown in step indicating an error in retrieving the state.

In step an engine node can instruct the state replica to remove the state from the database. The state replica can remove the session state from its RAM as shown in step . If the replica is a primary replica as determined in step a task can be enqueued to the remove queue as shown in step . Note that a different replica than the primary can also be used within the scope of the present embodiments. After the task is added to this queue success can be returned to the engine node as shown in step whereupon the thread is freed up to perform other tasks. A separate thread can then dequeue the task from the remove queue and perform the appropriate CRUD operation to delete the data therefrom. It should also be noted that in alternative embodiments some call states can be silently expired i.e. removed without the intervention of the engine tier. In these cases the persister replica is adapted to also remove the call state from the persistent store.

In various embodiments a new domain template replicatedDatabase is created in order to support the creation of new domains with database backed replication. This new template can add to the replicated domain a JDBC connection pool having one connection targeting the state tier cluster a JDBC data source containing the pool and targeting the state tier as well as an execute queue having one thread that will perform the tasks of writing data to the database. Furthermore an SQL file can be applied to create the data schema needed for the database. The model can be based on a numeric primary key generated by using the hashcode of the call identifier call ID . Because the call ID is a string controlled by the UACs and is of unknown length to the SIP server the numeric key that is used to store the data can be generated by hashing the call ID. This can allow the SIP server to store the session state data in a more consistent manner.

In one embodiment individual database operations are placed on an execute queue which get consumed by a single thread thus preserving the order of operations. On each successful database insert or put an additional remote method invocation RMI call is undertaken by each replica in the view. However this is not intended to limit the invention and in alternative embodiments multiple threads can be used to execute the write tasks. In those cases care should be taken that the same thread handles operations for a given key. Furthermore in yet other embodiments instead of placing database operations on an execute queue they could be placed in a map indexed by a key and consumed by a timer based thread. This timer task approach may add increased complexity and possibly increase the number of operations lost in case of replica failure. However it could have the following performance benefits 

Other possible modifications to the SIP server state persistence include for example distributing database operations across all replicas in the partition instead of having only the persister replica perform such functions. Furthermore a different table for each partition could be used thereby decreasing the contention on the database. All of these modifications may be left to be determined by an administrator and may be specific to each SIP server deployment and its particular requirements.

Various embodiments of the invention can include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs micro drives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs paper or paper based media and any type of media or device suitable for storing instructions and or information.

Various embodiments include a computer program product that can be transmitted in whole or in parts and over one or more public and or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. In various embodiments the transmission may include a plurality of separate transmissions.

Stored one or more of the computer readable medium media the present disclosure includes software for controlling both the hardware of general purpose specialized computer s and or processor s and for enabling the computer s and or processor s to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments and containers as well as user interfaces and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

