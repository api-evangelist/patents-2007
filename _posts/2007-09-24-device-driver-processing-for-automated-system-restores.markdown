---

title: Device driver processing for automated system restores
abstract: In one embodiment, a computer accessible medium comprises a plurality of instructions which, when executed and if a computer system comprises at least one virtual hardware device, identify the virtual hardware device and a corresponding physical hardware device. The plurality of instructions also capture a device driver associated with the physical hardware device for use as the device driver in an install of an operating system on a second computer system having a same type of physical hardware device. Corresponding computer systems and methods are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07941814&OS=07941814&RS=07941814
owner: Symantec Operating Corporation
number: 07941814
owner_city: Mountain View
owner_country: US
publication_date: 20070924
---
This application is a divisional of U.S. application Ser. No. 10 788 120 filed Feb. 26 2004 now U.S. Pat. No. 7 293 272 entitled Device Driver Processing for Automated System Restores by inventors Okan Okcu and Nicholas R. Graf.

This invention is related to the field of restoring computer system data from backup and more particularly to providing device drivers for restoring to a system.

Unattended or automated installs of operating systems may be used in a variety of situations. For example various backup and restore products are used to safeguard software and data state on a computer system. When a failure occurs on the computer system the failure may be corrected and the computer system state may be restored. Alternatively a new computer system may replace the failing computer system and the state may be restored to the new computer system. In either case so called bare metal backup and restore products may begin the restore process with bare metal that is no software installed on the computer system yet including operating system software . It may be desirable to install the operating system in an automated unattended fashion in such circumstances since the restore may be initiated by an administrator user who is not physically near the computer system to which the restore is being performed. Additionally it may be desirable to perform the install in an automated unattended fashion to simplify the restore process and reduce the opportunity for administrator user error in the process. Other software products may also use automated operating system installs. For example provisioning software products outfit a computer system with the software resources and configuration needed to perform one or more tasks. Provisioning software may make use of an automated operating system installation to provision a computer system with the desired operating system.

To properly perform an unattended operating system installation the device drivers used by at least some of the hardware devices in the computer system on which the installation is to occur the target computer system are required. Device drivers may be more briefly referred to herein as drivers. In some cases the operating system installation media may include drivers for the hardware devices but in other cases the drivers must be provided from another source.

Of particular concern are the drivers for any mass storage device MSD controllers in the computer system. The operating system is to be installed on the MSDs in the system and thus the MSDs need to be accessible during the installation process. Accordingly drivers for the MSD controllers are needed during the installation process.

For some operating systems such as the Windows operating system family from Microsoft Corporation Redmond Wash. a file is used to identify the drivers for installation during a text mode portion of the installation prior to starting the operating system itself. For example Windows expects a file having the name txtsetup.oem to identify such drivers. Drivers may be identified using driver information files inf files in Windows for the graphical mode portion of the installation e.g. after the operating system has been started . Various MSD controller manufacturers identify drivers by listing them in either the txtsetup.oem file in various inf files or both. Some MSD controller manufacturers do not include a txtsetup.oem file on their installation media or include a txtsetup.oem file that lists one or more inf files that include the desired drivers. Additionally if drivers are gathered from another source than a manufacturer s installation medium there may be no txtsetup.oem file. In some target computer systems more than one MSD controller is included and the MSD controllers use different drivers. However Windows expects a single txtsetup.oem file to identify the drivers for each MSD controller.

The VERITAS Bare Metal Restore BMR product available from VERITAS Software Corporation Mountain View Calif. is one example of a backup restore product which uses automated operating system installation. Accordingly BMR creates a txtsetup.oem file for use in a given installation. If the target computer system has more the one MSD controller information from more than one source may need to be merged into the txtsetup.oem file. Additionally if no txtsetup.oem file exists BMR creates one. In previous versions of BMR the product attempted to process the txtsetup.oem file provided by an MSD manufacturer to identify installation drivers for the text phase. However in some cases there is no txtsetup.oem file to process or the txtsetup.oem file does not properly identify the driver. In other previous versions of BMR the product attempted to process the driver information files instead of the txtsetup.oem file to identify installation drivers for the text phase. However in some cases an MSD uses a different driver for the text phase and for the graphical phase when the inf files are used . The inf files do not specify the correct drivers in such cases.

Another issue encountered in identifying drivers for automated operating system installations occurs when gathering drivers from a running computer system such as the computer system from which the backup is made . Some computer systems make use of virtual hardware devices. For example virtual network interface cards NICs are often used for fault tolerance and or load balancing purposes. When in use a virtual NIC is mapped to a corresponding physical NIC i.e. a NIC that is physically present in the computer system . Application software and even some operating system software uses the virtual NICs for network communications and the virtual NICs may pass the communications to and from the physical NICs.

When virtual hardware devices are used querying the running computer system to identified drivers is more complicated. The virtual hardware devices and physical hardware devices may both be indicated by the system e.g. using various operating system application programming interfaces APIs and or operating system files such as the Registry in Windows . However the drivers for the devices may only be associated with the physical hardware devices. Drivers indicated for the virtual hardware devices in some cases cannot control the physical hardware devices. Accordingly if a driver is selected from a virtual hardware device in the running computer system the correct driver for the physical hardware device may not be identified. Additionally in some cases a virtual hardware device includes properties needed for installation and configuration. For example transport control protocol internet protocol TCP IP properties may be including in the virtual NICs in Windows systems.

In one embodiment a computer accessible medium comprises a plurality of instructions which when executed parse at least a section of an input file to identify i one or more driver information files if at least one driver information file is listed in the section and ii one or more first device drivers if at least one device driver is listed in the section. The section corresponds to a hardware device. The plurality of instructions when executed and if at least one driver information file is listed in the section parse each of the one or more driver information files to identify i one or more second device drivers if at least one device driver is included in the driver information file and ii one or more miniport drivers if at least one miniport driver is included in the driver information file. The plurality of instructions when executed select a selected device driver from the first device drivers the second device drivers and the miniport drivers. The selected device driver is to be listed in an output file that is used in a text phase of an operating system installation on a computer system that includes the hardware device. A computer system including the computer accessible medium and a processor configured to execute the plurality of instructions is contemplated. A corresponding method is also contemplated.

In another embodiment a computer accessible medium comprises a plurality of instructions which when executed and if a computer system comprises at least one virtual hardware device identify the virtual hardware device and a corresponding physical hardware device. The plurality of instructions also capture a device driver associated with the physical hardware device for use as the device driver in an install of an operating system on a second computer system having a same type of physical hardware device. A computer system including the computer accessible medium and a processor configured to execute the plurality of instructions is contemplated. A corresponding method is also contemplated.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

Turning now to a block diagram of one embodiment of a system comprising several servers and clients is shown. In the illustrated embodiment a BMR server a boot server a file server a backup server and a set of clients A N are shown. Any number of clients A N may be included in various embodiments. The BMR server is coupled to the boot server the file server and the backup server . The clients A N are generally configured to interact with the servers and and may be coupled to the servers and . is illustrative of logical relationships between the servers and clients. Physical connection may be established in any desired fashion e.g. any type of network combinations of networks shared memory etc. .

Each of the clients A N comprises a computer system that may be backed up and restored using the servers and . Data corresponding to each client A N is backed up in a respective backup image A N on the backup server . The backup images A N may be the most recent backup image of each client A N. Other preceding backup images corresponding to various clients may also be retained on the backup server or other storage. In some cases when a restore is to be performed the data in a given backup image A N may have been backed up from the corresponding client A N previously and may be restored due to a failure in the corresponding client A N either hardware software or a combination thereof or other loss of the data in the corresponding client A N. In some cases of a hardware failure in the corresponding client A N the failing hardware may be replaced with different hardware. Alternatively if a restore is to be performed the data may have been backed up from another computer system not shown that subsequently experienced an irreparable failure or is otherwise being replaced by the corresponding client A N. The backup server may implement any backup solution e.g. the VERITAS NetBackup product from VERITAS Software Corporation or any other VERITAS backup product or backup product from any other vendor .

At the time that a backup is performed from a client A N a record is made of the system configuration of that client A N. The record is illustrated as the client configuration files A N in the configuration database on the BMR server in although the record may be stored in any form. In some embodiments the client configuration files A N may be part of the respective backup images A N as well or the client configuration files A N may be stored only as part of the respective backup images A N and may be retrieved by the BMR server when a client restore is to be performed. In one embodiment each of the clients A N may have a config save tool A N installed to generate the corresponding client configuration files A N. The config save tool may comprise software that is a plurality of instructions which when executed generates the client configuration file.

The client configuration files A N may store various information describing the corresponding client system A N configuration. For example the system configuration may identify the device drivers or more briefly drivers used by the corresponding client system. As used herein a device driver or driver may comprise any software that is used to control a hardware device included in a computer system and that may provide a higher level more abstract interface for other software to use in order to interact with the hardware device. Hardware devices controlled by device drivers may include MSD controllers such as small computer systems interface SCSI controllers integrated device electronics IDE controllers etc. Generally an MSD controller may be any controller that is capable of interfacing to one or more mass storage devices such as disk drives tape drives compact disk CD drives digital versatile disk DVD drives etc. Hardware devices controlled by device drivers may further include NICs or on board circuitry that implements the same function as a NIC. Generally NICs or corresponding on board circuitry or any combination thereof may be referred to as network interface hardware . Still further hardware devices controlled by device drivers may include video controllers displays audio controllers peripheral bus controllers also referred to as host bus adapters or HBAs and any other peripheral devices that may be included in or coupled to a computer system. The client configuration file A N may further include any other desired information e.g. the number type and size of storage devices in the client system the volumes on the storage devices including the layout of volumes on the storage devices and the attributes of the volumes the number and type of processors the amount of memory information on other peripheral devices etc. .

The file server may provide the clients A N with various software reference numerals A N respectively used during the restore process which may include the operating system software e.g. operating system commands and libraries BMR client software backup client software etc. The file server may implement any file system usable over a network e.g. network file system NFS Server Message Block SMB for Microsoft Windows or Samba for Unix like implementations etc. . The boot server may be used to provide respective boot images A N to the clients A N. When a client A N is booted to perform a restore the client A N may use standard network boot protocols to boot using the respective boot image A N. The boot images A N may include a customized restore procedure created by a restore tool on the BMR server to restore the client A N to the state corresponding to the respective backup image A N. In some embodiments a media boot is supported in which the boot image A N and software A N are stored on a computer accessible medium such as a compact disc and the disc is used to boot the client A N. In such embodiments the boot server and the file server may be eliminated. In the present embodiment a client A N at the beginning of the restore process to that client may be bare metal . That is no operating system software or other software may yet be installed although firmware may be included in the client . A client A N that is being restored is referred to herein as the target client .

Part of the restore procedure generated by the restore tool includes performing an automated install of the operating system on the target client. If the Windows operating system is to be restored a txtsetup.oem file is used to identify the drivers that are to be used during the text phase of the installation. In some embodiments the txtsetup.oem file may be created by the restore tool . In other embodiments the txtsetup.oem file may be created by the config save tools A N when a configuration save is made. In still other embodiments the create package tools A N may create a txtsetup.oem file when creating a driver package A M. In various embodiments the txtsetup.oem file may be created at any desired time. The txtsetup.oem file may be included in the files A N on the file server in the boot image A N or may be created and stored onto the target client in various embodiments. Additional details regarding the creation of a txtsetup.oem file are provided below.

In some embodiments a driver may be collected from a client system A N that is using at least one virtual hardware device corresponding to the physical hardware device that the driver controls. For example the config save tool A N may be attempting to collect drivers for a configuration save into a client configuration file A N. Alternatively the restore tool may attempt to collect a driver from a running system that has the same type of hardware device that would use the same driver as the target client has for restoring to the target client. The config edit tool may attempt to collect a driver to list in the client configuration file A N of the target client. Additional details regarding one embodiment of identifying a driver for a hardware device on a computer system that has at least one virtual hardware device are provided below.

If a backup image A N is to be restored to a target client that includes different hardware than the computer system from which the backup image A N was made referred to more briefly as the saved client the backup image A N may be modified to execute properly on the target client. For example if the hardware differences between the saved client and the target client include one or more hardware devices on the target client that use different drivers than the hardware devices on the saved client the drivers used on the target client are added to the backup image A N. In some cases the differing hardware devices may replace hardware functionality of hardware devices that were included in the saved client. In other cases the differing hardware devices may provide new hardware functionality not included in the saved client. Adding the drivers may involve inserting the driver file or files into an appropriate directory in the backup image A N and may also include updating one or more operating system files that map drivers to devices e.g. the registry in the Microsoft Windows operating system . The hardware differences between the saved client and the target client may also necessitate a different hardware abstraction layer HAL and or different kernel. The HAL may generally provide a consistent device independent interface for applications to use abstracting out various hardware differences across hardware platforms. The kernel may be the central module of the operating system providing various services to other parts of the operating system e.g. memory management disk management process and task management etc. . The HAL and kernel may be modified by changing the files containing the HAL and kernel code in the backup image A N.

In other embodiments data files in the backup image A N may be modified. For example various configuration files used by the operating system software within the backup image A N may be modified. Particularly the media access controller MAC address of the NIC or NICs in various configuration files may be changed to match the target client.

In one embodiment the restore tool uses the client configuration file A N corresponding to the saved client to perform the restore. Particularly the restore procedure may boot the client using drivers indicated in the client configuration file A N. In order to restore to different hardware in this embodiment the client configuration file A N may be edited to change the driver information for the client the HAL information for the client and or the kernel information for the client. The config edit tool may be used to edit the client configuration file. Generally the config edit tool may comprise software that when executed permits a user to change the features of the client configuration file and either save the changed file as a new client configuration file or overwrite the original client configuration file.

In one embodiment each of the BMR server the boot server the file server and the backup server may comprise computer systems configured to execute the corresponding server software. In some embodiments one or more of the servers and may be combined onto the same physical computer system as desired. Each computer system including the client computer systems A N as well may comprise at least one processor configured to execute the instructions comprising the software illustrated in memory to store the instructions for execution by the processor a computer accessible medium to store the instructions etc.

The drivers provided when the target client has different hardware than the saved client may be drawn from different sources. For example drivers may be published into a driver database on the BMR server . The driver database may comprise various driver packages A M each containing driver files and various other driver configuration information e.g. inf files used in the Microsoft Windows operating system . The clients A N may include a create package tool A N that may be used to publish drivers into the driver database . The user may select drivers from the driver database when editing the client configuration file A N. Alternatively drivers may be provided from other sources e.g. another client configuration file drivers shipped by the manufacturer of a device on a storage media drivers downloaded from a network source such as the Internet etc. .

In the illustrated embodiment there is a boot image A N and a software image A N for each backup image A N and for each client A N . In other embodiments one boot image A N may be used for multiple backup images A N and for multiple clients A N . Thus there may not be a one to one relationship between boot images A N and backup images A N and clients A N . Similarly in some embodiments one software image A N may be used for multiple backup images A N and for multiple clients A N . Thus there may not be a one to one relationship between software images A N and backup images A N and clients A N .

One embodiment for creating a txtsetup.oem file for a target client is next described. The txtsetup.oem file is used in embodiments in which the Windows operating system is to be installed on the target client. Other embodiments may implement similar features for creating a file used by the operating system to locate the drivers during a text phase of the operating system installation.

Turning now to a flowchart is shown illustrating one embodiment of the process of installing an operating system where the process includes both a text phase and a graphical phase. Generally the text phase includes copying at least a portion of the operating system onto the target client e.g. onto the MSDs on the target client . The portion of the operating system copied during the text phase comprises at least enough of the core of the operating system to permit the operating system to be started. In some cases the entirety of the operating system may be copied during the text phase. In other embodiments the kernel of the operating system and related operating system modules used to start the operating system may be copied and the remainder of the operating system modules may be copied during the graphical phase. The graphical phase may include the operating system discovering the hardware devices and configuration of the target client. For example the Windows operating system may install information into the registry in the graphical phase. Among the information installed into the registry is the drivers to be used for the hardware devices in the target client. As mentioned previously the drivers used in the operating system installed during the graphical phase may differ from the drivers used during the text phase in some cases.

During the text phase block the operating system installation uses the txtsetup.oem file to identify drivers for use on the hardware devices in the target client reference numeral . Particularly the txtsetup.oem file may identify a driver for the MSD controller in the target client so that operating system files may be copied to the MSDs on the target client. If more than one MSD controller is included more than one driver may be identified in the txtsetup.oem file in some embodiments.

During the graphical phase block drivers are identified for hardware devices using driver information files e.g. oemsetup.inf in reference numeral . In Windows operating system embodiments driver information files may also be referred to as inf files after the file extension of the files. Generally a driver information file may identify drivers to be used for various hardware devices. While one txtsetup.oem file is expected during Windows operating system installs many inf files may be provided if desired. In some embodiments the driver information files may also provide additional information regarding the hardware devices.

In Windows operating system embodiments both the txtsetup.oem file and the inf files may have multiple sections. Each section may correspond to a different hardware device and or a different driver.

Turning now to a block diagram is shown illustrating one embodiment of some possible sources of txtsetup.oem files and oemsetup.inf files. Also shown in is a create txtsetup tool which may comprise software configured to generate an output txtsetup.oem file for use in installing the Windows operating system on the target client. In different cases one or more of the sources may be used to generate the txtsetup.oem file .

For example one source may be a manufacturer s CD or other computer accessible media . The manufacturer s CD may be shipped with the hardware device and may include the drivers and other configuration files that are used with the hardware devices in a client. Particularly as shown in the manufacturer s CD may include one or both of a txtsetup.oem file and an oemsetup.inf . In other cases the manufacturer s web site may be a source of drivers and corresponding txtsetup.oem and oemsetup.inf files.

Another source may be a driver package from the driver database e.g. the driver package A shown in . The driver package A may include one or both of a txtsetup.oem file and an oemsetup.inf file . A third source illustrated in may be a running client e.g. client A . The client may include one or both of a txtsetup file and an oemsetup.inf file .

In some embodiments the user may identify which source or sources to use for locating input txtsetup.oem and or oemsetup.inf files to be used to create the txtsetup.oem file . In other embodiments the create txtsetup tool may automatically search a set of sources for the correct files.

The create txtsetup tool may be included in various other software shown in in various embodiments. For example as mentioned above with regard to various embodiments may create a txtsetup.oem file as part of the restore tool the config save tools A N or the create package tools A N. In such embodiments the create txtsetup tool may be part of any of the above software.

The create txtsetup tool may search both input txtsetup files e.g. reference numerals and and oemsetup.inf files e.g. reference numerals and to locate the correct drivers for listing in the output txtsetup.oem file . For example is a flowchart illustrating one embodiment of the create txtsetup tool . That is the create txtsetup tool may comprise a plurality of instructions which when executed implement the operation shown in .

The create txtsetup tool may receive as input a section name for a section to parse in an input txtsetup.oem file reference numeral . In the case that a driver has been captured from a client the input txtsetup.oem file may contain only one section. In other cases e.g. from the manufacturer s CD the txtsetup.oem file may have several sections. The user may be requested to select the section that is to be processed. Alternatively each section may be processed in some implementations. The input txtsetup.oem file may be obtained from any source e.g. any of the sources shown in .

Each section of the txtsetup.oem file may list zero or more drivers and zero or more inf files although at least one driver or inf file may generally be listed. For example the driver files and inf files may be listed by filename and file extension. In some embodiments a path name may also be supplied if needed. Similarly inf files may have sections listing one or more drivers.

The create txtsetup tool parses the section of the input txtsetup.oem file to identify any drivers indicated in the section and to identify any inf files in the section. The create txtsetup tool may create a first driver list and a list of inf files respectively as a result of parsing the section of the txtsetup.oem file block . That is the first driver list may be the list of driver file names and extensions if applicable parsed from the section of the input txtsetup.oem file. The list of inf files may be the list of inf file names and the extension inf if applicable parsed from the section of the input txtsetup.oem file.

The create txtsetup tool may parse each inf file in the list of inf files parsed from the input txtsetup.oem file block . Drivers listed in the inf files may be added to a second driver list. Additionally drivers indicated as miniport drivers may be added to a miniport driver list. As used herein a miniport driver may be the main device driver for a hardware device. Other device drivers may be identified for the device as well. For example a driver stack may be used in which the miniport driver is surrounded by one or more filter drivers. Filter drivers may include upper drivers which reside between the miniport driver and the applications and lower drivers which reside between the miniport driver and the hardware device. Additionally helper drivers may be defined to perform specific functions. In the case of an MSD controller the miniport driver may be a SCSI miniport driver.

The first driver list may have the drivers listed in the order that the drivers were found in the section of the input txtsetup.oem file. The initial driver identified in a section of the txtsetup.oem file is supposed to be the miniport driver for the hardware device but not all manufacturers follow this rule. In some cases the second driver list and the miniport driver list may also have the drivers listed in the order that they were found in the inf files.

The create txtsetup tool selects a driver to be listed in the output txtsetup.oem file from the drivers listed in the first driver list the second driver list and the miniport driver list. To make the selection the create txtsetup tool selects the initial driver from the first driver list that is the driver that was listed in the input txtsetup.oem file before any other driver if any and compares the driver to the drivers listed in the second driver list and the miniport driver list. That is the create txtsetup tool may compare the filenames and extensions of the drivers.

If the initial driver from the first driver list is not listed in either the second driver list or the miniport driver list decision block no leg the create txtsetup tool uses the initial driver as the initial file listed in the output txtsetup file block . This case may occur for example if the hardware device uses one driver during the text phase and another driver during the graphical phase .

If the initial driver is listed in at least one of the second driver list or the miniport driver list decision block yes leg the initial driver is still selected as the initial file listed in the output txtsetup file if the initial driver is listed in the miniport driver list decision block yes leg . In this case the initial driver from the input txtsetup.oem file has been verified to be a miniport driver and thus may be suitable for use during the text phase. If the initial driver is not listed in the miniport driver list decision block no leg the create txtsetup tool selects the initial file from the miniport driver list as the initial file for the output txtsetup.oem file block .

In addition to listing the driver as selected above the create txtsetup tool may add to the output txtsetup.oem file the list of inf files specified in the input txtsetup.oem file block . However other drivers may not be listed in the output txtsetup.oem file . These other drivers are excluded from the output txtsetup.oem file because the inventors have observed that having additional drivers in the output txtsetup.oem file has created problems for the automated installation. That is the automated installation did not work in some cases. However the other drivers may be included in the driver package with the selected driver so that the other drivers are available on the target client e.g. for Plug n Play installations of the drivers .

In the embodiment of one or more virtual NICs A L and one or more physical NICs A P may be included. Any number of virtual NICs A L and any number of physical NICs A P may be included. The number of virtual NICs A L may be greater than equal to or less than the number of physical NICs A P.

The virtual NICs A L may be mapped to the physical NICs A P in any desired fashion. For example virtual NICs may share a physical NIC e.g. lines and in . Alternatively virtual NICs may be mapped to different physical NICs e.g. lines and in .

A device driver A P may be included for each physical NIC A P. Separate physical NICs A P may use the same device driver A P in some embodiments so there may be fewer device drivers than there are physical NICs A P. The device drivers A P are associated with the physical NICs A P illustrated by the arrows from the device drivers A P to the physical NICs A P in but may not have any direct connection to the virtual NICs A P. On the other hand other properties of the NICs may be included in the virtual NICs A L e.g. TCP IP settings in . Such properties may also be used in restoring to a target client and thus may be captured along with identifying the drivers.

Also shown in the embodiment of is the hardware including a processor and memory similar to the embodiment of described above. While virtual NICs are used as an example in and in the detailed examples of any virtual hardware devices may be used in other embodiments. As used herein a virtual hardware device may comprise a software created construct that is used by application programs and or operating system modules as if it were the hardware device. The virtual hardware device may comprise any combination of data structures and or software. Each virtual hardware device that is in use is mapped to a physical hardware device. The physical hardware device is the hardware device that is physically present in the computer system. The physical hardware device provides the hardware function for the virtual hardware device.

The software may identify all devices of the type for which corresponding device drivers are to be identified block . That is both the virtual hardware devices and the physical hardware devices are in the list of identified devices. Various mechanisms may be used to identify the devices. For example some operating systems may provide an API for requesting information on the devices in the system. In other cases operating system databases configuration files may be consulted e.g. the Windows operating system s Registry . In still other cases a combination of APIs and databases configuration files may be used.

The software may determine if there are virtual hardware devices decision block . A variety of mechanisms may be used to determine if there are virtual hardware devices. For example if the hardware devices are Plug n Play devices the Plug n Play identifiers PnP IDs may be used to detect virtual hardware devices. The PnP IDs identify the manufacturer model number etc. of the hardware devices but there are also PnP IDs for legacy devices. The legacy PnP IDs do not identify a specific manufacturer etc. Since virtual hardware devices are not real hardware devices they may use the legacy PnP IDs. Another mechanism may be used for NICs. NICs have a MAC address and the MAC addresses may be compared to detect a duplicate or duplicates. If a duplicate is detected one of the devices having the duplicate is virtual and the other is physical. More than one duplicate of a given MAC address may be detected if more than one virtual NIC is mapped to the same physical NIC. Other hardware devices may similarly have an address that may be duplicated between a virtual hardware device and the corresponding physical hardware device. Any unique value duplicated between the virtual hardware device and the corresponding physical hardware device may be used to detect duplication and thus to detect virtual hardware devices.

If there are no virtual hardware devices decision block no leg the software may capture the driver for the physical hardware device or devices block . Also the software may capture any other properties of the device that may be used for the install if any e.g. the TCP IP settings of a NIC .

If there are virtual hardware devices decision block yes leg the software may identify the virtual devices and the corresponding physical devices block . Optionally the software may associate the properties from the virtual device with the physical device if one or more properties are found in the virtual device instead of the physical device block . For example for virtual NICs the TCP IP settings are found in the virtual NICs rather than the physical NICs in some embodiments. The software may then capture the driver and optionally other properties of the physical device or devices block .

Beginning with the embodiment of the software may obtain the service name the PnP IDs and the TCP IP settings for each NIC block . As illustrated at reference numeral the software may use the GetAdaptersInfo API in Windows2000 as well as the Registry to gather the information. In this embodiment if virtual NICs are included only information related to the virtual NICs is returned in the GetAdaptersInfo API. If virtual NICs are not used then physical NIC information is returned.

The software may analyze the PnP IDs to determine if any of them are legacy PnP IDs. For example in the present embodiment legacy PnP IDs may all start with Root . If none of the NICs are indicated as legacy decision block no leg then there are no virtual NICs and the flowchart of may exit to block in . The information obtained from the GetAdaptersInfo and the Registry includes the correct drivers as well as TCP IP properties in this case.

On the other hand if at least one NIC is virtual decision block yes leg the software may obtain the physical adapter information including the drivers used for each NIC from the Registry block . The key in the Registry that provides this information is shown at reference numeral . If the number of virtual NIC adapters identified in block is greater than the number of physical NIC adapters identified from the Registry decision block yes leg then at least some NICs have invalid internal use IP addresses e.g. IP addresses of 0.0.0.0 or autoconfigured IP addresses such as 169.256.xxx.xxx . The invalid adapters are eliminated block . With the remaining NIC adapters after the elimination represented by block or all NIC adapters if the number of virtual adapters is the same as the number of physical adapters decision block no leg the software compares the MAC addresses to identify virtual physical NIC pairs block . That is the virtual NIC and its corresponding physical NIC have the same MAC address. The software updates the TCP IP settings in the physical adapter information from the TCP IP settings in the virtual adapter information block . In this fashion the driver for the NIC and the TCP IP settings for the NIC are found in the physical adapter s information. The virtual adapter is replaced with the physical adapter block and the flowchart exits to block to capture the driver and properties of the physical device.

On the other hand if at least one virtual NIC is detected via a duplicate MAC address decision block yes leg the software may for each adapter that has a duplicated MAC address obtain the BusNumber from the Registry entry for that adapter block . Physical NIC adapters have a BusNumber in their Registry entries while virtual NIC adapters do not. Thus the software identifies the adapter having a duplicate MAC address and no BusNumber as the virtual NIC and identifies the adapter having that MAC address and having a BusNumber as the corresponding physical NIC block . The software updates the TCP IP settings of the physical NIC adapter with the settings from the virtual NIC adapter block and eliminates the virtual NIC adapter . The flowchart then exits to block capture the driver and properties of the physical device.

As mentioned above with regard to other embodiments may implement the network interface functionality on board rather than as a card. Thus while a NIC was used as an example in other embodiments may use any type of network interface hardware as an example.

Turning now to a block diagram of a computer accessible medium is shown. Generally speaking a computer accessible medium may include any media accessible by a computer during use to provide instructions and or data to the computer. For example a computer accessible medium may include storage media such as magnetic or optical media e.g. disk fixed or removable CD ROM or DVD ROM CD R CD RW DVD R DVD RW volatile or non volatile memory media such as RAM e.g. synchronous dynamic RAM SDRAM Rambus DRAM RDRAM static RAM SRAM etc. ROM Flash memory non volatile memory e.g. Flash memory accessible via a peripheral interface such as the Universal Serial Bus USB interface etc. as well as media accessible via transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link. The computer accessible medium in may be encoded with one or more of the restore tool the config edit tool one or more config save tools A N one or more client configuration files A N one or more backup images A N one or more create package tools A N one or more driver packages A M the output txtsetup.oem file the create txtsetup tool and or other software e.g. the software illustrated in one or more of . The restore tool the config edit tool the config save tools A N the create package tools A N the create txtsetup tool and the software may each comprise instructions which when executed implement the operation described herein for the software. Generally the computer accessible medium may store any set of instructions which when executed implement a portion or all of the flowcharts shown in one or more of and . In some embodiments a computer accessible medium similar to the computer accessible medium may be included in a client A N the BMR server the boot server the file server and or the backup server .

Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

