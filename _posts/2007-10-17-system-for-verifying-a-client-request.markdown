---

title: System for verifying a client request
abstract: A system and method are presented for authorizing execution of requested actions transmitted between clients and servers of a data processing system. The method includes receiving a message including a set of actions and simulating execution of the set of actions. A list representing allowable actions and user-definable inputs to the simulated actions is defined. The list of allowable actions and user-definable inputs to the allowable action is then compared to user-requested actions and inputs. When elements within the user-requested actions and inputs are included in the allowable actions and input list, the user-requested actions and inputs are authorized for execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07703127&OS=07703127&RS=07703127
owner: International Business Machines Corporation
number: 07703127
owner_city: Armonk
owner_country: US
publication_date: 20071017
---
Priority is herewith claimed under 35 U.S.C. 119 e from Provisional Patent Application No. 60 161 473 filed Oct. 25 1999 entitled METHOD AND SYSTEM FOR VERIFYING A CLIENT REQUEST the disclosure of which is incorporated by reference herein in its entirety. This application is a continuation of U.S. patent application Ser. No. 09 696 736 filed Oct. 25 2000 now U.S. Pat. No. 7 293 281.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever.

The present invention relates generally to privacy and security systems and more particularly to methods and systems for authorizing requests data informational content applications and other information transmitted between a client device and a host device within a data processing system.

In a client server data processing system a number of personal computers work stations portable and or handheld devices or the like clients are linked and communicate with one or more host computers servers . The servers process requests from the clients for information and or application programs shared by the clients over the network. Increasingly client server networks have been linked to form a wider network of networks including for example intranets and extranets that may themselves be a part of a world wide network namely the World Wide Web portion of the Internet web . The linking of networks permits clients to share resources e.g. information and application programs across the networks.

Along with an increase in the availability of shared information and application programs over potentially world wide networks there is an increase in the vulnerability of each of the individual client server networks. For example an unscrupulous person seeking to retrieve and or damage proprietary information and application programs stored on one of the networks may access the proprietary information and application programs and use them in an unauthorized way. In an effort to prevent such an unauthorized use many networks connect to other networks through firewalls. Conventional firewalls include hardware and or software systems designed to deal with access control to internal network resources e.g. a specific web server or a folder to limit access to portions of a network and to prevent unauthorized retrieval or damage to proprietary information and application programs stored thereon.

Many conventional firewall systems however do not deal with the authorization at an application level and may be defeated by an unscrupulous person masquerading as an authorized client. For example many web applications assume that the application user is in fact executing a mobile agent of the application on his her browser. However a malicious user can connect to a web server without using standard web browser software thus the user is not bound to any limitations whatsoever that may be forced at the browser side and the malicious user can masquerade as a standard client and send destructive or forged data to the web server.

In commonly assigned U.S. patent application Ser. No. 09 345 920 a solution for verifying requests from a user of a standard HTML document is described. The solution is based on extracting the set or pattern of actions HTTP requests the browser software may take based on the content of the HTML document authorized actions . This set of authorized actions is then matched against requests sent by a client application. Even if the user is not using one of the standard browsers only requests from within the legal or authorized set of actions will be passed to the web server.

In view of the foregoing the inventors of the present invention have recognized a need to extend the above described verification technique to logic e.g. JavaScript programs embedded into the HTML page executing on the client system on behalf of the web server. In particular the inventors have recognized a need for simulating executing of client side logic to capture and verify external data and events occurring thereon.

It is an object of the present invention to provide a verification technique for logic executing on a client system on behalf of a server system.

It is another object of the present invention to provide a verification technique for client side logic that simulates execution of the logic to capture and verify external data and events occurring therein.

It is a still another object of the present invention to provide a verification technique for client side logic e.g. JavaScript programs embedded into the HTML page . The technique simulates execution of the logic so that only authorized requests for external data and events are passed from the client to a protected server.

Further objects and advantages of this invention will become more apparent from a consideration of the drawings and ensuing description.

The foregoing and other problems are overcome and the objects are realized by methods and apparatus in accordance with embodiments of this invention wherein a system and method are presented for authorizing execution of requested actions transmitted between clients and servers of a data processing system. The method includes receiving a message including a set of actions or application programming logic e.g. JavaScript programs embedded into the HTML page and simulating execution of the set of actions or logic. A list is defined representing allowable actions and user definable inputs to the allowable actions. The list of allowable actions and user definable inputs is then compared to user requested actions and inputs. When elements within the user requested actions are included in the allowable actions and inputs list the message and included set of actions are authorized for execution.

In accordance with the present invention an authorization proxy system is coupled to and enforces a security policy protocol between the client and server . For example the authorization proxy system ensures that only authorized actions defined below are performed within for example requests messages data informational content applications and other information transmitted between the client and the server . The authorization proxy system simulates execution of commands fields user selectable input options HTTP requests and the like e.g. requested actions within the requests messages data informational content and applications transmitted between the client and the server and ensures that the requested actions are defined within a set of allowable actions e.g. authorized actions . Any actions not within the set of allowable actions are denied by the authorization proxy before reaching and potentially corrupting the target of the actions e.g. the server or client .

It should be appreciated that it is within the scope of the present invention to vary the implementation strategy of the authorization proxy. For example depicts the authorization proxy as a hardware component of the network separate and distinct from the server . In the authorization proxy is implemented as application programming logic plug in logic executing on a server . The server also includes plug in logic and for providing application programs informational content and data residing at the server e.g. contained in data store or on web pages to the client upon request. In accordance with the present invention the authorization plug in logic executes on the server to verify prior to transmission the programs content and data provided to the client .

Alternately depicts the authorization proxy operating as an intrusion detection system within a sniffer device coupled to a router or hub on a network . As is generally known the hub directs communications within a portion of the network . As illustrated in the hub isolates web server from direct communication over the network . The sniffer detects and intercepts transmissions targeting the web server . The sniffer executes methods described in detail below to evaluate the intercepted transmissions and to compare the actions requested within the transmissions to for example a list of authorized actions contained within a storage device . If not acceptable the sniffer alerts or passes a message to another system on the network.

While embodiments of the present invention are described as having particular application in web based applications it should be appreciated that it is within the scope of the present invention for the systems and methods described herein to be applicable within any client server communication systems and in particular communication systems where it is desirable to protect the server from unauthorized requests data and applications.

As described in detail below the authorization proxy of the present invention employs two techniques for verifying logic executing on a client system on behalf of a server system. In a first technique the authorization proxy simulates execution of the client side logic and invokes and or triggers each possible command field user selectable input option and HTTP request. As a result a full set of allowable browser actions are identified and used to verify subsequent requests from an actual client session. In a second technique the proxy traces execution of the client side logic during an actual client session. Results of the trace are transmitted to the authorization proxy within a request for server resources. In response the authorization proxy simulates execution of the client side logic and when input options or other requests for external data are encountered during the simulation the trace results are utilized. A successful simulation results in the approval of the client request for server resources and the authorization proxy passes the request to the appropriate server for actual processing.

The two verification techniques differ in the method in which they respond to the client logic s queries of unknown data and user intervention events. A detailed description of these techniques follows.

In a first aspect of the present invention the authorization proxy e.g. proxy plug in logic and sniffer invokes methods for evaluating transmissions between clients and servers simulating client side logic incorporated in the message originating from a client or a server e.g. JavaScript objects incorporated in a message from the server and extracting a list of possible requested actions. If the client sends a request the requested actions are then verified to a list of authorized actions. If the actions are acceptable the transmissions are passed onto the intended target such that only requests consistent with the intended application are performed.

At Block the evaluation process is invoked. The evaluation process includes for example a parsing of the HTML page to identify content and HTML tags as well as client side logic e.g. JavaScript code incorporated therein. Once the components present within the HTML page are identified the authorization proxy simulates execution of the components of the page e.g. a simulated browser environment so that all possible requested actions can be identified within the transmission and provided to the list of authorized actions.

The simulated browser environment includes a JavaScript runtime environment in which the simulated browser s Document Object Model DOM and browser objects are recreated Blocks and respectively. Some of the JavaScript standard objects need to be replaced as explained in greater detail below. The authorization proxy executes the components of the HTML page in the simulated environment. Hooks in the environment inform the authorization proxy of any triggered browser actions e.g. retrieving a document from web server or submitting a form to the web server. Once the simulation is completed these actions supplement the list of authorized actions that are matched against the client s actual requests at Block as described below.

As discussed some of the objects and their methods need to be simulated to represent the client browser environment. Foremost is the DOM which is created from the HTML document . Additionally there are browser objects such as Navigator which in Netscape provides information about the browser context and window. An enumeration engine at Block coordinates the simulation of the DOM and JavaScript components. Objects such as the time object random functions etc. are also simulated by the enumeration engine. All these objects need to be consistent with what the script would have obtained had it accessed them in the client s environment e.g. on the client browser . For example a text area in the DOM should return the value the user entered in the browser a random function should return the same value the client script obtained in the user s browser and the navigator.userAgent should return the name of the client browser .

As should be appreciated some of the data inputted to browser objects is deduced from the enveloping data e.g. navigator.userAgent can be obtained from the HTTP headers sent by the client e.g. within the original request for the HTML page . However some data is dependent on the actual scenario followed in the client side. An additional complexity is introduced in event handlers e.g. code executed in response to a user action present within the JavaScript. While JavaScript HTML script tags are executed once loaded some of the code e.g. the event handlers is only executed on user intervention. For example there exists an onClick event handier for many of the input controls in the HTML language. The corresponding event handler is only executed when the user selects e.g. clicks on the control.

The enumeration engine Block performs a coverage method. For example the engine assumes that by triggering all the events in the HTML page as well as performing multiple simulated executions on different possible inputs by the user it covers all the possible actions by the browser . As should be appreciated the execution time of this embodiment increases exponentially for scripts that depend on many input controls. It may also be difficult to handle the random function in this embodiment. The simulated execution proceeds until it requests user input. At which point user actions are required to record and simulate further execution with a variety of possible input values. This aspect of the simulation method is discussed in further detail below with reference to .

Once simulation is complete a list of all possible browser actions is provided that is consistent with the HTML page and associated client side logic originating from the server. These possible actions are aggregated and identified as legal actions in Block . The legal actions are utilized by the authorization proxy to verify the requested actions received from a particular execution of the HTML page at the client browser . At Block the client s requested actions are returned to the authorization proxy and compared to the list of legal actions produced from the simulation of the HTML page by the authorization proxy. Accordingly the authorization proxy accepts or rejects the client s requests depending on the presence or absence of the request and valid user input within the list of legal actions e.g. requested actions are denied if a corresponding legal action was not identified by the authorization proxy . It should be appreciated that the list of legal actions may be stored e.g. in the data store to accommodate a delay in receipt of the requested actions from the client browser .

With reference to the following describes options for handling request for user input and multiple possible inputted values within a simulated execution of HTML page . As discussed above at Block the authorization proxy simulates execution of browser commands and the client logic included within the HTML page . Simulated execution continues until an input control is encountered at Block or a request is made for other user input at Block . At Block a free text input command such as for example HTML tags is detected within the HTML page . If a free text input command is encountered control passes to Block where a unique place holder is assigned to represent input received from the client. The place holder assigned at Block is for example a field that is later recognized in the generated URL as input generated from a free text input command in response to a user action. At this later stage the authorization proxy performs a pattern match with received client requests Block of . The pattern matching is implemented so that it allows only safe expressions. A preferred pattern matching technique is derived from the HTML link extractor described in commonly assigned U.S. patent application Ser. No. 09 345 920. Hooks are embedded into the JavaScript environment which recognize branch decisions if statements based on strings which contain the placeholders. In such cases the execution is invalidated since this implies the input affects the logical procession of the script. The system can validate links if the place holder affects the generated URL directly by appearing in it or indirectly by affecting the program s execution flow.

Control passes from Block to Block or if no free text input commands are encountered from Block to Block . At Block the authorization proxy detects an occurrence of a command requesting input by the user from one of a number of possible input values. If such a command is encountered control passes to Block otherwise control passes to Block . At Block a first available value for an enumerated input control is assigned. Since other possible legal input value are available control passes to block where an entry is made in a backtrack log . The entry records the relative position of current execution within the HTML page e.g. depth in the execution as well as the remaining number of possible legal entries. It should be appreciated that the log permits control to loop back to the previous point of execution depth select a next value of the possible legal input values and continue execution with the next legal input value. By looping back and simulating execution of all inputs to the HTML page all possible browser commands and user inputs thereto are collected within the list of possible legal actions discussed above.

The execution continues at Block after logging the value provided. At Block the simulator detects an end of the code. If the end is detected control passes to Block for possible backtrack processing. If the end is not encountered control loops back to Block where simulation continues as described above. At Block the backtrack log is evaluated to determine whether possible additional input values may drive detection of further possible legal actions. If entries remain in the backtrack log the depth variable is utilized to relocate execution at one of the encountered multiple input commands. Once relocated a next value of the input command is assigned and simulation proceeds from the relative location forward to the end of the code. Such looping back execution continues until each value in the backtrack log is exhausted.

The inventors have determined that one implementation of backtracking in the JavaScript environment is to restart the execution with the same values until the backtracking point. Another legal input is provided at this time and logged. This process is iterated until all enumerated values have been processed.

As described above by aggregating all the browser actions triggered by all possible inputs and events during the simulation process the authorization proxy obtains a list of most if not substantially all possible requests from the client which are consistent with the script originating in the web server. In some embodiments this system is used as an auxiliary for the trace embodiment described below to obtain better performance.

where country is one of us or il according to country gender is a value of boys or girls and name is an input text field.

1. An examination of the document yields that the only event which executes JavaScript is clicking on the Get My Page button. The event is triggered. This is noted in the backtracking log with an annotation that this was the only event to trigger thus this entry is exhausted. Exhaustion is explained in more details in subsequent steps.

3. A value is supplied for the country in selectedIndex there are two possible values 0 for U.S. and 1 for Israel . The first is supplied and it is noted that a value of 0 was supplied at Branch A.

4. Execution proceeds to Branch B where the checked value of the Gender radio box is checked. There are two possible values true boys and false girls . A value of true is supplied and noted in the backtracking log .

5. Execution proceeds until Access C is reached where a value for the text field is required. A place holder is supplied. This place holder is a UNICODE string which cannot appear under normal circumstances. This place holder is marked as . There is no need to log this in the backtracking log since no backtracking is required over this value. The type of is noted as text of maximum length .

6. The JavaScript function open of the object window is hooked in the simulated environment to a function which records the requested URL. The constructed URL would look as follows 

7. The policy enforcer is informed of this new possible action with the associated annotation that can be matched against any text of maximum length .

8. The execution restarts. The same steps are followed except for the deepest backtracking entry Branch B where the value is replaced with the next possible value false. Since all possible values of Branch B have been exhausted it is marked as exhausted in the backtracking log .

9. Thus a value of girls is provided in the gender field and the generated link would be http site.us.perfectotech.com girls .html.

10. Execution restarts. This time Branch A is the deepest branch and its next allowed value is provided 1 for Israel.

11. Branch B is reached again this time no backtracking log exists so a re newed entry is logged and the first legal value is provided true boys .

12. Execution resumes in the same pattern the link obtained this time is http site.il.perfectotech.com boys .html.

13. This process continues iteratively e.g. one more time providing a value of girls for the gender field until all backtracking logs have been exhausted. Thus no more execution paths are possible.

In reviewing the JavaScript code a theoretical execution path is seen which could have generated the request http site.intl.perfectotech.com . . . this path was not taken since the DOM did not provide selectedIndex for country which was other than 0 or 1. This is an example of how both the JavaScript code and the DOM affect the allowed requests. Since there were only two possible values for the country the third execution path is not a legal path.

In a second aspect of the present invention the authorization proxy e.g. proxy plug in logic and sniffer invokes methods for evaluating transmissions between clients and servers. Firstly client side logic is instrumented by inserting code to trace an execution of the client side logic on the client system . Once executed by the user on the client system requests for server resources are received at the authorization proxy along with the results of an actual execution the trace results . The authorization proxy simulates execution of the client side logic and when input options or other requests for external data are encountered during the simulation the trace results are utilized. A successful simulation results in the approval of the client request for server resources and the authorization proxy passes the request to the appropriate server for actual processing. For example transmissions having acceptable actions are passed onto the intended target such that only requests consistent with the intended application are performed.

As described above the instrumented code traces the browser actions and returns to the authorization proxy within or in addition to a request for further action the results of the trace. When the client browser requests server resources the trace of browser actions e.g. inputs and events performed on the client browser are returned to the authorization proxy for evaluation. In this embodiment instead of enumerating on all inputs as was described above with reference to the simulation process outlined in the browser sends with its request a trace of all values the script obtained during an actual user session in the browser environment. The trace is maintained within the authorization proxy at a trace feeder Block .

Once the results of a trace are received the authorization proxy simulates the code and DOM components within the original transmission e.g. the HTML page at Block . As shown in the input to the simulation step include the original client side code e.g. client side logic without the trace supporting code the DOM components from Block and the trace results from the trace feeder from Block . When a traced object is queried in the simulated environment at Block the authorization proxy via a trace feeder checks for the traced values received from the client. The traced values are also checked against the logical content rules of the object e.g. a maximum number of allowable characters within a text field or a checkbox value that can only be one of two possible values true false any other value is illegal. The results of the simulation are a list of allowable or authorized browser actions that are passed to Block . However in this embodiment the authorized browser actions are based on values input and events from within the trace determined from a particular execution at a client browser and not all possible browser requests as described above with reference to the first verification process. The client actions passed from Block are compared to the authorized actions passed from Block at Block such that a decision can be made as to whether the requested action or actions of a particular client browser execution Block are authorized.

As should be appreciated the browser does not perform and or send results of a trace by default. Therefore the code e.g. HTML document sent to the browser is mutated instrumented in the aforementioned step performed at Block prior to simulation so that it will create and return the trace of the browser actions in the browser environment Block . An exemplary instrumentation process for the code includes 

The mutated code calls as .prop on get property of document.forms 0 to check that it s a form and then for the elements.day.value. The as .prop function checks whether the value should be traced as is in a value of a text field and adds the value to a trace variable. The set property is modified to add the trace to the requested URL. The as .init is added both at the head of the script and at the event handlers. When an event handler is triggered the event is added to the trace. Once the trace is sent to the authorization proxy it is processed as explained above.

Following is a description of the process where by the user chooses to purchase a ticket for Monday. The code has been instrumented as listed above. However the user sees a very simple form in his browser identical to the one he would have seen had the code not been instrumented 

Let s assume our user enters tuesday and sends the request by selecting the send button. What actually happens is as follows. In the browser 

Had a user of a client system e.g. a hacker operating client attempted to provide a value which does not constitute a legal input for a text field of size 20 e.g. a 21 characters input the trace feeder would have blocked it by marking it as an illegal input and stopping the execution. Had the user attempted to provide an illegal request then matching the simulated environment action with the actual request would have failed.

While the invention has been described and illustrated in connection with preferred embodiments many variations and modifications as will be evident to those skilled in this art may be made without departing from the spirit and scope of the invention and the invention is thus not to be limited to the precise details of methodology or construction set forth above as such variations and modification are intended to be included within the scope of the invention.

