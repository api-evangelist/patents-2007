---

title: System and method for projecting content beyond firewalls
abstract: A system and method for exchanging information between clients separated by firewalls is disclosed. A server may receive the information as posted through a browser client from beyond a first firewall and relay it to another client beyond a second firewall without lowering the security levels of the firewalls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407350&OS=08407350&RS=08407350
owner: Science Applications International Corporation
number: 08407350
owner_city: San Diego
owner_country: US
publication_date: 20070202
---
This application is a divisional of U.S. patent application Ser. No. 09 824 132 filed Apr. 3 2001 entitled System and Method for Projecting Content Beyond Firewalls which is incorporated herein by reference.

The present invention relates generally to the exchange of data between networks. More particularly the invention relates to sending information beyond a firewall.

Firewalls while protecting data behind them can be cumbersome to coordinate during the transfer of information between networks using them. Generally port 80 or 8080 is open to traffic sent to and received from the Internet. To establish a path of communication between computers separated by a firewall either additional ports need to be opened or a Virtual Private Network VPN by Alcatel Data Network U.S. Pat. No. 5 768 271 with additional open ports needs to be established. Due to regulations imposed by a company s information system department preventing reduced security it may not be possible to establish a VPN due to requirements to modify a firewall or open additional ports for a direct connection between the clients. Accordingly a system is needed to permit communication between two computers in which one or more firewalls exist between them that is easy to establish and maintain without affecting the security features of the existing firewalls as well as efficiently transferring data between end users.

In short if two computers are each behind firewalls there is no way for them to exchange data directly because firewalls hide them from each other and from the public Internet. By placing a server on the public Internet both computers can access the public server and the public server can relay the data between the two computers. The Hyper Text Transfer Protocol HTTP allows bi directional communication between a computer behind a firewall and an HTTP server computer on the other side of the firewall usually on the public Internet . HTTP does not allow communications between two computers each behind their own firewalls as it is always a client server server client communication paradigm. At least one problem associated with repeated posting and retrievals is the number of delays associated with attempting to retrieve repeatedly posted information. Simply put having a sender post information the central server expose the information for downloading then waiting for an end user to download the posted information leads to undesirable delays.

U.S. Pat. No. 6 104 716 to Crichton et al. relates to SOCKs aware firewall server and clients. One of the difficulties with the approach used in this patent is the need to modify the various transmitting and receiving entities to accommodate SOCKs as well as permit firewalls to accommodate SOCKs requests to open holes in the firewalls. However firewall administrators do not want to permit programs to open new holes in firewalls as this lessens the security provided by the firewall. Notably Crichton requires the modification of the firewalls to be SOCKs compatible. The proxy software communicates with the SOCKs proxy software existent on the firewall. Without the SOCKs proxy software on the firewall Crichton s communications are disabled or cannot be established. This requirement of the SOCKs proxy software forces firewall administrators to explicitly configure the firewall and maintain a list of authorized users to enable SOCKs communications.

Internet Relay Chat IRC is another data transfer system using the Internet that end users may use to communicate with each other. However IRC fails to protect the exchanged messages as they are transmitted without encryption. Further various intermediary servers that intercept the chat messages may determine the sender s address the receiver s address and the content of the message. In some cases the combination of these three pieces of information is sensitive if not confidential thereby rendering this process unusable for information that needs to remain secure. Accordingly IRC does not provide a satisfactory level of encryption for information. In addition IRC protocol typically communicates uses TCP port 194 which is often blocked by network firewalls.

A system and method for establishing and maintaining communications between computers communicating through at least one firewall is disclosed. In one embodiment a first application residing on a first computer generates information that needs to be sent to a second application residing on a second computer where the two computers are separated by two firewalls. An example is where the two computers are in firewall protected companies that intend to communicate quickly with each other over the Internet. The first application sends the information to a client on its side of the first firewall. The client encrypts the information and posts it using HTTP to an intermediate server located for example on the Internet. The intermediate server forwards the encrypted information to a second client beyond the second firewall. The second client next decrypts the received encrypted information and passes it to the second application on the second computer. The system may also use compression to conserve bandwidth and authentication of the various parties to ensure identities.

Other embodiments exist where for example the intermediate server is incorporated into one of the first or second firewalls. In this example the first firewall sends the encrypted information to the second computer without using a separate intermediate computer located between the two firewalls. An alternative embodiment includes the use of only one firewall separating the two clients with the server incorporated into the firewall.

Another embodiment relates to the modification of the client running on the first and second computers. The client may be a separate application that receives information from primary applications. Alternatively the client may be a set of externally callable routines a dynamic linked library DLL for example that may be accessed by the primary applications. Further the client may be a Java Class with multiple associated methods that may be accessed by the primary applications.

Numerous clients may communicate with each other using the system disclosed herein. For example a first client may encrypt a message using a public key for a second client and a public key for a third client. The message may then be transmitted to the server for transmission to both the second and third clients for later decryption. Using this embodiment joint collaboration over an encrypted system may be realized.

It is also appreciated that this system may be fully embedded within other systems. In these cases the other system s functionality will be enhanced to allow multiple computers to communicate the other system s application specific information from behind firewalls.

These and other embodiments will be realized as described in relation to the following description and related drawings.

The invention enables users separated by at least one firewall to communicate with a decreased level of difficulty. The invention will be described in relation to hardware and software. It is appreciated that the methods described herein may take the form of software as embodied in a computer readable form.

To assist the reader the following working definitions are provided. These definitions are not exhaustive and may be supplemented by well know definitions as well.

Client The software and associated computer hardware that passes data from the application to the server.

Attachment Established communication from a client to a server that is awaiting connection to another client.

Session HTTP communication with a server that is identified by a unique attachment identifier. A session may include multiple HTTP exchanges using the same attachment identifier.

Filtered Network A network with a firewall or other network device that selectively modifies or removes network traffic.

The system consists of two major components a client software component and a server software component. The system permits two software applications residing on separate computers connected to separate networks each with a firewall connection to a common network such as the public Internet to communicate with each other in a secure fashion through the firewalls via the common network. To accomplish this communication each of the two software applications contains or is linked to the client. The client associated with each application communicates through its respective firewall or firewalls to the server on a separate computer located on the common network. Data from each application is received by the server and forwarded to the other application.

The system design uses two specific functional or configuration characteristics common to most network firewalls currently in use. The first is that most network firewalls are configured to permit users on computers behind firewalls to access data e.g. web pages on the public Internet. This is accomplished by allowing two specific Internet Protocol IP communication ports Port 80 and Port 8080 through the firewall and then optionally screening data through these ports to assure that it has the proper Hyper Text Transport Protocol HTTP format used for conventional web communication. Attempts to access other ports and other data formats are often prevented by the firewall. The second is that many network firewalls may act as proxy servers to prevent the network IP addresses of computers behind the firewalls from being accessible or even visible from outside the firewalls. The network address of the firewall computer is used as a proxy or substitute for the network addresses for all the other computers behind the firewall thus preventing direct access to those computers from outside. Address translation may or may not be implemented in all firewalls.

A characteristic of HTTP communication that facilitates security is that it can be initiated from a computer behind a firewall. Once initiated data can be returned to the computer behind the firewall from a computer outside the firewall as long as the return communication is linked to the original outgoing communication. The client in an enabled software application initiates communication outward from behind its firewall to the server on the common network. This initiation may take the form of an HTTP post operation in which data from the application is packaged in an HTTP format and transmitted to the server through Port 80 or Port 8080. This HTTP post operation to the server may be performed by both enabled applications from behind their respective firewalls which has the effect of also opening return paths to each application from the server. Data received by the server from each application via the post operation is forwarded to the other application through the return path opened by that application s initial post operation and vice versa. Also a return path different from the forward path may be used.

In this way the server enables the two enabled applications each residing on computers behind separate firewalls to communicate bi directionally as if they are connected together over the same private network. Furthermore neither firewall needs to be modified in any way to facilitate this communication. By incorporating robust error checking and extensive authentication and encryption this technique permits highly secure communications without the disadvantages of other techniques that require opening additional ports in the firewalls or establishing a Virtual Private Network VPN which may introduce additional vulnerabilities to the enterprise security.

Referring to two clients and reside behind their respective firewalls and . Client may be a browser based client or a java based client. Client includes a commercial web browser for example Microsoft Corporation s Internet Explorer 5.5 or Netscape Corporation s Netscape Navigator 4.7 with commercial Java plug in . The browser communicates with client software in client . The client software also communicates with an end user application which may also be browser based or java based .

Client may have the same configuration as that of client . Alternatively client may have a different configuration as that shown in . Here client is a native based client with client software .

The native client software communicates with an end user application . Here the end user application is an independent application program.

Server is made up of a publicly available Java web server a system administration component and a data communication server . For example one may use the Sun Netscape IPlanet web server the IBM websphere server and the Jakarta Project Tomcat web server.

The data communication server implements the exchange of data between the client enabled applications and . The client and attaches to the application software and on each of two computers and that are connected to separate private networks and behind firewalls and . The server is installed on an intermediate third computer that is connected directly to a common network usually the public Internet . When exchanging data the application software the first computer behind firewall transfers a message to the client on that computer. The client then compresses and encrypts the message converts it to an HTTP post format and sends it through the firewall to the data communication server on the intermediate computer . The data communication server then forwards the message through the second firewall to the client on the second computer along the path of a previous HTTP post operation from the second computer . The received message is then decrypted and uncompressed and delivered to the second application software . Transfers between applications may be made in either direction.

The server system administration component allows system managers to add or modify users change connections monitor system performance and gather accounting information which is eventually stored in database . Further administrator functions are served by a publicly available web server here shown as a Java based web server .

As above the client is available in at least two different configurations a native client configuration and a Java client configuration. In the native configuration as shown in client the client exists as a set of externally callable application interface API routines. The application software connects to the client native configuration through calls to the API routines for sending and receiving data and may be written in any language that supports API calls. For example one may use a socket connection to access the APIs.

In the Java configuration the client is packaged as a Java Class with multiple methods in .class format. The application software may take the form of a Java applet and connect to the client Java configuration by including the client class in the applet and invoking the client methods for sending and receiving data. Data from application is transferred to client . Once in the browser based client an applet may access the server for communication of data from application . The client .class file Java configuration may also be used in standalone application software that is written in the Java language. Web browsers and assist in the administration of the access rights to clients and and in the invocation of a browser based client applet.

The following description relates to a number of embodiments. Further there are several logical extensions and enhancements that are considered part of the invention.

The computer on which the client and associated application software reside may be any type of computer such as a personal computer PC a workstation or an application server. For example a database server may be located behind a corporate firewall and accessed from computers on the same private network with the server from computers on the common network outside the firewall or from computers behind a second firewall on another private network. The clients and associated applications do not need to involve human interaction. For example two corporate transaction servers each behind their own corporate firewalls may exchange information on electronic business transactions. Clients may also be hosted on any electronic device capable of communicating on a network such as hand held devices printers modems etc. And the network between clients may be any combination of wired and or wireless networks. For example a Palm Pilot or other hand held computing device may use a wired or wireless connection to communicate with a personal computer or server located behind a company firewall. In this way a person traveling on business may synchronize their Palm PC or Palm OS device and information stored therein with a computer back at their office even though the office computer is behind a firewall. Devices may also connect to other devices. For example a hand held computing device may print information on an office printer. The hand held computing device may connect via wireless communications and print on a printer located behind a firewall.

As mentioned above any kind of networked computing device may host the client for communication using this technique. For the current implementation standard PCs are used. These PCs have the following configuration 350 MHz Pentium II 128 MB of RAM about 10 GB of disk space and Ethernet. For commercial software they are running Microsoft Windows NT Version 4.0 Sun Java Version 1.2 and standard web browsers. Computers of more or less capability may operate as clients as well. The processing overhead of this technique is small and results in minimal impact to the computer on which it executes.

The server software may execute on any computer outside the firewalls and on a network that is accessible to both communicating clients. The server function may be hosted on one or both firewall computers or on one or more separate computers on the common network.

The server may use a standard commercially available Web server and a Data Communication server. The commercial Web server serves all the web pages required for registration and system administration. The custom Data Communication server is responsible for the client connections and data exchange. The Data Communication server may be implemented using a commercial Web server. However a conventional Web server is usually much less efficient because it is not designed to directly support the internal data exchange function for separate client connections. Accordingly a simple web server for efficiently handling internal data exchange functions may be implemented that incorporate the additional data exchange factors.

The server is designed to operate on a standard computer connected to the public Internet. A standard computer may have the following configuration 350 MHz Pentium II 128 MB of RAM about 10 GB of disk space and Ethernet. The other commercial software that could be installed on the computer includes an operating system such as Microsoft Windows Version 4.0 a Java Virtual machine such as Sun Java Version 1.2 and Java Web server such as Tomcat. Computers with more or less capability may also be used to host the server software. Other computer types operating systems programming languages environments and web servers may be us used as well.

As mentioned above the network may be implemented with any combination of wireless and or wired networks. The networks may operate at various speeds and with various protocols as well. Communicating clients may use a protocol that is commonly allowed through their firewall or firewalls. Protocols may include SSL FTP mail HTTP and others. When using non HTTP protocols one uses the respective ports generally associated with these processes as well known within the industry. The two communicating clients could have HTTP access or equivalent thereof to the server through their firewall or firewalls. Alternative formats may be used however it is appreciated that having both clients using the same type of access to the server provides advantages by not needing separate translation of the implemented protocols. The server resides on a computer on a network with the ability to connect to private networks through firewalls.

The invention treats the application data as binary data which has the feature of supporting all types of data. There is no minimum data size or a maximum data size. So the system may be used for file transfer business to business electronic commerce transactions chat database server access and the like. It may also support streaming data such as streaming video or audio or real time conferencing. In short any type of information that needs to be exchanged may be exchanged with the invention.

The system administration may use a standard server and standard web pages to implement user registration and system administration as are known in the art. For increased security the web connection may be implemented using Secure Sockets Layer SSL . This encrypted communication technique allows users and system managers to securely enter information such as usernames passwords and server configuration data. Other secure network networking techniques such as VPN may be employed or in less critical application standard unencrypted protocols may be used.

The following discloses an overview of a nine phases for establishing data communication along with alternative implementations.

The client connects to the server via an HTTP post operation of a URL to the server. The client and server exchange information allowing identification of the client software including for example software version number a number provided by the server a registration number and the like and verification of client software compatibility and designation of a unique attachment identification identifying the specific client server attachment. Next the client and server establish a receive channel. A receive channel is a response to a post from the client that is opened by the server and may remain open until the communication is discontinued. This receive channel allows the server to send data to the client at any time. When no data is transmitted from the server to the client for a timeout period the server sends a short message to the client to keep the firewall from breaking the connection. Also if the client detects that the connection is broken it will immediately re establish the connection with another post operation. Alternatively communication from the server to the client may be done without this technique if data requests from the client prompted the server to transmit data at frequent enough intervals to allow smooth communications from server to client. However the receive channel approach is more efficient for both the client and the server and data communication can flow directly from the server without waiting for the client s periodic post.

After the client and server exchange software identification numbers and an attachment identifier but before any additional data exchange the client and server negotiate an encryption key. Various key exchange systems may be used such as a secret key exchange a secure socket layer SSL exchange or selection of predetermined keys. Further a variety of key sizes may be supported including 56 128 168 . . . 1024 2048 and the like. It is appreciated that using shorter key lengths speed key generation encryption and decryption while longer key lengths enhance security. To improve security the key exchange is done first so that all future communication can be protected with encryption.

Through the use of encryption one may minimize the amount of unsecured data transmitted between entities in the system. As above different mechanisms may be used to encrypt data.

Bi directional authentication between the server and the client may be used to verify that only verified members are using the system. Authentication is bi directional in that the server authenticates the client and the client separately authenticates the server. In one embodiment an encrypted password exchange is used. Authentication may be implemented with one of many authentication techniques. For example the entire process of key exchange authentication and SSL encryption may be implemented with VeriSign 40 bit or 128 bit encryption digital certificates and SSL. Also if security is less critical then the requirements for key exchange encryption and authentication may be relaxed or even eliminated.

Once the encryption and authentication are complete the client requests connection to another client. The server either makes the connection to the other client or asks the client to wait for the other client to attach. The server supports multiple clients waiting and communicating. Each client identifies to the server the other client and application for connection. The connection process may be implemented in many different ways. For example a fixed connection may be made between two business computers that require an on going permanent connection.

A client to client key is a secure key exchange between the two connected clients. In a first embodiment the clients connect directly with each other and establish a client to client key or directly exchange public keys of their own separate public private key pairs. This technique insures that client to client data cannot be compromised even with direct access to the server. As with other key exchanges mentioned above any key exchange technique may be employed for this purpose. As a second option a client to client key may be passed directly between clients without a secret key exchange.

The client to client key exchange can be implemented in many different ways. Also the clients create a client to client key that may be a single key or may comprise the public keys of a public private key pair. The key or keys may be transmitted to each other via email or the like by using the Internet or the key or keys may be exchanged by establishing a direct connection between the clients direct dialup or by transferring hard copies of the keys mailing a disk with the key on it to another client . A variety of key exchange schemes as known in the art are possible.

Pre establishing the client to client keys as described above save time by avoiding the key exchange and still provide encrypted client to client data. For very critical data the direct client to client exchange may be the preferred approach mainly because a new key is generated with each new connection. Another option is to operate without client to client key exchange and without client to client encryption. This option would allow applications to encrypt their own data or to use no data encryption at all. For less critical data no encryption may be required.

While connected the two clients may communicate with each other transferring large amounts of data securely through using the server. To assist with passing large amounts of data during this phase the system may compress the transferred data. Alternatively the data may be left uncompressed. While compression may consume processing time of the clients the size of the transmitted file will be reduced. With the reduced file size the transmission time will be diminished thereby alleviating the transmission load on the firewalls and and the server .

For example application transfers data to client where the client compresses the data and transfers the compressed data through server to client which decompresses the data and passes the decompressed data to application . Different compression algorithms may be employed. Compression may be performed before or after encryption. Further the compression system may also be eliminated if not needed or if compression may take too long.

In this example standard zip compression is used. Alternatively one may use other compression systems as are known in the art. After compressing the data the client encrypts the data with the client to client key and sends the packet via an HTTP post. It is noted that an HTTP get may also be used as well as other known sending mechanisms. The server receives the post decrypts the header using the received client to server key and then encrypts the header with the destination client to server key before sending the packet to the destination client. The destination client decrypts the header with the client to server key decrypts the data with the client to client key and decompresses the data. The client software then passes the data to the application. The clients and may simply receive and transfer the data without alerting applications and of the compression and decompression of the data. One benefit of not alerting applications and to the existence of the compression and decompression of the data is that it permits applications and to generate and process the data without concern to the state of compression of the data. On the other hand the system also includes an alternative embodiment in which the compression and decompression is handled by applications and . In this alternative embodiment the applications and compress and decompress the transferred data internally. An advantage of having applications and handle the compression and decompression is that the applications themselves may have a more efficient compression decompression algorithm as determined in size or lossyness . It is noted that shows communications between applications and . While not shown application may communicate with other applications and application may communication with other applications .

Either one of the clients or the server may initiate termination of communications. Any client or the server may send a message that causes the server to break the connection and prompts the clients to exit to the application. The application is notified if a connection is broken. Also an application may request that the client break its connection with the server. Reasons for termination include extended delay between transmission and receipt of the communication loss of connection with a client or to the server end of data transmission by one of the clients failure of one of the applications to process data excess garbled data on a communication pathway and the like.

As shown in there are at least three different network configurations where applications may need to communicate. shows private network with computers and behind firewall . Private network includes computers and behind a number of firewalls and . It is appreciated that firewalls and may be only a single firewall but are shown here to illustrate a variety of network configurations. Common network shows a number of computers and not protected by a firewall and connectable to server computer .

First when two computers and are on an unfiltered network no firewalls or other network traffic protocol filtering devices applications on the computers may communicate freely via standard TCP IP socket communications. An unfiltered network includes devices or systems that monitor and can alter or block network communications. A filtered network may have a firewall or another network filtering device that is configured to allow certain communication between known friendly computers. In this case the network is effectively an unfiltered network with respect to those computers.

In the second configuration one computer is behind a firewall and the other computer is outside the firewall . A third configuration has a first computer separated from a second computer by at least two firewalls and . The present invention provides a solution for addressing each of these configurations.

The server provides system administration functions that register clients and managers maintain and monitor the server. The interface for the system administration tools may use a standard version 4.0 or later web browser. The software may be implemented as Java Servlets standard HTML and JavaScript. The information requiring persistence may be stored in databases. SQL queries may be used to access the databases. All the pages that display user information or server data may use encrypted communications. For security in one implementation any pages that require a user to login before the pages are accessed may be accessible only after the user logs in. Accessing login required pages prior to logging in result in the display of an appropriate login screen.

The system may incorporate user registration pages providing form entry modification of information needed to register a new user. The registration pages may provide entry of a username an authentication password. As registration pages are known in the art they will not be discussed in detail. However it is noted that the password created in the registration pages may be used to encrypt and decrypt data. Alternatively they may be used to provide seed information for the generation of new encryption keys. The passwords may be used for authenticating the client and the server prior to exchanging data. The user may register the client with a server. Also the user may register applications with the client to alert the client for which applications to identify and direct content when received. User registration pages may be available to general users as well as to system administrators.

Various pages may be extended to users as need be. For example new users may register managers may approve or disapprove of new users may approve or disapprove of applications to be used with the system and the like.

Current connections are shown to a user. This display may take the form of a table that lists the current connections with information including the two usernames the identification of the application transmitting and or receiving data the amount of data transferred between the clients the start date time of the connection and the elapsed time of the connection. The current connections display may also allow a manager to request that connections or attachments be broken. The display may allow users to view connections that involve themselves and managers may view all current server connections.

The event display may show event data from the event database. The display may include text descriptions of events. The event display may support filtering to display selected types of messages. The event display may order the list according to the contents of different fields. Many possible events may be captured and different types of event displays are possible as are commonly found in the art.

Client to server communications pass through firewalls using port 80 and or 8080 HTTP protocol. The communications may be implemented using HTTP functions. These communications appear to the firewalls as standard web traffic including the use of standard HTTP headers and body data. The communications may be robust enough to immediately detect and appropriately respond to network delays or errors and to clients that unexpectedly break attachments.

The breaks in communications may be determined by the client or the server through monitoring heartbeat signals connection signals the lack of communication beyond a set amount of time and communication errors reported by the lower level socket communications software. As long as neither client has requested a disconnection the client and server may take immediate action to reestablish communications. For clients they will initiate post operations. The server will change states to begin waiting for a reconnect. After an extended period of time the clients and or server will give up and terminate the connection.

The following paragraphs detail the actions that make up the nine phases described above in the high level communication process. Since these actions are grouped in terms of their technical domain and not in their order of occurrence during system operation the associated phase numbers have been included for clarity. FIGS. and A C shows the data and control flow for these actions. These actions may be performed in various sequences and using various techniques. FIGS. and A C show a sample embodiment. Other embodiments may be used.

For example the following description relates to one embodiment where the system attempts to minimize dropped packets with significant error checking and other systems. Alternative embodiments include placing a priority on data throughput at the expense of data integrity or correctness. The alternative embodiments include video streaming where minor errors or data loss is acceptable in favor of performance. Also with respect to establishing communications the connections and or accepted keys may be established by a trusted third party. Of course all initial set ups may be client based or server based.

The client and server establish full duplex communications. The specific actions used to establish communications are shown in and are as follows 

1. Initial URL Request The client transmits a request to server to establish a connection. The client may use the HTTP post request to connect to the server . The client s identifier may be sent with the post data or may be sent at a later time. Versions of software may be passed. This request initiates the server to client session.

2. Server Response to Initial Request First the server verifies the initial request. If the initial request does not satisfy the requirements the request is terminated. If the server confirms the request it generates an initial connection identifier for identifying future communications to the server. This may take the form of information to be included in all future client to server posts. It may also include an attachment identifier. The connection identifier is assigned to identify this client session. The identifier may be a 32 bit integer that results in over 2 billion possible attachment numbers. This information may be encrypted on a rotating encryption schema as is known in the art to further secure the transferred information. The server formulates a response authorizing the session and transmits it to the client. If the server does not respond or the client does not receive the response within a timeout period the client automatically sends the initial request again. After a maximum number of retries the client reports an error to the application.

After the server sends the response the server waits for a timeout period for the next post from the client. If the server does not receive the next post within the timeout period the server frees memory allocated for the session and invalidates any assigned resources including but not limited to the attachment identifier. Further the server may require two or more levels of verification before assigning resources. This additional requirement furthers the security of the system.

3. Client Initiates the Receive Channel In response to the communication from the server the client authenticates the server. The client may verify the received information from the server including the resources and other information received from the server. The information from the server may include software identification information or a modified form of the information transmitted by the client. In the example where the modified information is received the client checks the information to ensure that the information was modified correctly further ensuring the verity of the server . Next the client sends a request to the server to establish a receive channel. The client posts to the server the asset identification information from the server which may include for example the attachment identifier in the post data. This initiates creation of the server to client receive channel. If the server does not respond within a timeout period the client automatically sends this post again. After a maximum number of retries the client reports an error to the application. In order to maintain a receive channel if the client detects that the receive channel is broken the client may send this post again to re establish the receive channel.

4. Server Responds to Establish the Receive Channel If the client sends an attachment identifier that does not correspond to an expected attachment identifier or if the attachment identifier is already associated with an active session then the server sends back an error code. If the client response is correct then the server responds with a message that becomes the receive channel. The server uses the attachment identifier to identify the server sessions associated with each message from a client. The receive channel is a response to the HTTP post that is kept open. This allows the server to transmit data at any time via this channel. One advantage is that to the networks and firewalls the receive channel looks like a long HTTP download of a binary file. This data passes through firewalls because it is standard HTTP. At the same time it allows immediate asynchronous transmission from the server to a client . This may dramatically reduce the delays associated with passing data through the server .

From a network and firewall perspective the server is passing a very long binary file to the client. The receive channel remains open until the server closes it the client disconnects or a network error breaks it. In addition the server may periodically send a short keep alive message also known as a heartbeat or ping signal to the client if there are no messages transmitted on the receive channel within the time needed to keep the channel open. The keep alive message also maintains the connection through the firewalls. A number of firewalls block an open receive channel if they do not see a response within a given period of time. The keep alive messages maintain the asynchronous receive channel by not allowing the firewall to timeout during periods of time when no data is passing from the server to the client. The keep alive message also helps the server detect if a client has exited as in the case of a user rebooting their computer during a connection or attachment.

At this point there is one active server session the receive channel. This session looks to the network like a large file that is downloading via HTTP. This apparent downloading continues throughout the time the client is attached to the server. If the connection breaks it is immediately re established by a new client post operation. Due to the characteristics of server and client post operations client to server communication cannot be implemented in the same way as the receive channel i.e. by maintaining an open channel . In this example each message from the client to the server must be a separate post to the server. The messages from the client to the application include the following types of notification an invalid or out of date client software identifier incompatible client and server software server not responding and communication established.

A unique encryption key is generated for each new connection. A secure public key exchange operation is employed to exchange secret keys and to agree on an encryption key. The final encryption key may have many sizes depending on the level of security required. Good security may be obtained with 56 bits and 128 bits. 256 bits and longer 512 1024 and longer and all sizes there between produce security.

1. Client Initiated Key Exchange The client initiates the process to agree on a key length and a key. Also where key length is previously specified e.g. 56 128 256 and the like only the key itself needs to be negotiated. The key exchange takes place with a post to the server. The Java provided Diffie Hellman method may be used to agree on a secret key. If at any time during the communication an incorrect message is received then an error message is sent to the application and all communication is terminated. Once the server receives the key all future client server communication is encrypted using the client server key. Further this process may take place repeatedly with different seed information to regenerate the key. Messages may include 

When the server sends a connection established message to each of the associated clients full data communication is established between the two clients. After the connection is established the clients may optionally choose to invoke a client client key exchange agreement. There are three options for client client key agreement. The choice of option may be predetermined as well as negotiated between clients. For example the highest desired encryption level between both clients may be automatically chosen. The application software indicates to the client which key agreement option to use when it calls the client to establish the connection. The available options are 

1. No encryption The first client passes a message to indicate that the client will not encrypt the application data. This option may be used for applications that choose to encrypt their own data or for data that does not need to be protected.

2. Pass Key Through the Server The first client passes a message that contains a new client client key 168 or 256 or other know sizes . This key is encrypted with the client server key unencrypted by the server re encrypted with the destination client server key and delivered to the destination client. After this exchange both clients use this key to encrypt the application data.

3. Blind Server Key Exchange The client to client key exchange uses a similar process used in the client server key exchange.

Alternatively other key exchanges as are known in the art may be used to add further security. For example emailing keys direct dial up connections sending a key via regular mail on a diskette and other known methods of exchanging keys between clients are alternative methods of exchanging keys.

The blind key exchange allows encrypted communication between two clients that cannot be viewed from the server that relays data between them. A standard public key exchange is used between the two clients with all the packets relayed through the server. Messages related to key exchange include 

1. Client Sends Destination Request The client sends a request for connection to another client by posting a message to the server . The request includes the encrypted destination username and the identification of the desired application. The client may request a connection to a specific client . Also the client may make itself available for connection. This may be done by a number of means including but not limited to by posting a wildcard symbol . The use of the character for the username by a client indicates that the client will accept connection from any other client component requesting its username and application ID. For example client may request to connect to with an application ID of foobar . Client may connect to client by specifying the destination username of client and an application ID of foobar . If both clients specify as the destination username then no connection is made as both are being passive and not initiating a connection.

2. Server Verifies the Username The server verifies that the client s destination username the user name of client is a valid name registered in the username database. If both of these conditions are not met the server responds to the destination request with an error message and terminates the attachment between client and server .

3. Server Checks Current Connections The server checks the list of active connections to confirm that no current connection has the same two usernames and application ID as the requested connection. In one implementation a connection name is constructed from the clients usernames and the application ID and checked against a list of connection names maintained by the server . Other methods may be used as are known in the art. If an identical connection already exists then the server returns an error message to the client and the connection request is aborted.

4. Server Check for Current Attachment The server checks for an attachment awaiting connection that has the same connection information i.e. clients usernames and application ID . If a matching attachment is found then the server makes the connection i.e. sets up the internal data structures and inter thread communications and notifies both clients and of the connection.

The server may find a preexisting attachment made through communication and connect clients and . Server may also request client attach to server based on an attempted connection by client . This request is shown in dotted line as message .

5. Server Waits for Next Attachment If the server does not find a matching attachment then the client and its associated connection information are registered as an attachment. The server sends a message to the client indicating that it is waiting for connection. In one embodiment there is no limit to how long a client may wait. Alternatively the client may terminate any attachment when no connection is made within a predetermined period.

During this process the client may send the following message to the server Connect to destination user and application ID . Messages from the server to the client and subsequently passed on to the application include Cannot connect a client to itself Destination client username is not registered Requested connection already exists Connection made begin communicating and Other client is not available please wait .

1. Client Sends Data After a connection is successfully established the clients can transmit data for the applications on either end of the connection as shown in path . This transmission and reception system is shown in greater detail in . Standard error checking and transmission control protocol internet protocol TCP IP may be applied. To reduce transmission time the clients may compress the application data in the transmission packet. Once the data is compressed the clients may optionally encrypt the application data with a client to client key. Each client encrypts the packet header with a unique client to server key. So for each packet the header is encrypted with a client to server key and the data is compressed and optionally encrypted with a client to client key. The packet number is encrypted along with the application data. Once encryption is complete the client sends the packet to the server.

In order to protect all the information and minimize vulnerability to hackers different elements of the information are encrypted with separate keys to control which computers may process them. The client to client information is protected even if the server is compromised because only the two clients have access to the client to client encryption key. The server needs to have access to the packet header so that it may verify and forward the data to the correct client. The packet header is therefore encrypted separately with a client to server key for each client.

2. Server Receives Data The server verifies that a packet was received correctly and that it may be transmitted to the destination client. If a packet is correct the server uses the destination client server encryption key to encrypt the header and then writes the packet to the destination client buffer for transmission. The destination client buffer is a first in first out buffer that stores the packets prior to transmission to the destination client.

After successfully receiving a packet and assuming the destination client buffer is not full the server sends a message to the source client indicating that the packet was received and that another packet may be sent. This message is implemented as a response to the source client s POST. If the destination client buffer is full the server will send a message indicating that the packet was received but telling the source client to wait before transmitting the next packet. In both of these messages from the server to the source client the server includes the sequence number of the last packet received by the destination client so the source client knows that it was received correctly and empty its own send buffer.

3. Server Sends Data The server takes the next packet from the destination client buffer encrypts the header data with the destination client s client to server key and transmits it message to the destination client except via the receive channel. Except for verification that the entire packet was received the server transmits the application data without processing it. The packet sequence number added by the source client is retained and sent to the destination client with the data. If the server detects that the secure channel was lost during packet transmission the server will wait for the client to reconnect and retransmit the packet.

4. Destination Client Receives Data Clients continuously monitor their receive channels for errors. If an error is detected the client reestablishes the channel with a post to the server . Any packet that is partially received when a channel error is detected is discarded. When a packet is fully received the destination client decrypts the header with the client to server key. If client to client encryption is enabled the client also decrypts the application data with the client to client key. If the data is compressed the client decompresses it to produce the original application data. The destination client then makes the data available to the application. In response to receipt of the packet the destination client sends a reply message to the server via a message post. This message may contain any or all of the following information for the server a simple statement that all information received the total number of packets received and the number of the last valid packet received.

5. Server Receives Confirmation of the Receipt of the Data Packet When the server receives the post from the client that the packet transmitted in message has been properly received the server removes the associated packet from the destination client buffer. The server then responds to the post by sending the number of the last packet received to the other client . The server responds to a post to remain consistent with HTTP. This mechanism allows the client to empty its buffer of transmitted data as the confirmation indicates the remote client received a previous message.

Since the destination client buffer now has room for at least one more packet the server sends an OK to Transmit or resume message to that source client if the source client had previously been told to stop transmitting. This message is transmitted via the receive channel.

Messages between clients and and server associated with Connection Communication include the following 

Every message sent from a client to the server to another client follows a common message format. The format includes a header and data. The header includes standard header information including but not limited to header length message length asset identifier the names of both clients and the application ID. The header may also include time and date stamps verified location IDs message types attachment identifiers packet numbers CRCs and pre compressed data size for the message. The header may or may not be encrypted and in some instances only parts or none of the header information may be encrypted. For packets containing application data the encrypted part of the header if used may also include the packet identifier sequence number and its uncompressed size. This uncompressed size allows the destination client to allocate space for the data when it is decompressed. The header is followed by additional data that depends on the message type. For client to client application data messages it contains the application data. The message length includes the header length plus the data length. The destination client buffers partial data packets application data blocks may be broken into multiple smaller packets by the transmitting client and reassembles them to provide the entire data block to the application.

Further the data structure transmitted from the clients to the server may include the encrypted header described above. The headers may be encrypted with the client to server key and data encrypted with the client to client key. The data structure transmitted from the server to client includes the header encrypted with the client to server key and the data encrypted with the client to client key. It is noted that there may be a generic client to server key. Also there may be two keys client to server and client to server. Further there may be four keys associated with the server client to server key client to server key server to client key and server to client key. When using keys involving the server the information encrypted with the keys are less secure as the server may decrypt the information.

Either one of the clients or or the server may terminate communications. The client or may send a terminate message to the server or to the other client directly or the server may terminate an inactive connection. The manager may also use the system administration pages to remove a connection or request the server to remove an attachment. If an application wants to disconnect the associated client or will notify the server with a post operation. The server replies to the post with a disconnect acknowledgement message. The server also sends a disconnect message to the other client if a full client to client connection is already established. The other client is notified via its receive channel. When either client receives a disconnect message it discontinues communication with the server and alerts the application.

The server then monitors the receive channels and waits for the clients and to break the connections. When they are broken the server terminates the connection threads and frees the connection attachment data structures. When a client the server or a manager terminates a connection all disconnect messages to the clients are sent via the receive channels.

Data communication including client names passwords message types and message data is encrypted every time it is transferred across the network. The application data may be optionally encrypted. Various encryption systems may be used. Triple DES is described herein. Other encryption systems that may be used include SSL.

Besides the encryption decryption required for the DES two encryption algorithms are required. Both the client and server call routines for encryption decryption. These are used to encrypt decrypt header data and application data utilizing the appropriate keys. Each send receive HTTP session pair attached client uses the same encryption key.

1. Client Initiates Client Authentication The client reads a user configuration file or the application software may query the user for the user information or the user information may be obtained by other methods known in the art. The client sends the username and user password to the server.

2. Server Authenticates the Client The server queries the user database for the given username and verifies that the username is valid and that the user password is correct. If either the username or the user password is invalid a user password error is returned and client session on the server is terminated. Messages may include 

1. Server Sends Authentication Password If the client sent a valid username and password then the server returns a message containing the server s password that corresponds to the client.

2. Client Checks Server Password The client compares the password provided by the server with a local password. The local password may be stored in a file on the application computer entered by the user or derived by other methods as are known in the art. If the passwords match then the server is authenticated and the client may begin passing data. If the server password does not match then the client discontinues communications with the server. No disconnect message is sent to the server if the password is incorrect.

A variety of different authentications may be used as are known in the art. In some embodiments authentications that include digital certificates may be used.

After successful two way authentication i.e. client server and server client the client is attached to the server. The attachment key selection and authentication are complete and the client may request connection to another client.

The client interface component is the portion of the system that application integrators use to incorporate this capability into their applications.

The Java based client interface is used for web based applications that run in a browser or for stand alone Java applications. The code is written in Java and compiled to a jar file. The Java based client interface class contains procedures to initialize the connection to the server transmit data receive data and close the connection. It implements the following procedures 

This procedure returns either an error code and text message Example 100 server not responding or a completion code and text message Example 100 Connection complete .

This procedure returns after the server has replied to the post message with an Okay to send message. Otherwise it returns an error. If the data is larger than 10K bytes then the procedure may separate the data and transmit it in multiple packets.

This procedure sends a message to the server to request that the attachment and any corresponding connection be terminated.

A similar pathway exists from client to client . Here data is encrypted in client resulting in encrypted data and transmitted from client to the server considering client to have moved into a client out session . The server transmits a response back to client to indicate that the data has been received. Next the data passes through a FIFO over path in which it eventually reaches the client in session over path . The data is transmitted to client where client decrypts and passes the decrypted data on to its respective application or applications.

Initial connections with the server are made by the initialization communication phases and for the transmitting states of the clients and . As to the receiving states the initial connection made by client to the server is shown by initial connection and connect URL path . A similar initial receive connection by client is shown by initial connection and connect URL path .

It is noted that the clients may separately connect to the server for receiving and transmitting or may use only one connection. In other words the invention includes all of communications and being present or less than all shown communications to establish the connection with the server. For example communications and may exist to establish a connection between client and . However the system would use the same established pathway to communicate in the other direction as opposed to requiring clients and to initiate communications and . Here the clients are responsible for keeping open the communication pathway between the client and server. For example the client may continuously poll the server for new data.

An alternative method of keeping open the pathway between the server and client includes the server repeatedly transmitting a packet of information to the client thereby keeping the client s firewall from closing the established pathway.

Also the data may or may not be encrypted based on the security level required. Also the data transmitted between client and client intact or as modified or truncated or added to by server may be compressed and decompressed to minimize bandwidth consumption.

The code may be written in a number of different languages including C C Java and the like. In one embodiment the code is written in Java and compiled into native PC Windows object code. The native client interface implements the same functionality as the Java based client interface. The native client interface compiles into a form that is capable of being called from native executable application software without need for a Java virtual machine. Because it is compiled into native machine code this component does not require a Java virtual machine for execution. This software consists primarily of the generic applet I O source code with modifications and additions required to make it a stand alone library component that is callable from C or C .

Distributed systems communicate through a variety of different communication protocols. Many of these protocols are typically blocked by firewalls. Examples of standard communication protocols include Java Remove Method Invocation RMI Structured Query Language SQL queries Common Object Request Broker CORBA Distribute Common Object Model DCOM and X Windows. Several techniques may be employed to interface with these applications using protocols. Three different approaches are described below.

1. Call Routines Applications may call the client routines directly. These routines are detailed above.

2. Proxy Routines Special proxy routines may be created that directly correspond routine name and parameters to the standard communication protocol routines. These proxy routines may transfer the call name and parameters through firewalls to another proxy routine that makes the actual call to the standard communication routine to communicate with the destination client. The returned data is then transferred back to the initial proxy routine and returned to the client application. In this way an application may make standard calls to standard communication protocol routines. The call data and responses are passed between clients by the proxy routines.

3. Port Replication The port replication approach is similar to the proxy routines except that all communication to a specific standard communication protocol port is captured transferred and replicated on the destination client s local network. The sending client uses unmodified standard communication routines. However instead of communicating with the destination client directly the client communicates with a local port replication computer on it s local network. That local computer has port replication software that receives data on the standard communication protocol port. It then transfers the data to a remote port replication computer on the destination client s local network. The remote port replication computer sends the data to the destination client using the appropriate port. In this way the communication is captured on one network transferred and then sent out on a destination client s local network. One advantage of this approach is that is does not require modifications to the application software except to allow it to communicate to from a local port replication computer. The port replication software may execute on the client computers along with the applications or on other computers located on each client s local network.

The server test set is software that may be used to test the operation of the server software either as a standalone component or as a system across multiple computers and networks. It may be used for functional testing load testing and performance testing over a wide variety of system configurations and test conditions. The server test set operates by simulating from one to many clients that access the server according to a scripted scenario that allows the user to establish the full spectrum of normal operating conditions for numbers and frequencies of clients attaching connecting and disconnecting as well as packet sizes encryption methods and data rates for the simulated connections. The server test set may also be used to inject various types of error conditions that simulate a variety of client computer failure modes and network errors. By varying these different parameters the server test set may be used to create a complex and dynamic environment that is very realistic for rigorous testing of the server. The server test set may also display the test parameters and the system status to the user during the operation of a test. It may execute on the same computer as the server software or may operate on one or more separate computers either in front of or behind one or more firewalls. This permits realistic performance and load testing to be done with production computers over production networks prior to releasing the server for production in a particular application.

The data that defines a test scenario may be entered into an Excel spreadsheet or other user interface and saved as a data file or as an array of records. Each row in the spreadsheet or record may define the behavior of one of the simulated clients. For example a file with 100 lines may define a test scenario with 100 attachments and up to 50 potential connections. The server test set may use this file or array to perform the test.

In addition the single server system disclosed above the system may also include multiple servers to allow for continued operation in the event of a server failure. In this event the system may be implemented to provide fault tolerant operation of the server such that failure of a server that is serving two or more clients causes reversion to another available server to automatically reestablish all connections without loss of data. Possible failures include unanticipated disruption of the execution of the server software due to software or operating system faults hardware malfunction of the server computer interruption of electrical power to the server computer interruption of network communication to the server and others. One implementation for fault tolerance is to incorporate a list of servers in each client. This list may either be built into the client or downloaded by the client during setup at run time or at another time. When a client is ready to attach to a server the client opens an attachment with the first server on the list. If that client s destination client is already attached then the two clients negotiate a connection and begin communication. If the destination client is not attached then the client opens another attachment with the next server on the list and so on until it has either opened attachments on all of the servers on its list or it connects with its destination client on one of the servers. As soon as a connection is made both clients release any other attachments they have open on other servers. In the event of a server failure both clients go to the next server and begin reattaching until they make a new connection. With the data verification and retransmission logic built into the client software both clients hold and resend any data packets that are lost when a server failure occurs. Including the fault tolerance logic in the client software simplifies the server design and improves system performance because it does not require any communication among servers for live backups connection hand off or data retransmission.

Server backup may exist for servers in pairs as well. For example two servers may be used in place of server as described in . Each of the servers may forward information primarily or exclusively in one direction a first transmitting data to client and a second transmitting data to client . In this example a failure of one server or disruption in connection with the server may require that both servers be replaced. Alternatively only the problem server may be replaced.

This approach for server fault tolerance may also be extended to optimize the selection of communication paths for clients automatically. When a client is performing its initial attachments to the servers on its list it may also measure the performance of each attachment in terms of communication speed and latency. When the two clients begin to negotiate their connection they sort their joint server list based on the highest to lowest combined performance for those two clients for each server on the list. They then make their first connection with the server offering the highest combined performance connection and revert to the next lower performing connection if that server fails and so on. This approach is particularly effective when the servers and clients are geographically distributed with a number of different physical connection points to the Internet or other common network. Alternatively the clients may connect to all servers at the same time then pick the server with the best time or other criteria for example low error rate highest up time and guaranteed quality of service QOS high security rating and the like and disconnect from the others.

With the existence of additional computer B and or additional ISP B another embodiment of the invention is realized. The end computers may have multiple links to a number of computers or ISP simultaneously. Here the communication pathways between end computers may be varied periodically randomly or pseudo randomly thereby establishing communication path diversity. This variation in the pathways provides for enhanced security for the transmitted data because interception of data at one server may be useless without all the data transmitted between end computers.

In the foregoing specification the present invention has been described with reference to specific exemplary embodiments thereof. Although the invention has been described in terms of various embodiments those skilled in the art will recognize that various modifications embodiments or variations of the invention may be practiced within the spirit and scope of the invention as set forth in the appended claims. All are considered within the sphere spirit and scope of the invention. The specification and drawings are therefore to be regarded in an illustrative rather than restrictive sense. Accordingly it is not intended that the invention be limited except as may be necessary in view of the appended claims.

