---

title: Method and system for policy enabled programming
abstract: A system and method for allowing external execution-time adaptation of application behavior of an application in a telecommunication system without modification to the application code comprises an application having at least one break point and residing on an application server, at least one identifiable decision engine, and a listing of break points that has for each break point at least one identifier of the decision engine, such that at one of the break points, the application accesses the listing of break points, invokes the listed instances of the decision engine corresponding to the break point, and adapts application behavior based on the decision engine. In addition, each entry in the listing of break points can have a sequence number so that if two entries for the same break point have equal sequence numbers, the decision engines identified in these entries can be invoked in parallel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08448159&OS=08448159&RS=08448159
owner: TTI Inventions C LLC
number: 08448159
owner_city: Wilmington
owner_country: US
publication_date: 20071102
---
The present invention relates generally to programming of communications information and entertainment services.

Software applications written in a traditional manner have all the functionality defined within application code. Once such applications are deployed the providers offering the applications have little leeway to affect the behavior of the application. The application may have a few parameters that can be adjusted but generally the behavior of the application is fixed unless the application code is modified.

Service providers wishing to address dynamic markets need the flexibility to offer new services rapidly. The cycle time associated with modifying application code can slow the process down unacceptably. Therefore there is a need for application code in which the behavior can be modified without waiting for a software release.

Similar motivations were involved in the development of the Intelligent Network and Advanced Intelligent Network concepts for constructing telephone network services. It was possible to build new services by changing the code within the telephone switch but this was rather slow and cumbersome. The approach chosen was to precisely define the call model that specified the state of the telephone switch software in establishing a connection between two parties. At various points in the call model the telephone switch could be configured to query an external service control point for instructions on how to proceed. New service functionality could be produced by changing the behavior of the logic in the service control point without making changes to the software within the switching system itself.

This approach is highly dependent on the common call model that specifies the state of the switching system and the expected behavior. Such a call model could be defined because the process of establishing calls is consistent from one system to another. Definition and agreement of the call model took a substantial amount of time which was tolerable because the processing of telephone calls was relatively static over time. In environments where providers are offering new and varied services on a frequent basis it will not be possible to define such a detailed model for the internal states of the service logic. While this common call model technique has desirable characteristics it cannot be applied directly to the processing of emerging new and varied services.

Telecommunications equipment vendors and operators addressed a similar problem in adding features to call processing systems. The agreed upon solution the basis for the Advanced Intelligent Network AIN defines another common call model as the basis for processing the establishment of telephone calls. This common call model provides a pre defined set of events where external systems can be queried for decisions. U.S. Pat. No. 5 940 487 Programmable call processing system and method Bunch et al. for example illustrates this approach on a distributed telecommunication switching system coupled to AIN. This separation of service switching points switches which process calls and service control points which process service logic allows new calling services to be defined without making changes to the software within the switch. This approach worked well for controlling telephone calling in the circuit switched networks and was extended into next generation packet switched networks through the results of industry forums such as the Parlay Group specifications and the Java Community Process JAIN specification. The fact that there is a need for such standardization is indicative of the limitations of this approach in that it deals with a specific functionality call control and requires advance agreement and or standardization to function. Thus this approach is appropriate for application functionality that is static over time.

In U.S. Pat. No. 6 970 901 Device and method for swapping out a part of a service logic program Moritz teaches a mechanism for distributing service logic across multiple entities. Moritz specifically focuses on making use of the increasing capabilities of intelligent terminal devices acting as client terminals by distributing a portion of the service logic to the client terminal. Moritz discloses methods for using this distributed approach for determining charging related information. Distribution to client devices can enable personalization but does not easily enable modification of the behavior of an overall service because the change would have to be propagated to all of the client terminal devices. Enabling distribution for a single topic such as charging is simplified because the communication mechanism the charge ticket in Moritz can be defined and coded in advance. Thus Moritz addresses the need for flexible service logic programs but in a very limited domain.

In U.S. Pat. No. 6 967 957 Architecture for the rapid creation of telephony services in a next generation network Anjum et al. describe an object oriented call model which hides the detail of the underlying call state management protocols and hardware from applications . Specifically Anjum et al. describe a new call model that is designed to be abstract enough to represent call control in both circuit switched and packet switched telephony networks. Such a call model is more flexible than the Java Telephony Application Programming Interface JTAPI model on which it was based but still represents a single functionality. Thus this model is not applicable in the more general case where the behaviors are not as well defined or known clearly in advance.

The Policy Evaluation Enforcement Management PEEM effort within the Open Mobile Alliance OMA as specified in the draft requirements document Policy Evaluation Enforcement and Management Architecture OMA AD Policy Evaluation Enforcement Management V10 200600625 D describes an architecture for policy evaluation and execution as support for the OMA s service enablers. These enablers include functions such as group list management messaging and location. The architecture is designed to provide a common framework for these enablers to query for a policy decision. Such a capability would be useful although not required as a building block for the policy enabled programming described here because it would simplify the process of mapping interfaces between systems. The OMA work however does not specify how an enabler would determine when to query a policy engine the PEEM enabler or which policy engine to query.

Another approach is that supported by workflow systems. In these systems which are often applied to complex order processing the set of processing steps is defined in textual fashion that is interpretted at run time rather than compiled in the manner of software code. This provides flexibility in that the workflow can be modified without changing the code of the workflow engine. However the interpretation operation is inefficient leading to performance that is adequate for order processing but generally insufficient for the execution of actual services.

Database systems provide yet another mechanism where triggers and stored procedures can be invoked to execute logic providing a great deal of flexibility. However the operations where the stored procedures can be executed exist only for database operations of insert delete update and select on the data in the database. The problem with this approach is the restriction for database operations the entire specification is within the database system and not easily referenceable or modifiable unless one navigates through the data and the associated triggers and stored procedures.

Hence current processes are restricted to specific types of software applications e.g. call processing and have required advanced agreement and or standardization of the application processing model before they could be used. Other current processes exist only within middleware such as databases or workflow systems which limits their scope and does not meet performance requirements for service execution.

Thus there is a need for a system capable of determining dynamically when and where to query an external descision point such as a policy engine. There is also a need for a structured and efficient mechanism for configuring such dynamic queries characterized by breakpoints that can be configured to a controlled set of options.

The present invention advantageously provides a design architecture and methodology for building and deploying application software that allows the behavior of the application to be adapted or configured during execution without making changes to the application code. Reuse of a single software application multiple times for different purposes by configuration or adaptation of the application is provided. Furthermore the inventive system and method enables rapid deployment of new service behaviors because they can be delivered without the delays associated with the software development cycle.

A system and method for allowing external execution time adaptation of application behavior of an application in a telecommunication system comprises an application having at least one break point and residing on an application server at least one identifiable decision engine and a listing of break points that has for each break point at least one identifier of the decision engine such that at one of the break points the application accesses the listing of break points invokes the listed instances of the decision engine corresponding to the break point and adapts application behavior based on the decision engine.

The listing of break points can be a file external to the application and can contain attribute mapping for each identifier and an action type for each identifier and in addition can dynamically map the break point to the decision engine.

A system and method to allow external execution time adaptation of application behavior is presented. The key characteristics of this approach are that it provides application developers with the performance associated with compiled code as well as the flexibility to define the decision points and possible actions within the application flow allows for dynamic mapping of those decision points to external evaluation engines and enables application behaviors to be configured as the application is being deployed or even while the application is executing rather that only during the design and development of the application.

There are two specific mechanisms that support such a system and method. The first is an external table such as a break point configuration table. The application reads this table when it reaches a defined break point during execution to determine what actions to take. The entries in this table can be defined separately from the application and even changed while the application is running based on knowledge of what attributes or variables the application has defined at a given break point. The second adaptation method is contained in the external systems. The logic policies and or rules within these systems will create responses that will influence the subsequent flow and behavior of the application. With these two mechanisms the behavior of applications can be significantly modified without having to re write or modify the application code.

Note that the external system could also be a workflow system database system or even another software application. The fact that the mapping can be changed to point to different software applications provides flexibility even if the decision points are hard coded in the policy enabled application .

There are many ways in which a policy enabled application may react to the response it receives from an external policy engine . Building an application that gives an external system complete flexibility in determining its subsequent behavior would be extremely difficult and error prone. Through appropriate limitations on the range of action types or options however the complexity can be kept at a manageable level. Specifically the application could be designed to support a limited number of action types based on the response provided by the external system . Examples of these action types could include a fork or two way decision point action a null action and a variable replacement action.

In the case of a two way decision action the application sends a message to an external system and the external system provides a binary i.e. yes no or true false response. The application then follows one pre defined path if the response is a yes and another path if the response is a no . While the application performs only one of two options in this decision action the overall behavior can vary widely based on the policies or processes used by the external systems to make decisions. This can be extended to multi way decision actions where multiple paths are possible.

As an example an application designed to deliver or transmit a digital content item to a user could include a break point just before transmitting the content. In response to this break point the application supplies information identifying both the user and the list of content items in a query to an external policy engine . The application is programmed to proceed with the transmission of the content if the response is a yes and to cancel the transmission if the response is a no . In one situation the external system could be a real time charging engine that determines if the user has sufficient balance to pay for the items. If the user s balance is sufficient the external system debits the user account and returns a yes . If the balance is insufficient the external system returns a no . In another situation the external system can be an authorization system that only allows content to be downloaded to users within a certain physical location for example as a corporate security measure or as a means for restaurants to attract visitors. If the user is within the location bounds specified for the content items the external system returns a yes and if not the system returns a no . Hence two very different services employing distinct external systems have made use of the same content delivery policy enabled application .

In the case of a null action the application simply performs the break point and continues execution. The null action is appropriate where the application simply needs to inform an external system of some event. In the content download service example described above the application could be instructed to execute a break point comprising a null action just prior to transmitting the content. Executing the break point would cause an external system to record the download event including the list of content items so that the users with post paid accounts could be charged for the content during the next billing cycle.

In the case of a variable replacement action the application uses the response from the external system to alter the value of a variable being processed by the application . In the content download service example above the application could be instructed to execute a break point comprising a variable replacement action just prior to transmitting the content. Performing the break point could cause an external system to filter the list of content items removing those whose rating information indicates that they are not acceptable for the user perhaps based on the age or preferences of the identified user. The external system then returns the filtered list to the application which replaces the initial list of content items with the filtered list and proceeds with the download.

Other action types could be defined providing greater flexibility in the control of the application flow. Note that it is desirable to limit the number of action types or options in order to avoid undue complexity in constructing the application .

The policy enabled application would execute within an application server or service delivery platform and would have local access to the break point configuration table that would specify the application behavior associated with each break point . shows an exemplary table which could be populated by a provisioning system responsible for deploying the product service. The table comprises not only the action types discussed above but also the following fields which are described in more detail below an address for the policy engine or external system a sequence number and attribute mapping . The policy enabled application would interact with one or more external policy decision points. The configuration table links the points within the program flow where interactions can be performed with the specific decision point to interact with and the manner in which to interact such as the attributes to transmit .

While the discussion here describes policy decision points there is nothing in the mechanisms defined here that limits the external systems to being policy evaluators. Any external system with a defined invocation interface could be used in place of a policy decision point.

A simplified sample configuration table is shown in Table 1. In this case there are two break points entries associated with Break Point . For the first entry the application must perform attribute mapping by sending attributes A B and C to the PolicyEngine via the system address in the table and use the response to replace the value of attribute C. For the second entry the application must send attributes A C and D to PolicyEngine via its address in the table and perform a decision action based on the yes no response. The sequence number in the sequence column indicates the order in which the invocations associated with a single break point are executed. Invocations that share a sequence number could be executed in parallel. In cases where no sequence numbers are used the application could execute the queries in the order found in the file.

The right side of illustrates the flow that is used within the Break Point module to process these entries. Upon entry at step S the application invokes the external system at step S using the attribute mappings defined in the table . When the external system responds the application determines at step S the type of break point or action type being processed. If the action break point type is Variable Replacement the application at step S performs the replacement as defined in the configuration table and proceeds to step S to test if there are more break point entries to be processed. If the break point type is null the application need not wait for a response and proceeds directly to testing at step S if more break point entries need to be processed. If the break point type is fork the application tests the response from the external system at step S. If the external system response is yes the application proceeds to test for more break point entries at step S. If the external system response is a no the application breaks out of processing any further break point entries and returns to the main application flow with a No exit condition at step S. When there are no more break point entries to be processed the application returns to the main application flow with a Yes exit condition at step S.

Handling of exceptions and error conditions in the interactions with the external systems is not shown. The application could be programmed with various exception handling behaviors to deal with returned errors or time outs with no response. Alternatively the table could be extended to indicate the actions to be taken in the case of certain handled exceptions. The manner in which the application deals with these situations is not critical to this mechanism.

A key aspect of this dynamic programming approach is that the application break points can be mapped dynamically to decision point systems and to specific policies within them. There are numerous methods in which this mapping could be performed. Perhaps the most straightforward is a manual approach where human analysts create the break point configuration table define the policies that correspond to each break point load the configuration table into the application server and load the policies into the decision point. A greater degree of automation and validation in this mapping process is possible if the application break points and policies can be made visible in a structured fashion.

A design environment could import the structured representation of all the break points in an application selected by the user. The environment could retrieve policies from decision points known to it. When the human user selects a break point a brief representation of which is shown in Table 2 the environment could retrieve and present only those policies that are valid. For example if the break point only allowed forking operations or two way decision actions only those policies that return yes no or true false values would be appropriate. After selecting a policy the user would map the variables available from the software application at the chosen break point to those specified in the interface to the policy as shown in Table 3. The environment could then validate the mappings for example ensuring that the types e.g. string integer etc. match. After all the mappings are successfully defined in this manner the environment could create the corresponding break point configuration table and install it on the application server .

While the present invention has been described in particular embodiments it should be appreciated that the present invention should not be construed as limited by such embodiments but rather construed according to the claims below.

