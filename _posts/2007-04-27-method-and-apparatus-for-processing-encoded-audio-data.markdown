---

title: Method and apparatus for processing encoded audio data
abstract: To locate an encoded audio frame boundary and begin decoding audio at a point corresponding to that frame boundary, an audio decoder generates a matching pattern containing a syncword and additional bits related to a header of an encoded audio frame, detects an audio frame boundary by searching a data stream of encoded audio frame for instances of the matching pattern, and begins decoding audio frames at a point in the data stream corresponding to the detected frame boundary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07778839&OS=07778839&RS=07778839
owner: Sony Ericsson Mobile Communications AB
number: 07778839
owner_city: Lund
owner_country: SE
publication_date: 20070427
---
The present invention relates generally to audio decoders such as may be used in portable music players or other multimedia devices. An audio decoder may be used to decode stored audio files or to decode a stream of data provided over a network.

A variety of standards for encoding audio are known. In addition a variety of standards for encapsulating encoded audio data into a data stream which may include a data file or a stream of data provided over a network are also known. One example of the latter is the Audio Data Transport Stream ADTS format which is commonly used to encapsulate and transport audio data encoded according to the widely used Advanced Audio Coding AAC standard.

ADTS and other formats organize a data stream into frames of audio data each frame including a header. In some applications it may be necessary to scan a portion of the data stream to find the beginning of an encoded audio frame. So called syncwords are commonly included in frame headers to facilitate this scanning. A syncword is a fixed length fixed value data field generally placed in a consistent position within a header such as the beginning of the header.

Although scanning a data stream to detect occurrences of the syncword is generally effective to locate frame headers errors may occur. Because a syncword is generally limited for practical reasons to a relatively short length such as 12 bits an apparent syncword may occasionally appear in the audio payload data i.e. outside a frame header. This occurrence will result in a false detection of a frame. While various techniques for recovering from such a false detection are possible false detections result in the use of valuable processing time and cycles.

Accordingly a method for effectively locating frame boundaries in a data stream of encoded audio frames while reducing false detections is needed.

An audio decoder for decoding audio frames in a data stream where each frame includes a header is provided. The audio decoder includes one or more circuits configured to generate a matching pattern comprising a syncword and one or more additional bits corresponding to at least one anticipated value for a header field in a valid encoded audio frame detect a frame boundary by searching a portion of the data stream for one or more instances of the matching pattern and decode one or more audio frames beginning at a point in the data stream corresponding to the detected frame boundary.

The present invention provides methods for processing a data stream that includes encoded audio data wherein the data stream is organized into frames. The methods described herein reduce false detections of frame boundaries thus enabling improved error recovery and enhanced audio handling features in audio decoder devices. The present invention is applicable to processing of audio data organized into files and stored in non volatile memory or to audio data received by a network enabled device in an audio or multimedia stream. 

A data stream may include audio data encoded according to one of a variety of known audio encoding schemes such as the MP3 MPEG Layer 3 encoding scheme or the Advanced Audio Coding AAC encoding scheme. AAC has been standardized as Part 7 of the MPEG 2 standard known formally as ISO IEC 13818 7 1997 as well as Part 3 of the MPEG 4 standard known formally as ISO IEC 14496 3 1999 . Those familiar with the art will recognize that a number of other audio encoding schemes already exist or may be developed in the future and that each of these schemes may include a variety of techniques for compressing and encoding audio data. Indeed the AAC standard itself actually includes a number of different encoding schemes organized into profiles and or object types. 

Encoded audio data such as that encoded with AAC typically consists of a series of data blocks. A variety of methods for encapsulating the data have been devised. Among the simplest of these methods are those intended for use in situations where the encoded audio data is organized into a file and stored in memory as a complete file. In such a situation encapsulation of the audio may consist simply of the insertion of a single header at the beginning of the data file. This header may include data indicating the format of the audio data as well as various other data. For example the Audio Data Interchange Format ADIF is commonly used with AAC data to create AAC files. An ADIF header includes a field identifying the format of the file as well as other data related to copyright management and to a few details specific to the audio encoding scheme used to produce the audio data.

More complex schemes for encapsulating encoded audio data have been developed to handle situations such as the transporting of audio or multimedia streams in a network environment. In a network streaming environment such as may be found with Internet radio or in mobile communications an audio decoder may not have access to an entire audio data file at any given time. In addition audio data may be interwoven with other multimedia data such as video data for data transport purposes. To accommodate these situations various schemes have been devised for encapsulating the audio data wherein the audio data is organized into frames such as the encoded audio frames pictured in . One example of such a scheme devised for use with AAC data is the Audio Data Transport Stream ADTS format. This format is standardized in MPEG 2 Part 7 and MPEG 4 Part 3 along with AAC. ADTS formatted data is generally organized into a data stream organized into encoded audio frames with each encoded audio frame including a header as shown in .

Whether or not ADTS is used those familiar with the art will also recognize that a data stream may include other data for example video data in addition to the encoded audio. Thus a transport scheme that uses audio data formatted as a series of encoded audio frames is useful for segregating audio data from other data in the data stream . Accordingly encoded audio frames need not be organized into consecutive blocks. In addition ADTS and other transport schemes using audio frames are not limited to applications involving the streaming of audio in a data network. Although a frame based format such as ADTS uses more overhead than a simpler format such as ADIF these frame based formats are nevertheless suitable for situations in which audio data is organized into files and stored in memory for retrieval and playback. Thus the term data stream as used in this disclosure may refer to data organized into a file and stored in memory or to data transported in a streaming application such as Internet radio in such a manner that the audio decoder may not have access to the entirety of the audio data at a given time.

In contrast other fields within the header may vary from data stream to data stream. For example header in includes an ID field which includes a single bit. This field is used in ADTS to indicate whether the audio data in the data stream has been encoded according to the MPEG 2 standard ID Field 1 or the MPEG 4 standard ID Field 0 . Thus this field may vary between different data streams. also illustrates a layer field which in ADTS is fixed at 00 as well as a protection absent field in ADTS a one bit field indicating whether the header includes a checksum and a profile field in ADTS a two bit field indicating which of several AAC encoding schemes has been used to encode the audio data . Finally the header in includes a CRC cyclical redundancy check checksum field which is optional in ADTS and may be used to verify the integrity of the header.

As should be apparent to one skilled in the art illustrates but one exemplary header structure. Various alternatives are possible but a header will typically comprise a syncword which is a fixed value for all data streams of a given type as well as various other fields some of which may vary between different data streams of a given type and some that may vary between different headers in a single data stream . For example for ADTS the ID field layer field protection absent field and profile field will typically be fixed within a given data stream but one or more of these fields may vary from one data stream to another. On the other hand CRC field may vary from one header to the next. Because one or more fields may be fixed within a data stream it may often be possible to anticipate not only the value of the syncword in any given header but also the value of one or more other fields given prior knowledge of the contents of a valid header .

When processing a data stream it may be necessary to locate a frame boundary associated with the beginning of a frame header . Although a data stream is typically processed in a linear fashion i.e. bit by bit or word by word the presence of corrupted data in the data stream may necessitate the identification and location of a subsequent header from which location processing of the data stream might continue. In addition more complex functionality of an audio playback device may necessitate repeated identification of headers so that one or more encoded audio frames may be skipped. For example a fast forward function may require data processing to be suspended at an arbitrary location in the data stream and resumed with an encoded audio frame located further along in the data stream . Such a function might require that encoded audio frames be skipped until a terminating signal is sent. Alternatively such a function might require that a pre determined number of encoded audio frames are skipped and playback i.e. decoding resumed at the subsequent encoded audio frame .

Typically a data stream may be scanned sequentially and searched for the presence of a sequence of bits matching the syncword . Advancing to the next encoded audio frame is therefore generally a simple matter of scanning forward in the data stream until a series of bits matching the syncword is found and then processing encoded audio frames beginning at the location of the matching bits.

However given a syncword of any practical length sequences of bits matching the syncword may not be confined to the syncword position of headers . These sequences may appear at random positions within the encoded audio data. In practice random occurrences of these sequences have been frequently observed in ADTS formatted data for example.

As a result any processing of encoded audio that relies on the foregoing technique for locating frame boundaries is likely to suffer from an unacceptable frequency of false detections. One method for recovering from such a false detection is to parse upon detection of a match to the syncword a series of data bits that should ordinarily correspond to the remainder of the header and if these bits parse correctly to proceed with processing the subsequent audio data. This parsing may include the evaluation of a CRC checksum field which verifies the integrity of the header and thus implicitly verifies that a valid header has been located.

However parsing an entire header is time consuming. In a processing environment where processing cycles are limited recovering from frequent false frame boundary detections may therefore be highly undesirable even where the frequency of false frame boundary detection is relatively low.

The matching pattern generated in block also includes one or more additional bits . These additional bits comprise anticipated values of one or more fields found in a valid header of a particular data stream . As discussed above the values of certain fields of a header will be fixed within a particular data stream even though the values of those fields may vary between different data streams of the same type. Accordingly if the values of those fields are known for one header of a given data stream then those values may be anticipated to appear in all other headers of that data stream .

Referring back to it may be seen that an ADTS header for example includes an ID field a layer field a protection absent field and a profile field . All of these fields are generally fixed within a particular data stream if that data stream is formatted for ADTS. In contrast CRC checksum field will vary from one ADTS formatted header to the next.

Thus an audio decoder may generate a matching pattern for use with an ADTS formatted data stream that includes a 12 bit syncword and additional bits that correspond to anticipated values for one or more of the ID field layer field protection absent field and profile field . In this non limiting example the resulting matching pattern is 18 bits in length. Alternatively the matching pattern might comprise a 12 bit syncword plus additional bits corresponding to anticipated values for only the ID field layer field and protection absent field . In this case the matching pattern is 16 bits or two bytes in length. This length might be more convenient in some embodiments of the present invention.

Block of illustrates the generation of the matching pattern . The matching pattern may be constructed from various combinations of a syncword and additional bits . As previously discussed those additional bits correspond to anticipated values for one or more header fields in a valid encoded audio frame contained in a particular data stream . The values of those header fields may be anticipated based on a priori information regarding the target data stream . This a priori information may have been obtained from parsing the contents of one header contained in the target data stream or from information separately supplied and relating to the specific target data stream . For example in a streaming environment a computer server sourcing an audio stream may provide parameters describing the audio stream separately from the data stream itself. These parameters may indicate for example that the data stream contains AAC encoded data in accordance with the MPEG 2 standard and that the data stream does not include CRC checksum fields in the headers . Regardless of how these parameters are formatted it is thus possible to determine the anticipated values of several header fields contained within headers without first decoding a header . Thus an audio decoder may generate a matching pattern using information derived from decoding a header or using data derived from separately provided information.

In any event because the matching pattern is longer than the syncword random matches between the matching pattern and the data stream are less likely than if the matching was carried out with the syncword alone. Depending on how many additional bits are included in the matching pattern the probability of a false detection may be greatly reduced. For example assuming that the encoded audio data is generally random using a 16 bit matching pattern will reduce the false detection rate by over 93 . In practice of course the improvement may vary but the false detection rate will nevertheless be significantly reduced even for a relatively small number of additional bits .

The detecting step illustrated in block may optionally include searching for multiple occurrences of the matching pattern in the data stream . In one exemplary method a portion of the data stream is sequentially searched for a pre determined number of instances of the matching pattern and the detected frame boundary corresponds to the last instance. For example an application of the method might require that five frames be skipped. In this case the detecting step will include a search for five sequential instances of the matching pattern in the data stream the detected frame boundary will correspond to the last of those five sequential instances.

In an alternative embodiment of the present invention the data stream may be sequentially searched for multiple instances of the matching pattern until a terminating signal is received. In this embodiment the detected frame boundary may correspond to the last instance of the matching pattern detected before the terminating signal was received.

In yet another embodiment of the present invention each detection of an instance of the matching pattern in the data stream may trigger a signal indicating that a match has occurred so that this signal may be used to generate a terminating signal. For example a data stream may be rapidly searched for multiple instances of the matching pattern . Each match may cause a signal to pulse so that the pulses can be counted yielding a parameter indicating the number of matches detected. A given application might require that sixty frames be skipped for example and thus cause the search to be continued until sixty matches have been counted at which time the application generates a terminating signal. The detected frame boundary in this example might therefore correspond to the last instance of the matching pattern detected before the terminating signal was received.

After a frame boundary has been detected processing of subsequent encoded audio frames may proceed. In some embodiments of the present invention the header contained in the encoded audio frame corresponding to the detected frame boundary may be validated before audio data is decoded as illustrated in block . For example a CRC checksum field may be evaluated to confirm that the header was received correctly. In the event of a false frame detection which is less likely with embodiments of the present invention but still possible evaluation of the CRC checksum field will almost certainly fail indicating either that the data is corrupted or that the detection of a frame boundary failed. Thus the evaluation of a CRC checksum field serves to verify that a detected frame boundary corresponds to a valid header .

Other techniques for verifying that the detected frame boundary corresponds to a valid header are also possible. For example if the header contains information indicating the length of the frame then a processor may look ahead in the data stream to verify that a valid syncword is present where a subsequent header is expected. However it should be noted that any process for verifying that a detected frame boundary corresponds to a valid header will generally require additional processing steps. Accordingly reducing false detections in accordance with the teachings of this disclosure will also reduce the processing steps dedicated to verifying frame boundary detections.

If the detected frame header is valid decoding of encoded audio frames begins at a point in the data stream corresponding to the detected frame boundary as illustrated in block . Decoding of the encoded audio frames is carried out in accordance with the applicable encoding scheme. Thus for example an AAC decoder is used to decode encoded audio frames encoded by an AAC encoder.

The control logic block provides overall control for the decoder . It may provide triggers for initiating and or terminating audio decoding. It may also include logic for a user interface such as a keypad or touchscreen to allow user control of the decoder . Alternatively or in addition the control logic may include an implementation of an application programming interface API for communication with a separate software program or program module.

The matching pattern generator is configured to generate a matching pattern for use with a target data stream as discussed above. The matching pattern generator is provided with information relating to the data stream including the syncword used in data streams of the targeted type. Additionally the matching pattern generator is provided with information related to the anticipated value for at least one header field in a valid header in the target data stream . As discussed above this information may be derived from actually reading a header in the target data stream or it may be derived from separately provided information about the data stream . In either case the matching pattern generator constructs a matching pattern comprising a syncword which is identical to the syncword and additional bits corresponding to the anticipated value or values for one or more header fields in a valid header .

The matching pattern is used by the frame boundary detector to search a portion of the data stream for an instance of the matching pattern . Each instance of the matching pattern will usually correspond to a frame boundary . In some embodiments of the present invention the frame boundary detector will stop its search at the first instance of the matching pattern yielding a corresponding detected frame boundary . In other embodiments the frame boundary detector may be configured to continue to search the data stream detecting multiple instances of the matching pattern until it receives a terminating signal from the control logic . The detected frame boundary in this example may correspond to the last detected instance of the matching pattern before the terminating signal was received.

Alternatively as discussed previously the frame boundary detector may be configured to search the data stream for a pre determined number of instances of the matching pattern in this case the detected frame boundary may correspond to the last detected instance.

In any event the frame boundary detector passes information relating to the detected frame boundary to the frame decoder . The frame decoder decodes one or more encoded audio frames using an appropriate decoder algorithm. The frame decoder produces a decoded audio output which may comprise an uncompressed digital audio stream for example a pulse code modulation PCM audio stream for use by an audio application and or for conversion into analog audio.

The decoder may interface with a memory to access the data stream . The data stream may be organized as a file and stored in memory in which case the memory may be a random access memory or nonvolatile storage memory such as flash memory or a magnetic disk drive. The data stream may also be derived from a streaming audio or multimedia source on a data network in which case the memory is most likely a random access memory buffering a portion of the data stream .

The control logic block matching pattern generator frame boundary detector and frame decoder may be implemented with digital logic hardware or with software running on a microprocessor or a combination of both. Any block may be implemented by a dedicated processor or several blocks may be implemented by a single processor. The frame decoder in particular may be implemented with a specialized digital signal processor DSP but any of the blocks may be implemented in whole or in part with a general purpose microprocessor or a DSP. In addition functionality of any block may be partitioned between two or more processors or hardware blocks without departing from the spirit of this invention.

Those skilled in the art should appreciate that the present invention broadly provides methods and devices for rapidly and effectively detecting frame boundaries in an encoded audio data stream for use in an audio decoder. The present invention may of course be carried out in other specific ways than those herein set forth without departing from the scope and essential characteristics of the invention. Thus the present invention is not limited to the features and advantages detailed in the foregoing description nor is it limited by the accompanying drawings. Indeed the present invention is limited only by the following claims and their legal equivalents.

