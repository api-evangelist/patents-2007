---

title: Method and system for integrating security mechanisms into session initiation protocol request messages for client-proxy authentication
abstract: In response, the SIP client sends a second request message with a proxy authorization header containing authentication data, including a Kerberos server ticket for the Proxy, to allow the proxy to authenticate the client's user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07770007&OS=07770007&RS=07770007
owner: Microsoft Corporation
number: 07770007
owner_city: Redmond
owner_country: US
publication_date: 20070604
---
This application is a continuation of U.S. patent application Ser. No. 10 151 747 filed on May 17 2002 which application claims the benefit of U.S. Provisional Application No. 60 298 239 filed Jun. 14 2001 which applications are herein incorporated by reference in their entireties.

This invention relates generally to communications between devices over a computer network and more particularly to the integration of a security mechanism such as one based on the Kerberos authentication protocol into network communications that use the Session Initiation Protocol SIP as the signaling protocol for establishing a communication session.

The Session Initiation Protocol SIP is a signaling protocol that provides a mechanism for a computing device to locate another device it wants to communicate with over a computer network and to establish a communication session therewith. SIP is a versatile protocol and has been used for establishing communication sessions in many different scenarios. For instance SIP is used for Internet conferencing telephony presence event notification and instant messaging. An important strength of SIP is its support of personal mobility by providing the ability to reach a called party user under a single location independent address even when the called party has moved to a different computer.

One common mode of session initiation operation under the SIP is the proxy mode. By way of example a SIP client the caller may send a SIP request message such as an INVITE message identifying the intended recipient the callee by an e mail like address. This request message is typically first sent to an outbound SIP proxy of the sending SIP client. The outbound SIP proxy then forwards the request message often through other intermediate SIP proxies to an SIP proxy with which the intended recipient client has registered which then sends the INVITE to the recipient. The acceptance message 200 OK of the recipient client is returned through the signaling chain to the caller which can then communicate with the callee through a media channel that is typically different from the signaling channel. Besides communicating with another SIP client a SIP client may also talk to SIP servers for purposes such as registering itself with a SIP registrar by sending a REGISTER request.

Although SIP has been widely implemented for various applications it was designed mainly for signaling operations. It does not explicitly provide or require a security mechanism for protecting the security and privacy of the communication sessions. In many cases however it is desirable to require a SIP client that sends a request to authenticate its user to an outbound SIP proxy and to also require the proxy to authenticate itself to the SIP client. Moreover it is also often necessary to protect the integrity of the SIP request messages. Both the client proxy authentication and message integrity require the use of a reliable security mechanism. Thus there is a need to combine a reliable security mechanism with the SIP signaling operation to allow authentication between a SIP client and an outbound SIP proxy. The technical challenge is however how to fit the desired security mechanism into the SIP signaling framework so that the two mechanisms for different purposes can be performed together effectively.

In view of the foregoing the present invention provides a scheme to integrate a security mechanism such as the Kerberos protocol or the NTLM protocol into the message flow of the SIP signaling operation to allow a SIP client and a SIP proxy to authenticate each other. In accordance with the invention when the proxy receives a SIP request message from the SIP client it responds with a challenge message indicating that authentication according to a pre selected security mechanism is required. In response the SIP client sends a second or revised version of the request message with a proxy authorization header that includes authentication data for authenticating the client to the server according to the security mechanism. In the case where the Kerberos security mechanism is used the proxy authorization header includes data representing a Kerberos server ticket obtained by the client for accessing the proxy. If the authentication of the client s user based on the proxy authorization header data is successful the SIP proxy forwards the request through the SIP message signaling path between the SIP client and the intended recipient of the request message. If the SIP client requires mutual authentication the SIP proxy adds a proxy authentication information header to the next message it sends to the client. This message may be for example a 200 OK SIP response generated by a callee SIP client in response to an INVITE request or a 200 OK response generated by a SIP registrar server in response to a REGISTER message. The proxy authentication information header contains the authentication data for the client to authenticate the SIP proxy.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a personal computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The following description begins with a description of a general purpose computing device that may be used in an exemplary system for implementing the invention and the invention will be described in greater detail with reference to . Turning now to a general purpose computing device is shown in the form of a conventional personal computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the personal computer such as during start up is stored in ROM . The personal computer further includes a hard disk drive for reading from and writing to a hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories read only memories storage area networks and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more applications programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and a pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB or a network interface card. A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

The personal computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the WAN . The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

In the description that follows the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.

Referring now to the present invention is directed to a way to integrate a security mechanism especially one implementing the Kerberos authentication protocol into the request messages under the Session Initiation Protocol SIP to enable a SIP client and a SIP proxy server to authenticate each other and for protecting the integrity of the signaling messages. The SIP is defined in Request For Comments RFC 2543 which is hereby incorporated by reference in its entirety.

By way of example as shown in in a typical session initiation operation a user e.g. Ann of a SIP client the caller that wants to talk to another user e.g. Bob sends an INVITE message that identifies Bob as the intended recipient for the INVITE. This INVITE is sent to an outbound proxy server for the caller SIP client s domain. As shown in the INVITE message may be passed through multiple SIP proxies involved in the signaling operation before it reaches the SIP client the callee of Bob s computer . In a preferred embodiment the security of the SIP signaling messages being transferred between the SIP proxies in the signaling path is protected by sending the messages under the IPSec protocol or through a pipe under the Secured Sockets Layer SSL protocol. It will be appreciated that although in this example the SIP request is an INVITE request the authentication scheme described below can also be used for other types of SIP requests such as REGISTER MESSAGE SUBSCRIBE SERVICE etc.

For ensuring the security of the signaling operation and the integrity of the signaling messages the outbound SIP proxy server may require authentication of the user of the caller SIP client before forwarding the INVITE message through the signaling path . In accordance with the invention referring now to the proxy server responds by sending a challenge message to the SIP client . The challenge message contains the status code 407 Proxy Authentication Required as defined in the SIP specification for indicating that the client has to first authenticate the user with the proxy . Pursuant to the SIP specification the challenge message referred to hereinafter as the 407 message includes a Proxy Authenticate header field that contains data indicating the security mechanism the client should use for authentication. The syntax and contents of the Proxy Authenticate header is described in greater detail below. In a preferred embodiment Kerberos is the preferred security mechanism but the SIP framework also allows the use of the security mechanism based on the NTLM protocol. In the following description it is assumed that a security mechanism based on the Kerberos protocol is used unless otherwise indicated.

Still referring to when the SIP client receives the 407 message from the proxy server in response to the INVITE message it decides from the Proxy Authenticate header that the proxy server requires authentication of the user by means of the Kerberos mechanism. The client then obtains a server ticket from a Kerberos Key Distribution Center KDC for the SIP proxy server if it has not already obtained one. In one implementation the KDC is part of the domain controller for the proxy server . After obtaining the server ticket the client sends another INVITE message . This time however the INVITE message includes a Proxy Authorization header field pursuant to the SIP specification. The Proxy Authorization header field includes the server ticket for accessing the proxy which includes the session key to be used. The syntax and contents of the Proxy Authorization header field is described in greater detail below. Optionally the Proxy Authorization header may also include a request for mutual authentication i.e. asking the proxy server to authenticate itself to the client .

When the SIP proxy server receives the resent INVITE message with the Kerberos server ticket embedded therein it extracts the server ticket and verifies the validity of the ticket by decrypting it with its long term key shared with the KDC . If the ticket is valid the user is authenticated and the SIP proxy server forwards the INVITE message to the next proxy on the signaling path. If the client has requested mutual authentication in the Proxy Authorization header of the INVITE message the proxy server will sign future packets from the server to the client using a session key associated with the Kerberos server ticket. This message includes a Proxy Authentication Information header that contains the credentials of the proxy to allow the client to authenticate the proxy.

Ultimately the INVITE message reaches the callee i.e. the SIP client of Bob s computer . If the callee accepts the call invitation it returns a 200 OK message which is then routed back to the caller. Once the call connection is established the caller can communicate with the callee directly without having to go through the SIP proxies involved in the signaling phase.

Referring now to in accordance with the invention the operation of establishing the authentication security association SA with between the SIP client and the SIP proxy server can be viewed as a state machine . In the embodiment shown in the preferred security mechanism is Kerberos but optionally the NTLM security mechanism can also be used and the state machine diagram reflects the inclusion of that option.

In the states are shown in circles and the operations performed in connection with the states are shown in rectangular blocks. As shown in one state in the state machine is the SECURITY STATE NONE state in which no security SA has been established. When the client receives a 407 challenge from the proxy in response to an INVITE sent by the client or when the client decides to do a pre authentication with the proxy the client enters into a SECURITY STATE ACQUIRING SA state in which the client acquires the security association data required for authentication which depends on the security mechanism selected.

Generally the security association is defined as a state in which the client and the SIP proxy have exchanged a shared secret in a secure manner such that this secret can be used to authenticate and protect the integrity of any subsequent messages exchanged by the client and the proxy. If the security mechanism is Kerberos the security association includes the Kerberos server ticket for the proxy and the session key. In the case of Kerberos the obtained SA is complete i.e. it is sufficient for the proxy to authenticate the user of the SIP client. The client then sends this SA related information e.g. Kerberos session key encrypted with the server s secret to the proxy step . If the proxy sends back a signed 200 OK message step the authentication is successful and the security association is established i.e. the client is in the SA Established state . If however the proxy sends a 407 challenge instead step the client assumes that the proxy is in a bad state so that it cannot validate the client s good credentials. The client then waits for a back off time e.g. 5 minutes before trying to send SIP messages again step .

After entering the SA Established state the client can send further messages to the proxy without having to do the authentication again as long as the security association has not expired. If however the proxy sends a 407 challenge step the client assumes that the proxy has for some reason dropped the established security association. As a result the client enters the SA Dropped state and moves back to the SECURITY STATE ACQUIRING SA state to acquire a new SA for redoing the authentication with the proxy.

As mentioned above the NTLM mechanism can be optionally selected for user authentication. The state migration for NTLM is largely identical to that for Kerberos but with the difference that the NTLM acquires only a partial SA the first time step and sends the incomplete SA to the proxy in a first message. More specifically in the case of NTLM the first request from the client with the SA related information carries the client s security related capabilities e.g. the version of the protocol it supports the signing algorithms it supports etc. In response the server sends a second challenge step that contains its a own authentication data including its NTLM related capabilities and a random byte string typically called nonce . In response the client signs a hash of its own name and the nonce value sent by the proxy using its credentials. This is handled internally by the NTLM implementation. The server verifies the client s authentication data and gets the session key with the help of the domain controller. If the SIP proxy is not the intended recipient it then forwards the SIP request to the next hop in the signaling path and signs the next message e.g. a 200 OK message from the recipient to the sender SIP client step .

The syntax of the various SIP headers involved in the message exchange between the SIP client and the SIP proxy for authentication purposes is described below.

As mentioned above if the SIP proxy server wants to challenge the identity of the SIP client or its user that sent an INVITE message it sends a 407 message with a Proxy Authenticate header back to the client. The syntax of Proxy Authenticate header in a preferred embodiment requiring the use of the Kerberos security mechanism for authentication is as follows 

The syntax of the Proxy Authenticate header described here is similar to the WWW Authenticate Response Header defined in IETF RFC 2617 entitled HTTP Authentication Basic and Digest Access Authentication which is hereby incorporated by reference in its entirety. The optional parameters algorithm and stale have been dropped. The scheme field of the header allows the client to choose which authentication mechanism among the ones proposed by the server it wants to use to authenticate itself to the server. The client preferably chooses the Kerberos mechanism if it can support that mechanism and otherwise chooses the NTLM authentication mechanism.

The realm parameter is the unique identifier of the SIP service provider to which the SIP proxy belongs and the client is trying to access. The realm string is displayed to the user to help her identify the correct set of credentials she needs to provide in order to authenticate. The targetname parameter is a always required and is used to carry the FQDN for the SIP proxy. The actual contents of this parameter help the client to keep track of which proxy it is establishing an SA with. It helps the proxy to determine whether the response is meant for itself or some other proxy. The opaque parameter is used by the server to index the particular SA being established and has to be echoed in any future Proxy Authorization header the client generates for the SA as will be described below.

In this embodiment it is assumed that the Generic Security Service Application Programming Interface GSS API as defined in IETF RFC 2078 which is hereby incorporated by reference in its entirety has been implemented and is used for securely exchanging messages between communicating applications. The GSS API allows among other things a communicating application to authenticate the user associated with another application. The gssapi data field in the Proxy Authenticate header and the Proxy Authorization header described below is for holding the data returned during the SA negotiation phase by the Security APIs that implement NTLM and Kerberos security packages. These APIs return the gssapi data that need to be sent from the client to the proxy and vice versa. The gssapi data are opaque to the SIP client and proxy implementation and are interpreted only by the security API. The qop parameter tells the client the level of security the server wants to client to adhere to. The qop parameter value is always set to auth indicating the security level provided by this mechanism is user authentication.

Typically the SIP proxy would challenge the identity of the SIP client if it is provisioned to allow only authorized clients and the incoming SIP packet from the client does not contain any signature. The SIP proxy would also challenge a client if it has lost the security association for this SIP URI due a reboot etc. . If there is a mismatch between the authorization parameters that the client is using and what the SIP proxy is expecting the SIP proxy would challenge the client using a 407 message carrying the exact authorization parameters that SIP proxy wants the client to comply with.

In response to a 407 challenge the SIP client would try to generate a signature complying with the authentication parameters sent by the SIP proxy through the 407 challenge message. The SIP client would increment the Cseq value and resend the initial SIP request that was challenged along with the authorization information carried in a Proxy Authorization request header. The syntax of the Proxy Authorization request header in a preferred embodiment is as follows 

The syntax of the Proxy Authorization header described here is similar to the Authorization Request Header defined in IETF RFC 2617 except that the optional parameters algorithm and URI have been dropped. The Proxy Authorization header is added after the request URI and the Via headers The signature is computed using the session key across following fields 

The following are examples of a Proxy Authorization header in a client s response to a 407 challenge 

Besides responding to a 407 challenge from the proxy the client would also send this header when it registers with the SIP proxy for the first time. The Proxy Authorization header would contain the gssapi data parameter when the SIP client registers with the proxy server and is in the process of initializing a security association for a session.

Establishing a mutual authentication between the SIP proxy and the SIP client might be required in certain deployment scenarios. The client finds out from the provisioning profile it has for the particular proxy server whether mutual authentication is required or not. If the mutual authentication is enabled the client initializes its security association for mutual authentication using the standard version of the GSS API. Also if mutual authentication is enabled the server needs to sign every packet it sends to the SIP client. This signature is carried in the Proxy Authentication Information request header. The syntax of the Proxy Authenticate Information is as follows 

Generally in the SIP framework a SIP client may establish a security association with a SIP proxy during a registration process using a REGISTER request. The registration allows the SIP client to receive messages from the SIP proxy. When the SIP client registers with the SIP proxy it can at the same time authenticate its user with the SIP proxy server by sending the authentication data such as a Kerberos ticket along in the REGISTER message. If the SIP client has already registered and authenticated itself with the SIP proxy when the client sends a SIP request such as an INVITE the request message from the client will be signed using the Kerberos session key exchanged during the SA establishing process.

Nevertheless a SIP client is not required to register with the server before it can send out a request message to the SIP proxy. In the case where the caller has not authenticated itself with the proxy even if the SIP client has already registered with the proxy the SIP proxy does not forward the request to the next hop. Instead the proxy sends a challenge to the SIP client.

The challenge indicates that the client needs to establish a security association with this SIP server. The client can establish the SA by resending the request with the security association data or alternatively it can do so by refreshing its registration with this server if one is already in place but the SA has not been established. Establishing the SA using the registration refresh and then sending the SIP request with a valid signature has the advantage that it also makes sure that the registration is in a good state.

Also every time a SIP client un registers with SIP proxy the security association SA between the two is lost and a new security association has to be negotiated again. Moreover when the registration of a SIP client expires the proxy server will remove its corresponding security context from its list of SAs. Every time a SIP client refreshes its registration it has to refresh the authentication security association.

In a preferred embodiment that uses a security mechanism based on the Kerberos protocol a Kerberos ticket is requested from a Kerberos Key Distribution Center KDC every time the SIP client registers with the SIP proxy if the authentication of the user of the sending SIP client is required by the SIP proxy registrar. When the SIP client receives the Kerberos ticket it decrypts this ticket. The decrypted ticket contains the session key and some other properties of this Kerberos session. This ticket also contains the session key and other session related parameters encrypted with the server s credentials. This part is returned in a pOutput parameter in the gssapi data field and is sent in the re INVITE request to the proxy.

To facilitate a clear understanding of the operation of the security mechanism within the framework of SIP a particular example of client to proxy Kerberos authentication is described below with reference to . In this example it is assumed that the SIP proxy server has created a shared secret key with the KDC in the domain domainA.Microsoft.com S server1 where server1 is used in this example as the code name for a SIP proxy registrar. The KDC knows the proxy server as server ID server1.domainB.microsoft.com. The proxy server also acquires a credentials handle to be ready to respond to an incoming authentication request from the client. Server credentials are used to authenticate the proxy server to the SIP client in security protocols that support server authentication or mutual authentication. The proxy server obtains a handle to its credentials defined by the service account used to start the server. It does so by calling the function AcquireCredentialsHandle of the Security Support Provider Interface SSPI .

In the example of the user of the SIP client is Ann. Ann has an account in an NT domain and logs on her account when she starts the day with the following information 

When Ann wants to call Bob she starts the SIP client on her workstation the SIP client may start automatically as a service but should run in the security context of the user . The SIP client finds its outbound proxy server using DNS. The outbound proxy server to use in this example is identified as Server1.domainB.Microsoft.com. Ann indicates that she wants to talk to bob microsoft.com. Her SIP client then sends an INVITE message to Server1.domainB.Microsoft.com. The INVITE message includes the following information 

For purposes of keeping the description of the example concise and clear not all data contained in this INVITE message or other messages exchanged in the signaling processing are shown. The SIP proxy server has been configured to require that all INVITE requests be authenticated for calls made to the Microsoft.com user name space. As a result the SIP proxy server responds to the INVITE by sending a 407 message asking the SIP client to use Kerberos to authenticate the user Ann. The 407 message includes the following data 

The opaque value is initialized by the proxy to identify the security context to use for this call. To that end the proxy server calls the function AcceptSecurityContext at this time and returns in opaque the base64 encoded result of pOutput. The opaque value is used by the client and server to identify a security context to use for a particular server for the purposes of authentication continuation or re authentication of subsequent requests to the same server using the Authorization request header.

When the SIP client on Ann s workstation gets the 407 message indicating that authentication is required it checks if it has a valid session key for talking to Server1.domainB.Microsoft.com. If it does not have one yet it needs to contact the KDC in its domain to get a session key for accessing the outbound SIP proxy. In this example the client knows from the realm specified in the 407 message that the proxy is in a different domain than its own.

To establish a secured connection to the proxy server the client acquires an outbound credentials handle before sending an authentication request to the proxy. This is performed by calling functions of SSPI. The SSPI provides the means for networked applications to call one of several security support providers SSP to establish authenticated connections and to exchange data securely over those connections. There are two client side SSPI functions involved in the authentication setup. The AcquireCredentialsHandle function obtains a reference to previously obtained logon credentials. The function InitializeSecurityContext creates the initial authentication request security tokens. The call to initializeSecurityContext passes in the pInput the opaque value obtained from the 407 message. The client sets a tfContextReq parameter of the function to request MUTUAL AUTH. A pfContextAttr pointer is the way the Kerberos module tells the client that mutual auth has been requested . This information is part of the KERB AS REQ created by the Kerberos module of the client and passed in a secBuffer pOutput that tells the server here the SIP proxy the client wants mutual authentication. Since this is part of the KERB request there is no need for a SIP mechanism header parameter to request mutual authentication.

In the example shown in calling the API function InitializeSecurityContext causes the following Kerberos logic to happen. First the client asks the KDC for the domainA.Microsoft.com domain to give it a server ticket to the Proxy server in DomainB. The KDC for domainA.Microsoft.com sends the client a referral ticket to the KDC for corp.Microsoft.com. This referral ticket is encrypted in the inter domain key shared by the two KDCs. With the referral ticket the client asks the KDC for corp.Microsoft.com to give it a server ticket to the server in DomainB.

In response the KDC sends the client a referral ticket to the KDC for DomainB. This ticket is encrypted in the inter domain key the KDC shares with the DomainB KDC . The client then asks the KDC for DomainB to give it a ticket to the proxy server in DomainB. The KDC sends back a server ticket for accessing the proxy server . The KDC encrypts one copy of this session key with Ann s logon session key and embeds another copy of the session key in the server ticket along with Ann s authorization data and encrypts the server ticket with the proxy server s long term key. The KDC then sends these credentials back to the client in a Kerberos Ticket Granting Service Reply KRB TGS REP .

The call to InitializeSecurityContext thus causes the Kerberos module of the client machine to initiate a TGS exchange with the KDC. The value returned by this exchange is the session key for signing messages to be sent to the proxy.

Thereafter the SIP client creates a new INVITE message also called the re INVITE message to be sent to the SIP proxy. This new INVITE message includes a proxy authorization header as described above with the GSS API data therein containing the server ticket the client received from the KDC . The session key is the value returned in the pOutput buffer returned by the InitializeSecurityContext call. Thus the new INVITE message includes the following data 

To protect the integrity of the messages and authenticate itself i.e. prove the source of the message the client signs the INVITE message with the session key. Otherwise a third party could sniff the INVITE get the Opaque and Gssapi data values and send a bogus INVITE to the same server to make a call between itself and whatever destination it chooses. This means a client s authentication could be stolen for as long as the session key to the server is valid 8 hrs by default . Signing the INVITE doesn t stop a third party from grabbing the Opaque and Gssapi rdata but it can stop that party from creating a new INVITE to call whomever it wants. The server would have to be configured to only accept signed requests for this problem to be avoided.

The client uses the MakeSignature API and calls it for setting the phContext to the security context used in this call the one identify in the opaque of the 407 and passing the content to sign in pMessage. The output of this call is the signed message returned in pMessage. The client adds the signature to the INVITE . When the proxy server receives the resent INVITE message it checks the opaque value in the Proxy Authorization header and correlates it with a given phContext value handle to a given security context . It takes the gssapi rdata out and passes it to its Kerberos module by calling the AcceptSecurityContext API function and passing the gssapi rdata value obtained from the proxy authorization header in the pInput component of the API function. The Kerberos module decrypts the server ticket using the long term key of the proxy and extracts Ann s authorization data and the session key. It uses the session key to decrypt Ann s authenticator and then evaluates the timestamp inside.

If the authenticator passes the test the Kerberos module looks for a mutual authentication flag in the client s request. If the flag is set the Kerberos module uses the session key to encrypt the time from Ann s authenticator and returns the result in a Kerberos Application Reply KRB AP REP . This causes the call to AcceptSecurityContext to return a SEC E OK return value with the authenticator passed through the API using the pOutput buffer. Once the user is authenticated the SIP proxy registrar will process the request and forward the INVITE message to the next hop in the SIP signaling path.

The SIP component of the Proxy then uses the next message it forwards to the SIP client to pass to the client the proxy s authenticator so that the client can authenticate the server. In the illustrated example the message is a 200 OK message. This message is not originated by the SIP proxy. Rather the 200 response is generated by the callee in response to the INVITE request. The SIP proxy merely signs it with the session key before forwarding this response to the caller.

As described above the authenticator is in the Proxy Authentication Information header. The header also includes the opaque value for the client to match this response to the right security context.

When the SIP client on Ann s workstation receives the 200 OK message it extracts the Proxy Authentication Information header and calls InitializeSecurityContext with the phContext value set top the value in opaque and the pInput buffer set to response digest. The Kerberos module on the client decrypts the proxy s authenticator with the session key it shares with proxy and compares the time returned by the proxy with the time in the client s original authenticator. If the times match the call to InitializeSecurityContext will return a SEC E OK and the client knows that the proxy is genuine. Else the client should drop the call. There is no point in sending a CANCEL to kill the call since the client cannot trust the server to do anything it asks it to do.

In the example described above the authentication occurs in a scenario in which the SIP first sends an INVITE without authentication and then sends the authentication data in another INVITE in response to a 407 message from the proxy indicating that authentication is required. Alternatively the client can include the required authentication data in the first INVITE sent to the proxy. To that end the client obtains the server ticket for the proxy from the KDC before it is used by the user to make a call under SIP. The authentication data required are then put in the Proxy Authorization request header as described above. Doing this avoids the need for the proxy to send the 407 challenge to the client to ask for authentication data. Also even though only one SIP proxy is involved in the example of authentication operation described above there are typically multiple SIP proxies in the SIP signaling path between the caller and the callee and more than one of them may require the caller s client for authentication. For instance in the simplified case shown in there is another SIP proxy server in additional to the outbound proxy server of the SIP client and both proxies require client authentication before forwarding the INVITE message. In this case the client first goes through the same process as described above in connection with to authenticate itself with the outbound SIP server . After the proxy server authenticates the client it sends the INVITE to the second proxy which then sends a 407 challenge to the client.

In response the client sends another new INVITE with a Proxy Authorization header containing a Kerberos server ticket for the second Proxy server . After authenticating the client the second proxy passes the INVITE to the callee.

The following description provides additional examples of how the Proxy Authenticate Proxy Authorization and Proxy Authentication Information headers are used in scenarios of different message flows for performing authentication based on the Kerberos or NTLM security mechanism. Turning to in this case the SIP client performs a Kerberos based pre authentication when the client registers with the proxy server. The client sends a REGISTER request that includes a Proxy Authorization header containing the Kerberos server ticket for the proxy and a request for mutual authentication as described above. After authenticating the client based on the server ticket the proxy returns a 200 OK message with a Proxy Authentication Information header containing the proxy s authentication data that the client can use to authenticate the proxy. Exemplary contents of the REGISTER and 200 OK messages are as follows.

Turning now to as mentioned above in a preferred embodiment the NTLM security mechanism can be optionally used for the client proxy authentication. In this case the client first sends an INVITE message without authentication data and the proxy returns a 407 message. The Proxy Authenticate header of this 407 message indicates that NTLM should be used for authentication. The client then sends a REGISTER message with a Proxy Authentication header containing the authentication data of the client according to the NTLM protocol.

As mentioned above in connection with the state machine of the authentication data sent by the client allows the proxy to authenticate the client but the security association is not completely established based on the authentication data so the proxy sends another 407 challenge to the client again with a Proxy Authenticate header. The client then sends another REGISTER request with a Proxy Authorization header containing the authentication data required to complete the security association. The proxy server completes the security association based on the data in the second REGISTER request and returns a 200 OK message with a Proxy Authentication Information header containing authentication data about the proxy. Based on the authentication data in the 200 OK message the client authenticates the proxy and then sends out another INVITE message . Exemplary messages for this process are provided below.

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

