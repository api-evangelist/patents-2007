---

title: JEK class loader notification
abstract: A method and system for performing class loader notification. At least some of the illustrative embodiments are methods comprising raising a notification during execution of a first method (the notification based on an event), identifying the first method, and invoking a second method based on the identification of the first method in response to the notification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291435&OS=08291435&RS=08291435
owner: Texas Instruments Incorporated
number: 08291435
owner_city: Dallas
owner_country: US
publication_date: 20071212
---
The present application claims priority to EP Application No. 07291169.6 filed on Sep. 28 2007 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation based on a plurality bytecodes that define specific actions. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly.

Many times a processor that directly executes Java bytecodes is paired with a general purpose processor so as to accelerate Java program execution in a general or special purpose machine. It would be advantageous to provide accelerations similar to those seen for directly executed Java bytecodes in other languages and development environments.

In addition to using Java bytecodes to define specific actions the triggering of such actions is sometimes driven by the occurrence of specific events. An event is generated by an event source which is a Java object and which often corresponds to a user interface component such as a mouse keyboard or other user interface device. The event serves as a way to notify a listener program that something of interest has occurred such as typing of a key on a keyboard clicking of a mouse button or any other such event. When an event occurs a notification may be raised and a particular Java method may be triggered for execution. It would be desirable to define a methodology that would allow identification and execution of the proper Java method in response to the raised notification.

The problems noted above are solved in large part by a method and system for performing class loader notification. At least some of the illustrative embodiments are methods comprising raising a notification during execution of a first method the notification based on an event identifying the first method and invoking a second method based on the identification of the first method in response to the notification.

Other illustrative embodiments are computer systems comprising a processor that executes bytecodes and a memory coupled to the processor. The processor raises a notification during execution of a first method the notification based on an event that has an identification value . The processor identifies a class loader from among a plurality of class loaders wherein the class loader loaded the first method . The processor executes a second method wherein the class loader is used to select the second method based on the identification value.

Yet other illustrative embodiments are computer readable mediums storing a program that when executed by a processor of a host system causes the processor to raise a notification during execution of a first method the notification based on an event that has an identification value identify the first method and execute a second method in response to the notification wherein a class loader is used to identify the second method based on the identification value.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

The subject matter disclosed herein is directed to a programmable electronic device such as a processor. The processor described herein may be particularly suited for executing Java Bytecodes or comparable code. Java is particularly suited for embedded applications and is a relatively dense language meaning that on average each instruction may perform a large number of functions compared to various other programming languages. The dense nature of Java is of particular benefit for portable battery operated devices. The reason however for executing Java code is not material to this disclosure or the claims that follow. Further the various embodiments may be described in the context of Java but should not be limited to the execution of only Java instructions. The processor described herein may be used in a wide variety of electronic systems e.g. cell phones .

Optional processor may be referred to as a Micro Processor Unit MPU . System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise an Application Programming Interface implementation API and a Java Virtual Processor JVP discussed more below . The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

The MPU also may execute non Java instructions. For example the MPU may host an operating system O S which performs various functions such as system memory management system task management and most or all other native tasks running on the system management of the display and receiving input from input devices. Java code executed on the JVP may be used to perform any one of a variety of applications such as multimedia games or web based applications in the system while non Java code which may comprise the O S and other native applications may run on the MPU .

Most Java bytecodes perform stack based operations. For example an IADD integer add Java opcode pops two integers off the top of the stack adds them together and pushes the sum back on the stack. A simple opcode is one in which the JSM may perform an immediate operation either in a single cycle e.g. an IADD opcode or in several cycles e.g. DUP2 X2 . A complex opcode is one in which several memory accesses within the JVM or JEK data structure for various verifications e.g. NULL pointer array boundaries are made.

The JSM processor in accordance with some embodiments may execute in addition to the Java bytecodes a second instruction set other than Java bytecodes. In some exemplary embodiments the second instruction set may comprise register based and memory based operations rather than stack based operations. This second instruction set complements the Java instruction set and accordingly may be referred to as a complementary instruction set architecture C ISA . By complementary it is meant that some complex Java bytecodes may be replaced by a micro sequence comprising C ISA instructions. The execution of Java code may thus be made more efficient and run faster by replacing some opcodes by more efficient micro sequences of C ISA instructions. The JSM thus comprises a stack based architecture for direct execution of Java bytecodes combined with a register based architecture for direct execution of memory based micro sequences of C ISA instructions. Because various data structures may be JVM dependent and thus may change from one JVM implementation to another the software flexibility of the micro sequence provides a mechanism for various JVM optimizations now known or later developed.

As discussed above the JVP provides a layer of abstraction. In particular the JVP is a virtual hardware platform that is compatible with any Java API any real hardware software platform that may comprise a JSM processor or any JVM implementation. In some exemplary embodiments the JVP comprises a JEK core that has an execution engine a memory management component and a compiler. The execution engine may comprise a Bytecode engine a class loader a notification manager and an external method interface. The memory management component may comprise a memory allocator an object mapper for physically constrained objects a garbage collector a memory defragmentor and a swapper. The compiler may comprise a dynamic compiler and provide code buffer management. The JEK core may also comprise firmware to facilitate the execution of Java Bytecodes on the JSM processor.

The JVP also provides the API with methods to create software class loaders. A class loader loads classes used by an application at runtime. Other hardware components of the hardware platform or software components are virtualized within the JEK as Java Virtual Devices JVD that communicate with the JEK core. Each JVD comprises some combination of fields methods and notifications. The fields may comprise standard Java fields or may be mapped to a predefined or constrained physical memory space wherein the constraint may be due to hardware or software. The fields may also comprise a map to indirect memories. The methods may comprise standard bytecodes or may comprises JSM native code hardware instructions or may use any kind of native interface such as a Java Native Interface JNI or a KVM Native Interface KNI . The notifications may be initiated by an event for example a hardware interrupt or from software. Additionally the JEK core manages native interface links and the notification mechanism provides a way to implement flexible monitoring.

Java bytecodes may pop data from and push data onto the micro stack which micro stack comprises a plurality of gates in the core of the JSM . The micro stack comprises the top x entries of a larger stack that is implemented in data storage . Although the value of x may be vary in different embodiments in accordance with at least some embodiments the size x of the micro stack may be the top eight entries in the larger memory based stack. By implementing the micro stack hardware in the core of the processor access to the data contained in the micro stack is very fast although any particular access speed is not a limitation on this disclosure.

ALU adds subtracts and shifts data. The multiplier may be used to multiply two values together in one or more cycles. The instruction fetch logic fetches instructions from instruction storage which instructions may be decoded by decode logic . Because the JSM is configured to process instructions from at least two instruction sets the decode logic comprises at least two modes of operation one mode for each instruction set. As such the decode logic unit may comprise a Java mode in which Java bytecodes may be decoded and a C ISA mode in which micro sequences of C ISA instructions may be decoded.

The data storage comprises data cache D cache and data random access memory D RAM . The stack excluding the micro stack arrays and non critical data may be stored in the D cache while local variables and data may be stored in D RAM . The instruction storage may comprise instruction RAM I RAM and instruction cache I Cache . The I RAM may be used for opcodes or micro sequences and the I Cache may be used to store other types of Java bytecode and mixed Java C ISA instructions.

Referring now to the registers of may comprise a plurality of registers designated as R R. Registers R R R R R and R R may be used as general purposes GP registers for any purpose. Other registers and some of the GP registers may be used for specific purposes. For example registers R and R may each be used to store program counters with R storing a program counter PC for a stream of bytecodes and R storing a micro program counter micro PC for executing micro sequences. In addition to use as a GP register register R may be used to store the base address of a portion of memory in which Java local variables may be stored when used by a Java method. The top of the micro stack can be referenced by the values in registers R and R and the top of the micro stack may have a matching address in external memory pointed to by register R. The values contained in the micro stack are the latest updated values while their corresponding values in external memory may or may not be up to date. Register R provides the data value stored at the top of the micro stack. Registers R and R may also be used to hold the address index AI0 and address index AI1 . Register R may also be used to hold the indirect register index IRI . Register R may be used for status and control of the JSM . At least one bit called the Micro Sequence Active bit not specifically shown in status register R is used to indicate whether the JSM is executing by way of a micro sequence. This bit controls in particular which program counter is used R PC or R micro PC to fetch the next instruction.

As discussed above the JEK is capable of raising Java notifications based on an event. An event is generated by an event source discussed below which is a Java object and which often corresponds to a component such as the JVP itself a mouse keyboard or other device. The event serves as a way to notify a registered listener program discussed below that an event of interest has occurred such as typing of a key on a keyboard clicking of a mouse button or any other such event. When an event occurs a notification is raised and in accordance with some exemplary embodiments a particular Java method is triggered for execution in response to the notification.

In some embodiments hardware or software components may be virtualized by way of the JVD that is coupled to the JVP . When an event occurs e.g. clicking the mouse button the JVD communicates the occurrence of the event to the JVP as indicated by arrow and the JVP may raise a notification if there is a registered listener i.e. a registered event handler . A registered listener is a Java object that handles events generated by event sources. Only registered listeners may receive notifications from the JVP regarding events generated by the event sources. When a registered listener receives a notification a particular Java method is triggered for execution i.e. invoked . In embodiments of the present invention a class loader e.g. class loader or class loader assists in identifying the proper listener that is to receive an incoming notification and thus further assists in identifying the proper Java method that is to be triggered based on the notification. In addition the particular Java method that is triggered depends on the method executing within the JVP at the time the event is generated. In some embodiments the class loaders are designed to manage a plurality of notifications. In yet other embodiments the class loaders are responsible for determining which notifications to support. In still other embodiments each notification comprises a priority value assigned by the JEK and any particular notification can only be pre empted by a higher priority notification.

The class loaders assist in identifying the proper method to invoke based on the received notification. To accomplish this task in some embodiments a table is bound i.e. associated to the class loader and a table is bound i.e. associated to the class loader . As discussed above the illustrations of are exemplary and there may be more than two applications class loaders classes or methods. In particular in some embodiments each of the plurality of class loaders e.g. class loaders and may be bound to a plurality of tables. The tables may be implemented within the Java platform as separate logic in the JSM or as software within the JEK . The table comprises a plurality of entries and the table comprises a plurality of entries . The entries and may comprise one entry for each registered listener. For example if there are a total of 10 registered listeners the tables and each comprise at least 10 entries. In some embodiments each table may comprise a distinct number of entries which may correspond to each class loader e.g. class loaders and supporting a different number of notifications. In some embodiments each entry comprises at least two fields a notification identifier field and a listener field . Likewise each entry comprises at least two fields a notification identifier field and a listener field . Fields and comprise a notification identifier value corresponding to a unique event identification id that is generated by an event source indicating that an event has occurred e.g. a mouse button has been clicked . The listener fields and contain references to registered listeners that are associated with the notification identifier values stored in fields and respectively. When a notification is raised a class loader identifies a registered listener associated with a notification identifier value within a table having a value equal to the event id and an appropriate method associated with the identified registered listener is invoked. In other embodiments each entry comprises at least the listener field and an index value. Likewise each entry comprises at least the listener field and an index value. When a notification is raised a class loader may identify a registered listener based on the index value and invoke the appropriate method. In some exemplary embodiments the index value may equal the notification identifier value. In embodiments of the present invention the invoked method is dependent on the method executing within the JVP when the event is generated. In some exemplary embodiments the JEK may dynamically overwrite associations stored in the tables with new associations thus allowing any available method to be invoked by any notification identifier value and thus by any event id that is encountered.

Consider again the example as shown in and consider that an event occurs e.g. a mouse button has been clicked . An event source generates an event comprising a unique event identification id as indicated by arrow and the event id is passed to the JVP . Upon receiving the event id the JEK of the JVP identifies the method currently executing on the JVP and the JEK determines if there are any listeners registered to be notified of the occurrence of the event signified by the event id just received by the JVP . In the example of method corresponding to application is identified as the method executing upon receipt of the event id . For the purposes of this disclosure there is a negligible time lag between event generation and receipt of the event id by the JVP . A CPU object within the JEK for virtualizing the JSM then raises a Java notification . Based on the raised notification the JEK finds the class loader within the Java platform that loaded the class which corresponds to the method that was running within the JVP at the time the event id was received from the event source of the JVD . The class loader receives the notification which comprises the event id and thereby identifies the registered listener Listener within listener field associated with the event id by way of the notification identifier field within the table as indicated by arrow . Thereafter the appropriate method Method associated with the identified registered listener Listener is invoked as indicated by arrow and the notification expires.

System may be implemented as a mobile cell phone such as that shown in . As shown the mobile communication device has an outer enclosure and includes an integrated keypad and display . The JSM processor and MPU processor and other components may be included in electronics package connected to the keypad display and radio frequency RF circuitry . The RF circuitry may be connected to an antenna .

From the description provided herein those skilled in the art are readily able to combine software created as described with appropriate general purpose or a special purpose computer hardware to create a computer system and or computer subcomponents embodying aspects of the invention to create a computer system and or computer subcomponents for carrying out the method embodiments of the invention and or to create a computer readable medium storing a software program to implement method aspects of the various embodiments. Moreover the embodiments of the illustrative methods could be implemented together in a single program with various subroutines or split up into two or more programs executed on the processor.

While various embodiments of the invention have been shown and described modifications thereof can be made by one skilled in the art without departing from the spirit and teachings of the invention. The embodiments described herein are illustrative only and are not intended to be limiting. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

