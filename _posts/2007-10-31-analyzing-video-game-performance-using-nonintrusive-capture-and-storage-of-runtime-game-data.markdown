---

title: Analyzing video game performance using non-intrusive capture and storage of run-time game data
abstract: The performance of a video game is analyzed using non-intrusive capture and storage of game data. A non-linear capture format is used for capturing run-time game data. The run-time game data includes run-time parameters associated with execution of an application code as well as run-time parameters associated with hardware of a game platform upon which the application code is being executed. The captured data is stored in a storage medium using a non-contiguous storage format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667473&OS=08667473&RS=08667473
owner: Microsoft Corporation
number: 08667473
owner_city: Redmond
owner_country: US
publication_date: 20071031
---
The technical field relates generally to gaming applications and specifically relates to non intrusive capture and storage of run time game data for analyzing the performance of a video game.

It is a well known fact among engineers that tracking down and rectifying an intermittent problem poses a greater challenge than rectifying a problem that is consistently observable and quantifiable. This fact holds true in the case of video games as well. Typically an intermittent problem often referred to as a glitch manifests itself in a video game in several different ways. For example a glitch may be observed as a visual anomaly when viewing one or more images of the video game while the game is in progress. Some examples of visual anomalies include an image going black momentarily or an image freezing for some length of time. On the other hand an intermittent problem may also manifest itself in other ways. A few examples include a noticeable delay in executing a command provided through a joystick or a lack of synchronization between an image and a sound track.

Traditionally game developers attempt to rectify such problems by recreating the scenario wherein the intermittent problem was encountered and then troubleshooting the gaming application code and or the video game hardware. As can be appreciated the troubleshooting process often turns out to be a hit or miss affair for several reasons. The first reason pertains to accuracy in recreating the problem. This process involves a combination of factors some of which are readily apparent and some of which are of a subtle and complex nature that is not readily apparent. Consequently the success of the troubleshooting effort depends on the experience of the troubleshooter in predicting various possibilities for occurrence of the problem and accurately replicating the appropriate scenario.

The second reason pertains to pinpointing the root cause of the problem after observing the symptoms in the replicated scenario. Typically a software developer uses diagnostic tools such as breakpoints and customized pieces of troubleshooting code to track down the source of the problem in the gaming application code. The success of this troubleshooting effort is dependent upon the capacity of the software developer to accurately predict potential problem areas in the gaming application code and insert for example one or more customized pieces of troubleshooting code for capturing relevant performance data during execution of the gaming application code.

In contrast to the troubleshooting approach used by the software developer a hardware engineer who often works independent of the software developer may use other diagnostic tools such as a logic analyzer for example to track down a hardware component that may be malfunctioning. Here again the success of the troubleshooting effort is dependent upon the capacity of the hardware engineer to identify the problem as either a hardware problem or a problem associated with execution of the gaming application code upon the hardware. As can be appreciated this scenario often lends itself to finger pointing and blame between the hardware engineer and the software developer.

In view of the description above it can be understood that there is a need to provide solutions that address and overcome such traditional shortcomings.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description Of Illustrative Embodiments. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In one exemplary method for analyzing the performance of a video game using non intrusive capture and storage of game data a non linear capture format is used for capturing run time game data. The run time game data includes run time parameters and or run time measurements e.g. measured time to perform an action associated with execution of an application code as well as run time parameters measurements associated with hardware of a game platform upon which the application code is being executed. The captured data is stored in a storage medium using a non contiguous storage format.

Furthermore an exemplary system for analyzing the performance of a video game includes a game platform for running the video game and a debugger software module coupled to the game platform. The debugger software module is configured for capturing run time game data including audio and video data from the game platform using a non linear capture format that has minimal impact upon the performance of the video game. The captured run time game data includes run time parameters measurements associated with the video game as well as run time parameters measurements associated with hardware in the game platform. The system further includes a storage medium configured to store the captured game data in a non contiguous storage format.

It is to be understood that certain terms have been used herein merely for purposes of convenience and such usage should be interpreted broadly as would be apparent to a person of ordinary skill in the art. For example the terms software and code as used below should be interpreted as being applicable to software firmware or a combination of software and firmware. Similarly the term game data should be interpreted as being applicable to a wide variety of information pertaining to a game some of which may be captured and stored in hardware and some of which may be merely visual observations made by a developer or a game player.

The following description generally provides details of systems and methods for analyzing the performance of a video game by non intrusively capturing and storing run time game data during execution of gaming application code. Run time game data can include any combination of audio data video data GPU data CPU data or the like. The non intrusive nature of the data capture permits operation of the video game without extrinsically contributing to the problem or significantly affecting game performance. Typically the run time game data is captured using a circular data logging process whereby data is captured on a continuous basis and can be accessed at a later instant for analyzing game performance or for troubleshooting purposes.

In one exemplary application the captured game data is used for rectifying an intermittent problem that occurs during operation of the video game. To describe this exemplary application in more detail a developer notices an abnormality such as a slower than normal frame refresh rate or a suspicious spike in a particular video frame when the video game is in progress. In the background without any active intervention by the developer the data capture system has been continuously capturing run time game data. Upon noticing the abnormality the developer stops pauses the game and retrieves the captured run time game data for examining the status of various parameters at the moment in time when the abnormality occurred. This allows the developer to pinpoint the cause if any is present in the gaming application code. The captured run time data additionally provides information that may be used to identify a problem as being located in the video game hardware rather than in the gaming application code. In certain cases the root cause of the observed abnormality may be traced to a combination of software and hardware. Further details of this aspect as well as other aspects are provided below.

Application code is software firmware that is executed for running the video game on game platform . Application code may utilize a number of pre packaged software modules that are stored in one or more system libraries such as system library . This process is carried out using a first communication link that couples application code to system library and communication link that couples system library to game platform .

Debugger software module is communicatively coupled to application code system library and game platform via links and respectively . The coupling is configured for non intrusively capturing run time game data. In one exemplary embodiment debugger software module is implemented using Microsoft Xbox Debugging Module XBDM . The captured run time game data is stored in storage medium .

Debugger software module is also coupled to a performance monitor via a communications link . Performance monitor is configured for providing control signals for controlling debugger software module as well as for accessing run time game data stored in storage medium . The accessed run time data may be displayed in various formats that are suitable for analyzing gaming performance. Typically performance monitor obtains lightweight data that is a part of the run time game data stored in storage medium . Lightweight data is so called because it enables performance monitor to generate viewable information that provides a holistic high level view of video game performance without cluttering up this holistic view with details that can be obtained as and when needed.

It will be understood that performance monitor may be implemented in various alternative ways. However in one exemplary application performance monitor is implemented using tools such as Microsoft PIX or Microsoft Dr. PIX .

Storage medium may be implemented in various alternative ways as well. In a first exemplary embodiment a first in first out FIFO memory device of a suitable size may be used for storage of run time game data. The FIFO may be further configured as a circular buffer in certain applications. In an example embodiment this can be carried out by routing the output data from the FIFO back into the input of the FIFO thereby permitting circular logging of the run time game data. In an example configuration the circular buffer is a contiguous region of hard drive space and space is reclaimed when enough data has been recorded to wrap the buffer. In a second embodiment storage medium is a storage buffer such as a random access memory RAM device configured for short term storage of run time game data. The data stored in this short term storage buffer may be transferred regularly or intermittently from the short term storage buffer into a long term storage buffer such as a larger capacity hard disk. Alternatively new run time game data may be written into the RAM in selected locations that may be empty or may contain old data that is no longer needed.

Operation of system will now be described. When application code is executed certain system calls are made to system library which in turn provides instructions for running the video game on game platform . A few non exhaustive examples of the contents of system library include code for displaying graphics in a display window not shown of game platform code for generating audio in an audio transducer not shown of game platform and code for coupling game platform to a network not shown such as the Internet.

Concurrent to the process described above debugger software module is configured for capturing run time game data from each of the application code system library and game platform . Specifically run time parameters run time measurements e.g. measured time to perform an action associated with hardware of game platform is transported from game platform to debugger software module which then stores this data in storage medium . A non exhaustive list of run time parameters associated with hardware of game platform includes execution wait time GPU activity status CPU activity status CPU memory usage GPU memory usage bus activity bus contention and interrupt related activity.

Run time parameters measurements associated with execution of application code are transported from application code via link as well as from system library via link to debugger software module which then stores these run time parameters measurements in storage medium . In an example configuration there is no physical link to the debugger software module rather a section of code on the development kit is utilized rather than a separate piece of hardware. A non exhaustive list of run time parameters measurements associated with execution of application code includes frame rendering information stack information application programming interface API calls thread switches artificial intelligence AI routines and GPU related activity.

Capturing of run time game data is carried out in a non linear capture format that is designed to have minimal impact upon game performance. This minimization is desirable because the capture process is typically configured to run continuously in the background while the video game is in progress. A few examples will be used to illustrate the non linear capture format. In a first example a run time parameter associated with hardware of game platform may be captured only when the GPU is executing a low priority task or is in an idle state. Similarly a parameter pertaining to the CPU may be captured only when the CPU is in an idle state or in a wait state. In a second example a run time parameter associated with hardware of game platform is captured through a hardware device such as a data buffer that can continuously couple data out of a data bus without affecting data throughput to other hardware devices coupled to the data bus.

Capture of run time parameters measurements associated with execution of application code is also carried out using the non linear capture format. In one example the capture is carried out upon malfunctioning code such as those associated with halted threads unfulfilled interrupt requests and abnormal frame rendering. Capturing such items that are not currently active avoids impacting game performance which can continue to run without interruption. However the capture is not limited to such items because pertinent information is also desirable from currently running processes. For example in one typical capture process debugger software module tracks each instrumented API call and stores information pertaining to the API call as well as time stamps associated with the API call. In other capture processes debugger software module captures and stores run time game data associated with call stacks timing of events and user data.

In addition to the capture of the run time game data described above in another exemplary embodiment debugger software module captures and stores video image information in the form of one or more video images that are displayed in the display not shown of game platform . This image information is useful in certain cases for troubleshooting purposes. For example if a particular video image contains a black square area a developer can use this information to examine frame rendering game data at the time of occurrence of the video image to look for anomalies in the execution of a certain portion of application code .

In various exemplary embodiments run time game data whether in the form of run time parameters measurements associated with execution of application code or in the form of run time parameters measurements associated with hardware of game platform is captured using a frame format so as to allow performance monitor to display performance data in a frame by frame format. Consequently a developer can selectively view one or more frames where a performance glitch occurred some time earlier for carrying out performance analysis on a frame by frame basis. The developer can alternatively view the performance data in a timing mode that accommodates performance analysis on a time related basis. Viewing of performance data will be described below in further detail using other figures.

As can be understood the first and second set of GPU parameters are now stored in segments one and three that are not located adjacent to one another. This method of non contiguous storage enables debugger software module to capture run time game data in accordance with a capture sequence that is non linear and most suitable for having the least impact upon game performance. At a later instance in time when a developer desires to review GPU performance performance monitor accesses the first and the third memory segments of storage medium and suitably concatenates the GPU data for review by the developer.

System monitor display window hereinafter referred to as system monitor provides a graphical display of run time parameters measurements in terms of data statistics captured over a sequence of video gaming frames. In one example the data statistics is a count value pertaining to the number of occurrences of a monitored gaming parameter such as for example D3D locks. A D3D lock is a lock used to guard data shared by CPU and GPU devices. Consequently the number of D3D locks occurring on a real time frame by frame basis can be seen in system monitor . It will be understood that various run time parameters measurements can be selected for monitoring together with selectable priority levels and other performance metrics. A few non exhaustive examples of viewable run time parameters measurements include redundant states number of thread switches in a kernel sleep time ratio of bytes read to number of requests.

Below the graphics display of monitor display window is a tabular display that provides numerical information pertaining to the various graphs displayed in graphical display . The first column of tabular display identifies a particular graph. In the illustration of the graphs have been identified by various types of lines such as solid dashed and dotted lines. However this format has been utilized merely for ease of description. In a practical set up each of the graphs may be identified by a unique color and each of the colors is identified in the first column of tabular display . For example graph which is identified in using a solid line may be identified by a red color and cell of the first column of tabular display would be shaded red correspondingly. Other identification means may be similarly used for identifying the individual graphs.

The second column of tabular display provides list of performance metrics associated with various run time parameters measurements. In this exemplary embodiment the entries in the second column correspond to various counters that are used to obtain count values of certain performance metrics that are used to analyze the performance of the video game. The counters may be provided to correspond to a set of pre determined performance metrics that are selected by a manufacturer of performance analyzer system . Alternatively performance analyzer system may be configured to permit a developer or other individual to define one or more counters for various performance metrics that are of particular interest to the developer.

The third column of tabular display lists the scaling factors for each of the graphs of graphics display while the fourth and fifth columns provide minimum and maximum values of the corresponding monitored run time parameters measurements.

Diagnostics display window Dr. PIX Monitor provides data statistics pertaining to the run time parameters measurements and specifically provides data related to one or more monitored parameters that fall outside a pre determined threshold. In the exemplary view shown in a first column of diagnostics display window lists warnings related to the monitored parameters. The first warning indicates too many D3D locks while the second warning indicates too many debug prints. The second column of diagnostics display window lists the priority level of each of the warnings of column 1. The priority levels may be pre determined by a manufacturer of performance monitor or may be selectably set by a game developer or other user of performance monitor . The third column of diagnostics display window lists the count value for each of the warnings of column 1 while the fourth column provides frame information of where the warning occurred in the sequence of frames displayed in graphical display .

Diagnostics display window as well as system monitor may include soft keys for carrying out various operations such as for example Pause Stop Print Store Ignore Hide Edit and Clear. While the functionality of some of these soft keys is self evident it may be pertinent to point out certain features in some others. The Save key not shown is used to save the warnings in a database or file the Ignore key not shown is used to selectively ignore certain warnings the Hide key not shown is used to hide diagnostics display window the Edit key not shown to edit the warning conditions so as to make them visible or invisible and the Clear key soft key is used to clear the contents of diagnostics display window . The Stop key soft key is used to freeze the display so that a developer can examine and analyze displayed parameters.

Furthermore each of the cells in tabular display and or diagnostics display window may be configured in various ways. For example a cell may be configured as a soft key which when activated leads to a further operation such as providing an additional display. A cell may be further configured to be editable whereby for example the text content may be modified or a numerical parameter set to a desired value.

The processing portion is capable of implementing various functions of the system such as those provided by debugger software module performance monitor application code system library and game platform .

The processor can be implemented as a client processor and or a server processor. In a basic configuration the processor can include at least one processing portion and memory portion . The memory portion can store any information utilized in conjunction with non intrusive capture and storage of run time game data and or for analyzing the performance of the video game. Depending upon the exact configuration and type of processor the memory portion can be volatile such as RAM non volatile such as ROM flash memory etc. or a combination thereof. The processor can have additional features functionality. For example the processor can include additional storage removable storage and or non removable storage including but not limited to magnetic or optical disks tape flash smart cards or a combination thereof. Computer storage media such as memory portion and include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices universal serial bus USB compatible memory smart cards or any other medium which can be used to store the desired information and which can be accessed by the processor . Any such computer storage media can be part of the processor .

The processor can also contain communications connection s that allow the processor to communicate with other devices such as other devices for example. Communications connection s is an example of communication media. Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media. The processor also can have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. also can be included.

A computer system can be roughly divided into three component groups the hardware component the hardware software interface system component and the applications programs component also referred to as the user component or software component . In various embodiments of a computer system the hardware component may comprise the central processing unit CPU the memory both ROM and RAM the basic input output system BIOS and various input output I O devices such as a keyboard a mouse a monitor and or a printer not shown among other things. The hardware component comprises the basic physical infrastructure for the computer system.

The applications programs component comprises various software programs including but not limited to compilers database systems word processors business programs videogames and so forth. Application programs provide the means by which computer resources are utilized to solve problems provide solutions and process data for various users machines other computer systems and or end users . In an example embodiment application programs perform the functions associated with debugger software module performance monitor application code system library and or game platform .

The hardware software interface system component comprises and in some embodiments may solely consist of an operating system that itself comprises in most cases a shell and a kernel. An operating system OS is a special program that acts as an intermediary between application programs and computer hardware. The hardware software interface system component may also comprise a virtual machine manager VMM a Common Language Runtime CLR or its functional equivalent a Java Virtual Machine JVM or its functional equivalent or other such software components in the place of or in addition to the operating system in a computer system. A purpose of a hardware software interface system is to provide an environment in which a user can execute application programs.

The hardware software interface system is generally loaded into a computer system at startup and thereafter manages all of the application programs in the computer system. The application programs interact with the hardware software interface system by requesting services via an application program interface API . Some application programs enable end users to interact with the hardware software interface system via a user interface such as a command language or a graphical user interface GUI .

A hardware software interface system traditionally performs a variety of services for applications. In a multitasking hardware software interface system where multiple programs may be running at the same time the hardware software interface system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The hardware software interface system also manages the sharing of internal memory among multiple applications and handles input and output to and from attached hardware devices such as hard disks printers and dial up ports. The hardware software interface system also sends messages to each application and in certain case to the end user regarding the status of operations and any errors that may have occurred. The hardware software interface system can also offload the management of batch jobs e.g. printing so that the initiating application is freed from this work and can resume other processing and or operations. On computers that can provide parallel processing a hardware software interface system also manages dividing a program so that it runs on more than one processor at a time.

A hardware software interface system shell referred to as a shell is an interactive end user interface to a hardware software interface system. A shell may also be referred to as a command interpreter or in an operating system as an operating system shell . A shell is the outer layer of a hardware software interface system that is directly accessible by application programs and or end users. In contrast to a shell a kernel is a hardware software interface system s innermost layer that interacts directly with the hardware components.

As shown in an exemplary general purpose computing system includes a conventional computing device or the like including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device may further include a hard disk drive for reading from and writing to a hard disk hard disk not shown a magnetic disk drive e.g. floppy drive for reading from or writing to a removable magnetic disk e.g. floppy disk removal storage and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computing device . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment. Likewise the exemplary environment may also include many types of monitoring devices such as heat sensors and security or fire alarm systems and other sources of information.

A number of program modules can be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device e.g. mouse . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computing devices typically include other peripheral output devices not shown such as speakers and printers. The exemplary environment of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computing device may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computing device e.g. personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device although only a memory storage device floppy drive has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computing device is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computing device can include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computing device or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

While it is envisioned that numerous embodiments of non intrusive capture and storage of run time game data and or analysis of the performance of a video game are particularly well suited for computerized systems nothing in this document is intended to limit the invention to such embodiments. On the contrary as used herein the term computer system is intended to encompass any and all devices capable of storing and processing information and or capable of using the stored information to control the behavior or execution of the device itself regardless of whether such devices are electronic mechanical logical or virtual in nature.

The various techniques described herein can be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatuses for non intrusive capture and storage of run time game data and or analysis of the performance of a video game or certain aspects or portions thereof can take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for implementing non intrusive capture and storage of run time game data and or analysis of the performance of a video game.

The program s can be implemented in assembly or machine language if desired. In any case the language can be a compiled or interpreted language and combined with hardware implementations. The methods and apparatuses for implementing non intrusive capture and storage of run time game data and or analysis of the performance of a video game also can be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer or the like. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of non intrusive capture and storage of run time game data and or analysis of the performance of a video game. Additionally any storage techniques used in connection with non intrusive capture and storage of run time game data and or analysis of the performance of a video game can invariably be a combination of hardware and software.

While non intrusive capture and storage of run time game data for analyzing the performance of a video game has been described above using exemplary embodiments and figures it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiments for performing the same functions without deviating therefrom. Therefore non intrusive capture and storage of run time game data and or analysis of the performance of a video game as described herein should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

