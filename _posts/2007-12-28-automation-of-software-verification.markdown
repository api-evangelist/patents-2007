---

title: Automation of software verification
abstract: A method, system, and computer program product are disclosed for automatic test generation for a compiler. In one approach, the method, system and computer program product represent a test case for the compiler in a structure with one or more elements of a programming language, associate at least one syntactic rule and semantic rule with the one or more elements in the structure, create a test with the structure compiling the test with the compiler, and display results of the test.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08156474&OS=08156474&RS=08156474
owner: Cadence Design Systems, Inc.
number: 08156474
owner_city: San Jose
owner_country: US
publication_date: 20071228
---
The goal of software verification is to ensure that error free software has been produced and is an essential part of software development. Software verification is generally accomplished with Black Box Testing. Black Box Testing consists of activating a software application with a set of inputs or test cases and comparing the output produced by the software application to the expected output from the software application. To ensure that a software application is error free a set of possible test cases are created for the software application and used to activate the software application under test with the test cases. Large scale software applications tend to require a vast number of test cases with an infinite number of permutations of inputs. However it is often impractical for one to manually create a set of all possible inputs and permutations of inputs for the test cases and therefore automatic verification is a preferred approach for testing large scale software applications.

A compiler is a computer program that translates a high level programming language such as C or JAVA into a lower level language such as machine code assembly or an intermediate bytecode form that can run on a virtual machine. A compiler checks for errors in the input program files that are to be translated by the compiler. When a compiler discovers an error in the input program file that is being compiled the compiler may indicate both the error and the occurrence of an error during the compilation. When a compiler successfully translates the input file an executable is generated.

A compiler is verified by compiling a set of programs or test cases with the compiler and comparing the output from the compiler with the expected output of the compiler. Theoretically a complete verification of a compiler requires a set of all possible test cases. However there are an infinite number of computer programs that can be compiled such that a complete verification of a compiler is unachievable. A practical approach for compiler verification is to create output producing test cases that contain all words in the high level programming language and all the possible combinations of the words or statements in the language. The verification of all the words elements and statements defined as a combination of elements in a programming language of a programming language is referred to as checking the syntax. Verification of a compilers ability to handle the syntax of a programming language alone is insufficient because the compiler must handle the semantic constraints of the programming language.

The semantics of a programming language takes in to consideration the context the surrounding statements or environment for the statement or element in the program. For example it is possible that an action or statement may be correct within a loop construct in the language but the same action or statement may be incorrect within a conditional if statement construct. Semantics are an important part of a high level programming language because the sentences or statements in the program are dependent upon each other. For example in some high level programming languages the statement x 5 cannot be written in the program without first declaring int x in the program. Such semantic checks are called Static Semantics. In some programming languages the statement x y z cannot be written when z is equal to zero. These types of checks are Dynamic Semantics checks because the checks involve evaluation rules of the language.

Compiler verification is done by compiling and running test cases with predicted run results and comparing them to the actual run results at the end. Compiler verification must contain both legal and illegal test cases for complete verification of the ability for the compiler to handle the syntax and semantics of the high level programming language. Illegal test cases may be input to the compiler in order to verify the error handling ability of the compiler. Legal test cases may be input to the compiler to test the compiler s ability to generate and executable. As a result complete compiler verification may require tens of thousands of test cases to cover every possible test case.

An approach for compiler verification is the manual creation of program files and an expected output file corresponding to each program file. Approaches involving manual creation of test cases may not handle all the relevant cases and make it difficult to handle updates of the programming language because the programs and expected output files must be manually altered. Obviously the large amount of possible test cases makes it impossible for human to cover all the scenarios.

Automation of compiler verification involving the generation of test cases that is capable of programming meaningful test cases with algorithms that mimic those created by a programmer of a high level language in order to test the semantics of the programming language requires an extremely high level of Artificial Intelligence AI . The complexity involved in developing such an AI solution for compiler verification makes such an approach infeasible. Yet testing a compiler without semantic checks on meaningful test cases does not allow for an accurate verification of the compiler. Thus the ability to automate compiler verification would significantly increase the verification quality while reducing the time it consumes.

A method system and computer program product are disclosed for automatic test generation for a compiler. In one approach the method system and computer program product represent a test case for the compiler in a structure with one or more elements of a programming language associate at least one syntactic rule and semantic rule with the one or more elements in the structure create a test with the structure compiling the test with the compiler and display results of the test.

The present invention is directed toward methods systems and computer program products for automatic generation of compiler tests.

Embodiments of the present invention implement automatic generation of compiler tests in order to verify the compiler. A test for a compiler is a computer program source code or portion of a computer program written in the programming language supported by the compiler. The automatic test generator creates tests for a compiler with test cases that cover the interesting semantic and syntactic scenarios supported by the programming language.

Next the syntactic and semantic rules for each element of the programming language are associated with the elements in the structure that correspond to the rules for the elements of the programming language . Each element of the structure may have rules that restrict the elements related to that particular element. Related elements are connected to the element in the hierarchical structure. In one or more embodiments the structure is a syntax tree a hierarchy of nodes or elements that abide by the syntax rules of the programming language. For example a syntax tree is created by starting with a root node or element and each element becomes responsible for creating its own subtree. An element selects the syntactic properties of its child nodes such as the element that may have two expression child nodes. The semantic manager may use the context information and semantic filters to create a legal instance of each element.

The syntactic rules may be defined in a class definition for the element or node and the semantic rules may be associated with the element or node when the element or node is instantiated with the class constructor during the creation of the tree or structure. When the syntax tree is created the elements of the syntax tree may be instantiated with the class constructors for the elements in the class definition thereby associating the semantic rules with the elements of the syntax tree. In one or more embodiments a semantic manager may associate the semantic rules with the elements of a syntax tree. A semantic manager may use the rules associated with each element to call methods that filter out illegal elements or sub elements to be created for that element. In some embodiments a semantic manager may be implemented with a factory design pattern. Each parent element may call the semantic manager associated with the parent element to filter or select legal sub elements for the parent element.

The tests for the compiler may then be created using the structure . Embodiments of the invention may create the test for the compiler by stepping through the elements in the structure and writing the necessary statements lines of source code or portions of statements in the test file for each of the elements in the structure. The statements written to the test file may be incorrect usage of the elements of the programming language in the structure to test the error handling of the compiler under test. Optionally the elements may provide information on the statements that can be placed in the test files which can be displayed to the user to alert the user of the progress of the current generation of the test file.

After the tests have been created the tests may then be compiled with compiler and the results from the compilation are indicated. The results may be displayed or stored for later access . In one or more embodiments the test file may include statements that display the success or failure of the compilation of the test. Embodiments may generate tests that have statements within the test that allow for writing to standard error or an output file with the results of the compilation of the test. An output file may be used for comparison with an expected output file to verify the compiler in regards to the particular test.

The Element Definitions may define actions and expressions that are permitted in the programming language. An element may be a composite of one or more elements or sub elements. A Test Generator may employ the use of Expression and Action Factories to create the Test Case Structure with elements that comply with legal programming language expressions and actions for the programming language. The Expression and Action Factories constrain the type and characteristics of the sub elements. Each Element Definition may have the Element Syntax Rules Element Semantic Rules and Element Self Code Generation Options. The Element Self Code Generation Options may allow for the display of results of the test of a particular element of the programming language. The Test Generator builds a Test Case Structure using the Element Definitions in the Programming Language Library . The Test Case Structure defines the test case that will be generated by the Test Generator .

In one or more embodiments the Test Case Structure is a hierarchical structure such as a tree. Each node of the tree is an element of the programming language and each child of the node is a sub element of the element. The Test Generator creates a syntactically correct test case with the hierarchical creation of the Test Case Structure using the rules provided in the Element Definition . For example a plus mathematic expression will have two operands required by the hierarchy.

In one or more embodiments the Test Generator is able to test the semantics of the programming language by using a Semantic Manager . A Semantic Manager has the Current Context for the test case as it is being generated and constrains the elements of the tree to be semantically correct. By way of illustration Test Generator in has a Semantic Manager with the current context data including the current scope and methods for the Test Case Structure . For example a plus mathematic expression needs two operands as required by the hierarchy of the tree and the operands need to be of numeric type. Further an operand that is a variable may need to be initialized to be of numeric type and the current scope may contain the information as to whether an operand is of numeric type and whether a variable has been initialized e.g. int x and int y prior to the statement x y 1 . The syntax language tree construction may be accomplished by recursively building layers of tree elements where each element is responsible for the creation of its sub tree using the Test Generator which is aware of the context for the elements being created.

Compiler testing consists of both legal and illegal tests as an input so that syntactic semantic error detection is provided as part of the testing process. Based on the structure of the tree self checking code segments may be created by each code element and inserted at different points according to the semantic restrictions. The tests may be enhanced by random insertion of noise mechanisms such as Garbage Collection and other language neutral actions. For example tests may allow for statements that intend to free unused memory e.g. delete free or check the value of variable to ensure that the garbage collection statements did not corrupt the variable value.

The Test Plan Parser is an optional component of automatic test generation that allows the user to specify concrete aspects of the language to test and is useful when adding or changing an element in the language. The Test Plan Parser may allow the user to define the coverage demands of a set of tests. By default the requested coverage may be all the permutations of the defined elements. In one or more embodiments the Test Plan Parser may allow the user to specify the test of define corner cases of a programming language. For example all datatypes that may appear in print actions may be designated by the user as a set of elements of the programming language to test. Often it is difficult to randomly create tests for interesting features of an action or an expression. For example it may be useful to the user to check the assignment of negative number to an unsigned numeric type variable. The user may want to specify that the tests include particular input datatypes actions expressions or contexts. For example the user may desire to check that an assignment of a variable is correct in an if action statement and a for action statement.

The Code Coverage is an optional component that may pass on the generated test case syntax tree to collect information on the created elements and their dependencies with other elements. The generated tests can then be checked for their coverage of the programming language in the Analyzer .

The Analyzer is responsible for managing the executed tests. The Analyzer may receive the executed tests from the Runner and catalogues them in a database. The Analyzer may report on the pass or failure of a test and sort the tests and test results.

The Runner is a connection with an external application that is responsible for compiling and running the tests. The runner may be as simple as running a shell command or use a more complex interface.

The tests may be stored for later regression testing in Regression test storage. In one or more embodiments the Regression test storage may be a database.

In the following description numerous details are set forth for purpose of explanation. However one of ordinary skill in the art will realize that various embodiments of the invention may be practiced without the use of these specific details. In other instances well known structures and devices are shown in block diagram form in order not to obscure the description of various embodiments of the invention with unnecessary detail.

According to one embodiment of the invention computer system performs specific operations by processor executing one or more sequences of one or more instructions contained in system memory . Such instructions may be read into system memory from another computer readable usable medium such as static storage device or disk drive . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and or software. In one embodiment the term logic shall mean any combination of software or hardware that is used to implement all or part of the invention.

The term computer readable medium or computer usable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as disk drive . Volatile media includes dynamic memory such as system memory .

Common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

In an embodiment of the invention execution of the sequences of instructions to practice the invention is performed by a single computer system . According to other embodiments of the invention two or more computer systems coupled by communication link e.g. LAN PTSN or wireless network may perform the sequence of instructions required to practice the invention in coordination with one another.

Computer system may transmit and receive messages data and instructions including program i.e. application code through communication link and communication interface . Received program code may be executed by processor as it is received and or stored in disk drive or other non volatile storage for later execution.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example the above described process flows are described with reference to a particular ordering of process actions. However the ordering of many of the described process actions may be changed without affecting the scope or operation of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

