---

title: Framework for creating user interfaces containing interactive and dynamic 3-D objects
abstract: An arrangement for creating a fully interactive user interface containing 3-D objects is provided by a suite of attached dependency properties in a single class that operates under the Windows Presentation Foundation (“WPF”) programming model. The framework for exposing such 3-D interactive functionality, named Facade 3-D, enables application developers to extend the existing functionality of WPF visual objects called FrameworkElements through mapping objects they have defined with 2-D visual trees to 3-D trees which contain arbitrary, application-defined 3-D models. Application users are enabled with highly-configurable ways to interact with the underlying source 2-D FrameworkElements vicariously through manipulation of their 3-D representations called “Facades.”
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07818690&OS=07818690&RS=07818690
owner: Microsoft Corporation
number: 07818690
owner_city: Redmond
owner_country: US
publication_date: 20070615
---
The Microsoft .NET Framework is a managed programming model for Microsoft Windows that includes Windows Presentation Foundation WPF . WPF provides application developers with a unified programming model for building rich Windows smart client user experiences particularly including user interfaces UIs that make better use of current hardware and technologies. WPF provides a richer set of drawing features and performs considerably faster than its predecessor the Win32 based UI graphics subsystem using Microsoft Windows Graphics Device Interface GDI and Microsoft Windows GDI which were originally developed more than 20 years ago.

WPF provides developers with a way to create applications having advanced UI graphics with fewer constraints in how graphical elements are controlled. WPF provides a library of commonly used vector drawn 2 D two dimension shapes such as rectangles and ellipses which are not just shapes but are programmable elements that implement many of the features expected from most common controls including keyboard and mouse input. If the shapes in the library are not sufficient WPF can support geometries and paths by which developers may create custom shapes or use as drawing brushes or use to clip other WPF elements.

WPF provides a library of 2 D classes that a developer may use to create a variety of effects. The 2 D rendering capability of WPF provides the ability to paint UI elements using brushes. Use of a Visual Brush for example enables a UI element to be painted with any visual tree. Those UI elements in the visual tree may be manipulated by using translation rotation scaling and skewing. WPF further provides a set of 3 D three dimensional rendering capabilities that integrate with 2 D graphics support in WPF so that developers can create interesting layouts UIs and data visualizations. The WPF 3 D implementation allows developers to draw transform and animate 3 D graphics in both mark up and procedural code. Developers can combine 2 D and 3 D graphics to create rich controls provide complex illustrations of data or enhance the user experience of an application s interface.

While the WPF 3 D capabilities are well suited to many scenarios the 3 D objects in a UI space are limited in that they are not interactive or dynamic in the same manner as their WPF 2 D counterparts. While an application developer can presently take a 2 D interface and place it on a 3 D surface there is no currently supported functionality in WPF to enable interaction with that interface while in the 3 D space. For example a UI might include some controls such as buttons scroll bars and text entry boxes. While WPF currently supports user interaction with the UI to enable the buttons to be pushed scrolls bars to be used and text to be entered by the application s user such supported interaction ends once the interface is put into the 3 D space.

This Background is provided to introduce a brief context for the Summary and Detailed Description that follow. This Background is not intended to be an aid in determining the scope of the claimed subject matter nor be viewed as limiting the claimed subject matter to implementations that solve any or all of the disadvantages or problems presented above.

An arrangement for creating a fully interactive and dynamic UI containing 3 D objects is provided by a suite of attached dependency properties in a single static class that operates under the WPF programming model. The framework for exposing such 3 D interactive functionality named Facade 3 D enables application developers to extend the existing functionality of WPF interactive visual objects called FrameworkElements. This is accomplished by mapping FrameworkElements that comprise 2 D visual trees they have defined to 3 D objects with arbitrary 3 D geometry that are assembled into a parallel 3 D visual tree. Application users are enabled with highly configurable ways to interact with the underlying source 2 D FrameworkElements vicariously through manipulation of their 3 D representations called Facades. 

In an illustrative example the mapping of the 2 D visual tree to the 3 D visual tree is effectuated using an interface comprising XAML accessible eXtensible Application Markup Language accessible static attached dependency properties that are definable by the application developer on the source FrameworkElements. Application developers may create interactive UIs in a typical manner for a 2 D WPF application by defining a variety of FrameworkElements and then providing these objects with 3 D facades having interactive and visual properties that are controllable using the developer defined attached dependency properties. Advantageously very few new objects need to be explicitly defined by the application developer to fully specify the desired interactive 3 D functionality.

The 2 D visual tree hierarchies are utilized by the Facade 3 D framework to systematically construct and synchronize the structures of the corresponding 3 D visual trees. In addition Facade 3 D further automatically moves the 2 D visuals of the source FrameworkElements off the display screen so that only the Facade 3 D geometry remains visible and available for interaction.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

The primary WPF programming model is exposed through managed code classes in the WPF .NET application development environment that run on top of the common language runtime CLR . shows the major code components of the WPF architecture which include a Presentation Framework Presentation Core and Milcore where Mil stands for Media Integration Library . Of these components only Milcore which functions as the low level WPF graphic composition engine represents an unmanaged component. Milcore is written in unmanaged code to enable tight integration with the DirectX APIs .

All UI display in WPF is done through the DirectX APIs application programming interfaces to the kernel to thereby communicate with the operating system and or graphic drivers etc. which thus allows for efficient hardware and software rendering. While the User32 library is utilized to interact with various legacy elements for example to handle allocation of space to windows on the display the DirectX APIs renders all of the content inside the window.

The CLR is the core runtime engine in the Microsoft .NET Framework for executing applications. The CLR supplies the managed code components the Presentation Framework and Presentation Core with services such as cross language integration code access security object lifetime management resource management type safety pre emptive threading metadata services type reflection and debugging and profiling support.

The Presentation Framework sits at the top level in the WPF architecture and provides a managed API that provides access to the underlying functionality. Many developers working in the WPF environment will work exclusively with this Presentation Framework . The framework includes a large number of standard controls such as Button Label Menu layout panels 2 D and 3 D graphics and text primitives support for imaging effects media animation and document services and support for interoperability with GDI DirectX and Windows Forms GDI .

The Presentation Core is a lower level API in the WPF architecture that enables interaction between the development framework provided by the managed Presentation Framework and the unmanaged WPF graphics handling core comprised of Milcore and the DirectX APIs . Most elements in WPF derive from a base Visual class which is exposed by the Presentation core API. The Visual class is the base abstraction by which data is composited for output onto the screen and thus provides for building a tree of visual objects by WPF applications where each visual tree optionally contains drawing instructions and metadata about how to render those instructions clipping transformation etc. .

Visual objects in the Visual class are the core WPF objects whose primary role includes providing graphic rendering support. The Visual object provides support for output display transformations clipping hit testing i.e. determining whether a coordinate or geometry is contained within the bounds of the visual object and bounding box calculations. However the Visual object does not include support for non rendering functions such as event handling layout styles data binding or globalization.

The UIElement class is a base class for WPF implementations that provides a starting point for element layout services and also exposes virtual methods that derived classes can override which can influence the layout rendering behavior of the element and its child elements. Much of the input and focusing behavior for elements in general is also defined in the UIElement class . This includes the events for the keyboard mouse and stylus input and related status properties. The UIElement also includes APIs that relate to the WPF event model including methods that can raise specific routed events that are sourced from an element instance.

The FrameworkElement class is the connecting point between WPF framework level element classes and the WPF core level set of UIElement presentation services. Accordingly FrameworkElement builds on the layout introduced by UIElement and makes it easier for layout authors to have a consistent set of layout semantics. As noted above it allows the developer to override the automatic layout functionality introduced by UIElement by specifying alignment and layout properties for controls. In addition two critical elements that FrameworkElement introduces to the WPF are data binding which enables application developers to bind and manipulate within applications and styles which are a set of properties applied to content used for visual rendering.

WPF 3 D views are composed within a Viewport3D and typically use one or more objects to describe geometry light sources camera view and material. Material is described using a property in WPF properties are described below in more detail which indicate the surface conditions of a 3 D model. If the property is empty then the model is not visible in the UI. The Visual3D class is the base class for all 3 D visual elements in WPF. The ModelVisual3D class provides services and properties common to all 3 D visual objects including hit testing and coordinating transformation.

WPF applications can be deployed on a desktop PC personal computer or hosted in a web browser for example and can provide very graphic rich user experiences. WPF applications are typically built using a number of Extensible Application Markup Language XAML pronounced ZAM el pages plus optional supporting code called code behind. The XAML markup is utilized to declaratively set application properties resources and register events while handling events and implementing the application specific behavior in the code behind.

At the core of all WPF applications is the Application object which operates in the Presentation Framework . The Application object forms the interface between the application and the operating system and enables the application to be managed as a collection of XAML pages.

A WPF application works by creating a tree of elements through the XAML markup and optional code behind that becomes the application s visual tree. The visual tree contains all the visual elements used in an application s UI. Since a visual element contains persisted drawing information the visual tree may be thought of as a scene graph containing all of the rendering information needed to compose the output to a display device. The visual tree is thus the accumulation of all visual elements created directly by the application whether in markup or code. The visual tree also contains any visual elements that may be created through application of any templates.

As shown in a simplified graphical representation of a visual tree is created by a WPF application on a UI thread in managed code in the Presentation Framework . The visual tree is communicated via the Presentation Core to the Milcore over a communication channel as a data structure where it is effectively replicated on a rendering thread as a composition tree . Note that the visual tree and composition tree are not necessarily identical. For example off screen elements in the visual tree may not be included in the composition tree .

The rendering thread is responsible for traversing i.e. walking the composition tree and rendering the UI through the DirectX APIs . When an application wants to make a change to the displayed UI the markup or code results in edits to the visual tree for example by child elements being added or removed the modifications to the visual tree are sent as edits which are then reflected in the composition tree . The rendering thread then re composes and re renders the changed portions of the UI although it does not re render some element s sub trees in the composition tree that for example are occluded in the UI display.

A WPF application utilizes a set of services which can be used to extend the functionality of a CLR property. Collectively these services are known as the WPF property system. A property that is backed by the WPF property system is known as a dependency property.

The purpose of dependency properties is to provide a way to compute the value of a property based on the value of other inputs. These other inputs might include system properties such as themes and user preference just in time property determination mechanisms such as data binding and animations storyboards multiple use templates such as resources and styles or values known through parent child relationships with other elements in an element tree.

In addition a dependency property can be implemented to provide self contained validation default values callbacks that monitor changes to other properties and a system that can coerce property values based on potential runtime information. Derived classes can also change some specific characteristics of an existing property by overriding dependency property metadata rather than overriding the actual implementation of existing properties or creating new properties.

The WPF property system further includes a metadata reporting system that goes beyond what can be reported about a property through reflection or CLR characteristics. Metadata for dependency properties can also be assigned uniquely by the class that defines a dependency property and can be changed when the dependency property is added to a different class and be specifically overridden by all derived classes that inherit the dependency property from the defining base class.

XAML defines a concept called an attached property which is intended to be used as a type of global property that is settable on any object. Under the WPF framework most attached properties are implemented as dependency properties. Attached properties are set using the syntax 

Attached dependency properties are often created in order to have a property setting mechanism available for classes other than the defining i.e. owning class. The present framework for creating UIs containing 3 D objects uses attached dependency properties in another way in order to implement a service in which the Facade 3 D class represents a 3 D functionality service that is available to other WPF classes in particular FrameworkElement. Using attached dependency properties in such a manner enables such classes to integrate the 3 D functionality service very transparently.

Accordingly one of the main components of Facade 3 D is a single static WPF class that defines attached dependency properties and associated methods that are used to enhance implementations of existing instances of 2 D FrameworkElements to thereby enable a 3 D UI to incorporate much of the interactivity that is built into the UI provided by the underlying 2 D FrameworkElements. This aspect of the present arrangement advantageously enables WPF application developers to avoid needing to create custom 3 D objects or subclasses to re implement such interactivity. Instead they can leverage their existing FrameworkElement properties.

For example if an application developer wants to create a 3 D object with button functionality then rather than creating code for button like functions into a new 3 D object or subclass of an existing FrameworkElement the developer can simply provide an existing instance of a WPF button with the Facade 3 D attached dependency properties. In most cases this can be done purely with XAML without having to provide any code behind. Use of such a technique advantageously enables application developers to develop complete and functional traditional 2 D UIs first and then transform them into fully functional interactive 3 D UIs later simply by defining certain attached properties on the original 2 D objects.

Shown below is the application markup expressed in XAML that is associated with the UI shown in and the 2 D visual tree that is shown in . The markup is used to define the UI elements data binding eventing and other features provided by the WPF framework as required to implement the illustrative 2 D UI shown.

The markup below shows the original application XAML as enhanced by the present Facade 3D framework. The differences from the original 2 D application XAML are underlined.

The utilization of the Facade 3 D enhanced application XAML shown above results in a UI having fully interactive 3 D objects as shown by the illustrative screenshot in . In this particular illustrative example of Facade 3 D no application level code behind is used.

The 3 D UI uses the same CD jewel boxes indicated by reference numeral in as are used in the illustrative WPF 2 D UI shown in . But rather than simply scrolling along in a flat linear window in response to user input the CD objects rotate in a 3 D carousel arrangement . When a user selects a particular CD object through a mouse click anywhere on the 3 D facade the carousel is animated to rotate and then the selected CD object moves from its position in the carousel to a front and center position as shown by CD object which has its graphic artwork represented by the letter G . When another CD object is selected by the user in the UI the previously selected CD object moves from its front and center position back to a slot in the carousel . Keyboard functionality is also maintained from the 2 D example shown in because the underlying 2 D visual tree is persisted.

FrameworkElements may implement a facade through definition of a Facade3D.Visual3DTemplate that uses a ModelVisual3D object containing a template of a desired 3 D geometry. Examples of this technique are shown by the ListBox control that uses RackVisual the Rectangle control that uses xyPlaneVisual and ListBoxItem 1 2 . . . N that use CubeVisual. ModelVisual3D templates may be specified as resources for example in a ModelVisual3D repository at the application level.

The markup below shows several illustrative examples of ModelVisual3D template objects. Such objects could be stored for example in a general purpose ModelVisual3D repository.

Other ModelVisual3D template objects may include application specific ModelVisual3D templates. An illustrative example is shown below.

The Facade 3 D framework generates a suite of 3 D transformations having six degrees of freedom with scaling the 6 D O F Transformation Stack using an ordered transformation stack and assigns the transformation stack to the ModelVisual3D that makes up the Facade3D.Visual3D. These transformations are 

The following are the attached dependency properties exposed by the Facade 3 D framework that are each configured to map to a transformation 

By setting and animating these properties 3 D facades applied to FrameworkElements can be controlled using six degrees of freedom plus scale.

These properties may also be controlled within current WPF Bindings Style Setters Triggers etc. just like any other property on the source FrameworkElement. Moreover controlling these properties using WPF Styles that package 3 D functionality in a reusable way is a particularly advantageous feature provided by the present Facade 3 D framework. For example the rotating 3 D rings used by the carousel may use a ListBox Style named OrbitListStyle that packages this functionality and which may be used by other FrameworkElements operating in the UI.

The markup below shows the 6 DOF Transformation Stack expressed in XAML with bindings to Facade 3 D attached properties underlined 

At runtime the Facade 3 D framework facilitates the generation of an application 3 D visual tree that is comprised of objects which are sourced from the application XAML in combination with objects sourced from a ModelVisual3D repository and the Facade 3 D framework itself. The application visual tree using XAML like expression is shown in the Appendix.

As noted above the 3 D visual tree follows the 2 D structure for the source FrameworkElements that define the 3 D facades. Accordingly the 3 D visual tree is assembled initially and constantly synchronized during application runtime to be responsive to changes in 2 D application visual tree.

As shown in when the Facade 3 D framework is initialized the static Facade 3 D attached dependency properties are declared and the framework further subscribes to property changed events for many of the declared attached dependency properties by the addition of WPF PropertyChangedCallbacks to the property metadata .

As shown in when a Viewport3D Facade 3 D attached dependency property is defined on a FrameworkElement the Facade 3 D framework subscribes to the Viewport3D object s WPF PreviewGotKeyboardFocus event and all mouse events from the Viewport3D . In addition the 2 D visual tree rooted at the defining FrameworkElement is translated off screen so that only the 3 D geometry is displayed and not the defining 2 D source elements.

As noted above a 3 D facade may be specified by defining a Facade3D.Visual3DTemplate to be a ModelVisual3D object that contains the template of the 3 D geometry. Accordingly as shown in when the Visual3DTemplate Facade 3 D attached dependency property is defined on a FrameworkElement the Facade 3 D framework clones the specified ModelVisual3D template for example from the general purpose repository as described above. The Facade3D.Visual3D is set to the cloned ModelVisual3D .

Similarly as shown in when a Facade3D.Material attached dependency property is defined on a FrameworkElement the Facade 3 D framework sets the Facade3D.Material to the specified reference on the element in the 3 D application visual tree .

As shown in when a Facade3D.Visual3D attached dependency property is defined on a FrameworkElement the Facade 3 D framework subscribes to the defining element s Loaded event and Unloaded event . This enables synchronization of the 2 D and 3 D application visual trees as shown below.

Continuing with the description of in further response to a Loaded event the Facade 3 D framework will also assign a clone of the 6 DOF Transformation Stack to the defining FrameworkElement s counterpart ModelVisual3D . Properties within the 6 DOF Transformation Stack are initialized with the corresponding Facade 3 D property values that are set in the application XAML . The Facade 3 D framework creates two way bindings between the defining FrameworkElement s Facade 3 D transformation properties e.g. Facade3D.Yaw and the corresponding properties of objects in the ModelVisual3D s transformation stack .

The Loaded and Unloaded events correspond respectively to nodes being added and removed from the application visual tree. Therefore when a source 2 D FrameworkElement is Loaded its ModelVisual3D facade is attached to the ModelVisual3D facade of its nearest ancestor that also has a 3 D facade defined by adding the ModelVisual3D facade to the Children list of that element.

Likewise as shown in when the source 2 D Framework Element is Unloaded the FrameworkElement s ModelVisual3D facade is removed from the application 3 D visual tree .

There are basic properties of FrameworkElements that make them dynamic interactive and controllable. The Facade 3 D framework utilizes and in some cases may transfer these properties onto the 3 D facades that these FrameworkElements define.

One such property is handling input as shown in . Facade 3 D accomplishes mouse interaction with the 3 D facades by intercepting and handling mouse events captured on their 3 D geometry and performing 3 D hit tests to determine which ModelVisual3D was hit.

Facade 3 D is able to perform these steps in code defined within event handlers that are attached to the Viewport3D containing the 3 D tree when these Facade 3 D properties are defined. After determining which ModelVisual3D was hit by the mouse Facade 3 D iterates up the 3 D tree in order to identify the ModelVisual3D that was defined as the corresponding Facade 3 D visual of some 2 D FrameworkElement counterpart . Finally Facade 3 D re raises the captured mouse event on this source 2 D FrameworkElement counterpart . These steps enable application users to interact with the 3 D geometry that comprise the 3 D facades using the mouse vicariously as though they are interacting with the 2 D source FrameworkElements themselves.

Another property that FrameworkElements may have is keyboard focus focus refers generally to the object in the UI which is currently receiving input from in this case the keyboard . The 2 D source FrameworkElements that have these Facade 3 D properties defined still exist in the application s visual tree so focus is handled just as with any FrameworkElement.

As a result there is an inherent notion of focus that these FrameworkElements can maintain. As indicated in Facade 3 D properties may respond to focus events just as any other dependency properties could . For example if an application developer desires the 3 D geometry can be scaled up rotated into place or moved closer to the screen using a WPF Trigger once the source FrameworkElement receives focus. WPF handles all the logic for transfer of focus itself since the 3 D geometry is associated with the FrameworkElement in the application visual tree.

The events and respective actions shown in and described in the accompanying text are summarized in the Event Action table and respectively shown in and

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

