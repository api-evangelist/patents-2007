---

title: Distributed computing system having autonomic deployment of virtual machine disk images
abstract: One or more control nodes provide for the efficient and automated allocation and management of computing functions and resources within the distributed computing system. The distributed computing system includes a software image repository storing: (i) one or more image instances of a virtual machine manager that is executable on the application nodes, wherein when executed on the applications nodes, the image instances of the virtual machine manager provide one or more virtual machines, and (ii) one or more image instances of one or more software applications that are executable on the virtual machines. The distributed computing system also includes a control node that comprises an automation infrastructure to provide autonomic deployment of the image instances of the virtual machine manager on the application nodes and to provide autonomic deployment of the image instances of the software applications on the virtual machines.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572138&OS=08572138&RS=08572138
owner: CA, Inc.
number: 08572138
owner_city: Islandia
owner_country: US
publication_date: 20070330
---
This application claims the benefit of U.S. provisional Application Ser. No. 60 787 280 filed Mar. 30 2006 the entire content of which is incorporated herein by reference.

The invention relates to computing environments and more specifically to distributed computing systems.

Distributed computing systems are increasingly being utilized to support business as well as technical applications. Typically distributed computing systems are constructed from a collection of computing nodes that combine to provide a set of processing services to implement the distributed computing applications. Each of the computing nodes in the distributed computing system is typically a separate independent computing device interconnected with each of the other computing nodes via a communications medium e.g. a network.

One challenge with distributed computing systems is the organization deployment and administration of such a system within an enterprise environment. For example it is often difficult to manage the allocation and deployment of enterprise computing functions within the distributed computing system. An enterprise for example often includes several business groups and each group may have competing and variable computing requirements.

In general the invention is directed to a distributed computing system that conforms to a multi level hierarchical organizational model. One or more control nodes provide for the efficient and automated allocation and management of computing functions and resources within the distributed computing system in accordance with the organization model.

As described herein the model includes four distinct levels fabric domains tiers and nodes that provide for the logical abstraction and containment of the physical components as well as system and service application software of the enterprise. A user such as a system administrator interacts with the control nodes to logically define the hierarchical organization of the distributed computing system. The control nodes are responsible for all levels of management in accordance with the model including fabric management domain creation tier creation and node allocation and deployment.

In one embodiment a distributed computing system comprises a plurality of application nodes interconnected via a communications network and a control node. The control node comprises a set of one or more applications to be executed on the application nodes an application matrix that includes parameters for controlling the deployment of the applications within the distributed computing system and an automation unit having one or more rule engines that provide autonomic control of the application nodes and the applications in accordance with a set of one or more rules and the application matrix.

In another embodiment a method comprises generating an application matrix that specifies data for controlling the deployment of a set of applications within a distributed computing system and performing operations to provide autonomic control over the deployment of the applications within the distributed computing system in accordance with parameters of the application matrix.

In another embodiment a computer readable medium comprises instructions. The instructions cause the processor to generate an application matrix that specifies data for controlling the deployment of a set of applications within a distributed computing system and perform operations to provide autonomic control over the deployment of the applications within the distributed computing system in accordance with parameters of the application matrix.

In another embodiment a distributed computing system comprises a plurality of application nodes interconnected via a communications network. In addition the distributed computing system includes a software image repository storing i one or more image instances of a virtual machine manager that is executable on the application nodes wherein when executed on the applications nodes the image instances of the virtual machine manager provide one or more virtual machines and ii one or more image instances of one or more software applications that are executable on the virtual machines. The distributed computing system also includes a control node that comprises an automation infrastructure to provide autonomic deployment of the image instances of the virtual machine manager on the application nodes and to provide autonomic deployment of the image instances of the software applications on the virtual machines.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

In the illustrated example the collection of computing nodes forming distributed computing system are logically grouped within a discovered pool a free pool an allocated tiers and a maintenance pool . In addition distributed computing system includes at least one control node .

Within distributed computing system a computing node refers to the physical computing device. The number of computing nodes needed within distributed computing system is dependent on the processing requirements. For example distributed computing system may include 8 to 512 computing nodes or more. Each computing node includes one or more programmable processors for executing software instructions stored on one or more computer readable media.

Discovered pool includes a set of discovered nodes that have been automatically discovered within distributed computing system by control node . For example control node may monitor dynamic host communication protocol DHCP leases to discover the connection of a node to network . Once detected control node automatically inventories the attributes for the discovered node and reassigns the discovered node to free pool . The node attributes identified during the inventory process may include a CPU count a CPU speed an amount of memory e.g. RAM local disk characteristics or other computing resources. Control node may also receive input identifying node attributes not detectable via the automatic inventory such as whether the node includes I O such as HBA. Further details with respect to the automated discovery and inventory processes are described in U.S. patent application Ser. No. 11 070 851 entitled AUTOMATED DISCOVERY AND INVENTORY OF NODES WITHIN AN AUTONOMIC DISTRIBUTED COMPUTING SYSTEM filed Mar. 2 2005 the entire content of which is hereby incorporated by reference.

Free pool includes a set of unallocated nodes that are available for use within distributed computing system . Control node may dynamically reallocate an unallocated node from free pool to allocated tiers as an application node . For example control node may use unallocated nodes from free pool to replace a failed application node or to add an application node to allocated tiers to increase processing capacity of distributed computing system .

In general allocated tiers include one or more tiers of application nodes that are currently providing a computing environment for execution of user software applications. In addition although not illustrated separately application nodes may include one or more input output I O nodes. Application nodes typically have more substantial I O capabilities than control node and are typically configured with more computing resources e.g. processors and memory . Maintenance pool includes a set of nodes that either could not be inventoried or that failed and have been taken out of service from allocated tiers .

Control node provides the system support functions for managing distributed computing system . More specifically control node manages the roles of each computing node within distributed computing system and the execution of software applications within the distributed computing system. In general distributed computing system includes at least one control node but may utilize additional control nodes to assist with the management functions.

Other control nodes not shown in are optional and may be associated with a different subset of the computing nodes within distributed computing system . Moreover control node may be replicated to provide primary and backup administration functions thereby allowing for graceful handling a failover in the event control node fails.

Network provides a communications interconnect for control node and application nodes as well as discovered nodes unallocated nodes and failed nodes. Communications network permits internode communications among the computing nodes as the nodes perform interrelated operations and functions. Communications network may comprise for example direct connections between one or more of the computing nodes one or more customer networks maintained by an enterprise local area networks LANs wide area networks WANs or a combination thereof. Communications network may include a number of switches routers firewalls load balancers and the like.

In one embodiment each of the computing nodes within distributed computing system executes a common general purpose operating system. One example of a general purpose operating system is the Windows operating system provided by Microsoft Corporation. In some embodiments the general purpose operating system such as the Linux kernel may be used.

In the example of control node is responsible for software image management. The term software image refers to a complete set of software loaded on an individual computing node to provide an execution environment for one or more applications. The software image including the operating system and all boot code middleware files and may include application files. As described below embodiments of the invention provide application level autonomic control over the deployment execution and monitoring of applications onto software images associated with application nodes .

System administrator may interact with control node and identify the particular types of software images to be associated with application nodes . Alternatively administration software executing on control node may automatically identify the appropriate software images to be deployed to application nodes based on the input received from system administrator . For example control node may determine the type of software image to load onto an application node based on the functions assigned to the node by system administrator . Application nodes may be divided into a number of groups based on their assigned functionality. As one example application nodes may be divided into a first group to provide web server functions a second group to provide business application functions and a third group to provide database functions. The application nodes of each group may be associated with different software images.

Control node provides for the efficient allocation and management of the various software images within distributed computing system . In some embodiments control node generates a golden image for each type of software image that may be deployed on one or more of application nodes . As described herein the term golden image refers to a reference copy of a complete software stack for providing an execution environment for applications.

System administrator may create a golden image by installing an operating system middleware and software applications on a computing node and then making a complete copy of the installed software. In this manner a golden image may be viewed as a master copy of the software image for a particular computing function. Control node maintains a software image repository that stores the golden images associated with distributed computing system .

Control node may create a copy of a golden image referred to as an image instance for each possible image instance that may be deployed within distributed computing system for a similar computing function. In other words control node pre generates a set of K image instances for a golden image where K represents the maximum number of image instances for which distributed computing system is configured for the particular type of computing function. For a given computing function control node may create the complete set of image instance even if not all of the image instances will be initially deployed. Control node creates different sets of image instances for different computing functions and each set may have a different number of image instances depending on the maximum number of image instances that may be deployed for each set. Control node stores the image instances within software image repository . Each image instance represents a collection of bits that may be deployed on an application node.

Further details of software image management are described in co pending U.S. patent application Ser. No. 11 046 133 entitled MANAGEMENT OF SOFTWARE IMAGES FOR COMPUTING NODES OF A DISTRIBUTED COMPUTING SYSTEM filed Jan. 28 2005 and co pending U.S. patent application Ser. No. 11 046 152 entitled UPDATING SOFTWARE IMAGES ASSOCIATED WITH A DISTRIBUTED COMPUTING SYSTEM filed Jan. 28 2005 each of which is incorporated herein by reference in its entirety.

In general distributed computing system conforms to a multi level hierarchical organizational model that includes four distinct levels fabric domains tiers and nodes. Control node is responsible for all levels of management including fabric management domain creation tier creation and node allocation and deployment.

As used herein the fabric level generally refers to the logical constructs that allow for definition deployment partitioning and management of distinct enterprise applications. In other words fabric refers to the integrated set of hardware system software and application software that can be knitted together to form a complete enterprise system. In general the fabric level consists of two elements fabric components or fabric payload. Control node provides fabric management and fabric services as described herein.

In contrast a domain is a logical abstraction for containment and management within the fabric. The domain provides a logical unit of fabric allocation that enables the fabric to be partitioned amongst multiple uses e.g. different business services.

Domains are comprised of tiers such as a 4 tier application model web server application server business logic persistence layer or a single tier monolithic application. Fabric domains contain the free pool of devices available for assignment to tiers.

A tier is a logically associated group of fabric components within a domain that share a set of attributes usage availability model or business service mission. Tiers are used to define structure within a domain e.g. N tier application and each tier represents a different computing function. A user such as administrator typically defines the tier structure within a domain. The hierarchical architecture may provide a high degree of flexibility in mapping customer applications to logical models which run within the fabric environment. The tier is one construct in this modeling process and is the logical container of application resources.

The lowest level the node level includes the physical components of the fabric. This includes computing nodes that as described above provide operating environments for system applications and enterprise software applications. In addition the node level may include network devices e.g. Ethernet switches load balancers and firewalls used in creating the infrastructure of network . The node level may further include network storage nodes that are network connected to the fabric.

System administrator accesses administration software executing on control node to logically define the hierarchical organization of distributed computing system . For example system administrator may provide organizational data to develop a model for the enterprise and logically define the enterprise fabric. System administrator may for instance develop a model for the enterprise that includes a number of domains tiers and node slots hierarchically arranged within a single enterprise fabric.

More specifically system administrator defines one or more domains that each correspond to a single enterprise application or service such as a customer relation management CRM service. System administrator further defines one or more tiers within each domain that represent the functional subcomponents of applications and services provided by the domain. As an example system administrator may define a storefront domain within the enterprise fabric that includes a web tier an application tier and a database tier. In this manner distributed computing system may be configured to automatically provide web server functions business application functions and database functions.

For each of the tiers control node creates a number of node slots equal to the maximum number of application nodes that may be deployed. In general each node slot represents a data set that describes specific information for a corresponding node such as software resources for a physical node that is assigned to the node slot. The node slots may for instance identify a particular software image instance associated with an application node as well as a network address associated with that particular image instance.

In this manner each of the tiers include one or more node slots that reference particular software image instances to boot on the application nodes to which each software image instance is assigned. The application nodes to which control node assigns the image instances temporarily inherit the network address assigned to the image instance for as long as the image instance is deployed on that particular application node. If for some reason the image instance is moved to a different application node control node A moves the network address to that new application node.

System administrator may further define specific node requirements for each tier of the fabric. For example the node requirements specified by system administrator may include a central processing unit CPU count a CPU speed an amount of memory e.g. RAM local disk characteristics and other hardware characteristics that may be detected on the individual computing nodes. System administrator may also specify user defined hardware attributes of the computing nodes such as whether I O like HBA is required. The user defined hardware attributes are typically not capable of detection during an automatic inventory. In this manner system administrator creates a list of attributes that the tier requires of its candidate computing nodes. In addition particular node requirements may be defined for software image instances.

In addition to the node requirements described above system administrator may further define policies that are used when re provisioning computing nodes within the fabric. System administrator may define policies regarding tier characteristics such as a minimum number of nodes a tier requires an indication of whether or not a failed node is dynamically replaced by a node from free pool a priority for each tier relative to other tiers an indication of whether or not a tier allows nodes to be re provisioned to other tiers to satisfy processing requirements by other tiers of a higher priority or other policies. Control node uses the policy information input by system administrator to re provision computing nodes to meet tier processing capacity demands.

After receiving input from system administrator defining the architecture and policy of the enterprise fabric control node identifies unallocated nodes within free pool that satisfy required node attributes. Control node automatically assigns unallocated nodes from free pool to respective tier node slots of a tier. As will be described in detail herein in one embodiment control node may assign computing nodes to the tiers in a best fit fashion. Particularly control node assigns computing nodes to the tier whose node attributes most closely match the node requirements of the tier as defined by administrator . The assignment of the computing nodes may occur on a tier by tier basis beginning with a tier with the highest priority and ending with a tier with the lowest priority. Alternatively or in addition assignment of computing nodes may be based on dependencies defined between tiers.

As will be described in detail below control node may automatically add unallocated nodes from free pool to a tier when more processing capacity is needed within the tier remove nodes from a tier to the free pool when the tier has excess capacity transfer nodes from tier to tier to meet processing demands or replace failed nodes with nodes from the free pool. Thus computing resources i.e. computing nodes may be automatically shared between tiers and domains within the fabric based on user defined policies to dynamically address high processing demands failures and other events.

Distributed computing system may provide one or more advantages. For example distributed computing system may deliver application services in a manner that is independent of the computational infrastructure which generates the application services. For example the computation infrastructure that provides an application service to a user of distributed computing system may be irrelevant to the user so long as distributed computing system provides the application service. Distributed computing system may deliver application services in a manner that is independent of the computational infrastructure by utilizing an infrastructure management facility IMF that may guarantee application service delivery using service level automation. 

This concept is itself based upon two concepts The Service Delivery Model and Service Level Automation.

1. Service Delivery Model The concept of computing as a service is based upon the ability of the consumer to be guaranteed availability of the quantity and quality of an application service required at the time and location necessary independent of the type of service provided e.g. audio video application programs etc . This may be achieved if the application services are provided in a manner that is independent of the location and condition of the physical and logical infrastructure which generates the application service limited only by total capability and capacity available. This disclosure may refer to this concept as the Service Delivery Model. 

Physical and logical infrastructure facilities that provide an application service may comprise a computing infrastructure. A computing infrastructure may include computing storage and communication hardware and related software infrastructure the application software and application containers and other enabling facilities and services that are part of the environment necessary to generate and deliver application services.

2. Service Level Automation In order to implement the service delivery model the IMF may provide service level automation. The IMF may implement the service delivery model for single and or multiple application service flows. For example the IMF may automatically and dynamically adjust application service levels of these application service flows based on a policy automation facility. The policy automation facility may automate delivery of application service based upon dynamically extensible policies. These dynamically extensible policies may include but are not limited to customer location priority duration date and time of day service type business demands and conditions quantity and quality of the application service. The policy automation facility may also enable independent control of the application service by a service provider and by a consumer. Furthermore the policy automation facility may allow the consumer provide the application service or a service based on the application service to another consumer. In addition the IMF may measure both efficiency and cost as reflected in the behavior of the product. For example the IMF may provide the ability to make decisions that account for the best uses of the resources on a dynamic basis in order to choose between functionally equivalent alternatives that make the best usage of the economics of the infrastructure at the time. This disclosure may refer to this concept as Service Level Automation SLA .

Service level automation may enable the separation of some or all aspects of the implementation of the computing infrastructure from the delivery of application services. Separating the implementation of the computing infrastructure from the delivery of application services may allow a consumer of the application services to decrease risk and cost while increasing business agility. Implementations of service level automation may be based upon a new abstraction which operates independent of existing software categories e.g. applications middleware data base operating systems and system management which for the purposes of this disclosure shall be referred to as Metaware. 

The IMF may comprise Metaware that regulates the delivery of application services through service level automation. The IMF may use service level automation to regulate the delivery of application services in a manner that is independent of the computing infrastructure that provides the application services. Because application services are the result of applications running within distributed computing system the IMF may automate application service levels and may make independent of all aspects of the computing infrastructure within the limits of the capability and capacity available for delivery to the consumer. Service level automation may provide extensible dynamic policy driven control of service delivery for both service providers and service consumers. The IMF may include the following six functional design capabilities 

1. Application Service Independence The basic concept which enables the IMF to deliver application services may be the ability of the IMF to dynamically manage service level automation in a manner that is independent of the computing infrastructure. A key element of this is that application services themselves are independent and unmodified. The IMF may be able to accomplish this by abstracting the physical and logical computing infrastructure away from the quantity and quality of application services generated by the computing infrastructure.

2. Scale Independence The incremental overhead of the IMF required by any server included in distributed computing system may be independent of the number of nodes in distributed computing system .

3. Container Capacity Metering Distributed computing system may achieve application service independence by dynamically metering higher level software facilities of the computing infrastructure. The higher level software facilities may generate the application services service flow and flux. This disclosure may refer to these facilities as container services. Examples of container services may include but are not limited to virtual machine managers operating systems and web application servers. Furthermore some container services may contain other container services that the IMF manages. The system may conceptualize the application service as being independent of the type of computing infrastructure e.g. middleware and hardware nodes that generate these services.

4. Policy Automation The IMF may deliver the required service level automation through its extensible policy management facility. The policy management facility may dynamically adjust application service levels in order to implement user defined policy. The ability to adjust application service levels may be limited only by the capacity and capability of the available computing infrastructure. The policy management facility may be capable of providing guaranteed service levels for single and or multiple application service flows which the IMF automatically and dynamically adjust based on user defined and extensible policies in response to changes in the environment. Examples of policies may include but are not limited to customer location service type cost and or pricing quantity and quality of service priority duration date and time of day business demands and conditions and other policies. The policy management facility may also allow the service provider to manage delivery and meter the capacity that the service provider delivers to individual customers. The policy management facility may allow the service provider to manage delivery and meter capacity independent of the ability of the customer to set and manage their own policies of how their capacity is utilized. This may be effectively done by leveraging application service independence.

5. Dynamic Provisioning The IMF described herein may support the ability to dynamically provision at boot and run time all software in order to support installation capacity management service levels and other policies and software upgrades. Offering a computing infrastructure architecture that is application service independent may create flexibility in deployment of a single instance of a service.

6. Data Capture Capability The IMF described herein may acquire the data necessary to enable the service provider to implement metering and auditing facilities necessary to control audit bill and account for services provided in complete detail. The customer may also use the ability to capture this data as a means to educate the IMF about the performance characteristics of combinations of resources in order to allow the IMF to improve the quality of its scheduling decisions over time. Improvement of the quality of scheduling decisions may enhance the ability of the IMF to provide the requisite services with high efficiency.

The described system may allow customers to conveniently acquire the guaranteed quantity and quality of application services required at competitive market driven rates with the ability to directly control the SLA capability of the IMF in order to maximize their operations efficiency and effectiveness without having to tradeoff operation risk cost and business agility. Potential advantages may include but are not limited to 

1. Efficiency and Effectiveness The customer may not need to manage the technology and can focus on the automation of the application service to improve their efficiency and effectiveness without having to tradeoff operation risk cost and business agility which the IMF may enable through the service level automation capability of the IMF.

2. Capabilities Convenience By leveraging the Internet as a generic global delivery facility and separating the computing infrastructure from the application service delivery the IMF may simplify the consumer s life in several ways 

3. Cost By logically abstracting the application services from the computing infrastructure the IMF may enable a competitive service provider industry that includes 

The IMF may enable the implementation of a service delivery model based on service level automation by service providers 

1. A service provider may use the IMF to implement a service delivery model for application services independent of the computing infrastructure or of the service types provided. This capability may enable the service provider to deliver service level automation on a global basis utilizing generic computing infrastructure for all types of digital services. Such digital service may include traditional applications and service flow processing digital audio and digital video services independently to any consumer type e.g. individual organization or corporation as long as the consumer has access to sufficient capacity of broadband communications for the services levels require and other types of digital services. This capability of the IMF may also allow a consumer of an application service to in turn be a service provider as well.

2. The IMF described herein may enable a service provider to meter application services that distributed computing system delivers. For example the service provider may meter application services based on the capacity of computing infrastructure consumed by customer. The service provider may meter application services in order to control audit bill and account for the application services provided to individual consumers of the application services. This capability may represent a uniform model of service level automation that is independent of the capacity of computing infrastructure for some or all types of application services. As a result a pricing model of a service provider may reflect the goal of utility computing by enabling the service provider to bill based upon a combination of application service delivery parameters. These application service delivery parameters may include but not limited to customer type of service duration date and or time of day location point of delivery quantity and quality of service and excess or reserved capacity and other application service delivery parameters.

3. The IMF may also enable the service provider to leverage the economics of the service delivery model in several ways 

In this example e commerce fabric includes a storefront domain A and a financial planning domain B. Storefront domain A corresponds to the enterprise storefront domain and allows customers to find and purchase products over a network such as the Internet. Financial planning domain B allows one or more employees to perform financial planning tasks for the enterprise.

Tier level C includes one or more tiers within each domain that represent the functional subcomponents of applications and services provided by the domain. For example storefront domain A includes a web server tier labeled web tier A a business application tier labeled app tier B and a database tier labeled DB tier C. Web server tier A business application tier B and database tier C interact with one another to present a customer with an online storefront application and services. For example the customer may interact with web server tier A via a web browser. When the customer searches for a product web server tier A may interacts with business application tier B which may in turn access a database tier C. Similarly financial planning domain B includes a financial planning tier D that provides subcomponents of applications and services of the financial planning domain B. Thus in this example a domain may include a single tier.

Tier level D includes one or more logical node slots A H node slots within each of the tiers. Each of node slots include node specific information such as software resources for an application node that is assigned to a respective one of the node slots . Node slots may for instance identify particular software image instances within image repository and map the identified software image instances to respective application nodes . As an example node slots A and B belonging to web server tier A may reference particular software image instances used to boot two application nodes to provide web server functions. Similarly the other node slots may reference software image instances to provide business application functions database functions or financial application functions depending upon the tier to which the node slots are logically associated.

Although in the example of there are two node slots corresponding to each tier the tiers may include any number of node slots depending on the processing capacity needed on the tier. Furthermore not all of node slots may be currently assigned to an application node . For example node slot B may be associated with an inactive software image instance and when needed may be assigned to an application node for deployment of the software image instance.

In this example organizational data associates free node pool with the highest level of the model i.e. e commerce fabric . As described above control node may automatically assign unallocated nodes from free node pool to at least a portion of tier node slots of tiers as needed using the best fit algorithm described above or another algorithm. Additionally control node may also add nodes from free pool to a tier when more processing capacity is needed within the tier remove nodes from a tier to free pool when a tier has excess capacity transfer nodes from tier to tier to meet processing demands and replace failed nodes with nodes from the free tier.

Although not illustrated the model for the enterprise fabric may include multiple free node pools. For example the model may associate free node pools with individual domains at the domain level or with individual tier levels. In this manner administrator may define policies for the model such that unallocated computing nodes of free node pools associated with domains or tiers may only be used within the domain or tier to which they are assigned. In this manner a portion of the computing nodes may be shared between domains of the entire fabric while other computing nodes may be restricted to particular domains or tiers.

During this process control node may receive input specifying node requirements of each of the tiers of the hierarchical model . As described above administrator may specify a list of attributes e.g. a central processing unit CPU count a CPU speed an amount of memory e.g. RAM or local disk characteristics that the tiers require of their candidate computing nodes. In addition control node may further receive user defined custom attributes such as requiring the node to have I O such as HBA connectivity. The node requirements or attributes defined by system administrator may each include a name used to identify the characteristic a data type e.g. integer long float or string and a weight to define the importance of the requirement.

Control node identifies the attributes for all candidate computing nodes within free pool or a lower priority tier . As described above control node may have already discovered the computing nodes and inventoried the candidate computing nodes to identify hardware characteristics of all candidate computing nodes. Additionally control node may receive input from system administrator identifying specialized capabilities of one or more computing nodes that are not detectable by the inventory process.

Control node dynamically assigns computing nodes to the node slots of each tier based on the node requirements specified for the tiers and the identified node attributes . Population of the node slots of the tier may be performed on a tier by tier basis beginning with the tier with the highest priority i.e. the tier with the highest weight assigned to it. As will be described in detail in one embodiment control node may populate the node slots of the tiers with the computing nodes that have attributes that most closely match the node requirements of the particular tiers. Thus the computing nodes may be assigned using a best fit algorithm.

Next control node retrieves the node requirements associated with the selected tier . Control node may for example maintain a database having entries for each node slot where the entries identify the node requirements for each of the tiers. Control node retrieves the node requirements for the selected tier from the database.

In addition control node accesses the database and retrieves the computing node attributes of one of the unallocated computing nodes of free pool . Control node compares the node requirements of the tier to the node attributes of the selected computing node .

Based on the comparison control node determines whether the node attributes of the computing node meets the minimum node requirements of the tier . If the node attributes of the selected computing node do not meet the minimum node requirements of the tier then the computing node is removed from the list of candidate nodes for this particular tier . Control node repeats the process by retrieving the node attributes of another of the computing nodes of the free pool and compares the node requirements of the tier to the node attributes of the computing node.

If the node attributes of the selected computing node meet the minimum node requirements of the tier YES of control node determines whether the node attributes are an exact match to the node requirements of the tier . If the node attributes of the selected computing node and the node requirements of the tier are a perfect match YES of the computing node is immediately assigned from the free pool to a node slot of the tier and the image instance for the slot is associated with the computing node for deployment .

Control node then determines whether the node count for the tier is met . Control node may for example determine whether the tier is assigned the minimum number of nodes necessary to provide adequate processing capabilities. In another example control node may determine whether the tier is assigned the ideal number of nodes defined by system administrator . When the node count for the tier is met control node selects the next tier to enable e.g. the tier with the next largest priority and repeats the process until all defined tiers are enabled i.e. populated with application nodes .

If the node attributes of the selected computing node and the node requirements of the tier are not a perfect match control node calculates and records a processing energy of the node . As used herein the term processing energy refers to a numerical representation of the difference between the node attributes of a selected node and the node requirements of the tier. A positive processing energy indicates the node attributes more than satisfy the node requirements of the tier. The magnitude of the processing energy represents the degree to which the node requirements exceed the tier requirements.

After computing and recording the processing energy of the nodes control node determines whether there are more candidate nodes in free pool . If there are additional candidate nodes control node repeats the process by retrieving the computing node attributes of another one of the computing nodes of the free pool of computing nodes and comparing the node requirements of the tier to the node attributes of the computing node .

When all of the candidate computing nodes in the free pool have been examined control node selects the candidate computing node having the minimum positive processing energy and assigns the selected computing node to a node slot of the tier . Control node determines whether the minimum node count for the tier is met . If the minimum node count for the tier has not been met control node assigns the computing node with the next lowest calculated processing energy to the tier . Control node repeats this process until the node count is met. At this point control node selects the next tier to enable e.g. the tier with the next largest priority .

In the event there are an insufficient number of computing nodes in free pool or an insufficient number of computing nodes that meet the tier requirements control node notifies system administrator . System administrator may add more nodes to free pool add more capable nodes to the free pool reduce the node requirements of the tier so more of the unallocated nodes meet the requirements or reduce the configured minimum node counts for the tiers.

Control node then determines whether there are any computing nodes in the free pool of nodes that meet the minimum node requirements of the tier . When there are one or more nodes that meet the minimum node requirements of the tier control node selects the node from the free pool based the node requirements of the tier as described above and assigns the node to the tier . As described in detail with respect to control node may determine whether there are any nodes that have node attributes that are an exact match to the node requirements of the tier. If an exact match is found the corresponding computing node is assigned to a node slot of the tier. If no exact match is found control node computes the processing energy for each node and assigns the computing node with the minimum processing energy to the tier. Control node remotely powers on the assigned node and remotely boots the node with the image instance associated with the node slot. Additionally the booted computing node inherits the network address associated with the node slot.

If there are no adequate computing nodes in the free pool i.e. no nodes at all or no nodes that match the minimal node requirements of the tier control node identifies the tiers with a lower priority than the tier needing more processing capacity .

Control node determines which of the nodes of the lower priority tiers meet the minimum requirements of the tier in need of processing capacity . Control node may for example compare the attributes of each of the nodes assigned to node slots of the lower priority tiers to the node requirements of the tier in need of processing capacity. Lower priority tiers that have the minimum number of computing nodes may be removed from possible tiers from which to harvest an application node. If however all the lower priority tiers have the minimum number of computing nodes defined for the respective tier the lowest priority tier is selected from which to harvest the one or more nodes.

Control node calculates the processing energy of each of the nodes of the lower priority tiers that meet the minimum requirements . The energies of the nodes are calculated using the differences between the node attributes and the node requirements of the tier needing additional capacity. Control node selects the computing node with the lowest processing energy that meets the minimum requirements and assigns the selected computing node to the tier in need of processing capacity .

When harvesting a node control node calculates the processing energy of all the nodes in the tier as described above with reference to . Control node identifies the node within the tier with the highest processing energy and returns the identified node to the free pool of nodes . As described above the node with the highest processing energy corresponds to the node whose node attributes are the most in excess of the node requirements of the tier.

Returning the node to the free pool may involve remotely powering off the computing node and updating the database to associate the harvested node with free pool . In addition control node updates the database to disassociate the returned node with the node slot to which it was assigned. At this point the node no longer uses the network address associated with the image instance mapped to the node slot. Control node may therefore assign a temporary network address to the node while the node is assigned to free pool .

When configuring a tier system administrator may elect to activate email alerts. For example system administrator may activate the email alerts feature in order to receive email alerts providing system administrator with critical and or non critical tier information such as a notification that a tier has been upgraded a node of the tier has failed or the like. Furthermore system administrator may input various policies such node failure rules. For example system administrator may identify whether control node should reboot a node in case of failure or whether the failed node should automatically be moved to maintenance pool . Similarly system administrator may identify whether nodes assigned to the tier may be harvested by other tiers.

User interface may also allow system administrator to input node requirements of a tier. In order to input node requirements of a tier system administrator may click on the Requirements tab causing user interface to present an input area to particular node requirements of the tier.

User interface also displays properties that control node has identified during the computing node inventory process. In this example user interface presents system administrator with the a CPU node count a CPU speed the amount of RAM the disk size and other characteristics that are identifiable during the automated node inventory. User interface additionally presents interface information to system administrator . Specifically user interface provides system administrator with a list of components and their associated IP and MAC addresses.

User interface also allows system administrator to define other custom requirements. For example system administrator may define one or more attributes and add those attributes to the list of node attributes presented to system administrator .

System administrator or another user may select an image by clicking on the box in front of the image identifier name and perform one or more actions on the image. Actions that system administrator may perform on an image include deleting the image updating the image and the like. System administrator may select one of the image actions via dropdown menu . In some embodiments user interface may further display other details about the images such as the node to which the images are assigned if the node status is active the network address associated with the images and the like.

For each node user interface presents a node ID a status of the node the tier to which the node belongs a hostname associated with the node a NIC IP address a rack location a slot location the number of CPU s of the node the amount of RAM on the node the number of disks on the node whether the node has I O HBA and the number of NICs of the node.

System administrator or other user may select a node by clicking on the box in front of the node identifier name and perform one or more actions on the node. Actions that system administrator may perform on the node include deleting the node updating the node attributes or other properties of the node and the like. System administrator may select one of the node actions via dropdown menu .

System administrator or other user may select an alert by clicking on the box in front of the logged alert and perform one or more actions on the logged alert. Actions that system administrator may perform include deleting the alert changing the status of the alert or the like. System administrator may specify the log actions via dropdown menu .

Monitoring subsystem provides real time monitoring of the distributed computing system . In particular monitoring subsystem dynamically collects status data from the hardware and software operating within distributed computing system and feeds the status data in the form of monitor inputs to SLAI . Monitoring inputs may be viewed as representing the actual state of the fabric defined for the organizational model implemented by distributed computing system . Monitoring subsystem may utilize well defined interfaces e.g. the Simple Network Management Protocol SNMP and the Java Management Extensions JMX to collect and export real time monitoring information to SLAI .

SLAI may be viewed as an automation subsystem that provides support for autonomic computing and acts as a central nervous system for the controlled fabric. In general SLAI receives monitoring inputs from monitoring subsystem analyzes the inputs and outputs appropriate action requests to BLT . In one embodiment SLAI is a cybernetic system that controls the defined fabric via feedback loops. More specifically administrator may interact with BLT to define an expected state for the fabric. BLT communicates expected state to SLAI . SLAI receives the monitoring inputs from monitoring subsystem and applies rules to determine the most effective way of reducing the differences between the expected and actual states for the fabric.

For example SLAI may apply a rule to determine that a node within a high priority tier has failed and that the node should be replaced by harvesting a node from a lower priority tier. In this example SLAI outputs an action request to invoke BLT to move a node from one tier to the other.

In general BLT implements high level business operations on fabrics domains and tiers. SLAI invokes BLT to bring the actual state of the fabric into accordance with the expected state. In particular BLT outputs fabric actions to perform the physical fabric changes. In addition BLT outputs an initial expected state to SLAI and initial monitoring information to SLAI and monitoring subsystem respectively. In addition BLT outputs notifications to SLAI and monitoring subsystem to indicate the state and monitoring changes to distributed computing system . As one example BLT may provide control operations that can be used to replace failed nodes. For example BLT may output an action request indicating that a node having address 10.10.10.10 has been removed from tier ABC and a node having address 10.10.10.11 has been added to tier XYZ. In response monitoring subsystem stops attempting to collect status data from node 10.10.10.10 and starts monitoring for status data from node 10.10.10.11. In addition SLAI updates an internal model to automatically associate monitoring inputs from node 10.10.10.11 with tier XYZ.

As described further below monitoring subsystem employs a modular architecture that allows new detection and monitoring collectors to be plugged in for existing and new protocols and for existing and new hardware and software. As illustrated in monitoring subsystem provides a plug in architecture that allows different information collectors to be installed. In general collectors are responsible for protocol specific collection of monitoring information. The plug in architecture allows for new protocols to be added by simply adhering to a collector plug in signature. In this example monitoring subsystem includes collectors A and B for collecting information from operating systems and applications executing on nodes within tier A and tier B respectively.

In one embodiment collectors are loaded at startup of control node and are configured with information retrieved from BLT . Monitoring engine receives collection requests from SLAI sorts and prioritizes the requests and invokes the appropriate one of collectors based on the protocol specified in the collection requests. The invoked collector is responsible for collecting the required status data and returning the status data to monitoring engine . If the collector is unable to collect the requested status data the collector returns an error code.

In one embodiment collectors are Java code compiled into a jar file and loaded with a class loader at run time. Each of collectors has an associated configuration file written in a data description language such as the extensible markup language XML . In addition a user may interact with BLT to add run time configuration to dynamically configure collectors for specific computing environments. Each of collectors expose an application programming interface API to monitoring engine for communication and data exchange.

A user such as a system administrator specifies the protocol or protocols to be used for monitoring a software image when the image is created. In addition the users may specify the protocols to be used for monitoring the nodes and each service executing on the nodes. Example protocols supported by the collectors include Secure Shell SSH Simple Network Management Protocol SNMP Internet Control Message Protocol ICMP ping Java Management Extensions JMX and the Hypertext Transfer Protocol HTTP .

Some protocols require special privileges e.g. root privileges to perform the required data collection. In this case the corresponding collectors communicate with a separate process that executes as the root. Moreover some protocols may require deployment and or configuration of data providers within the fabric. Software agents may for example be installed and configured on nodes and configured on other hardware. If needed custom in fabric components may be deployed.

In this example the modular architecture of monitoring subsystem also supports one or more plug in interfaces for data collection from a wide range of third party monitoring systems . Third party monitoring systems monitor portions of the fabric and may be vendor specific.

In general sensor subsystem receives actual state data from monitoring subsystem in the form of monitoring inputs and supplies ongoing dynamic input data to analysis subsystem . For example sensor subsystem is notified of physical changes to distributed computing system by monitoring subsystem . Sensor subsystem uses the state data received from monitoring subsystem to maintain ongoing calculated values that can be sent to analysis subsystem in accordance with scheduler .

In one embodiment sensor subsystem performs time based hierarchical data aggregation of the actual state data in accordance with the defined organization model. Sensor subsystem maintains organizational data in a tree like structure that reflects the current configuration of the hierarchical organization model. Sensor subsystem uses the organizational data to perform the real time data aggregation and map tiers and domains to specific nodes. Sensor subsystem maintains the organizational data based on notifications received from BLT .

Sensor subsystem sends inputs to analysis subsystem to communicate the aggregated data on a periodic or event driven basis. Analysis subsystem may register an interest in a particular aggregated data value with sensor subsystem and request updates at a specified frequency. In response sensor subsystem interacts with monitoring subsystem and scheduler to generate the aggregated data required by analysis subsystem .

Sensor subsystem performs arbitrary data aggregations via instances of plug in classes referred to as triggers that define the aggregations. Each trigger is registered under a compound name based on the entity being monitored and the type of data being gathered. For example a trigger may be defined to aggregate and compute an average computing load for a tier every five minutes. Analysis subsystem requests the aggregated data based on the registered names. In some embodiments analysis subsystem may define calculations directly and pass them to sensor subsystem dynamically.

Analysis subsystem is composed of a plurality of forward chaining rule engines A N. In general rule engines match patterns in a combination of configuration data and monitoring data which is presented by extraction agent in the form of events. Events contain the aggregated data values that are sent to rule engines in accordance with scheduler .

Sensor subsystem may interact with analysis subsystem via trigger listeners that receives updates from a trigger within sensor subsystem when specified events occur. An event may be based on system state e.g. a node transitioning to an up or down state or may be time based.

Analysis subsystem allows rule sets to be loaded in source form and compiled at load time into discrimination networks. Each rule set specifies trigger delivered attributes. Upon loading the rule sets analysis subsystem establishes trigger listeners to receive sensor notifications and update respective working memories of rule engines . As illustrated in each of rule engines may serve a different tier defined within the fabric. Alternatively multiple rule engines may serve a single tier or a single rule engine may serve multiple tiers.

Rule engines process the events and invoke action requests via calls to effector subsystem . In addition rule engines provide a call back interface so that effector subsystem can inform a rule engine when an action has completed. Rule engines prevent a particular rule from re firing as long as any action invoked by the rule has not finished. In general rules contain notification calls and service invocations though either may be disabled by configuration of effector subsystem . BLT supplies initial system configuration descriptions to seed each of rule engines .

In general rule engines analyze the events and discover discrepancies between an expected state of the fabric and an actual state. Each of rule engines may be viewed as software that performs logical reasoning using knowledge encoded in high level condition action rules. Each of rule engines applies automated reasoning that works forward from preconditions to goals defined by system administrator . For example rule engines may apply modus ponens inferences rules.

Rule engines output requests to effector subsystem which produce actions requests for BLT to resolve the discrepancies. Effector subsystem performs all operations on behalf of analysis subsystem . For example event generator task invocation module and logger of effector subsystem perform event generation BLT action invocation and rule logging respectively. More specifically task invocation module invokes asynchronous operations within BLT . In response BLT creates a new thread of control for each task which is tracked by a unique task identifier task id . Rules engine uses the task id to determine when a task completes and if needed to re fire any rules that were pended until completion of the task. These tasks may take arbitrary amounts of time and rules engine tracks the progress of individual task via change notifications produced by BLT .

Event generator creates persistent event records of the state of processing of SLAI and stores the event records within a database. Clients uses these event records to track progress and determine the current state of the SLAI .

Logger generates detailed trace information about system activities for use in rule development and debugging. The logging level can be raised or lowered as needed without changing operation of SLAI .

In addition working memory includes a second data region that is modifiable i.e. read write and may be updated by monitoring subsystem or used internally by rule engines . In general data region stores aggregated data representing the actual state of the fabric and can be updated by sensor subsystem or by rule engines . The actual state may consist of a set of property annotations that can be attached to objects received from BLT or to objects locally defined within a rule engine such as local object .

As described BLT provides the facilities necessary to create and administer the organizational model e.g. fabric domains tiers and nodes implemented by distributed computing system . In general BLT abstracts access to the persisted configuration state of the fabric and controls the interactions with interfaces to fabric hardware services. As such BLT provides fabric management capabilities such as the ability to create a tier and replace a failed node. WSDL interfaces provide web service interfaces to the functionality of BLT that may be invoked by web service clients . Many of WSDL interfaces offered by BLT allow administrator to define goals such as specifying a goal of the expected state of the fabric. As further described below rule engines within SLAI in turn invoke task manger to initiate one or more BLT tasks to achieve the specified goal. In general web service clients may be presentation layer applications command line applications or other clients.

BLT abstracts all interaction with physical hardware for web service clients . BLT is an enabling component for autonomic management behavior but does not respond to real time events that either prevent a goal from being achieved or produce a set of deviations between the expected state and the actual state of the system. In contrast BLT originates goals for autonomic reactions to changing configuration and state. SLAI analyzes and acts upon these goals along with real time state changes. BLT sets the goals to which SLAI strives to achieve and provides functionality used by the SLAI in order to achieve the goals.

In general BLT does not dictate the steps taken in pursuit of a goal since these are likely to change based on the current state of distributed computing system and changes to configurable policy. SLAI makes these decisions based on the configured rule sets for the fabric and by evaluating monitoring data received from monitoring subsystem .

Fabric administration service implements a set of methods for managing all aspects of the fabric. Example methods include methods for adding viewing updating and removing domains tiers nodes notifications assets applications software images connectors and monitors. Other example methods include controlling power at a node and cloning capturing importing exporting or upgrading software images. Rule engines of SLAI may for example invoke these methods by issuing action requests .

Task manager receives action requests via task interface . In general task interface provides an interface for receiving action requests from SLAI or other internal subsystem. In response task manager manages asynchronous and long running actions that are invoked by SLAI to satisfy a goal or perform an action requested by a client.

Task manager generates task data that represents identification and status for each task. Task manager returns a task identifier to the calling web service clients or the internal subsystem e.g. SLAI that initiated the task. Rule engines and web service clients use the task identifiers to track progress and retrieve output results and errors associated with achieving the goal.

In one embodiment there are no WSDL interfaces for initiating specific tasks. Rather administrator interacts with BLT though goal interfaces presented by WSDL interfaces to define the goals for the fabric. In contrast the term task is used to refer to internal system constructs that require no user interaction. Tasks are distinct low level units of work that affect the state of the fabric. SLAI may combine tasks to achieve or maintain a goal state.

For example administrator can request configuration changes by either adding new goals to an object or by modifying the attributes on existing goals. Scheduled goals apply a configuration at a designated time. For example the goals for a particular tier may specify the minimum maximum and target node counts for that tier. As a result the tier can increase or decrease current node capacity by scheduling goals with different configuration values.

This may be useful for example in scheduling a software image upgrade. As another example entire domains may transition online and offline per a defined grid schedule. Administrator may mix and match goals on a component to achieve configurations specific to the application and environment. For example a tier that does not support autonomic node replacement would not be configured with a harvesting goal.

In some embodiments goals are either in force or out of force. SLAI only works to achieve and maintain those goals that are currently in force. SLAI may applies a concept of gravity as the goals transition from in force to out of force. For example SLAI may transition a tier offline when an online goal is marked out of force. Some goal types may have prerequisite goals. For example an image upgrade goal may require as a prerequisite that a tier be transitioned to offline before the image upgrade can be performed. In other embodiments goals are always in force until modified.

SLAI may automatically formulate dependencies between goals or may allow a user to specify the dependencies. For example a user may request that a newly created tier come online. As a result of this goal SLAI may automatically direct task manager to generate a task of harvesting a target number of nodes to enable the tier. Generally all goals remain in force by SLAI until modified by BLT . In one embodiment each goal remains in force in one of three states Satisfied Warning or Critical depending on how successful SLAI was in achieving the goal at the time the event record was generated and stored.

In this manner SLAI controls the life cycle of a goal i.e. the creation scheduling update deletion of the goal and provides a common implementation of these and other services such as timeout event writing goal conflicts management of intra goal dependencies and tracking tasks to achieving the goals.

Progress toward a goal is tracked though event subsystem . In particular event subsystem tracks the progress of each in force goal based on the goal identifiers. Tasks executed to achieve a particular goal produce events to communicate result or errors. The events provide a convenient time based view of all actions and behaviors.

Examples of goal types that may be defined by administrator include software image management goals node allocation goals harvest goals tier capacity goals asset requirement goals tier online offline goals and data gathering goals.

In one embodiment BLT presents a task interface to SLAI for the creation and management of specific tasks in order to achieve the currently in force goals. In particular rule engines invoke the task interface based on evaluation of the defined rule sets in view of the expected state and actual state for the fabric. Example task interfaces include interfaces to reserve node resources query resources for a node slot associate or disassociate an image with a node in a tier node slot allocate de allocate startup or shutdown a node move a node to a tier apply remove or cycle power of a node create a golden image create or delete an image instance and delete an activity node or tier.

Report generator provides an extensible mechanism for generating reports . Typical reports include image utilization reports that contain information with respect to the number of nodes running each software image inventory reports detailing both the logical and physical aspects of the fabric and system event reports showing all events that have occurred within the fabric. Report generator gathers localizes formats and displays data into report form for presentation to the user. Report generator may include one or more data gathering modules not shown that gather events in accordance with a schedule and update an events table to record the events. The data gathering modules may write the events in XML format.

Rule compiler compiles each of rules and translates match conditions of the rules into a discrimination network that avoids redundant tests during rule execution. Execution engine handles rule administration object insertion and retrieval rule invocation and execution of rule actions. In general execution engine first matches a current set of rules against a current state of working memory and local objects . Execution engine then collects all rules that match as well as the matched objects and selects a particular rule instantiation to fire. Next execution engine fires executes the instantiated rule and propagates any changes to working memory . Execution engine repeats the process until no more matching rule instantiations can be found.

Firing of a rule typically produces a very small number of changes to working memory . This allows sophisticated rule engines to scale by retaining match state between cycles. Only the rules and rule instantiations affected by changes are updated thereby avoiding the bulk of the matching process. One exemplary algorithm that may be used by execution engine to handle the matching process includes the RETE algorithm that creates a decision tree that combines the patterns in all the rules and is intended to improve the speed of forward chained rule system by limiting the effort required to re compute a conflict set after a rule is fired. One example of a RETE algorithm is described in Forgy C. L. 1982 RETE a fast algorithm for the many pattern many object pattern match problem Artificial Intelligence 19 1737 hereby incorporated by reference. Other alternatives include the TREAT algorithms and LEAPS algorithm as described by Miranker D. P. TREAT A New and Efficient Match Algorithm for AI Production Systems . ISBN 0934613710 Daniel P. Miranker David A. Brant Bernie Lofaso David Gadbois On the Performance of Lazy Matching in Production Systems. AAAI 1990 685692 each of which is hereby incorporated by reference.

Application matrix contains all the information needed by control unit to interact with one or more applications or application servers and provide autonomic control over a set of applications. Specifically application matrix provides a logical definition for deploying and controlling the set of applications to one or more tiers within distributed computing system . In one embodiment application matrix is an electronic document that conforms to a data description language e.g. the extensible markup language XML . Application SLAI includes an application rules engine dedicated to processing application level rules i.e. forward chaining rules to provide autonomic control over the applications defined within application matrix . Like rules engine application rules engine contains a rule compiler an execution engine and a working memory. In order to give effect to changes in application matrix application SLAI automatically updates application rules engine and monitoring subsystem . In particular application matrix sends an alert whenever application matrix changes. In response to this alert application SLAI captures application specific attributes from application matrix . Specifically application SLAI captures configuration attributes and rule attributes contained in application matrix . Application SLAI transfers any new rule attributes to the working memory of application rules engine to provide autonomic control over the deployment monitoring and the execution of the applications defined within application matrix . In addition application SLAI updates monitoring subsystem to collect information required to control the applications In this manner administrator may continue to add new application definitions and configurations to application matrix after distributed control node has started.

As described in further detail below configuration processor is a software module that generates an application matrix entry based on an application definition and application configuration properties of a staged application. A staged application is an application that has been deployed in a staging environment and customized for subsequent deployment within distributed computing system . After creating the application matrix entry administrator may insert the application matrix entry into application matrix .

Configuration processor is pluggable. That is administrator can plug in different implementations of configuration processor as needed. For example administrator may need to plug in a different implementation of configuration processor to handle applications that do not use an application server.

Application governor is a software engine that performs application level actions based on requests received from application rules engine . In this manner BLT effects fabric level actions e.g. deployment and monitoring of nodes and images based on request from fabric level rules engines while matrix governor performs application level actions e.g. deployment and monitoring of applications based on requests from application rules engine .

Application governor uses application matrix as a source of parameters when carrying out the application level operations requested by application rules engine . For example application rules engine may detect that a node to which the application is not deployed is ready for use by the application. As a result application rules engine directs application governor to handle the details of deploying the application to the node. In turn application governor accesses application matrix to retrieve application specific parameters necessary to deploy the application. Storing application specific parameters in application matrix allows the application specific parameters to change without having to recompile the rules within working memory of application rules engine .

Application governor performs a similar procedure to undeploy an application. That is application rules engine may detect that a second application needs to use a node more than a first application that is currently deployed to the node. In this situation application rules engine sends an instruction to application governor to undeploy the first application and deploy the second application. To carry out this instruction application governor accesses application matrix to discover configuration parameters of both applications. Application governor then uses the discovered configuration parameters to communicate with the applications.

Like configuration processor application governor is also pluggable. That is administrator can easily install or remove implementations of application governor depending on the circumstances. Because application governor and configuration processor represent interchangeable plug in modules the other parts of control unit and system including application rules engine can remain generic and application neutral while providing autonomic control over distributed computing system .

In this example application matrix contains seven columns and two rows. Each row represents a different application entry for deployment within distributed computing system . In only the first entry is shown in detail.

Each of the columns represents a different category of elements that make up an application s logical definition. In this example the columns include 

 1 an application column that includes elements generally related to the deployment of the application 

 2 an application nodes column that contains elements related to the tier node slots to which the application may be assigned 

 3 a services column that contains elements related to the executable services launched when the application is deployed 

 4 a node monitor values column that contains elements related to attributes of the nodes that are to be monitored after the application is deployed to that node 

 5 a service monitored attributes column that contains elements related to attributes of the services that are to be monitored after the application is deployed 

 6 a service levels column that contains elements related to attributes for use when constructing rules to monitor execution of the services and

 7 a deployment constraints column that contains elements related to attributes for use when constructing rules to control deployment of the application.

Different types of applications may have different elements in each column and different numbers of columns.

In the example of application matrix contains two applications DataDomain and PortalDomain . DataDomain application has eleven attributes that define how control node accesses and launches the application. For instance the adminIP and adminPort attributes instruct governor as to which the server and port hosts the administrative part of the logically defined application. Other attributes like maxNodes and minNodes instruct application rules engine to run the application no less than minNodes and no more than maxNodes. Applications other than application may have different numbers or types of attributes. In XML format the attributes of application may appear as follows 

In addition to these attributes application contains a series of elements columns . In general application nodes contain a list of all of the available tier node slots to which control node may deploy application . In this example two tier node slots are specified. In XML managed servers appears as 

Each services element identifies a service that control node launches when deploying application on a given application node. A service element comprises a service name and a path to a file containing the executable service. Governor uses the path to locate and launch the service. For example the following XML code indicates that governor must access the file at lib worklistApp worklistApp.ear .

Node Monitored Values elements represent characteristics for use in constructing rules for monitoring nodes to which the applications are deployed. Similarly Service Monitored Values elements represent characteristics for use in constructing rules for monitoring services that are launched once the application is deployed. In this example a nodeMonitoredValues element defines characteristics of a particular node that are to be monitored. For instance the amount of free memory in a node is one example of a characteristic listed as a nodeMonitoredValues element. On the other hand a serviceMonitoredValues element is specific attribute of a service that is to be monitored. For example the number of pending operating system level requests for the service the number of idle threads etc. could be service monitored values. In a XML rendition of application matrix node monitored values and service monitored values could appear as follows 

Deployment constraint elements specify characteristics of a node under which application rules engine should or should not deploy a service to the node. In this example a deployment constraint element has five attributes attribute expression frequency maxThreshold minThreshold and period. The attribute attribute names the deployment constraint. The expression attribute specifies an arithmetic expression manipulating a monitored value. For example the expression could be PercentMemoryFree 100 meaning monitor the value of the PercentMemoryFree node monitored value multiplied by 100. The expression attribute may specify one or more node monitored values. The frequency attribute informs application rules engine how frequently to check the monitored value. The maxThreshold attribute tells application rules engine to invoke a rule when the value of the expression exceeds the value specified by the maxThreshold attribute. Similarly the minThreshold attribute tells application rules engine to invoke the rule when the value of the expression drops below the value specified by the minThreshold attribute. Finally the period attribute informs application rules engine of the period over which to collect monitored value. For example a deployment constraint element may specify that application rules engine should monitor the PercentMemoryFree attribute of a node every 15 seconds for 60 seconds. If the value of PercentMemoryFree 100 should drop below 1.0 i.e. 1 of memory free for 60 seconds then application rules engine should not deploy the application to that node. In XML this rule would be represented as 

Service level elements have the same five attributes as deployment constraints elements attribute expression frequency maxThreshold minThreshold and period . However the expression attribute deals with service monitored attributes rather than node monitored attributes. For example a service level element may specify that application rules engine check the pendingRequest service monitored attribute every 15 seconds for 30 seconds. Then if there are more than 20 pending requests for more than 30 seconds application rules engine should take the action of starting a new application. On the other hand if there are fewer than 5 pending requests for 30 seconds application rules engine enables the action to remove the application to free up space on a node. Such a service level element could be represented as 

Put together an XML representation of an application matrix logically defining a single application for deployment within autonomically controlled distributed computing system may appear as follows 

During this process administrator directs the application to generate an application definition file that represents an application specific configuration based on the environment specified by the administrator. The application definition file contains information specific to an installation instance of the application. For example the application definition file typically specifies the locations paths for all software components of the application as staged within the staging environment a list of files to execute connectivity information for the application and other information that may be recorded by the configured application.

After staging the application administrator defines a set of application configuration properties that specify desired behavior of the application within distributed computing system . Examples of such application configuration properties include a minimum number of nodes minimum resource requirements for a node deployment timing information network addresses of tier node slots that are able to execute the application and other properties.

Next administrator directs configuration processor to generate an application entry for the application using the application definition and the application configuration properties . The application entry contains configuration attributes used by application governor to interact with the application. In addition the application entry contains rule attributes used by application rules engine that define how control node monitors the deployment and execution of the application within distributed computing environment .

After configuration processor creates the application entry administrator may modify the application entry . In particular administrator may update start scripts or shell scripts for the application due to path changes between the staging environment and distributed computing system .

Once administrator has finished modifying the application entry administrator inserts the application entry into application matrix . Because application matrix detects that it has changed application matrix sends an alert to application SLAI .

In response to the alert application SLAI may update application rules engine and monitoring subsystem . In particular application SLAI automatically scans application matrix . If application SLAI detects new rule attributes application SLAI creates local objects reflecting the new rule attributes in the working memory of application rules engine . In addition if application SLAI detects new monitored values application SLAI updates monitoring subsystem to add new monitoring collectors .

After application SLAI updates application rules engine and monitoring subsystem control node has autonomic control over the deployment of applications to tiers based on the configuration of application matrix . For example control node deploys images deploys applications monitors the state of nodes and the execution of the applications and applies tier level rules as well as application specific rules. Application SLAI continues to listen for alerts from application matrix .

As illustrated in a virtual machine manager is executing on node . As used herein a virtual machine manager is a software program that is capable of managing one or more virtual machines. For example virtual machine manager may be an instance of VMWare ESX software produced by VMWare Inc. of Palo Alto Calif.

When deployed on physical node virtual machine manager hosts virtual machines A through N collectively virtual machines . The term virtual machine is used herein to refer to software that creates an environment that emulates a computer platform. For example virtual machines provide environments on which guest operating systems OS execute as through the operating systems were operating directly on a physical computing platform. In this manner multiple operating systems and software applications A through N collectively operating systems and applications may execute on virtual machines A through N respectively and the virtual machines may execute on a single physical node or multiple physical nodes. For example if virtual machine A emulates an x86 machine an instance of the Microsoft Windows operating system e.g. OS A may execute on virtual machine A as through the instance of Windows were running on a physical x86 machine. Other software applications may be installed and configured on the guest operating system running on virtual machine . For example an instance of Microsoft Internet Information Server may execute on an instance of Microsoft Windows that is executing on a virtual machine that emulates an x86 machine. In this manner virtual machine manager and virtual machines provide a level of independence from the particular hardware environment provided by physical node .

Virtual machine manager utilizes operating system data and application data for execution of each of virtual machines . The operating system data and application data as well as instance specific configuration data for the underlying virtual machines is stored as respective virtual disk image files . From the perspective of the guest operating system each of virtual disk image files appears as a bootable hard disk of the host computer. In other words the virtual disk image file provides a bootable software image of the operating system and applications and includes all necessary configuration data and file structures. As illustrated in virtual machine disk image file A provides a bootable software image for operating system application information A that is capable of being executed on virtual machine A. For instance if virtual machine manager is an instance of VMWare ESX virtual machine disk image files may be specially captured .vmdk files.

A two phase capture process may be used to provide autonomic control and deployment of the virtual machine disk image files as well as virtual machine manager to physical nodes within distributed computing system . In particular control node may first capture an image of virtual machine manager installed on physical node prior to installation and configuration of any guest operating system and applications . Control node may utilize this captured image of virtual machine manager as a golden image from which instance images can be created for this type virtual machine. The instance images may be stored within application matrix for autonomic deployment as other software images .

After the first capture is complete an administrator may install one or more virtual machines to virtual machine manager . After the user installs and configures guest operating systems and any necessary applications on the virtual machines control node may capture software images for storage as virtual disk image files . Specifically control node may utilize the captured images as a golden images for the particular operating systems applications and specific configuration of the virtual machine. The golden image may then be used to produce image instances i.e. virtual disk images in this case that are bootable on the virtual machines. The image instances may likewise be stored in application matrix for autonomic deployment.

After generation of image instances for virtual machine manager and virtual disk image files control node may deploy the image instance of virtual machine manager to one or more nodes in free pool . Once control node deploys the image instance of virtual machine manager to a node the node appears to be one or more new unallocated nodes. For instance if the image instance of virtual machine manager is configured to support five virtual machines control node represents the newly deployed image instance as though five new unallocated nodes have been added to free pool . Subsequently control node may deploy an image instance of virtual disk image files to one of the new unallocated nodes.

In one embodiment during deployment administrator may specify whether data in virtual disk image files is to be treated as persistent or non persistent. If administrator specifies that the virtual disk image files are persistent changes made to a virtual disk image file persist when node is restarted. To ensure the persistence of the data administrator may configure virtual machine manager to store virtual disk image files in a storage area network SAN . Otherwise if administrator specifies that virtual disk image files are non persistent the original virtual disk image file is reloaded from control node . Non persistence may be valuable to minimize risks e.g. potential corruption due to viruses associated with prolonged use of an operating system. Further corrupt or invalid data in the virtual disk image file may be corrected by use of non persistent image instances for the virtual disk image files.

In this way distributed computing system may autonomically utilize application nodes e.g node to flexibly support a wide variety of operating systems and applications and provide virtualized execution environment for those operating systems and applications. For instance node may autonomically configured to support a Macintosh Operating System designed for a PowerPC processor and a Microsoft Windows Operating System designed for an x86 processor based on the particular goals of the autonomic system. Thus control node may not need to distinguish between hardware processor architectures when deploying operating systems and applications. However this system may also allow administrator to specify that control node operate an image instance directly on a node without the intervening virtual machine and virtual machine manager. Furthermore by executing multiple operating systems on a single node distributed computing system may be able to use and deploy the resources of each node more efficiently.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

