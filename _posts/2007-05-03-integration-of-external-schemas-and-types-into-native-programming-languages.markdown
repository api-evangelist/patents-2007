---

title: Integration of external schemas and types into native programming languages
abstract: A system includes a processor, a storage medium, an extensible markup language (XML) schema stored on the storage medium, and a script for manipulating an XML document stored on the storage medium. The script includes an import function to import the XML schema such that the definitions of the XML schema are used to interpret the script.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958492&OS=07958492&RS=07958492
owner: Oracle International Corporation
number: 07958492
owner_city: Redwood Shores
owner_country: US
publication_date: 20070503
---
This application claims priority from the following co pending application which is hereby incorporated in their entirety 

U.S. Provisional Application No. 60 797 510 entitled INTEGRATION OF EXTERNAL SCHEMA AND TYPES INTO NATIVE PROGRAMMING LANGUAGES filed by John C. Schneider filed May 4 2006.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

XML is rapidly emerging as the de facto standard for transmitting data structures between software applications and web services. While most software applications and web services are written in modern programming languages such as Java or C none of these programming languages provide native support for representing and manipulating XML. Consequently programmers are forced to develop or adopt external software packages for representing and manipulating XML within the context of their applications and web services.

In general external software packages are not capable of providing the host language with native support for processing XML data. As such they represent and manipulate XML in ways that are quite different than those provided by the host language for its native data types. Most often external software packages represent XML data using a general purpose tree abstraction and provide a tree based application programming interface API for navigating and manipulating the data e.g. getParentNode getChildNodes removeChild etc. . Additionally there are different processing models such as DOM XSLT XQuery etc that can introduce a steep learning curve for the developer community as these models require specialized knowledge and cumbersome concepts of trees nodes recursive decent etc. This method of accessing and manipulating data structures is cumbersome and time consuming compared to methods used for accessing and manipulating data structures native to the host programming language.

Therefore a programming language that enables the integration and manipulation thereafter of external schema and types of data representation language such as XML with the same power and flexibility afforded by native data structures is desirable. This is particularly useful for untyped native programming or scripting languages. This enables programmers and web developers to use the power of XML structured data allowing them to leverage their existing skills and reuse familiar programming concepts operators and syntax . By allowing the facility to manipulate and use external schema and types in the native language reduces code complexity time to market cost of development and testing and decreases code footprint requirements.

In the following description various aspects of the present invention will be described. However it will be apparent to those skilled in the art that the present invention may be practiced with only some or all aspects of the present invention. For purposes of explanation specific numbers materials and configurations are set forth in order to provide a thorough understanding of the present invention. However it will also be apparent to one skilled in the art that the present invention may be practiced without the specific details. In other instances well known features are omitted or simplified in order not to obscure the present invention.

Concepts and terminology commonly used by those familiar with compiler and parser design are used herein. Those who are unfamiliar with the inner workings of compilers and parsers are referred to Compilers Principals Techniques and Tools by A. Aho R. Sethi and J. Ullman published by Addison Wesley Publishing Company in November 1985 ISBN 0201100886 . In addition basic familiarity by the reader with XML concepts and terminology including XML XML Schema the Document Object Model DOM the XML Query Language and XPath is assumed. Those unfamiliar with these technologies are referred to the following World Wide Web Consortium W3C publications Extensible Markup Language XML 1.0 Second Edition W3C Recommendation REC XML 20001006 6 Oct. 2000 Document Object Model DOM Level 1 Specification W3C Recommendation REC DOM Level 1 19981001 1 Oct. 1998 XQuery 1.0 An XML Query Language W3C Working Draft WD XQUERY 20021220 20 Dec. 2001 XML Path Language XPath W3C Recommendation REC XPATH 19991116 16 Nov. 1999 XML Schema Part 0 Primer W3C Recommendation REC XMLSCHEMA 0 20010502 2 May 2001 XML Schema Part 1 Structures W3C Recommendation REC XMLSCHEMA 1 20010502 2 May 2001 and XML Schema Part 2 Datatypes W3C Recommendation REC XMLSCHEMA 2 20010502 2 May 2001.

Parts of the description will be presented in terms of operations performed by a processor based device using terms such as receiving analyzing determining generating and the like consistent with the manner commonly employed by those skilled in the art to convey the substance of their work to others skilled in the art. As well understood by those skilled in the art the quantities take the form of electrical magnetic or optical signals capable of being stored transferred combined and otherwise manipulated through mechanical and electrical components of the processor based device and the term processor include microprocessors micro controllers digital signal processors and the like that are standalone adjunct or embedded.

Various operations will be described as multiple discrete steps in turn in a manner that is most helpful in understanding the present invention however the order of description should not be construed as to imply that these operations are necessarily order dependent. In particular these operations need not be performed in the order of presentation. Further the description repeatedly uses the phrase in one embodiment which ordinarily does not refer to the same embodiment although it may.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to an or one embodiment in this disclosure are not necessarily to the same embodiment and such references mean at least one.

A type definition of the XML schema can be used to interpret the script. At least one of the type definitions can be a complex type definition. Functions in the script can interpret data according to the type definition in the XML schema . The script can include a validate method to check if an XML schema data constraint is violated. The script can use a keyref dereference operator to use a keyref defined in the XML schema to get data. The system can coerce data into a type defined in the XML schema.

An interpreter can be used to evaluate the script. In one embodiment interpreter can execute a script in accordance with a scripting language. The scripting language can include an import function to import an XML schema such that the definitions of the XML schema are used to interpret the script .

In one embodiment computer executable method comprises importing an XML schema for a script. The script allowing the manipulation of an Xml document and using definitions of the XML schema to interpret the script.

The present invention can include the provision of functional descriptions of methods that help integrate external Schema and Types into the native programming language. More specifically in accordance with one embodiment of the invention by integrating native XML Schema and Type into a given programming language such as ECMAScript XML based member functions for performing common operations within native programming and or scripting language can be made available. Additionally embodiments of the present invention can extend current Types by use of constraints on structure and also the ability to mix constrained and unconstrained Types into a common structure. The external data source can be any programming language or database. Accordingly the present invention can provide a mechanism to integrate and manipulate both external and native objects which is particularly suited for the increasingly universal problem of mapping external objects into and out of software applications and web services written in modern programming languages.

The present inventions will be described by way of exemplary embodiments but not limitations illustrated in the accompany software code and or drawings. Embodiments of the present invention can include a method for associating external Type system in the native programming language such that programmer can take advantage of the Type representation of an external programming language or database into the host programming language using familiar to the host programming language programming concepts and without major effort or learning exercise. Thus a new Type system is introduced by importing a new schema and Type system into the host programming language.

In addition embodiments of the present invention can use a method to expand and extend the native Type system with the help of constraints on structure.

In addition embodiments of the present invention can use a method for allowing coercion of Types so that the programming language can perform operations on values of different types without the compiler interpreter raising an exception. Instead the compiler interpreter can automatically change coerce one of the data types to that of the other before performing the operation. In one embodiment the compiler interpreter can allow all coercions unless it can prove that the coercion will always fail. Any coercion that may fail can generate a warning at compiler time and many produce a runtime error if the coercion fails.

In addition the embodiments can use a method to use Type information to change semantics and a method of mixing constrained and unconstrained Types in a common structure to dynamically include anything.

In addition embodiments of the present invention include a method to include external Types and Schemas into the native language editors and IDEs to provide assistance to the programmer by offering features such as name completion and property lists.

As discussed above conventional programming languages do not provide sufficient functionality when it comes to interoperability and integration between XML documents and programming language objects. Therefore in accordance with the teachings of the present invention XML oriented schema and document for use in association with a programming language such as Java C ECMAScript and so forth are provided and will now be described. To avoid confusion the following examples are described in relation to ECMAScript however the applicability of the present invention should not be read as being limited solely to ECMAScript.

The inventions are discussed below with the help of illustrations in accordance to one embodiment of the invention. is an exemplary XML Schema to describe an inventory that consists of various parts. Here our hypothetical schema is residing on example.com server and the file is called inventory.xsd. It is in its first version. The default namespace declaration is the schema reference to XML Schemas Structures and this is a closed model schema which means that all documents conforming to this schema will be completely defined by the schema and must not have any outside content. Next element is used to declare inventory element. Inventory is defined as a complexType element meaning that it contains other elements and or attributes. The constraint on its occurrence meaning maximum number of times that an element may appear in a content model as defined by the term unbounded indicates that there is no maximum number of occurrences for this element. The key name indicates that some field of the schema contains a key value. The key value must be unique and may not be nullable. The part of element refers to another part of which this part is a sub component. The requires element refers to a set of other parts this part requires. Then the schema defines elements for part with the constraint that the element information items match the items in sequential order. Some of the part elements have constaints as defined by dataType quantityType and partIdType. The annotations element can have any dataType as indicated by anyType dataType.

Importing an XML Schema file can create a collection of new types for manipulating XML values conforming to the XML types defined in the schema file. Each of these types can be a restricted form of the general XML type. The nature and extent of these restrictions can be defined by the XML Schema language. The programming language compiler interpreter can enforce these restrictions through a combination of compile time and run time checks for each operation. Importing the schema inventory.xsd can create a new XML type called inventory. This is done by declaring an object inv that holds inventory document. Then we read an XML inventory document from file such as inventory.xml . At this point the new Type can be created and initialized with appropriate values. The type can be further expanded by the user of constraints defined in the schema to form complex types. For example. value of instock and onorder elements of each part can be constrained to be between 0 and 999 and partIDType element is constrained by the format A Z 3 0 9 4 or AAA 1111 format where AAA is any alphabet string and 1111 can be any number between 0 and 9999. Another example would be specifying a date format for example a date could be represented as date month year or month date year by specifying the constraints as dd dd dddd . Yet another example would be specifying the pattern constraint for a telephone number for e.g. nnn nnn nnn nnnn country code area code npa nxxx . Other types of constraints could be defining the element a string or float. This Type constraint could be one or many of any of the Types defined in the external programming language irrespective of whether they are defined in the native language or not. This way the native language is incorporating the feature functionality and semantics of the external programming language while using the programming concepts of the native programming language. Thus it is able to introduce new Type systems as well as extend current Type system and data representations.

If the value of these elements is changed to a value that doesn t follow the pattern or is not within the defined schema constraints then the error can be caught at compile time or by using a built in function. This feature may be implemented by augmenting the compiler or interpreter with calls to well known validation algorithms for each type of schema constraint. For example in the addition of an illegal property color can be flagged at compile time or run time using the schema information which doesn t define the element color. Similarly in attribute partno doesn t follow the A Z 3 0 9 4 format described in the schema so can be flagged as an error. In an another example as depicted in since element instock can only take values between 0 999 the declared value of 999999 can be flagged as an error. To avoid unnecessary runtime inefficiencies runtime validation can be deferred until the developer explicitly requests it using the built in validate method. The validate method can detect at run time if any data constraints of the element have been violated as shown in .

In addition the present invention introduces a method for allowing coercion of Types so that the programming language can perform operations on values of different types without the compiler raising an exception. Instead the compiler automatically changes coerces one of the data types to that of the other before performing the operation. The compiler allows all coercions unless it can prove that the coercion will always fail. Any coercion that may fail generates a warning at compiler time and many produce a runtime error if the coercion fails. For example in since schema describes each part price as a floating point number operator does the arithmetic addition instead of string concatenation. Similarly in the integer is automatically coerced to the floating point value 35.00 due to schema information.

One embodiment includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the features presented herein. The storage medium can include but is not limited to any type of disk including floppy disks optical discs DVD CD ROMs micro drive and magneto optical disks ROMs RAMs EPROM s EEPROM s DRAMs flash memory devices magnetic or optical cards Nan systems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

Stored on any one of the computer readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers and user applications.

The foregoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to one of ordinary skill in the relevant arts. For example steps performed in the embodiments of the invention disclosed can be performed in alternate orders certain steps can be omitted and additional steps can be added. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims and their equivalents.

