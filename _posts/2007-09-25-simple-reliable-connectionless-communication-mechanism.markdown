---

title: Simple, reliable, connectionless communication mechanism
abstract: A server interconnect system includes a first server node operable to send and receive messages and a second server nodes operable to send and receive messages. The system further comprises a first interface unit in communication with the first server node and a second interface unit in communication with the second server node. The first interface unit has a first set of message send registers and a first set of message receive registers. Similarly, the second interface unit has a second set of message send registers and a second set of message receive registers. The server interconnect system also includes a communication switch that receives and routes a message from the first or second server nodes when either of the first or second registers indicates that a valid message is ready to be sent. A method implemented by the server interconnect system is also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396159&OS=09396159&RS=09396159
owner: Oracle America, Inc.
number: 09396159
owner_city: Redwood City
owner_country: US
publication_date: 20070925
---
In at least one aspect the present invention relates to communication within a cluster of computer nodes.

A computer cluster is a group of closely interacting computer nodes operating in a manner so that they may be viewed as though they are a single computer. Typically the component computer nodes are interconnected through fast local area networks. Internode cluster communication is typically accomplished through a protocol such as TCP IP or UDP IP running over an ethernet link or a protocol such as uDAPL or IPoIB running over an Infiniband IB link. Computer clusters offer cost effective improvements for many tasks as compared to using a single computer. However for optimal performance low latency cluster communication is an important feature of many multi server computer systems. In particular low latency is extremely desirable for horizontally scaled databases and for high performance computer HPC systems.

Although present day cluster technology works reasonably well there are a number of opportunities for performance improvements regarding the utilized hardware and software. For example ethernet does not support multiple hardware channels with user processes having to go through software layers in the kernel to access the ethernet link. Kernel software performs the mux demux between user processes and hardware. Furthermore ethernet is typically an unreliable communication link. The ethernet communication fabric is allowed to drop packets without informing the source node or the destination node. The overhead of doing the mux demux in software trap to the operating system and multiple software layers and the overhead of supporting reliability in software result in significant negative impact on application performance.

Similarly Infiniband IB offers several additional opportunities for improvement. IB defines several modes of operation including Reliable Connection Reliable Datagram Unreliable Connection and Unreliable Datagram. Each communication channel utilized in IB Reliable Datagrams requires the management of at least three different queues. Commands are entered into send or receive work queues. Completion notification is realized through a separate completion queue. Asynchronous completion results in significant overhead. When a transfer has been completed the completion ID is hashed to retrieve context to service the completion. In IB receive queue entries contain a pointer to the buffer instead of the buffer itself resulting in buffer management overhead. Moreover send and receive queues are tightly associated with each other Implementations cannot support scenarios such as multiple send channels for one process and multiple receive channels for others which is useful in some cases. Finally reliable datagram is implemented as a reliable connection in hardware and the hardware does the muxing and demuxing based on the end to end context provided by the user. Therefore IB is not truly connectionless and results in a more complex implementation.

Accordingly there exists a need for improved methods and systems for connectionless internode cluster communication.

The present invention solves one or more problems of the prior art by providing in at least one embodiment a server interconnect system providing communication within a cluster of computer nodes. The server interconnect system includes a first server node operable to send and receive messages and a second server node operable to send and receive messages. The system further comprises a first interface unit in communication with the first server node and a second interface unit in communication with the second server node. The first interface unit has a first set of message send registers and a first set of message receive registers. Similarly the second interface unit has a second set of message send registers and a second set of message receive registers. The server interconnect system also includes a communication switch that receives and routes a message from the first or second server nodes when either of the first or second registers indicates that a valid message is ready to be sent. Advantageously the server interconnect system of the present embodiment is reliable and connectionless while supporting messaging between the nodes. The server interconnect system is reliable in the sense that packets are never dropped other than in catastrophic situations such as hardware failure. The server interconnect system is connectionless in the sense that hardware treats each transfer independently with specified data moved between the nodes and queue memory addresses specified for the transfer. Moreover there is no requirement to perform a handshake before communication starts or to maintain status information between pairs of communicating entities. Latency characteristics of the present embodiment are also found to be superior over the prior art methods.

In another embodiment of the present invention a method of sending a message from a source server node to a target server node via associated interface units and a communications switch is provided. The method of this embodiment comprises providing a message to the system memory of the source server node. Send message information is written into an assigned send doorbell register located within a source interface unit. The send message information includes a pointer to a buffer placed in a SEND ADDR field the size of the message placed in a SEND SIZE field the target server node identification placed in a TARGET NODE field and the receive queue identification placed in a TARGET QID field. A corresponding send status register located in the source interface unit is set to a pending state. The target node identification receive queue identification and message content are transferred to a server switch. The message is then routed to the second server node.

Reference will now be made in detail to presently preferred compositions embodiments and methods of the present invention which constitute the best modes of practicing the invention presently known to the inventors. The Figures are not necessarily to scale. However it is to be understood that the disclosed embodiments are merely exemplary of the invention that may be embodied in various and alternative forms. Therefore specific details disclosed herein are not to be interpreted as limiting but merely as a representative basis for any aspect of the invention and or as a representative basis for teaching one skilled in the art to variously employ the present invention.

Except in the examples or where otherwise expressly indicated all numerical quantities in this description indicating amounts of material or conditions of reaction and or use are to be understood as modified by the word about in describing the broadest scope of the invention.

It is also to be understood that this invention is not limited to the specific embodiments and methods described below as specific components and or conditions may of course vary. Furthermore the terminology used herein is used only for the purpose of describing particular embodiments of the present invention and is not intended to be limiting in any way.

It must also be noted that as used in the specification and the appended claims the singular form a an and the comprise plural referents unless the context clearly indicates otherwise. For example reference to a component in the singular is intended to comprise a plurality of components.

Throughout this application where publications are referenced the disclosures of these publications in their entireties are hereby incorporated by reference into this application to more fully describe the state of the art to which this invention pertains.

With reference to a schematic illustration of an embodiment of a server interconnect system for communication within a cluster of computer nodes is provided. Server interconnect system includes server nodes . Since the system of the present invention typically includes a plurality of nodes i.e. n nodes as used herein the superscript n which can be used to refer to the configuration of a typical node with associated hardware. Each of server nodes includes CPU and system memory . System memory includes send buffers and receive queues . In the present embodiment messaging is initiated by writes to doorbell registers implemented in hardware as set forth below. The content of the write specifies the source node and address and the destination node and queue. Multiple doorbell registers are defined for each node. The doorbell registers are advantageously mapped into user processes. Messaging may be initiated at the user level. Interface units are associated with server nodes . Interface units are in communication via communication links to server communication switch . In a variation of the present embodiment the server interconnect system is used to connect multiple servers through a PCI Express fabric. Moreover in one refinement of the present embodiment interface units and server communication switch are implemented as separate chips. In another refinement of the present embodiment interface units and server communication switch are both located within a single chip.

With reference to the utilization of a plurality of message registers to send and receive messages is illustrated. is a schematic illustration of an embodiment of a interface unit used in server interconnect systems. Server nodes are associated with a set of message registers. Set of message registers are located within interface unit and are associated with server node . provides a schematic illustration of the disposition of message registers in interface unit . Interface unit includes a set of message send registers and a set of message receive registers. The set of message send registers include send doorbell register that is used to initiate a message transfer. In one variation send doorbell register includes the fields provided in Table 1. The sizes of these fields are only illustrative of an example of send doorbell register .

The set of message send registers also includes send status register . Send status register is associated with doorbell register . Send status register contains the status of the message send initiated through a write into send doorbell register . In a variation send status register includes at least one field as set forth in Table 2. The size of this field is only illustrative of an example of send status register .

Software encoded in computer readable media and executing on server node allocates a receive queue to receive messages in system memory. The set of message receive registers includes receive queue configuration register . Receive queue configuration register is used by the executing software to describe the receive queue structure to hardware. Fields in receive queue configuration register include one or more of the fields set forth in Table 3. The sizes of these fields are only illustrative of an example of receive queue configuration register .

Receive queue control register is associated with receive queue configuration register . Receive queue control register includes at least one field as set forth in Table 4. The size of this field is only illustrative of an example of receive queue control register .

Receive queue status register is also associated with receive queue configuration register . Receive queue status register holds the current status of the receive queue. Fields in receive queue status register include one or more of the fields set forth in Table 5. The sizes of these fields are only illustrative of an example of receive queue status register .

Each of interface units typically contain a large number of send and receive registers i.e. on the order of a 1000 or more . Each software process thread on a server that wishes to send data to another server is allocated a send doorbell register and an associated send status register. Each software process that wishes to receive messages from another server is allocated a receive queue configuration register and an associated receive queue status register.

With reference to D an example of communication utilizing the server interconnect system set forth above is provided. provide a flowchart of a method for transferring messages between server nodes. In this example communication is between source server node and target server node . Executing software writes a message into buffer in system memory associated with source server node as indicated in step a . In this example server node and interface unit are the send side and server node and interface unit are the receive side. Software then writes in step b a valid word into the assigned send doorbell register with a pointer to buffer placed in the SEND ADDR field the size of the message placed in the SEND SIZE field the target server node id placed in the TARGET NODE field and the receive queue id placed in the TARGET QID. The valid bit is used by hardware to determine if software is providing a valid doorbell for processing. In a variation hardware may also assume an implicit valid when it receives a doorbell write but we just chose to include an explicit valid bit set by software. When hardware in interface unit detects a valid doorbell it sets the corresponding send status register to the pending state by writing the corresponding message to the SEND STATUS field in step c . In step d hardware then performs a DMA read to get the contents of the message from system memory and sends it to the server communication switch along with the target node id and receive queue id. Server communication switch routes the message to target server node .

Target interface unit at the target server uses the receive queue id to identify the targeted receive queue in step f . A DMA write is then performed to deposit the message in receive queue pointed to by the tail pointer of the receive queue status register in step g . Target interface unit unit then increments RQ TAIL in the receive queue status register in step h and sends an acknowledgment ack back to the source interface unit . When source interface unit receives the ack it updates the SEND STATUS field in send status register to done as shown in step i . When errors occur or if the receive queue is full target interface unit sends an error message back to source interface unit . Depending on the type of error source interface unit either does a retry sends message again or discards the message and sets the SEND STATUS field to indicate the error. Communication is reliable in the absence of unrecoverable hardware failure. When ARM INTR is set the receiving server is interrupted as set forth above. ARM INTR provides a way for software to tell messaging hardware if it software is waiting for an interrupt on message arrival.

Executing software on the send side polls the send status register . When a status change from pending to done or error is detected the appropriate action is taken. Executing software on the receive side polls the receive queue status register . When an incrementing of the tail pointer is sensed target sever node detects the arrival of a new message. Target server node proceeds to process the message. Optionally the receive side could also wait for an interrupt when a message arrives. Once processing of an entry is completed the RQ HEAD field is updated in the receive queue control register to inform hardware that the corresponding queue entry is now available for a new message. In this context hardware refers to hardware processing the receive queue. It should be appreciated that in at least one variation the receive queue is a ring and has a certain number of entries Table 3 RQ ENTRIES . Hardware adds new messages at the tail and increments the tail pointer to tell software that a new message is available . Software processes messages at the head and increments head pointer to tell hardware that a message has been processed the corresponding entry is available . When all entries in a receive queue are full and a new message arrives receiving hardware sends a queue full error message instead of an ack.

In a variation of the present embodiment sockets are utilized to effect message transferring. As used herein the term socket refers to a software object e.g. application programming interfaces API that connects an application to a network protocol. In a refinement of this variation datagrams are used for communication between the server nodes. Datagrams utilize data packets for such communication. In a further refinement of this variation this communication is connectionless. The implementation of socket datagrams used herein are reliable in the absence of hardware failure.

Referring to each server node utilizes a driver that attaches to the associated interface unit . The driver controls all send and receive registers on interface units and allocates them to user processes as needed. A user level socket library runs on top of the driver. The socket library is linked by an application executing on server node . The socket library is used by the application to communicate with other server nodes. The socket library converts socket API calls to interface units to perform communication as described below.

In a refinement of the present application four function calls are used herein in the socket datagram API. These function calls are set forth in Table 6.

An open on interface device is performed to get a file descriptor to the interface device. Multiple mmap calls are utilized to map a send doorbell register and an associated send status register and a receive queue configuration register and an associated receive queue status register. Send buffers and receive queues are also allocated with the receive queue configuration register programmed as needed. A bind call is executed from a running socket by first checking if the bind requires the server to attach to a specific receive queue . If so an mmap is performed to attach to the receive queue if the receive queue is already taken it is an application error and the appropriate error code is returned . If the bind does not specify a receive queue the running socket just returns the ID of receive queue allocated earlier. To perform sendto or sendmsg a running socket copies the message from the application provided buffer into the library send buffer allocated earlier. Send doorbell register is then written to thereby initiating message transfer to user address space. The running socket then waits for send status register to indicate that the message transfer is done or that an error has occurred. When the transfer is completed successfully the number of bytes transferred is returned as the return value of the sendto sendmsg function call. It should be appreciated that there are two levels of processing here. There is the user library that manages the send doorbell and send status registers and the application visible socket interface that works similar to software functions subroutines that take parameters and return a value on completion. When the transfer fails an appropriate error code is returned to send status register . To perform recvfrom or recvmsg the running socket first checks if receive queue is empty. If receive queue is not empty the next valid message in receive queue is copied into the application provided buffer. The number of bytes received is then returned. If receive queue is empty the running socket may wait while polling the receive queue . In a variation interrupts are utilized to indicate to the operating system that a message has been transferred to receive queue . Alternatively if a non blocking socket is utilized the appropriate error code is returned allowing the application to retry later.

While embodiments of the invention have been illustrated and described it is not intended that these embodiments illustrate and describe all possible forms of the invention. Rather the words used in the specification are words of description rather than limitation and it is understood that various changes may be made without departing from the spirit and scope of the invention.

