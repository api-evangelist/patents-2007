---

title: Method and system for communicating between two independent software components of a device
abstract: A method and system for communicating between two independent software components of the WINDOWS® SIDESHOW™ device are disclosed. Specifically, one embodiment of the present invention sets forth a method, which includes the steps of independently queuing an incoming packet from a second software component via an emulated serial transport in a first software component before parsing and responding to the incoming packet and independently queuing an outgoing packet in the first software component before transmitting the outgoing packet to the second software component also via the emulated serial transport.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08032354&OS=08032354&RS=08032354
owner: NVIDIA Corporation
number: 08032354
owner_city: Santa Clara
owner_country: US
publication_date: 20071227
---
The present invention relates to WINDOWS SIDESHOW technology and more particularly to a method and system for communicating between two independent software components of a SIDESHOW device.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Windows Vista is a commercially available operating system from Microsoft Corporation of Redmond Wash. hereinafter referred to as WINDOWS VISTA. Windows SideShow is a commercially available application program from Microsoft Corporation of Redmond Wash. hereinafter referred to as WINDOWS SIDESHOW. With WINDOWS VISTA operating systems becoming the dominant operating systems for personal computers a variety of software or hardware applications compatible with Vista based computer systems are also becoming more and more popular. One of the Vista based software hardware applications WINDOWS SIDESHOW which is a technology that supports an auxiliary screen to the Vista based computer system.

To illustrate is a simplified block diagram showing a software stack for a WINDOWS SIDESHOW device. The software stack includes a built in gadget a SIDESHOW Application Programming Interface API a tiny media API a tiny Common Language Runtime CLR and an embedded operating system OS . Here two distinct software components such as the built in gadget and the embedded OS communicate with each other via emulated serial transports such as virtual Universal Asynchronous Receiver Transmitter UART ports. Unlike their physical counterparts that directly access the hardware of the WINDOWS SIDESHOW device these virtual UART ports are created to emulate the characteristics of the physical UART ports and to facilitate the communication between two software components. Specifically for the built in gadget to access the hardware of the WINDOWS SIDESHOW device the built in gadget may invoke function calls supported by the tiny media API wherein the function calls further depend on routines that are supported by the tiny CLR . To abstract some of the operation details of the software stack from the built in gadget some of the data or commands from the built in gadget are encapsulated and sent through virtual UART ports so that the data or commands can be further operated on by the embedded OS .

However there currently lacks a method or system to ensure the robustness of the communication between the aforementioned two independent software components through the emulated serial transports. More particularly conventional methods or systems neither guarantee the success of the transfer of packets from one software component to another nor enable the software component that sends the packets to efficiently acquire the status of such transfer.

What is needed in the art is thus a method and system that enable two independent software components of the WINDOWS SIDESHOW device to communicate robustly and efficiently and address at least the problems set forth above.

A method and system for communicating between two independent software components of the WINDOWS SIDESHOW device are disclosed. Specifically one embodiment of the present invention sets forth a method which includes the steps of independently queuing an incoming packet from a second software component via an emulated serial transport in a first software component before parsing and responding to the incoming packet and independently queuing an outgoing packet in the first software component before transmitting the outgoing packet to the second software component also via the emulated serial transport.

At least one advantage of the present invention disclosed herein is to further improve the robustness of the communications between two independent software components in a WINDOWS SIDESHOW device.

Throughout this description a computer system may include a main system and an auxiliary system. The main system typically is configured with a feature rich operating system such as WINDOWS VISTA and much computing resources such as central processing units CPUs and memory systems. The auxiliary system on the other hand is typically configured with embedded software programs and limited hardware resources. A primary display broadly refers to the display mainly driven by the main system and an auxiliary display broadly refers to the display that can be driven by either the main system or the auxiliary system. Here an example of the main system is a laptop computer and an example of the auxiliary system is a WINDOWS SIDESHOW device coupled to the laptop computer.

Outgoing packets of the first software component whether containing commands results of executions or status information are transferred by the first packet transmitter to the second packet receiver through the emulated serial transport . Once received by the second packet receiver such outgoing packets are viewed as incoming packets from the perspective of the second software component . If the packets are successfully received the second packet receiver returns an acknowledgment signal indicative of the success to the first software component through the emulated serial transport . If the packets are not successfully received the second packet receiver returns a non acknowledgment signal indicative of the failure also back to the first software component . After successfully receiving the packets the second packet receiver sends the received packets to a receive queue not shown from which the second packet parser retrieves the packets and looks into the content of the packets. If the packets received are command packets the parsed commands will be executed and the results of the executions are sent to the second packet transmitter . In one implementation the second packet parser generates the packets that contain the results and are sent. If the received packets are not command packets such as packets containing responses or status information no commands are executed. Instead some application programs not shown may be notified of the responses or status information.

Similarly the second packet transmitter also transmits packets to the first packet receiver through the emulated serial transport . After having successfully received the packets the first packet receiver returns an acknowledgement signal to the second software component . On the other hand if the packets are not received successfully the first packet receiver returns a non acknowledgment signal back to the second software component . The first packet receiver then sends the packets to the receive queue from which the first packet parser retrieves the packets and looks into the content of the packets to decide whether to execute commands or to notify the first software component of some execution results.

In one implementation the packet parser generally recognizes two types of packets a command packet and a response packet. A command packet contains a particular command intended to be executed and a response packet contains results of executing a command. In one implementation the response packet may also include error information associated with a failed operation. To illustrate suppose an incoming packet is a command packet. After the packet parser parses the packet an application program corresponding to the command executes the command and places the execution results in a response packet to be sent back to the software component from which the command packet comes. This response packet to be transferred is first placed in the transmitter queue which the packet transmitter subsequently accesses. It should be noted that not all command packets require the recipient to respond with a response packet.

On the other hand suppose the command is not executed properly. An error response packet is generated containing information associated with the failed execution and is placed in the transmitted queue to be sent out. In another situation suppose the packet transmitter sends out an outgoing packet and receives a predetermined number of non acknowledgement notifications over a predetermined amount of time. Here the packet transmitter also generates an error response packet with information indicative of this detected error condition and actually places this error response packet in the receiver queue of the same software component . Subsequent paragraphs further detail the interactions among the various sub components within the software component .

On the other hand if the packet in the receiver queue is the command packet then the packet parser invokes the application program corresponding to the command to execute it in step . The application program in one implementation is external to the software component and even the software component communicating with the software component . It should also be noted that the packet parser continues to check if there is another packet in the receiver queue during the execution of the command. After such execution is done the packet parser generates a response packet including the results of the execution and puts the response packet in the transmitter queue in step . It is worth noting the steps of generating the response packets and the command packets are of higher priory than any other steps of the illustrated process . In other words generating the response packets and the command packets is attended to by the packet parser first even if the packet parser is still in the process of invoking an application program to execute the command determining the packet type or checking if there is any packet in the receiver queue .

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. One embodiment of the present invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. The above examples embodiments instruction semantics and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

