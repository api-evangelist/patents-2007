---

title: Transactional memory computing system with support for chained transactions
abstract: A computing system processes memory transactions for parallel processing of multiple threads of execution provides execution of multiple atomic instruction groups (AIGs) on multiple systems to support a single large transaction that requires operations on multiple threads of execution and/or on multiple systems connected by a network. The support provides a Transaction Table in memory and fast detection of potential conflicts between multiple transactions. Special instructions may mark the boundaries of a transaction and identify memory locations applicable to a transaction. A ‘private to transaction’ (PTRAN) tag, directly addressable as part of the main data storage memory location, enables a quick detection of potential conflicts with other transactions that are concurrently executing on another thread. The tag indicates whether (or not) a data entry in memory is part of a speculative memory state of an uncommitted transaction that is currently active in the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08095741&OS=08095741&RS=08095741
owner: International Business Machines Corporation
number: 08095741
owner_city: Armonk
owner_country: US
publication_date: 20071030
---
This application is a continuation in part and contains subject matter which is related to the subject matter of the following co pending application which is assigned to the same assignee as this application International Business Machines Corporation of Armonk N.Y. The below listed application is hereby incorporated herein by reference in its entirety 

U.S. Ser. No. 11 748 044 filed May 14 2007 entitled COMPUTING SYSTEM WITH OPTIMIZED SUPPORT FOR TRANSACTIONAL MEMORY by Thomas Heller et al.

IBM is a registered trademark of International Business Machines Corporation Armonk N.Y. U.S.A. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

This invention relates to computer systems and particularly to a computing system with support for chained transactions with transactional memory.

Current multiprocessor and multithreaded computing systems allow the performance of a single software application to be scaled to many times the possible performance of a single threaded application. Current software and hardware systems provide for the parallel processing of multiple threads of execution. Software applications can use existing thread libraries such as the POSIX pthread library to control the creation of multiple threads of parallel execution. The use of multiple threads works well for applications that operate on easily partitioned tasks and data. Course grain locks can be used to control access to the few shared data structures to prevent rare conflicts between the data updates of multiple threads. However how a system can support a single large transaction that requires operations on multiple threads of execution has not found a satisfactory solution.

Many software applications contain data structures that must be shared among multiple threads and have frequent concurrent inspections and updates of the shared data structures. These applications require additional modifications in order to obtain good scaling when using large numbers of threads. Applications which use multiple threads of execution that access shared data structures currently require the use of specialized data locking routines in order to produce a reliable outcome that is free from deadlocks and corrupted data. The majority of existing multithreaded applications in this category use fine grained software locks to achieve good performance and correct operation. Writing high performance multithreaded programs which use fine grained software locks is extremely difficult and requires expert programming skills. The lack of these skills in the software industry severely limits the production of multithreaded applications which require the use of shared data structures and therefore the usefulness of multithreaded and multiprocessor computing systems for certain application classes including many forms of transaction processing.

Various Transactional Memory systems have been proposed and built to provide a simpler programming model for constructing multithreaded applications that need to control access to shared data structures. These systems allow software running on one thread of execution to optimistically assume that shared data structures can be updated without conflict with the accesses and updates of other threads of execution. The speculative updates to memory are kept pending until the transactional memory system confirms that no conflicts with storage accesses of other threads have occurred. The transactional memory system must be able to discard the pending speculative updates when conflicts between the storage accesses of multiple threads are detected. The existing transactional memory systems range from those that rely completely on new software constructs to those that rely on a mixture of hardware and software to obtain reasonable performance. Some existing systems have very high overhead in terms of the number of instructions executed in support of the required transactional memory behavior. Other existing systems have limitations associated with complex data cache structures that hold the pending updates to memory in caches. The cache based systems use many additional cache coherency states which causes a large increase in the design and simulation efforts for those systems.

Recently transactional memory systems have been proposed as illustrated by Microsoft s United States Patent Application Publication No. US2007 0028056 which use software enlistment records associated with memory locations that have been accessed by transactions. The Microsoft system also uses a version value in the enlistment record . FIG. 3 of Pub. No. 2007 0028056 includes an operation Locate enlistment record of memory location . The text describing gives the example of the enlistment record being part of a software object at the referenced memory address. From Pub. No. 2007 0028056 in paragraph 24 it will be seen that Timothy L. Harris the Microsoft inventor indicates that an enlistment record is created with the use of a software transactional memory interface . The Microsoft Pub. No. 2007 0028056 uses version numbers associated with each enlistment record and needs to deal with cases where the version number exceeds the maximum number supported by the enlistment record. In hindsight after learning of the details of our invention it will be recognized that these features of the recent developments in transaction memory systems are not needed and can be improved upon.

Earlier and now long ago as pointed out in the development of fast paced computing systems developments summarized by David A. Wood University of Wisconsin Transactional Memory Workshop Apr. 8 2005 it was Chang and Mergen of IBM described in 801 Storage Architecture and Programming who proposed using a lock bit associated with each segment of virtual memory. Their system provided an ability to detect concurrent accesses of storage locations by multiple threads but restricted the total number of concurrent threads that could operate on any single virtual memory segment when the transaction locking mechanism becomes active. Large virtual memory page tables which are required by Chang and Mergen to execute concurrent threads imposes a performance penalty on all threads of execution that use virtual memory not just those that execute transactions so the Chang and Mergen suggestions became an anecdote in the prior art as Woods said No one seems to be looking at what they learned . The current invention uses a Transaction Table that is distinct from the virtual memory page tables of the system.

Unknown to Woods in the Chang and Mergen IBM Yorktown facility there have been ongoing laboratory developments relating to transactional memory systems culminating with the most recent transactional memory system described by Xiaowei Shen U.S. patent application Ser. No. 11 156 913 filed Jun. 20 2005 and entitled Architecture Support of Best Effort Atomic Transactions for Multiprocessor Systems .

Shen describes a transactional memory system which focuses on using caches as buffers for data accessed by atomic transactions . Xiaowei Shen forces the failure of a transaction when the system detects a buffer overflow and does not propose dealing with the case of speculative data being evicted from the cache. A buffer overflow will result if too many transactional loads or stores target the same cache congruence class. The percentage of transactions which overflow the cache and fail will be proportional to the number of loads and stores contained in a transaction. Long transactions will fail more often.

Other systems have been proposed which use a cache to implement a conflict detection scheme and to capture speculative data which overflows the cache. We have found it desirable not to rely primarily on data cache states for conflict detection. The required specialized cache states cause an undesired increase in complexity and also makes it difficult to add the required detection and isolation mechanisms to existing multiprocessor cache coherency designs. Nevertheless there are numerous attempts to exploit the cache which have been tried besides the Xaiowei Shen development including Moore et al who describe the use of a before image log in their paper LogTM Log based Transactional Memory . Moore uses cache coherency states to implement a conflict detection scheme. Another such system Ananian et al describe a transactional memory system which uses a single unsorted linear array data structure to capture speculative data which overflows data caches. They use an extra bit per cache set the O bit to indicate if that set has overflowed and another bit per cache entry the T bit to indicate that the entry holds speculative data. The linear array data structure does provide the ability to support longer transactions but it does not provide the fast detection capability of the current invention. The linear array in Ananian needs to be searched for any cache access that targets the set that overflowed . This can be a long process for transactions which cause many overflows. Rajwar Herlihy and Lai take a similar approach as Ananian in their paper Virtualizing Transactional Memory . Rajwar also uses a data cache as the primary mechanism to track the speculative state associated with transactions. Speculative data which is forced out of the caches is moved to the XADT overflow area in virtual memory. The detection of a possible conflict with an address that is part of the XADT requires a slow linear search of the XADT. Rajwar describes the use of filters to eliminate some of these searches but there are many cases where the searches will still need to be done.

In addition to the above summarized developments in the field many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The paper Architectural Semantics for Practical Transactional Memory McDonald et al Computer Systems Laboratory Stanford University 2006 this paper listed in our IDS is submitted herewith and is incorporated herein by reference compares some of the proposals and provides references for many others and is incorporated herein by reference.

The shortcomings of the prior art are overcome and additional advantages are provided through the provision of a computing system which processes memory transactions for parallel processing of multiple threads of execution provides execution of multiple atomic instruction groups AIGs on multiple systems to support a single large transaction that requires operations on multiple threads of execution and or on multiple systems connected by a network. A combination of a private to transaction PTRAN tag attached to each increment of real system memory and a log of speculative loads and stores to provide an improved implementation of a transactional memory system. The current invention uses a log with the added mark bit employed as a private to transaction PTRAN tag and associated with every increment of real system memory. Hardware is provided to quickly detect conflicts between the storage accesses of transactions running on multiple threads of execution. The use of the tag in memory and associated conflict detection hardware included in this invention provides a much faster transactional memory system with much less overhead when compared to existing systems. The complexity of the current invention is lower than prior attempts at using additional cache coherency states for conflict detection especially for systems with large numbers of processors and associated interconnections.

The current invention uses the main memory array of the computing system to hold the speculative data and can support very long transactions. The current invention can benefit from the use of data caches but it does not require their use. The current invention provides the ability to check the address of a new memory access without a long search process for common cases. Likewise it is an improvement over software only transactional memory systems since the conflict detection and use of the tag in memory eliminates some of the software overhead associated with tracking the speculative state of transactions. It also provides the ability to detect storage conflicts at a very fine level down to a single byte as opposed to prior art software systems that track updates to entire software objects which may be hundreds or thousands of bytes. Existing software systems will either give frequent over indication of potential data conflicts or incur very large software path length penalties when attempting to track the updates to individual components of software objects.

Many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The current invention can be used in combination with any of them in order to provide high performance transactional memory operations without incurring a large increase in hardware or software complexity. The preferred embodiment is described for the PowerPC architecture but anyone skilled in the art could apply the same approach to any other architecture such as IBM s zSeries IBM s pSeries with the P3 P4 P5 processors and even IBM s System 38 and its AS 400 which have a memory work of 65 bits could utilize the support of this invention as well as other computer systems such as Sun Microsystems SPARC Intel s IA32 etc. Anyone skilled in the art could extend the current invention for use with other Application Programming Interfaces APIs that may be created for other specialized versions of transactional memory implementations.

The current invention uses a hardware bit or bits associated with all memory locations not just those that are currently part of an active transaction. The current invention uses the added hardware bit or bits to provide much faster execution of transactions than that which can be obtained using Microsoft s Pub. No. 2007 0028056. The current invention uses an improved transaction table as a log to optimize the memory usage and provides a system which uses less memory than would be used by other systems like the Microsoft proposal yet the invention can execute applications developed for the Microsoft proposal. The current invention provides one or more PTRAN bits for every storage increment. There is no need in the current invention for an indirect method of locating the PTRAN bit. The current invention will provide a much faster indication of potential conflict since the PTRAN bit is a directly addressable part of the memory location to be marked. The current invention does not need a Microsoft style interface and achieves its benefit using hardware and firmware to update and reset the PTRAN bit. The current invention does not require application software to be aware of the state of the PTRAN bit or bits although one may provide a direct interface if desired. The current invention is also optimized for a short commit processing time. The current invention does not require the use of a version number for each storage location.

The current invention uses a hardware bit or bits associated with all memory locations not just those that are currently part of an active transaction. The current invention uses the added hardware bit or bits to provide much faster execution of transactions than that which can be obtained using Microsoft s Pub. No. 2007 0028056. The current invention uses an improved transaction log method to optimize the memory usage and provides a system which uses less memory than would be used by other systems like the Microsoft proposal. The current invention provides one or more PTRAN bits for every storage increment. There is no need in the current invention for an indirect method of locating the PTRAN bit. The current invention will provide a much faster indication of potential conflict since the PTRAN bit is a directly addressable part of the memory location to be marked. The current invention does not need a Microsoft style interface and achieves its benefit using hardware and firmware to update and reset the PTRAN bit. The current invention does not require software to be aware of the state of the PTRAN bit or bits although one may provide a direct interface if desired. The current invention is also optimized for a short commit processing time. The current invention does not require the use of a version number for each storage location.

We noted above the Chang and Mergen suggestions which became an anecdote in the prior art as Woods said No one seems to be looking at what they learned . An advantage of the current invention is that it uses a Transaction Table that is distinct from the virtual memory page tables of the system. This enables the current invention to process very large transactions and to provide conflict detection down to a single byte. The current invention has no limit on the number of concurrent threads that can simultaneously access memory locations in the same virtual memory segment. The current invention performs conflict detection on physical memory addresses or real addresses and only restricts simultaneous access at the granularity of this conflict detection. This granularity can differ for various implementations of the current invention but will usually be on the order of bytes. If the Chang and Mergen system tries to use large numbers of concurrent threads that system could not provide similar benefits without using extremely large virtual page table formats and consequently incurring a performance penalty. The current invention does not impose this performance penalty.

System and computer program products for implementing transactions using the above summarized methods are also described and claimed herein. Generally computer program products are delivered as computer program media which are tangible embodiments of the program delivering the instructions via a CD Rom a computer disc drive a connection to another system or other tangible embodiment of a signal for delivering a program signal to the computing system which supplies the support of this system all collectively known as computer program media. The computer program media may be provided as an independent software medium installed in the computing system memory or installed as firmware embodied in the computing system memory itself during operation.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

As a result of the summarized invention technically we have achieved a solution which provides a much faster transactional memory system with much less overhead when compared to existing systems. The current invention is also an improvement over existing hardware based transactional memory systems that rely on changes to cache coherence protocols. It allows the hardware system to deal with transactions which are long enough to overflow average size caches and doesn t involve the virtual memory management overhead of prior art schemes. The current invention has a much lower level of hardware complexity and is easier to implement and verify via simulation. It also allows for the ability to detect conflicts at a finer granularity than the cache line granularity of prior art systems that are tightly coupled with data caches. The current invention also allows for the fast execution of nested transactions.

The detailed description explains the preferred embodiments of the invention together with advantages and features by way of example with reference to the drawings.

Turning now to the drawings in greater detail it will be seen that in there is a computing system illustrating an embodiment of our invention which has one or more microprocessors coupled to a physical memory array via an interconnection element . The physical memory array stores transaction data and private to transaction PTRAN tags which are associated with every increment of real system memory. The interconnection element can be implemented as a shared bus or crossbar switch. The invention applies to systems which use any other scheme of interconnecting physical memory to a multiprocessor system which may be implemented in one or more chips. The memory could be broken down into smaller portions and distributed across private connections to each of the CPU chips as done for the IBM Systems using the Power4 microprocessor or for the AMD Opteron based servers. The microprocessors and memory controllers may be located together on a single silicon chip or they may be spread across multiple chips.

The physical memory of the computing system is divided into n increments. One or more private to transaction bits PTRAN associated with every increment of real system memory are provided for each of the n increments. The invention allows for the choice of any memory increment size and the best choice will depend on workload characteristics hardware costs and data caching structure used in the target system. An increment of 16 bytes is used in the illustrated embodiment. The PTRAN bit s are used to indicate whether or not a data entry in memory is part of the speculative memory state of an uncommitted transaction that is currently active in the system.

Special new instructions BEGIN AIG END AIG as illustrated by the Nested AIG code sequence of are used to mark the beginning and end of a group of instructions. The instructions which execute between the special new instructions are referred to as an Atomic Instruction Group AIG illustrated by AIG instructions shown in Instruction A Instruction A Instruction A . Additional storage access rules are used when a processor is executing instructions which are part of an Atomic Instruction Group. All of the storage locations modified by the AIG group of instructions are updated in memory in an atomic fashion. The updates to the storage locations are kept pending until the processor and or software application indicates that they should be committed . All of the updates are either committed to normal memory at once or they are discarded. The results are discarded when hardware and or software detects a conflict between the storage accesses of multiple AIGs that are executing concurrently in the multiprocessor system. The invention provides a way for hardware to quickly detect potential conflicts between the storage accesses of multiple AIGs. Although the invention uses special new instructions to mark the boundaries of a transaction any other method could be used to identify a group of memory locations that are to be updated in an atomic fashion. The invention is compatible with any number of software interfaces that may be used to implement a transactional memory system. The invention can provide the same fast conflict detection for any system which is attempting to provide an atomic update of multiple storage locations. The invention also applies to systems which mark the boundaries of an instruction group in any other ways including compiler generated hints attached to other instructions internal microprocessor commands generated by internal microcode or millicode.

The PTRAN tag is one or more bits associated with an increment in memory which is set for all memory accesses generated by instructions that are part of an Atomic Instruction Group. A processor inspects the bit before attempting to set it this enables the quick detection of potential conflicts with other AIGs that are concurrently executing on other threads. The setting of the bit may be accomplished by a TS test and set operation of the IBM z Architecture as described by the IBM z Architecture Principles of Operation or any other equivalent operation that enables an atomic update in a multithreaded or multiprocessor system.

Turning now to it will be seen that Transaction Tables are created as part of the real system memory which is illustrated here as physical memory. The Transaction Tables could also created in logical or virtual memory. Any system to map the logical system memory to the physical system memory can be used and there are numerous examples known in the art which can be used such as those in the IBM zSeries IBM s p Series Sun Microsystems SPARC Intel s IA32 etc. A Transaction Table entry is made when instructions that are part of an Atomic Instruction Group cause a memory location to be inspected or updated. A Thread ID is associated with each Transaction Table. A Next Entry register is used as an index into the Transaction Table and indicates which entry should be written next. A Table Origin indicates the address of the first entry of the Transaction Table for its thread . The Transaction Table is used to hold additional information beyond the simple information that is associated with the PTRAN tag bit or bits that are associated with the memory location that has been inspected or updated. This additional information is related to the speculative state associated with an Atomic Instruction Group. In an illustrated IBM zSeries or pSeries CPU embodiment which we describe here we prefer to use a single PTRAN bit. In this case the Transaction Table will contain all additional information about the speculative state therefore the PTRAN bit will only indicate that a physical address is involved in an AIG. This is illustrated for Transaction Table A as the address the transaction info identifier and old or new data . Other embodiments of the current invention may use additional PTRAN bits which can be used by hardware or software to speed the processing of certain events involved in the processing of Atomic Instruction Groups or the speculative states of any other transactional memory system. The combination of using just a single bit in memory and associating that bit with a more complete description of the transactional state in the Transaction Tables provides a transactional memory system which requires very little hardware overhead without incurring the performance penalty seen in prior art software transactional memory systems.

Turning again to it will be seen as we said that an entry in the Transaction Table A for example comprises the address that has been inspected or updated inside of an AIG a Tran Info field and a Data Field . A store instruction that is part of an AIG will cause the system to copy the old data value from the original storage location to the Transaction Table entry for that address and the new speculative data is placed in the main storage location.

The invention can be made to work with the new values held in the Transaction Table if desired. The preferred embodiment places the old data value in the transaction table. This allows the system to be optimized for the case where most transactions are successful. The old data can be discarded quickly when it is no longer needed when a transaction is committed permanently to memory by changing the pointer to the transaction table or by clearing the contents of the transaction table. The Tran Info field of a Transaction Table entry includes any transaction information that is needed to make detailed decisions about the need to cause a transaction failure. It also has provisions for additional information to allow efficient support of nested transactions virtualized transactions or other extensions of the transactional memory architecture. In the preferred embodiment the Tran Info field includes an indication of whether the storage access of the associated address was a load type access or a store type access. The Tran Info field can also indicate whether the address is shared among multiple AIGs in the system.

An override of this AIG active mode may be provided. The override could be associated with the logical memory segment or logical memory page which contains the target address. An override forces the system to treat the storage request as normal in spite of the fact that the request is part of an AIG. If the override is active then the result of the decision will cause normal processing to take place. Assuming that an AIG is active and the override is not then the associated PTRAN bit is inspected at an inspection step . A load instruction inside of an AIG detects upon inspection the state of the PTRAN bit. When the PTRAN bit is already set it is due possibly to the actions of another thread executing on the same processor or on another processor. If at the inspection step it is found that the PTRAN bit is not set then the processor sets the PTRAN bit and make a record of the access in the Transaction Table for the active AIG by adding to the Transaction Table at the Set PTRAN step and then the complete load can continue . If the PTRAN bit is already set the address which caused this potential conflict is compared with the addresses already entered in the processor s Transaction Table. If the PTRAN bit was set when tested at the inspection step by another load earlier in the same AIG it is already part of the AIG as tested and determined and then the complete load may continue . Each Transaction Table contains the addresses for a particular AIG. Accordingly if the address was not already part of the AIG as tested and determined then the address for the load is not found in the processor s Transaction Table and then the processor checks whether the address is enabled for sharing among AIGs in a determination step for AIG sharing . If the address is not currently enabled for sharing among multiple AIGs the processor may signal other processors in the system to request a shared AIG access for this address during the determination step whether sharing is allowed among AIGs . A shared access can be granted if no other AIG in the system has speculatively written the storage location. If the shared access is not granted then the AIG fails otherwise the load address is added to the Transaction Table and the Tran Info field is updated to indicate that the address is a load access that is shared among multiple AIGs in the system.

The Store Processing Flowchart shows the actions for processing a store that is part of an AIG. When a processor attempts a store type access initially a store decision is made to determine whether the access is part of an AIG and whether the special storage access rules for AIG accesses apply. The mode of the processor is checked in a similar method as previously described for load accesses. If the special mode of operation under which the special access rules for AIG accesses apply is not active then the store is treated as a normal store . Assuming that an AIG is active the associated PTRAN bit is inspected at the store process inspection step . If the PTRAN bit is not already set then the PTRAN bit is set at the store transaction step and a new entry is added to the Transaction Table . The old data is moved to the Transaction Table entry the address is written to the new entry and the Tran Info field is updated. The Tran Info field is marked to indicate that the access associated with this entry was a store type access. The new store data is written to memory after the setting of the PTRAN bit is completed. If the inspection of the PTRAN bit indicates that the bit was already set then a decision is made based on whether the current store address is already part of an AIG which is active on the processor. The Transaction Table for the processor is examined if it is determined that the address is present in the Transaction Table then the Tran Info for the entry is checked and a decision as to shared access entry is made. If the Tran Info indicates that the entry is a load type access entry that is shared among multiple AIGs the transaction fails otherwise the Tran Info field for the associated entry is updated to indicate a store type access and the store is processed .

Turning now to the Commit Processing Flowchart of it will be seen that the invention includes a set of actions completed when the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory as determined initially at a test step . If not the processing continued in AIG mode . An AIG is committed to memory when the processing of the loads and stores of the AIG according to flowcharts from and does not result in a Transaction Failure. In the case of AIG success then testing determines the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory. Then the Transaction Table is examined and each entry for the AIG to be committed is read and its associated PTRAN bit is reset in memory at the Transaction Table commit step determination.

A specialized hardware engine may be used to complete the performance of this commit operation. A combination of processor caches multiprocessor coherency actions and the current invention can be used to provide software with the illusion that all of the memory updates for a single AIG occur simultaneously even though the main memory storage arrays are not updated simultaneously. During the commit processing the resetting of the PTRAN bits continues until the last valid entry in the Transaction Table has been determined to be reached . At this point the AIG is considered to be committed and the performance by the engine therefore completes .

Some conditions prevent the completion of an AIG. These conditions may be detected during load processing while executing an AIG or during store processing while executing an AIG . There are many other possible processor conditions that may cause the need to abort the processing of an AIG. These include error conditions detected in the system as well as other conditions that would require significant additional hardware support to enable the processor to handle them correctly. Many prior art transactional memory architectures include provisions for the abort of transactions and for a subsequent retry. Prior art software constructs can be used together with the current invention to eliminate the need to provide hardware to deal with all possible special cases. A simple example is the case of a timer interrupt in the middle of processing an AIG. The interrupt may cause the processor to spend a large amount of time running code that is not part of the partially completed AIG. It may not be desirable for the processor to keep the AIG active during this time. The system can force a transaction failure for any AIG that is currently executing when a timer interrupt occurs. A similar approach can be used for any other special case events occurring in the processor.

Transaction failures or forced retries are handled according to the process of the Rollback Processing Flowchart for rollback processing shown in . Turning now to it will be seen that the lack of a transaction failure condition allows the processor to continue in the AIG active mode . The preferred embodiment of the current invention uses an eager policy with respect to detecting transaction failures and causing transaction rollback. Also the invention may be used in systems that wait until the end of a transaction to take the actions required for a rollback. The memory updates executed as part of an Atomic Instruction Groups are either committed to normal main storage at the same time or they are discarded with a rollback operation .

Upon finding a transaction failure condition failure several additional steps are required . Rollback Transaction Table processing entry steps provide that the Transaction Table for the AIG is inspected and any old data is written back to the main memory address indicated in the entry. The PTRAN bit for the associated address is reset. The rollback processing continues until the last valid entry in the table has been processed . After the last valid entry has been processed the rollback is complete . The actions taken by the processor at this point will differ based upon various software architectures for transactional memory. Any of transactional memory architectures described in the background may be used. In some cases the AIG will be retried from the beginning. In other cases special software handlers will be invoked to deal with the transaction failure. The current invention may be used with any of these different architectures and chained AIGs may be executed in processors having different architectures as those processors can provide the PTRAN bit support and Atomic Instruction Group execution natively or by emulation.

The current invention supports the execution of nested transactions. A second AIG may be included within the scope of the first AIG as shown in . Each BEGIN AIG special instruction statement causes the system to create a Transaction Table and to associate the table with the AIG. Decisions about whether or not a storage address belongs to an AIG may include the inner AIG A or the combination of the inner and outer AIGs A B . The END AIG special instruction statement ends the transaction sequence but as shown a sequence for a specific transaction Transaction B may be nested within another sequence Transaction A The use of multiple Transaction Tables may be used to support many nesting architectures for transactional memory. Multiple versions of the old data may be stored in any number of Transaction Tables at any nesting depth. These multiple Transaction Tables are used to track the read and write sets of a chain of Atomic Instruction Groups which may be rolled back in the case of a transaction failure and to roll them back individually when needed.

Prior art transactional memory systems that rely on data caches to hold speculative state are unable to provide similar support for nested transactions without adding additional state information to cache directories and adding additional complexity to the cache coherency protocol. Nesting support on prior art systems would impose a large hardware complexity penalty on those designs. The current invention can also be extended to include a combined Transaction Table that includes entries from both the inner AIG Instruction B Instruction B and the outer AIG Instruction A Instruction A Instruction A . This Combined Transaction Table may be used in place of the individual Transaction Tables or in addition to the individual Transaction Tables.

The execution of multiple AIGs on multiple systems is now possible using the multiple Transactions Tables . Multiple AIGs on multiple systems support a single large transaction that requires operations on multiple threads of executions and or multiple systems connected to a network. A large transaction which requires the services of another thread of execution may find it on the same computing system or in another computing system. IBM s system z9 for instance has multiple processors internally connected by a Sysplex network and provides virtual processor support by its operating system z OS PR SM or z VM Hypervisor 1 and the System z9 couples to information handling apparatus beyond the operating system as to zVM Hypervisor 2 Guests or another processor such as a Linux processor. This operating system can be used to make the necessary connection called for by instructions of an AIG having calls to a specialized service API.

In accordance with the invention a message is sent to the other system from within an AIG operating under control of the primary operating system Hypervisor 1 . The message includes an indication that the request is part of a speculative which has not been committed to memory. The receiving thread of execution begins an AIG on its own thread and establishes a chain of AIGs which may be rolled back in case of a transaction table. The multiple Transaction tables are used to track the read and write sets individually and to roll them back when needed.

In implementing this invention an AIG includes a function call to a specialized service API. Thus the AIG provides 

The service API includes code which generates a network request or any other messaging request which is received by a service provider that has been changed to make use of an AIG for speculative execution.

The speculative service provider receives the request and begins an AIG of its own. The AIG includes code to execute the service . The service provider responds to the original speculative service API when the service is completed and ready to commit. The chained AIG is not committed until the original AIG is also ready to commit.

The commit code for the original AIG is modified to support the chain of AIGs that has been established by the specialized API. The chain is known to span multiple threads of execution of multiple systems and all participants in the chain will be notified when an AIG should be committed. 

There are many additional hardware features that can be added to the invention to speed the processing of the Transaction Table manipulations and the setting and resetting of the PTRAN bit s . Since the PTRAN bit is part of the main storage data it can be cached in the normal data caches of the system. The Transaction Tables are also part of main storage and can also be cached. Additional control information can be added to the data caches to indicate whether a specific address has been enabled for shared AIG access and therefore eliminate the need to search the Transaction Table for some cases.

The capabilities of the present invention as described above can be implemented in software firmware hardware along with some combination of software and firmware.

As one example one or more aspects of the present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The computing system described herein is able to detect the signal and recover a computer program embodied therein. It makes no difference whether the computer program is embodied in a physical media such as a hard drive or computer memory or on a CD or within a data signal. The underlying program is usable by the computing system to execute the steps described for a computer readable memory to execute the encoded functions regardless of the format of origin of the encoded program or whether the format is a disk or a signal.

Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The preferred embodiment identifies the beginning of an AIG after decoding of an instruction . If it is determined that a BEGIN AIG instruction has been decoded the processor enters a new mode of execution AIG MODE otherwise the instruction is executed as usual and processing continues with the next instruction .

Prior to entering AIG MODE the architected state of the processor is saved in the same manner that a traditional Program Call is handled in the IBM Z Series architecture. Any similar state saving mechanism may be used on any other processor architecture. The processor may return directly to this saved state if the AIG fails or may return to this state after a series of other error handling routines have been invoked. While in AIG MODE decoding of instructions continues . If a load or store is decoded then special handling of these loads and stores is required . The steps required for the processing of a load inside of an AIG are described in those for a store inside of an AIG are described in . After loads and stores in an AIG are processed it is determined whether there has been an AIG failure as described in the descriptions of and . If there is a failure then special handlers are invoked . The actions of the special handlers for transaction failure may vary depending on the architecture of the system using the invention. Many methods of dealing with transaction failures have been described in the prior art any of them could be used for this purpose. The possible methods include retrying the transaction from the beginning for a set number of attempts waiting for the condition that caused the failure to change calling specialized software routines to resolve conflicts among threads etc. These possible failure handlers may require the rollback of the AIG which caused the failure . If no failure was detected then it is determined whether the load or store was the last instruction of the AIG . If the instruction is the last instruction in the AIG then the AIG is committed using the process described in . The processor then exits the AIG Mode and continues with the next sequential instruction after the AIG .

The decoding of instruction other than loads and stores inside of an AIG does not necessarily require special processing . If the instruction is not a load or store type instruction then it is determined whether the instruction is another BEGIN AIG . Nested AIG instructions require special handling . The prior art contains many different ways of handling nested transactions. The current invention can be used to support any of them. The nested AIG handler for the preferred embodiment adds the instructions of the inner AIG to the outer AIG creating a single larger AIG. Other embodiments of the invention may provide different rules of processing for loads and stores that are part an inner nested transaction as well as special rules for the commitment and failure handling of inner nested transactions. If it is determined that the instruction is not a BEGIN AIG then the instruction is executed and it is next determined whether the instruction is the last instruction of the AIG. The preferred embodiment uses the decoding of an END AIG instruction to indicate that the last instruction of an AIG has been reached. If the last instruction of the AIG has been reached then the AIG is committed to memory and the processor exits the AIG MODE of operation .

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

