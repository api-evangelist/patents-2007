---

title: Transaction co-validation across abstraction layers
abstract: A method, apparatus, and system in which a modeling tool made up of a testbench executable program validates behavior of one or more sub-components of an electronic system design modeled as one or more executable behavioral models and a transactor translates a behavior of the sub-components between one or more different levels of abstraction derived from a same design.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08868397&OS=08868397&RS=08868397
owner: Sonics, Inc.
number: 08868397
owner_city: Milpitas
owner_country: US
publication_date: 20070112
---
This application is a continuation in part of and claims the benefit of U.S. patent application titled TRANSACTION CO VALIDATION ACROSS ABSTRACTION LAYERS Ser. No. 11 561 815 and filed on Nov. 20 2006 now abandoned.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the software engine and its modules as it appears in the Patent and Trademark Office Patent file or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the invention generally relate to electronic system design verification. An aspect is related to verification of the electronic system design at different levels of abstraction.

High level system description methodologies can allow designers and system architects to modify the traditional system design approach. Some languages such as SystemC may allow system architects to model a circuit or system at a transaction level in order to test the specified functionality and get early performance reports.

The traditional design cycle still follows or often runs concurrently with this architectural modeling. The design will be written in a hardware description level usually at RTL register transfer level to be synthesized and finalized into silicon. This brings up the need for a correlation of disparate descriptions of the same circuit or system.

The problem can be turned around chronologically as well but with the same verification challenges. Silicon IP vendors may be required to provide a transaction level model of their part in order for their customers to realize a high level simulation of a system embedding the part. This means that an existing design with a RTL description may need to be modeled at the transaction level.

Various methods and apparatuses are described for co validating transactions across multiple abstraction layers. A modeling tool made up of a testbench executable program may validate behavior of one or more sub components of an electronic system design modeled as one or more executable behavioral models. A transactor may translate a behavior of the one or more sub components between the one or more different levels of abstraction derived from the same electronic system design based upon an applied sequence of test patterns and expected test results from the same instance of the testbench executable program. A transactional testbench interface allows the transactor to access and exploit the applied sequences generated by the testbench executable program. The testbench executable program the transactor and the transactional testbench interface are to be stored and executed on a machine readable storage medium.

While the invention is subject to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention.

In the following description numerous specific details are set forth such as examples of specific data signals named components connections etc. in order to provide a thorough understanding of the present invention. It will be apparent however to one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Further specific numeric references such as a first instance of a transactor may be made. However the specific numeric reference should not be interpreted as a literal sequential order but rather interpreted that the first instance of a transactor is different than a second instance of a transactor. Thus the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention.

In general various methods and apparatuses are described for co validating transactions across multiple abstraction layers. A modeling tool including a testbench executable program validates the behavior of one or more sub components of an electronic system design modeled as one or more executable behavioral models. The testbench executable program may include code scripted as a sequence of test patterns and expected test results used to validate the behavior of the sub components. A same instance of the test bench executable program may provide the sequence of test patterns and expected test results to validate the modeled sub components at the different levels of abstraction. Thereby eliminating a need to generate a new instance of the test bench executable program for each different level of abstraction of a design to be tested. A transactor may translate a behavior of the one or more sub components between the one or more different levels of abstraction derived from the same electronic system design based upon an applied sequence of test patterns and expected test results from the same instance of the testbench executable program. A transactional testbench interface allows the transactor to access and exploit the applied sequences generated by the testbench executable program. The transactor may convert stimulus requests and responses sent between the testbench executable program and the electronic system design under verification to the necessary level of abstraction. The testbench executable program the transactor and the transactional testbench interface are to be stored and executed on a machine readable storage medium.

As discussed many electronic system designs are written at a Register transfer level RTL description of a circuit or system in a hardware description language. Generally a RTL description describes what intermediate information i.e. information stored between clock cycles in an electronic circuit is stored in registers where it is stored within the design and how that information moves through the design as it operates. The RTL description of an electronic system is a functional description at least one level of abstraction higher than the individual gate layout of the electronic design system e.g. gate level implementation Netlist . The RTL description fully and explicitly describes virtually all of the logic and sequential operations of the circuit. RTL descriptions are commonly written in standard languages such as Verilog or VHDL and are intended for logic synthesis and mapping with a commercial logic synthesizer.

A transaction level model can be a software coded model of a circuit or a system where data transfers are simplified and abstracted. This model is typically written in a high level software language such as C C or SystemC. RTL may be considered Transaction Level 0 TL0 and correspond directly with signals in the open core protocol specification. Transaction Level 1 TL1 modeling may correspond to a given protocol s phase level on an individual transfer basis and be cycle accurate. Transaction Level 2 TL2 modeling may correspond to one or more open core protocol transfers or transactions at the same time and be transaction accurate but cycle approximate. For example if a system implements burst data transfers between components this burst may be expressed using a single function call in the implementation language. The difference in the number of application programming interface calls or events can cause timing inaccuracies between these different levels of abstraction.

A transaction can be a functional unit of data transfer through a system. A transaction may be an aggregate of multiple data transfers but is tied by a semantic unity. For example a transaction may merely be group transfers at consecutive addresses between the same two components of the system.

A testbench can be the instantiation of a description of the Design under verification DUV along with meaningful sequences of stimulus applied to the system in order to validate functionality. The DUV is generally a sub component of the electronic design system and described as an abstract executable representation that may include a hierarchical set of subroutines or classes in a programming language or modules Verilog or entities VHDL in a hardware description language.

There may be a need to validate two or more descriptions of the same circuit or system. With the complexity of modern systems the verification process that consists of developing a complete testbench for the system is long and costly. It is accounted for with the same care as the resources and schedule allocated to the design of the system itself.

Therefore the perspective of developing multiple instances of different testbenches for these different descriptions is very unappealing. Designing a truly re usable common testbench across descriptions of a system at different levels of abstraction that cooperates with one or more instances of a transactional testbench interface that does translations between different levels of abstraction is desirable.

The transactor connects to a transactional testbench interface TTI . The transactor is able to exploit the methods of the transactional testbench interface to extract transactions issued by the testbench executable program . Methods of the transactional testbench interface are usually implemented outside the transactor such as a Test Channel shown in . Compliance with the transactional testbench interface is a requirement transactors should fulfill to be compatible with a testbench executable program .

The testbench executable program may contain code scripted as a sequence of test patterns and expected test results that are used to validate the behavior of the sub components . The key is to define the abstraction level that is suitable for the highest level model of the electronic system design. This means defining a data structure that represents a transaction of the system. A same instance of the testbench executable program provides the sequence of test patterns and expected test results to validate the modeled sub components at the different levels of abstraction.

The testbench executable program defines the transaction data structure of the electronic system design. Once the transaction data structure is defined the communication means of the testbench executable program to a transactor goes through a transactional testbench interface . The transactor translates a timing a functional or other type of behavior of the sub components between one or more different levels of abstraction derived from a same electronic system design. For example if the electronic system design under verification is coded at the RTL level of abstraction then each transaction sent from the testbench executable program is converted to individual signals corresponding to the planned wires at the RTL level. Essentially the RTL corresponds to code lines written for a component level description on a chip. However if the electronic system design under verification is coded at functional block level then entire circuits consisting of for example thousands of components may be represented in the software with a small amount of lines of code defining that circuit s inputs outputs capabilities its responses to various inputs and other high level characteristics of the circuit as opposed to characteristics of each individual component making up that circuit. Thus two or more different SystemC HDL descriptions of the same sub component may exist with different levels of abstraction correlating to the design.

Another example another instance of the transactor may convert each transaction to individual transfers if the design under test is coded at the transfer level of abstraction.

Overall if the testbench executable program is written at a higher level of abstraction than the level of abstraction of the subcomponent of the electronic system under test then the transactor converts the level of abstraction of the coded commands signals etc. for responses from the inputted stimulus to the electronic system design under verification up to the abstraction level of the testbench executable program . The transactor also converts the level of abstraction of the coded commands signals etc. for inputted stimulus to the electronic system design under verification from the testbench executable program down to the abstraction level of the electronic system design under verification. The transactor performs the opposite if the testbench executable program is written at a lower level of abstraction than the subcomponent of the electronic system under test. The transactor does no conversion if the design under test is coded at the same level of abstraction as the testbench executable program .

The modeling tool may also address functional validation with a high level model that merely describes approximate timing. This means the testbench executable program needs an understanding of transactions and how to correlate them with a lower level counterpart which may be as detailed as individual wires of an RTL description. The sub components of the electronic system design under verification may have several disparate descriptions each at a different level of abstraction describing the details of that sub component that can all be verified using the same testbench executable program .

The testbench executable program sends out one or more transactions at a transaction level of abstraction to the port interface from the buffer. The buffer provides storage for these requests and responses going between the testbench executable program and the transactional testbench interface . The transactor receives the testbench transactions and sends them to a channel . The buffer stores the transactions until the transactor is ready to receive the transactions and convert the transactions to the level of abstraction of sub components of the design under verification. Another buffer also stores responses from the design under verification via the transactional testbench interface until those responses are analyzed. The adapter converts responses from the design under verification to the level of abstraction of the testbench executable program.

The transactor s role in traditional methodologies merely specifies the interface to the channel connected to the design under verification but the transactional testbench interface is adapted to applying the same stimulus from the testbench executable program in different contexts. The transactor s role is to obtain the incoming transactions from the buffer and convert them to a level of abstraction usable to drive the design under verification .

For the purposes of an example let Transaction Level 2 represent a modeling layer that describes passing transactions with approximate timing information. In the Open Core Protocol OCP context this is a set of interfaces where OCP burst requests and responses can each be initiated with a single function call. Let Transaction Level 1 represent a modeling layer that describes individual data transfers with accurate protocol level phases. For example phases of a transfer and handshakes are modeled accurately. Such a model is typically synchronous and can be used to describe a system cycle accurately.

In this example the testbench executable program would be used for validation of a TL1 model. The transactional testbench interface used in this case is a FIFO accessor of transaction data structures equivalent to the ones used in the TL2 interface of each protocol.

In order to connect to such a transactional testbench interface the testbench executable program would simply need an internal FIFO of transaction data structures for each port of the design under verification. The testbench executable program is able to simply concentrate on producing sequences of transactions without worrying about signal and timing details of how they are delivered to the sub component of the design under verification . This can be modeled in SystemC using the templated sc fifo interface classes sc fifo in sc fifo out or the templated tIm fifo interface classes of the OSCI TLM standard.

The flow described here may be successfully carried out on models supporting an OCP socket. The following concrete data types may be used with SystemC and OCP 

In an embodiment the testbench executable program may include an internal buffer of transaction data structures for each port of a sub component of the electronic system design . The testbench executable program is not required to have intimate knowledge of the sub components of the electronic system design under verification . The testbench executable program has a universal interface since the transactor is coded separately and can be adjusted for the appropriate level of abstraction for sub component of the electronic system design under verification .

In operation the sequence of test patterns and expected test results of the testbench executable program are applied to the sub component of the electronic system design under verification at two or more different levels of abstraction. The testing and verification may occur in parallel or in series. The testbench executable program determines one or more behavioral descriptions of the sub components by applying a common stimulus to all different levels of abstraction of the sub component . The first monitor records a first set of functional or timing results derived from the simulation of the sub component represented at a TL2 abstraction level. The second monitor records a second set of function or timing results derived from the simulation of the sub component represented at a RTL abstraction level. The correlation module compares the first set of functional or timing results to the second set of functional or timing results for one or more stimulus generated from the testbench executable program. A set of function results may include behavior to applied stimulus such as whether an expected logic value occurs or an expected blocking of a signal occurs etc. Note for timing correlation the monitors may record timing data for later comparison by the correlation module as described more fully later. The functional correlation can include identifying that all of the transactions are present in the requests and responses collected by the monitors of the DUV at both levels of abstraction. Depending on the abstraction level of the model the transactions may be expected to be found in the same order making the correlation simple. If order inaccuracy is tolerated a mechanism for the testbench to assign unique identifiers to transactions is required. Naturally the transaction identifiers will be found in both traces since the same testbench is used.

Thus the monitors are used to correlate the behavioral descriptions of the sub components between two or more different levels of abstraction from the same design having the common testbench executable program applied to all levels of abstraction. The role of these monitors is to record a textual description of all transactions as they are played through the test channel. Because of the position of the test channel these monitors are independent of the sub component of the electronic system design description and will naturally produce traces that are comparable. The monitors obtain the comparable trace between the two or more simulations of the design which are at different levels of abstraction. The monitors may be connected to the invariant part of the transactor and are therefore recording comparable transactions. Note in an embodiment the correlation of behavioral descriptions of the sub components may be done as a postprocess based on trace files recorded by the monitors in contrast to a cycle accurate case described later in

The modeling tool may be used for correlating a behavior of one or more sub components of an electronic system design modeled as one or more executable behavioral models to one or more different levels of abstraction derived from a same design. The modeling tool may also be used for validating the behavior of the sub components with a same instance of a testbench executable program .

The testbench executable program defines the transaction data structure of an electronic system design produces one or more sequences of test patterns and expected test results and communicates the sequences of test patterns and expected test results at a first level of abstraction to the modeled sub components of the electronic system design at a second level of abstraction via a transactor . A transactor obtains each transaction from a channel of the transactional testbench interface and converts these transactions from a first level of abstraction to a second level of abstraction. The transactor may obtain and convert one or more transactions at a time.

The modeling tool may include a functional correlation module to establish a functional correlation between the different levels of abstraction of a first sub component having the common testbench executable program applied to all levels of abstraction of the sub component . The responses of the sub component s are read through the monitors and and sent to a correlation module which compares the results from the first abstraction level to the results at a second abstraction level.

The modeling tool may also include a timing module separate or coded within correlation module to generate correlation measurements of timing approximation between the different levels of abstraction of the sub components . A precise correlation may be generated by analyzing a specific location in the modeled sub components and comparing time differentials to get the same results at that location between the two different levels of abstraction.

To complete the validation it may be determined if the behavior of two or more descriptions match some consistency criteria. This may depend on the timing requirements of the descriptions. In order to validate that the behavior matches end to end checks may be performed. These are checks that involve the state of the transactions at the boundary of the system. For example a typical transaction may be a read operation. The response obtained for the request is critical transaction data observable at the boundary. Verifying that all the requests that were sent produced the same response with two or more descriptions is a key co validation measure.

This may be achieved with transactional monitors placed on each of the test channels. As discussed the monitors produce traces that are comparable. The remaining challenge to establish a functional match between two or more traces is protocol specific. For example it may involve finding matching transactions in a different order. This can be achieved by the addition of a unique identifier field to each transaction. The testbench executable program assigns a unique identifier to a first transaction generated as part of the stimulus from the testbench executable program . Using the unique identifier for the first transaction the system can match functional results between different levels of abstraction of the sub components of the electronic system design under verification . This may be done by matching a first transaction identifier from the first data set to a second transaction identifier from the second data set to find matching transactions. This identifier field will have to be supported by the protocol. For example with OCP the MReqlnfo and SRespinfo fields that may be attached to transactions are a natural choice.

The match will then involve a program reading two or more traces of the testbench traffic gathering them all by identifier and determining equivalence regardless of order and time. Then additional measures can be implemented such as the difference between the span end time minus start time of a transaction in each trace.

The behavior of one or more sub components of an electronic system design modeled as one or more executable behavioral models may be correlated to one or more different levels of abstraction derived from a same design. The correlating of the behavior of the sub components may include recording a first timing data derived from a first simulation of the sub components represented at a first abstraction level recording a second timing data derived from a second simulation of the sub components represented at a second abstraction level and then comparing the first timing data to the second timing data for one or more stimulus generated from the testbench executable program . End to end checks are verified concurrently with comparing timing results from the sub components of the electronic system design under verification at different levels of abstraction. The correlating may also include recording a first set of functional results derived from a first simulation of the sub components represented at a first abstraction level recording a second set of function results derived from a second simulation of the sub components represented at a second abstraction level and then comparing the first set of functional results to the second set of functional results when a stimulus from the testbench executable program is generated. The testbench executable program assigns a unique identifier to a first transaction generated as part of the stimulus from the testbench executable program . The unique identifier for the first transaction may be used to match functional results between different levels of abstraction of the sub components of the electronic system design under verification.

A first transaction from the testbench executable program is obtained and converted from a first level of abstraction to a second level of abstraction. A first data set containing a response at a first level of abstraction to a request sent by the testbench executable program is read from a first transaction monitor placed on a first test channel. A second data set containing a response at a second level of abstraction obtained for a request sent by the testbench executable program is read from a second transaction monitor placed on a second test channel. An equivalence of the responses found in the first data set and the second data set is determined for each level of abstraction of the sub components.

The behavior of the sub components with a same instance of a testbench executable program may be validated. The instance of the testbench executable program defines a transaction data structure of the electronic system design produces one or more sequences of test patterns and expected test results and communicates the sequences of test patterns and expected test results at a first level of abstraction to the modeled sub components of the electronic system design at a second level of abstraction via a transactional testbench interface.

In an embodiment the SystemC based modeling tool and unit testbench environment is used for the specific purpose of comparing cycle accuracy of two or more levels of abstraction. The sequence of test patterns and expected test results of the testbench executable program are applied to a sub component of the electronic system design under verification . The first level of abstraction may be the RTL level and the second level of abstraction may be TL1. The sequence of test patterns and expected test results are translated from the abstraction level of the testbench executable program and then applied at a signal level to the sub component of the electronic system design under verification . The RTL input and output signals are then derived to a correlation module where correlation to the reference phase accurate model TL1 can be established.

The correlation module operates at the level of the reference phase accurate abstracted model . Signal level inputs and outputs of the RTL unit description are converted to the level of abstraction of the reference model and connected to two channels and where abstracted traffic is compared by a correlation checker . The sole purpose of channel is to re create at an abstracted level the behavior of the RTL unit . Channel is used to stimulate and collect the behavior of the reference model .

The modeling tool may also include a standard configuration application programming interface API shown in coded in a derivative of C language to receive parameters of the modeled sub components . The parameters received may include describe characteristics such as burst capabilities data bus bit width configuration information that includes hierarchical sets of parameters that define the address map of the system the register map of the system arbitration priorities etc. A configurable circuit or system can have its behavior modified by a number of parameters. This set of parameters is hierarchical and complex in the case of many products. In order to enable reuse through the test and modeling efforts a consistent view of the configuration must be defined. This API is used in most abstracted descriptions of the sub component .

This justifies the need for a standard API describing the configuration of the system. The API may use a neutral language such as a pure C or C which are especially appealing because they can be used in various flows. A C description or C description would integrate seamlessly with a SystemC description and can also be used in most hardware description languages since they provide a C interface standard in Verilog .

In an embodiment an equivalence checker may read two or more data sets containing responses at one or more different levels of abstraction to requests sent by the testbench executable program . The equivalence checker may then determine an equivalence of the responses found in the two or more data sets for each level of abstraction of the sub components .

The data sets may constitute functional results derived from simulations of the sub components represented at two or more different abstraction levels. The system would then compare the first set of functional results to the second set of functional results when a stimulus from the testbench executable program is generated at a same level of abstraction. For example the functional results may be the particular behavior of the sub component to the applied stimulus such as whether an expected logic value occurs or an expected blocking of a signal occurs etc. The results may be derived from an electronic system design under verification represented at one or more levels of abstraction.

The data sets may constitute timing data such as a number of cycles actual time increments accurate time spans in the transaction flow etc. derived from a first simulation of the sub components represented at a first abstraction level. The system would then compare the first timing data to a second timing data when a stimulus from the testbench executable program is generated at a same level of abstraction. The system is able to directly compare the functional results and the timing data results because a monitor program reads values stored in the channel between the transactor and the interface port. The values stored in the channel are always at the same level of abstraction regardless of the level of abstraction of the sub component of the electronic system design under verification . In an embodiment the accurate time spans in the transaction flow may be described as the span latency between the first request and the first response of a transaction and the span between the first request and the last response of a transaction. The tool then establishes a figure of merit for the timing correlation based on the mean and deviation of these 2 statistics.

The system may also complete co validation by verifying end to end checks concurrently with comparing timing results from the sub components of the electronic system design under verification at different levels of abstraction. This may eliminate the need for an additional validation step of verifying end to end checks such as stimulus inputted into the electronic system to expected results from the electronic system design at each level of abstraction.

In an embodiment the end to end checks involve the testbench issuing a directed set of transactions to observe a particular response. The simplest case is a write transaction followed by a read transaction of the same length and at the same address to ensure the written data is returned by the read. A more complete approach involves the testbench maintaining an image of the system address space and recording every write into that image and matching every read response with the one expected by the image. The latter approach means the testbench needs full knowledge of the functional specification of the system under test which is typical and also justifies the testbench as a critical reuse component.

The modeling tool may be part of a computing system made up of a processor component to execute instructions from the testbench executable program that generate and apply a sequence of test patterns and expected test results to sub components of a design of an electronic system under verification at two or more levels of abstraction.

The modeling tool may be used for verifying highly configurable scalable System On a Chip sub components. In an embodiment an example modeling tool may include the following a graphic user interface a common set of processing elements and a library of files containing design elements such as circuits control logic and cell arrays. Traditionally there exist two major stages of SOC design front end processing and back end programming. Front end processing consists of the design and architecture stages which includes design of the SOC schematic. The front end processing may include connecting models configuration of the design simulating and tuning during the architectural exploration. The design is simulated and tested. Front end processing traditionally includes simulation of the circuits within the SOC and verification that they work correctly. The integration of the electronic circuit design may include packing the cores verifying the cores simulation and debugging. The tested and verified components then may be stored as part of a library. The modeling tool that can be used for verification and validation of an electronic system design as well as other applications.

Back end programming traditionally includes programming of the physical layout of the SOC such as placing and routing or floor planning of the circuit elements on the chip layout as well as the routing of all interconnects between components. Thus the floor plan may be generated imported and edited. After this the design may be outputted into a Netlist of one or more hardware design languages HDL such as Verilog VHDL Very High Speed Integrated Circuit Hardware Description Language or SPICE Simulation Program for Integrated Circuit Emphasis . A Netlist describes the connectivity of an electronic design such as the components included in the design the attributes of each component and the interconnectivity amongst the components. After the Netlist is generated synthesizing of the design with Register Transfer Level RTL may occur. Accordingly back end programming further includes the physical verification of the layout to verify that it is physically manufacturable and the resulting SOC will not have any function preventing physical defects. The front end views support documentation simulation debugging and testing. The back end files such as a layout physical Library Exchange Format LEF etc are for layout and fabrication.

In block the electronic system design as well as other embedded component designs parameters are supplied to the modeling tool. The modeling tool may include object code in a set of executable software programs in order to run actual operation and configuration simulations. The modeling tool will be used to validate the behavior at different levels of abstraction of a sub component of an electronic system design under verification.

In block the modeling tool may provide test data to validate verify and debug the designs by simulating and verifying the operation of each sub component of an electronic system design under verification at different levels of abstraction. The machine may also generate simulations of representations of the circuits described above that can be functionally tested timing tested debugged and validated.

The modeling tool may have its instructions executable code sequences data files etc stored on a machine readable storage medium. A machine readable storage medium may include any mechanism that provides e.g. stores and or transmits information in a form readable by a machine e.g. a computer . For example a machine readable medium may include but is not limited to read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices DVD s EPROMs EEPROMs FLASH magnetic or optical cards or any other type of media suitable for storing electronic instructions.

In block the circuit layout of a verified an IP block may be integrated with the entire integrated circuit. One or more lithographic masks may be generated from to be used for the manufacturing of a chip based upon that layout.

In block the chip verified with the modeling tool may be fabricated using CMOS process employing 1.0 um 0.35 um 0.25 um 0.13 um 90 nm etc. technologies.

Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussions it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

While some specific embodiments of the invention have been shown the invention is not to be limited to these embodiments. For example most functions performed by electronic hardware components may be duplicated by software emulation. Thus a software program written to accomplish those same functions may emulate the functionality of the hardware components. The hardware logic consists of electronic circuits that follow the rules of Boolean Logic software that contain patterns of instructions or any combination of both. The invention is to be understood as not limited by the specific embodiments described herein but only by scope of the appended claims.

