---

title: System and method for intercepting, instrumenting and characterizing usage of an application programming interface
abstract: A system and method for generically intercepting any type of application programming interface (API) events. The API event interception system includes an intercept library and an API. The application program calls the API to process the client event generated. The API receives the request for service from the application program and determines if intercepting of events is enabled. If intercepting is enabled, the API sends the event to the intercept library. The intercept library determines that the intercept library is enabled to support the event. If the intercept library is enabled to support the event, the intercept library invokes the required event program. If the intercept library is not enabled to support the event, the intercept library returns a message instructing the API to process the event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07921430&OS=07921430&RS=07921430
owner: Hewlett-Packard Development Company, L.P.
number: 07921430
owner_city: Houston
owner_country: US
publication_date: 20070117
---
This application is a continuation of copending U.S. utility application entitled System and Method for Intercepting Instrumenting and Characterizing Usage of an Application Programming Interface having Ser. No. 09 417 201 and filed Oct. 11 1999 which is entirely incorporated herein by reference.

The present invention generally relates to computers and software and more particularly to providing a flexible system and method for generically instrumenting and intercepting any type of application programming interface events.

As known in the art the intercepting of application program interface API events requires a large amount of tools specific instrumentation code or relies upon the behavior of shared library dynamic symbol binding. Generally the characterization code is contained in a shared library which replaces the actual shared library for which the characterization is needed. The characterization code is for showing the right information about events. In some cases this tools specific instrumentation code is kept inside the API shared library. This then requires the addition of another shared communication library to accomplish the communication between the API library and the collection tool.

One well known way to intercept events is to replace the target API library with an intercept library that looks to the system exactly like the original target API library. Thus when the application makes calls into the library the replacement library s entry point is called by the application rather than the target library. The replacement library can then log the call or do whatever it was designed to do find the target library load the appropriate entry point from the target library and call it.

A significant problem with this approach is that each revision of the library requires that the intercept library be kept up to date and also requires a new version.

Another significant problem is that the internal instrumentation code in the intercept library requires a significant amount of effort to maintain and is usually only useful for a single collection tool.

Still another significant problem is that the entry point for the replacement library and the target library must be carefully maintained because they must be identical.

Until now systems and methods for intercepting application programming interface events have lacked the ability to provide a flexible interface for intercepting all generic application programming interface events from any type of application programming interface.

The present invention provides a system and method for intercepting any application programming interface events generically. The system and method for intercepting any applications programming events generically provides cross platform capability greater flexibility higher performance lower maintenance and provides for easier creation and maintaining of the code for control tools.

Briefly described in architecture the system can be implemented as follows. An application program interface receives a request for service and generates at least one event to complete the request for service. An intercept logic for processing an event and a generic interception communication interface for transferring the event from the application program interface to the intercept logic if event intercepting is enabled

The present invention can also be viewed as providing a method for intercepting any application programming interface events generically. In this regard the method can be broadly summarized by the following steps generating an event by an application program interface transmitting the event to an intercept logic if event intercepting is enabled determining if the event is to be processed by the intercept logic and processing the event

Other features and advantages of the present invention will become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional features and advantages be included herein within the scope of the present invention.

The present invention will now be described in detail with specific reference to the drawings. While the invention will be described in connection with these drawings there is no intent to limit it to the embodiment or embodiments disclosed therein. On the contrary the intent is to cover all alternatives modifications and equivalents included within the spirit and scope of the invention as defined by the appended claims.

The present invention provides a system and method for a flexible interface for control tools and intercepting any application programming interface API calls. A major benefit of the present invention allows for multiple control tools to use the same interface and it does not place any restrictions on what form the API takes i.e. it can be shared library archived library application database etc. . These tools can be any kind of tool that can make use of intercept information. For example but not limited to a tool that will write out a source file of OpenGL commands. This way an arbitrary program can be run to capture some interesting behavior of that program to a source file. Then it is possible to compile and run the source file to duplicate the interesting behavior. Another example is a tool that analyzes OpenGL calling patterns for an application and looks for any known patterns that may be inefficient. Still another example is a tool that is similar to a debugger. The debugger tool intercepts all OpenGL calls and the user can get information about the call step over the call break on a specific call etc.

The present invention also provides a generic instrumentation and interception interface that allows any control tool to handle API events generically. This means that the control tool does not have to know about all of the API events in advance and hence a properly designed control tool does not need to be updated whenever the API adds a new entry point or other control event. The instrumentation of the present invention eliminates nearly all of the maintenance work for extra instrumentation code within the API.

The present invention provides these capabilities on any arbitrary operating system such as for example but not limited to Unix Windows HP UX Windows NT Mac OS and the like and also provides improved performance over the prior art methodologies.

Turning now to the drawings is a block diagram of just one system configuration that illustrates the flexibility expandability and platform independence of the present invention. While the system configuration could take many forms the diagram of illustrates a plurality of diverse workstations and directly connected to a network for example but not limited to a LAN . Additional workstations may similarly be remotely located and in communication with the network through a dial in or other connection . Each of the workstations in is uniquely illustrated to emphasize that client workstations may comprise a diverse hardware platform.

Additional workstations and may similarly be located and in communication with the remote server for access to data on the local server and the remote server . Workstations and communicate with the remote server on a LAN network . Networks and may be for example but not limited to Ethernet type networks also known as 10 BASE 2 10 BAS 5 10 BSAF 10 BAST BASE BAN network CO EX cable and the like.

Illustrated in is a block diagram illustrating an example of a prior art API having event interception situated within a computer readable medium for example in a computer system of a server system . Server systems today include APIs which are libraries that include a set of routines used by application programs to direct the performance of procedures and or subroutines required by the application program. This implementation requires that both the API and intercept library must be shared libraries.

An example of API library is OpenGL which is a software interface to graphics hardware. As known in the art Open GL s interface consists of about 120 distinct commands which a user could utilize to specify the objects and operations needed to produce an interactive 3 dimensional display. In this example API library routines are generally designed to be hardware independent interfaces that are implemented on many different hardware platforms.

Server systems today access and process these API library resources required by an application program by using the processor storage device and memory with an operating system and window manager . The processor accepts data from memory and storage over the bus . Directions from the user can be signaled to the server system by using the input devices such as but not limited to a mouse and keyboard . The actions input and result output are displayed on a display device such as but not limited to terminal .

Illustrated in is a block diagram illustrating an example of a prior art collection tools situated within a computer readable medium for example in a client computer system . Collection tools are located in memory of a client computer system.

The collection tool is a tool that collects interception data for later use. For example but not limited to the prior example of a tool that creates source code from a sequence of intercepted OpenGL calls. The collection tool runs in connection with its intercept library. The collection tool simply collects intercept data and saves it in a compact format to a file. Then another tool is run that converts this compact file into source code. The reason for this is that it is much faster to just save the data to a compact file than it is to re interpret it as source code and write out the source code file. Since the intercept collection process happens while the target application is running the interpretation and conversion to source code is done in real time. This same concept is useful for many kinds of analysis tasks where one wants to capture some data then spend time analyzing the data later when performance is not so important.

The architecture of the client computer system is similar to the servers and . The principal difference between the servers and and the clients and is that the client systems interface to the user and request the functionality through the network or . Servers and generally provide the services requested by the client systems utilizing the application program the intercept library and API library .

Otherwise the functionality of processor storage mouse keyboard display and modem are essentially the same as corresponding items of described above. As known in the art the client systems and and server systems and may reside on the same physical machine.

Illustrated in is a block diagram illustrating a prior art process interaction for requests for service events issued by an application program API library intercept library and the collection tool . These events are intercepted by the intercept library for reporting to the collection tool as shown in . As can be seen the application program generates events which are then transmitted to the intercept library .

The intercept library receives the events i.e. requests for service from the application program and attempts to find the required event routine for responding to the event generated by the application program . The intercept library also determines if the event generated by application program is event transaction to be addressed by the collection tool . If the event generated by application program is an event to be addressed by the collection tool the intercept library transmits a copy of the event to collection tool for processing.

The intercept library then transmits the event to the API library for processing the event generated. The API library processes the event generated and returns the required output to the intercept library which in turn returns the required output to the application program . The API library in this diagram is simply a repository of code that is called by the intercept library .

One of the disadvantages with this architecture is that the intercept library must look exactly like the API library . This is because the intercept library completely replaces the API library from the application program perspective. So the application program never communicates with the API library . Only the intercept library communicates with the API library . This is why the intercept library must look exactly like the API library and why this configuration has the versioning problem. If any mismatches occur between the intercept library and the API library the event generated by the application program will not be handled correctly and could cause an operation error.

Another disadvantage of this approach is that it relies on the behavior of shared libraries for its implementation. This approach relies on the fact that shared library entry points are bound to the application at run time by the OS and that by physically replacing the shared library with one that looks identical the OS will cause the entry points in the replacement library to be bound instead. Therefore this approach can only be used to intercept an API library that is contained in a shared library and can t be used at all on an operating system that doesn t support shared libraries i.e. MS DOS CPM Windows CE etc . . . .

Illustrated in is a block diagram illustrating the prior art process interaction between an application program interface library and events issued by an application program . When interception is enabled the events issued by an application program are decomposed into intercept events managed and communicated by the intercept module wholly contained within the application programming interface library . In this case the event data is sent directly from the intercept module to the collection tool .

As shown the application program generates events and places a call to the API library . The API library determines if interception is enabled. If interception is not enabled the API library processes the event and returns any event output. If interception is enabled the API library calls the intercept module with the appropriate event information. The intercept module receives the request from API library and establishes a communication link with the collection tool . The intercept tool sends the event to the collection tool for processing. The intercept tool then waits for a reply from the collection tool regarding the event sent. Collection tool then either processes the event or returns a message requesting normal API library event processing. If the intercept tool receives a message requesting normal API event processing the intercept tool performs the required API event processing. The intercept tool then returns the required event output to be API library and waits to receive the next request.

The disadvantage to this architecture is that every intercepted event i.e. API call is sent by the intercept tool over a communication link to the collection tool . Then the intercept tool has to wait for the collection tool to respond again over a communication link so that it knows how to proceed i.e. whether to call the real entry point etc . . . . This process is horribly inefficient and slows down the intercepted process tremendously. Also this architecture doesn t solve the version synchronization problem i.e. the collection tool has to be the same version as the intercept module which has to be the same version as the API library .

Illustrated in is a block diagram illustrating an API event interception system of the present invention situated within a computer readable medium for example in a computer system. As shown the API event interception system of the present invention includes an API generic interception communication interface and intercept library . The application program API generic interception communication interface and intercept library all reside in memory of the a server system or as herein previously defined with regard to .

Illustrated in is a block diagram illustrating control tool process situated within a computer readable medium for example in a computer system. As shown the control tool resides in memory of client system as previously defined with regard to the collection tool . The control tool provides a user interface with which the user controls the actions of the intercept library i.e. whether the intercept library should intercept specific events what it should do with the events it does capture etc.

Illustrated in is a block diagram illustrating a process interaction between application program application program interface generic interception communication interface and the control tools of the present invention. The intercept library of the present invention intercepts these events for processing under the direction of the control tools as shown in . The control tools can be any kind of tool that can make use of intercept information.

Upon start up of application program and prior to receiving a client event the API performs the initialization process. The API initializes the intercept event send handlers in the generic interception communication interface . The API also searches for the intercept library . If the intercept library is found the API sends an initialization event to the intercept library . The intercept library initialization includes registering events of interest and event receiving handlers and then establishing communication with control tool .

As shown the application program processes data and creates client events for service. The application program calls the API to process the client event generated. The API receives the request for service from the application program . The API then determines if the intercept library is enabled to handle events. If the API determines that the intercept library is not enabled to support the event the API processes the event and returns the event output to the application program .

If the API determines that the intercept library is enabled to support the event the API calls the intercept library through the generic interception communication interface to allow the intercept library to process or handle the event. API waits for a reply from the intercept library . If the intercept library returns that it was able to process the event the API waits to receive the next request for service of the application program . If the intercept library was not able to process the event the API processes the event and returns the event output to the application program .

The intercept library receives the request for service event from the API . The intercept library contains code to handle or process a number of events. The intercept library then determines if processing of the received event is required. If event processing is required the intercept library invokes the required event program to process the event. The intercept library returns any output to the API for further transmission to the application program . If the intercept library is not required to process the event the intercept library sends a reply to API that the event was not processed.

It is important to note that in the present invention the events are captured and processed by the intercept library and only controlling information need be sent over a communication link between the control tools which by necessity is running in a different process and the intercept library . Communication between processes is inherently very slow. But communication between code fragments in the same process i.e. between the intercept library and the API is very fast. It s very important to understand that in the present invention the control tools do not process the individual events. Rather the intercept library which resides in the same process as the application and API will process each event according to the control information it receives from the control tools

Illustrated in is a flow chart of an example of the application process as shown in A C . First the application program is initialized at step . The application program then loads and initializes the API at step .

Next the application program begins normal execution and makes calls to the API to handle events at step . The application program then checks whether the normal execution of the application program is done at step . If the application program is not done the application program returns to step to continue execution of the application program and to call an API to continue to handle events at step .

If the application program is done the application program calls the application program interface for client cleanup at step . The application program then exits at step .

Illustrated in is a flow chart of an example of the process for the API of the present invention as shown in . First the API is initialized at step . Then the API determines if an appropriate intercept library exists at step . If the appropriate intercept library does not exist the API skips to step .

If the appropriate intercept library exists the API loads the appropriate intercept library calls the API intercept initialization routine and the intercept library initialization routine at step . The API intercept initialization routine includes be initialization of the intercept event send handlers in the generic interception communication interface herein previously defined with regard to . The intercept library initialization routine includes registering events of interest and event receiving handlers and then establishing communication with control tool herein previously defined with regard to .

At step the application program interface starts normal execution. If the API is performing interception then the API sends resulting intercept events to the intercept library event handlers in the generic interception communication interface . The generic interception communication interface sends resulting intercept events to the intercept library to handle events at step . Routinely the API checks to see if the application program execution is done at step . If application program is not done the API returns to step for continued execution. If the application program is done then the API performs the client clean up process at step and if intercepting calls the intercept library clean up routine at step . The API then exits at step .

Illustrated in is a flow chart of an example of the intercept library of the present invention as shown in . First the intercept library is initialized at step . The intercept library registers the events at interest and the event handlers for the events of interest at step . At step the intercept library establishes a communication link with the control tools .

The intercept library begins normal processing and waits to receive the event from the API through the appropriate event handler at step . Upon receiving an event from the API the intercept library processes the event data. At step the intercept library determines if the intercept library is to perform API type processing. If the intercept library determines that API type processing of the event is not enabled for the intercept library the intercept library returns a reply to the API that the event was not handled.

If the intercept library determines that API type processing of the event is enabled the intercept library performs API type processing of the event at step . At step the intercept library returns the event output and a reply to the API at the event was handled.

Next the intercept library checks for a done status at step and returns to continue processing events at steps if not done. If the intercept library determines that the done status is true the intercept library performs the intercept library cleanup at step . The intercept library exits at step .

The API event interception system comprises an ordered listing of executable instructions for implementing logical functions can be embodied in any computer readable medium for use by or in connection with an instruction execution system apparatus or device such as a computer based system processor containing system or other system that can fetch the instructions from the instruction execution system apparatus or device and execute the instructions. In the context of this document a computer readable medium can be any means that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable medium can be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a nonexhaustive list of the computer readable medium would include the following an electrical connection electronic having one or more wires a portable computer diskette magnetic a random access memory RAM magnetic a read only memory ROM magnetic an erasable programmable read only memory EPROM or Flash memory magnetic an optical fiber optical and a portable compact disc read only memory CDROM optical .

Note that the computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory.

The block diagrams and flow charts of show the architecture functionality and operation of a possible implementation of the API event interception system software . In this regard each block represents a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the blocks may occur out of the order noted in the figure. For example blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved.

The foregoing description has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obvious modifications or variations are possible in light of the above teachings. The embodiment or embodiments discussed were chosen and described to provide the best illustration of the principles of the invention and its practical application to thereby enable one of ordinary skill in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. All such modifications and variations are within the scope of the invention as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly and legally entitled.

