---

title: Mapping schemas using a naming rule
abstract: Among other disclosed subject matter, a computer-implemented method for creating a mapping includes obtaining a definition relating to a first schema, the definition comprising a first plurality of nodes to be mapped to a second schema comprising a second plurality of nodes. The method includes receiving at least one context value for the received definition, the context value being associated with at least one context category defined for the second schema. The method includes generating names corresponding to each of the nodes in the first plurality, the generated names being consistent with a naming rule for the second schema. The method includes mapping each of the nodes in the first plurality to a respective one of the nodes in the second plurality, wherein the context value and at least one of the generated names are taken into account in the mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08041746&OS=08041746&RS=08041746
owner: SAP AG
number: 08041746
owner_city: Walldorf
owner_country: DE
publication_date: 20071030
---
The material on the accompanying compact discs is hereby incorporated by reference into this application. The accompanying compact discs contain one file Computer Program Listing which was created on Sep. 9 2011. The file named Computer Program Listing is 140 kb. The file can be accessed using Microsoft Word on a computer that uses Windows OS.

Many aspects of electronic communication and in particular electronic commerce is based on business documents that parties can exchange over a computer connection. A big problem in current e Business is the variety in structure and description of business information and business documents. The absence of uniform and standardized methods for the common representation of the structure and semantics of business data has led to today s situation where there is an increasing growth of different representations of electronic business information and documents. It may not be possible to exchange business documents electronically between two business partners without previous coordination and manual mapping between different document structures and semantics. A world wide accepted syntax for representation exists with extensible markup language XML but this does not solve the problem of non uniform semantics and structure.

Some business documents are based on reusable building blocks that define the semantics of the document data. An example of a standard that defines such building blocks is the electronic business XML ebXML Core Components Technical Specification issued by the United Nations Centre for Trade Facilitation and Electronic Business. This specification is also known as the ISO 15000 5 standard and is hereafter referred to as CCTS. The CCTS is the first standard which combines all necessary aspects for human legibility and automatic machine processing so that an integrated interoperability can be guaranteed. The CCTS based building blocks are syntax free and very flexible because they are based on a modular concept. Business information can be assembled for all demands by reusable building blocks. Syntax free means that these building blocks called Core Components or CCs and Business Information Entities or BIEs represents only the business semantic meaning and can be generated in arbitrary representations like XML ABAP Objects or Java classes. However the semantics described by the CCs in accordance with the CCTS do not change. This guarantees one general naming convention for the unambiguous composition of semantic information. A number of conventions within the CCTS e.g. a naming convention guarantee that the semantic information in each CC is unambiguous. This mechanism is comparable with the grammar and words of a naturally spoken language because a naturally spoken language can also be represented in many different ways by writing or by speech and the semantics are always the same.

Sometimes two enterprises that wish to transact electronic business use communication schemas that are incompatible with one another for e.g. a CIDX Purchase Order and a RosettaNet Purchase Order . If a system generates an electronic document using a first communication schema and sends the document directly to another system that uses a different communication schema the other system is unable to interpret the electronic document because it lacks information for mapping business data elements between different schemas. The other system may therefore use a translation infrastructure to translate electronic documents from the first communication schema format to an intermediary communication schema format and then from the intermediary communication schema format to the second communication schema format. The translation between the schemas must be made manually and because of the complexity of the schemas not all entities will be translated. This can lead to loss of knowledge.

While the use of an ordinary intermediary schema formats is common it may however have some disadvantages. Particularly from time to time there is a need to integrate a new schema into the system. This tends to result in more and more extensions of the intermediary format. Solutions such as XML schema specific extensions may not be particularly helpful to the extent they consider a kind of extension in only one dimension. Especially extensions that consider some similar and slightly different parts must be structurally separated. Therefore the so called one dimension extension may not be helpful for consolidating parts that are semantically the same. That is due to structural and semantical mismatches in the different sources the intermediary format is typically extended for the new format and as a result the intermediary schema continually grows and becomes more fragmented. In the end such a situation may not offer any real advantage over creating direct mappings between the different sources.

In a first aspect a computer implemented method for creating a mapping includes obtaining a definition relating to a first schema the definition comprising a first plurality of nodes to be mapped to a second schema comprising a second plurality of nodes. The method includes receiving at least one context value for the received definition the context value being associated with at least one context category defined for the second schema. The method includes generating names corresponding to each of the nodes in the first plurality the generated names being consistent with a naming rule for the second schema. The method includes mapping each of the nodes in the first plurality to a respective one of the nodes in the second plurality wherein the context value and at least one of the generated names are taken into account in the mapping.

Implementations can include any all or none of the following features. The received definition can be at least one of the first schema and a mapping between the first schema and a third schema. A user can enter the at least context value to be associated with the definition. The generation of each of the names can include receiving a definition of a data element for which a unique name is to be created that complies with a predefined name format the definition comprising human understandable descriptive language the data element identifying an information category in an electronic communication identifying a noun phrase and a verb phrase in the definition and generating the name using a first noun obtained from the noun phrase and a second noun obtained from the verb phrase. Identifying the noun phrase and the verb phrase can include generating a hierarchical tree for the definition. The predefined name format can require the unique name to comprise at least a first term for an object class to which the data element relates and the second noun can be used as the first term. The predefined name format can require the unique name to comprise also a second term for a property of the object class and another noun associated with the verb phrase can be used as the second term. The predefined name format can require the unique name to comprise also a third term for a representation form of the data element and the first noun can be used as the third term. The method can further include combining the context value the generated names and also additional information obtained from the definition in a data structure and using the data structure in the mapping. The mapping can include an iterative process. The iterative process can include multiple matcher units each matching unit corresponding to a matching based on at least one aspect relating to the definition including a context value matcher using the at least one context value and a name matcher using the generated names. In the iterative process there can be determined for each node in the definition a probability for the node to be mapped to each of the nodes in the second plurality. Each of the nodes in the first plurality can be mapped by associating it with one of the nodes in the second plurality based on at least some of the determined probabilities. There can be a weighting of the matchers so that at least one of the matchers is weighted compared to remaining matchers. The method can further include determining that there are ambiguous mappings between the first schema and the second schema in response to the determination revising the weighting by changing the weight of at least one of the matchers relative to remaining matchers and performing the iterative procedure using the revised weighting. The method can further include presenting the mapping to a user as a suggestion which the user can at least accept or reject. The user can accept the suggestion and the method can further include adding the at least one context value to the node in the second plurality. Obtaining the definition relating to the first schema can include obtaining a definition of an initial schema that does not comply with a standard for the second schema and transforming the received initial schema into the first schema the transformation providing that the first schema complies with the standard for the second schema. The standard can be CCTS and the transformation can provide the first schema with a CCTS based notation. The transformation can associate the first schema with a primary construct that includes at least a complex type entity and a global declared element. The transformation can associate the first schema with a documentation schema that includes at least a definition of a message that is embodied in the initial schema. The transformation can associate the first schema with a business context schema configured to specify a context in any of a plurality of predefined context categories. The transformation can associate the first schema with a source schema artifact that includes at least a syntax element with information of a specific syntax.

In a second general aspect a computer program product is tangibly embodied in a computer readable storage medium and includes instructions that when executed by a processor perform a method for creating a mapping. The method includes obtaining a definition relating to a first schema the definition comprising a first plurality of nodes to be mapped to a second schema comprising a second plurality of nodes. The method includes receiving at least one context value for the received definition the context value being associated with at least one context category defined for the second schema. The method includes generating names corresponding to each of the nodes in the first plurality the generated names being consistent with a naming rule for the second schema. The method includes mapping each of the nodes in the first plurality to a respective one of the nodes in the second plurality wherein the context value and at least one of the generated names are taken into account in the mapping.

In a third general aspect a computer program product is tangibly embodied in a computer readable storage medium and includes instructions that when executed generate on a display device a graphical user interface for creating a mapping. The graphical user interface includes a first input area for making a first user entry identifying a definition relating to a first schema the definition comprising a first plurality of nodes to be mapped to a second schema comprising a second plurality of nodes. The graphical user interface includes a second input area for making a second user entry identifying at least one context value for the definition the context value being associated with at least one context category defined for the second schema. Names corresponding to each of the nodes in the first plurality are generated after receipt of the first user entry the generated names being consistent with a naming rule for the second schema and a mapping of each of the nodes in the first plurality to a respective one of the nodes in the second plurality is generated after receipt of the second user entry the context value and at least one of the generated names being taken into account in the mapping.

Advantages of implementations can include any all or none of the following providing an improved creation of a semi automatic mechanism of mapping between two schemas providing a context dependent procedure for relating schemas with each other providing an automated approach to matching with increased sensitivity and flexibility providing improved specification of mappings between semantically appropriate entities provide improved reusability by reusing semantically correct entities reducing modification within types providing an automatic evolutionary generation of appropriate entities in an intermediary schema during mapping of external schemas providing an evolutionary and semi automatic knowledge enrichment and providing a hybrid matcher with better time performance.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

Particularly the system may be provided with one intermediary schema that is not identical to either of the first and second schemas . The intermediary schema may be based on the conventions of UN CEFACT XML Naming and Design Rules for CCTS or could be represented in other technical formats while being based on CCTS conventions e.g. F Logic representation relational database scheme SQL etc. . Moreover there can be created a first mapping from the first schema to the intermediary schema . To the extent possible the first mapping maps portions of the first schema to corresponding portions of the intermediary schema . Each portion describes an entity of a semantic meaning that belongs together. A second mapping can then be used to map the translated portions from the intermediary schema to the second schema . While single first and second schemas are shown here for simplicity other configurations are possible. Particularly there can be more than one first schema and or more than one second schema. For example an n m mapping and conversion can be used where n is the number of schemas being mapped from and m is the number of schemas mapped to such as with an CCTS based intermediate format.

In some examples the system can use one or more matching procedures to create a mapping from the first schema to the second schema . The matching procedures may be processed by a hybrid matcher and or a combined matcher. For example the hybrid matcher creates the mappings using one or more match criteria or information sources. In some embodiments the hybrid matcher can create the mappings by considering the criteria in a particular order according to specific heuristics. For example the system may be mapping a data type element of the first scheme . A hybrid matcher may check the similarity of the data type element of the first schema to a plurality of data type elements of the intermediary schema in a specific order. In one example the hybrid matcher may have a specific order in applying several matcher components. In one example the system may first use a data type matcher for matching the data types between the first schema and the intermediary schema . Later the system may use a name matcher for checking similarity of the data type names between the first schema and the intermediary schema . The heuristics may be predefined in the hybrid matcher. This can provide better time performance compared to separate execution of multiple matchers by reducing the number of passes to be performed over the input schema s . As another example the hybrid matcher can effectively and promptly identify poor match candidates by qualifying the match candidates using more than one matching criteria.

The combined matchers can use multiple matchers which can be either hybrid matchers combined matchers or both to name a few examples. The combined matchers can be used to estimate element similarity between schemas. The approach for combining the results of constituent matchers in a combined matcher can follow the same or similar principles as used for combining matcher results in a final phase of a match iteration. Examples of matchers and matching approaches include but are not limited to 

In one embodiment the intermediate schema may use dictionary entry names DENs defined by the standard UN CEFACT CCTS. For example the system may obtain a definition related to the first schema and generate a DEN for the obtained definition via the first mapping . Using the generated DEN the system can use the second mapping to map the DEN to the second schema .

It is possible however that one or more portions of the first schema cannot be mapped to the intermediary schema by the different matchers of the hybrid mapping approach. The first schema may include a portion that has no corresponding portion in the intermediary schema . For example the intermediary schema may lack a building block corresponding to a buyer s agent . In such and other situations an approach that is followed can run essentially as follows 

1. The system can first categorize the portions of the first scheme with their respective context values according to predefined context categories.

3. The system can then attempt to match the portions of the first scheme with the intermediary scheme by using the hybrid matching approach. The system can consider the information of portions of other schemas that are already mapped to the appropriate portions of the intermediary schema by using the same hybrid matching approach. An example of this is the appropriate portion of the second schema if this schema is already mapped with the intermediary schema . This can increase the quality of matching because the additional comparison with the already mapped schemes can increase the precision at a semantic and context specific level.

5. For any of the portions that cannot be mapped the system can generate a new entry at the appropriate position of the intermediary scheme according the rules that apply to the intermediary format such as CCTS. The DEN for the new entry can be the already generated DEN for the first scheme .

6. The system can also place the appropriate portion of the first schema beneath the newly generated entry in the intermediary scheme .

In some embodiments the system generates a new entry corresponding to the lacking building block at the appropriate position of the intermediary schema according the rules of CCTS. For example the new entry may have a DEN that is the generated DEN for the first scheme . In some examples the system can insert the appropriate portion of first scheme beneath the new entry in the intermediary scheme . The system can suggest the new DEN to the user. If the user accepts the suggestion the system can then map the first schema to the intermediary schema using the new entry.

In some embodiments the system can use context values in creating the mappings for example as follows. For example the term bank may be ambiguous unless the precise context where it will be used is known. The system may therefore identify at least one context category defined for the first schema and the second schema in generating the mapping and the mapping respectively. In some examples the system can use the at least one context category of the first and second schemas to reduce computation time and complexity for generating the mappings respectively.

In operation the system can generate the mappings to map portions between the first schema and the second schema using one or more appropriate portions of the intermediary schema . In some embodiments the system can use the mappings to automatically generate conversion rules. Such rules can be used at runtime for converting incoming instances in one schema into outgoing instance of another schema. For example the system can use the conversion rules at runtime to convert instances in the first schema into an instance in the second schema . In so doing directions can be considered separately. For example in six conversion rules can be identified and or generated 

Such conversion rules can convert instances that are based on the first schema the second schema and also the intermediary schema at runtime. In other implementations other conversion rules can be used.

Particularly the first schema repository can store the first schema and uses it in creating and interpreting business documents. In particular the first computer organizes the data entered by the user according to a communication schema format and can then transmit the document over the network to a receiving entity such as the second computer . The second computer is capable of interpreting received electronic documents in accordance with the metadata stored in the second schema repository . Particularly the second schema repository can store the second schema and uses it in creating and interpreting business documents.

An intermediary computer is connected to the network and includes a translation infrastructure for translating the electronic document from the first schema format to the second schema format. The intermediary computer includes a storage device containing an intermediary schema repository . The intermediary schema repository can include the first mapping and the second mapping to name just two examples. Accordingly the intermediary computer can translate the document using the mapping over the intermediary schema. For example the translation infrastructure can include the Exchange Infrastructure available from SAP AG of Walldorf Baden Germany. In some examples the translation infrastructure can include naming rules defined for generating DENs.

A storage device may contain a statistics database that is used in collecting various data regarding the operation of the intermediary computer or the translation infrastructure . Particularly the data obtained in monitoring use of the direct mapping may be deposited in the storage device . Regularly or from time to time the intermediary computer can analyze the database and determine whether the use meets the predefined criterion. The predefined criterion may correspond to how many times the direct mapping has been used or how frequently it has been used to name two examples. The same criteria may be used for several direct mappings. Further examples of mappings are described in pending patent application Ser. No. 11 088 158 entitled Translation of Information Between Schemas the contents of which are incorporated herein by reference.

The mappings used in the translation may be created using one or more matching procedures. shows a matcher module that can perform such a procedure. For example the matcher module can be included in the intermediary computer . The matcher module includes a matching engine that performs the procedure s and a knowledge base that holds relevant information. The matching engine includes execution logic and a matcher library . The knowledge base includes a building block repository that includes the building blocks that make up the intermediary schema. For example when the intermediary schema is CCTS based the building block repository includes building blocks defined by CCTS. The knowledge base also includes a mapping repository in which can be stored one or more mappings between a schema and an intermediary schema.

1. Defining and assigning the context s in which this schema and its entities are valid. For example the context values may indicate a primary usage of the first schema e.g. Industry High Tech Business Process Purchasing Geopolitical Global . This can be considered a contextualization and can be done by the user before a matching and normalization into CCTS format. A contextualization can provide a higher precision for subsequent processes. For example semantic aspects can be ambiguous and can limit DEN naming and matching results. Examples relating to context value assignment are described below with regard to .

2. Transforming entities of a schema into a CCTS based schema. For example the imported schema can be transformed to include DENs representation of the nodes in the first schema . CCTS normalization can improve the mapping results and if an appropriate entity in the intermediary scheme does not exist the specific entity of the external schema can be directly integrated into the intermediary schema as a new node with a new semantics. Examples relating to transforming schema entities into the CCTS convention are described below with reference to .

Returning now to the matching procedure includes an imported schema that is related to the first schema . The matching module is used to apply one or more matching procedures to the first schema as indicated by respective matcher components labeled Matcher Matcher . . . Matcher n. The input to the procedure in this example is the schema and in other implementations can be another definition that relates to a schema such as a mapping between two or more schemas to name just one example.

In another example the imported schema may include nodes of the first schema transformed into CCTS conventions. By transforming the entities of the first schema into CCTS conventions the procedure may generate more accurate results. Additionally if an appropriate entity in the intermediary schema corresponding to a specific entity of the first schema does not exist the specific entity can be directly integrated into the intermediary schema as a new node with a new semantics because the specific entity is already transformed into CCTS conventions. Some examples of generating dictionary entry names DENs of entities of the first schema are described with reference to . As shown in this example the matcher components include a DEN matcher and a context value matcher . The procedure includes execution of the DEN matcher to match for the DENs of each of the nodes in the imported schema and DENs of some or all of the nodes in the intermediary schema such as by comparing with the DENs of the target nodes.

The context value matcher matches the context value of each node of the imported schema with the context value of a node of the intermediate schema. The context value matcher compares the context values of the nodes of the imported schema with the context values of the nodes in the intermediary schema. Based on the comparison result the context value matcher can assign probability values to the matching candidates. For example the context value matcher can assign a higher probability value to a matching candidate that has a similar set of context values as the set of context values assigned to the imported schema . The probability values can be combined later in the procedure to generate a score for ranking the match candidates. If the result is sufficiently unambiguous according to a predefined criterion the final mapping to the appropriate node can be created.

The matching procedure may be analogized to a toolbox where different tools matching procedures are sequentially applied to the schema to find a suitable match within the intermediary schema. The procedure may use the DEN matcher the context value matcher and possibly one or more conventional and adaptive heuristic matching procedures in creating the mapping s . For example the procedure may also use the hybrid matchers and the combine matchers. More simple matching procedures involve the use of a synonym library to compare leaf names in the first schema and the intermediary schema or a node by node comparison of tree structures in the respective schemas. The procedure may analyze the type of the schema component that is to be mapped. Matching procedures may use a hybrid approach that also considers a set of criteria in a particular order according to some specific heuristics. The results of the matching procedure s may consist of probabilities associated with possible candidate building blocks in the intermediary schema.

Each matching algorithm can calculate a probability that any element X of the source schema maps to an element Y of the intermediary schema. In one example the DEN matcher may assign a high probability to an element Y of the intermediary schema to match an element X in the source schema if the DEN of the element Y matches the DEN of the element X. In another example the context value matcher can assign a higher probability to the element Y to match the element X if the element Y has the same context value as the element X. For example the matcher components may identify two results to translate the term bank . The first result may have a context value indicating that it is used in the financial industry and the second result may have a context value indicating that it is used in the gardening industry. Depending on the context value of the source schema the context value matcher can adjust the probability of the two results. Suppose the source schema has a context value of a gardening industry then the context value matcher may assign a higher probability to the second result.

In some implementations the context matcher may determine a probability value for each of the matching candidates based on a set of context logic. For example the context matcher may include a context logic processor to analyze the context values of the matching candidates and the input schema. The context logic processor may determine that the matching candidate having similar context values as the input schema may be assigned a higher probability. In some embodiments the context categories can have different weights for calculation of matching probabilities. For example the context category industry IN may have a higher weight than the context category business process Bu .

Suppose there are three matching candidates from the intermediary schema. For example a first node that is a matching candidate includes the context

where IN represents invoice processing. Finally in this example a third node that is a matching candidates includes the context

where AU represents the automotive industry. Based on weights of the context categories the context matcher may assign the highest probability to the second matching candidate because the wildcard character in node relates to a bigger set than a single value and the category In has a higher weight than the category Bu.

In another example if context values do not match but DEN correspondence is high the matching procedure can recommend that the existing schema be extended for the new context value s . If n number of matching algorithms are available and if the source schema has s number of elements and the intermediary schema has i number of elements a total of n s i probability values will be calculated. The probability values from each of the matching components may be represented as a similarity cube having edges that correspond respectively to n s and i values. The n probability values created by the n matchers of the element X corresponding to the element Y can then be combined into a final probability value using weights. A threshold value may be used to determine if the resulting probability for the mapping is sufficiently high. The results are combined into a matching result at a combination stage . The matching result may include a S1 BB mapping corresponding to the mapping from the first schema to the building blocks in the intermediary schema. Similarly the result may include a BB S1 mapping corresponding to the reverse mapping from the intermediary building block s to the first schema. The latter mapping can be used in translations to the first schema from other schemas including the second schema.

Various combination strategies can be used to combine the probability values generated by each of the matcher components . In one example the combination stage may include a weighting function to combine the results from the matchers . For example the combination stage may combine the probability values using a linear combination of the weights and the probability values. The procedure can assign different weights to the matcher components . In one embodiment the DEN matcher may have the highest weight and the context value matcher may have the second highest weight. Examples of weights of the meta model information and association to the matcher components are listed in the following table 

Table 1 shows that a matching of the matcher component controllingAgency has a weight value of 4 whereas the context matcher component has a weight value of 65536 to name two examples. Table 1 also shows that each matcher component which can be an attribute of the meta model can be associated with a respective matcher that operates according to a particular matching approach. For example the matcher component controllingAgency is associated with the Name Matching matcher and the context matcher component is associated with the Context Matching component. Using the listed weight s the aspects covered by the respective matchers listed in Table 1 will be given relatively high or low significance in determining the mapping.

We define A . . . Aas the content of n filter data structure attributes FilterDSA . The FilterDSA can be used to do a filtered matching which can improve performance. Consider that it may make little or no sense to compare an entity of the first schema with all entities of the intermediary schema . For this and or other reasons one or more aspects including but not limited to context type of standard kind of entity such as leaf elements associations or types level of hierarchies etc. can be used to set or create a filter here implemented by the FilterDSA. This means the system can match with the entities that are filtered. In some implementations the filter could be the context such as industry Manufacturing . In such a situation the system will do a match with the entities that are associated with the context industry Manufacturing . If no sufficient unambiguous result is obtained the system can revise the filter by taking out one or more filter attributes and can perform a next iteration of matching. This procedure can be repeated until the result is either unambiguous or only an ambiguous or non matchable result remains after all filter attributes have been removed.

We define a . . . aas the content of the n attributes of the typeElement e.g. a node to be tested for which the test entity T is to be calculated.

The selection of the proper typeElements according to a FilterDSA can then be performed in three steps 

A first step can include comparing every Awith the corresponding a and for each one that satisfies the test assign the predetermined number of points e.g. the weight numbers listed in Table 1 above . The assigned points form a partial test value t that reflects the result of comparing two attributes.

A second step can include calculating the actual test entity T using the partial test values t . . . t. The test entity specifies how many points the typeElement has totally received in the comparison of attributes.

In a third and in this example last step only the maximum Tof all test entities T for a single typeElement is forwarded. All of the typeElements that have lower values than T or whose value falls below a required minimum value Tcan be discarded or rejected.

Two attribute values A and a can be considered compatible with each other symbolized by A a when the relation

A a and there exists a context within which the attribute values can be said to be semantically similar. Consider the examples INOUT IN and IN INOUT 

respectively. In the former example there is sought typeElements defined for both the incoming and the outgoing directions hence the term INOUT . A typeElement that is defined for the incoming direction represented by the term IN can then be considered relevant.

In the latter example there is sought typeElements defined for the incoming direction hence the term IN . A typeElement defined for both directions represented by the term INOUT can then be considered relevant.

The following are notes on determining the partial test entities t. The value 1 is assigned when the corresponding attribute in the typeElement is set and also is not the empty string and when the attribute from the FilterDSA is compatible with the typeElement. However if the attribute in the typeElement not set or if it is the empty string then no statement can be made. A neutral value of zero can then be assigned. On the other hand when the typeElement is set and also is not the empty string and not compatible with the attribute from the FilterDSA then the typeElement s will not be available for selection. This can be recorded using a value of 1.

That is the result T equals zero if any of the matcher generates a matching value of 1. Otherwise T equals to the sum of each of the generated matching value multiplied by the weight of the matcher. The weights are expressed here as 2 where i is the rank of the matcher. The weights of individual attributes can be any or all of those described with reference to Table 1 above for example.

Each entity of standard that is to be matched can be compared with a CCTS based entity. Some different matchers e.g. those listed in Table 1 for the comparison and the following result can be calculated.

Using the above formula the product of all matching calculations gives the matching result. However the matching result will be automatically 0 if one of the matching entries has 1 according to the above formula.

P i here represents the weights. For example the input is a received node in the procedure and the four results are candidates for mapping the input into the intermediate schema identified by the matcher components . Here the input has a standard of EDIFACT a version of D and a geopolitical context value of USA and a DEN of Buyer. Address . Depending on the attributes of the matching results the matcher components assign different weights to the results. If a matcher determines that a matching is correct then the matcher can assign a weight to the result according to Table 1. In this example the standard matcher assigns a weight of 32768 to the results having a standard of EDIFACT because the standard of the input is EDIFACT . If a matcher determines that a matching is not correct the matcher assigns a weight of 1 to the result. In this example the version matcher assign a weight of 1 to a result having a version of FREETEXT because the version of the input is D . If a matcher determines that a matching is empty the matcher assigns a weight of 0 to the result. In this example the DEN matcher assign a weight of zero to the result having an empty DEN.

Based on the assigned weights a product value can be computed for each of the results using the formula . If a matching result includes at least one incorrect matching then the result is determined to have a product of zero. For example the first result has a product value of zero because the context value of the result Geopolitical Germany and the context value of the input Geopolitical USA does not match. In another example the third result has a product value of zero because the standard and the version of the result do not match the standard and the version of the input.

If none of the matching is not correct then a product value is computed by summing all the weights assigned to the result. In this example the second result having a standard of EDIFACT a version of D and no context value and DEN is computed to have a product value of 33024. The forth result having a standard of EDIFACT a version of D and a geopolitical context value of USA and a DEN of Buyer. Address is computed to have a product value of 170652.

If any of the matching is not correct then a new DEN may be integrated into the intermediary schema. In one example the new DEN may be shown as a recommendation of a new entity to the user. The user can accept this recommendation or map the unmappable portion of the input schema manually to the appropriate intermediate scheme entities according the user s requirements to name two examples.

The procedure can compare the product values to determine the best match for the input. In this example the procedure selects the last result because it has the highest product value.

After the detailed calculations and the product values are evaluated there can be generated a final statement characterizing the matching as an ambiguous match an unambiguous match or even as non matching. Thus this can be the result in the combination stage .

The matching procedure may however not end with the first formulation of a result in the combination stage . Rather the procedure may go through one or more iterations in which the current results are tested against the respective schemas and re evaluated for accuracy and robustness. Particularly portions that have been found unmappable may be retried in light of the overall result. The procedure may allow user feedback for portions that the matcher module has not successfully mapped. Nevertheless some first schema portions may be deemed unmappable after several iterations. For such portions the matcher module can generate a new entry in the intermediary schema to matching these unmappable portions. For example the procedure can add a new entry in the intermediary schema using the DEN of the first schema portion.

In some embodiments the weights used by the combination stage can be adjusted in an attempt to produce more desirable results after each iterations . For example the combination stage may determine that there are ambiguous mappings between the imported schema and the intermediary schema. Based on determination result the combination stage can revise the weight of at least one matcher component. Thus the ratio of the weight of the at least one matcher component to the weights of the other matcher components is changed. In a subsequent iteration the combination stage can then use the weights as revised to generate the matching result. Further examples of weight adjustments are described in pending patent application Ser. No. 10 856 694 entitled Automatic Match Tuning the contents of which are incorporated herein by reference.

After obtaining a final matching result the procedure can receive user feedback by allowing the user to accept or reject the final matching result. For example the procedure may present the final matching result as a suggestion to the user. Upon presenting the suggestion the procedure can receive a user input indicating an acceptance or a rejection of the suggestion. If the user rejects the suggestion then the procedure may for example request more information from the user and perform another iteration of the matching procedure to obtain another matching result. If the user accepts the suggestion then the final matching result may be exported and stored in the building block repository . In some embodiments the matching procedure can add the received context values to the final matching result upon receiving the acceptance from the user.

From the final results of the matching procedure the system forms a mapping from the first schema to the intermediary schema with the possible exception of the unmappable portion s . Particularly the mapping provides the relation between the first schema and the building blocks of the intermediary schema as schematically illustrated by an arrow . Examples of such building blocks in the building block repository are Address. Details Batch. Details Price Component. Details Price Component. Base. Amount and Batch. Toll Free. Indicator the names of which indicate their respective functions. The matcher module stores the created mapping in the mapping repository .

As shown the schema includes a plurality of nodes . Any or all of the nodes is to be associated with a context value set as a result of the process . Note that in this example only shows a portion of a full schema for clarity.

The process includes a graphical user interface GUI to set the context values for any or all of the nodes . In one embodiment a user can use the GUI to enter a context value to be associated with the schema e.g. a definition in the schema in its entirely. That is the entered context value s can be associated with all entities of the schema . In one embodiment the GUI may be generated when a user inputs an entry to identify a definition related to the schema in a previous GUI. For example the user may browse to a file location where the schema is stored and initiate the entry of context value s . In the implementation shown here the GUI includes an input area where the user can enter the name of a schema or a mapping so as to direct the entered context value s for association with that schema mapping.

As shown the GUI includes multiple context categories . For each of the context categories the GUI includes one or more drop down list boxes for the user to select a context value. In one embodiment the context categories and the values included in the drop down list boxes are identified based on CCTS defined context categories and context values. Each of the context categories may include a default context value that may be set when the GUI is generated.

In this example a user can enter the context value for the schema in any or all of the context categories using the GUI . Multiple levels of context value are presented. The user can first select a context value in the drop down list box containing the first level context values and then further select a second level context value within the first level context. For example the user can select Purchasing Ordering Request as the context value for the Business Process Context category by first selecting Purchasing Ordering in the first level and Purchase Ordering Request in the second level. The user can also select a wildcard context value . For example the user enters the wildcard context value in a Geopolitical Context category meaning the contexts of the nodes in the schema are not restricted to any country.

In one embodiment the GUI is presented to the user when context information is required. For example the matching procedure may cause the GUI to be presented before starting the matching or in a first iteration thereof.

The user can cause the entered context value s to be assigned to the current schema as indicated by an arrow by selecting an OK button in the GUI . In one example the user can use the GUI to define the context values of the schema . Next the user can cause the schema to be imported for matching. By taking the context values and the names into account the procedure can generate a mapping of the nodes to a respective one of the nodes in the intermediate schema.

The names can be generated to be consistent with a naming rule for the intermediate schema. There will now be described examples of using generated names to aid the creation of a mapping. shows an example of a name generating module that is capable of generating unique names for data elements using the definition for each respective element. The system can use the name generating module to generate DENs for each of the nodes in the input schema before importing the input schema into the procedure . Using the generated DENs the matching procedure can map one or more of the nodes from the imported schema to the output schema.

The name generating module receives input that can include definitions for the data elements and the element names from the external schema. The module uses the input to create unique name s as output. For example the definition may define a data element e.g. a node in a schema . The exemplary name generating module includes a predefined name format a grammar module a dictionary a rule repository and a hierarchical tree . The definition that is received in the input is formulated in a human understandable descriptive language. This means that the definition is composed of terms phrases or expressions corresponding to and consistent with those vocabularies included in the dictionary and furthermore follows the grammar defined in the grammar module . For example the definition may be composed of one or more sentences in English.

The predefined format defines the requirement of the format of the generated unique name . For example the predefined format could be an international standard for generating DENs such as the ISO 11179 and the rules of UN CEFACT Core Component Technical Specification CCTS . In another example the predefined name format may also be a private naming convention agreed between two or more business partners.

The name generating module goes through a process to generate unique names that comply with the predefined name format . The process may use rules stored in the rule repository . The name generating module may apply the rules to the definition to obtain one or more nouns that are useful for generating the unique name . This may involve using a set of rules based on generative and transformational grammar which is a proof theoretical approach to the study of syntax of sentences. Such rules may be inspired by a formal grammar of precisely describing a formal language. One of the essential parts of this formal grammar is the representation of context free grammars defined in the Chomsky Hierarchy which can be depicted as a derivation tree. This derivation tree is a key part for analyzing sentences and representing the coherence of words in sentences by subordinate and superordinate branches connected at nodes. According to these branches and nodes it is possible to derive the correct terms of a DEN getting the unambiguous meaning that is originally represented in the definition sentence. The correct derivation and serialization of terms are based on further rules in addition to the generative and transformational grammar.

In one embodiment the name generating module may first parse the definition into at least one noun phrase and at least one verb phrase. The name generating module may use a first noun obtained from the noun phrase a second noun obtained from the verb phrase and a third noun associated with the verb phrase to create the unique name . The rules may also define how to truncate a word obtained from the input .

In some embodiments the predefined name format can require the unique name to include an object class term a property term and a representation term. An object class term is a part of a unique name of a data element that represents the object class to which it belongs. A property term is a part of a unique name of a data element that expresses a property of an object class. A representation term is a part of a unique name that represents the form of a set of valid values for a data element due for example to the data element being defined as having a certain data type. The object class terms property terms and representation terms may be those used with implementations of the CCTS standard.

The name generating module may parse the definition to generate the hierarchical tree in order to obtain the object class term the property term and the representation term for generating the unique name . As an illustrative example the name generating module generates a dictionary entry name that consists of three terms using the hierarchical tree . A first term is an object class term. A second term is a property term. A third term is a representation term. For example the definition may be This identifier identifies the person. Then the name generating module selects the noun identifier as the representation term and the noun person as the object class term. To obtain the property term the name generating module converts the verb identifies in into a noun associated with the verb phrase identifies the person . The name generating module may use the dictionary for this conversion. For example the name generating module obtains the property term by converting the verb identifies in the verb phrase identifies the person into a noun identification . The name generating module generates a DEN by combining the obtained terms resulting in a DEN person.identification.identifier .

Using the resulting DEN the DEN matcher can match the generated unique name with names in the intermediate schema. Further examples of generating unique names are described in pending patent application Ser. No. 11 400 837 entitled Generating a Unique Name for a Data Element the contents of which are incorporate herein by reference. In this implementation the result is a new external schema that has three categories of information 

2. The reference for each element and type to its origin representation as it was in the external schema can be used for a later conversion in runtime .

These information categories will be used for the next step the matching procedure . The matching procedure considers all three parts by its different schema matcher 

In step the operations can comprise identifying a first plurality of nodes to be mapped to a second schema with a second plurality of nodes. For example the procedure identifies nodes in the imported mapping between schemas so that the identified nodes can be mapped to the output schema. In other implementations this step can be omitted. For example the plurality of nodes can be implicitly generated in connection with step below.

In step the operations comprise receiving at least one context value for the received definition. For example the process receives context values of one or more context categories e.g. the context categories by generating the GUI and receiving user input from the GUI . This receipt of context value s can precede the procedure for example as shown in . The context values can be assigned to the elements of the schema. In another example the context value definition may be available in the imported schema or from online documents of the imported schema.

In step the operations comprise generating names corresponding to each of the nodes in the first plurality. The generated names are consistent with a naming rule for the second schema. For example the name generating module generates DENs for each of the nodes in the imported schema. The names can be generated so that they are consistent with the naming convention for CCTS to name one example.

In step the operations comprise mapping each of the first plurality of nodes to a respective one of the second plurality of nodes. The context value and at least one of the generated names are taken into account in the mapping. For example the matching procedure uses the similarity cube and the combination stage to combine matching results from the matching components . After combining the matching results each node in the imported schema is mapped to a respective node in the output schema.

In some implementations and with reference again to the system can create the mapping by first enriching context to the first schema using the process generating DENs for the data types and data elements of the first schema using the name generating module and performing the transformation according to . shows a procedure that is an example of such a process. In short this example involves importing a schema D setting a context for it transforming it to a CCTS convention and performing the mapping to an intermediate schema.

In more detail then an input schema is imported to the procedure to be mapped to an intermediary schema. As shown the input schema is the schema D and includes an address type. The address type includes four nodes StreetNm HouseNb CityNm and CountryCd.

The procedure first assigns context values to the input schema . In this example the procedure can enrich the input schema with a context value I A . A context enriched schema is generated. As shown every node in the schema D is enriched with the context value I A . For example the AddressType of the schema D is enriched to become AddressType Context I A . For example the nodes StreetNm HouseNb CityNm and CountryCd within the AddressType are also enriched to become StreetNm Context I A HouseNb Context I A CityNm Context I A and CountryCd Context I A respectively.

Next the procedure transforms the enriched schema into a transformed schema . In this example a one to one mapping between a DEN and a node in the schema is generated. For example the name generating module can generate a node for each of the nodes AddressType StreetNm HouseNb CityNm and CountryCd based on the CCTS conventions. As shown a new layer of definition is generated that includes a DEN of each of the nodes. Each of the DENs is associated with a child node that represents the original presentation of this element. The DENs are also enriched with the context values assigned to the original presentation of the elements. For example the transformed schema includes an Address. Details Context I A having a child node Schema D AddressType Context I A an Address. Street. Name Context I A having a child node Schema D StreetNm Context I A an Address. House. Number Context I A having a child node Schema D HouseNb Context I A an Address. City. Name Context I A having a child node Schema D CityNm Context I A and an Address. Country. Code Context I A having a child node Schema D CountryCd Context I A .

The procedure uses different matchers such as the matchers described with reference to . Using the matchers the procedure can compare each child node relating to the schema D with existing nodes in a repository e.g. the repository in that includes the nodes of the already mapped standards. In this example the repository includes nodes of the intermediary schema. Each of the nodes includes one or more child nodes. The child nodes are entities of another schema e.g. schema A schema B schema C that are mapped to their corresponding parent nodes in the intermediary schema.

To create a mapping between the schema D and the intermediary schema the mapping procedure attempts to assign the nodes in the transformed schema to any of the nodes in the intermediary schema in repository based on the DEN and the context of the nodes. In this example the result is that the child node Schema D AddressType Context I A is assigned to the node the child node Schema D StreetNm Context I A is assigned to the node the child node Schema D CityNm Context I A is assigned to the node and the child node Schema D CountryCd Context I A is assigned to the node .

The DEN Address. House. Number HouseNb does not exist in the repository . Therefore the mapping procedure can integrate the node Address. House. Number into the repository . As a result an intermediary schema is generated with the new semantic. This can be viewed as an extension of the intermediate schema because the new node was added. The new intermediary schema can be stored in the repository and be used in mappings.

Here the transformation receives a schema as its input. For example the schema can be a RosettaNet representation of a purchase order document. The schema includes a schema portion and context values associated with the nodes in the schema portion . For example the context values may have been associated with the schema nodes as part of the process .

The received schema is provided to a linguistic processor for normalization according to a standard. Here the transformation passes the schema to a CCTS based linguistic processor . An output of the linguistic processor in this example is a CCTS based representation of the incoming schema. The CCTS based representation has a CCTS compliant representation of the nodes in the schema that includes the proper DENs is organized in a coherent multilevel structure of nodes and that is further enriched with parameters from the original here RosettaNet schema. Moreover the CCTS based representation also includes the context values obtained from the schema . As such the CCTS based representation can be used as an input to the procedure see . For example the CCTS based representation can correspond to the transformed schema see .

The CCTS based linguistic processor can include a context analyzer a morphological transformer and one or more syntactic transformers . The context analyzer can analyze one or more of the context values for creating the CCTS based representation . For example the context value s can be analyzed to determine whether a representation already exists for the specified context.

The morphological transformer can perform one or more morphological transformations e.g. an inflection a derivation and or a compounding on words included in the schema . This can result in a morphological representation as an intermediate result from the CCTS based linguistic processor . For example the morphological representation can include words inflected derived and or compounded from the original here RosettaNet schema.

The one or more syntactic transformers can perform one or more syntactic transformations on the schema for example to transform a RosettaNet based syntax to a CCTS based syntax. This can result in a syntactic representation as an intermediate result from the CCTS based linguistic processor . For example the syntactic representation applies the CCTS based syntax to the contents of the schema . In some implementations the CCTS based representation is created by merging the morphological representation and the syntactic representation .

In some implementations the CCTS based representation can be implemented using a ready to map format RTMF . For example the RTMF is based on the XML Schema representation according to rules of XML Naming and Design Rules XMLNDR for CCTS. In one example the RTMF can be used to transform the input schema which may or may not be CCTS based e.g. Universal Business Language UBL RosettaNet CIDX etc. for mapping into a repository of a CCTS Modeler Warp by a semi automatic mapping approach e.g. the approach used in the process .

The RTMF in this example includes CCTS specific aspects business context classification and other information describing a structure of an input schema e.g. the input schema . In some implementations the system can use the RTMF to generating mappings for external business to business B2B libraries including both CCTS based B2B libraries and not CCTS based B2B libraries based on other structures and conventions. For example one or more RTMF entities can be contextualized to provide a higher precision during the mapping procedure e.g. the process .

A CCTS based B2B library need not be serialized into the RTMF because the RTMF follows completely the conventions of the XML Naming and Design Rules XMLNDR for CCTS. In contrast the characteristics of entities of other B2B schemas may need to be serialized into appropriate aspects of the source schema artifact area.

As shown in the code defines an example structure of a primary construct of an RTMF schema. As shown the code includes definitions of at least one complex type entity and a global declared element .

An entity name may be a name of the ABIE complying with the XMLNDR conventions. The information is optional because the information can only be filled from an available CCTS based ABIE.

The complex type entity includes an annotation element and a sequence element . The annotation element optionally includes a CCTS based documentation and a business context . The CCTS based documentation is a CCTS based documentation of the ABIE. In some implementations information in the documentation optional because the information can only be filled from an available CCTS based ABIE. The documentation schema construct can be imported. An example code of the CCTS based documentation is described below with reference to .

The business context can specify a business context of the specific ABIE. The business context may be filled independent of whether the source schema is based on CCTS conventions. In some implementations the business context is imported. An example code of the business context is described with reference to .

The annotation element includes one or more element definitions . For example the element definitions may specify characteristics of the specific ABIE if the characteristics are from a B2B schema that is not based on CCTS conventions. The element definitions may need to be filled if the source schema is not based on CCTS conventions. In some implementations the element definitions can be imported. An example code of the element definitions is described with reference to .

The sequence includes a local declared element and at least one global declared element . For example the local declared element is a BBIE or an ASBIE that is a composition. The composition is described in UML conventions. The local declared element includes an element name an entity element type a minimal occurrence and a maximal occurrence . For example the values can specify properties of the local declared element . The element name is a name of the BBIE or ASBIE according to the XMLNDR conventions if the BBIE or ASBIE is represented as a local declared element. The element name may be optional. In some examples the entity name can be filled if a CCTS based BBIE or ASBIE is available.

The element type is a type of the specific BBIE or ASBIE is based on. In some implementations the element type is described according to the XMLNDR conventions. For example the element type can be either a business data type BDT or an ABIE that represents a composition. In some implementations the element type may be optional. For example the element type can be filled if a CCTS based BBIE or ASBIE is available.

The minimal occurrence is a minimal occurrence of a BBIE or an ASBIE. The minimal occurrence is used for both CCTS based and non CCTS based libraries. The minimal occurrence can include values based on the XML Schema convention. Some example values are No occurrence representing a mandatory occurrence of the element an integer value representing a number of minimal occurrences of the BBIE or the ASBIE or unbounded representing an infinite number of occurrences of the BBIE or the ASBIE to name a few examples.

The maximal occurrence is a maximal occurrence of a BBIE or an ASBIE. The maximal occurrence is used for both CCTS based and non CCTS based libraries. The maximal occurrence can include values according to the XML Schema convention. Similar to the minimum occurrence example values are No occurrence an integer value or unbounded to name a few examples.

The definition of the local declared element includes a CCTS based documentation a business context and a characteristic . The CCTS based documentation is a CCTS based documentation of the BBIE or ASBIE. For example the CCTS based documentation may be optional. In some implementations the CCTS based documentation can be filled if a CCTS based BBIE or ASBIE is available. The CCTS based documentation can be imported. An example the CCTS based documentation is described with reference to .

The business context specifies a business context of the specific BBIE or ASBIE. The business context may be filled if a CCTS based BBIE or ASBIE is available. In some implementations the business context may be imported. An example of the business context is described with reference to .

The characteristics include the characteristics of the specific BBIE or ASBIE for example if the BBIE or ASBIE is obtained from a B2B schema that is not based on CCTS conventions. The characteristics may be filled if the source schema is not based on CCTS conventions. The characteristics may be imported from the input schema. An example code of the element definitions is described with reference to .

The global declared element is specified using a reference the minimal occurrence and the maximal occurrence . For example the reference is a name of the ASBIE according the XMLNDR conventions if the ASBIE is a global declared element or even an aggregation. The aggregation is described in the UML conventions. The information of the reference can be optional. The information can only be filled if a CCTS based ASBIE is available.

The global declared element is declared using a name and a type . For example the name is a name of the global declared element of an ABIE based on the XMLNDR conventions. The ABIE can be a root element of a message or an aggregation. In some implementations the name can be optional. The name can only be filled if a CCTS based ABIE is available.

The global declared element is based on a type that is the type of which the specific ABIE is based on. For example the ABIE is either a root ABIE or representing a stand alone object that can be used for aggregations. The type is described based on the XMLNDR conventions. In some implementations the type can be optional. For example the type can only be filled if a CCTS based ABIE is available.

As shown in the code is an example of a documentation schema for artifacts described in . For example the documentation schema can be used to specify one or more metadata as specified in the CCTS e.g. to convey the semantic content carried in the XML construct . In one example the annotation documentation can include annotations defined in section of the XMLNDRs. In the depicted example the code includes a unique identifier an acronym a DEN a version a definition an object class term an object class qualifier a usage rule a business term and an example .

The unique Identifier is an identifier assigned to the artifacts associated with the documentation in the B2B library.

The acronym is an abbreviation of a type of the component. In the depicted example the acronym is associated with a value of ABIE representing an aggregation business information entity. Other acronyms are for example BBIE basic business information entity ASBIE associated business information entity BDT business data type BDTSC business data type supplementary component or MSG message to name a few examples.

A name can be a name of a supplementary component or a business information payload. The name can be represented in XML code as Name .

The code may optionally include a cardinality e.g. represented as Cardinality in XML code associated with the artifact. For example the cardinality can indicate whether the artifact is not applicable optional mandatory and or repetitive characteristics of the object.

The object class term is an object class represented by the artifact. The object class qualifier is one or more terms that qualifies the object class of the artifact. For example a qualifier order value can qualify a term attribute . In another example a qualifier positive integer can qualify a term type . In some implementations the terms and the qualifiers complies the CCTS convention for DEN. In one example the names can be generated using the name generating module as described in .

The documentation can include a property term represented by the artifact. For example the property term can be represented as PropertyTerm in XML code. The documentation can include one or more property qualifier terms qualifying the property term. For example the property qualifier term can be represented as PropertyQualifier in XML code.

The documentation can include a representation term that is a primary representation term represented by the artifact. For example the representation term can be represented as RepresentationTerm in XML code. The documentation can include a representation qualifier that qualifies the representation term. For example the representation qualifier term can be represented as RepresentationQualifier in XML code.

The documentation can include an association type of the ABIE. For example the association type can be represented as AssociationType in XML code.

The documentation can include a data type term represented by the artifact. For example the data type term can be represented as DataTypeTerm in XML code. The documentation can include a data type qualifier that qualifies the data type term. For example the data type qualifier can be represented as DataTypeQaulifier in XML code.

The documentation can include a primitive type that represents a primitive data type assigned to the artifact by CCTS. For example the primitive data type can be represented as PrimitiveType in XML code.

As shown in the code specifies a business context schema. In some implementations the code can specify business context using values selected from a specific business context value list.

The code includes a unique identifier and a version identifier of the business context. For example each of the unique identifier and the version identifier may be non repetitive and have an UDT of IDType. In one implementation the unique identifier may be mandatory. In some implementations the version identifier may be optional.

The code specifies business context in various business context categories and . For each of the business context categories and the code includes an excluded indicator and an all context values indicator .

The excluded indicator is a boolean flag or parameter that may be optionally included in any or all definitions of business context category and . For example the excluded indicator can indicate whether a subsequent list is a negative list that contains values to be excluded from the set of valid context values. For example the excluded indicator includes a true value to indicate that the subsequent list is a negative. In one example negative lists are to be used if less than a half of the universal context values set are invalid for a current case. Otherwise positive lists are to be used. In some examples the excluded indicator may be used if the all context values indicator is set to true.

The all context values indicator may be an optionally included boolean flag or parameter. For example the all context values indicator can be set to true to include all context values into the current context. In some examples single values can be excluded using the excluded indicator . For example for a given universal set of values a b c d e f g with a set of valid values a b c d a negative list can be used for a context value to exclude e f g as follows.

The business information context categories may be optional and repetitive. The business information context category optionally includes a business information entity ID and a business data type ID . For example the business information entity ID may be repetitive and nillable. In one implementation the business information entity ID may be a UDT of IDType. In some implementations the business information entity ID uses a business context value list to determined an identifier list of all unqualified and qualified ABIEs because associated subjacent ABIEs BBIEs or BDTs may have a specific context specific view belonging to the superjacent ABIE. In some implementations a business context value list is not required.

The business information context category optionally includes a business data type ID . The business data type ID may be repetitive and nillable. In one implementation the business data type ID may be a UDT of IDType. In some implementations the business data type ID can use a business context value list that is based on an identifier list of all unqualified and qualified BDTs because content components or even supplementary components can have specific characteristics according the qualified BDT. In some implementations a business context value list is not required.

The code can optionally include one or more of the business process context category . The business process context category is repetitive. In general an important aspect of describing a business situation is business activities being conducted. For example the business process context category may unambiguously identify business activities being conducted. In some implementations the business process context category uses a common point of reference to ensure consistency with the business process activities. For example a definitive point of reference for international standards is the UN CEFACT Catalogue of Common business processes.

The business process context category includes a business process type code a business transaction type code and a business transaction message type code . One or more of the business process type code may be optionally specified. For example the business process type code may be nillable and repetitive. In one implementation the business process type code may be an Unqualified Data Type UDT sometimes also referred to as a Core Data Type . A UDT is a generic representation of the Code. Type . The Code. Type could also be restricted as Country Code. Type for example. In one example a valid business context value list may be the BusinessProcessCodeList.

The business transaction type code may be optional repetitive and nillable. For example the business transaction type code may be a Code. Type. In some implementations the valid business context value list need not be required.

The business transaction message type code may be optional repetitive and nillable. For example the business transaction message type code can have a Code. Type. In one example a valid business context value list for the business transaction message type code is a MessageTypeCodeList.

The business process role context category may be optional and repetitive. In one example the business process role context category includes aspects of a business situation that are specific to an actor or actors within the business process. Values of the business process role context category can be taken from a set of role values provided by the UN CEFACT Catalogue of Common Business Processes. In one implementation the business process role context is specified by using a value or set of values from the set of role values from this source.

The business process role context category includes a party function code . The party function code may be optional repetitive and nillable. The party function code can be a Code. Type. For example the party function code represents the business process role of a specific business party. In one example the party function code uses a PartyFunctionCode as a valid business context value list.

The supporting role context category may be optional and repetitive. In one example the supporting role context category identifies parties that are not actively participants in the business process being conducted but may have an interest in the business process. The supporting role context category can be specified with a value or a set of values from a standard classification. The supporting role context category includes a supporter function code that may be optional repetitive and nillable. The supporter function code can be a Code. Type. For example a business context value list need not be required.

The industry classification context category may be optional and repetitive. In one example the industry classification context category includes a description of an industry or a sub industry in which the business process takes place. An example valid business context value list of the industry context category is IndustryClassificationCode. The industry classification context category includes an industry type code . The industry type code can be optional repetitive and nillable. The industry type code can be a Code. Type.

The product classification context category may be optional and repetitive. The product classification context category specifies aspects of a business situation related to goods or services being exchanged by or otherwise manipulated or concerned in the business process. Some recognized code lists can be used to provide authoritative sources of product classification contexts. The product classification context category includes a product type code . The product type code is optional repetitive and nillable. The product type code can be a Code. Type. In one example the product type code may not require a business context value list.

The geopolitical context category may be optional and repetitive. The geopolitical contexts category includes a description of aspects of the business context related to region nationality or geographically based cultural factors. The geopolitical context category includes a continent code a country code a region code and a language code . In some examples the continent code the country code the region code and the language code may be optional repetitive and nillable. In some examples the continent code the region code and or the language code may not require a business context value list. The continent code the region code and the language code can be a Code. Type. The country code can be a UDT of CountryCodeType and use CountryCode as a business context value list.

The official constraints context category may be optional and repetitive in the code . For example the official constraints context category describes aspect of a business situation that result from legal or regulatory requirements and similar official categories. The category includes regulatory and legislative requirements and conventions and treaties requirements. The regulatory and legislative requirements can be unilateral in nature. The regulatory and legislative requirements include for example customs authority regulations. The conventions and treaties requirements include bi or multilateral agreements. For example the conventions and treaties requirements can include different constraints imposed by the regulatory and legislative requirements.

The official constraints context category includes a law code . For example the law code may be optional repetitive and nillable. For example the law code can be a Code. Type. The law code may not require a business context value list.

The system capabilities context category may be optional and repetitive. In one example the system capabilities context category identifies a system a class of systems or standard in a business situation. In one implementation the system capabilities context category can require at least one pair of values an identification of the classification scheme being used and a value from that scheme. In some examples more than one pairs of values are permitted.

The system capabilities context category includes a software solution ID . For example the software solution ID may be optional repetitive and nillable. For example the software solution ID can be a UDT of IDType. The system capabilities context category can also include a schema library ID . The software solution ID may not require a business context value list. The schema library ID can be used for the identification of specific business process standards and libraries such as RosettaNet EDIFACT Chemical Industry Data Exchange CIDX and proprietary libraries that considers business data models such as intermediate document IDoc business application programming interfaces BAPIs global data types GDTs . For example the schema library ID may be optional repetitive and nillable. For example the schema library ID can be a UDT of IDType. For example a Uniform Resource Name URN based format should be used without the urn sap prefix such as PIP V2.0 RosettaNet. For example the schema library ID can include a schema source that represents a library name and a version e.g. PIP V2.0 RosettaNet . The schema library ID can also include a responsible agency that represents a name or a code of the responsible agency. If the responsible agency is a code the code is selected from the United Nations Economic Commission for Europe UNECE code list. In one example the schema library ID can use a SchemaLibraryID as a valid business context value list.

The user context category may be optional and repetitive. In one example a user ID may be required in the user context category . The user context category includes a party ID . The party ID can be may be optional repetitive and nillable. For example the party ID can be a UDT of IDType.

As shown in the code is an example structure for specifying a source schema artifact. The code includes a documentation element group a syntax element a content element a position element and a processing element .

The document element group includes a name and a description . The document element group can also include constraint rules of the artifact. The documentation element group includes information described in a human readable language. For example the language can be assigned by the xml lang attribute. The documentation element group is mandatory and non repetitive. The documentation element group includes at least the name or the description . For more precise matching results both the name and the description are included in the documentation element group . In some implementations an internet search mechanism may be used to get some or all of the missing information for the name and or the description . The name may be optional and is a non repetitive string. For example the name is a human readable name of the artifact. The name may be included if the description is not available. The description may be optional and is a non repetitive string. The description includes text description of a meaning e.g. a business meaning of the artifact. The description may include at least one grammatically correct sentence. In some implementations the documentation element group includes the description if the name is not available.

The syntax element may be mandatory and non repetitive. The syntax element includes information of a specific syntax of the schema artifact such as XML UN CEFACT ANSI ASC X12. The syntax element describes also the characteristics and behaviors of the specific syntax. The syntax element includes a type code . The type code may be a mandatory and non repetitive token. The type code can specify a type of representation syntax. Some example codes for syntax representation are listed in the following table.

The syntax element also includes an artifact type code . The artifact type code may be a mandatory and non repetitive token. The artifact type code includes information of how the artifact is to be represented or specified the specific syntax. The following code values may be used.

The syntax element includes an artifact name . The artifact name may be a mandatory and non repetitive string. The artifact name is the name of the artifact itself. In one example the artifact name can be represented in a human readable form which is similar to the name e.g. XML tag names . In another example the artifact name can be an acronym or an artifact identifier e.g. UN EDIFACT tag names which does not carry the semantic in a human readable form.

In some examples the source schema artifact may not include different syntaxes for globally and locally declared elements because the distinction may have no impact at an instance level. However nested elements including their documentations may need to be listed at an appropriate position of a sequence or choice structure. If a nested element refers to a globally declared element specific information to the globally declared element may be represented at the nested elements level. For example an example definition of the source schema can be include the following code.

In some examples an example representation of the global element in the source schema artifact may be

A typeCode attribute of the artifact name defines the kind of position. For example the typeCode attribute may be used if the syntax is not XML . The attribute can be 

The syntax element can optionally include an artifact base type that is a non repetitive string. The artifact base type refers to a type represented by the artifact type code . The artifact base type can be used in elements and attributes. The artifact base type can be used as a reference to valid complexTypes or simpleTypes. For example one or more xsd built in types may be used if the artifact base type is a simpleType. The following conversion may be considered 

As discussed above the source schema artifact does not differentiate between globally and locally declared elements. If in the source schema an element refers to a globally declared element the specific type of the globally declared element may be represented as the artifact base type . Using the above example code an example representation in the artifact may be specified as 

In an EDIFACT implementation nested elements that consider segments or element groupds may be based on globally defined complexTypes. For example the artifact name and the artifact base type have the same names. For example the syntax element in an EDIFACT implementation can be specified as 

As shown in the above code the artifact name S009 is based on a complexType that defines the artifact based type S009 .

The syntax element can optionally include a fixed length indicator that is a non repetitive boolean flag or parameter. For example the fixed length indicator indicates whether a length of the artifact is based on a fixed length. In one example the fixed length indicator can include a default value being false . The fixed length indicator with a false value means that the length will always be variable.

The syntax element can optionally include a fixed length value that is a non repetitive integer. The fixed length value provides the length of the artifact if the length of the artifact is based on a fixed length.

The syntax element optionally includes a separation sign that is a repetitive e.g. unbounded string. The separation sign defines the representation of separation signs between the groups elements and content. The content of separation sign is the separation itself. The separation sign is used if the type code is not XML . A typecode attribute of the separation sign defines the kind of separation signs used. Some examples of separating signs are

The separation sign also includes an omitIndicator attribute. The omitIndicator attribute is an optional boolean parameter or flag. If the value of an artifact is not shown in an instance the omitIndicator can defines the non representation of a separation sign . The default value of the omitIndicator attribute is true meaning the separation sign will be omitted if the artifact value is not represented.

The separation sign is required at an element level e.g. at a root element or nested elements . The separation sign is not required for types e.g. simpleTypes and complexTypes . For example elements are shown in the instance level.

The content element is optional and non repetitive. The content element defines the representation and characteristics of data content. For example the content element can be used for defining leaf elements that consider data content. The content element includes an example element a default element a fixed element a length value a minimum length value a maximum length value a total digits value a fraction digits value a white space code a pattern a facet and a fixed length fill signs .

The example element can be optionally included and can be a repetitive string. The example element can include a possible list of valid examples if at least one example is available.

The default element can be optionally included and can be a non repetitive string. In one example if the default element is specified and the default element is empty then the supplied constraint content may be used as the default element .

The fixed element can be optionally included and can be a non repetitive string. If the fixed element is specified then the artifact s content may either be empty in which case the fixed element behaves as default or the fixed element content may match the supplied constraint content. The fixed element may indicate that the content element if not empty is equal to the supplied constraint content.

The length value can be an optional and non repetitive integer. The length value defines a required fixed length of the string. The length value may impose a format restriction that need not be used in combination with the maximum length value and or the minimum length value . The behavior is similar as described in W3C XML Schema Part II . The length value can have the same value as the fixed length value for example if the fixed length indicator is true . In this case the fixed length value need not be required.

The minimum length value can be an optional and non repetitive integer. The minimum length value can define the minimum length of the string based content. In some implementations the minimum length value may not be used in combination with the length value restriction. The behavior is similar as described in W3C XML Schema Part II .

The maximum length value can be an optional and non repetitive integer. The maximum length value can define the maximum length of the string based content. In some implementations the maximum length value may not be used in combination with the length value restriction. The behavior is similar as described in W3C XML Schema Part II .

The total digits value can be an optional and non repetitive integer. The total digits value can be used for representation of decimal and integer values. The total digits value represents a total length sequence of decimal or integer digits. The total digits value includes the integer digits and the decimal digits. The behavior is similar as described in W3C XML Schema Part II .

The fraction digits value can be an optional and non repetitive integer. The fraction digits value can be used for representation of decimal values. The fraction digits value restricts a maximum number of decimal digits. The behavior is similar as described in W3C XML Schema Part II .

The white space code can be an optional and non repetitive token. In one example the white space code includes the same behavior as whiteSpace that is define in W3C XML Schema Part II . The white space code may specify one or more constraints of special characters of the content. The white space code can be one of the following values 

The pattern can be an optional and non repetitive string. The pattern can specify a constraint of the content element according to a regular expression. The representation of the pattern may be based on the regular expression defined by W3C XML Schema Part II .

The facet can be an optionally included repetitive string. For example the content element may include numeric and data based content that may have upper or lower limits of content. These limits can be expressed by the facet according to the conventions of some of the constraining facets of W3C XML Schema Part II . Some example attributes typeCode are

The fixed length fill signs can be an optional and repetitive string. For example the fixed length fill signs can define the character that should be used to fill the content element to the predefined fixed length specified in the fixed length value element. Some example attributes of the typeCode for defining the type of alignment are

The position element can be an optional and repetitive e.g. unbounded . The position element can define an absolute position of the artifact in the whole schema. A specific artifact can be shown on several positions within the schema. Therefore the position element can be repeated for each of the positions in the artifact. Some types such as the complexType and the simpleType may not need position information. A root element such as the first element of a message may have the expression . Each of the nested elements and attributes may be associated to one or more of the position elements .

The position element includes a XPath subchapter a trigger indicator and a qualifies artifact . The XPath subchapter can be a mandatory and repetitive string. For example the position element can be described as an absolute path according to a XML Path Language XPath 2.0. The XPath subchapter can explain the specific artifact that may need to be used. For example the element can occur at many distinct positions in an instance. Using the XPath subchapter possible paths for the artifact can be entered. In some examples the ssa XPath entry may be used for the complex Types e.g. ABIES only because BDTs may be very generic and may have extremely many possible positions.

The trigger indicator can be an optional and non repetitive boolean flag or parameter. The trigger indicator can indicate one or more trigger behaviors of an associated element. The trigger indicator can especially indicate this trigger behavior and need not be used for the syntax XML because some source schemas have specific artifacts that may have a trigger behavior. For example an instantiation of this artifact may be also the beginning of a new group of segments or elements. For example all following groups or elements may belong to this group until the same artifact may be instantiated. The default of the trigger indicator is false which means that the artifact has no trigger behavior.

The qualifies artifact can be an optional and non repetitive boolean flag or parameter . For example the qualifies artifact can be used if the specific artifact provides some additional semantics that qualifies another artifact more precisely. The another artifact can be expressed by the absolute path according XML Path Language XPath 2.0. The XPath subchapter specifies the specific artifact that should be used.

The processing element can be optional and non repetitive. The processing element can include instructions to software or users that receive and process the instance. The processing element includes a rule . The rule can be an optional and repetitive e.g. unbounded string. The rule may include rules from some B2B libraries some migration guidelines additional constraint rules or integrity conditions which can be described in freestyle or even according to constraint languages such as an object constraint language OCL . The rule includes a typeCode attribute that is an optionally included token. The typeCode attribute defines the kind of representations. The following example codes can be used.

The rule optionally includes a direction attribute. The direction attribute can be a token that defines a direction that a specific rule takes effect. Some example directions are as follows.

The rule also includes an attribute orderNumber that is an integer. For example the orderNumber attribute may be mandatory. The orderNumber attribute can be used for definition of a sequence number.

The RTMF uses regular expression to describe date time and duration. In general the regular expressions of Date Time and Duration differ from other regular expressions that are used for strings or numeric representations. In some implementations the RTMF uses a regular expression convention to represent date time and duration with a combination of ISO 8601 and UN EDIFACT Trade Data Element Date or time or period format code. In some examples the convention may be very flexible in order to define a large umber of alternative representation of dates time and time intervals that are used in B2B applications.

 S is used to represent a specific date time period character only means that the specific date time value will be represented only.

 n S is used to represent a number of digits in curly brackets specific date time period character represents digit from a positive integer or zero.

 n is used to represent a digit from a positive integer or zero. For example 1 represents one fixed digit and 2 represents two fixed digits.

 n m is used to represent from a number of digits to a number of digits in form of positive integer or zero. For example 0 2 represents zero to two digits.

 cl is a Namespace token of a specific code list if values are considered in diverse code lists. The namespace token should be valid and the specific code list should be imported.

 is used to represent a plus sign if in combination with the following element a positive value or zero needs to be represented in this case unless explicitly stated otherwise the plus sign shall not be omitted or a minus sign if in combination with the following element a negative value needs to be represented.

T is used as a time designator to indicate for example a start of the representation of local time to designate local time expressions a start of the representation of the time of day in date and time of day expressions or a start of the representation of the number of hours minutes or seconds in expressions of duration.

 .   are allowed separation designators. According to ISO 8601 a colon is used to separate the time elements e.g. between hour and minute and between minute and second solidus is used to separate components in the representation of time intervals and recurring time intervals and a hyphen is used to separate the time elements e.g. year and month year and week year and day month and day and week and day .

In a regular expression date time or duration follow a format. The format can be specified using a convention described below.

 C represents a digit used in the time element century . Various representations of the century time element can be used. For example a century can be represented as CC with a range 00 99. In another example a century can also be represented as nnC with a range 00C 99C.

 Y represents a digit used in the time element year . For example a year can be represented as YY with a range 00 99.

 M represents a digit used in the time element month . For example a month can have a range of 1 12 representing 12 months of a year.

 B represents a digit used in the time element half month . For example 1 can represent a first half month and 2 can represent a second half month.

 D represents a digit used in the time element day . For example a range 1 28 is used to represent exactly 28 days in a month 02. In another example a range 1 29 is used to represent exactly 29 days in month 02 when the year is a leap year. In another example a range 1 30 is used to represents exactly 30 days in months 04 06 09 and 11. In another example a range 1 31 is used to represent exactly 31 days in months 01 03 05 07 08 10 and 12.

 h represents a digit used in the time element hour . For example a range 0 23 is used to represent exactly 24 hours.

 m represents a digit used in the time element minute . For example a range 0 59 is used to represent exactly 60 minutes

 s represents a digit used in the time element second . For example a range 0 59 is used to represent exactly 60 seconds.

 W is used as a week designator preceding a data element which represents the ordinal number of a calendar week within the calendar year.

M Minute S Second. YYDDD can be used to represent a calendar day e.g. 1 Jan. 2007 can be represented as 07001 . For example MMDD can be used to represent a day of a month. For example DDD can be used to represent a day s number within a specific year. For example WW can be used to represent a week s number within a specific year. MM can be used to represent a month s number within a specific year. DD can be used to represent a day s number within is a specific month. YYMMDDHHMM can be used to represent a calendar date including time without seconds. To specify a time zone to represent the calendar date YYMMDDHHMMZZZ can be used where Z Time zone. YYMMDDHHMMSS can be used to represent a calendar date including time with seconds. To specify a time zone to represent the calendar date YYMMDDHHMMSSZZZ can be used where Z Time zone. CCYYMMDDHHMM can be used to represent a calendar date including time with minutes. To specify a time zone to represent the calendar date CCYYMMDDHHMMZZZ can be used where Z Time zone. CCYYMMDDHHMMSS can be used to represent a calendar date including time with seconds. To specify a time zone to represent the calendar date CCYYMMDDHHMMSSZZZ can be used where Z Time zone. CCYYMMDDHHMMZHHMM can be used to represent a calendar date including time and time zone expressed in hours and minutes. For example ZHHMM can be used to represent a time zone given as offset from UTC.

MMDDHHMM can be used to represent a month day hours minutes in which M Month D Day H Hour M Minute. DDHHMM can be used to represent a day hours minutes in which D Day H Hour M Minute. HHmm can be used to represent a time without seconds in which H Hour m Minute. HHmmss can be used to represent a time with seconds in which H Hour m Minute s Seconds. To specify a time zone of the time HHmmssZZZ can be used where Z Time zone.

mmmmss can be used to represent a time without hours in which m minutes s seconds. ZHHMM can be used to represent an offset from UTC where Z is a plus or a minus sign. HHmmHHmm can be used to represent a time span without seconds in which H Hour m Minute.

HHMMSS HHMMSS can be used to represent a period of time specified by giving the start time followed by the end time e.g. both expressed by hours minutes and seconds . Data is to be transmitted as consecutive characters without hyphen. HHMMSSZZZ HHMMSSZZZ can be used to represent a period of time specified by giving the start time followed by the end time both expressed by hours minutes seconds and time zone . Data is to be transmitted as consecutive characters without hyphen.

CC can be used to represent a century. YY can be used to represent a calendar year in which Y Year. CCYY can be used to represent a calendar year including century in which C Century and Y Year. YYS can be used to represent a semester in a calendar year in which Y Year S Semester. CCYYS can be used to represent a semester in a calendar year in which C Century Y Year S Semester. CCYYQ can be used to represent a quarter in a calendar year in which C Century Y Year Q Quarter. YYMM can be used to represent a month within a calendar year in which Y Year M Month. CCYYMM can be used to represent a month within a calendar year in which CC Century Y Year M Month.

YYMMA can be used to represent a ten day period within a month of a year A a ten day period . CCYYMMA can be used to represent a ten day period within a month of a year including century. YYWW can be used to represent a week within a calendar year in which Y Year W Week e.g. 1st week of January week 01 . CCYYWW can be used to represent a week within a calendar year in which CC Century Y Year W Week. YY YY can be used to represent a period of time specified by giving the start year followed by the end year without indicating a century. For example data can be transmitted as consecutive characters without hyphen. CCYY CCYY can be used to represent a period of time specified by giving the start year followed by the end year without indicating a century. Data is to be transmitted as consecutive characters without hyphen.

YYS YYS can be used to represent a period of time specified by giving the start semester of a year followed by the end semester of a without indicating a century. Data is to be transmitted as consecutive characters without hyphen. CCYYS CCYYS can be used to represent a period of time specified by giving the start semester of a year followed by the end semester of a year without indicating a century. Data is to be transmitted as consecutive characters without hyphen. YYPYYP can be used to represent a format of period to be given without hyphen e.g. P period of 4 months .

CCYYP CCYYP can be used to represent a format of period to be given without hyphen. YYQ YYQ can be used to represent a period of time specified by giving the start quarter of a year followed by the end quarter of year without indicating a century. Data is to be transmitted as consecutive characters without hyphen. CCYYQ CCYYQ can be used to represent a period of time specified by giving the start quarter of a year followed by the end quarter of year with both including a century. Data is to be transmitted as consecutive characters without hyphen. YYMM YYMM can be used to represent a period of time specified by giving the start month of a year followed by the end month of a year without including a century. Data is to be transmitted as consecutive characters without hyphen. CCYYMM CCYYMM can be used to represent a period of time specified by giving the start month of a year followed by the end month of a year with both time including a century. Data is to be transmitted as consecutive characters without hyphen. YYMMDDHHMM YYMMDDHHMM can be used to represent a period of time specified by giving the start time followed by the end time. Data is to be transmitted as consecutive characters without hyphen. YYWW YYWW can be used to represent a period of time specified by giving the start week of a year followed by the end week of year without including a century. Data is to be transmitted as consecutive characters without hyphen. CCYYWW CCYYWW can be used to represent a period of time specified by giving the start week of a year followed by the end week of year with both times including a century. Data is to be transmitted as consecutive characters without hyphen. YYMMDD YYMMDD can be used to represent a period of time specified by giving the start date followed by the end date not including century. Data is to be transmitted as consecutive characters without hyphen. CCYYMMDD CCYYMMDD can be used to represent a period of time specified by giving the start date followed by the end date including century. Data is to be transmitted as consecutive characters without hyphen. CCYYMMDDHHMM CCYYMMDDHHMM can be used to represent a period of time which includes the century year month day hour and minute. Format of period to be given in actual message may be without hyphen. DHHMM DHHMM can be used to represent a format of period to be given without hyphen in which D day of the week e.g. 1 Monday 2 Tuesday . . . 7 Sunday .

The table below entitled Example Purchase Order includes an example schema representation of an UN EDIFACT purchase order serialized in RTMF. The schema representation includes example codes having structures corresponding to the description above with reference to . For example the schema representation has a primary construct as described above with regard to the code . For example the schema representation includes code sections of documentation elements the code business context elements the code and schema artifacts the code . In one example the schema representation can be used as an input to the process . For example the process can extract information such as DENs and business context of the artifacts specified in the RTMF schema. Using the information extracted from the RTMF schema the process can generate mappings for the artifacts.

The memory stores information within the system . In one implementation the memory is a computer readable medium. In one implementation the memory is a volatile memory unit. In another implementation the memory is a non volatile memory unit.

The storage device is capable of providing mass storage for the system . In one implementation the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device.

The input output device provides input output operations for the system . In one implementation the input output device includes a keyboard and or pointing device. In another implementation the input output device includes a display unit for displaying graphical user interfaces.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include e.g. a LAN a WAN and the computers and networks forming the Internet.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

A number of embodiments have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of this disclosure. Accordingly other embodiments are within the scope of the following claims.

