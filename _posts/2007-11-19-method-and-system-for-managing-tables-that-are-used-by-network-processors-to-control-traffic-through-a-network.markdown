---

title: Method and system for managing tables that are used by network processors to control traffic through a network
abstract: A method for managing tables that are used by network processors to control network traffic through a network. The method comprises including a first table management software application in a first network processor, in which the first table management software is dedicated to managing only tables associated with the first network processor; including a second table management software application in a second network processor, in which the second table management software application is dedicated to managing only tables associated with the second network processor; and including a table management control application in a host processor, in which the table management control application is configured to respectively manage the tables associated with the first network processor and the tables associated with the second network processor through the first table management software application and the second table management software application through a plurality of generic application programming interfaces (APIs).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865912&OS=07865912&RS=07865912
owner: International Business Machines Corporation
number: 07865912
owner_city: Armonk
owner_country: US
publication_date: 20071119
---
This application is a continuation of application Ser. No. 10 706 232 filed Nov. 12 2003 now U.S. Pat. No. 7 325 239 the entire contents of which are incorporated by reference herein.

The present invention relates to computer systems and more particularly to a method and system for providing a mechanism for allowing a host to manage tables such as lookup tables in a scalable flexible manner.

Driven by increasing usage of a variety of network applications such as those involving the Internet computer networks are of increasing interest. In order to couple portions of a network together or to couple networks together network processors residing in switches routers and or other components are typically used. In order to adequately control the traffic through the network the network processor must classify packets and perform other functions that use tables such as lookup tables. In order to use these tables the properties of the tables are managed. For example size the data structure and corresponding speed the location memory selected the insertion of entries in the tables and certain relationships between tables are controlled. Thus a network administrator typically desires to manage the properties of the tables being used by the network processors.

The conventional network processors and are typically purchased by the owner of the conventional system . The conventional network processors and each includes conventional software and or firmware and respectively that are used in managing the tables not explicitly shown . In addition the conventional software and or firmware and may be different. For example the conventional network processors and may include different versions of a particular model of network processor from a particular vendor and or other model s of network processor that may be from other vendors. Thus the conventional network processors and are depicted as having software and or firmware and that are different versions of a Model X network processor while the software and or firmware of the conventional network processor is a Model Y network processor. Because the conventional network processors and are designed to communicate with different control applications each conventional network processor and utilizes conventional application program interfaces APIs and respectively that are specific to the particular software and or firmware and respectively.

The conventional table management application is used to manage the tables used by the conventional network processors and respectively. The conventional table management application thus includes a corresponding set of conventional behaviors and for each set of the conventional APIs and respectively. The conventional APIs and are designed to communicate with the conventional behaviors and respectively. The conventional APIs and are also used to control the corresponding software and or firmware and respectively. Thus using the conventional behaviors and corresponding to the conventional APIs and respectively the conventional table management application can control the tables for the conventional network processors and respectively.

Although the conventional system functions one of ordinary skill in the art will readily recognize that the conventional system is difficult to scale and may have high maintenance costs. The conventional network processors and are typically heterogeneous in nature. Because the conventional network processors and are heterogeneous the conventional network processors may include different versions of a particular model of network processor and or different models of network processor. In addition the way in which particular tables are used in each conventional network processor and may differ widely. Thus the software and or firmware and of different network processors typically differ. The APIs and thus also differ. Consequently the corresponding behaviors and of the conventional table management application are distinct. One of ordinary skill in the art will also readily recognize that the conventional system may actually include a large number of network processors. Consequently the number of conventional APIs and with which the conventional table management application must be compatible may be large. As a result the number of distinct conventional behaviors used by the conventional host processor and developed by the owner of the conventional system such as the conventional behaviors and may be large. As a result the conventional table management application may be complex and include an amalgamation of a variety of behaviors one for each model and or version of conventional network processor. It may thus be difficult to incorporate new network processors which may have software and or firmware and thus APIs not previously supported. The conventional system is therefore difficult to scale. Because of difficulties in incorporating new software and or firmware and their corresponding APIs evolving the conventional table management application and therefore the conventional system to utilize improved network processors may be problematic. Furthermore because supporting a variety of conventional behaviors and makes the conventional table management application more complex the conventional system may be subject to higher maintenance costs.

Accordingly what is needed is a system and method for allowing a host to manage tables used by a network processor in a scalable flexible manner. The present invention addresses such a need.

The present invention provides a method and system for managing a plurality of tables for a plurality of heterogeneous network processors in a network. The network also includes at least one host processor that utilizes at least one table management application. The method and system comprise providing a plurality of generic application program interfaces APIs . The generic APIs communicate with the control application s and the heterogeneous network processors. The generic APIs communicate with the table management application s in a network processor independent manner but manage the tables for the heterogeneous network processors in a network processor specific manner. Thus the generic APIs allow the control application s to be network processor independent and to manage the tables for the heterogeneous network processors in the network processor specific manner.

According to the system and method disclosed herein the present invention provides a generic mechanism for managing the tables for network processors. As a result a customer need not maintain a table management application having different sets of API for different types e.g. models and or versions of network processors.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Features and advantages will be apparent from the description and drawings and from the claims.

The present invention relates to an improvement in computer system. The following description is presented to enable one of ordinary skill in the art to make and use the invention and is provided in the context of a patent application and its requirements. The present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features described herein.

The present invention provides a method and system for managing a plurality of tables for a plurality of heterogeneous network processors in a network. The network also includes at least one host processor that utilizes at least one table management application. The method and system comprise providing a plurality of generic application program interfaces APIs . The generic APIs communicate with the control application s and the heterogeneous network processors. The generic APIs communicate with the table management application s in a network processor independent manner but manage the tables for the heterogeneous network processors in a network processor specific manner. Thus the generic APIs allow the control application s to be network processor independent and to manage the tables for the heterogeneous network processors in the network processor specific manner.

The present invention will be described in terms of a particular computer system a particular network processor and certain APIs. However one of ordinary skill in the art will readily recognize that this method and system will operate effectively for other computer system and network processors as well as additional and or other APIs. The present invention is also described in the context of a network including specific components and a particular number of components. However one of ordinary skill in the art will readily recognize that the present invention is consistent with other networks containing other and or additional components as well as another number of components. The present invention is also described in the context of particular types of tables. One of ordinary skill in the art will readily recognize that the method and system are consistent with other types of tables.

To more particularly illustrate the method and system in accordance with the present invention refer now to depicting one embodiment of a system in accordance with the present invention for managing tables not shown for network processors. The system is depicted as including a host processor and network processors and . The host processor includes a table management application . The network processors and include table management software and or firmware and respectively. However one of ordinary skill in the art will readily recognize that the generic APIs are of particular utility. In addition the generic APIs are depicted as a separate entity. However one of ordinary skill in the art will readily recognize that the host processor and network processors and utilize the generic APIs for communication and control.

The network processors and are capable of being heterogeneous. Thus the network processors and may have hardware software and or firmware for managing tables that differ significantly. For example as depicted in the software and or firmware for the network processor is Model X Version 1.0. In contrast the network processor includes software and or firmware that is Model X Version 2.0. The network processor is a completely different model having software and or firmware that is Model Y Version 1.0. Other network processors not shown having different models and or versions may also be included. Because they are heterogeneous in the absence of the present invention the network processors and would each require a separate network processor specific set of APIs in order to be controlled by a conventional table management application such as the conventional table management application depicted in .

Referring back to the generic APIs include APIs are used by the table management application and the network processors and . In particular the generic APIs communicate with and are used by the table management application in a network processor independent manner. In other words the table management application is network processor independent. In the context of the present application a network processor independent manner means that the table management application need not contain knowledge of the specific hardware software and or firmware and of any of the network processors and respectively for which tables are being managed. At the same time the table management application can control the tables for the network processors and by managing the software and or firmware and respectively. Because the table management application is network processor independent the table management application can control such as configuring and updating the tables for the network processors and without requiring specific knowledge of the hardware or software and or firmware and respectively of the individual network processors and respectively.

The generic APIs also communicate with and control the network processors and in a network processor specific manner. In the context of the present application network processor specific includes a knowledge of the specifics of a particular network processor such as the hardware software and or firmware and and possibly other components used by the particular network processor and respectively. Thus the APIs allow the table management application to be network processor independent while allowing each of the network processors and to be control in a network processor specific manner.

Using the system and more particularly the generic APIs the table management application can be network processor independent. Because of the use of the generic APIs the table management application can still control the tables for the potentially heterogeneous network processors and in a network processor specific manner. As a result the table management application need not include a separate set of APIs for each type of network processor and used. The table management application is therefore simpler. As a result it is significantly simpler to scale the system including adding new types of network processors. It is thus also easier to improve the performance of the system by adding improved network processors. In addition the maintenance costs of the system may be reduced due to the use of a simpler table management application .

The properties of the tables not shown in . used by the network processors such as the network processors and are abstracted via step . Each network processor and has specific tables used in a certain manner. Step abstracts the tables to a more general level.

For example the tables used by network processors such as the network processors and are complex data structure that exhibits certain properties. Each table acts as a container for one or more user data records and maintains various states. Each table also typically has a maximum size or number of records of fixed size that can be stored.

In a preferred embodiment step abstracts the tables as either fast or standard tables. The tables are placed in various memories either internal or external to the corresponding network processor and or . Tables may for example be placed in Dynamic Random Access Memories DRAMs and Static Random Access Memories SRAMs . The speed with which data can be accessed from a table depends upon factors such as the size the placement in memory and the type of search algorithm used by the table. In step the table size and the memory in which the records are placed i.e. the memory in which the tables are placed are abstracted to fast tables and standard tables. Fast tables are small in size in comparison to standard tables and are placed in memories internal to the corresponding network processor or or in SRAMs. Standard tables may be very large in size and are placed in slower memories such as DRAMs. Thus step abstracts the type of table to fast or standard. However the exact interpretation of this abstract concept can depend on the software and or firmware and implemented by a specific network processor.

For example depict abstractions of a fast table and a standard table respectively. The tables and also represent abstractions of other features of tables. The fast table is depicted as including records and as well as bookmarks and . The records and have corresponding keys A through A. Also shown are pointers A B A B A and B. As discussed below the keys A through A are generally used for exact matches. In other words an exact match for one of the keys A through A is typically searched for in the fast table . The standard table also include records and corresponding keys A through A and pointers A B A B A and B. However the algorithm typically used for a standard table as discussed below is generally a longest prefix match.

In addition to abstracting the table type the step preferably abstracts the search algorithm used by the tables. For example tables may generally be accessed in a random manner or in a sequential manner. When accessed in a random manner a search key is provided. The type of search key that is provided depends on the search algorithm that the table uses to access a particular record. A table generally incorporates one algorithm for accessing records randomly. In one embodiment the abstracting step defines two types of search keys corresponding to two types of search algorithms. The keys are exact match keys such as the keys through Aa and longest prefix match keys such as the keys through A as depicted in . The maximum length of these keys need not be specified but is preferably large enough to support the largest key that could be specified in a heterogeneous system of network processors.

If sequential access is supported by a table then records in a table may also be accessed sequentially from the beginning of the table or from some marked location within the table. Thus the tables and are depicted as including pointers A B A B A and B and A B A B A and B. The sequential access to records may occur in a forward direction where the term forward indicates access to the n 1record following the nrecord or in a backward direction where the term backward indicates access to the n 1record following the nrecord or both. If sequential access is supported then all of the records in the table are circularly linked. Therefore there is no concept of the beginning or end of a table since there is no reference point to support this concept. However tables may support bookmarks such as the bookmarks and that may temporarily indicate a reference point for sequential access of records. A bookmark such as the bookmarks and indicates the starting point of a sequential access. The complete table is said to have been sequentially traversed if the N 1 or N 1for a backward access sequential access returns a bookmarked record.

A table such as the table or is multi user in nature which enables multiple entities to access the table or respectively. The table management application entity on the host processor and its proxy on each network processor or if so implemented is also considered to be an Administrative entity. All entities may access the table simultaneously to either perform random sequential searches or to insert delete update a Record in the Lookup Table. Each entity that wishes to perform a sequential search on the table registers with the table and obtains a sequential access user identifier. This identifier enables a table or to manage the bookmarks and or and respectively associated with each registered entity independently. Thus all registered entities are able to sequentially access the entries and and and in the table and respectively simultaneously without adversely affecting one another.

The records are an integral part of the table. Thus the abstraction step also abstracts the operations relating to records. The records of a table are of a fixed length. The length is specified as part of the table definition process. The record contains the user specific data and may contain other implementation specific control information required to implement certain behaviors such as sequential access. In addition any record in a lookup table can be added to modified or deleted by the table if the record not being accessed at that time by another entity . The table incorporates behavior to ensure that sharing violations are avoided.

In the network processors and the information in the records of a table have a finite time period during which it is valid. On the expiration of this time period the entries are automatically deleted from the table. The process of deleting a record after a finite time period is referred to as aging. Thus step preferably also abstracts the aging process for tables. The abstraction of tables performed in step supports the aging function. In a preferred embodiment the abstraction will require users to specify if aging is required to be supported on the table and if so the identifier of an aging procedure that needs to be invoked the elapsed time interval between aging cycles the number of records that must be visited in a single cycle and or any other information used in aging. Other aspects of the tables are preferably also abstracted in step .

The generic APIs are defined using the abstraction provided via step . Thus step provides the generic APIs that can preferably manage tables such as the tables and for the network processors and . Furthermore where a particular operation is not supported by tables for a particular network processor and the generic APIs account for this by providing a null behavior to the table management application .

Step also provides the generic APIs such that the APIs can be used with a network processor independent table management application . Thus using the method the generic APIs can be provided. The network processor independent table management application as well as the network processors and can be developed to utilize the generic APIs .

In a preferred embodiment the generic APIs include at least APIs for configuring and updating the tables for each of the network processors and in a network processor specific manner. The generic APIs thus include APIs that govern the tables in general as well as the entries or records . The generic APIs preferably include APIs for setting the type of the table and setting the states of the table defining enabling disabling and locking tables. The generic APIs also include APIs for linking cascading tables updating entries adding entries deleting entries purging entries and aging entries. In addition to controlling the tables for the network processors and in a network processor specific manner the APIs preferably also return a null behavior for a particular function that is not implemented by a particular network processor.

In a preferred embodiment the generic APIs include twenty five APIs. The APIs preferably include Table Define Table Delete Table Add Entry Table Update Entry Table Read Entry Table Delete Entry Table Purge Table Set Link Table Switch Version Table Enable Table Disable Table Lock Table Unlock Table View Config Table List Table Register SA Table Deregister SA Table Get Current Entry Table Get Next Entry Table Get Previous Entry Table Process Entry Table Set Bookmark Table Go to Bookmark Table Start Aging and Table Stop Aging. In a preferred implementation of the generic APIs including the configure update enable disable and list APIs parameters and fields are specified. Table 1 describes a preferred embodiment of the fields used.

Some portion of the above fields are preferably used by the generic APIs for performing different operations such as configuring and invoking different types of congestion control at various points in the network processor. Note however that an alternate embodiment might use additional and or other fields having other uses.

Preferred embodiments of the Table Define API Table Delete API Table Add Entry API Table Update Entry API Table Read Entry API Table Delete Entry API Table Purge API Table Set Link API Table Switch Version API Table Enable API Table Disable API Table Lock API Table Unlock API Table View Config API Table List API Table Register SA API Table Deregister SA API Table Get Current Entry API Table Get Next Entry API Table Get Previous Entry API Table Process Entry API Table Set Bookmark API Table Go to Bookmark API Table Start Aging API and Table Stop Aging API are described below. However nothing prevents the use of additional and or different APIs.

The table define API allows the table management application to define the characteristics of a table. A TableID is supplied by the user to identify the table to the system and is bound to those defined characteristics. Once a TableID is defined it uniquely identifies the table until the table is deleted. The parameters associated with this API are as shown in Table 2. If the operation is successful and sequential access is specified a Sequential Access ID is returned.

The Table Delete API allows a table to be deleted. The table is preferably in the disabled state prior to invoking this API. When a table is deleted all entries and the table configuration is removed. The TableID is then ready for re use. Preferably the only parameter for the Table Delete API is the TableID.

The Table Add Entry API allows an entry to be added to into an existing table. The table is in the Enabled or Locked state for this operation. The parameters associated with this API are depicted in Table 3.

The Table Update Entry API allows an entry in a table to be updated. Three modes of operation are preferably available Standard update Select and Invert. All modes specify the size and position of the entry data to be modified. In the Standard Mode the user data is overwritten starting at the specified data offset within the record. In the Select Mode a mask is specified for indicating only the bit positions which are to be modified. In Select Mode the mask size is the same as the data size. The Invert Mode uses the mask to indicate which bit positions to invert. The table is in the Enabled or Locked state prior to invoking this API. The parameters associated with the Table Update Entry API are shown in Table 4.

The Table Read Entry API is used to read an entry in a table. The table is in the enabled or locked state for the Table Read Entry API to utilize the table. The requested amount data is read from the record associated with the specified key and returned. The parameters associated with the Table Read Entry API are depicted in Table 5.

The Table Delete Entry API allows an entry to be deleted from a table. The table is in the enabled or locked state for this API. The parameters associated with the Table Delete Entry API are shown in Table 6.

The Table Purge API is used to purge all the entries in a table. Resources that were consumed by these entries are then returned to the system for reuse. The table can be in either the enabled or disabled state prior to utilizing this API. If the table is in the enabled state the Table Purge API preferably locks the table purges the entries and then unlocks the table. In a preferred embodiment the only parameter associated with the Table Purge API is the Table ID.

The Table Set Link API allows the NextTableID field to be set in the table configuration. Although the NextTableID is set when a table is defined subsequent actions on the table chain such as the Table Delete API update links from the original definition. If the Cascaded Table parameter is set to False then the table identified by the Table ID parameter is the last table in the cascade. The table is preferably in the enabled state for to the Table Set Link API. In a preferred embodiment this API automatically transitions the table to the locked state set the new link value and then transition back to the enabled state. The parameters associated with this API are shown in Table 7.

The Table Switch Version API is used to swap two versions of a table preferably even if the 100 system is running. After the operation is completed registered sequential users of the old table are transferred to the newer version of the table. The sequential access pointers and bookmarks associated with each user are reset. If Aging had been initiated on the old table and if aging is enabled on the newer version of the table then the aging parameters are transferred to the new table and the aging operation commences. The Sequential Access ID Aging Interval and Aging Entries parameters are all preferably inherited from the old table. The table is preferably in the enabled state prior to the Table Switch Version API operating. In a preferred embodiment both tables are transitioned to the Locked state before performing the switch operation and automatically transitioned back to enabled state when the switch operation is concluded. The parameters associated with the Table Switch Version API are shown in Table 8.

The Table Enable API is used to transition a table from disabled to the enabled state. Transitions from other table states may result in an error. If the table is already in the enabled state this operation is preferably treated as a essentially null operation. In a preferred embodiment the only parameter associated with this operation is the Table ID.

The Table Disable API allows a table to be transitioned from enabled to the disabled state. If the table is already in the enabled state this operation is essentially treated as a null operation. In a preferred embodiment the only parameter associated with the Table Disable API is the Table ID.

The Table Lock API use used to move a table from the enabled to the locked state. After the transition to the locked state the table is deemed to be temporarily out of service for non administrative entities. Operations on the table from such entities are blocked until the table is unlocked or they time out. In a preferred embodiment all generic APIs may be performed using the table control application except the Table Define API the Table Delete API the Table Enable API and the Table Disable API. In a preferred embodiment the only parameter associated with this operation is the Table ID.

The Table Unlock API is used to moves a table from locked to enabled state. In a preferred embodiment the only parameter associated with this operation is the Table ID.

The Table View Config API returns the configuration information associated with a table. The configuration information is the preferably same as specified during use of the Table Define API. In a preferred embodiment the only parameter associated with this operation is the Table ID.

The Table List API allows the currently defined tables in the system to be listed. In a preferred embodiment in a standard mode the output from the use of the Table List API contains a list of TableID s the number of entries in each table the search type and the table state. In a preferred embodiment of a verbose mode the output of the operation of the Table List API contains all of the parameters found in the operations for the Table Define API in addition to the state. Tables in the undefined state are preferably ignored by this API. A search filter enables specification of search criteria. The parameters associated with this operation are shown in Table 9.

The Table Register SA API can also be utilized. A table can be set up to execute a forward sequential access or both forward and backward sequential accesses. This access can be performed by multiple users simultaneously without any detriment to one another. However prior to performing sequential access a user e.g. an entity must register to receive Sequential Access services on a particular table. The response to this service request is an SA User Id which is used to differentiate SA users on a particular table. A table us in the enabled or locked state for this API. In a preferred embodiment the only parameter to this operation is the Table ID. If the operation is successful a Sequential Access ID which is used in performing sequential access on the table is preferably returned.

The Table Deregister SA API is used to free the Sequential Access ID and its associated resources. This API is preferably invoked after a registered entity has finished traversing a table sequentially and has no further use of the ID. A table is in the enabled or locked state prior to utilizing the Table Deregister SA API. The only parameters associated with this API are preferably the Table ID and the Sequential Access ID.

The Table Get Current Entry API is used to fetch the current record pointed to by a sequential access pointer of a particular entity. The table is in the enabled or locked state and the entity previously registered in the table for sequential access in order for the Table Get Current Entry API to function as desired. The only parameters associated with this API are preferably the Table ID and the Sequential Access ID. The Table Get Current Entry API preferably returns the User Data Size and User Data.

The Table Get Next Entry API operation is used to fetch the entity s sequential access pointer to point to the next record and then fetch the contents of the next record. The table is preferably in the enabled or locked state and the entity has previously registered for sequential access for the Table Get Next Entry API to function as desired. The sequential access pointers are also updated accordingly. In a preferred embodiment the only parameters associated with this operation is the Table ID and the Sequential Access ID. The operation returns the User Data Size and User Data refer to Lookup Table AddEntry for the specification of these fields .

The Table Get Previous Entry is used to fetch the entity s sequential access pointer to point to the previous record and then fetch the latter s contents. The sequential access pointers are also preferably updated accordingly. The table is in the enabled or locked state and the entity must have previously registered for sequential access for the Table Get Previous Entry. In a preferred embodiment the properties of the table indicate that it is capable of both forward and backward traversal. In a preferred embodiment the parameters associated with this operation are the Table ID and the Sequential Access ID. The operation returns the User Data Size and User Data.

The Table Process Entry API allows the entire table or a segment of the entire table to be sequentially walked either forward or backward . In addition for every access calls a specified procedure in order to enable the latter to process the entry. The Table Process Entry API is typically used by aging routines. The specified procedure address must have previously been bound to an ordinal number that represents that address. The enabled or locked state and the entity must have previously registered for sequential access. The parameters associated with this operation are depicted in Table 10.

The Table Set Bookmark API is used with bookmarks. Bookmarks are associated with sequential table access and are used for marking a particular location or record in a table so that it is possible to directly go to the bookmark later and begin a sequential walk from the bookmarked record. If a bookmarked record is deleted the bookmark is simply moved to the next record in the chain. Bookmarks are associated with registered users. Therefore each user may maintain independent bookmarks at different record locations within the same file. The Table Set Bookmark API allows a bookmark to be set at the current sequential access point within a table. The table is in the Enabled or Locked state for use of this API. Other preconditions include configured support for sequential access and user registration. The parameters associated with the Table Set Bookmark API are shown in Table 11.

The Table Go To Bookmark API is used to initialize the sequential access pointers associated with a registered user to point to the desired bookmark of the user. If a subsequent Table Get Current Entry API is utilized then the contents of the record associated with the bookmark are returned. Similarly if a subsequent Table Get Next Entry API is utilized then the contents of the record next to the bookmarked record are returned. The table is in the enabled or locked state for this API to be successfully used. In addition support for sequential access and user registered for sequential access are already preconfigured. The parameters associated with this operation are the same as that for the Table Set Bookmark API.

The Table Start Aging API allows aging of a table to commence. When a table is defined it is possible to indicate whether aging is supported on the table and if so the Aging Procedure ID is provided refer to the Lookup Table Define API for details of the parameter . If aging is supported the Lookup Table Define API allows the user to be automatically registered for sequential access and returns a Sequential Access ID. However the aging procedure does not actually start until Table Start Aging API is used. Because the aging procedure involves sequential access the Sequential Access ID returned as part of the Table Define API operations and is provided as a parameter for this operation. The table for which the Table Start Aging API is utilized is in the enabled or locked state. The parameters associated with the Table Start Aging API are depicted in Table 12.

The Table Stop Aging API is operation is used to stop the aging function. This presupposes that aging had previously been started using the Table Start Aging API. The conditions for the table are similar to that for the Table Start Aging API. The parameters associated with this API are preferably limited to the Table ID and the Sequential Access ID used by the Table Start Aging API.

A user such as a network administrator is allowed to input information to manage the tables for the network processors and using the generic APIs in a network independent manner via step . In step therefore a user might provide the identification of the network processor desired to be controlled values of the appropriate parameters and flags as well as other information used by the API s of the generic APIs being used. The generic APIs are then used to control tables for the possibly heterogeneous network processors and in a network processor specific manner via step .

Using the system the methods and and more particularly the generic APIs the table management application can be network processor independent. Because of the use of the generic APIs the table management application can still control tables for the potentially heterogeneous network processors and in a network processor specific manner. As a result the table management application need not include a separate set of APIs for each type of network processor and used. The table management application is therefore simpler. As a result it is significantly simpler to scale the system including adding new types of network processors. It is thus also easier to improve the performance of the system by adding improved network processors. In addition the maintenance costs of the system may be reduced due to the use of a simpler table management application .

A method and system has been disclosed for managing tables for heterogeneous network processors using a network processor independent control application. Software written according to the present invention is to be stored in some form of computer readable medium such as memory CD ROM or transmitted over a network and executed by a processor. Consequently a computer readable medium is intended to include a computer readable signal which for example may be transmitted over a network. Although the present invention has been described in accordance with the embodiments shown one of ordinary skill in the art will readily recognize that there could be variations to the embodiments and those variations would be within the spirit and scope of the present invention. Accordingly many modifications may be made by one of ordinary skill in the art without departing from the spirit and scope of the appended claims.

