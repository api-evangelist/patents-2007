---

title: System and method for virtual coverage anti-aliasing
abstract: A graphics system has a mode of operation in which real samples and virtual samples are generated for anti-aliasing pixels. Each virtual sample identifies a set of real samples associated with a common primitive that covers a virtual sample location within a pixel. The virtual samples provide additional coverage information that may be used to adjust the weights of real samples.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07573485&OS=07573485&RS=07573485
owner: NVIDIA Corporation
number: 07573485
owner_city: Santa Clara
owner_country: US
publication_date: 20071213
---
This application is a continuation of U.S. application Ser. No. 10 980 078 filed Nov. 2 2004 now U.S. Pat. No. 7 333 119 and is incorporated herein by reference in its entirety.

The present invention is generally related to anti aliasing of graphics applications. More particularly the present invention is directed towards reducing the storage bandwidth and computational requirements for achieving high quality anti aliasing that conventionally requires a substantial number of samples per pixel.

Computer graphics systems represent graphical primitives as pixel elements of a display. Aliasing refers to the visual artifacts such as stair stepping of surface edges sometimes known as jaggies that occur when an image is sampled at a spatial sample frequency that is too low.

A variety of anti aliasing techniques exist to reduce visual artifacts. One example is supersampling in which an image is sampled more than once per pixel grid cell and the samples are filtered. For example in supersampling the contribution of each sample in a pixel may be weighted to determine attributes of the pixel such as the pixel color. Another example of an anti aliasing technique is multisampling. As objects are rendered in a multisampling system a single color is typically computed per primitive and used for all subpixel samples covered by the primitive. Additional background information on anti aliasing techniques used in graphics processing units GPUs may be found in several patents issued to the Nvidia Corporation of Santa Clara Calif. such as U.S. Pat. No. 6 452 595 Integrated graphics processing unit with anti aliasing U.S. Pat. No. 6 720 975 Supersampling and multi sampling system and method for anti aliasing and U.S. Pat. No. 6 469 707 Method for efficiently rendering color information for a pixel in a computer system the contents of each of which are hereby incorporated by reference.

In both supersampling and multisampling the quality of the anti aliasing tends to improve as the number of samples per partially covered pixel increases. For example increasing the number of samples per pixel from four samples 4 sampling to sixteen 16 sampling would be expected to reduce visual artifacts. However as the number of samples per pixel increases more sample data must be generated stored transported and processed. Consequently the required memory resources computing resources and memory bandwidth may increase as the number of samples per pixel is increased. As a result the cost and complexity of a graphics system tends to increase as the number of samples used for anti aliasing increases.

Therefore what is desired is an improved apparatus system and method for anti aliasing that achieves many of the same benefits associated with an increase in the number of samples per pixel but without the corresponding increase in cost and complexity associated with conventional anti aliasing techniques.

A graphics system has a mode of operation in which it determines coverage of primitives at virtual sample locations and real sample locations within a pixel. Information on virtual sample coverage is used to adjust the weights of real samples for a down filtering process. In one embodiment a real sample has color component data whereas a virtual sample has no color component data.

In one embodiment weighted samples for anti aliasing a pixel are generated by determining coverage of primitives over virtual sample locations and real sample locations and utilizing virtual sample coverage information to adjust the weights of real samples.

One embodiment of a method of generating weighted samples for anti aliasing pixels includes generating a sequence of graphical primitives for a scene detecting coverage of at least one virtual sample location by the primitives for each covered virtual sample location forming a virtual sample by identifying a set of real samples that are also covered by a common visible primitive and utilizing the at least one virtual sample to adjust the weight of at least one real sample.

One embodiment of a method of generating weighted samples for anti aliasing a pixel includes determining coverage of a sequence of primitives generated for a scene on real sample locations and virtual sample locations for each real sample location generating a real sample having at least color component information for each virtual sample location identifying a set of real samples which are covered by a common primitive and utilizing coverage information for at least one of the virtual sample locations to adjust the weight of at least one of the real samples.

The present invention generally comprises an apparatus system and method for utilizing both real samples and virtual samples for anti aliasing AA graphical primitives such as polygons and lines. An exemplary application of virtual sample module is in a multisampling system although it will be understood throughout the following discussion that virtual samples of the present invention may be utilized in other types of anti aliasing systems such as supersampling systems.

In one embodiment graphics system includes a coverage update module to calculate the fractional coverage of primitives across partially covered pixels for virtual sample locations. In one embodiment coverage update module utilizes a comparatively low precision test to determine which real and virtual samples are covered on individual pixels in order to reduce the bandwidth of information required from the rasterizer . In one embodiment a virtual sample module generates virtual samples that provide information on the coverage of primitives across pixels. For a particular pixel virtual samples are updated in response to a change in the coverage of primitives across the pixel. The virtual samples that are generated may be stored in one or more locations such as in a frame buffer color buffer z buffer or other memory location. Coverage update module and virtual sample module are illustrated at a particular location within graphics pipeline although it will be understood that they may be located in other locations such as in ROP .

Virtual sample module may in some embodiments be configured to generate and utilize virtual samples in anti aliasing calculations for specific operational conditions. In some embodiments virtual samples are utilized for anti aliasing calculations only for edge pixels i.e. only for partially covered pixels . In some embodiments coverage updates used to generate virtual samples are disabled if a z depth test operation is disabled a z depth write operation is disabled or alpha blending is enabled. In some embodiments an Application Programming Interface API provides commands for enabling disabling and configuring the use of virtual samples to update coverage information during execution of a graphics program by the CPU not shown . In one embodiment heuristics are used to determine when coverage should be updated using virtual samples. For example the heuristics may be chosen so that rendering modes that correspond to scene geometry get high quality coverage information using virtual samples but rendering which corresponds to special effects or lighting e.g. particles or multi pass geometry do not.

When a new primitive crosses one or more real samples changes to the status of virtual samples are updated. Any virtual sample locations that are covered by the primitive are updated. Additionally the status of virtual samples that used to refer to the covered real samples but which are now not covered are updated. In one embodiment a virtual sample is a pointer that maps a correspondence of a virtual sample location within a pixel to the set of real samples that are covered by a visible e.g. currently the topmost with respect to an eyepoint primitive that also covers the virtual sample location. A virtual sample is owned by a real sample if it is determined that a visible topmost primitive covers both the real sample and the virtual sample. A virtual sample is assumed to have the same color component value as the real samples that own it since they are all covered by the same primitive. For example if a real sample of a primitive has a green color then a virtual sample covered by the same primitive can be assumed to have the same green color. Table 1 illustrates an exemplary mapping for three virtual sample locations within a pixel.

The identity of virtual samples that are owned by a real sample provides additional information that can be used to adjust the weight given to R in a blending process in light of the additional coverage information provided by the virtual samples. For example if virtual sample locations are distributed within a pixel then the number of virtual samples owned by a real sample will approximately scale with the primitive coverage. Thus for example in the case illustrated in the number of virtual samples owned by real sample R may be used to assign a weight to real sample R that more closely corresponds to the actual coverage percentage of second primitive within pixel . However since each virtual sample need only contain a pointer to a real sample the memory and bandwidth requirements for virtual samples is much lower than if additional conventional real samples were taken in the interior of pixel .

Pixel is divided into a 16 16 uniform grid corresponding to 16 sampling with the number of real and virtual samples selected to total up to sixteen. A pre selected number of real sample locations such as real samples and are arranged on the 16 16 grid. For each real sample location a conventional real sampling technique may be used to calculate a full set of conventional sample attributes such as color component values z depth values or other sample attributes. In one embodiment there are twelve virtual samples A B C D E F G H I J K and L arranged on the same 16 16 uniform grid as real sample locations and . In the example illustrated in the real samples are located near the borders of the 16 16 uniform grid since this maximizes virtual sample coverage.

Since each virtual sample is a pointer it requires much less data than a conventional real sample. As an illustrative example in one embodiment each real sample is at least 32 bits and may contain for example a 32 bit z depth or stencil value and a 32 to 128 bit color component value. Each virtual sample requires only sufficient bits to point to all the real samples in a pixel that own it which as described below in some embodiments requires only 1 bit per real sample e.g. four bits assuming 4 real samples . Thus the memory storage and bandwidth requirements for virtual samples are only a small fraction of that of real sample.

In one embodiment a bitcode is used to assign ownership of a virtual sample to one or more real samples. For example in an embodiment in which there are 12 virtual samples and 4 real samples each real sample may have a preselected bit code e.g. bit codes 0001 0010 0100 and 1000 . Thus a virtual sample owned by a single real sample may be assigned the same bit code as the real sample.

Virtual samples owned by more than one real sample are indicated by a bit code indicating the set of real samples that own the virtual sample. For example the virtual sample bit code may have one bit location in the bit code to represent each real sample that owns the virtual sample. For example a four bit bitcode has one bit position for each of four real samples. The set of real samples that own a virtual sample can thus be identified by bit positions having a value of 1 e.g. a bit code of 0001 indicates that the virtual sample is owned by a real sample assigned the first bit position but is not owned by any of the other real samples whereas a bit code of 1001 indicates that the virtual sample is owned by both the real sample assigned the first bit position and by the real sample assigned the fourth bit position .

In one embodiment a logical OR operation is performed on the bit code of each real sample that owns a virtual sample to generate a bitcode that identifies the set of real samples that owns the virtual sample. For example a virtual sample that is covered by the same primitive which covers real samples 0001 and 1000 would have after a logical OR operation on 0001 and 1000 a bitcode of 1001.

The set of bitcodes for all of the virtual samples of one or more pixels forms a virtual coverage buffer. As a new primitive is received the virtual coverage buffer is updated to reflect any changes in ownership of the virtual samples. The virtual coverage buffer may for example be stored in a portion of AA buffer or other memory location.

In the example of it is assumed that one primitive covers the entire pixel grid of pixel as indicated by the uniform shading of the entire 16 16 grid. For this case all of the virtual pixels are assigned a default value e.g. 1111 as indicated in Table 2 indicating that each virtual sample is owned by all four real samples. In one embodiment the default 1111 value is also assigned to all virtual samples at the beginning of each scene as part of a clear step such as a z depth buffer clear step performed prior to a new scene.

As new primitives are rendered the situation may arise that a new primitive is drawn on top of a real sample such that virtual samples which previously were owned by a visible real sample become orphaned. This case is illustrated in . In the example of a new triangle is on top of a previously received triangle . As a result new triangle covers real sample and also covers virtual sample L. Virtual samples I H and J associated with triangle are now orphaned in that they are not owned by any visible real samples.

A rule is required to deal with orphaned virtual samples. For example while the virtual sample bit code could be set to zero to indicate no coverage for orphaned samples this might result in a later anti aliasing operation overweighting one or more of the real samples. In one embodiment each orphaned virtual sampled has its virtual sample bit code set to be that of the closest real sample within the pixel. For example orphaned virtual sample H is closest to real sample . Consequently orphaned virtual sample H may be assigned the bit code of real sample . Conversely orphaned real samples I and J are closest to real sample and are assigned the bit code of real sample . Table 5 summarizes the bit codes for the virtual samples after the orphaned samples are assigned to the closest real samples.

As can be understood from the previous discussion of sliver triangles and orphaned virtual samples the anti aliasing quality tends to scale with the number of real samples used per pixel. The anti aliasing quality also depends upon the types of graphical objects being rendered with for example lines being likely to require more real samples than polygons to achieve comparable AA quality. In one embodiment graphics system has a plurality of modes that tradeoff memory space and bandwidth for anti aliasing quality. It is contemplated that the modes could be set either statically e.g. for an entire graphics program or dynamically using an API depending upon the desired level of AA quality and the type of graphics scenes to be rendered. For example in a 16 anti aliasing system the number of real samples could be selected to be 2 3 4 5 6 7 or 8 real samples with the rest of the 16 samples being virtual samples. For example in one embodiment the quality settings for 16 AA vary from 2 4 6 or 8 real samples and 14 12 10 and 8 virtual samples respectively. For 16 coverage quality the equation for bytes of bandwidth and storage is 64 16 80 where R is the number of real samples per pixel. illustrates a plot of the corresponding tradeoff between aliased bandwidth and real sample count.

In one embodiment data storage requirements for virtual samples are reduced by including an algorithm to make certain ownership bit patterns invalid. Quality loss can be avoided by carefully choosing these invalid patterns such that the probability of any pattern occurring is minimized. Conceptually this is performed by drawing a circle of influence around every real sample. If a virtual sample is located within a real sample s circle then the real sample is a legal owner of that virtual sample. If not then the real sample is not a valid owner and its ownership mask is always considered to be 0. When writing data to the coverage buffer these forced zeros are skipped when reading they are added. This allows a 4 12 virtual coverage AA mode to be stored in 32 bits rather than the typical 48. The rules applied to limit virtual coverage bit patterns will depend upon the number of real samples and their distribution in a pixel. For 4 12 X virtual coverage anti aliasing the convex hull of the 4 real samples is a quadrilateral with vertices at the real samples. In one implementation the 4 virtual samples near the pixel center are allowed to reference all 4 real samples while the 8 remaining virtual samples may only reference 2 real samples. These specifics are different for alternate sample patterns for example 4 12 Y modes where the convex hull is a triangle with the fourth real sample located at approximately the centroid .

As previously described the virtual samples provide additional information on pixel coverage and may be used to adjust a weight given to real samples in anti aliasing. For example since a virtual sample is assumed to have the same color as the real samples that own it in one embodiment the number of sample counts for a particular color can be increased by the number of corresponding virtual sample counts and then be scaled by the total number of real and virtual samples. However more generally an arbitrary weighting function may be used for weighting real samples as a function of the virtual samples that they own.

It is desirable to reduce the computational effort required to calculate real sample weights during a down sampling process to resolve an anti aliasing buffer. Since a virtual sample can point to more than one real sample it is desirable to utilize a weighting algorithm that avoids unnecessary renormalization calculations. In one embodiment a virtual sample contributes to the weighting only of the closest real sample to which it points e.g. the closest real sample with a 1 in a bitmask . An exemplary weighting algorithm for determining weights from the coverage buffer bitmask during a down sampling process is as follows 

The final pixel color is calculated during anti aliasing using the weights calculated for the real samples. An exemplary algorithm for computing the final pixel color as a weighted average of the real sample colors color r is as follows 

In one embodiment graphics system automatically falls back into a conventional anti aliasing mode utilizing only the real samples when the coverage information alone for the virtual samples is insufficient. This guarantees a minimum AA quality for any type of rendering. By way of comparison some A buffer and fragment AA techniques have failure modes that introduce artifacts which aren t present in normal multisampling e.g. bleed through A buffer merge artifacts or drop AA quality to effectively zero such as during stencil buffer rendering. By gracefully dropping back to 4 rotated multisampling or more accurately the number of real samples in cases where coverage information alone is insufficient stencil rendering is the most notable example the algorithm of the present inventing provides a graceful failure mode.

In one embodiment during a down sampling process to resolve the AA buffer each virtual sample s weight is summed up by finding the highest priority bit set where priority is defined by proximity to the real samples. Searching the bits in priority order facilitates a graceful fallback to 4 rotated AA in cases where the virtual coverage buffer may not contain enough information e.g. stencil only rendering alpha blending .

Note that the check for valid owners the assertion in the last line can be performed either during an update or during a downfilter. The two operations are equivalent and the results identical.

The present invention provides a number of benefits. As previously described each virtual sample requires less data than a real sample. Consequently high quality AA may be achieved for a particular number of real and virtual samples with reduced data storage and bandwidth requirements compared with sampling with the same total number of real samples. Additionally it is highly scalable order independent compatible with a low cost hardware implementation does not suffer from bleed through is compatible with different color and depth buffer formats and has a graceful failure mode in which it falls back to a minimum AA quality.

While one embodiment of the present invention includes a plurality of real samples and virtual samples locations within each individual pixel it will be understood that other arrangements are also contemplated. For example in an alternate embodiment there is one real sample per pixel and one virtual sample. For example each pixel may share one virtual sample with each of its four neighbors. Thus in this embodiment a pixel has one real sample and four virtual samples arranged along its four edges. In this example the downfiltering would be a weighting of the one real sample and the real samples of neighboring pixels.

The foregoing description for purposes of explanation used specific nomenclature to provide a thorough understanding of the invention. However it will be apparent to one skilled in the art that specific details are not required in order to practice the invention. Thus the foregoing descriptions of specific embodiments of the invention are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed obviously many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications they thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the following claims and their equivalents define the scope of the invention.

