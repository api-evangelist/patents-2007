---

title: Visual creation of object/relational constructs
abstract: Visual controls such as drag and drop are utilized to create object-oriented constructs from corresponding relational constructs, for instance. Similarly, an object-relational map can be generated between the relational constructs and the created object-oriented constructs to facilitate interaction across disparate programmatic models.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024701&OS=08024701&RS=08024701
owner: Microsoft Corporation
number: 08024701
owner_city: Redmond
owner_country: US
publication_date: 20070327
---
This application is related to U.S. patent application Ser. No. 11 669 966 filed Feb. 1 2007 and entitled VISUAL ASSOCIATION CREATION FOR OBJECT RELATIONAL CLASS DEVELOPMENT and U.S. patent application Ser. No. 11 669 968 of even date and entitled VISUAL CONTROLS FOR STORED PROCEDURE AND OBJECT RELATIONAL CLASS DEVELOPMENT. The entireties of these applications are incorporated herein by reference.

Integrated development environments IDEs provide a common platform and design tools for modern software development. While software is often the most time consuming and highest risk aspect of electronic program development it also holds the greatest potential to enhance a design for multiple target applications. Such design tools allow designers to efficiently develop code where graphical user interfaces GUI automate and simplify configuration of complex programming projects. These tools also enable designers to create source code by enhancing code readability and simplifying code writing. For instance source code editor features may include syntax coloring auto indenting and shortcut menus that link stored procedure calls to their definitions declarations and usages even when these references reside in separate files. Other aspects of the tools include simulation resources to allow designers to develop and debug applications.

One area of software development that is performed on IDEs includes mapping class objects to relational objects referred to as O R mapping and is the latest advancement in modern day programming technologies. It improves productivity of programmers by many degrees while providing flexibility to adapt to changing business needs. While O R technology itself provides many benefits to programmers enabling O R classes to be created and set up correctly is not an easy task for normal development nor is it well supported in current programming tools. Without providing adequate tools support programmers trying to adopt the technology may be forced to write their respective code manually.

One purpose driving O R technologies is the need to interface the relational database world with the models supported in the object oriented programming world. For example relational database management systems RDBMS supporting a relational database pre dated the popularization of object oriented programming in the 1990s. Using relational databases to store object oriented data leads to a semantic gap where programmers would be required to allow their software to function in two different worlds processing of data would be performed in object oriented form but the same data would have to be stored in relational form.

Requiring this constant conversion between two different forms of the same data not only had the effect of stifling performance but also imposed difficulties for programmers as relational or object oriented forms would impose limitations on each other. For example relational databases make complicated associations difficult and they tend to map poorly into the object oriented world since they fail to implement the relational model s user defined types. This problem is sometimes referred to as the Object Relational impedance mismatch.

Generally relational databases use a series of tables representing simple data where optional or related information is stored in other tables. A single persistent object record in the database often spans several of these tables and requires a join to collect all of the related information back into a single piece of data for processing. This would be the case for an address book example which would likely include at least a user and address table but perhaps even a phone number table as well. In the object world there is a clear sense of ownership where a particular person object owns a particular phone number in the above example. This is not the case in relational databases where the tables have no understanding how they relate to other tables at a fundamental level. Instead the user must construct a query to gather information together. Queries not only request what information to return but also need to know how the tables involved are related to each other illustrating the point that tables do not know their relationships when they are residing in the database. Thus these relationships are typically only known when a query is run to specify the relationships. Relational databases which attempt to implement the Relational Model do maintain relationships via constraints but the Structured Query Language SQL for example is generally unaware of these.

When creating Object Relational O R classes by mapping class objects to database objects it is important to also set correct associations between related objects so that applications written on top of these objects can easily take advantage of such relationships. Hand coding such relationship is not a trivial task for typical developers. While the O R technology itself provides many benefits to programmers manually having O R classes created and set up correctly is not a straightforward or simple task. With current development tools support programmers trying to adopt O R technology are often forced to write code manually which detracts from the utility of such tools.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to a development system or designer to facilitate construct creation and mapping. More particularly visual controls can be employed to facilitate automatic generation of an object oriented construct and or associated object relational mapping. Mechanisms are provided that enable programmers to visually map relational constructs and object oriented constructs by depositing a relational construct onto a workspace or design surface. Code generation is done transparently behind the scenes to limit or eliminate manual coding. This simplifies O R programming and encourages adoption of the technology.

In accordance with an aspect of the disclosure a development system is provided. The system includes an interface component to receive or otherwise identify select constructs and a creation component that creates or defines a corresponding structure. Automated creation of an object oriented structure for instance is initiated by selection of a relational construct and adding it a workspace or designer.

According to another aspect of the disclosure the development system includes a mapping component coupled to the interface and creation components. The mapping component generates a map between a select construct and a created construct such as an object relational mapping between a relational and object oriented construct. This mapping facilitates interaction amongst disparate data models. Similar to the creation component the mapping component can also be visually initiated by dropping a construct on a workspace.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods are provided to facilitate program development. Visual mechanisms can be employed to initiate automatic generation of constructs of a first type from constructs of a second type. For example relational constructs such as databases tables and the like can be dragged and dropped upon a design surface or workspace to initiate generation of corresponding object oriented constructs. Furthermore a map can be created to facilitate interaction amongst constructs of disparate programmatic models such as those associated with relational and object oriented programming.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a construct development system is illustrated in accordance with an aspect of this disclosure. The system is operable to create constructs of a first type from a construct of a second type automatically. In one instance such functionality can be employed with respect to generation of object oriented constructs from corresponding relational constructs. This is quite useful as conventionally object oriented constructs and associated mappings are handwritten with little if any help from a development environment which is not a simple task for average programmers. Among other things the functionality associated with the development system can be embodied as a component of an integrated development environment IDE as an application programming interface API or the like.

The development system includes an interface component that receives relational constructs or identification thereof. As will be described further infra receipt of these constructs can be provided via deposit of the constructs or a representation thereof onto a design surface or workspace. Examples of relational constructs or more generally database constructs that can be received by the interface component are databases tables stored procedures table value functions and views among other things. The interface component is communicatively coupled to creation component to enable provisioning of constructs.

The creation component receives retrieves or otherwise acquires one or more constructs obtained by the receiver component and generates a corresponding construct or constructs. In particular the creation component can create an object oriented construct from an identified relational construct or vice versa. For example if the relational construct is a table the creation component can generate a class of the same or similar name including column names as class properties. In one instance the creation component can acquire information about an identified relational construct from a context file associated there with and utilize this information to create the corresponding object oriented structure.

The creation component can also perform analysis on a provided or identified construct to determine an appropriate matching construct. Accordingly the component need not simply utilize a predetermined one to one mapping. By way of example consider identification of a database with two columns is identified such as a lookup table. Rather than creating a class with two properties corresponding to an id and another column name the creation component can recognize that this structure resembles a simple dictionary table and choose to create an enumeration.

It should be appreciated that the development system is quite flexible in creation of corresponding constructs. While an entire database can be placed on a workspace and subject to generation of one or more corresponding constructs this is not required. The development system can be much more granular and allow users to pick and choose constructs with which they desire to work. Among other things this enables development flexibility and efficiency since an entire database need not be subject to mapping but rather only those constructs needed.

Referring to a representative creation component is illustrated to facilitate description of additional functionality. The creation component can include a construct definition component and a code generation component . The construct definition component can produce definitions of created structures such as class definitions including properties and methods. These definitions can be defined independent of a particular language implementation for instance as an XML eXtended Markup Language document. Accordingly as relational constructs are received such a document can be updated to include created object oriented constructs. This definition can be employed by the code generator component to generate target language code for example in C Visual Basic or Java among others. For example upon initiating a save of the created constructs the code generator component can be invoked to translate the constructs into a designated programming language. Accordingly the creation component can output a target language independent or internal representation of created constructs and or a language specific representation.

The creation component can also include a configuration component to facilitate language translation. For example since relational databases tables tend to be defined as plural entities the configuration component can singularize table names or alternatively pluralize singular names where needed. For instance a table entitled customers can be converted to a singular customer class. The configuration component can aid such transformation with the help of a dictionary or the like. Furthermore such transformations can occur in any language.

Additionally the configuration component can assist in converting types specific to databases to known language types. By way of example the SQL varchar database type can be converted to a string for a target language such C or Visual Basic. Still further yet the configuration component can aid in generation of valid names for particular languages as databases sometimes allow characters that are not valid. For instance if a name has a space the configuration component can replace the space with an underscore character where necessary.

Turning to a representative interface component is provided in accordance with an aspect of the claimed subject matter. As previously described the interface component can receive relational constructs to facilitate creation of corresponding object oriented constructs among other things. In one instance the interface component can form part of and or interact with an integrated development environment.

The interface component can include a workspace component that affords a graphical region for designing programs or portions thereof In other words elements of a program API library or the like can be visually and or graphically compiled on the workspace to facilitate development. Also included is a data component . The data component identifies one or more available data sources such as databases tables and associated structures and or methods. These sources can be displayed in an organized fashion with associated text and or icons to aid identification thereof. In this manner the data component provides an explorer of one or more databases and or elements thereof.

Selection component and drag and drop component provide mechanisms for interacting with a workspace and or displayed data. More particularly the selection component enables data to be selected for example via point and click voice recognition and or other gesturing. In this manner a data element of interest can be identified. The drag and drop component enables a selected item or copy thereof or identifying information to be deposited onto the workspace. This enables the selected item to be added to a program project or the like. By way of example a database table can be selected and subsequently dragged and dropped onto the workspace. Alternatively the same table may be added to the workspace by alternative means including without limitation via a command to add the table to the workspace.

Alteration component enables a user to edit a workspace item or representation thereof. For example a user can change attributes associated with an item such as the item s name or type. This can be accomplished through a separate interface window and or directly on the item in workspace. Additionally or alternatively the alteration component enables items on a workspace to be related or associated. In this manner the alteration component allows a user to customize workspace items and facilitate program design.

Turning first to screenshot illustrates an exemplary integrated development environment. Included therein is a workspace designer onto which programmatic items can be placed and or interacted with to generate a program application programming interface library or the like. The environment also includes a windowpane for display of data items or elements. In this instance a data hierarchical structure is shown with text and mechanisms to expand and collapse items to aid structure navigation. Also provided is a tool bar windowpane for selection of an interface mechanism. Here a pointer is identified as the selection mechanism.

In accordance with an aspect of the claimed subject matter a database construct can be selected from the data pane and dragged on dropped onto the workspace . In this case the database table employee is selected and deposited onto the workspace . Here that is denoted by the dashed line box around employee and the tool tip by the same name indicated it is being dragged onto the workspace . This action can initiate creation of an object oriented construct that corresponds to the employee table rather than simply placing a copy of the table thereon. As shown a class employee is created automatically from the employee table and presented to a user. Each table column name is translated into a class property and class methods are also created to facilitate interaction with class data e.g. store retrieve update delete . . . .

Once generated users can alter the class in a number of ways. For example property windowpane can be utilized to alter property names values and or types among other things. Further yet a user way simply select and modify the class directly in the workspace . For example the property HireDate could be renamed StartDate among other things.

Screenshot of illustrates the addition of another element to the workspace . In particular an employee address table is selected and added to the workspace . A corresponding class named employee is generated upon the addition including one or more properties and methods. It can also be noted that it that the employee class is related to the employee address class perhaps by associated keys e.g. primary foreign . This relationship or association can then be captured and is represented graphically by the arrow connecting the classes and . This can be done automatically and or manually. It is important to set correct associations between related objects so that applications written on top of these objects can easily take advantage of such relationships.

Referring to a development system is depicted in accordance with an aspect of the claimed subject matter. Similar to system of system includes the interface component and creation component as described supra. In brief the interface component receives a construct such as a relational construct and the creation component acquires this construct and generates a corresponding construct such as an object oriented construct. Hence a database schema can be translated to a program language schema. In addition to creating a corresponding construct a map between constructs can be created by map generation component . The map generation component can acquire a first construct from the receiver component and a generated corresponding construct from creation component and generate a map between the constructs.

The map can facilitate interaction between the constructs. In one instance the map can be an object relational mapping. In this manner an object model can be mapped to the relational model to enable object model data to be persisted to and or retrieved from a relational model or vice versa. By way of example the mapping may map a class method to a SQL language implementation and or a SQL language implementation to a class method. The impedance mismatch can thus be bridged by the generated map.

Constructs can be preexisting and or generated by hand alone or in combination with help from design tools. System includes an identifier component that identifies or discovers such preexisting and or alternately generated constructs and provides them to the map component for generation of an appropriate map or mapping.

By way of example and not limitation a user can hand code a class corresponding to a relational database table. Subsequently the same user can drag and drop the table into a workspace. The identify component can acquire the table identify the associated class and cause the object relational mapping to be generated by the map component . Similarly if there is a pre existing mapped class and the underlying database schema changes a user could drag and drop the table over the class and the class and or mapping can be updated refreshed base on the new database schema.

As a result the development system is flexible with respect to construct and map generation. In one instance corresponding constructs and associated maps can be created automatically by the system for an identified construct. Additionally or alternatively related constructs can be constructed by hand or other conventional mechanism and a mapping generated automatically. All such functionality can be implemented in a visual fashion to facilitate easy specification via a mechanism like drag and drop.

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. For example the configuration component and or associated functionality can be included within one or both of the construct definition component and the code generator component . Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems and methods may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation the creation component can employ such mechanisms select and construct construction of an appropriate construct. Similarly the mapping component can utilize these mechanisms to infer maps between constructs given a particular context.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to construct creation method is illustrated in accordance with an aspect of the claimed subject matter. In one instance method can be employed by an integrated development environment to assist program development. At reference numeral a construct is acquired. For example a relational construct such as a database table store procedure view can be received or otherwise identified. At numeral a corresponding construct is created for the acquired construct. In once instance an object oriented construct is created that corresponds or maps to a received relational construct. It should be appreciated that the created construct can be a definition of the construct for example in an XML document. The actual construct can subsequently be generated in a target programming language utilizing the generated definition.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers . For example programs can be designed on client s that interact with data housed by server s or more specifically server data store s . Constructs can be created from schema associated with a remote database. Furthermore maps can be created to facilitate interaction amongst client s and a server s to enable data to be accessed updated inserted and or deleted over disparate data models across the communication framework .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

