---

title: Navigation through components
abstract: This disclosure provides various embodiments of software for navigating through components. In one aspect, the software associates a transactional process with a first component, triggers navigation from the first component to a second component, and performs the transactional process associated with the first component upon triggering navigation from the first component to the second component. In some implementations, the transactional process comprises validating modifications made to the data of the first component. In other implementations, the transactional process further comprises saving the modifications to the data of the first component if the validation is successful, and if the validation is unsuccessful, not saving the modifications to the data of the first component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07769698&OS=07769698&RS=07769698
owner: SAP AG
number: 07769698
owner_city: Walldorf
owner_country: DE
publication_date: 20070322
---
This application claims the priority under 35 U.S.C. 119 of Provisional Application Ser. No. 60 841 860 filed Sep. 1 2006.

This document relates to electronic data processing and more particularly to application programming for navigating through components.

Applications can be developed using various architectures including for example a model view controller MVC architecture. The MVC architecture breaks an application into three separate parts models views and controllers. Each model may have multiple views where each view displays information about the model to a user. A controller of the model receives events for example raised by a user interacting with a view to manipulate the model. Each model may have multiple controllers and a controller may relate to multiple views. When changes occur in the model the model updates its views. Data binding may be used for data transport between the view and its model or controller. For example a table view may be defined to display data of a corresponding table that is stored in the model or controller. Further the table view may be replaced by a further view such as a graph view that binds against the same table.

Application development is often divided into two general stages design time and runtime. With respect to the MVC example above the design time stage may include steps such as designing the views of an application including the layout of the user interface elements in each view modeling of the application flow including the selection of the views to be displayed designing one or more models and creating and editing other application elements such as controllers and contexts. The design time stage may also include the binding of user interface UI elements within views to data sources that are defined in a data type repository. Information created during the design time may include application metadata. Application metadata may be stored in a metadata repository and used as input to the runtime process. During the runtime process the application metadata may be used to generate the actual runtime code of an application. In some implementations the application metadata is platform independent and the generated runtime code is platform specific. The runtime code may be executed in a runtime environment that provides a general framework for running applications. For example a runtime environment may provide services for deploying and maintaining applications as well as features such as a caching mechanism that may be used to improve performance and automatic input assistance and default error handling that is based on the declared application metadata.

This disclosure provides various embodiments of systems methods and software facilitating navigation through components. In one aspect the software associates a transactional process with a first component triggers navigation from the first component to a second component and performs the transactional process associated with the first component upon triggering navigation from the first component to the second component. In some implementations the transactional process comprises validating modifications made to the data of the first component. In other implementations the transactional process further comprises saving the modifications to the data of the first component if the validation is successful and if the validation is unsuccessful not saving the modifications to the data of the first component.

While generally described as software some or all of these aspects may be further included in respective systems or other devices for executing implementing or otherwise supporting a suitable software application. The details of these and other aspects and embodiments of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the various embodiments will be apparent from the description and drawings and from the claims.

As such the business application may provide a technique for navigating through components while retaining some or all of the changes made by the various users of the applications to the data presented. In some cases this component may contain objects like views models and controllers. For example navigation from a view set in a component A to a view set in component B may occur by triggering so called outbound plugs. The outbound plug attached to A is typically linked to an inbound plug of B. Triggering the outbound plug automatically facilitates business application to leave the view of A and to visualize the one from B. This A view may be surrounded with or otherwise associated with a transactional process so that when one leaves this view a validation and a save of the work done on data in A could be done. Of course the validation can lead to some error messages that may in some cases result in denying the navigation request. For instance the component may represent one application unit which may involve with some data offering the possibility to view and or to change it. Data may be shown as a table according to the Object Identification Pattern OIP Object Data Pattern ODP pattern. The application unit where data can be changed can be triggered within a transaction. In the OIP sight the developer may work with one line of a table at a time which may mean changing to another line leads to a process of saving the data beginning with a validation part . The developer may also save the work explicitly moreover there is typically the possibility to go away by clicking some other link in the menu leading him to quit the current component.

Turning to environment may include or be communicably coupled with a server one or more clients and a network . The server includes memory and one or more processors and comprises an electronic computing device operable to receive transmit process store or manage data associated with the system. Generally this disclosure provides merely one example of computers that may be used with the disclosure. As used in this document the term computer is intended to encompass any suitable processing device. For example the environment may be implemented using computers other than servers as well as a server pool. Indeed the server may be any computer or processing device such as for example a blade server general purpose personal computer PC Macintosh workstation Unix based computer or any other suitable device. In other words the present disclosure contemplates computers other than general purpose computers as well as computers without conventional operating systems. The server may be adapted to execute any operating system including Linux UNIX Windows Server or any other suitable operating system. According to one embodiment the server may also include or be communicably coupled with a web server and or a mail server.

Memory may include any memory or database module and may take the form of volatile or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. For example the memory may store classes frameworks applications backup data jobs or other information that includes any parameters variables algorithms instructions rules or references thereto. The memory may also include any other appropriate data such as VPN applications firmware logs and policies firewall policies a security or access log print or other reporting files HTML files or templates and others. Illustrated memory may contain reference or otherwise store a component repository that stores one or more component instances . In other words each logical component may have more than one instance or none if it is not currently utilized across multiple applications such as for example illustrated business application .

This MVC architecture generally allows developers to separate model functionality from the presentation and control logic that uses that functionality. Such separation allows multiple views to share the same enterprise data model thereby facilitating support of multiple clients by perhaps making it easier to implement test and maintain certain MVC functionality. As described above the models views and controllers that make up an MVC application may be structured as reusable components. is a block diagram of one example of a reusable component in an MVC application. As described earlier the component is a reusable entity providing functionality that may be used by many applications or that may be used multiple times by the same application . Components may be embedded in other components or portions thereof and may have any number including zero of visual representations. In other words component that is not associated with a visual representation may not be displayed. Components may be embedded within the business application another application or even within another component. The application or component that embeds the component may be referred to as a component embedder for the component and the component may be referred to as the embedded component. Components may also be encapsulated in development components and may be surrounded by a transaction process able to recognize navigation from one component or view to a second component or view.

The transactional process may be an agent daemon object service or other software that is reactive to certain events occurring in or upon its associated component. The transactional process may intercept signals and events concerning the associated component or the component may actively supply the transactional process with notification and data regarding the signals and events it receives and or transmits. The transactional process may be defined such that the transactional process may implement or cause certain events and or actions to be taken when specific signals commands or events that relate to the associated component occur. For instance when a user navigates to a component associated with a transactional process the transactional process may begin to log the changes to the data stored within the component. In another example navigation away from a component associated with a transactional process may activate certain save conditions such that the data of the component may be validated and saved when the navigation event is received by the transactional process. In such situations the transactional process may cause outside agents or software to save and or validate the data of the associated component or the transactional process may perform the validation and or save itself through its internal capabilities.

As illustrated component may provide three separate interfaces a programming interface a data binding interface and a visual interface . The programming interface may be used by the component embedder to interact with the component . In some cases the component interface can be considered an active component. The component interface defines the component methods that may be visible to the component embedder and routes the visible method calls to one or more component implementations. The component embedder embeds the component by programming to the programming interface i.e. the component embedder may call the methods provided by the programming interface . In one implementation the programming interface may be provided by a controller referred to as a component interface controller. Thus a component embedder may interact with an embedded component through the interface controller of the embedded component . The component may also have one or more visual representations herein referred to as views . A component embedder may access and use the views of the component through a visual interface . The data binding interface may be used by a component embedder to exchange data with the component .

In one implementation the component may include one or more controllers one or more associated contexts and one or more views. The controllers may be used to implement the logic of the component and the views may provide a visual representation of the component. Additionally component may include multiple types of controllers. The controllers implement event handlers that may be executed in response to an action performed by a user e.g. pressing a button or making a menu selection. Each controller may be bound to an associated context. The context is a local data structure of a controller that stores data and state specific to the controller.

Component usage object provides life cycle management of the associated component by providing methods for creating and deleting component instances of the associated component at runtime. The life cycle of the component instance may be controlled by the component embedder . At design time an application programmer programs using a programming interface for a component without specifying a particular implementation of the component . At runtime the component embedder creates the component instance implementing the component programming interface used by the component embedder by calling the methods provided by the component usage object . The component usage object responds to requests to create a component in the component repository that implements the desired programming interface and creates an instance of the selected component . Alternatively if the application programmer specifies a component implementation at design time an instance of the specified component may be created and used at runtime.

At runtime the component usage object may be used to access the programming interface of the associated component. The component usage object may also be used to manage event subscriptions for the associated component . In an implementation where a component embedder may subscribe to events generated by embedded components the component usage object caches the event subscriptions for subscripting components because the subscribing component may have not been created or because it may have been deleted . In such a situation the event subscriptions may be delivered to the subscribing component when the subscribing component is instantiated. Component usage object may include a context mapper that maintains context mappings between the component embedder and the component instance . The component usage object may cache specified context mappings for a component that has not been instantiated and create the specified context mappings for the component after the component has been instantiated.

Context is a local data structure for a controller that stores data and state specific to the controller. Controllers within a component i.e. the interface controller the configuration controller the component controller the custom controllers and the view controllers communicate data by mapping contexts. Similarly the data binding interface allows the component embedder to communicate data with the embedded component by mapping the interface context and the configuration context using the context mapper .

The visual interface may have more than one view of which only some views may be visible at any given time. The views that may be visible in the visual interface may change either automatically or in response to input from the user. Inbound plugs outbound plugs and navigation links are design time constructs that may be used by application developers to specify transitions between the views. Each view may have an inbound plug and an outbound plug . At design time each navigation link establishes a potential transition from the view with the outbound plug to the view with the inbound plug . At design time a transition from a first view to a second view may be specified by connecting the outbound plug of the first view to the inbound plug of the second view. In some implementations the first view may reside in a first component while the second view resides within a second component. The navigation links may be processed at runtime to cause the view transitions specified at design time. At runtime based on user input or some programmed event the application calls the outbound plug of the first view to cause a transition from the first view to the second view.

An inbound plug may include an application specific event handler and calling the inbound plug results in running the event handler for the inbound plug prior to displaying the view corresponding to the inbound plug . Navigation links are typically processed by calling the inbound plugs connected to an outbound plug when the outbound plug is called. The event handler for an inbound plug may call the outbound plug for the view corresponding to the inbound plug to cause other views connected to the outbound plug to be displayed. The application can use the event handler for the inbound plug to initialize the corresponding view e.g. the corresponding view may be initialized based on why the view is being displayed.

The view may have an associated view controller that includes the event handlers associated with the inbound plug . The view controller may also contain event handlers for the UI elements in the view as well as the presentation logic for the view.

The business application or a component may specify any number of views at design time any of which may be displayed at runtime. The set of views that may be displayed is referred to as the view composition or window of . Each component may have one or more windows associated with an interface view. By embedding the interface view at design time users of the business application may see the corresponding view composition or window at runtime. A view assembly is the set of views that are actually displayed at runtime. The view assembly for an application or a component consists of views in the view composition that are selected for display at a certain point in time. When a navigation is processed at runtime a particular view in the current view assembly may be replaced by one or more destination views from the view composition which would be tracked or otherwise monitored by the transactional process.

Returning to illustrated server also includes a processor . The processor executes instructions and manipulates data to perform the operations of the server such as for example a central processing unit CPU a blade an application specific integrated circuit ASIC or a field programmable gate array FPGA . Although described as a single processor in the server multiple processors may be used according to particular needs and reference to processor is meant to include multiple processors where applicable. In certain embodiments the processor executes business application and development application .

At a high level business application is any application program module process or other software that may execute change delete generate or otherwise request or implement batch processes according to the present disclosure. In certain cases environment may implement a composite application . For example portions of the composite application may be implemented as Enterprise Java Beans EJBs or design time components may have the ability to generate run time implementations into different platforms such as J2EE Java 2 Platform Enterprise Edition ABAP Advanced Business Application Programming objects or Microsoft s .NET. Further while illustrated as internal to server one or more processes associated with application may be stored referenced or executed remotely. For example a portion of application may be a web service that is remotely called while another portion of application may be an interface object bundled for processing at remote client . Moreover application may be a child or sub module of another software module or enterprise application not illustrated without departing from the scope of this disclosure. Indeed application may be a hosted solution that allows multiple parties in different portions of the process to perform the respective processing. For example client may access business application once developed on server or even as a hosted application located over network without departing from the scope of this disclosure. In another example portions of business application may be developed by the developer working directly at server as well as remotely at client .

More specifically business application may be a composite application or an application built on other applications that includes an object access layer OAL and a service layer. In this example application may execute or provide a number of application services such as customer relationship management CRM systems human resources management HRM systems financial management FM systems project management PM systems knowledge management KM systems and electronic file and mail systems. Such an object access layer is operable to exchange data with a plurality of enterprise based systems and to present the data to a composite application through a uniform interface. The example service layer is operable to provide services to the composite application. These layers may help composite application to orchestrate a business process in synchronization with other existing processes e.g. native processes of enterprise base systems and leverage existing investments in the IT platform. Further composite application may run on a heterogeneous IT platform. In doing so composite application may be cross functional in that it may drive business processes across different applications technologies and organizations. Accordingly composite application may drive end to end business processes across heterogeneous systems or sub systems. Application may also include or be coupled with a persistence layer and one or more application system connectors. Such application system connectors enable data exchange and integration with enterprise sub systems and may include an Enterprise Connector EC interface an Internet Communication Manager Internet Communication Framework ICM ICF interface an Encapsulated PostScript EPS interface and or other interfaces that provide Remote Function Call RFC capability. It will be understood that while this example describes the composite application it may instead be a standalone or relatively simple software program. Regardless application may also perform processing automatically which may indicate that the appropriate processing is substantially performed by at least one component of system . It should be understood that this disclosure further contemplates any suitable administrator or other user interaction with application or other components of system without departing from its original scope. Finally it will be understood that system may utilize or be coupled with various instances of business applications . For example client may run a first business application that is communicably coupled with a second business application . Each business application may represent different solutions versions or modules available from one or a plurality of software providers or developed in house.

The development application may be any software operable to invoke or execute certain described processes. In some implementations the development application may implement MVC technology to develop business application or create and initialize components and component instances among other functionality. Regardless of the particular implementation software may include software firmware wired or programmed hardware or any combination thereof as appropriate. Indeed development application may be written or described in any appropriate computer language including C C Java Visual Basic assembler Perl any suitable version of 4GL as well as others. For example the development application may help implement a business application where the business application portions may be implemented as Enterprise Java Beans EJBs or the design time components may have the ability to generate run time implementations into different platforms such as J2EE Java 2 Platform Enterprise Edition ABAP Advanced Business Application Programming objects or Microsoft s .NET. It will be understood that the development application may not only include any number of sub modules such as applications and third party modules but it may instead be a single multi tasked module that implements the various features and functionality through various objects methods or other processes. While described as internal to the server one or more processes associated with development application may be stored referenced or executed remotely. For example a portion of the development application may be a local library or process while another portion of the development application may be an interface object bundled for processing at a remote client. In another example the majority of processes or modules may reside or processing takes place on the client . Moreover the development application may be a child or sub module of another software module or development environment not illustrated without departing from the scope of this disclosure.

Turning to specific examples the development application may in some situations support development kits that contain special tools dedicated to certain components. For example a Mobile Development Kit may integrate tools required to help build and test mobile applications for PDAs and laptops. The development application may also include tools dedicated to constructing an application s user interface. Some kits may be language agnostic and may support Java or ABAP as well as other programming languages. In another example the development application may be the technical foundation for enterprise mobility within another development studio and provide the technology that powers composite applications for a mobile business. With this development application the business may mobilize quickly taking advantage of existing IT infrastructure and extending tried and true business processes within and beyond enterprise boundaries. This example development application may comprise three mobile client technologies to enable standardized mobile business solutions as well as customer specific developments. These clients may be optimized for specific user roles and target devices. For example the modules may include 

Mobile Java client optimized for personal digital assisted PDA or handheld devices that display occasionally connected applications such as mobile asset management 

Mobile .NET client designed for Microsoft Windows based devices that display occasionally connected CRM field applications with a rich function set and or

Mobile browser client designed for mobile devices that are connected to a Web server using a technology such as WAP wireless LAN Bluetooth and GPRS.

As an integrated component of another development studio or environment the development application may potentially leverage the overall platform benefits. For example business application may operate in both connected and disconnected modes because development application may provide a local run time environment not illustrated that may allow employees to perform their jobs whether disconnected or connected to the systems at their main office. With solutions powered by this development application employees can store data offline on their mobile device and then synchronize information on back end systems as needed. This development application may provide a mobile development kit that helps developers build and customize mobile solutions that are tightly integrated with the back end system. The development application may also provide a console that enables system administrators to centrally manage mobile solutions and infrastructure. While the above mentioned client technologies may be included the foregoing does not represent an exclusive list of possible modules for customer specific developments. Put simply the development application may comprise any suitable technology that can implement component or model view controller technology or concepts. Specifically development application may reduce coding increase design capability and increase development productivity through support of both model centric and code centric development techniques. In other words it often supports a component centric development paradigm for better reusability and the MVC design pattern for better scalability. In some cases development separates the underlying application from user interface client technologies such as Web rich clients mobile devices and others. Moreover it may provide a data dictionary for the central definition of data types and database tables that can be used for layers of application development such as presentation business and persistence layers.

Applications may make use of components that contain view compositions or windows . Components may embed other components such that a first component may interact and make use of a second embedded component. The view composition of the first component may include views of the second component. Similarly the view composition of the application may include views of the components used by the application. In addition an application developer may design application specific views that may be part of the application s view composition.

Returning to a component developer designates one of the views in the view composition of the component as an interface view . The interface view and the associated inbound plug and outbound plug are the visual interface for the component . At design time the component embedder may use navigation links to specify view transitions to the interface views of embedded components like any other view in the view composition of the component embedder. A component may present more than one visual interface by defining more than one interface view.

Each view has a view controller and a view context associated with the view controller . The view controller implements presentation logic implemented by the view such as triggering events in response to user interaction with UI elements in the view. The view context stores data and state associated with the view controller . The view context may be used to communicate data between the view and any controller of the component by mapping the view context to the context of the controller.

Component may also include a component controller that implements common functionality required by views implemented by the component . The component controller may receive control when the component is instantiated after the component instance has been initialized. The component may also include one or more custom controllers and associated contexts . The custom controllers and associated contexts may be used to implement and structure functionality and data storage of the component .

The component embedder interacts with the embedded component by using the programming interface the data binding interface and the visual interface . The embedded component may interact with the component embedder by generating events. The component embedder may subscribe to events generated by the embedded component and react to such events.

Each node typically has a node type. Examples of node types are value nodes and model nodes. The value node may maintain such as store and administer its own application data transient application data . The data may be for example scalar data tables or structures. The model node may include a reference to application data that persists in a corresponding model. The parent node may also have attributes. Each child node may include an arbitrary tree structure that includes further child nodes and or attributes. Attributes are leaves in tree structure. Attributes represent for example scalar data types such as strings and integers or Java types e.g. java.util.Date .

For example in at design time the context includes the independent node PN that includes the two attributes A A and that is the parent node of the dependent nodes CN CN. The second dependent node CN has two further attributes A A. This structure defines a first node element for the parent node PN and a second node element for the second child node CN. The first node element includes information about the context structure with regards to the parent node PN. In other words it summarizes information that is available at the context structure level that is under the level of the parent node PN. The second node element includes information about the context structure with regards to the second dependent node CN. The context structure implies that the second node element which corresponds to the child node CN depends on the first node element which corresponds to the parent node PN .

At runtime structure elements e.g. nodes may represent a set of data instances. Nodes provide type information about object instances that are maintained by the node. Each node may have a node collection wherein each element of the node collection has the same node element type. For example the example parent node PN corresponds to a first node collection that includes multiple runtime instances of the first node element . Each runtime instance of the first node element may have the attributes A and A a node collection corresponding to child node CN and a node collection corresponding to child node C. An example of the latter node collection is shown in as node collection which contains multiple runtime instances of the second node element . The node collection may be empty or may have at least one instance of the corresponding node element.

The node collection may have a cardinality and a node collection type such as list tree set or collection. The node collection cardinality see table 2 and the node collection type see table 1 may be declared at design time. An evaluation mechanism may be used to automatically evaluate the node collection of a child node at runtime when its parent node changes.

Dependent nodes may get their values by using the supply function. For example the node collection of a dependent node may become obsolete when a selection of its parent node changes i.e. when a different element is selected from the node collection corresponding to the parent node . In this scenario the dependent node may be recalculated that is the content of its node collection may be determined on a subsequent access. In another example a representation instance is created for each dependent node of a parent node. The values of the representation instances enable a load data on demand or an unload data when not needed mechanism. In this manner memory may be used in an efficient manner.

The content of a node collection may also be explicitly set to a certain state such as invalid or unfilled. When the node that corresponds to the node collection is subsequently accessed the node collection content is determined again. This may be used to force a re read of modified data when the modification e.g. in the model was not visible to the application at runtime.

Returning to the example server may also include an interface for communicating with other computer systems such as the clients over the network in a client server or other distributed environment. Generally the interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the interface may comprise software supporting one or more communications protocols associated with communications such that the network or hardware is operable to communicate physical signals.

The network facilitates wireless or wireline communication between the server and any other local or remote computer such as the clients . Indeed while illustrated as two networks and respectively network may be a continuous network without departing from the scope of this disclosure so long as at least a portion of network may facilitate communications between senders and recipients of requests and results. The network may be all or a portion of an enterprise or secured network. In another example the network may be a virtual private network VPN merely between the server and the client across wireline or wireless link. Such an example wireless link may be via 802.11a 802.11b 802.11g 802.20 WiMax and many others. In other words the network encompasses any internal or external network networks sub network or combination thereof operable to facilitate communications between various computing components in the system. The network may communicate for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and other suitable information between network addresses. The network may include one or more local area networks LANs radio access networks RANs metropolitan area networks MANs wide area networks WANs all or a portion of the global computer network known as the Internet and or any other communication system or systems at one or more locations. In certain embodiments the network may be a secure network associated with the enterprise and certain local or remote the clients.

The client is any computing device operable to connect or communicate with the server or the network using a wireline or wireless connection. At a high level each client includes at least the GUI and in some cases an agent and comprises an electronic computing device operable to receive transmit process and store any appropriate data associated with the backup system. It will be understood that there may be any number of the clients communicably coupled to the server . For example the clients may include one local client and two external clients to the illustrated portion of the network . Further the client developer and user may be used interchangeably as appropriate without departing from the scope of this disclosure. For example the developer may use development application on a first client while an end user may use business application on a second client . Moreover for ease of illustration each client is described in terms of being used by one user. But this disclosure contemplates that many users may use one computer or that one user may use multiple computers. As used in this disclosure the client is intended to encompass a personal computer touch screen terminal workstation network computer kiosk wireless data port smart phone personal data assistant PDA one or more processors within these or other devices or any other suitable processing device. For example the client may comprise a computer that includes an input device such as a keypad touch screen mouse or other device that can accept information and an output device that conveys information associated with the operation of the server or the clients including digital data visual information or the GUI . Both the input device and output device may include fixed or removable storage media such as a magnetic computer disk CD ROM or other suitable media to both receive input from and provide output to users of the clients through the display namely the GUI .

GUI comprises a graphical user interface operable to allow the user of the client to interface with at least a portion of environment for any suitable purpose such as to allow the user to navigate through the components within business application . Generally the GUI provides the particular user with an efficient and user friendly presentation of data provided by or communicated within the system. In particular GUI may provide the user of business application with access to data stored within memory . The GUI may comprise a plurality of customizable frames or views having interactive fields pull down lists and buttons operated by the user. These frames or views may be associated with specific component instances such that the related data may be accessed and modified. In addition to manipulating data other portions of the customizable frames or views may allow users to navigate between a plurality of views and or components through user actions in the GUI . Navigation may present the user with new frames or views of a business application . Upon indicating a desire to navigate away from a first frame or window event handlers within the component instances of the business application or other programming of the business application may cause data associated with the first frame or view to be processed prior to presenting the new frame or view to the user via the GUI . Therefore the GUI contemplates any graphical user interface such as a generic web browser touch screen or command line interface CLI that processes information in environment and efficiently presents the results to the user. The server can accept data from the client via the web browser e.g. Microsoft Internet Explorer or Mozilla Firefox and return the appropriate HTML or XML responses using the network .

The general menu may be created by a manner similar to the process described in the descriptions accompanying . For instance an API or public part may be defined in the lowest level components of the application where the programming in the API or public part may be used and implemented in the topmost component where the context is known. At runtime the concrete implementing class of the topmost level may be registered to the lowest level components. This process is described above with regards to step in . Similarly the navigation history menu may be created in a similar process as described in . The navigation history links may represent the locations previously visited by the application . If one of the links is activated an outbound plug is triggered from the current view navigating the application to the specified location. In some embodiments the parameters of the location from the previous visitation may be stored using context saving or other methods such that the user may view the former location in the same manner as when the user originally navigated away. In this manner data that was not previously saved explicitly by the user or prior to outbound navigation by the application may be restored.

In the present embodiment subview is embedded within main view . The subview contains three UI elements. The first is a table which may contain records or information relating to the application . The user may have the ability to interact with the data to make any necessary or desired changes. The subview contains two other UI elements a button labeled Save and a button labeled Finished. In this embodiment the user may indicate a desire to save any changes to the data by activating button . When user interaction is complete the user may activate the second button Finished to notify the application that any events based upon the completion of user interaction may be triggered. Both actions are governed by the methods detailed in .

The final portion of the visual interface is subview which is also embedded within the main view . In the current embodiment subview contains a text box for displaying information relating to the table of subview . The text box of this embodiment is not interactive. The data displayed is meant to describe the information displaying in the table and is thus static. In other embodiments the text box may be an interactive element such that the user may change the description of the table .

In the user initializes the application at step . Upon initialization the user may be presented with an initial visual interface for the application . This visual interface may include one or more views each of which in turn may contain one or more UI elements such as tables drop down boxes menus or other elements. In one embodiment the default visual interface may include one view displaying a table representing for instance financial data. In a second embodiment in addition to the table the default visual interface may also include a second view containing a text box with information related to the table s data.

At step the user may interact with the UI elements of the visual interface to change or update the data presented. In one embodiment the data may only be initially changed in the local UI element. In still other embodiments the data may be automatically updated to a persistent storage upon any changes being made. In the embodiment illustrated by the flowchart of the data may not be saved in persistent storage until the user takes some action to indicate an explicit validation and save at step . If the user chooses not to explicitly save changes to data prior to navigating away from the current component then method will move to step when the user attempts to navigate away from the current visual interface. If however the user does choose to explicitly save the changed data method will move to step where the changes may be validated. In one embodiment the view in which the user modified the data may include another UI element such as a button with which the user may activate a signal to the application that a validation and save should be performed.

After indicating an explicit save should occur the user may wait for the application to finish the validation of the data performed at step . The validation process may involve the application checking the formatting substance or style of the new data against any requirements in place for the changed fields. At step the application determines whether or not the validation was successful. If successful method may save the local changes to persistent storage at step such that the changes are available to other users or applications that access the data. Once the changes have been saved at step the user may choose to make more changes to the data returning to step or the user may be finished making changes and ready to navigate to another component or to another view within the component.

However if validation was unsuccessful method moves to step where the user may elect to modify the data into an acceptable format or allow the changes to be erased and continue navigating to a new component or view. If the user chooses to correct the errors method returns to step . In some embodiments upon electing to modify the data into an acceptable format the changed data may remain in the local environment after a failed validation. In other embodiments the data may be reset to the original value causing any changes to be made again. In some embodiments changes that were validated may be saved while the unacceptable changes are removed. Additionally some embodiments may provide error messages generated by the application indicating to the user what issues arose during the validation process.

At step the user may perform an action corresponding to the activation of an outbound trigger of the current view in order to navigate to a new view. In one embodiment this trigger may be activated by using an embedded UI element such as a button menu or link. In other embodiments focusing the application on another of the views within the interface may cause the activation. In some embodiments changing the lead selection of a table such as by changing the selected row may also initiate the save and validation process for any data that has not previously been explicitly saved. Step determines whether any unsaved changes to the data remain upon navigating to a new view. The user may or may not have already explicitly saved all of the changes to the data. Prior to navigating to the new view or component step ensures that any changes to the data requiring saving are appropriately stored. If no unsaved changes remain the method moves to step where the application navigates to the new view specified by the outbound trigger without further action.

However if unsaved changes to data remain at step the application attempts to validate the data. In one embodiment validation may be performed in a similar manner as in step . In other embodiments validation may be performed differently than the previous validation. After attempting to validate the new data step determines whether or not the validation was successful. If successful method may move to step where the previously unsaved changes are stored in the persistent storage for other users and applications accessing the data. If validation is unsuccessful however an error message may be provided to the user at step . The error message may be a pop up notification a visual indication on the screen as to which portions of the data are unacceptable or another notification technique. Once the user has been notified of the error at step the user may elect to correct the error by attempting to correct the data or chose to continue on with the navigation without storing the changes. If the user chooses to attempt correction of the errors the method returns to step wherein the user modifies the data to conform to the application s requirements. The user would then continue through method as normal with the opportunity to explicitly save the changes at step before attempting to navigate away from the current visual interface. If the user chooses not to correct the data at step the application would allow navigation to the new view to occur at step without saving the changes. In some embodiments any changes made by the user would be lost. In other embodiments changes that were successfully validated may be saved while those failing the validation step are not. After completing the method for a single set of data the user may perform the same method in the view being navigated to or in another portion of the visual interface.

As previously described components may be embedded or nested within other components. illustrates several components embedded within DC . DC encapsulating a component having screen and DC encapsulating a component having screen represent two components embedded within DC at a second level. Within DC two more components are embedded at a third level DC encapsulating a component having a screen and DC encapsulating a component having a screen . Similar to DC each of these components and their related screens are encapsulated by a transactional process that identifies when the application navigates from that component or view to another component or view. Each component including DC may contain a plurality of outbound plugs that allow for user navigation to one or more related components or views. By triggering these outbound plugs navigation to those components or views may be implemented.

Two types of navigation may occur within the components of namely vertical and horizontal. One example of vertical navigation can be navigation occurring by a triggering of an outbound plug from the general menu . The general menu may be defined in a logically higher component DC and may be located within a view of DC . Further the general menu can be also declared within the lower level components as well. In the embodiment of the menu is located within screen . The general menu may include existing outbound plugs such that by using the menu destinations within the application may be reached by activating the associated plug. As mentioned registration occurs at step of method . This registration process often involves registering the logically higher in this case topmost component DC with the logically lower components such that components and their views may access the general menu as well as the other navigational aspects of the topmost component. In this manner navigation may be triggered from any component due to each component s reliance on the reference to the topmost component. In one embodiment referring the navigational capabilities of the topmost component to the lower components may be performed by declaring a public part at the topmost component containing the required actions and then creating dependencies upon that public part at the lower components. In another embodiment an application programming interface API may be defined in the lowest component where it is used and implemented in the highest level component. At runtime the concrete implementing class of the highest level component may then be registered to the lowest component such that the navigation process is available to the lowest component. In one embodiment the following may represent the API listing 

The second type of navigation is horizontal navigation. Horizontal navigation can be considered as the navigation from one view or component to another using defined outbound plugs on the first view or component to navigate to the inbound plugs of a second view or component. One example of horizontal navigation in would be navigation from DC to DC where triggering the outbound plug occurs by user s activation of a corresponding UI element i.e. button in DC or by some other event recognized by an event handler within the component DC that corresponds to the navigation. During horizontal navigation a user or application may need or desire to navigate back to a previously viewed component or view. This may be performed by passing information relating to the context of the current component or view to the component or view to which the user or application is navigating such as by the passing of parameters during the navigation. In this way the information from the previous view or component may be available to the user or application even after navigating to the new view or component. The navigation history may be kept during navigation throughout the application and in some embodiments presented to the user in a separate view within the visual interface. In one embodiment the abstract class controlling navigation may be extended such that some specific information concerning the outbound plug that is to be triggered is provided along with the navigation. Some navigation methods may also be overwritten to alter the abstract class to provide for the solution. An example of the code enabling this embodiment may resemble the following 

Returning to method completes the registration process and provides an initial visual interface at step . This visual interface may include one or more views from one or more components each of which in turn may contain one or more UI elements such as tables drop down boxes menus or other elements. In one embodiment the default visual interface may include one view displaying a table along with a second view containing a text box with information related to the table s data. In still other embodiments the initial visual interface may include a view containing a general menu for vertical navigation and or a view for displaying the navigational history of the current session.

At step the application may receive any changes made by user interaction with the UI elements of the visual interface updating the data. The modified data may initially only be changed in the local environment. In the current embodiment the data will not be saved to persistent storage until the application receives some user command or signal at step indicating that the user has chosen to perform an explicit validation and save of the modified data. In some instances the application may not receive a command from the user to explicitly save the altered information. If this is the case then at step the method may wait for the application to receive an event indicating the user s intention to navigate to a new component or view. If the application does receive a command to explicitly save the changed data the application may attempt to validate the changes to the data at step .

The validation process of step may involve the application reviewing the formatting substance or style of the altered data to determine whether any requirements of the fields were violated. At step the application may determine whether the validation was successful or not. If successful the application saves the altered data to the persistent storage at step such that the data may be accessible to the application other applications and any user attempting to access the information. If the validation is unsuccessful the application provides a validation error message at step providing the user notification that the changes to the data may not be saved due to an error. After the data is saved at step or after the validation error message is provided at step the application waits to receive any more user changes to the data. If changes are made the method returns to step to receive additional user changes. The application may wait for more user changes until it receives a command or event indicating that the user requests or requires a new view or component to be displayed at step .

After receiving this command the application reviews the current data to determine whether or not any unsaved changes exist at step . Unsaved data may be present when the user has chosen not to explicitly save any changes. If no unsaved data is present the method moves to step where the application navigates to a new component or view. If unsaved data does exist it should not be discarded when the user navigates away from the current component or view. In order to ensure that the proper saves are made the application analyzes the intended target of the navigation at step to determine the proper actions to take. Application determines whether the requested or required navigation is a vertical navigation at step . Vertical navigation is performed when the general menu is used to navigate to a specific component. In the embodiment of method vertical navigation may signify that work in the previous component is complete so that a validation and save process may be engaged. In alternative embodiments vertical navigation may not automatically signal that the user is finished manipulating the data such that it is ready to be saved thus requiring additional user commands to perform a non explicit save. If vertical navigation is detected the method validates the changes to the data at step . This validation may be performed in a manner similar to that of step or it may validate the data in a different manner. Regardless of the method used at step the application determines whether the validation was successful or not. If successful the changes are saved at step and the navigation to the new view or component is performed at step . However if the validation was unsuccessful the application provides the user attempting to navigate vertically with an error message indicating the reasons for failure of the validation. In the present embodiment the application provides the user with an opportunity to return to the data and correct the errors found by the validation process at step . If the user elects to correct the data the method returns to step wherein the application receives additional user changes. From there the method continues as before. If however the user elects to not cure the data the application may move to the next view or component without saving the data to the persistent storage. Any changes may be lost and other users or applications accessing the persistent data will not access the unsaved user modifications.

Returning to step the application may determine that the navigation requested or required is not a vertical navigation. In that situation the navigation is horizontal navigation and the application prepares the relevant information regarding navigation history for transmission to the new view or component at step . This step is performed to provide the user with the ability to return to data when navigation was not meant to be a final action. For instance some horizontal navigations may be to a help component. Leaving the current view or component may not mean that the user wants to save and end the current work but rather retrieve information from another source and then return to editing the data of the current view or component. In some embodiments a back operation may be included in the new view or component such that the navigation history information provides the data needed to navigate back to the previous view with minimal effort. In some embodiments a new view or component may provide a listing of the previous navigations along with outbound plugs to those previous locations provided with links.

After having prepared the navigation history information the application may determine whether a validation and save process should be implemented upon the current data set at step . As mentioned above some horizontal navigations may not be permanent navigations such that modifications to the data set are not complete. Different embodiments with different requirements may provide different rules for determining when a horizontal navigation should require the saving of modified data and when a save is unnecessary. If the save is deemed unnecessary the application simply navigates to the new view or component at step . If a save is necessary due to the specific embodiment s requirements the application proceeds to validate the changes at step . The data is validated the validation is analyzed at step and the modifications are saved at step or rejected in step as in the vertical navigation situation described above.

While the preceding flowcharts and accompanying descriptions illustrate exemplary methods and environment contemplates using or implementing any suitable technique for performing these and other tasks. It will be understood that these methods are for illustration purposes only and that the described or similar techniques may be performed at any appropriate time including concurrently individually or in combination. In addition many of the steps in these flowcharts may take place simultaneously and or in different orders than as shown. Moreover environment may use methods with additional steps fewer steps and or different steps so long as the method remains appropriate.

Although this disclosure has been described in terms of certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain the disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure and such changes substitutions and alterations may be included within the scope of the claims included herewith.

