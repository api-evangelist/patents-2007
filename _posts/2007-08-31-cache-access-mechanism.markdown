---

title: Cache access mechanism
abstract: Techniques for improving cache accesses in an object-relational mapping space are described herein. In one embodiment, in response to a first cache request received at a first cache API associated with a transaction for updating a data entry of the relational database, the updated data of the data entry is stored in a local cache, where the local cache is one of members of a cache cluster, and an invalidation message is sent to remaining members of the cache cluster to invalidate corresponding cache entries of the remaining members. In response to a second cache request received at a second cache API associated with a transaction for loading data from a data entry of the relational database, the loaded data is stored in the local cache without sending an invalidation message to the remaining members of the cache cluster. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266392&OS=08266392&RS=08266392
owner: Red Hat, Inc.
number: 08266392
owner_city: Raleigh
owner_country: US
publication_date: 20070831
---
The present invention relates generally to object relational mapping in database management. More particularly this invention relates to improved cache accesses in object relational mapping.

Data management tasks in object oriented programming are typically implemented by manipulating objects which are typically non scalar values. Consider the example of an address book entry which represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object oriented implementation by a person object with slots to hold the data that comprise the entry the person s name a list or array of phone numbers and a list of addresses. The list of phone numbers would itself contain phone number objects and so on. The address book entry is treated as a single value by the programming language it can be referenced by a single variable for instance . Various methods can be associated with the object such as a method to return the preferred phone number the home address and so on.

Many popular database products however such as SQL DBMS products can only store and manipulate scalar values such as integers and strings organized within tables. A programmer must either convert the object values into groups of simpler values for storage in the database and convert them back upon retrieval or only use simple scalar values within the program. Object relational mapping is used to implement the first approach.

Object relational mapping aka O RM ORM and O R mapping is a programming technique for converting data between incompatible type systems in databases and object oriented programming languages. This creates in effect a virtual object database which can be used from within the programming language.

Typically an ORM system provides an application programming interface API to access a cache which may be implemented locally or in a cluster manner. Typically when a data entry is accessed the content of the data entry is replicated in a local cache and an invalidation message is sent to other caches in the cluster. Although certain data accesses may not require invalidating other caches such an invalidation message is still sent which causes certain unnecessary communication traffic.

Techniques for improving cache accesses in an object relational mapping space are described herein. In the following description numerous details are set forth to provide a more thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to one embodiment ORM includes one or more cache APIs and a local cache for caching content of certain entries stored in a database or data store . In addition the local cache may be implemented as part or a member of a cache cluster having multiple caches or cache members . Cache cluster may be implemented locally with respect to ORM e.g. in different virtual machines or VMs . Alternatively cache cluster may be implemented remotely over an interconnect or network which may be a local area network LAN or a wide area network WAN such as the Internet. Similarly data store may be implemented locally or remotely over a network.

A cache may be organized as a tree with a single root. Each node in the tree essentially contains a map which acts as a store for key value pairs. A cache can be either local or replicated. Local trees may exist inside the JVM in which they are created whereas replicated trees propagate any changes to some or all other trees in the same cluster. A cluster may span different hosts on a network or just different JVMs on a single host.

According to certain embodiments when a change is made to an object in the cache and that change is done in the context of a transaction the replication of changes is deferred until the transaction commits successfully. All modifications may be kept in a list associated with the transaction for the caller. When the transaction commits the system replicates the changes. Otherwise on a rollback the system may simply undo the changes locally resulting in zero network traffic and overhead. For example if a caller makes 100 modifications and then rolls back the transaction the system will not replicate anything resulting in no network traffic.

If a caller has no transaction associated with it the system will replicate right after each modification e.g. in the above case we would send 100 messages plus an additional message for the rollback. In this sense running without a transaction can be thought of as analogous as running with auto commit switched on in JDBC terminology where each operation is committed automatically. The replication may be performed synchronously or asynchronously. During a synchronous replication the replicated caches replicate all changes to the other caches in the cluster. Synchronous replication means that changes are replicated and the caller blocks until replication acknowledgements are received. During an asynchronous replication replicated caches replicate all changes to the other caches in the cluster. However being asynchronous the caller does not block until replication acknowledgements are received.

In addition instead of replicating content from one cache to another cache an invalidation message may be used to notify a cache that its data is stale and may need to update from the data store. If a cache is configured for invalidation rather than replication every time data is changed in a cache other caches in the cluster receive a message e.g. invalidation message informing them that their data is now stale and should be evicted from memory. Invalidation when used with a shared cache loader would cause remote caches to refer to the shared cache loader to retrieve modified data. The benefit of this is twofold network traffic is minimized as invalidation messages are very small compared to replicating updated data and also that other caches in the cluster look up modified data in a lazy manner only when needed.

In one embodiment invalidation messages are sent after each modification e.g. no transactions or at the end of a transaction upon successful commit. This is usually more efficient as invalidation messages can be optimized for the transaction as a whole rather than on a per modification basis. Invalidation too can be synchronous or asynchronous and just as in the case of replication synchronous invalidation blocks until all caches in the cluster receive invalidation messages and have evicted stale data while asynchronous invalidation works in a fire and forget mode where invalidation messages are broadcast but do not block and wait for responses.

Referring back to according to one embodiment cache APIs include multiple specific interfaces having specific functionalities. An example of the cache APIs is shown in for the purposes of illustration. Referring to in this example cache APIs which may be implemented as part of cache APIs of include APIs . For example API e.g. put from load may be used to write a copy of data into the cache when the data is loaded from a data store. Similarly APIs may be used to update the cache when the corresponding data entry in the data store is updated inserted or deleted.

In one embodiment not all APIs require sending an invalidation message to other caches in the cluster. For example API which is a put from load may not require sending an invalidation message to other caches of the cluster because there is no change in the data entry. However APIs may require sending an invalidation message to other caches to inform them there is a change in the data entry. Note that some or all of the components as shown in may be implemented in software hardware or a combination of both. Other configurations may also exist.

Framework includes a variety of components. For example session factory is configured to provide a thread safe immutable cache of compiled mappings for a single database. Session factory is a factory for session and a client of connection provider and it may hold an optional e.g. second level cache of data that is reusable between transactions at a process or cluster level. Session is a single threaded short lived object representing a conversation between the application and the persistent store . Session wraps a JDBC connection and is a factory for transaction . Session holds a mandatory first level cache of persistent objects which are used when navigating an object graph or looking up objects based on an identifier.

Persistent objects are short lived single threaded objects containing persistent state and business function. Persistent objects may be for example ordinary JavaBeans POJOs plain old Java objects . Persistent objects may be associated with a session e.g. session . As soon as the associated session is closed the persistent objects may be detached and free to use in any application layer e.g. directly as data transfer objects to and from presentation . Transaction is a single threaded short lived object used by the application to specify atomic units of work. Transaction abstract applications from underlying JDBC Java database connectivity JTA Java transaction API and or CORBA common object request broker architecture transactions. A session may span several transactions in some situations.

The JDBC API is the industry standard for database independent connectivity between the Java programming language and a wide range of databases SQL databases and other tabular data sources such as spreadsheets or flat files. The JDBC API provides a call level API for SQL based database access. The JTA specifies standard Java interfaces between a transaction manager and the parties involved in a distributed transaction system such as the resource manager the application server and the transactional applications. The CORBA is a standard defined by the Object Management Group OMG that enables software components written in multiple computer languages and running on multiple computers to interoperate. CORBA wraps program code into a bundle containing information about the capabilities of the code inside and how to call it. The resulting wrapped objects can then be called from other programs or CORBA objects across a network. CORBA uses an interface definition language IDL to specify the interfaces that objects will present to the world. CORBA then specifies a mapping from IDL to a specific implementation language like C or Java.

Referring back to connection provider is a factory for and pool of JDBC connections. Connection provider abstracts application from underlying data sources or driver managers e.g. JNDI or Java naming and directory interface JDBC and JTA . Transaction factory is a factory for transaction instances. Framework supports a variety of databases including for example Oracle DB2 Sybase MS SQL server MySQL etc. In one embodiment framework further includes cache APIs as described above with respect to . Note that some or all of the components as shown in may be implemented in hardware software or a combination of both hardware and software.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

