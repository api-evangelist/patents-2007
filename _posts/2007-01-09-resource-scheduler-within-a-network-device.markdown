---

title: Resource scheduler within a network device
abstract: A network device is described in which a dedicated resource scheduler monitors memory consumption to provide for improved processing of communication sessions. The scheduler maintains a dependency list of communication sessions, and reserves memory for communication sessions as requests for memory are received. The amount of memory reserved is determined based on the amount of memory currently reserved for the communication sessions in the dependency list. The network device may control ongoing communication sessions by way of window manipulation. Communication sessions are processed in a first mode when available memory has not reached a predetermined amount, while communication sessions are processed in a second mode when available memory reaches a predetermined amount.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546371&OS=07546371&RS=07546371
owner: Juniper Networks, Inc.
number: 07546371
owner_city: Sunnyvale
owner_country: US
publication_date: 20070109
---
This application claims the benefit of U.S. Provisional Application No. 60 882 737 filed Dec. 29 2006 the entire content of which is incorporated herein by reference.

The invention relates to computer networks and for example to processing data flows in computer networks.

A typical computer network such as an internet protocol IP based network supports communications between various network devices. The devices may for example include personal computers laptops workstations personal digital assistants PDAs wireless devices network ready appliances file servers print servers routers or other devices. When two devices communicate the devices establish a communication session using a communication protocol such as the transmission control protocol TCP . Devices referred to as routers forward packets associated with the communication sessions through the physical network that connects the devices. The flow of packets between the devices for a TCP session is commonly referred to as a TCP flow.

Various kinds of processing of the TCP flow can be done by intermediate devices placed along the path taken by packets that constitute the TCP flow. Some examples of the kinds of processing currently performed on TCP flows between devices include data compression encryption and decryption TCP acceleration application layer acceleration anti virus processing and intrusion detection and prevention.

In general the invention is directed to techniques for scheduling the processing of incoming packets received on communication sessions to regulate memory consumption and avoid dropping the communication sessions. The technique may be applied by an intermediate device located between network devices. For example the techniques may be applied by an anti virus device that monitors traffic flowing within an enterprise network between an external network and internal computing nodes.

The techniques described herein may be applied in the context of certain applications such as anti virus scanners. These applications often require that an entire file be accumulated before any of the file is analyzed and forwarded to the destination server or client i.e. file based anti virus scanning . For network devices that do not have secondary storage or do not want to use secondary storage for performance considerations main random access memory RAM can run out quickly causing service interruptions. For example a situation may occur where multiple files have been partially received and the partially received files use up the RAM. As a result none of the files can be fully received and processed and so the sessions time out and are dropped. The techniques described herein may be applied to avoid problems associated with conventional intermediate devices such as randomly dropping ongoing sessions when the main memory is exhausted until memory becomes available to handle new incoming packets.

In one example embodiment the techniques provide a dedicated scheduler that monitors memory consumption to provide for improved processing of communication sessions such as Transmission Control Protocol TCP sessions. The scheduler maintains a dependency list of TCP sessions and reserves memory for TCP sessions as requests for memory are received. The amount of memory reserved is determined based on the amount of memory currently reserved for the communication sessions already in the dependency list. Moreover in certain example embodiments the techniques reserve memory in an attempt to guarantee that at least one session is always able to complete processing thus avoiding situations where high traffic volumes overload the device.

The techniques may control ongoing TCP sessions by way of TCP window manipulation. For example in the absence of any memory bottleneck the scheduler operates in a normal mode in which the TCP windows for all ongoing sessions remain open. When the scheduler detects a bottleneck condition the scheduler begins to operate in a constrained mode in which the TCP windows for all but the first TCP session on the dependency list are gradually closed. The scheduler has previously reserved enough memory for the first session in the dependency list to complete operation. The scheduler allows the first session to finish before reopening the TCP window of the next session on the dependency list. In this manner sessions are processed in series in the order listed on the dependency list and at least one session at a time is guaranteed to finish while the scheduler is in the constrained mode. Once the bottleneck condition has subsided the scheduler initiates opening of all the TCP windows and resumes processing the sessions in parallel in accordance with the normal mode.

In one example embodiment a method comprises maintaining a dependency list of communication sessions wherein the dependency list specifies an order in which to process the communications sessions and wherein for each communication session the dependency list specifies an amount of memory currently reserved for the communication session. The method further comprises receiving a request to reserve memory for processing a new communication session and determining whether an amount of memory required to process the new communication session is greater than a total amount of memory reserved for the communication sessions already listed within the dependency list. The method further comprises when the amount of memory required to process the new communication session is greater than the total amount of memory reserved for the communication sessions already listed within the dependency list reserving memory for the new communication session in an amount equal to a difference between the amount of memory required to process the new communication session and the total amount of memory currently reserved for the communication sessions already listed to guarantee that processing of the new communication session can be completed upon processing the communication sessions already listed within the dependency list. The method also includes processing the communication sessions with the security device in accordance with the dependency list.

In another example embodiment a network security device comprises a scheduler that maintains a dependency list of communication sessions wherein the dependency list specifies an order in which to process the communications sessions and wherein for each communication session the dependency list specifies an amount of memory currently reserved for the communication session. The network security device further includes a proxy module that receives a request to reserve memory for processing a new communication session. The scheduler determines whether an amount of memory required to process the new communication session is greater than a total amount of memory reserved for the communication sessions already listed within the dependency list. When the amount of memory required to process the new communication session is greater than the total amount of memory reserved for the communication sessions already listed within the dependency list the scheduler reserves memory for the new communication session in an amount equal to a difference between the amount of memory required to process the new communication session and the total amount of memory currently reserved for the communication sessions already listed to guarantee that processing of the new communication session can be completed upon processing the communication sessions already listed within the dependency list. The network security device further includes an anti virus engine that processes the communication sessions in accordance with the dependency list.

In yet another example embodiment a computer readable medium contains instructions that cause a programmable processor to maintain a dependency list of communication sessions wherein the dependency list specifies an order in which to process the communications sessions and wherein for each communication session the dependency list specifies an amount of memory currently reserved for the communication session. The instructions further cause the programmable processor to receive a request to reserve memory for processing a new communication session and determining whether an amount of memory required to process the new communication session is greater than a total amount of memory reserved for the communication sessions already listed within the dependency list. The instructions further cause the programmable processor to when the amount of memory required to process the new communication session is greater than the total amount of memory reserved for the communication sessions already listed within the dependency list reserve memory for the new communication session in an amount equal to a difference between the amount of memory required to process the new communication session and the total amount of memory currently reserved for the communication sessions already listed to guarantee that processing of the new communication session can be completed upon processing the communication sessions already listed within the dependency list. The instructions further cause the programmable processor to process the communication sessions with the security device in accordance with the dependency list.

In a further example embodiment an anti virus device for processing communication sessions comprises an internal memory an anti virus engine that performs file based anti virus scanning on network traffic received via the communication sessions using the internal memory and a resource scheduler module that prevents the communication sessions from timing out by allocating memory from the internal memory so that at least one of the communication sessions is guaranteed to be processed to completion.

The invention may provide one or more advantages. For example the techniques described herein allow multiple sessions to be processed at the same time. The techniques allow for improved use of main memory and detection of bottleneck conditions so that such conditions may be managed. The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

In the example of enterprise network includes anti virus AV device that resides between firewall and internal computing nodes and monitors traffic flowing between firewall and internal computing nodes . In general anti virus device is capable of interacting with nodes and network devices to facilitate transmission of data through public network and more specifically to monitor traffic flowing between firewall and nodes .

Anti virus device may be a network security device that provides a variety of security functions such as analyzing the network traffic to detect network attacks and scanning the network traffic for viruses. For example anti virus device may act as a proxy between one of nodes and one of external network devices A N external network devices located outside of enterprise . In one embodiment anti virus device may be transparent to nodes and external network devices . In another embodiment anti virus device may operate as a full proxy between nodes and external network devices so as to maintain separate communication sessions with the devices.

Nodes and network devices exchange communications using communication sessions such as Transmission Control Protocol TCP sessions which typically include two streams or connections of TCP packets flowing in opposite directions between the devices. For example external network device A may be a server and node A may be a client device that requests a web page from the server via a TCP stream. As another example node B may be a server and external network device N may be a client device that uploads information to the server via a different TCP stream.

Anti virus device may process a plurality of communication sessions between nodes and external network devices . The techniques of the invention may allow anti virus device to reduce connection dropping even in resource congested conditions. In one example anti virus device includes an anti virus AV engine that scans application layer communications such as files or web pages sent via the communication sessions. In accordance with the principles of the invention anti virus device includes a resource scheduler to manage usage of internal memory resources as the AV engine processes the plurality of TCP sessions. For example each time a new session is established the scheduler receives a request for memory to process the new session and adds an entry to a dependency list. Entries are generally added to the dependency list in the order the sessions are added. Each entry may for example specify a maximum amount of memory needed to process the session and an amount of memory reserved by the scheduler for the session.

The scheduler determines an amount of memory to reserve for processing the session by comparing the amount required by the newly requested session to an amount currently reserved for sessions represented by the dependency list. If the amount currently reserved by the dependency list is less than the amount required by the new session the scheduler reserves assigns an amount of memory equal to the difference between the amount required and the amount currently reserved. In this manner once the sessions for the previous entries have been processed enough reserved memory will be available for processing the new session. If the amount currently reserved is greater than or equal to the amount required by the new session the scheduler need not reserve any additional memory since sufficient memory for the new session is guaranteed to be released once the sessions associated with the previous entries have finished processing.

In some example embodiments anti virus device provides control of ongoing TCP sessions by way of TCP window manipulation. For example in the absence of any memory bottleneck the scheduler operates in a normal mode in which the TCP windows for all ongoing sessions remain open. When the scheduler detects a bottleneck condition the scheduler begins to operate in a constrained mode in which the TCP windows for all but a subset of sessions e.g. the first TCP session on the dependency list are gradually closed. The scheduler has previously reserved enough memory for the first session to complete operation. The scheduler allows the first session to finish before reopening the TCP window of the next session on the dependency list. The next session on the dependency list inherits the amount of memory that was reserved for the session ahead of it on the dependency list. As sessions are sequentially processed the next session to be processed will inherit the total amount of memory reserved for all of the sessions ahead of it on the dependency list. In this manner the scheduler is guaranteed to finish each of the sessions on the dependency list in sequence when in the constrained mode. Once the bottleneck condition has subsided the scheduler initiates opening of all of the TCP windows and resumes processing the sessions in parallel in accordance with the normal mode.

After anti virus device has completed operation on a session such as completed scanning a file for a virus anti virus device may take one or more programmed actions such as automatically dropping packet flows associated with the application layer communications within which the virus was detected. In some embodiments enterprise network may include multiple anti virus devices located within different regions e.g. sub networks of enterprise network . A security management device not shown may operate as a central device for managing the anti virus devices .

Although the example illustrated in is described in terms of a dedicated anti virus device the techniques may be applied to any intermediate device that performs operations on communications sessions such as data compression encryption and decryption TCP acceleration application layer acceleration and intrusion detection and prevention. The techniques may also be applied to a firewall that performs anti virus operations.

Moreover the functionality described herein may be incorporated within other devices such as firewall or switch or within a proxy server load balancer router gateway intelligent switch intelligent hub or other type of intermediate network device. The techniques are described herein in reference to TCP communications for exemplary purposes and may readily be applied to other network communication protocols.

In one example embodiment anti virus device may use TCP proxy to intercept and or establish TCP sessions with nodes and network devices . In this example anti virus device sends and receives packet flows using TCP protocol . TCP proxy may participate in a three way TCP handshake that initiates a new TCP session. When a new TCP session has been initiated TCP proxy notifies AV engine of the new session and stores information about the new session such as the source and destination addresses memory requirements and type of data being transferred in session list . Although described as being performed by TCP proxy one or more of these functions may be performed by an application proxy or other module. When AV engine needs to process a file received via the session AV engine sends a request to scheduler to reserve memory from reserved pool for processing the file. The request specifies an amount of memory required to process the session. Scheduler determines an amount of memory to reserve for the session and adds an entry to dependency list . Scheduler may be a dedicated scheduler that is part of an embedded system within anti virus device . Anti virus device may execute other network communication protocols not shown . Anti virus device may also present a user interface not shown by which an administrator may configure anti virus device . For example the administrator may configure anti virus device to monitor particular subnets of the enterprise network.

Heap is a pool of available memory such as random access memory RAM . As an example in an embedded environment of an intermediate network appliance heap may include 128 megabytes to one gigabyte of memory. Public buffer pool and reserved buffer pool represent logical data structures maintained on top of heap that are used for allocating packet buffers to temporarily store incoming TCP packets using memory from heap . Scheduler reserves an amount of memory from reserved buffer pool sufficient to process at least one session to completion at a time. In the absence of excess congestion scheduler allocates packet buffers for all sessions from public buffer pool . If congestion occurs scheduler does not allocate from public buffer pool instead scheduler allocates packet buffers from reserved buffer pool based on a maximum amount currently reserved in reserved buffer pool . This is described in further detail below. Anti virus device establishes reserved buffer pool during a system boot to pre reserve memory for processing at least one session. The size of reserved buffer pool is determined according to customer specifications. In particular the size of reserved buffer pool is selected to be as large as the largest potential amount of memory that a received file is likely to need to process the file. In one embodiment reserved buffer pool comprises ten megabytes of memory that is pre reserved for processing at least one session.

As sessions are established AV engine makes requests to reserve memory from reserved buffer pool for processing the sessions. Scheduler calculates an amount of memory to be reserved such that at least the first session in dependency list can be processed. AV engine may also request memory directly from heap . Each of public buffer pool and heap have two associated memory usage watermarks i.e. first and second respective predetermined amounts of memory remaining that trigger certain actions by AV device when reached. In particular each of public buffer pool and heap has a low watermark and a too low watermark. When the memory usage has not yet reached either of the low watermarks scheduler operates in a first mode referred to as a normal mode by continuing to process all of the pending sessions as described in further detail with respect to . When the memory usage has reached one or both of the low watermarks scheduler operates in a second mode referred to as a constrained mode by causing connection management module to close the TCP windows for every session other than the first entry in dependency list as described in further detail with respect to . The watermark values may be hard coded or programmably configured. Example too low watermark values are six megabytes remaining for heap and eight megabytes remaining for public buffer pool . Example low watermark values are twelve megabytes remaining for heap and sixteen megabytes remaining for public buffer pool i.e. an amount double the two low watermark values .

Scheduler monitors the use of public buffer pool and heap as AV engine processes files associated with a plurality of sessions. In particular when one or both of pools reaches a memory usage watermark scheduler switches from operating in a normal mode to operating a constrained mode. In the normal mode connection management module keeps the TCP windows for all ongoing sessions open. Scheduler maintains dependency list as a subset of session list and uses dependency list when operating in the constrained mode to control the flow of incoming packets.

Scheduler may add sessions to dependency list in the order that scheduler receives requests to reserve memory for the sessions. In the constrained mode scheduler sets flags that causes connection management module to close the TCP windows for a subset of the sessions e.g. all but the first session on the dependency list . As a result for each closed TCP window the TCP session peer will stop sending traffic on the TCP session. When adding sessions to dependency list scheduler reserves enough memory in reserved buffer pool for at least the first session to be processed. By reserving memory for sessions within the dependency list and forcing AV engine to process only one session at a time when in the constrained mode scheduler guarantees that at least one session will be finished when operating in the constrained mode. Moreover scheduler guarantees that each of the sessions in the dependency list can sequentially be processed.

When the session is completed scheduler checks public buffer pool and heap to determine whether either of the watermarks is still exceeded. If so scheduler continues in the constrained mode and processes the next session on the dependency list by opening that session s TCP window. If neither of the watermarks are exceeded scheduler switches back to the normal mode and connection management module opens all of the TCP windows. AV engine resumes processing the plurality of sessions in parallel.

In one example embodiment anti virus device identifies packet flows in the monitored traffic and transparently reassembles application layer communications from the packet flows. An HTTP decoder identifies each request response within the TCP connection as a different transaction. Scheduler allocates a packet buffer from public buffer pool . TCP proxy copies incoming packets associated with a TCP session to the packet buffer allocated from public buffer pool . Anti virus device may then put the packet buffer into a link list. AV engine reassembles an application layer communication from the data in the packet buffer and scans the entire application layer communication e.g. a file or web page for viruses. In the event no viruses are found AV engine breaks the application layer communication back into pieces which TCP proxy then sends out to the destination of the communication in the form of packets. TCP proxy informs scheduler that processing associated with the session is finished and scheduler removes the completed session from dependency list and makes the reserved memory available. A session may be added to the dependency list each time processing is to be performed for the session i.e. when new work is detected for a session such that a subsequent download may be detected as a new session as the term is used herein.

Example application programming interface API commands used by anti virus device are set forth below in Table 1.

In this example dependency list also includes a memory required column which indicates the amount of memory e.g. in bytes that is required to process an object e.g. a file associated with the session. For example when scheduler receives notification from AV engine that TCP proxy has detected a new session or new work to be performed for an existing session scheduler also receives a request from AV engine to reserve memory in reserved buffer pool . The request indicates the amount of memory that will be required to process the session. As one example AV engine may predict the amount of memory that a session will require based on the protocol associated with request for the session. As another example if AV engine is unable to determine an amount of memory required for the session AV engine may indicate this by specifying that the session requires zero memory. In response scheduler may assume the session will take the maximum amount the system can provide. This amount may be configured as a pre defined amount such as ten megabytes. If a received file requires more than the maximum amount in some embodiments anti virus device will drop the file while in other embodiments anti virus device will forward the file without scanning by AV engine .

Dependency list also includes a memory reserved column which shows an amount of memory e.g. in bytes that scheduler has reserved for the session entry. Scheduler determines an amount of memory in buffer pool to reserve for processing the session by comparing the amount required to an amount currently reserved in reserved buffer pool for sessions already stored within dependency list . If the amount currently reserved is less than the amount required by the new session scheduler reserves memory in reserved buffer pool equal to the difference between the amount required and the amount currently reserved. Thus once the sessions for the previous entries have been processed i.e. the work for those sessions have been processed enough reserved memory will be free for processing the new session. In other words the new session inherits the total amount of reserved memory assigned to the sessions ahead of it in the dependency list. If the amount currently reserved is greater than or equal to the amount required by the new session scheduler does not reserve any additional memory since sufficient memory for the new session will be released once the previous entries have finished processing. In some embodiments dependency list may contain additional information than is illustrated in the example of . As another example dependency list may factor in the priority levels of different sessions instead of being organized solely on a first come first served basis.

Dependency list may be composed of a subset of the entries of session list . Anti virus device may maintain session list and dependency list in the form of one or more tables databases link lists radix trees databases flat files or any other data structures. In another embodiment scheduler may maintain multiple dependency lists to increase system performance. Using more than one dependency list may result in higher throughput when operating in the constrained mode since multiple first session entries will be processed at one time i.e. the first session on each dependency list .

When the requirement of the new session is greater than the currently reserved amount YES branch of scheduler reserves additional memory from reserved buffer pool to the new session to cover the difference so that when AV engine finishes processing the sessions ahead of the new session on dependency list sufficient memory resources will be available for processing the new session. In particular scheduler reserves an amount of memory equal to the difference between the memory required by the new session and the amount currently reserved for existing sessions. Scheduler adds a new entry to dependency list for the new session and updates the stored currently reserved amount .

AV engine then scans the file for any viruses . In the event AV engine detects a virus YES branch of anti virus device may take one or more programmed actions such as automatically dropping packet flows associated with the application layer communications within which the virus was detected . If AV engine does not detect any viruses NO branch of TCP proxy sends the file out to its destination . AV engine notifies scheduler the session is finished and that the memory from this session is now available . Scheduler updates the dependency list by removing the entry associated with the session that has been completed and recalculating the dependency list in view of the memory that has been made available .

TCP proxy copies the received data to the allocated packet buffer . AV engine assembles the file from buffer pool once TCP proxy has copied data corresponding to the entire file to the allocated packet buffer . AV engine then scans the file for any viruses . In the event AV engine detects a virus YES branch of anti virus device may take one or more programmed actions such as automatically dropping packet flows associated with the application layer communications within which the virus was detected . If AV engine does not detect any viruses NO branch of TCP proxy sends the file out to its destination . AV engine notifies scheduler the session is finished and that the memory from this session is now available . Scheduler updates the dependency list by removing the entry associated with the session that has been completed and recalculating the dependency list in view of the memory that has been made available . Scheduler may again check again to see whether any of the memory usage watermarks have been reached by the system and return to operating in the normal mode of . . If any of the watermarks is still reached scheduler continues operating in the constrained mode and opens the TCP window for the next session on dependency list .

Some time later a third session entry is added as shown in C. The third session requires five megabytes of memory. Scheduler compares the required memory to the amount of memory currently reserved. Since the required memory of the new session is greater than the amount of memory currently reserved scheduler reserves two additional megabytes of memory for the third entry. As a result once the first and second sessions have completed three megabytes will become available. With the addition of the two megabytes reserved for the third session five megabytes will be available for processing the third session. The amount of memory currently reserved is five megabytes.

Some time later a fourth session entry is added as shown in D. The fourth session requires ten megabytes of memory. Scheduler reserves five additional megabytes of memory for the third entry which is equal to the difference between the memory required and the currently reserved five megabytes. The amount of memory currently reserved is now ten megabytes.

Some time later a fifth session entry is added as shown in E. The fifth session requires eight megabytes of memory. Scheduler compares the required memory to the amount of memory currently reserved. Since the required memory of the new session is less than the amount of memory currently reserved scheduler reserves zero additional megabytes of memory for the fifth entry since the preceding sessions will free up sufficient memory upon completion to cover the needs of the fifth session. The amount of memory currently reserved is still ten megabytes.

Some time later the fourth entry of dependency list E has completed and is removed from the dependency list as shown in dependency list F. The fifth session moves up to become the fourth session and scheduler recalculates the dependency list. Entries one through three remain the same. Scheduler reserves three megabytes of memory from buffer pool to cover the difference between the amount that will become available after the previous sessions are completed and the amount required by the fourth entry. The amount of memory currently reserved is now eight megabytes. As this example illustrates sessions are not necessarily completed in the order they were added to dependency list particularly when scheduler is operating in normal mode.

Some time later the first entry of dependency list F has completed and is removed from the dependency list as shown in dependency list G. Scheduler moves each of the remaining sessions up in the dependency list and recalculates the dependency list. The session of the first entry of dependency list G requires two megabytes of memory so scheduler reserves two megabytes of memory to the first session. The second session on dependency list G requires five megabytes of memory which is three megabytes more than is reserved for previous sessions so scheduler reserves three megabytes of memory to the second session. The third session on dependency list G requires eight megabytes of memory which is three megabytes more than is reserved for previous sessions so scheduler reserves three megabytes of memory to the third session. The amount of memory currently reserved is eight megabytes.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

