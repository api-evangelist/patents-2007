---

title: Method and system for storage
abstract: A method and system for storage is provided that in one embodiment includes a store process that continually appends data to the end of a data file and without deleting the data file. Additions, changes and deletions to data are managed by adding new data to the file and changing appropriate pointers in the data file to reflect the new data. Various application programming interfaces are also provided so that the store process can operate transparently to higher level applications. Various plug-ins are also provided so that the store process can utilize different types, configurations and numbers of storage devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805897&OS=08805897&RS=08805897
owner: Redknee Inc.
number: 08805897
owner_city: Mississauga
owner_country: CA
publication_date: 20071213
---
This specification relates generally to computer hardware and software architecture and more particularly relates to a method and system for storage.

Relational databases were originally developed at a time when the speed of central processing units CPU were relatively slow the amount of random access memory was relatively small the size of hard disks was relatively small but the speed at which hard disks was accessed was relatively fast. Interestingly hardware advancements have now lead to a different paradigm where CPUs are relatively fast the amount of random access memory is relatively high the size of hard disks is relatively large but the speed at which hard disks are accessed is relatively slow. This new paradigm means that where large amounts of data are written in relatively small blocks across a large hard disk the speed at which that data can be accessed is somewhat limited.

A method and system for storage is provided that in one embodiment includes a store process that continually appends data to the end of a data file and without deleting the data file. Changes to data structures are managed by adding new data to the file and changing appropriate pointers in the data file to reflect the new data. Various application programming interfaces are also provided so that the store process can operate transparently to higher level applications. Various plug ins are also provided so that the store process can utilize different types configurations and numbers of storage devices.

Another aspect of the specification provides a skip list data structure readable by a processing unit. The processing unit is configured to perform operations on contents of the data structure. The skip list data structure comprises a root object a first child object and a plurality of additional child objects. The root object includes a pointer from said root object to said first child object. The root object also includes a pointer from the root object to every other one of the additional child objects. The every other one of said additional child objects including a pointer to one of each of said additional child objects to which said root object does not point.

Referring now to a system for storage is indicated generally at . System can be based on a now known or future conceived computing environment. To provide an example shows a block diagram representing exemplary components of system . System thus includes a processor which can also be referred to as a central processing unit which interconnects input devices if present e.g. a mouse and keyboard and output devices if present e.g. a display . Processor can be implemented of course as a plurality of processors or one or more multi core processors. Processor is also connected to a persistent storage device . Persistent storage device can be implemented using for example a hard disc drive a redundant array of inexpensive discs RAID or the like and or can include other programmable read only memory PROM technology a removable smart card and or can comprised combinations of the foregoing.

System also optionally includes a network interface that connects processor to a network not shown which in turn can connect to one or more additional persistent storage devices not shown that are similar in function to persistent storage device .

System also includes volatile storage which can be implemented as random access memory RAM which can be used to temporarily store applications and data as they are being used by processor . System also includes read only memory ROM which contains a basic operating system containing rudimentary programming instructions commonly known as a Basic Input Output System BIOS that are executable by processor when system is initially powered so that a higher level operating system and applications can be loaded and executed on processor . Collectively one can view processor volatile storage device and ROM as a microcomputer. It should now be apparent that system can be based on the structure and functionality of a commercial server such as a Sun Fire X4450 Server from Sun Microsystems Inc. of Palo Alto USA but it is to be stressed that this is a purely exemplary server as server and other elements of system and its variants could also be based on any type of computing device including from other manufacturers.

The microcomputer implemented on system is thus configured to store and execute the requisite BIOS operating system and applications to provide the desired functionality of system . In particular system is configured so that a plurality of processes is executable on processor . In processor is represented as configured to execute the following processes store read commit and root each of which can be invoked by commands entered via keyboard and or via other processes not shown executing on processor . Also in persistent storage is shown as maintaining a file that can be operated upon by store read commit and root as will be discussed in greater detail below. File in is shown as being empty only including an end of file marker EOF which is located at Location zero L within file .

Referring now to a flow chart depicting an exemplary method of implementing store is indicated generally . Exemplary performance of store is represented in as an object O is shown as being taken from volatile storage and stored within file using store . At block a write command is received. Such a write command can be received by store using any known means including a direct command inputted via keyboard or via another process not shown executing on processor . At block the object to be written is received. The object received at block is associated with the write command received at step . At block the end of file is sought. As part of block store accesses file and seeks end of file marker EOF in file in order to determine the Location of end of file marker EOF. Taking the result from block at block store defines the write Location in file for object O which in the present example is Location L. At block the object is written at the Location defined at block . Block is represented in as object O is shown now located at Location L within file . At block an object identifier is defined that is associated with object O as it is now stored in Location L. The object identifier can be any index or pointer that now reflects Location L. At block the end of file marker EOF is redefined to the Location after the Location in which the object has been written at step . In the present example as shown in end of file marker EOF is now shown as stored in Location L.

It should now be understood the repeated performances of store will continue to append objects to file . For example assume that store is executed again for a second object O immediately after the preceding exemplary performance of store for object O. As a result of such performance file would appear as represented in with object O in Location L object O in Location L and end of file marker EOF at Location L. To continue with this example the object identifier for O is Location L. According to this example Table I below shows another representation of the contents of file that corresponds to .

Thus Table I corresponds to the file as shown in with the one exception that Table I additionally includes a column titled Active which is not actually reflective of file contents but instead represents whether the particular object in the respective Location of Table I is currently in use or not. The purpose of the Active column will become clearer from further reading below.

The teachings herein are applicable to the storage of many types of file structures. One exemplary type of file structure is a tree structure. Building on the example of file in and Table II shows object O and object O represented as part of a very basic tree structure T with a root and single child node wherein object O is the root and object O is the child node. Accordingly pointers are also needed identify the relationships in the tree structure. Thus a root marker RM is additionally needed with a pointer to the Location of object O. Table II builds upon Table I and includes such pointers.

Referring now to a flow chart depicting an exemplary method of implementing commit previously mentioned in relation to is indicated generally . Commit can be used to add root marker RM. shows system wherein file reflects the contents of Table II including the invocation of commit in order to include root marker RM and appropriate pointers in file . At block the commit command is received. Such a commit command can be received by commit using any known means including a direct command inputted via keyboard or via another process not shown executing on processor . At block the object ID to be written is received. The object ID received at block is associated with the commit command received at step and typically embedded therein. In the present example the commit command includes the parameter O to identify object O. At block the root marker is appended. As part of block commit accesses file and seeks end of file marker EOF in file in order to determine the location of end of file marker EOF and then defines the write location for the root marker RM and moves end of file marker EOF to location L. Additionally root marker RM is stored to include pointer P which points to object O in location L and object O is stored to include pointer P which points to object O in location L. Those skilled in the art will now recognize that file now stores object O and object O in a manner that corresponds to tree structure T shown in .

It should now be understood that store and commit can be performed any number of times and file will grow in size particularly in light of the fact that no delete command is utilized. For example assume that tree structure T is to be replaced by tree structure T shown in . Tree structure T includes a root containing object O and a child node containing object O. When store is performed twice to store object O and object O and when commit is performed once to identify object O as the root file will have the appearance as shown in . Table III shows a corresponding representation of file in .

Of note is that file continues to grow but object O object O and the root marker RM in location L are no longer active. However it is to be reemphasized that the Active status column is not expressly maintained by file but is the effective result of utilizing store and commit as previously described. Indeed the active status need not even be relevant depending on the intended use of file since tree structure T in the form of object O object O and the root marker RM in location L is still available on an archive basis.

Referring now to a flow chart depicting an exemplary method of implementing root previously mentioned in relation to is indicated generally . Root can be used to locate the root of a given tree structure stored within file . shows system representing exemplary performance of the method in . At block the root command is received. Such a root command can be received by root using any known means including a direct command inputted via keyboard or via another process not shown executing on processor . At block a seek to end of file is performed. At block a backwards scan through file is performed until the root marker RM is found. In the case of Table III the backwards scan reaches the root marker RM in location L and thus it can be seen where there is more than one root marker RM in a given file only the root marker RM nearest the end of file marker EOF will be found at block . Accordingly the remaining root markers RM in a given file are effectively rendered inactive without the need to expressly identify them as such. At block the root is located. Block is performed by examining the pointer associated with the root marker RM found at block . In this example the pointer references location L where object O is stored. At block the root found at block is returned and thus in this case object O is returned to root for further processing.

Referring now to a flow chart depicting an exemplary method of implementing read previously mentioned in relation to is indicated generally . Read can be used to read the contents of a given object within file . shows system representing exemplary performance of the method in . At block the read command is received. Such a root command can be received by read using any known means including a direct command inputted via keyboard or via another process not shown executing on processor . Additionally at block an object identifier OID associated with the read command is received. In a basic form the object identifier can be one of the locations L L within file in . In more complex scenarios the object identifier itself can be a variable e.g. X that itself points to the location L L so that if the object is changed by writing it again at a subsequent location within file using store then the location associated with the variable is updated at the time it is written. In a present example object identifier OID is the location L. At block the location of file associated with the location associated with object identifier OID is accessed which in this example is location L. At block the contents of the location accessed at block are returned which in this example is object O as stored in location L.

Referring now to another implementation of system is shown. In system additionally includes a plurality of higher level application program interfaces API . APIs in a present embodiment include a file system interface a B tree B tree interface a skip list interface a store and forward interface and a geographic interface . APIs in turn can be accessed by a data access object DAO a structured query language SQL . All of the foregoing can be accessed by an application . It should now be apparent that store is in and of itself an application program interface which can be utilized directly or indirectly by APIs DAO SQL or application . Such utilization of store can be substantially transparent such that the exact means by which store actually interacts with file is completely unknown and substantially irrelevant to the operation of APIs DAO SQL or application . It should also be understood that system as shown in can be varied to include none of or one or more of APIs DAO SQL or application .

In system additionally includes a plurality of lower level plug ins . Plug ins in a present embodiment include caching plug in a clustering plug in a partitioning plug in a sequencing plug in a monitoring plug in and a remoting plug in . It should also be understood that system as shown in can be varied to include none of or one or more of plug ins . Each plug in can be used to influence and or enhance how store interacts with file . It should now also be apparent that regardless of which plug ins are used such plug ins are also transparent to APIs DAO SQL or application .

File system interface can be based on any suitable file manager such as the well known file manager interface found within a Windows operating system from Microsoft Corporation Redmond Wash. USA.

B tree interface discussed further below can be an interface that automatically manages the storage including deletion and appending of objects maintained in a B tree structure on behalf of a higher level application. While the present example is a B tree in other embodiments similar tree structures are contemplated such as B Tree B Tree binary tree trie and the like. 

Skip list interface can be an interface that automatically manages the storage including deletion and appending of objects maintained in a linked list structure on behalf of a higher level application.

Likewise store and forward interface is also an interface that automatically manages storage of objects maintained in the structures bearing similar name to the respective interface. Store and forward interface can be used to implement clustering since with clustering changes to the local store are communicated to remote stores so that remote stores can make the corresponding changes local to their copies as well. In this example remoting plug in would be used in conjunction with store and forward interface . In the event the remote server being accessed by remoting plug in is temporarily inaccessible then data would be stored somewhere until such time as the missing resource becomes accessible again all of which would be managed by store and forward interface . All updates for the remote node would be stored in a store and forward structure until they could ultimately be delivered.

Geographic interface manages the storage of objects that represent geographic locations as might be implemented using a quad tree. It should now be apparent that interfaces in general manage the storage structure as that structure is utilized by higher level applications and such interfaces access store accordingly. Interfaces can issue interact with store via block and block as per the method shown in . Though not shown in interfaces can likewise interact with read commit and root .

DAO SQL and application represent higher level applications or interfaces which directly or indirectly utilize store .

Caching plug in can work transparently with and on behalf of store such that storage of certain objects according to store are temporarily stored in volatile storage or a separate volatile storage device not shown according to a given criteria. When the criteria is satisfied those objects are actually flushed to persistent storage device in the manner described above.

Clustering plug in can work transparently with and on behalf of store such that file is spread across a plurality of persistent storage devices not shown in .

Partitioning plug in is similar in concept to clustering plug in and can also work transparently with and on behalf of store such that portions of file are stored across a multiple number of persistent storage devices . By way of further explanation clustering plug in stores all data to all persistent storage devices whereas partitioning plug in typically only stores a subset of data across each persistent storage device. Also with clustering updates can originate from multiple locations whereas with partitioning updates typically occur from one location unless there is further partitioning.

Sequencing plug in can be implemented as a variant of clustering plug in utilizes a plurality of persistent storage devices not shown in sequence such that when one persistent storage device is full the file is continued on the next persistent storage device. Sequencing plug in can also be implemented so that data inserted during the same time period e.g. during one day or week are all stored in the same file. This implementation can make time based retention policies simple ie. deleting data after 90 days for example as one just drop whole files of when the data in them expires.

Monitoring plug in can be used to assess the utilization of persistent storage device or multiples thereof so that operations from store can be moderated to accommodate any restrictions associated with a given persistent storage devices.

Remoting plug in can be used where a remotely connected persistent storage device not shown is connected to network interface in order to permit store to utilize such remotely connected persistent storage devices.

It is to be reemphasized that the components relative to interfaces and plug ins as introduced in can be mixed and matched according to any desired combination. shows one such simplified example wherein B tree interface is shown alone in conjunction with store as being accessed by application . shows a B tree T stored in volatile storage which is to be written to file . shows an example of B tree T in greater detail that is be stored by application using B tree interface and store . When completely stored file will appear as shown in . B tree interface issues the instructions to store and to commit as appropriate so that file has the structure of storage locations pointers root marker and contents that are reflective of B tree T as shown in all in a manner transparent to application . B tree T can now likewise be accessed by application via tree interface using read and root .

File from this point will simply grow in size. For example shows B tree T A which adds object O as a child depending from object O. The top half of shows B tree T beside its corresponding version of file reproducing B tree T from and file from . Assuming that object O is simply added to B tree T to produce B tree T A by application then B tree interface will work with store and commit such that file is grown so that it appears as shown in the lower half of . To further assist in the foregoing Table IV shows the contents of file as shown in and in the top half of corresponding to the initial storage of B tree T 

To further assist in the foregoing Table V shows the contents of file after file is updated from the state shown in Table IV and as also shown the bottom half of corresponding to the storage of B tree T A in File by B tree interface and store after application appended object O to object O and instructed that B tree T A be persistently stored.

Using the foregoing it will now be understood that deletion of nodes can be effected in a similar manner whereby file just continues to grow and various locations cease to be active and new locations in file are written to even with duplicates of data already present within file in the event that new pointers are required.

As another example that the components relative to interfaces and plug ins as introduced in can be mixed and matched according to any desired combination shows another simplified example wherein skip list interface is shown alone in conjunction with store as being accessed by application for the purpose of storing a skip list SL currently being maintained in volatile storage . shows an exemplary skip list SL that can be implemented using the teachings herein. In skip list SL the root is object O which points to objects O O and O. Object O points to object O and object O points to object . Thus skip list SL differs in structure from a B tree. Those skilled in the art however will now recognize using the previous teachings herein that skip list interface can be configured to work with store to create a version of file that reflects skip list SL and by extension the various ways that skip list SL can be stored within file . It is further worth noting that in a new skip list SL A is provided which is the same as skip list SL except that object O has been added and that object O now additionally points to object O. Assuming that a version of file already exists that reflects skip list SL then as object O is added to file it is only necessary to write object O for the first time into a new location in file and rewrite object O into a new location in file so that pointers to object O and object O can be provided and to rewrite object O into a new location in file so that the pointer to the new location of object O can be provided. Otherwise objects O O O and O can remain active within file and need not be rewritten into new locations of file .

 Those skilled in the art will now recognize that skip list SL is a novel skip list as in order to be a traditional skip list object O would need to point to object O object O would need to point to object O and object O would need to point to object O. Thus skip list SL is in fact a novel skip list. Skip list SL is therefore a novel embodiment in and of itself. Skip list SL can have many uses such as journal based storage. 

As another example that the components relative to interfaces and plug ins as introduced in can be mixed and matched according to any desired combination shows another simplified example wherein store is shown with partition plug in and sequence plug in which can be implemented collectively as a single plug in referred to herein as compound storage plug in and in turn three different additional instances of store are provided namely store A store B and store C. Similar additional instances of read commit and root are also provided but not shown in . Store A store B and store C are accessible to plug ins and . Note that the exact placement of each plug in in relation to each instance of store may not be exactly as shown in during an actual implementation. For example an instance of plug in could in practice not be implemented above store A store B and store C but instead below each one of store A store B and store C. In system also includes three persistent storage devices A B and C each with its own respective file A B and C. In this highly simplified example file A B and C each only have two locations. Therefore in order to store four objects O O and identify one of those objects as a root and to have an end of file marker EOF partition plug in and sequence plug in cooperate with store A store B and store C to store objects O O the root marker and the end of file marker across storage devices A B and C. It can be desired to implement system according to when the sizes of devices A B and or C are limited and or where it is desired to keep a long historical record of changes. A read can be effected to any one of the devices A B C. When the devices A B C become full a new device can be added.

As a further enhancement it is to be understood that partition plug in can be implemented if desired in accordance with the teachings of co pending and commonly assigned U.S. patent application Ser. No. 11 693 305 filed Mar. 29 2007 now U.S. Pat. No. 7 680 766 the contents of which are incorporated herein by reference.

As another example that the components relative to interfaces and plug ins as introduced in can be mixed and matched according to any desired combination shows a more complex example including a plurality of separate servers remotely connected to each other with processor A representing the processor of the first server processor B representing the processor of the second server and processor representing the processor of the nth or final server Processor A includes store cache plug in partition plug in and remote plug in as previously discussed. Remote plug in can communicate with store on processor B and store on processor . Processor B and processor themselves each implement cache plug in partition plug in and sequence plug in which make use of two persistent storage devices local to each processor B and . The configuration in highlights the highly scalable nature of the teachings herein to provide large amounts of storage capacity with transaction speeds that can be described as at least good and potentially much better than current commercial database solutions offered by Oracle Corporation 500 Oracle Parkway Redwood Shores Calif. 94065 and others. Furthermore such storage can be provided relatively inexpensively.

It should now be apparent that many other combinations subsets and variations of interfaces and plug ins across one or more physical servers are within the scope of the teachings herein. In general it should now be understood also that combinations subsets and variations of all of the embodiments herein are contemplated.

Indeed the present novel system and method for storage can present some advantages in certain implementations. For example the inventor has done research leading the inventor to believe that a properly configured implementation can provide disk accessing speeds of up to 1.5 million transactions per second. A still further potential advantage from a properly configured implementation where the persistent storage is based on Flash drives can ultimately lead to longer life for such Flash drives as a properly configured implementation of certain embodiments can lead to substantially equal use of all memory locations in the Flash drive or at least more equal use of those memory locations than the prior art. Since memory locations in Flash drives burn out after a certain number of uses the useful life of such Flash drives can conceivably be extended. As a still further potential advantage properly configured implementations of certain embodiments can provide databases where recording of changes to those databases is automatically effected.

In addition the teachings herein can in properly configured implementations support Relational object oriented Temporal Network Hierarchical Inverted Index search engine Object Relational Geographic and other persistence paradigms which can all be combined into the same database at the same time.

In addition teachings herein can support in properly configured implementations a single top level first in first out read write queue that would suffice for an entire system. No internal synchronization would be required for read operations. This is possible because Objects are never updated only replaced which can provide good in memory performance.

In addition Compact Disk Representation of Objects can be provided using certain properly configured embodiments of the teachings herein. As known to those skilled in the art relational databases using fixed size rows can be very wasteful for cases where many rows are unused or usually contain a default value or when large strings values are used to store only small values on average. The teachings herein can in properly configured implementations support storage of non default values and so that only amount of string data which is actually used is stored. This can lead to significant performance and disk space efficiency improvements.

In addition bursty traffic can be more readily accommodated using properly configured embodiments of the teachings. Under short periods of heavy load a journal garbage collector would execute at a lower priority or not at all thus allowing for higher peak loads than what could normally be sustained.

In addition properly configured embodiments of the teachings herein can provide Large Collection Support and obviate the need for a Separate Transaction Journal. This means that transactions can be easily supported without incurring the overhead normally associated with their use.

In addition properly configured embodiments of the teachings herein can obviate Separate Clustering Channels. This means that larger clusters can be supported more efficiently. A ten fold increase over certain configurations of current clustering performance could be realized.

In addition properly configured embodiments of the teachings herein can provide scalability because data is never updated only replaced there is a reduced and possibly zero possibility for corruption. Properly configured embodiments can be equally suitable for databases of all sizes. For small databases it can be as fast as completely in memory systems. Large databases can be scaled in the same way as completely disk based systems. This can allow one to code all of databases in the same way without forcing the use a different system depending on your performance or size requirements.

