---

title: Textual image coding
abstract: Textual image coding involves coding textual portions of an image. In an example embodiment, a textual block of an image is decomposed into multiple base colors and an index map, with the index map having index values that each reference a base color so as to represent the textual block. A set of neighbor index values are ascertained for a particular index of the index map. A context that matches the neighbor index values is generated from among multiple contexts. The matching context includes a set of symbols. At least one symbol-to-value mapping is determined based on the matching context and a symbol to which the particular index corresponds. The particular index is remapped to a particular value in accordance with the symbol-to-value mapping and the symbol to which the particular index corresponds.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07903873&OS=07903873&RS=07903873
owner: Microsoft Corporation
number: 07903873
owner_city: Redmond
owner_country: US
publication_date: 20070913
---
Images today are often stored manipulated and transmitted in electronic format. Especially with regard to the storage and transmission of images the size of the data for an electronic image continues to be important. Generally the smaller the size of an electronic image the easier it is to store or transmit. The size of the data for an electronic image may be reduced by compressing the data. Unfortunately appreciable compression is often lossy which means that information is lost during a compression and decompression cycle. This lost information results in the visual quality of the image being degraded after the decompression.

In other words although higher compression facilitates the storage and transmission of an image such compression usually degrades the resulting visual quality of the electronic image after decompression. Consequently a balance is typically struck between an implemented compression ratio and good visual quality. One way to improve this balance is to improve the compression algorithm that is applied to the electronic image. If the compression algorithm is improved a higher compression ratio can be attained without sacrificing visual quality. A novel and superior compression algorithm that is particularly applicable to images having textual portions is described herein below.

Textual image coding involves coding textual portions of an image which may have both textual and graphical portions. In an example embodiment a textual block of an image is decomposed into multiple base colors and an index map with the index map having index values that each reference a base color so as to represent the textual block. A set of neighbor index values are ascertained for a particular index of the index map. A context that matches the set of neighbor index values is generated from among multiple predetermined contexts. The matching context includes a set of symbols. At least one symbol to value mapping is determined based on the matching context and a symbol to which the particular index corresponds with the symbol to value mapping including at least one mapping from a respective symbol to a respective value. The particular index is remapped to a particular value in accordance with the symbol to value mapping and the symbol to which the particular index corresponds. After the index map is converted by remapping each index thereof the converted index map and the base colors may be coded to compress them.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure application programming interface API arrangement etc. implementations are described herein.

With the rapid development of the Internet and the widespread adoption of rich media applications compound images are produced in addition to natural images. Compound images may include but are not limited to web pages slides posters and so forth. Compound images include textual portions and graphical portions. The textual portions include for example alphanumeric or other characters in various fonts that are formed from pixels e.g. bit mapped or are otherwise not currently recognized as being individual whole characters. The graphical portions include for example natural pictures.

For natural pictures many existing image and video coding standards e.g. JPEG2000 and H.264 AVC have demonstrated good coding performance. However they are inadequate at compressing compound images especially due to any textual portions thereof. In an example embodiment textual portions and graphical portions of a compound image are distinguished. The textual portions are then coded using an approach that differs from that of the graphical portions.

For an example embodiment image is encoded by encoding procedure . Textual portion is encoded using a first encoding approach and graphical portion is encoded using a second different encoding approach. A compressed version of image is then communicated from one device to another device and or from one memory to another memory via communication procedure . An example device that may be used to implement embodiments for textual image coding is described herein below with particular reference to .

After communication procedure decoding procedure is applied to the compressed version of image to produce a decompressed version which is termed the reconstructed image . A first decoding approach is applied to the compressed version of textual portion to produce reconstructed textual portion . A second decoding approach is applied to the compressed version of graphical portion to produce reconstructed graphical portion . Although images include both textual portions and graphical portions the inventive principles as described herein are also applicable to images that include only textual portion s .

For an example embodiment image is divided into and thus includes multiple blocks . These blocks may be of any size shape or proportion. However an example value for such blocks is 16 pixels by 16 pixels. Block type identification procedure is applied to each block . Each block is thereby distinguished as being a textual block T or a graphical block G .

Any technique may be used to identify blocks as textual portions or graphical portions. By way of example only the techniques described in co pending U.S. Nonprovisional patent application Ser. No. 11 276 342 entitled Block Based Fast Image Compression which was filed 24 Feb. 2006 by inventors Feng Wu et al. and assigned to the same Assignee MICROSOFT Corp. may be employed to implement a block type identification. Although blocks are distinguished as being of one of two image portion types there may alternatively be more than two possible types of image blocks. Similarly graphical blocks G may be subdivided into different types of graphical blocks e.g. smooth hybrid etc. . Each respective image block type may be encoded using its own respective algorithm type. It should be understood that for images that are known to have only textual portions the block type identification procedure may be omitted.

Generally input block T represents pixels that form at least part of one or more characters of a textual portion of an image. Each pixel color of input block T is represented by one or two letters as follows LB light blue DB dark blue B black DY dark yellow and LY light yellow. Thus the top row includes eight pixels that are from left to right as follows light blue light blue dark blue black dark yellow light yellow light yellow and light yellow.

In an example embodiment input block T is decomposed into base colors and an index map . Base colors are colors that are extracted from input block T . Each color of base colors is associated with a value such as a numerical value. In the illustrated example light blue is associated with 0 dark blue is associated with 1 black is associated with 2 dark yellow is associated with 3 and light yellow is associated with 4. The pixel colors of input block T are represented by index map as a matrix having the numerical values that are associated therewith by base colors .

Index map represents the structural information contained in the pixels of input block T . Index map therefore has the same dimension as input block T which is eight by eight in this example. The top row of index map includes eight index values that are from left to right as follows 0 0 1 2 3 4 4 and 4. In an example embodiment base colors and index map are separately coded. To enable a more efficient coding and a likely higher compression ratio index map is coded by remapping the index values based on multiple contexts using a structure aware paradigm. Example contexts and methods for this remapping are described further herein below especially with reference to et seq.

Next an example embodiment of a scheme for textual image coding is described generally. As illustrated in textual blocks are represented in the spatial domain using multiple base colors and an index map. The index map indicates the structural information of a textual block. To decompose a textual block a color quantization algorithm is applied to generate this representation which is followed by a structure aware context adaptive arithmetic encoding.

With regard to color quantization generally traditional color quantization methods such as vector quantization and K means are designed to minimize the distortion for the display of a limited number of colors. However the entropy of the color quantized image may be high which makes it difficult to compress. In an example described approach the number of bits for compression is also considered during color quantization. Because base colors cost far fewer bits than the index map the entropy of a textual block usually depends primarily on the index map. To reduce the entropy the diversity and disorder of the index map is constrained. To do so a two step quantization process is used to achieve the rate and distortion trade off.

As a first step a local quantization is performed to cluster neighboring similar pixels into a group. This ensures or at least increases the likelihood that neighboring pixels will tend to be quantized to the same base color. As a result the disorder of the associated index map is reduced. In particular given an allowed maximum distortion among neighboring pixels each neighboring pixel with distance under a threshold are clustered to the same group which is represented by their average value.

As a second step the block after local quantization is further quantized to multiple base colors. Specifically the pixels in the same group are quantized to the same color. The total number of base colors of a given block depends on the content. Instead of quantizing each block to a fixed number of colors the allowed maximum distortion is set to be a constant. By way of example only the constant may be equal to q 4 where q is the quantization step used in an H.264 Advanced Video Coding H.264 AVC aka MPEG 4 Part 10 intra coding. With this example the number of base colors of a 16 16 macroblock may vary from 1 to 8. In practice a tree structure vector quantization TSVQ method may be employed in which each pixel is treated as a vector. With a TSVQ method the maximum distortion may be the criterion to split a tree in TSVQ.

In an example embodiment with regard to the entropy coding for a textual block both the base colors and the index map may be compressed with a context adaptive arithmetic coder. The YUV components of a base color are first quantized. Index maps show similar patterns among many different textual blocks. Predetermined contexts and predefined remappings are used to exploit the similar patterns to enhance the compression.

When coding an index map the indices are arranged in scan line order. The predetermined context that matches an index to be coded is deduced from its neighboring index values. The current index value is then remapped to a symbol according to its matched context and neighboring indices and the symbol is coded with an arithmetic coder using the context. Example predetermined contexts are described herein below with particular reference to and example predefined mappings are described herein below with particular reference to .

At block each graphical block is encoded. At block each textual block is decomposed into one or more base colors and an index map. At block each decomposed textual block is encoded using coding contexts and remappings. Example structural aware coding contexts are described herein below with particular reference to . Example predefined mappings are described herein below with particular reference to . At block an encoded bitstream having compressed graphical blocks and compressed textual blocks is transmitted from a first device and or memory.

At block the encoded bitstream is received at a second device and or memory. At block the compressed graphical blocks are decoded to produce reconstructed graphical blocks. Each decomposed textual block that was received in a compressed form is decoded at block using the remappings and the coding contexts. At block each decomposed textual block that has been decoded is recomposed by combining the decoded base colors and the decoded index map into a reconstructed textual block. A version of the original image is reconstructed at block by merging the decoded and reconstructed graphical blocks with the decoded and reconstructed textual blocks. After all or part of the image has been reconstructed it may be presented on a display device including a screen printer and so forth.

There are up to four different possible symbols or shapes for each context. Each shape represents a neighboring index while the different shapes indicate the different potential index values. By way of example only the illustrated symbol shapes or more generally symbol types are a circle a square a triangle and a hexagon. The neighboring indices corresponding to symbols may be considered proximate when they are sufficiently close to a particular index so as to act as probabilistic predictors of the color symbol of the particular index.

In an example embodiment the four proximate neighboring indices are adjacent. These four adjacent neighboring indices include two that are along the cardinal directions e.g. left right top or bottom and two that are along the diagonal directions e.g. left top right top left bottom or right bottom . A different number of neighboring indices other than four may alternatively be used for the contexts. More specifically the four adjacent neighboring indices as illustrated include a left index a left top index a top index and a right top index.

The definitions of left right top and bottom are with respect to the scan line pattern and not necessarily with respect to the texture of the image although they can be so defined . In other words the first line of a block being scanned for coding and the direction of such scanning determine the top of the block and the left right or right left pattern respectively. In other words the selection of e.g. four neighboring indices for the contexts may be based on which neighboring indices are known when a particular index is being mapped in dependence on the scan line pattern.

The contexts of any given category a e each have the same number of different color indices as established by the neighboring indices of a current index being remapped. The single context of context category a has four identical neighboring color indices. The contexts of context category b have exactly three identical neighboring color indices. Context category b includes four different contexts to represent the four possible positional permutations of four indices in which one and only one index differs from the other three.

The contexts of context category c have two pairs of identical neighboring color indices. Context category c includes three different contexts. The contexts of context category d have exactly two identical neighboring color indices. Context category d includes six different contexts to represent the six possible positional permutations of four indices in which two are different from each other as well as from the two identical indices. The single context of context category e has no identical i.e. four different neighboring color indices.

Generally those index values of an index map that are represented by one of the symbols e.g. circle square triangle or hexagon are remapped. This remapping is performed because in the same structure aware context the probability distributions of indices correlate to the actual values of neighboring indices. Generally index values of neighboring pixels have higher probabilities than other values to occur in a current particular index being remapped.

The indices with high probabilities are remapped to small values. Taking a context of context category b as an example the index value corresponding to the circle symbol has the highest probability of occurrence. Hence this index value is remapped to 0 which makes the compression of the current index ultimately more efficient when taken with the textual block as a whole. The predetermined contexts of tabular diagram are defined such that the base color value having the greatest probability of being the current index based on its structure aware context is remapped to zero using the symbols e.g. the circle symbol . Example predefined context mappings for each of the context categories is described below with particular reference to .

The contexts of tabular diagram are primarily applicable to interior indices. More specifically they are not applicable to the top row or to the outside columns e.g. the far left and far right columns . However other contexts may be applied to the boundary indices whose neighboring indices are at least partially unavailable. These e.g. twenty two other contexts may be used to similarly code the boundary indices.

In an example embodiment the contexts of tabular diagram are carefully arranged such that the same symbol for any of the five context categories a e maps to the same index value. However the symbols of each context may be arranged differently. As is evident from tabular diagram the circular symbol maps to the index value 0 for each of the context categories a e . When present the square symbol maps to the index value 1 for each of the context categories b d . Similarly the triangle symbol maps to index value 2 for each of the context categories d and e and the hexagon maps to index value 3 for the context category e .

At block a context that matches the set of neighbor index values is generated from among multiple predetermined contexts the matching context including a set of symbols. For example if there are three identical neighboring color indices a predetermined context of having four symbols three of which are identical may be generated from the context category b to match the ascertained set of neighbor indices. To further illuminate certain principles of a described embodiment a specific pixel color example is provided. It is assumed for this example that the neighboring indices for the current index are dark blue for the left index black for the top left index dark blue for the top index and dark blue for the top right index. This corresponds to the second from left context in context category b . The circle symbol therefore corresponds to the dark blue pixel color and the square symbol therefore corresponds to the black pixel color.

At block a symbol to value mapping based on the matching context is determined the symbol to value mapping including at least one mapping from a respective symbol to a respective value. For example the index mappings of of the context category b are referenced. Circle symbols are mapped to zero for a dark blue pixel color and the square symbol is mapped to 1 for a black pixel color.

At block the current index is remapped to a value in accordance with which symbol of the symbol to value mapping corresponds to the current index. For example if the current index is dark blue and thus corresponds to a circle symbol then the current index is remapped to a zero value using the index mappings . If the current index is black and thus corresponds to a square symbol then the current index is remapped to a 1 value. If the current index does not match one of those in the set of neighbor index values i.e. if the color of the current index is neither dark blue nor black the value of the current index is unchanged by the remapping.

As illustrated image decoder generally includes graphical oriented components and textual oriented components . More specifically image encoder includes block identification switch a discrete cosine transformer DCT a quantizer an entropy encoder and multiplexer . Image encoder also includes a color quantizer an arithmetic coder a context adaptive arithmetic coder a context generator index remapper and a multiplexer .

In operation for an example embodiment an image is input to block identification switch . Block identification switch distinguishes between graphical blocks and textual blocks. Graphical blocks are forwarded to DCT and textual blocks are forwarded to color quantizer . DCT quantizer and entropy encoder may function in manners known in the art e.g. in accordance with H.264 AVC to encode a graphical block. For example DCT may apply a discrete cosine transform to the graphical blocks. The DCT coefficients are quantized by quantizer and the quantized DCT coefficients are encoded by entropy encoder . Other non entropy encoding may alternatively be used. Entropy encoder outputs a compressed graphical bit stream.

Color quantizer decomposer accepts as input the textual blocks from block identification switch . Color quantizer performs one or both of the steps described herein above for the two step quantization process. Namely color quantizer performs a local quantization to group neighboring pixels. Color quantizer further quantizes the colors of the grouped pixels into base colors. Afterwards color quantizer decomposer decomposes the color qunatized textual block into base colors and an index map. Color quantizer outputs the base colors and the color indices as the index map.

Arithmetic coder accepts the base colors as input from color quantizer and codes them to compress their data size. Other non arithmetic coding schemes may alternatively be employed. Arithmetic coder outputs the compressed base colors as a bit stream and forwards them to multiplexer .

Context adaptive arithmetic coder accepts as input the index map having the color indices from color quantizer . Before context adaptive arithmetic coder encodes the index map the color indices thereof are remapped by context generator index remapper . Context generator index remapper has access to neighboring coded pixels. For instance the neighboring coded pixels may be ascertained directly by context generator index remapper . Alternatively the neighboring coded pixels may be ascertained by another component e.g. color quantizer and or context adaptive arithmetic coder etc. and provided to context generator index remapper .

With reference to tabular diagram of the context generator of context generator index remapper generates a context that matches the ascertained neighboring pixels. The generated context includes one or more symbols and belongs to an associated context category a e . With reference to tabular diagram of an index mapping that is associated with the same context category is determined. The index remapper of context generator index remapper then remaps each particular pixel of the index map using the determined index mapping in accordance with the symbol to which the particular pixel corresponds.

After each of the indexed pixels of the index map is remapped context adaptive arithmetic coder encodes the remapped index map using an arithmetic coding scheme. Alternatively a non arithmetic context adaptive coder may be employed. The coded base colors are provided to multiplexer from arithmetic coder and the coded and remapped index map is provided to multiplexer from context adaptive arithmetic coder . Multiplexer combines the coded base colors and the coded index map into a compressed textual bit stream.

Multiplexer receives the compressed graphical bit stream from entropy encoder and the compressed textual bit stream from multiplexer . Multiplexer combines the compressed bit streams and forwards the combined compressed bit stream to a memory for storage to a network for transmission and so forth. Alternatively the compressed graphical and textual bit streams may be communicated separately.

As illustrated image decoder includes a demultiplexer and an image reconstructor . Generally image decoder includes graphical oriented components and textual oriented components . Graphical oriented components include an entropy decoder a dequantizer and an inverse DCT . Textual oriented components include a demultiplexer an arithmetic decoder a context adaptive arithmetic decoder a context generator index remapper and a recomposer .

In operation for an example embodiment a combined compressed bit stream is input to demultiplexer . Demultiplexer distinguishes between the compressed graphical bit stream having graphical blocks and the compressed textual bit stream having textual blocks. Graphical blocks of the graphical bit stream are forwarded to entropy decoder and textual blocks of the textual bit stream are forwarded to demultiplexer .

Entropy decoder dequantizer and inverse DCT may function in manners known in the art e.g. in accordance with H.264 AVC to decode a graphical block from a graphical bit stream. For example the compressed graphical bit stream may be decoded by entropy decoder . Other non entropy decoding may alternatively be used. The decoded graphical bit stream is dequantized by dequantizer and the dequantized graphical data is converted back to the spatial domain with inverse DCT to produce the decoded graphical blocks. The decoded graphical blocks are forwarded to reconstructor .

Demultiplexer accepts as input the compressed textual bit stream having textual blocks from demultiplexer . Demultiplexer separates the base colors from the color indices of the index map and outputs them separately. The base colors are forwarded to arithmetic decoder . Arithmetic decoder decodes the base colors. Another non arithmetic decoding scheme may alternatively be employed. The decoded base colors are forwarded to recomposer .

Context generator index remapper has access to neighboring decoded pixels of a particular pixel. These neighboring decoded pixels may be directly ascertained by context generator index remapper or they may be ascertained by one or more other components e.g. demultiplexer context adaptive arithmetic decoder etc. and provided to context generator index remapper . The context generator of context generator index remapper generates a context that matches the neighboring decoded pixels from among multiple predetermined contexts . The generated context as shown in tabular diagram of is a set of symbols.

The index remapper of context generator index remapper determines a symbol to value mapping based on the generated context using tabular diagram of . The symbol to value mapping includes at least one mapping from a respective symbol to a respective value. The index remapper also remaps the particular pixel to a particular value in accordance with which symbol of the symbol to value mapping corresponds to the particular pixel. Context generator index remapper then outputs the particular value for the particular pixel. This is repeated for each pixel of the index map.

Context adaptive arithmetic decoder accepts the multiple color indices from demultiplexer and each remapped value for each particular pixel from context generator index remapper . Context adaptive arithmetic decoder decodes the index map using the multiple color indices and the particular value for the particular pixel. For example context adaptive arithmetic decoder may decode the compressed index map pixel by pixel in conjunction with the decompressed index map being remapped by context generator index remapper . Another non arithmetic decoding scheme may alternatively be employed. It should be understood that after an index is decompressed with an appropriate decoding scheme by context adaptive arithmetic decoder the decompressed index is remapped by the index remapper of context generator index remapper . The remapped index is then used to decompress another e.g. the next index because the decompression of a current index involves using decoded neighbor indices. Context adaptive arithmetic decoder forwards the decoded index map to recomposer .

Recomposer accepts the decoded base colors from arithmetic decoder and the decoded index map from context adaptive arithmetic decoder and combines them to recompose the textual block. Recomposer forwards the recomposed textual block to reconstructor . Reconstructor therefore receives the decoded graphical blocks from inverse DCT and the decoded textual blocks from recomposer . Reconstructor reconstructs the image by combining the graphical blocks and the textual blocks.

Blocks and serve to decompose the textual block. At block the base colors of the quantized textual block are ascertained. At block an index map of the textual block is constructed responsive to the ascertained base colors. Blocks and pertain to the base colors. At block the base colors are encoded e.g. arithmetically . At block the encoded base colors of the textual block are communicated e.g. transmitted .

Blocks pertain to the coding including the remapping of the indices of the index map. At block for a particular index of the index map a matching coding context is generated based on one or more neighbor index values that are proximate to the particular index and with reference to a set of predetermined contexts e.g. of tabular diagram of .

At block responsive to a symbol that corresponds to the particular index and that is included in the generated coding context the value of the particular index is remapped based on predefined mappings e.g. of tabular diagram of . If the predefined mappings vary by context category then the remapping of the particular index may be performed responsive to a context category that is associated with the generated coding context corresponding to the particular index with the context category including one or more index mappings. Each index mapping maps a symbol to a value with the particular index corresponding to one of the symbols. At block the acts of blocks and are repeated for each index of the index map to convert the index map into a remapped index map.

At block the converted index map is encoded e.g. arithmetically . At block the encoded index map for the textual block is communicated e.g. transmitted .

At block an encoded index map is received. At block the encoded index map is decoded e.g. arithmetically . At block for a particular index of the decoded index map a matching coding context is generated with reference to a set of predetermined contexts e.g. of tabular diagram of and based on one or more neighbor index values that are proximate to the particular index.

At block responsive to a symbol that corresponds to the particular index and that is included in the matching coding context the value of the particular index is remapped based on predefined index mappings e.g. of tabular diagram of . Each index mapping maps a symbol to a value with the particular index corresponding to one of the symbols of the index mappings. At block the acts of blocks and are repeated for each index of the index map to reproduce the index map.

At block the decoded base colors and the decoded and remapped index map are combined to recompose the textual block s . At block the reconstructed textual blocks are output. In the drawings and are flow diagrams and respectively. Implementations of these flow diagrams may be realized for example as processor executable instructions. Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth. The acts of these flow diagrams may be performed in many different environments with a number of different devices and or in conjunction with a variety of different coding standards. Hence although the descriptions of certain blocks and the acts thereof reference other elements that are described herein they do so by way of example only. The order in which the methods are described is not intended to be construed as a limitation and any number of the described blocks can be combined augmented rearranged and or omitted to implement a respective method or an alternative method that is equivalent thereto.

Generally a device may represent any computer or processing capable device such as a server a desktop a notebook etc. computer a workstation or other general computer device a data storage repository apparatus a personal digital assistant PDA a mobile phone a gaming platform an entertainment device a router computing node a mesh or other network node a wireless access point some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In an example embodiment of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more human device interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports a network communications stack a radio and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii human device interfaces include those that communicate by wire or wirelessly to human device interface components e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device . Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth.

Thus realizations for textual image coding may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof image data structures context and mapping oriented data structures other data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology and one may be realized as a general purpose processor e.g. a central processing unit CPU a microprocessor a controller etc. a graphics processing unit GPU a dedicated or special purpose processor a derivative thereof and so forth. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media storage and transmission media e.g. wireless or wired communication channels hard coded logic media combinations thereof and so forth. Media is tangible media when it is embodied as a manufacture and or as a composition of matter. For example media may include an array of disks or flash memory for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed and or otherwise processed link s on network for transmitting communications and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein. Such functions include but are not limited to i those acts that are illustrated in flow diagrams and of and respectively ii those that are illustrated in the different described procedures scenarios etc. of iii those that are realized by the encoder and decoder of respectively iv those involving the contexts and mappings of respectively those of other algorithms described herein combinations thereof and so forth.

The devices acts aspects features functions procedures modules data structures techniques components etc. of are illustrated in diagrams that are divided into multiple blocks and other elements. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks and or other elements can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses arrangements etc. for textual image coding.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other example embodiments have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claimed invention.

