---

title: Shared persistent objects
abstract: A system and method are disclosed for an interactive multimedia file (iMF), running on an interactive multimedia runtime (iMR), to store an object onto a computer, the method comprising creating a local instance of the object, storing the local instance into a memory location on the computer, monitoring changes to one or more data slots of the local instance, assigning a version identifier to the local instance, synchronizing the local instance with a main instance of the object, and interfacing the one or more data slots of the local instance with said iMF during execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945916&OS=07945916&RS=07945916
owner: Adobe Systems Incorporated
number: 07945916
owner_city: San Jose
owner_country: US
publication_date: 20070912
---
The present application is a continuation of commonly assigned U.S. patent application Ser. No. 10 402 357 entitled SHARED PERSISTENT OBJECTS filed Mar. 28 2003 now U.S. Pat. No. 7 287 256 issued on Oct. 23 2007 the disclosure of which is hereby incorporated herein by reference.

The present invention relates in general to distributed computing and more particularly to shared media.

The client server relationship has opened vast areas of network operability. Whether implemented in a local area network LAN or the Internet the interaction between client entities and a centralized server forms the basis of the computing world today. Applications routinely incorporate remote use of data or logic to manage inventory employees sales and other such activities. Early client server applications involved remote access to databases to provide data for locally running applications. The management of such distributed functionality has advanced with several programming techniques and architectures. MICROSOFT CORPORATION S Distributed Component Object Model DCOM and Common Object Request Broker Architecture CORBA developed by Object Management Group are just two examples of architectures and specifications that allow programs at different locations and possibly developed by different vendors to communicate in a network through an interface broker.

With CORBA the essential concept is the Object Request Broker ORB . ORB support across a network of multiple computers with multiple clients and servers allows for a client program to request services from a server program or object without having to completely understand where that server program or object is or what the interface to that server program or object requires. ORB s communicate requests and return replies by using the General Inter ORB Protocol GIOP and when used across the Internet Internet Inter ORB Protocol IIOP . IIOP generally maps GIOP requests and replies into the Transmission Control Protocol TCP layer for each computer. Thus the interfacing of the different entities is transparent to the user. DCOM works in a similar manner using TCP Internet Protocol TCP IP and hypertext transfer protocol HTTP to communicate remote procedure calls RPCs to the compatible server objects.

Both DCOM and CORBA follow a similar step by step process. A local application or object requests services from another remote object. The remote object is located using the class ID CLSID for DCOM or client ORB for CORBA. This broker or agent arrangement operates in a similar manner to the stub and skeleton architecture used in Remote Procedure Call RPC communication. The stub which is a small piece of communication code on the client system operates as the proxy with the remote server performing all communications with the skeleton which is the corresponding communication code on the remote server. Therefore the client does not have to address the different interface possibilities with the remote server. Once the request for service has reached the server object at the remote server an instance of the object is downloaded to the client. The client may then run the instantiated object locally using the local user interface.

The common thread with DCOM and CORBA is that the distributed management performed by each architecture is directed to distributed computing. Code may be persistent between sessions and RPCs data is not. Therefore while logic may persist between sessions data is only session specific.

Another tool of distributed or remote interactive computing is the cookie. A cookie is data created by a server side connection such as a common gateway interface CGI script that can be used to both store and retrieve information on the client side of the connection. This addition of a simple persistent client side state significantly extends capabilities of Web based client server applications. The standard specification for cookies began with NETSCAPE COMMUNICATION CORPORATION s Persistent Client State HTTP Cookies and continues with RFC 2109 HTTP State Management Mechanism issued by the Network Working Group of the Internet Engineering Task Force IETF . These specifications define a size limit of 4096 bytes per cookie. Moreover a limit of 20 cookies per Web server is also defined which means than any one Web server can store a maximum of 20 4096 byte cookies on every client computer.

Cookies provide a way for Web sites to keep track of user patterns and preferences and with the cooperation of the Web browser store the cookies on the client computer. Hypertext Transfer Protocol HTTP which is the transfer protocol of the Web is a stateless protocol such that each request for a Web page is independent of all other such requests. Therefore the Web page server has no memory of the current state i.e. what pages or information has previously been sent to or exchanged with the client computer . Cookies provide the ability for the user to experience a personalized session by providing the Web page and Web page server data that creates a remembered state of the user Web interaction.

In a typical example of operation when a user at a client computer runs its Web browser and types in a Universal Resource Locator URL such as www.macromedia.com the browser communicates with the Web server and requests the macromedia.com home page. On the client side once the request is made the browser searches its cookie file for cookies designated for macromedia.com. If none are found no cookies are sent. On the server side the macromedia.com Web server receives the request and attempts to read any cookies that may be transmitted from the requesting browser. If none are available the Web server determines that this is the first time the client browser has visited the macromedia.com Web site. The macromedia.com Web server may then direct that a cookie or cookies be saved onto the client computer marking the visit and identifying the client side computer. When the client computer next makes a request for the macromedia.com home page it will now typically send the cookies designated for the macromedia.com Web site. The macromedia.com Web site will read the cookies and be able to adjust the user experience at the client side using this state information.

Some cookies persist only until the end of a specific browser session. Meaning that when the browser program is closed the cookies are erased. However when some cookies are created they include an expiration date after which the cookie will expire and be erased from the designated cookie file. Thus those cookies persist from one browser session to another residing on the client computer until the expiration date has been reached. Cookies may also be erased if the maximum cookie limit which is a standard specification is exceeded. In this situation the most least accessed cookies will typically be deleted first. Therefore most cookies are set once and then go away either 1 at the close of the current browser session 2 until the cookie expiration date is reached or 2 when the maximum number of cookies has been exceeded.

Cookies provide an adequate tool for simple Web interactions such as remembering login information setting up a shopping cart in an e commerce Web site or tracking user history information. However for more complicated distributed Internet applications cookies are somewhat inadequate. Cookies are limited solely to text formatting. Therefore they can provide no distributed functionality or logic. Cookies are also single version data. Once the cookie information is set it does not change until the cookie expires. New information must generally be saved as a new cookie. Furthermore cookies are accessible by URL paths so the capability exists for many different URLs may have an opportunity to use that information by including many different URLs in the path property of the cookie.

Representative embodiments are directed to a method for an interactive multimedia file iMF running on an interactive multimedia runtime iMR to store an object onto a computer executing the iMR the iMF processing with the object during operation the method comprising creating a local instance of the object storing the local instance into a memory location on the computer monitoring changes to one or more data slots of the local instance assigning a version identifier to the local instance synchronizing the local instance with a main instance of the object and providing the local instance to the iMF for processing during operation of the iMF.

Additional representative embodiments are directed to an application programming interface API having a plurality of instructions accessible by a developer wherein the plurality of instructions abstract manipulation of an object the object having a local instance and a central instance the API comprising a storage interface underlying the instructions for storing the local instance on a computer responsive to an interactive multimedia file iMF playing on an interactive multimedia runtime iMR wherein the storage interface maintains a local version indicator of the local instance and wherein the iMF uses the local instance in operation on the iMR a communication interface underlying the instructions for communicating with an interactive multimedia communication server iMCS wherein the central instance is stored on the iMCS the central instance including a central version indicator for each of a plurality of properties of the object and a version interface underlying the instructions for comparing the local version indicator with a corresponding one of the central version indicators wherein the version interface determines which of the local instance and the central instance is to be updated.

Additional representative embodiments are directed to a computer program product having a computer readable medium with computer program logic recorded thereon for manipulating an object across a network the computer program product comprising code accessible by a designer for selecting a constructor method for locally creating an abstract data type for use in an interactive multimedia file iMF locally running on an interactive multimedia runtime iMR wherein the abstract data type is either locally accessible only or remotely accessible wherein a remote abstract data type exists on an interactive multimedia communication server iMCS corresponding to the remotely accessible abstract data type code accessible by a designer for selecting an edit method to modify a plurality of data slots in the abstract data type and code for synchronizing the locally created abstract data type and the remote abstract data type to harmonize the plurality of data slots.

Additional representative embodiments are directed to a method for securing a local shared object comprising receiving a request from an interactive multimedia file iMF to create the local shared object under a requested name creating an instance of the shared object using the requested name storing the instance at a path location defined using a file path of the iMF and denying access to the instance by any requesting entity whose path does not match the path location.

Additional representative embodiments are directed to a computer program product having a computer readable medium with computer program logic recorded thereon the computer program product comprising code for receiving a request from an interactive multimedia file iMF to construct a local shared object using a user designated name code for creating an instance of the shared object using the user designated name code for storing the instance at a path location defined using a file path of the iMF and code for denying access to the instance by any requesting entity whose path does not match the path location.

Additional representative embodiments are directed to a method for an interactive multimedia file iMF running on an interactive multimedia runtime iMR to store an object onto a computer executing the iMR the iMF processing with the object during operation the method comprising storing the object into a memory location on the computer monitoring changes to one or more data slots of the object assigning a version identifier to the object and providing the object to the iMF for processing during operation of the iMF.

Additional representative embodiments are directed to a computer program product having a computer readable medium with computer program logic recorded thereon for an interactive multimedia file iMF running on an interactive multimedia runtime iMR to store an object onto a computer executing said iMR the iMF processing with the object during operation the computer program product comprising code for storing the object into a memory location on the computer code for monitoring changes to one or more data slots of the object code for assigning a version identifier to the object and code for providing the object to the iMF for processing during operation of the iMF.

Further representative embodiments are directed to a computer program product having a computer readable medium with computer program logic recorded thereon for manipulating an object across a network the computer program product comprising code accessible by a designer for selecting a constructor method for locally creating an abstract data type for use in an interactive multimedia file iMF running on an interactive multimedia runtime iMR wherein the abstract data type is either locally accessible only or remotely accessible code accessible by a designer for selecting an edit method to modify a plurality of data slots in the abstract data type code for establishing a version indicator representing an version of the plurality of data slots wherein the version indicator is compared with a set of remote version indicators when the abstract data type is remotely accessible and code for synchronizing the locally created abstract data type and the remotely accessible abstract to harmonize the plurality of data slots.

Instead of providing distributed computing using the persistent code attributes of DCOM or CORBA that do not have the capability for handling persistent data or using cookies that have a limited ability for persistent data without the capability for providing persistent or distributed code representative embodiments of the present invention provide a distributed object that may be shared in real time by any accessible client. The complex functionality of the shared distributed object is presented to a designer through a collection of abstract data types in an application programming interface API such that a designer with minimal programming skills and experience may effectively implement extremely complex features.

Object Oriented Programming OOP is a well known programming technique that decomposes problems into a collection of intercommunicating self contained entities composed of data and operations on the data. These self contained entities are called objects. Objects typically have an internal state which are the current values of its data and methods which are typically the only means by which the object s state can be inspected modified or processed by another object. is a conceptualized illustration of object . Object includes method portion comprising individual methods M M and data portion comprising data slots D D. Data slots D D may contain items such as plain values or other objects. For example data slot D may contain the string December or the integer 15 or even another object. Methods M M may contain logic instructions that may operate on the data contained in data slots D D. For example method M may contain logic for writing the value contained in data slot D to a certain memory location in the host computer.

Objects once created can be reused can intercommunicate and return values for any number of different desired tasks. An object has generally been shareable to the extent that the available data slots and corresponding methods are available to all host or client computers that have a copy of that object. However the data or state information contained in an object on one host is typically not persistent across multiple hosts or clients. Thus without more complexity added typical instances of objects transmitted in DCOM and or CORBA usually do not include any persistent data or state information.

In contrast to the architectures shown in . is a block diagram illustrating a representative embodiment of the present invention implementing shared object . Client computer includes interactive multimedia runtime iMR which is an application that may display and or interact with compatible multimedia files. One example of such a multimedia application is MACROMEDIA s FLASH player. Files compatible with MACROMEDIA FLASH are typically small web file .swf format. Thus iMR may run and display content from local .swf file or from remote .swf file or even both. IMR may direct shared object to be stored locally on client . Shared object comprises data and logic . Data and logic of shared object are used in the execution of the multimedia file. For instance if iMR were running .swf in which .swf were a shopping cart feature on an e commerce Web site shared object may include data for items in the shopping cart and logic that would typically be a part of a shopping cart such as inventory control summing tax calculations and the like. IMR may cause shared object to be stored locally resulting in the necessity of very few page calls to remote server because data and logic are already local to client .

In operation with a communication server such as iMCS shared object may also be shared by other clients with access to iMCS . IMR establishes a shared resource with interactive multimedia communication server iMCS . An iMCS is a communication server with special capabilities for handling multimedia communication. One example of such an iMCS is MACROMEDIA s FLASH COMMUNICATION SERVER . Following this association main shared object may be created. Main shared object includes data and logic . Periodically iMR contacts iMCS and updates data and logic from data and logic of shared object . Therefore the other sharing clients may maintain up to date information. In additional embodiments main shared object may originate from iMCS with client running iMR subscribing to it.

The shared object as described in the teachings of the present invention acts as a logic and data repository for an iMR instance. The MACROMEDIA FLASH player is one example of an iMR. MACROMEDIA FLASH movies i.e. .swf format files may originate from remote or local storage areas for execution within the local instance of the MACROMEDIA FLASH player. Data and logic that may be necessary or usable by the multimedia file may be stored as a shared object. Rather than making remote requests or calls for such data and logic the multimedia file may use local resources to store or maintain the data and logic used by the multimedia file. A multimedia file may be coded to implement a shopping cart a card catalog system a reservation system or other such interactive and data dependent application. When data and logic are stored locally as a shared object complex data operations may take place solely on the client computer without the need to keep an established connection to the remote server. The information processed on the client within the local shared object instance may periodically be communicated to the main instance of the main shared object on the remote server. Therefore instead of waiting for entry and retrieval of information concerning an electronic transaction from a remote server all of the entry retrieval and processing is completed on the client s system and then updating the remote instance. The interactive application would typically not need to refresh or page with new information retrieved from and stored to the remote server.

A shared object is created to maintain data and logic for an iMR in either a remote or local entity. In a remote or distributed system shared objects may be used for multiple users to experience a singular multimedia experience. For example in remote education applications a teacher at one location may be operating an electronic white board to write notes formulae or the like. Each student at a client computer may observe the activities on the electronic white board. Shared objects configured according to the teachings of the present invention may also be used to implement the remote education application. A shared object may be created to represent the white board cursor. Each client subscribes to the cursor shared object. As the data is updated on the white board the information is updated and changed on each instance of the shared object.

Returning to shared object represents the main version stored on iMCS . The shared object container includes a name SharedCursor and the container version 33. Shared object includes data slots labeled color xPos yPos type and visible. The data slots contain state information or data for each of the slots or properties. The color slot holds the hexadecimal value for a type of red 0xff0000. The x axis position for the cursor xPos holds the value 45 that may represent which pixel grid number the cursor is currently positioned on in the x direction. The y axis position for the cursor yPos holds the value 72. The type of cursor slot holds the representation of hand to define the graphical representation of the cursor and the visible slot holds true to indicate that the cursor is currently visible.

In order to maintain the correct versions for each of the accessing client computers shared object also includes a slot version for each of the data slots. The container version of shared object represents the latest version of any of the noted data slots. The versioning system implemented by distributed shared object system provides the ability for each of clients to have information updated in real time or at least as the latency of each connection to iMCS allows.

Client contains shared object . As client checks in with iMCS the current version of shared object is passed along to iMCS . IMCS compares the current version of shared object with the container version of iMCS to determine if shared object is up to date. Because the current version for shared object is the same as the container version for shared object iMCS determines that shared object is up to date and requires no updated information.

Client contains shared object . When client checks in with iMCS it shares the current version 9 of shared object . IMCS determines that shared object s version is lower than the container version of shared object and begins the updating process. Shared object contains slot versions for each of the data slots of the shared object. IMCS will check each slot version against the current version of shared object and will transmit only the slot data for the slots that are out of date on shared object . Because shared object has a current version of 9 iMCS will send the updated slot information for the type version 10 color version 14 xPos version 19 and yPos version 23 slots. The large discrepancy in versions may have been a result of a high latency in the connection between client and iMCS or may have resulted from some other issue such as if client had been logged off of the network for a period of time and had just regained connection. Regardless of the reasoning by comparing the current version of shared object with the container version of shared object shared object is brought up to date.

Similarly clients and contain shared objects and respectively. Shared object s version is 19 while shared object s version is 15. On analysis by iMCS shared object will receive the updated version of slot yPos and shared object will receive the updated versions of slots xPos and yPos. Therefore depending on how often clients communicate with iMCS each of shared objects are brought up to date. When each of shared objects are updated the current versions are then changed to reflect the container value of shared object . Therefore unless any of the data changes again the next check in period should not include any version updates. Neither DCOM CORBA nor cookies provide a mechanism for versioning the entire object.

In the example given above a remote education application is described in which the typical scenario is the teacher lecturing and using the multimedia tools while the students at the client computers passively watch. The present invention also supports the complete interaction between the accessing client computers. For example a multi player game may be implemented in which each user at a client computer may control some aspect of movement on the graphical multimedia display that will be viewable by the other accessing clients. Therefore each client computer may be dictating changes to the shared objects that will typically need to be updated to each player on the system.

One simple method for maintaining the current versions of the distributed shared objects that would also facilitate the fully interactive uses would be to exchange complete copies of the shared object at pre defined intervals. However because shared objects are not strictly limited in size nor are the client computers strictly limited in amount of interaction exchanging complete copies of the shared objects would undesirably tie up considerable bandwidth. The slot specific updating method in the versioning example of still maintains the most efficient means for maintaining the complete shared object experience among the multiple client computers. However because data slots may contain objects arrays or other non linear data types there is a difficulty in designating what slots to send for updates.

The data slots for color Ranch and control Std contain values that are also objects. These object values are shown at level . The color slot of level contains reference to an object named Ranch. For purposes of this example Ranch defines an object color scheme with three properties shown in level . The Ranch object includes values for bk yellow win green and ToolB Std . Bk yellow defines the color of the background of SharedWindow as yellow while win green defines the color of the window as green. The ToolB property references yet another object Std for providing the presentation of SharedWindow s toolbar. The properties of the Std object of ToolB are shown in level .

The control slot of level contains reference to an object named Std. For purposes of this example Std defines a window control scheme object with three properties shown in level . The Std control object includes values for ToolB Std size diag and close box . The control ToolB Std property references the same Std object that was referenced in the color ToolB Std property. Thus while the data slots of SharedWindow may reference objects as well as discrete data values they may also cross reference the same objects. The control ToolB object may only use the properties in the Std object of level that address file filed edit edit view view and pos top while the color ToolB object may only use the color gray property of the Std object of level .

In order to maintain control of the varying slot object values the present invention provides for monitoring each node within SharedWindow . If any node is changed the corresponding data slot of level is marked for change. For example if the tool bar color which according to the example shown in is controlled by the color gray data slot of the Std object of level is changed from gray to blue both the color Ranch and the control Std data slots of level are marked for change. The distributed shared object system recognizes when the data slots are marked for change and automatically serializes each of the trees of the two data slots for transmission to the iMCS.

Similarly if the background color is changed from yellow to white the color Ranch data slot of level is marked for change and serialized for transmission to the iMCS. By marking the data slots of level for change instead of the actual node that is changed the distributed shared object system is not only able to keep each instance of the shared object up to date but is also able to resolve any slot cross pollination that may occur when multiple slots reference the same object as illustrated in .

Slot cross pollination occurs when two slots reference the same object. Problems arise when the iMCS receives a reference to one of these cross pollinated slots. At that point it becomes imperative to determine the order in which to process the slots because which instance of the slot object gets processed first will have a direct impact on the other instance. Another problem arises when one of the cross pollinated slots is deleted. In that scenario one of the existing slots would point to or reference a non existent data item in a non existent slot. These issues require a great deal of complex code in the server to handle the inter related slots.

The versioning system and method described as a part of the present invention also effectively eliminates slot cross pollination thus eliminating the associated problems and diminishing the need for server and client complexity. Referencing the example illustrated in when the color Ranch and control Std data slots of level are marked for change the system separately serializes the data slot tree of color Ranch through levels and the data slot tree of control Std through levels . Therefore two completely separate serialized data streams will be sent to the iMCS. As other accessing clients are updated by the iMCS the other clients will receive separate objects instead of the cross pollinated reference. Thereafter if one of the other clients updates or amends either of the color Ranch and control Std data slots of level shared object instance will be updated with a completely separate data object that will remove the slot cross pollination. Because slot cross pollination is removed the server does not need to determine which slot to process first or what to do if a cross pollinated slot is deleted.

The versioning and updating procedures for the shared objects allow for sharing information and functionality at any desired periodic rate from a per server access to real time updates. However the teachings of the present invention also allow for securely storing the shared object within the local client. Instead of storing each shared object in a single well known area much like cookies are stored shared objects utilizes a simple algorithm for determining both the storage path and accessibility to the shared object. Certain embodiments of the present invention provide for a singular known file or path to start for storing the shared objects however the ultimate path to the shared object from this known starting position is governed by algorithm.

This filing system also controls the security regarding which multimedia files can access the data and logic stored in the shared object. Access to shared objects is domain sensitive. Therefore SharedCursor.sol at macromedia foo boo mySo.swf SharedCursor.sol can be accessed by the multimedia file at www.macromedia.com foo boo mySo.swf but not mySo.swf at C fool cool mySo.swf . SharedCursor.sol may not be accessed by mySo.swf because its domain does not match mySo.swf s domain. The domain sensitivity does however allow access by domains that are lower than the originating multimedia file. Thus both www.macromedia.com foo boo mvSo.swf and www.macromedia.com foo boo cool endoCal.swf would be able to share access to SharedCursor.sol because the domain level macromedia foo boo match.

In order to facilitate the sharing of local shared objects between more than one multimedia file. A local path string may be added to perform a head match against the URL path of the multimedia file. The matching portion of the path or URL is then used to create the location of the shared object. is a block diagram illustrating one embodiment of the present invention storing a local shared object with an added local path string at the direction of iMR . As client runs mySo.swf on iMR a call to create a shared object on memory is made using a local path string. In this instance foo boo is the local path string used. The resulting path for SharedCursor.sol would then be macromedia foo boo ShareCursor.sol which as noted uses the matched portion of local path string foo boo and path www.macromedia.com foo boo mySo.swf to create the lower domain levels of path . As implied above SharedCursor.sol could be accessed by any multimedia file that included the domain string macromedia foo boo . Therefore by strategic use of the local path string the local shared objects may be made more or less shareable by multimedia files run on iMR . Similarly if fool cool were used as the local path string for creating a shared object from mySo.swf the resulting shared object TabSo.sol would reside at localhost fool cool TabSo.sol . In the example using MACROMEDIA ACTIONSCRIPT the shared object is generated with the local path string using a command such as SharedObject.getLocal SharedCursor foo boo or SharedObject.getLocal TabSo fool cool .

The local path string also is an element to the security system of the described embodiment of the present invention. For example if mySo.swf were run on iMR with a local path string of foos cool iMR would not allow a shared object to be store on memory in slot because the path. C fool cool mySo.swf does not match foos cool . At this point iMR knows that mySo.swf is not allowed to write to client as far as the local path string foos cool is used.

One of the most powerful features of the various embodiments of the present invention is the ability to facilitate the remote shared objects. The locally stored instances of the remote shared objects are stored in a manner similar to the local shared objects but in certain representative embodiments of the present invention additional security features are included. is a block diagram illustrating one embodiment of the present invention for locally storing a remote shared object at the direction of iMR . Client may access iMCS using a connection over Internet . Storage of iMCS includes remote versions of SharedCursor.sor and TabSo.sor . The storing of shared objects onto local memory of client works in a similar manner to the local shared objects. The multimedia file run on iMR allows for or directs iMR to store the shared object.

The embodiment described in provides for the local instance of the remote shared object to be created by passing optional parameters for an application and local instance name and a persistence option which may comprise the local path string described with regard to . In operation iMR runs mySo.swf over Internet . MySo.swf may use data and logic from SharedCursor.sor thus prompting iMR to generate a local instance of remote shared object SharedCursor.sor . The instance of SharedCursor.sor is generated using application instance parameter App1 myInst and persistence option parameter foo boo . Pursuant to the algorithm for storing the shared objects the local instance SharedCursor.sor is then stored at macromedia foo boo App1 myInst SharedCursor.sor . Similarly mySo.swf running on iMR may use data and logic from TabSo.sor which along with application instance name parameter App2 myInst and persistence option stores the shared object TabSo.sor at localhost App2 myInst TabSo.sor . In the example using MACROMEDIA ACTIONSCRIPT the local instance of the remote shared object may be generated using a command such as SharedObject.getRemote SharedCursor App1 myInst foo boo or SharedObject.getRemote TabSo App2 myInst .

The accessibility of SharedCursor.sor and TabSo.sor are controlled in a similar manner as previously described in which access is granted or denied on matching domain levels. However in addition to the domain matching influenced by the path or URL of the multimedia document the remote shared object security is also influenced by the particular application that is running. For example if mySo.swf were running on iMR and directed creation of a local instance of SharedCursor.sor using application instance name App3 myInst and persistence option foo boo SharedCursor.sor would be created at macromedia foo boo App3 myInst SharedCusor.sor . Therefore if SharedCursor.sor were still stored on local memory the running instance of mySo.swf using the application App3 would not be able to access SharedCursor.sor because it had been generated using application App1.

The functionality of the local and remote shared object is accessible to a user through an API. The storage mechanism operates in the background of the API commands. In the remote shared objects the versioning mechanics described above also operate in the background of the API commands to update the information on the remote server in order to maintain consistency in the transactions and data. Therefore the user does not need to understand the complexities of client server programming. Moreover serialization is also completed in the background of the API commands which relieves the user from writing serialization code for each communication of information between the iMR client and the iMCS server.

One example of an iMR client is MACROMEDIA s FLASH player. An example of an iMCS is MACROMEDIA s FLASH COMMUNICATION SERVER . An example API that presents the functionality of the local and remote shared objects is MACROMEDIA s ACTIONSCRIPT . ACTIONSCRIPT allows the unsophisticated Web designer to incorporate the complex versioning storing and communication features of shared objects into program designs by leveraging the abstract data types of ACTIONSCRIPT and its corresponding methods. As referenced above after establishing the local instance of a shared object either through the ACTIONSCRIPT command SharedObject.getLocal name or SharedObject.getRemote name uri . Local updates to the shared object may be automatically detected and sent to the remote instance with a command such as SharedObject.on Sync which synchronizes the two shared object instances. Furthermore if the SharedObject.on Sync command returns a confirmation of the data change the system may be set to automatically send changes to the iMCS on periodic basis using a command such as SharedObject.setFps which sets a frame rate per second to send changes to the remote shared object instance. The user does not have to manage the client server connection nor does the user have to write serialization code or the like. The complexities of the disclosed embodiments of the shared objects are hidden behind the abstraction of the API.

When implemented in software the elements of the present invention are essentially the code segments to perform the necessary tasks. The program or code segments can be stored in a computer readable storage medium. The computer readable storage medium may include any medium that can store information. Examples of the computer readable storage medium include an electronic circuit a semiconductor memory device a ROM a flash memory an erasable ROM EROM a floppy diskette a compact disk CD ROM a hard disk etc. The code segments may be downloaded via computer networks such as the Internet Intranet and the like.

Bus is also coupled to input output I O controller card communications adapter card user interface card and display card . The I O adapter card connects to storage devices such as one or more of a hard drive a CD drive a floppy disk drive a tape drive to the computer system. The I O adapter would also allow the system to print paper copies of information such as documents photographs articles etc. Such output may be produced by a printer e.g. dot matrix laser and the like a fax machine a copy machine or the like. Communications card is adapted to couple the computer system to a network which may be one or more of a telephone network a local LAN and or a wide area WAN network an Ethernet network and or the Internet network. User interface card couples user input devices such as keyboard pointing device to the computer system . The display card is driven by CPU to control the display on display device .

In some instances the data slots on any given instance of the shared object may periodically contact the main version to check for updates. In these cases the version identifier is compared with a container version of the main instance in step . In step the version identifier is compared with each of a plurality of main slot version identifiers when the container version is more recent than the version identifier. In step each main data slot corresponding to each of the plurality of main slot version identifiers that is more recent than the version identifier is serialized for transmission. Each of the serialized main data slots is then transmitted to the computer for updating corresponding the one or more data slots in step . The version identifier is revised in step to the container version responsive to the updating. With either path that update the versions or changes to the object access to the local instance is provided to the iMF for processing during operation of the iMF in step .

Although the present invention and its advantages have been described in detail it should be understood that various changes substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims. Moreover the scope of the present application is not intended to be limited to the particular embodiments of the process machine manufacture composition of matter means methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure of the present invention processes machines manufacture compositions of matter means methods or steps presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized according to the present invention. Accordingly the appended claims are intended to include within their scope such processes machines manufacture compositions of matter means methods or steps.

