---

title: Method and system for online image security
abstract: An online application enables an end user to navigate to a web site, upload digital images, and to combine those images with words in a stylized template to create a user-generated story. A story is a web page, typically a collection of photos and words that are brought together by a stylized template that can be customized by the end user. Preferably, a given story is available from the site at a given location (at a URL) that may be private or public. A given story may be shared with other end users, published to other web sites or web logs, or maintained solely for one's own use. The invention also provides for multiple end users to collaborate to create a “shared” story.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261335&OS=08261335&RS=08261335
owner: Hewlett-Packard Company
number: 08261335
owner_city: Palo Alto
owner_country: US
publication_date: 20070223
---
The present invention relates generally to a web based application for putting together photos and words with styled templates that can be customized by an author for the purpose of telling a story.

Online sharing of digital photos is well known in the prior art. In particular commercial web sites such as Ofoto Shutterfly Flickr and many others offer end users the ability to upload and store digital photos and to secure those photos e.g. using standard logon and or password schemes. It is also well known in the art to provide hosted services such as Six Apart that enable end users to publish their own web logs blogs . Social networking sites such as Friendster MySpace Facebook and others combine photo sharing and blogging by providing tools and hosted services that enable end users to upload and store their digital photos and to publish blogs in association with those photos. While current approaches provide some advantages the prior art has not recognized that digital photos are often episodic in nature and as such they are best shared in the context of a story. The prior art does not provide adequate tools or services to enable end users to upload and composite their photos with text in a storybook or scrapbook manner. In addition prior solutions do not afford multiple end users each of whom may have captured some relevant aspect of a shared experience to share their photos on a collaborative canvas.

There remains a need in the art to provide an easy to use secure scalable and highly available online application that enables end users to publish their photos and words in custom stories that can be accessed shared and re published.

The present invention provides an online application that enables an end user to navigate to a web site upload digital images and to combine those images with words in a stylized template to create a user generated story. In one embodiment a story is a web page typically a collection of photos and words that are brought together by a stylized template that can be customized by the end user. Preferably a given end user generated story is available from the site at a given location at a URL that may be private or public. Thus a given story may be shared with other end users published to other web sites or blogs or maintained solely for one s own use. The invention also provides for multiple end users to collaborate to create a shared story.

In one embodiment the application is made available from a web site on the publicly routable Internet. An end user operating a client machine navigates to the site via a web browser. Using an upload tool e.g. a browser plug in the user uploads digital photos to the site. To design the story the end user then selects one of a set of style templates. In response a server side layout algorithm takes an unstructured set of photos identified by the end user and the selected template and provides an initial layout for the story. This initial layout is exported to the web browser and displayed as a web page. Using one or more of a set of client side editing tools the end user then creates a custom design comprising the photos and any text blocks that are added to the page. Thus for example using a drag and swap tool the user may alter the positions of any photos and text blocks in the layout. As this tool is used i.e. as a given client side user interface gesture occurs a server side reflow algorithm dynamically changes the order and placement of the photos and text in the layout. In addition the editing tools enable the end user to select and edit a given photo e.g. resizing rotating or adding a given visual effect or to add new photos and text blocks as desired. When the end user is satisfied with the layout and content of the story he or she may then select a publishing option. In this manner the end user may take a given action namely publish the story to a community other given users of the site limit access to the page via privacy settings announce the story via email invite others to collaborate on the story or publish the story to a blog or other site. The site may also include online tools to facilitate manufacture of one or more products e.g. posters books e cards cards and any other items on which the story or portions thereof may be incorporated.

A dynamic client side interface affords end users with significant creative control over how their photos are displayed and integrated with text to create their customized visual stories. Using the initial layout algorithm the system takes an arbitrary set of photos and text blocks together with a user selected layout and optionally a theme and generates an initial layout page that preserves the user s storyline. As the end user modifies edits the story the reflow algorithm dynamically changes the display in from the user s perspective real time. In so doing however preferably the client side only exchanges small amounts of data with the server side so that the entire page does not have to be reloaded each time the end user performs a given UI gesture during the editing process.

According to another feature of the invention the online application is scalable to large numbers of end users using a server side infrastructure that includes an image transformation application engine loosely coupled to a back end filesystem and an associated database. The filesystem preferably just handles files and security settings are enforced to ensure that images do not get served directly from the filesystem itself.

According to a feature of the present invention when a story is written to HTML i.e. as the web page exported to the client browser preferably each photo of the story is associated with an image tag and the SRC attribute of that tag preferably has a given URL of the form http x fetch . PARAMLIST. This URL points to a server side image transformation application and it also includes i an image hash that is a unique identifier for the photo and ii a list of parameters that describe one or more image transformations. Thus a portion of the URL itself functions as an application programming interface API to the image transformation engine. As will be seen by incorporating image transformations within the URL itself and by separating the transformation engine from the database storage via a filesystem the system can perform image manipulations directly at the entry to or exit from the site i.e. as photos are received in or served from the site . This feature obviates storage of multiple versions of a given photo which significant reduces storage cost.

The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.

As noted above in a typical use scenario an end user operating a client machine navigates to the site s home page via a web browser. Upon selecting an Upload display tab from a navigation bar an upload page is displayed. is representative. The name tabblo is a service mark of Tabblo Inc. Preferably the page affords the end user a number of tools for use in uploading photos. These include for example a local file search and upload tool as well as navigation bar from which the end user can select for download one or more other upload tools such as a Java uploader a Flash uploader an ActiveX uploader or plug ins to enable integration with other photo sharing tools or sites e.g. Picaso and Flickr . The page also preferably includes a display panel through which the end user sets an upload privacy e.g. public a circle of authorized viewers or private. The panel preferably also includes an input form by which the user can identify one or more upload tags for the story the system uses these tags to identify the story to one or more search processes.

Once the images are uploaded to the system the end user begins the process of creating a visual storyboard by navigating to a Make display tab and selecting a link to create a new story. As a result a Make page is displayed as illustrated in . As can be seen page includes a first choose photo shape and layout section and a second choose theme section . Within the first section the user can select one of a set of square layout options such as shown in alternatively he or she can select one of a set of rectangle layout options. illustrates a portion of the display of after the user selects a rectangle based layout option. Referring back to a desired display theme e.g. background colors and the like is selected from the choose theme section . Upon selecting the desired layout and theme the user selects the Continue button . In response the system preferably displays an add photos page such as illustrated in . The page preferably includes a first section in which the user s uploaded photos are positioned. The end user then selects which of the photos are to be included in a given story e.g. by dragging and dropping the selected photos from the first section to a second section which is a holding area. After the photos are selected for the holding area the user selects the Continue button to continue the process of creating the story.

As will be described in more detail below upon selecting the Continue button on page a server side process executes an initial layout algorithm which takes the unstructured set of photos identified by the end user from the page and the selected square or rectangle based template and theme from the Make page and in response provides an initial layout for the story. A resulting initial layout for the story under development in this example is shown in the edit page of . As seen in the edit page preferably includes a layout control which provides the user with varying degrees of control over a layout mode. Depending on the mode selected the system provides the user with a very hands on experience a highly automated experience or somewhere in between. illustrates a representative layout control . By selecting one or more operations from the layout control menu various operating modes are entered as now described. As will be described in more detail below these operating modes are enabled via a server side reflow algorithm. The reflow algorithm also takes advantage of the AJAX enabled client shim so that as a result the story page generation is made to feel more responsive to the end user. As previously noted the use of an AJAX enable client enables the client side to exchange small amounts of data with the server side running the reflow algorithm so that the entire page does not have to be reloaded each time the end user performs a given UI gesture during the layout process.

In particular and with reference to in a compact mode after every change made by the user the system preferably rearranges the photos and text to fix any overlapping items and to remove any empty blocks of space. In general this is accomplished by shuffling items in a right and left fashion. In this operation the swap function described below is also enabled. In an automatic mode after every change made by the user the system preferably rearranges the photos and text so that no items overlap but also keeps any empty blocks of space. This is accomplished by pushing items lower down the page as will be described. Once again in this operation the Swap function is enabled. The swap function is a mostly manual mode. In particular when the user moves a photo or a text block on top of another item in the story preferably the two items will trade places or swap. Other than this switch the system preferably does not make any other changes to the user s layout. In a manual mode the user has full control i.e. the system does not make any automatic changes as the user moves his or her items around the layout . This mode can be useful for putting a text block on top of an image or the like. illustrates a set of custom settings that may be selected from the layout control when the user has selected the manual mode. In particular these controls include checkboxes to enable swapping to remove empty spaces and to fix overlaps or move items either horizontally or vertically as selected by the radio buttons . Referring back to a snap grid control provides either a coarse grid as shown in or a fine grid with the images in close proximity.

When the end user is satisfied with the layout and content of the story he or she then selects a publishing option. Preferably this is achieved by having the user navigate to a Share page such as illustrated in . From this page the user can select a story and a publication option such as without limitation inviting others via email to view the story purchasing products e.g. posters prints books and the like obtaining HTML to publish the story to a web log sending the story image to a third party site selecting who can view the story selecting groups that may view the story and selecting others who the user authorizes to create variations of the story e.g. in a collaboration. With respect to collaboration preferably the site provides several different types of options. In particular in one embodiment the site implements a multi source single author collaboration model. For example in this model and based on access controls explicitly granted or implicitly granted by being in someone s circle social network user A can include content that has been uploaded by user B in user A s own work. Additionally should user B decide that user A should no longer have access to the content user A has borrowed from user B with one simple access control change user B can suppress the content from all of the products online or otherwise that user A has used the content. Additionally this model supports a variations feature that allows user A to make a completed product online book poster or the like available for variation access to any number of selected users a feature that effectively allows these users to begin creating content not from scratch but rather from user A s finished product i.e. a given story or some portion thereof . This variations feature effectively allows a first end user to start from where another end user leaves off. In another embodiment the site implements a multi source multi author collaborative model. In this latter model and once again based on access controls multiple users can contribute content and also concurrently edit the same story product. This is achieved by having one user user A take ownership of the story and then open up specific editable areas that will each carry with them edit access control for one or more specifically designated users. Thus for example this collaboration model is used for allowing users A B and C to edit specific page ranges in a school yearbook.

The story generation process as described above should not be taken as limiting. There is no requirement that the end user go through a set of predefined display screens to create a story. In an alternative embodiment the user simply navigates his or her browser to a given page and then he or she uploads imports and or otherwise selects photos preferably in a user defined sequence or order . The system may then take the photos select a given layout from a set of one or more system layouts and generates the initial layout automatically i.e. without the user selecting a given layout a theme or both . In other words the layout selection may be performed automatically by the system and not necessarily in response to an end user action. Indeed no particular sequence of events upload product selection layout selection theme selection and the like is required or dictated by the system in general or the user interface in particular. Any particular sequence can be practiced.

The client shim provides the end user with a set of one or more client side editing tools. These edit tools include for example pan and zoom to enable scaling and re centering apply effects to enable rotation black and white sepia conversion negative and the like expand and collapse and the like. A given tool is selected by the end user right clicking on the image which action preferably opens an editing tool bar in association with the photo. Icons in the tool bar are then selected for the one or more functions. When the end user performs a given edit the client side shim communicates with the server back end and in particular with an image transformation engine as will be described . The actual image transformation s are carried out on the server side but as will be seen the system itself only needs to persistently store the image itself. In other words it is not required to store the multiple versions of the image that are created by applying the one or more image transformations.

The above has provided a description of the system from the end user s perspective during the process of creating and publishing an online story. The following section provides additional details regarding how the system provides the layout and rendering functions. As used herein a story is composed of a number of elements positioned on a grid. A grid is an underlying coordinate system on which all elements comprising the story are placed. As illustrated in in some grids the grid units are squares. As illustrated in in other grids the grid units are rectangular. If desired combinations of square and rectangular grid units may be utilized. A given template may have a number of different grids of different coarseness but preferably the initial layout of a template is done on a coarse grid. Grids preferably are laid out by analogy to a city block and street model in particular grid units are separated from each other by streets. As will be seen a given story element can cover a single grid unit or it can cover multiple units in each direction. If a story element covers more than one unit then it may also cover the streets between grid units. Preferably an element only covers a street if it also covers the units on either side of the street. Dimensions of grids are specified within the system in pixels. When stories are rendered onto a display screen the pixels are literally the screen pixels. In other renderings for example to PDF format for printing a virtual pixel coordinate system is used. In some grids the street width is zero which means that the grid units abut directly. In these grids a fake margin width can be defined so that elements do not abut each other. As will be described below the initial layout and reflow algorithms preferably use the fake margin to achieve the effect of the streets elements have a consistent amount of space separating them while allowing more flexibility in the placement of elements. Grids have a grid width which is defined as a maximum number of columns. This width dimension enables online stories to fit within a reasonable screen width while still being able to grow vertically to accommodate as many photos as the user desires. In its full generality a grid is defined by a number of attributes i a block size represented by a height and width in pixels of a single grid unit ii an in margin which represents a width of the streets in pixels iii a fake margin which represents a number of grid units to reserve between automatically placed elements and iv a grid width measured in grid units. If the in margin is zero then the fake margin is non zero and vice versa. In desired the in margin may be different for vertical streets as opposed to horizontal streets.

Although not meant to be limiting preferably a rectangular grid unit in the system is sized so as to provide a 1 2 aspect ratio the ratio of width to height when a given photo is displayed in a layout that includes rectangular grid units. This aspect ratio ensures that the system provides consistent display of photos regardless of their orientation portrait or landscape .

A story element is one of a number of types of content. For online stories typically a story element is a photo or a text box but this is not a limitation of the system. An element may also be an external piece of content such as a Google map an interactive component e.g. a list of persons within a circle a graphic and so on. Elements are placed on a grid by specifying their x and y position i.e. posx and posy and size width and height the latter preferably in whole integer grid units. The values posx and posy preferably are the column number and row number of an upper left grid unit covered by the element both starting with zero. Preferably within the system elements also have a sequential ordering order that is used externally for displaying a slideshow of the photos in a story and internally for the reflow algorithm as described below. illustrates a representative online story that has been generated according to the steps previously described by an end user uploading photos and then organizing the photos within a selected template and theme. As can be seen this particular story has five elements all photos labeled with their order from 0 4 . In this example the grid as drawn in has six columns with 90 pixel grid units separated by 30 pixel streets . The first photo order is at position 0 0 and has size in grid units of 2 2 . The second photo order is at position 2 0 and has size 1 1 . The third photo order is at position 3 0 and has size 3 2 . The fourth photo order is at position 2 1 and has size 1 2 . Finally the fifth photo order is at position 3 2 and has size 2 1 . The order is determined by the reading order of the upper left corner of the photo which is why photo comes after photo .

Preferably the system uses one or more grid designs to specify all or substantially all aspects of the appearance of a story from colors and type specifications to the grids and initial positions of story items. A grid design typically is constructed by combining the templates and customizations specified by a story which include a layout template a theme template story customizations and any page customizations. In addition the actual appearance of an element can be changed by information within the element. For example the type face used for a text block can be set in a template in a story wide customization in a per page customization or in the text block itself. Templates are named grid designs presented to the user as layout and theme choices. In particular in the user interface as shown in templates are divided into layouts and themes internally however preferably any of the settings can be stored in any template. In a representative embodiment a given story is associated with two 2 template identifiers one for the selected layout and one for the selected theme. Of course default layouts and or themes may be used.

With the above as background the following provides additional details of how the initial layout and reflow algorithms work in one embodiment.

Generally the initial layout algorithm takes an arbitrary set of elements e.g. photos text blocks or some combination a template and a theme and it produces an initial layout for the story. The initial layout algorithm preferably is also used when re laying out a story e.g. when the user changes styles and or chooses a new layout. Preferably there are two 2 basic approaches of the initial layout algorithm simple layout and component based layout. The simple layout approach is most useful when the end user has selected a template with square elements. In the simple layout a template specifies a list of one or more molds each of which is used to position a photo. In particular preferably a mold specifies a position and a size both expressed in grid units and a type typically either photo or text block. Thus a given mold may be a photo mold or a text block mold. It may be desirable to provide a combination mold . A mold list preferably comprises for a given layout a fixed initial part and then a repeating part which is repeated as needed to fill the mold. The initial part of a given mold may be empty e.g. for layouts that use a simple repeating pattern. To lay out an online story using a simple layout preferably the one or more molds each of which has an associated mold list and photo list and text blocks if any are paired together. In particular as noted each photo mold specifies the position and size of a next photo in the photo list. When a text type mold is encountered if there is a list of text blocks to layout a next text block is placed. If there is not a list of text blocks an empty text block which may include double click here to enter text may be placed in the layout. The process continues until the list of photos and text blocks is exhausted. In this manner an online story can grow as long as it needs to use all the photos and text. Physical products such as a poster may have a fixed length in which case the process ends when the bottom or an end of the poster or other item is reached in which case all unused photos and text blocks are placed back in a holding area.

Because a simple layout specifies the precise size and position of photos or text blocks it is not efficient for laying out rectangular elements where orientation such as with respect to photos portrait or landscape has to be honored. In a component layout preferably the template specifies the positioning of photos with a two tier arrangement. In particular preferably the template specifies a series of blocks each of which is filled with a mini layout called a component. Typically a block is collection of grid units. The choice of component is determined by the block and by the orientations of the photos to be placed. In this way the order and orientation of the photos is preserved and the designer of the template can exert some control over the layout. A component is a list of molds just as described above with respect to the simple layout templates. Preferably components are grouped together internally i.e. within the system into named sets for example photext photos photos according to a designer s wishes. illustrates representative groupings. The square outlines shown in are merely for illustration purposes and are not part of the grouping. Thus one named set e.g. photos comprises short layouts 1 grid unit high tightly packed with photos while another named set photos comprises 2 grid unit high layouts also tightly packed with photos. Yet another representative set e.g. photext comprises 2 grid unit high layouts with tightly placed photos and text. Another named set e.g. photext although not shown comprises 1 grid unit high layouts with and loosely packed photos and text. A phosparse named set comprises a loosely packed set of photos each of which are 1 grid unit high while a phosparse named set comprises a loosely packed set of photos that are each 2 grid units high and so on. The system may include as many different components and sets of components as desired. The naming conventions of course are not meant to be limiting. Typically the components within each set differ as to how many photos and what orientations of photos they layout. A component based template specifies a list of blocks. As in simple layouts preferably the list of blocks has an initial part used once at the start of the story and then a repeating part which is used over and over to provide a layout as long as is needed. Moreover preferably each block also specifies a number of photos to use in the block and a component set to choose a component from. For example a block list might be defined as follows 

To layout the story the blocks in the block list are considered in turn by the initial layout algorithm. In particular the photo count from the block is used to examine the next photos from the photo list. Using this example above the first block specifies six photos so the algorithm looks at the first six photos in the photo list and collects their orientations. The orientations are used to choose a component. Thus assume that the six photos as selected by the end user are all portrait orientation except for one so the orientations may be notated as PLPPPP. The block specifies a component set in this example photext . To find the component to use the initial layout algorithm takes a name of the component set e.g. photext and the orientations of the photos in this case PLPPPP and determines if there is a component in the component set which lays out six photos in the desired orientations. If there is not a component like that the algorithm preferably omits a photo e.g. the last one and tries again in this case looking for a photext component that lays out five photos PLPPP. This process of reducing the list of photos and examining the component set for a matching component continues until a match is found. Each time the list of photos is reduced by one the dropped photo is returned to the photo list so that it will be used as part of a next block.

A component set may have more than one component for the same orientations. In this case preferably one of the matches is chosen at random although a deterministic scheme may be used as well. Preferably the system designer provides sufficient components e.g. by always specifying at least a portrait component and a landscape component so as to ensure that a match is always found. Once a matching component is found it is used to layout the photos and text just as in the simple layout. In particular the positions specified in the component are interpreted relative to the position of the block. After positioning the photos in a block the process repeats beginning with the next photos in the photo list. As with simple layout an online story can be arbitrarily long with the laying out continuing until the list of photos and text are exhausted. As noted above some products such as a poster or a book have a fixed length in which case preferably the process stops when the product is full and the remaining photos and text are put back into the holding area.

The reflow algorithm preferably is used when the user changes the positions or sizes of elements in a story. This algorithm which executes on the server side but takes advantage of AJAX enabled client side technologies is used to enforce one or more rules about the layout. These rules include for example that the layout should not include extra space that elements should not overlap and the like. In general the reflow algorithm operates as follows based on certain settings elements within the story are moved to satisfy a rule and in particular by adjusting the position of one or more elements that are later in the element order i.e. that have a higher ordinal position . As will be seen this effect may cascade in the sense that once an element is moved that movement may cause adjustments to elements later in the element order to guarantee that all the desired rules are satisfied. As used herein the reflow algorithm works in conjunction with the following attributes collision and whitespace. A collision occurs when two elements both overlap the same grid unit. A grid unit is considered to be whitespace if no element overlaps that grid unit. The reflow algorithm preferably works in different ways based on the user s choice of layout mode. In particular preferably these options change both which rules are enforced and the strategies used to enforce them. Thus for example collisions are fixed by reflowing elements to the right Reflow Collisions by pushing elements down Push Collisions or by ignoring them entirely Ignore Collisions . Whitespace can be collapsed Collapse Whitespace or it can be left in place Leave Whitespace . As illustrated in the user interface presents one or more of these options to the user each of which then determines choices of strategy Compact Collapse Whitespace Reflow Collisions Automatic Leave Whitespace Push Collisions Swap Leave Whitespace Ignore Collisions Manual Leave Whitespace Ignore Collisions Custom settings allows the user to choose the strategies explicitly. It is not required that all combinations of these strategies be implemented of course. Thus for example it may not be required for the algorithm to handle the situation where both Collapse Whitespace and Push Collision are chosen. One of ordinary skill in the art will also appreciate that when Leave Whitespace and Ignore Collisions are chosen then no reflowing is needed.

In one representative embodiment there are four 4 basic operations 1 Collapse Whitespace Ignore Collisions ii Collapse Whitespace Reflow Collisions iii Leave Whitespace Reflow Collisions iv Leave Whitespace Push Collisions. The reflow algorithm preferably uses a set of functions. The functions include an AVOID COLUMN OVERFLOW function an AVOID COLLISION REFLOW function and an AVOID COLLISION DOWN. The AVOID COLUMN OVERFLOW function checks if an element is so far to the right that it is not fully contained within the grid width and if so the element is moved to the beginning of the next row in the grid 

In one embodiment the reflow algorithm works as follows below. Preferably the algorithm is implemented in software as a set of processor executable instructions. The algorithm removes all elements from the story i.e. from a current web page representation while remembering their original position. Then the algorithm considers each element in turn and places the elements back onto the grid using the user selected or system selected chosen strategies to fix violations of the rules as it goes 

As noted above preferably the above algorithm executes on the server side. Nevertheless because the client preferably is AJAX enabled only small amounts of data need to be transmitted between the client and server as a result of a given UI gesture moving a photo from a first position to a second position inserting a textbox or the like on the client side. In response the server returns a JSON data structure detailing for each element in the story what its new position is. Then the client can simply move the elements to their new positions using conventional AJAX enabled functions . Thus in effect the reflow algorithm redraws the layout as a new web page on the fly using the algorithm described above. From the end user s perspective the resulting layout appears to be edited in real time as photos and text blocks are seamlessly moved about the layout to facilitate the storyboarding process.

While the reflow algorithm has been described in one embodiment one of ordinary skill will appreciate that one or more variants to the algorithm may be practiced. Thus for example the algorithm could be modified so that it is executed in a forward or reverse direction from some particular location in the page.

The initial layout and reflow algorithms described above also are implemented in the application server layer.

According to a feature of the present invention when a story is written to HTML i.e. as the web page exported to the client browser preferably each photo of the story is associated with an image tag and the SRC attribute of that tag preferably has a given URL. In particular the URL is of the form 

As can be seen and with reference to the URL points to the image transformation application in particular the IMFE process and it also includes i an image hash that is a unique identifier for the photo and ii a list of parameters that describe one or more image transformations. Thus a portion of the URL itself functions as an application programming interface API to the image transformation engine. As will be seen by incorporating image transformations within the URL itself and by separating the transformation engine from the database storage via the filesystem the system can perform image manipulations directly at the entry to or exit from the site i.e. as photos are received in or served from the site . As noted above this feature obviates storage of multiple versions of a given photo which significant reduces storage cost.

Although not required preferably the image hash is used as a content addressable storage CAS identifier so that the location of the image in the database is a function of the hash. Any other convenient indexing scheme may be used instead.

As noted above the client side image transformations are varied and include without limitation one or more of the following scaling sizing cropping zoom rotation sharpening effects and others. A transformation typically is effected by an end user taking a given user interface action on the client side e.g. clicking on a photo selecting an editing tool and performing an edit . The following is a representative list of some URL API parameters and their associated image transformation 

For HTTP GET calls the API returns an image and a cookie. For transformation calls the API returns an image transformed as requested and if cookiestate on a cookie called fileid whose value is . Future requests to the transform API send this value if subsequent operations are to be based on a last operation done rather than on the original file.

The filesystem is distinct from the transformation application engine and preferably just handles files. View item security is implemented in the application layer to ensure that images with security settings do not get served directly out of the filesystem. This resource locking is accomplished as follows and with reference to the URL format described above. First direct fetching from the filesystem is disabled by requiring that the x fetch method use a secret user agent header that does not circulate outside of the infrastructure. Second with respect to the image retrieval URLs preferably every request to x fetch requires two 2 parameters timestamp and token. If either parameter is missing the IMFE process declines the request. The timestamp is the seconds since the epoch and it is considered to be valid for only a given time period e.g. one 1 hour. Thus e.g. if the timestamp describes a time that the IMFE considers longer than an hour in the past IMFE declines the request. The token preferably is an MD5 hash that ensures the timestamp was not tampered with. In a representative embodiment the md5 hash is defined as 

If the token parameter does not match this calculation preferably the IMFE declines the request as previously noted.

In addition to the above the security API preferably allows permalinks to be created as endpoints. Thus for example the end user may create an endpoint called user image. Now suppose the user desires a link to a public picture called 0aaabbbaaa5555123.jpg which for example is a picture of a dog. The picture is referred to as dog in the permalink and the association is stored. The user is then provided with the following representative link . . . studio user image dog.jpg. The link would then provide the following when hit 

The filesystem is implemented in a distributed manner e.g. across a set of Intel processor or equivalent based Linux or equivalent based server machines that are connected in a local area network or in any other convenient manner. The filesystem front end processes and the back end processes shown in run on these machines. illustrates an embodiment of the filesystem in more detail. The filesystem comprises a storage synchronization daemon one or more of the front end FE modules running as Apache modules one or more of the back end BE modules running as Apache modules and a file replication daemon . The synchronization daemon preferably executes in both FE and BE machines and the file replication daemon typically runs on the BE machines. Although the drawing illustrates separate FE and BE machines this is not a requirement as FE and BE modules may execute on the same machine. As also seen in preferably each FE and BE machine supports a shared memory segment that is maintained by the daemon and the FE module . The daemon wakes up and then checks a set of hosts that are configured into the filesystem to determine their status.

The FE module provides the basic connectivity to the BE modules and handles file read and write operations for the filesystem. A startup sequence for the FE module begins by reading and storing configuration options and then determining which back end hosts are reachable.

A startup sequence for a back end BE module begins by reading configuration options. The module then uses the internal API to announce itself by IP address to an identified primary and secondary FE.

The file replication daemon runs on back end machines and operates to ensure that every file in the Real File DB has copies. It also ensures that if a disk goes down a process of re replicating the lost files begins.

Although the present invention has been described primarily in the context of creating and publishing online stories this is not a limitation of the invention. A given story may be published to a product such as a book a postcard a single page poster a multi page poster and other items. In such case preferably the site includes one or more additional display screens by which the story is adapted for a particular product based format. Thus for example if the end user desires that the story be published in the form of a gift book or the like the interface may include additional display screens e.g. to enable the end user to design individual pages to interact with a third party publishing system and the like. Of course although not described in detail one of ordinary skill in the art will appreciate that the inventive system may interact with one or more e commerce payment manufacture promotion and distribution systems as required. One of more of such components may be performed natively or through web based or other interaction with third party systems.

While the above describes a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In one preferred embodiment the initial layout and reflow algorithms are implemented in software executing in one or more server machines. The invention or portions thereof may take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. A computer usable or computer readable medium can be any device or apparatus that can include store or communicate the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical or the like. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

As noted above preferably the client side interface is dynamic and affords end users with significant creative control over how their photos are displayed and integrated with text to create their customized visual stories. Although not required the interface is conveniently enabled using AJAX Asynchronous Javascript and XML which are a known set of web development techniques that enhance the web page s interactivity speed and usability. AJAX technologies include XHTML Extensible HTML and CSS Cascading Style Sheets for marking up and styling information the use of DOM Document Object Model accessed with client side scripting languages the use of an XMLHttpRequest object an API used by a scripting language to transfer XML and other text data asynchronously to and from a server using HTTP and use of XML or JSON Javascript Object Notation a lightweight data interchange format as a format to transfer data between the server and the client.

While given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

