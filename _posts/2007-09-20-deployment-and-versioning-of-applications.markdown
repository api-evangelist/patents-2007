---

title: Deployment and versioning of applications
abstract: A method and system to deploy a software archive on a runtime environment. The method extracts metadata from the archive and verifies the components can be deployed and further deploys them on the runtime environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08296758&OS=08296758&RS=08296758
owner: SAP AG
number: 08296758
owner_city: Walldorf
owner_country: DE
publication_date: 20070920
---
This application claims the priority of U.S. Provisional Patent Application Ser. No. 60 846 155 filed Sep. 20 2006.

The invention relates generally to software environments and more specifically to deploying software components.

Software environments require that software components such as business applications upgrades configurations and so on must be deployed before they are run on an environment. When an application is deployed on a system it is referred to as a deployed component. Deployed components include one or more modules that contain source code and application resources. The smallest deployable unit of an application is an application module. Application modules are packed for distribution into application archives. If a modification is made to any part of a module the whole module must be redeployed. The latter single module approach is suitable for application development and testing. In a large software environment modifications to a system cannot be applied module by module because of time and resource constraints. For example once a module is applied to a system the system cannot provide any information about current version and compatibility state of an affected application. This in turn makes the analysis of runtime problems due to incompatibility issues substantially more difficult.

In another aspect application modules often use interfaces or parts of other modules or libraries. To run properly such modules need all dependent parts to be deployed and active. These dependencies have to be declared by the application and processed by the deployment services. Application modules also depend on the runtime environment because they use its services and communication interfaces. This results in the platform release dependence. Such dependencies must also be declared by the application and processed by the deployment service.

In the context of Java applications the application resources of a Java application are packaged into one Software Component Archive hereinafter SCA . An SCA contains two types of deployable objects. These are module and configuration archives. Module archives contain the java code of the application and all runtime resources. The configuration archives contain data for configuration management. Modules and configurations are both application resources. However configurations have specifics that require separate treatment. Modules and configurations are packed in Java archive files hereinafter JAR in the software component level of the SCA and specify deployment descriptors as main attributes in a corresponding MANIFEST.MF file in the JAR. The MANIFEST.MF file is a file that contains metadata for the SCA.

A method and system to deploy software components on a runtime environment is described. The method extracts metadata to a memory that is independent of a file system and verifies if the components can be deployed based on the metadata. The method further deploys the components after the verification is complete.

Software environments such as application servers are initially installed and configured with a set of components. For the components to run on an environment they must be deployed on a system. Deployment involves obtaining components checking if they can be deployed on the environment and if the checks are satisfied physically uploading the components to the runtime environment. To start a deployment process an embodiment of the invention receives input with deployment parameters via a user interface. The deployment parameters contain a path to a software archive containing components for deployment and configuration parameters pertaining to the deployment process.

As shown in a software archive contains modules and configurations . Modules are application source code. As such a module contains compiled code and deployment descriptors . Configurations contain configuration information in the form of logical configurations deployment descriptors and mapping data .

Referring to the deploy processor receives a software archive through the user interface UI . The deploy processor sends the archive to the archive processor . Referring to the archive processor opens the software archive and traverses it . During the traversing the archive processor extracts all metadata from the archive and stores it to memory . In one embodiment the memory is main memory and is independent of a file system. By extracting to a memory and extracting only metadata a number of important benefits are achieved. For example by not extracting all data from the archive on a file system the system reduces the possibility of errors to a substantial extent because extracting all contents of an archive to a file system is very error prone. Also because only a small portion of the data in the archive is extracted the deployment process is less time consuming and more efficient. Later in the process keeping the metadata in main memory allows for random access to different portions of the stored metadata as is required for deployment.

Based on the extracted metadata the archive processor creates deployment objects . To deploy the deployable objects the archive processor checks the compatibility of the objects to the runtime environment platform version to the version of the objects already deployed on the environment and the dependencies between objects. The relevant information for these checks is included in the deployment descriptors of components. The archive processor retrieves the platform version of the runtime environment and the platform version of the deployable objects and verifies their compatibility . Then the archive processor retrieves the component versions of the components deployed on the runtime environment which are required by the deployable objects the components versions of deployable objects and verifies their compatibility . With the latter two checks the archive processor ensures that from a versioning perspective the deployable objects can safely run on the environment.

After the versioning checks the archive processor checks dependencies between components . In this section of the process each deployable object is analyzed for dependencies to other components. That is does the object need any other components to run on the environment If no dependencies are identified the deployment manager deploys the objects on the environment . When objects are deployed they are encapsulated and activated on the environment. Encapsulating an object means wrapping the object so that it can run on the environment even if the environment contains components incompatible with it. This mitigates the risk of conflicts where concurrently existing transactions use different versions of the same objects. In such cases older versions are maintained on the environment until the transactions relying on are complete. In one embodiment once all transactions relying on an older version of the objects complete those objects are deleted from the environment. After deployment of the object any newly initiated transaction will use the newest version deployed.

In complex environments objects may depend on more than one component. If each of these components is available the deployment manager deploys the objects . If a component is not available and there are no further instructions for its processing the archive processor sets its state to error and skips the object . The system also allows for special instructions to be supplied and executed in the event of an object dependency being unresolvable. If the object has dependencies and further instructions are supplied in a control table the control table is loaded from storage . The control table contains specific commands instructing the archive processor how to proceed with the object. The command is identified and applied. If the command is to delete an object if its dependencies are not resolved the archive processor deletes the object . If the command is to skip the object if its dependencies are not resolved the archive processor skips the object . However in some cases deployment of an object may be required notwithstanding that the object s dependencies cannot be resolved. In this case a force command is supplied and the archive processor sends the object to the deployment manager for deployment on the runtime . The latter case allows for a software environment to be downgraded. Without a forced deployment a deployment system performing only static checks would not provide the possibility of a downgrade. Downgrades are important in certain test and maintenance scenarios such as ensuring backward compatibility of systems.

Throughout the deployment process the log manager maintains data about the process and logs errors and warnings about the process. After the deployment completes the log manager sends the log to the deploy processor . The deploy processor in turn sends the log to the UI and the UI reports the log. Thus an error handling policy can be applied through an analysis of the log.

In an embodiment of the invention Java application components are packed into a software component archive hereinafter SCA . SCA upload is performed in two stages. Firstly the SCA is uploaded to one of the application servers and is traversed to find out which and how many deployable Java objects modules or application configurations it contains. The deployment descriptors for these objects get cached and preliminary version checks take place. In the second stage approved objects are physically uploaded to a runtime environment. After the completion of the deployment process a list of all processed objects and a detail log about all errors and warnings occurred during deployment may be supplied.

An SCA is a nested archive forming a tree of four layers. Java resource files are divided in different components on the second level of the SCA tree. Physically deployable objects are packed into Java archives hereinafter JAR within a corresponding archive on the third level of the SCA tree. The root level of each JAR contains a META INF directory with the JAR MANIFEST.MF file. The SCA deployment service looks for the deployment descriptors either in this MANIFEST.MF or if not found there in a file in the root level of the JAR called deployment.properties. Deployment descriptors contain all necessary information to upload and activate the contained application resources. The deployment descriptors also tell the deployment service what kind of resources it has to process configurations or modules. The deployment expects to find only one module in a module type JAR and in general more than one logical configuration in a configuration type JAR. All logical configurations in a JAR belong to the same application. Configuration type JARs contain an obligatory mapping resource which defines the mapping between the resource data eXtensible Markup Language hereinafter XML files and the corresponding logical configuration.

In the embodiment of the invention the deployment system is implemented using three layers an UI layer an Advanced Business Application Programming hereinafter ABAP layer and a Java layer as shown on . For an application to be deployed the archive is uploaded to an application server instance and the analyzed to identify deployable Java objects that is modules and configurations. This is referred to as parsing mode . In parsing mode an SCA Processor opens the software component archive traverses it to find deployable Java resources and reads in their deployment descriptors. For each found module or configuration archive it creates one or more deployable objects and stores them. In this mode the system stores the transformed deployment attributes in a form which is suitable for physical processing and implements various attribute format transformations and platform related version checks. Also type specific deployment attributes for modules and configurations are maintained separately.

Once the objects are identified their deployment descriptors are read and version checks are performed on them. Once the deployable objects are approved they are loaded into the application runtime. To confirm the completion of the process the system provides a list of deployed objects and a list of errors and warnings that occurred during the deployment process. The deploy system also implements error handling policies and object level processing instructions for specific modules and configurations. This is referred to as deployment mode . In deployment mode the platform and mutual dependencies of all objects in the list are processed and uploaded to the application runtime. The physical upload is performed by a built in database class loading connector.

Referring to deployment parameters and an archive location are collected at the UI layer . The collected input is then received at the ABAP layer which uses the Java command handler to communicate with the Java layer . The Java layer processes the archive and uploads deployable objects on the Java application runtime using the Java runtime connector . Once the process is completed the Java layer uses the Java command handler to send a list of performed operations to the deploy list processor . The deploy list processor in turn sends two reports to the UI layer to display and confirm the deployment process.

The processor types in the Java layer are shown separately in . The Java command handler instantiates exactly one SCA Processor per SCA and controls its life cycle. It also creates an instance of the Log Manager to log its own processing messages. The SCA Processor uses one or more instances of a specialized input stream object to enable the read of application resources without unpacking them to a persistent storage. The specialized input stream object extends a regular Java input stream object with valuable features like random reading of particular resources. This is necessary because the underlying regular Java input stream is a low level inflator stream which can only access the archive data in sequential order. It can not be reset or repositioned and is the only possible stream to access nested JAR type entries in a compressed archive. On the other side deployment data processing must be able to access particular resource data in random order because it analyzes dependencies between them and determines the right deployment order. The specialized input stream object can be instructed to cache the data bytes of particular resource types at the moment the underlying regular input stream reaches them. Thus they can be accessed at an arbitrary point in time and access is not bound to the store sequence in the archive.

Error handling in the Java layer is enabled by several exception types that keep error codes and information for error situations. When a deployment exception type is instantiated the corresponding error code is set and the actual message parameters are saved for later use. The Log Manager can then retrieve all the information at log time. This approach allows very detailed error logging with the possibility to trace back not only the technical but also the logical cause of a deployment processing error.

As noted above SCA processing is performed in two stages. First a list of deployable objects is extracted. Referring to list extraction is initiated by a Remote Function Call hereinafter RFC . The command handler in turn instantiates a new SCA Deployer instance associates it with the SCA and calls the method getDeployables on it. From this point the control is taken over by the SCA Deployer . It opens an input stream and starts processing the deployables from the archive to traverse the nested levels of the archive tree and look for deployable objects. The method processDeployables performs both list extraction and actual deployment and is instructed which stage to perform via a Boolean parameter. After the list is extracted the SCA Deployer does all necessary version checks to ensure that the modules and configurations in the list are basically deployable. Versions are checked from two perspectives own version compatibility and platform version dependency. The deployment descriptors specify some versioning attributes for both perspectives. In general the versioning attributes contain at least one implementation version string of type digit .digit e.g. 700.11.20051011.12345 . The deployment service looks for the corresponding object in the persistence database and compares their versioning strings with the specified string. From the own version compatibility perspective the specified version must be greater or equal to the version of the deployed object module or configuration . To calculate this relation the corresponding version strings are translated into long arrays by splitting into numbers along the separator dots. The resulting arrays are then compared from left to the right .

From the platform dependency version perspective the version parameters of the corresponding platform component are compared with the specified version parameters in the deployment descriptor. Platform version parameters contain at least one major release and one patch number. Major release numbers for specified and deployed components must be equal. The patch version for installed platform components must be greater or equal to the specified patch version. The result of the version checks is reflected in the state field of each deployable instance. If the implementation version and the other relevant deployment attributes are compatible with the installation the object is set to state new otherwise it is set to state error.

In the second deployment stage all found modules and configurations in the archive are analyzed for dependencies to other objects. At this point a special deployment control table can be used to specify mandatory operations for particular modules or configurations in the list. The following control commands can be specified force skip and delete . The command force instructs the deploy processor to ignore the result from any dependency checks and to upload the object resources directly. For example this is the only way to achieve a downgrade of a Java module. The command skip instructs the deploy processor to skip the corresponding deployable from upload. The command delete instructs the deploy processor to delete the corresponding deployable from the application runtime.

When dependencies are examined if some required objects modules are neither installed nor available for upload in the same archive the corresponding deployable object is set to state error and skipped from further processing. shows an example embodiment of the overall deployment sequence. The process is initiated by the function module SVMCRT TRANS JAVA COMMAND which again sends to the CommandHandler the local path to the archive and an optional control table. The execution control is then transferred to the corresponding SCA Deployer which instantiates the initial input stream for the archive. After parsing the control table SCADeployer.modifyDeploymentIndex the SCA Deployer analyzes the object dependencies using the method preprocessDependenices and triggers the deployment via method processDeployablesFromArchive .

Elements of embodiments may also be provided as a machine readable medium for storing the machine executable instructions. The machine readable medium may include but is not limited to flash memory optical disks CD ROMs DVD ROMs RAMs EPROMs EEPROMs magnetic or optical cares propagation media or other type of machine readable media suitable for storing electronic instructions. For example embodiments of the invention may be downloaded as a computer program which may be transferred from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a carrier wave or other propagation medium via a communication link e.g. a modem or network connection .

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments of the invention.

In the foregoing specification the invention has been described with reference to the specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

