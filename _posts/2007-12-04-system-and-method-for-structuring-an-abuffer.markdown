---

title: System and method for structuring an A-buffer
abstract: One embodiment of the present invention sets forth a technique for efficiently creating and accessing an A-Buffer with a GPU. The A-Buffer is organized in arrays of uniformly-sized tiles. Each array represents a group of pixels, and each tile within an array includes the set of fragments at a specific depth complexity that are associated with the pixels in the pixel group represented by the array. The size of the tiles may be selected to be the minimum necessary for efficient memory access. The GPU determines the number of tiles in each array by calculating the maximum of the depth complexity associated with the pixels in the pixel group represented by the array and creates a corresponding prefix sum image to allow the GPU to efficiently locate the array associated with a given pixel group in the A-Buffer for addressing purposes. Advantageously, structuring the A-Buffer by both pixel proximity and depth complexity improves memory locality, thereby improving the overall rendering performance of the graphics pipeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08040349&OS=08040349&RS=08040349
owner: NVIDIA Corporation
number: 08040349
owner_city: Santa Clara
owner_country: US
publication_date: 20071204
---
The present invention relates generally to the field of graphics processing and more specifically to a system and method for structuring an A Buffer.

A typical computing system includes a central processing unit CPU and a graphics processing unit GPU . Some GPUs are capable of very high performance using a relatively large number of small parallel execution threads on dedicated programmable hardware processing units. The specialized design of such GPUs usually allows these GPUs to perform certain tasks such as rendering 3 D scenes much faster than a CPU. However the specialized design of these GPUs also limits the types of tasks that the GPU can perform. The CPU is typically a more general purpose processing unit and therefore can perform most tasks. Consequently the CPU usually executes the overall structure of the software application and configures the GPU to perform specific tasks in the graphics pipeline the collection of processing steps performed to transform 3 D images into 2 D images .

One task that may be performed when transforming 3 D images into 2 D images is to determine the visible color of each pixel in the image. To accurately determine the color at each pixel the fragment of each pixel intersected by an object may be evaluated to create a portion of the overall color of the pixel that includes a variety of effects such as transparency and depth complexity of field. In some approaches objects may need to be rendered in a specific order to ensure that the visible color of each pixel in the generated image is realistic. However in other approaches the fragments corresponding to each pixel may be collected sorted and reduced to an image which accurately displays advanced effects irrespective of the order in which the objects are rendered. One structure that computing systems may implement in these various approaches is an A Buffer a memory structure that maintains a collection of fragments associated with each polygon that intersects the pixels in an image frame being rendered for display.

In one approach to organizing an A Buffer the CPU is used to create and address in software a linked list of fragments per pixel. One drawback to this approach is that the A Buffer structure is not conducive to some of the most frequent fragment access patterns. For example when a polygon is rendered many of the corresponding fragments are located in adjacent pixels at the same depth complexity. As is well known memory accesses are usually most efficient if they can be grouped such that successive accesses target data that is closely located within the memory known as memory locality. Thus an efficient memory structure would enable fragments of this nature located at the same depth complexity to be simultaneously accessed. However since each pixel in the A Buffer has a separate linked list fragments corresponding to adjacent pixels at the same depth complexity may be far apart in memory leading to poor memory locality. Consequently accesses to the A Buffer may be inefficient.

Another drawback to this approach is that the CPU ends up performing many of the A Buffer operations rather than the GPU. As is well known graphics processing efficiency is increased when graphics processing operations are consolidated in the GPU. This problem can be addressed by having the GPU create and address the A Buffer using the linked list approach detailed above but such a solution does not address the depth complexity locality problem. Furthermore linked list operations are not usually performed efficiently in hardware such as the raster operations unit in the GPU and therefore such a solution would not necessarily improve the overall efficiency of A Buffer operations.

As the foregoing illustrates what is needed in the art is a more effective technique for creating and accessing an A Buffer.

One embodiment of the present invention sets forth a method for generating an A Buffer for storing pixel information. The method includes the steps of receiving an image frame comprised of a plurality of pixels dividing the image frame into one or more pixel groups where a number of pixels in each of the one or more pixel groups is based on a tile size generating a pixel depth complexity image based on the image frame where each entry in the pixel depth complexity image reflects a depth complexity associated with a different one of the pixels in the plurality of pixels and generating a tile depth complexity image based on the pixel depth complexity image where each entry in the tile depth complexity image reflects a maximum depth complexity associated with a different one of the one or more pixel groups. The method also includes the steps of determining a number of tiles associated with the A Buffer based on the tile depth complexity image and allocating memory space for the A Buffer based on the number of tiles associated with the A Buffer.

One advantage of the disclosed method is that organizing the A Buffer by both pixel proximity and pixel depth complexity improves the memory locality thereby increasing the efficiency of memory accesses used when rendering image data. Moreover the designer may select an appropriate tile size considering factors such as memory locality and the burst lengths of the different memory elements in the system to optimize the performance and memory usage of the A Buffer.

The system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM used to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions transmitted by the CPU and processes the instructions in order to render and display graphics images on the display devices .

The system memory includes an application program an application programming interface API high level shader programs and a graphics processing unit GPU driver . The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits one or more high level shading programs to the API for processing within the GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shaders within the graphics processing subsystem . The API functionality is typically implemented within the GPU driver . The GPU driver is configured to translate the high level shading programs into machine code shading programs that are typically optimized for a specific type of shader e.g. vertex geometry or fragment .

The graphics processing subsystem includes a graphics processing unit GPU a GPU local memory and a GPU data bus . The GPU is configured to communicate with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions in order to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as one or more programmable shaders e.g. vertex geometry or fragment each executing a machine code shading program i.e. a thread to perform image rendering operations. The GPU may be provided with any amount GPU local memory including none and may use GPU local memory and system memory in any combination for memory operations.

The GPU local memory is configured to include machine code shader programs storage buffers an A Buffer and a frame buffer . The machine code shader programs may be transmitted from the GPU driver to the GPU local memory via the system data bus . The machine code shader programs may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The storage buffers are typically used to store shading data generated and used by the shading engines in the graphics pipeline. The A Buffer may be used to store a collection of fragments associated with each polygon that intersects the pixels in an image frame that is being rendered for display. The frame buffer stores data for at least one two dimensional surface that may be used to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is used to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

The data assembly unit is a fixed function unit that collects vertex data from the application program for high order surfaces primitives and the like and passes the vertex data to the vertex shader . The data assembly unit may gather data from buffers stored within system memory and the GPU local memory as well as from API calls from the application program used to specify vertex attributes. The vertex shader is a programmable execution unit that is configured to execute a machine code vertex shading program processing vertex data as specified by the vertex shading program. For example the vertex shader may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may access data that is stored in GPU local memory .

The primitive assembly unit is a fixed function unit that receives processed vertex data from vertex shader and constructs graphics primitives e.g. points lines triangles or the like for processing by the geometry shader . In alternative embodiments a second primitive assembler not shown may be included subsequent to the geometry shader in the data flow through the GPU . The geometry shader is a programmable execution unit that is configured to execute a machine code geometry shading program processing graphics primitives received from the primitive assembly unit as specified by the geometry shading program. For example in addition to well known per primitive operations such as clipping the geometry shader may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used when the new graphics primitives are rasterized. The geometry shader may access data that is stored in the GPU local memory . The geometry shader outputs the parameters and new graphics primitives to the rasterizer .

The rasterizer is a fixed function unit that scans the new graphics primitives and outputs fragments each containing fragment data which may include raster position depth complexity or interpolated vertex attributes such as texture coordinates and opacity to the fragment shader .

The fragment shader is a programmable execution unit that is configured to execute a machine code fragment shading program processing fragments received from rasterizer as specified by the machine code fragment shading program. For example the fragment shader may be programmed to perform operations such as perspective correction shading blending and the like to produce shaded fragments that are output to the raster operations unit . The fragment shading engine may access data that is stored in buffers in the GPU local memory such as the A Buffer and the storage buffers . The raster operations unit optionally performs fixed function computations such as near and far plane clipping and raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in a buffer in the GPU local memory such as the A Buffer or the frame buffer . Together the rasterizer the fragment shader and the raster operations unit represent the fragment processing domain of the GPU where the raster operations unit may be used to operate on individual pixels or small squares of pixels and the fragment shader may be programmed to iterate across groups of pixels.

As shown in detail for the array S T each of the arrays may be subdivided into any number of two dimensional tiles . And as shown in detail in each tile may be configured to include an N by M set of fragments selected and arranged to correspond to the N by M pixel group represented by a specific array . Each tile may be further configured to include only fragments at a given depth complexity. In such a configuration the tiles included in a given array may together represent all of the fragments associated with the N by M pixel group represented by the array where each of the tiles represents the subset of the fragments at a particular depth complexity. As set forth in greater detail herein organizing the fragments in such a manner by both depth complexity and associated pixel proximity optimizes the locality of memory references.

The size of the tiles and consequently the size of the pixel group represented by each array may be chosen by the designer and may be uniform across the A Buffer . The size of the tiles in conjunction with the size of the image frame may determine the number of the arrays in the A Buffer . Suppose for example that a tile size of four by two pixels is chosen. And suppose the size of a given image frame is eight by four pixels. The pixels in the image frame may be divided into four subsets of four by two pixels and the A Buffer may be configured to include four arrays of four by two tiles . In other embodiments the tile size may be chosen to be more or less than four by two and the number of arrays in the A Buffer may be more or less than four. Furthermore the size of the tiles may be chosen in any technically feasible fashion to facilitate efficient memory access considering factors such as the burst lengths of the memory elements within the system and memory locality.

Referring back now to the number of tiles in each array may differ. Since each of the tiles corresponds to a specific depth complexity the number of tiles in a given array corresponds to the maximum depth complexity associated with any of the pixels represented by the array . For example if a given array were to represent pixels having two depth complexities such as depths zero and one then the array would include two tiles that include one or more fragments at these two depth complexities. Similarly if a given array were to include three tiles then the array would include fragments at three different depth complexities such as depth complexities zero one and two. The GPU is configured to assign tiles to each of the arrays calculating the maximum depth complexity associated with the N by M group of pixels represented by a particular array to determine the appropriate number of tiles to allocate for that array .

The computing system is configured to re allocate the A Buffer for each image frame determining the structure of the A Buffer by the size and complexity of the image frame as described above.

The method begins at step where the GPU receives an image frame and a memory efficient tile size N by M. As described above in conjunction with the tile size corresponds to the size of the pixel group represented by each of the arrays in the A Buffer and may be determined in any technically feasible fashion. illustrates an exemplary image frame . As shown the image frame includes sixteen pixels   arranged in a four by four rectangle. Each of the pixels may include any number of fragments not shown .

In step the raster operations unit creates a pixel depth complexity image by calculating the depth complexity for each pixel in the image frame. illustrates an exemplary pixel depth complexity image corresponding to the image frame of . As shown the pixel depth complexity image includes sixteen entries each entry representing the depth complexity of the corresponding pixel in the image frame . For example the pixel depth complexity image shows a depth complexity of twelve for the pixel   a depth complexity of eight for pixel   a depth complexity of one for the pixel   and a depth complexity of one for the pixel   .

In step the fragment shader creates a tile depth complexity image based on the pixel depth complexity image generated in step . More specifically the fragment shader divides the pixel depth complexity image into N by M groups of pixels where N by M is the tile size received in step . As part of step the fragment shader assigns each N by M group of pixels to a specific array in the A Buffer . For example referring again to the sixteen pixels in the image frame are divided into four two by two groups of pixels pixel groups . Therefore the A Buffer would have four arrays one corresponding to each of the two by two pixel groups .

Also as part of step the fragment shader evaluates the pixel depth complexities of each of the pixels associated with each of the N by M pixel groups and determines a single depth complexity for each N by M pixel group. The single pixel depth complexity corresponds to the maximum depth complexity associated with the pixels within the N by M pixel group. The fragment shader then arranges all of the maximum depth complexity values into a tile depth complexity image where each entry in the tile depth complexity image defines the number of tiles assigned to the array in the A Buffer associated with a particular N by M pixel group the entry in the tile depth complexity image is referred to as the tile depth complexity of the array . Consequently the size of the tile depth complexity image is a factor of N by M smaller than the corresponding pixel depth complexity image. illustrates an exemplary tile depth complexity image corresponding to the pixel depth complexity image of . As shown the tile depth complexity image includes four entries each entry representing the calculated tile depth complexity of an array corresponding to a particular pixel group . For example the tile depth complexity image shows a tile depth complexity of twelve for the array   which corresponds to the pixel group of . This tile depth complexity corresponds to the maximum depth complexity associated with the four pixels pixel   pixel   pixel   and pixel   within the pixel group . Likewise the tile depth complexity image shows a tile depth complexity of eight for the array   . This tile depth complexity corresponds to the maximum depth complexity associated with the four pixels pixels   pixel   pixel   and pixel   within the pixel group .

In step the fragment shader creates a prefix sum image of the tile depth complexity image. In so doing the fragment shader orders the arrays of the A Buffer in any technically feasible fashion before performing the prefix sum operations. For example the fragment shader may order the arrays by row majority set the first entry in the prefix sum image to zero and thereafter add the nth entry in the tile depth complexity image to the nth entry in the prefix sum image to obtain the nth 1 entry in the prefix sum image. The prefix sum image is the same size as the tile depth complexity image where each entry corresponds to a specific array in the A Buffer and indicates the number of tiles in the A Buffer that come before the first tile in that specific array . illustrates an exemplary prefix sum image corresponding to the tile depth complexity image of . As shown the exemplary prefix sum image includes four entries each entry representing the number of tiles that come before a particular array in the A Buffer. As illustrated in the prefix sum image the arrays have been ordered from first to last as follows         . The prefix sum image shows that the number of tiles that come before the array   in the A Buffer is nineteen which is the sum of the entry in the tile depth complexity image for the tile   eleven and the entry in the prefix sum image for the tile   eight . Likewise the prefix sum image show that the number of tiles that come before the array   in the A Buffer is eight which is the sum of the entry in the tile depth complexity image for the tile   eight and the entry in the prefix sum image for the tile   zero .

In step the CPU calculates the total number of tiles in the A Buffer . In one embodiment the CPU adds the last entry in the tile depth complexity image representing the number of tiles in the last array of the A Buffer to the last entry in the prefix sum image representing the total number of tiles that come before the last array in the A Buffer to determine the total number of tiles in the A Buffer . An exemplary calculation corresponding to the step is illustrated in using the tile depth complexity image of and the prefix sum image of . As shown the total number of tiles in the A Buffer is equal to the sum of the number of tiles in the last array of the A Buffer which is represented by the last entry in the tile depth complexity image twelve and the number of tiles before the last array of the A Buffer which is represented by the last entry in the prefix sum image twenty six . The result thirty eight is the total number of tiles in the A Buffer.

In step the CPU calculates the size of the A Buffer by multiplying the total number of tiles determined in step by the tile size and attempts to allocate the corresponding memory for the A Buffer .

In step if the CPU determines that the memory allocation failed then the method proceeds to step where the CPU tells the application program that the memory allocation for the A Buffer failed. The method then terminates. The application program may respond to this notification by iteratively reducing the size of the scene the application program is trying to render until the memory allocation for the A Buffer succeeds. If in step the CPU determines that the memory allocation succeeded then the method proceeds to step .

In step once the appropriate memory for the A Buffer is allocated the GPU populates the A Buffer with the various fragment data associated with the image frame. The GPU may use either the raster operations unit or the fragment shader to populate the A Buffer . The raster operations unit may be more efficient at performing some A Buffer operations however since the fragment shader may execute a machine code geometry shading program the fragment shader may be more flexible. As part of step the raster operations unit or the fragment shader may address the A Buffer using the method described below in .

The method begins at step where the GPU receives three values X Y D . The two dimensional coordinates X Y specify the coordinates of a pixel in a two dimensional image frame and D specifies the depth complexity of a particular fragment associated with the pixel. In step the GPU uses the N by M tile size of the A Buffer to calculate the two dimensional coordinates of the array that includes the pixel located at image coordinates X Y . The GPU may perform this calculation in any technically feasible manner. For example the GPU may calculate the array coordinates using the integer division operations X N Y M . Illustratively referring again to the image frame of and recalling that the exemplary tile size is two by two the array coordinates for a pixel located at coordinates 1 2 in the image frame would be 1 2 2 2 0 1 .

In step the GPU uses the array coordinates calculated in step to index into the prefix sum image generated in step of method to determine the array offset in tiles of the array that includes the pixel located at image coordinates X Y . Indexing into the prefix sum image may be accomplished in any technically feasible fashion corresponding to the organization of the arrays in the prefix sum image. For example the first of the two array coordinates may indicate the column number of the prefix sum image and the second of the two array coordinates may indicate the row number of the prefix sum image. The array offset represents the number of tiles in the A Buffer that come before the first tile in the array that includes the pixel located at image coordinates X Y . For example referring again to by using the array coordinates 0 1 calculated above to index into the prefix sum image thereby accessing the entry at column number zero and row number one the array offset corresponding to the array that includes the pixel at image coordinates 1 2 in the image frame is determined to be nineteen. In other words there are nineteen tiles in the A Buffer corresponding to the image frame that come before the first tile in the array that contains the pixel located at image coordinates 1 2 in the image frame .

In step the GPU calculates the tile offset in tiles of the specific tile that includes the fragment at the depth complexity D associated with the pixel located at the image coordinates X Y . Specifically the GPU adds the specified depth complexity D to the array offset calculated in step to compute the tile offset. The tile offset represents the number of tiles in the A Buffer that come before the specific tile in the A Buffer that contains the fragment at depth complexity D that is associated with the pixel located at image coordinates X Y . For example where the depth complexity D is two and the array offset calculated in step for a pixel at image coordinates 1 2 in the image frame is nineteen the tile offset is twenty one. In other words there are twenty one tiles in the A Buffer corresponding to the image frame that come before the tile that contains the fragment at the depth complexity two associated with the pixel located at the image coordinates 1 2 in the image frame .

In step the GPU multiplies the tile offset by the tile size N by M to determine the tile offset in pixel units. In step the GPU uses the tile size N by M to calculate the tile coordinates of the pixel located at image coordinates X Y . Again the GPU may perform this calculation in any technically feasible manner. For example the GPU may calculate the tile coordinates using the modulus operations X N Y M . For example if the image coordinates were 1 2 and the tile size were two by two then the tile coordinates would be 1 2 2 2 1 0 . In step the GPU uses the computed tile coordinates to index into the tile at the tile offset in pixel units calculated in step thereby addressing the fragment at depth complexity D that is associated with the pixel located at image coordinates X Y .

Although embodiments of the present invention have been described in the context of organizing the A Buffer using two dimensional tiles persons skilled in the art will appreciate that the principles of the present invention apply with equal force to implementations where the A Buffer is organized using different pixel groupings such as for example three dimensional pixel blocks.

In sum image rendering performance may be improved by using an A Buffer structure that allows fragment data to be stored in a way that increases the memory locality to enable high efficiency memory accesses by the GPU. In one embodiment the GPU determines the organization of the A Buffer generates a prefix sum image to facilitate allocation and addressing of the A Buffer populates the A Buffer and addresses the A Buffer while the CPU determines the overall A Buffer size and allocates the corresponding memory. In this approach the A Buffer is organized in three dimensional arrays of uniformly sized two dimensional rectangular tiles each array representing a group of pixels and the fragments associated with these pixels. Each tile in a given array includes the set of fragments at a specific depth complexity that are associated with the group of pixels represented by the array. Since each tile corresponds to a specific depth complexity the number of tiles in a given array corresponds to the maximum depth complexity associated with the pixels in the pixel group represented by the array. To reduce memory usage the GPU may assign a different number of tiles to each array calculating and using the maximum depth complexity of the pixels represented by each array to determine the appropriate number of tiles to allocate for the array.

Advantageously organizing the A Buffer by both pixel proximity and pixel depth complexity improves the memory locality thereby increasing the efficiency of memory accesses used when rendering image data. Moreover the designer may select an appropriate tile size considering factors such as memory locality and the burst lengths of the different memory elements in the system to optimize the performance and memory usage of the A Buffer. Finally consolidating A Buffer operations into the GPU increases the efficiency of these operations and consequently improves the overall performance of the graphics pipeline.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the scope of the present invention is determined by the claims that follow.

