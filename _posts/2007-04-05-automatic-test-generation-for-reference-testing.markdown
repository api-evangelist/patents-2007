---

title: Automatic test generation for reference testing
abstract: A system for application reference testing (SMART) solves the technical problem of generating test data and test cases from graphical user interface applications (GAPs) to test web services, effectively and non-invasively. SMART allows organizations to easily and promptly identify and resolve software bugs, ensure higher quality software and development productivity, complete software projects faster, deliver software products to market quicker, and improve the return on investment for software development projects. SMART provides a user friendly visualization mechanism that interacts with an accessibility layer to enable organizations to economically and easily define user interactions with GAPs, by performing point-and-click, drag-and-drop operations on the GAPs, and generate reusable test data and test cases for web services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07979846&OS=07979846&RS=07979846
owner: Accenture Global Services Limited
number: 07979846
owner_city: Dublin
owner_country: IE
publication_date: 20070405
---
This disclosure concerns generating test cases from graphical user interface applications GAPs to perform reference testing on web services. In particular this disclosure relates to an efficient and non invasive approach to generating reference tests cases and production data from GAPs for web services.

Organizations spend a substantial portion of their software development project budgets to create test cases. A strong demand exists for systems that generate accurate test cases efficiently and economically. However many software development projects employ laborious and inefficient methods and systems only to produce inaccurate and incomplete test cases that as a consequence fail to meet some or all of the testing requirements. A test case may include test data e.g. valid input data and a test oracle e.g. an expected or valid output . Organizations face many of the same technical issues generating both test data and production data from reference applications and develop elaborate data conversion programs to create production data for new applications. Software developers and system integrators developers commonly consider test data disposable and only used in testing. Accordingly test data content may in fact be production data though distinguished by name due to its role in the testing process.

Developers test new applications to validate that the software complies with system requirements. The testing process includes developing test logic based on detailed specifications and alternatively performing reference testing i.e. a form of regression testing . Developers retest i.e. regression test modified software to ensure that a modification to the modified software operates properly and that the modification has not caused other previously working functions of the modified software to fail. Reference testing includes comparing outputs from new applications against previously recorded i.e. expected outputs from the same application or another application. Test oracles may require developers to provide detailed and comprehensive descriptions of the desired behaviour for the new application. Consequently the quality of a test oracle depends on the quality of the specification. Reference testing includes testing new applications target applications using information from legacy applications reference applications . When developers migrate or model functionality from a reference application to a target application developers attempt to reuse test data and test cases from the reference application. The purpose of migrating functionality includes replacing the reference application with the target application. In contrast the purpose of modelling functionality of a reference application may include merely replicating the functionality of the reference application in the target application and not for the purpose of replacing the reference application.

It is very commonly the case that after a software project team deploys a reference application into production for an organization neither the organization nor the team preserves test data or testing documentation. Even though organizations may store data accumulated by reference applications over many years of use in production organizations find it difficult to extract and develop test data and test cases from the reference applications to test target applications. Organizations that desire to use data from reference applications spend significant time and money in attempts to understand the source code and the data structures of the reference applications.

Modern systems often incorporate Graphical User Interface GUI Applications GAPs implemented in a closed and monolithic manner. Developers building target applications find extracting test cases from existing GAPs reference applications a difficult technical challenge especially for closed and monolithic GAPs. Thus a fundamental technical problem of interoperability for developers is how to extract test cases from existing GAPs efficiently and non invasively.

Developers and organizations purchasing system integration and software development services recognize the difficulty and enormous expense of developing new software applications. Beyond developing new applications developers must define and generate accurate test data and test cases. Organizations tend to use legacy GAPs as long as possible in business operations primarily to realize the return on investment for the legacy GAPs. However developers find extracting data from GAPs difficult because the vast majority of GAPs are closed and monolithic. In other words most GAPs do not expose programming interfaces or data in known formats. Thus while developers find the use of GAPs to extract test data and test cases desirable often the original implementation of a GAP makes the extraction impossible.

In contrast to GAPs developers design web services as software components that flexibly exchange information over networks including the Internet. Consequently business industry demand for applications that easily and inexpensively exchange information has partly caused widespread acceptance of web services. Employing web services unlike GAPs enables organizations to quickly build integrated systems by composing i.e. configuring the web services for information exchange. Organizations easily migrate and or model functionality from existing web services to other web services. However migrating or modelling functionality in GAPs to generate test data and test cases for web services provide a considerable technical challenge for organizations and developers.

Organizations have invested heavily in legacy GAPs and developers find it difficult and time consuming to analyze the source code of GAPs to extract data and test cases because of brittle legacy architectures poor documentation significant programming effort and subsequently the large cost of such projects. Organizations often do not have access to the source code necessary to analyze and develop data extraction and test cases from GAPs in particular regarding third party provided GAPs. Given the complexity of GAPs and the cost to migrate and model GAPs to create new web services a fundamental problem exists of how to extract test data and test cases from GAPs to test web services and generate production data from GAPs efficiently and non invasively.

A need has long existed for a system and method to economically and efficiently extract test cases and production data from GAPs for web services.

A system for application reference testing SMART considers GAPs as state machines in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state i.e. GAP state definition useable to test applications. SMART provides a general reusable and reliable mechanism for generating test data and test cases from legacy applications without the need to understand manipulate or modify the legacy application source code or data storages. When developers write target applications the reference applications serve as references to test the target applications. Reference applications may include legacy applications that the target application will replace i.e. migrate functionality or non legacy applications i.e. applications that the target application will not replace that possess functionality the target application intends to model. Developers may also use SMART to generate test cases and production data from the reference applications to test and operate the target applications. Organizations face many of the same technical issues generating both test data and production data from reference applications and often spend significant time money and other resources to develop elaborate data conversion programs to create production data as well as test data for new applications. One distinction between test data and production data is that test data is generally considered disposable. Accordingly SMART also solves the technical problem of creating production data for target applications from reference applications.

In one implementation SMART considers GAPs as state machines in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state or GAP state definition. The GAP state definition may include UI screen sequences GUI elements of the GAP the function types of the GUI elements the properties of the GUI elements and the values of the GUI elements. SMART may establish test cases based on GUI elements that can substitute for target application data and GAP state definitions. SMART may establish the test cases to include test logic incorporated with GAP state definitions. SMART allows developers to test target applications e.g. web services based applications using GAPs as reference applications. In addition SMART may calculate or analyze the number of GUI elements that SMART may substitute for target application data and the number of data elements employed by the GAP including non GUI elements to determine the suitability of a GAP as a reference application for testing a target application. SMART may indicate the percentage of target application data parameters that SMART may substitute using GAP GUI elements as test data.

SMART may work in conjunction with a Composer of Integrated Systems Coins to produce test cases and production data. Coins provides an approach for creating integrated systems composing GAPs and web services. SMART may work with Coins to control a first GAP e.g. invoice application to produce an input to a second GAP e.g. an expense application to produce a test case. Coins combines a non standard use of accessibility technologies used to access and control GAPs in a uniform way with a visualization mechanism that enable nonprogrammers to compose GAPs with each other and web services. Coins uses accessibility technologies to control GAPs and their user interface UI elements as programming objects set and retrieve UI elements and associates methods with actions that users perform on the UI elements. For example when a user selects a combo box item the combo box invokes a method that performs some computation. A web service would invoke methods and set or retrieve field values of a programming object representing the combo box to control the combo box programmatically. Coins controls GAPs as programming objects and UI elements as fields of the programming objects and invokes methods on the objects to perform actions and manipulate the GAPs and UI elements. Unfortunately web services cannot access and manipulate UI elements as pure programming objects because UI elements only support user level interactions. However accessibility technologies expose a special interface that allows the Coins to invoke methods and set and retrieve UI element values and thereby control UI elements and GAPs.

Organizations may extend the value of legacy GAPs by using the legacy GAPs to test web services. SMART allows users to associate GUI elements GAP state definitions and test logic with test cases that establish test frameworks. SMART establishes test frameworks by capturing user interactions with GAP GUI element e.g. clicking a button on a GAP screen . SMART allows users to define the GUI elements to use as test data elements and the GAP state definitions and test logic to define test oracles. In addition SMART allows users to specify how to use test oracle return values to validate test results.

Other systems methods and features of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the following claims.

A system for application reference testing SMART considers GAPs as state machines in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state i.e. GAP state definition useable to test applications. SMART solves the technical problem of generating test data and test cases from GAPs to test applications. SMART interacts with an accessibility layer to define user interactions with GAPs by performing point and click drag and drop operations on the GAPs and generate reusable test data and test cases for target applications. SMART considers GAPs as state machines in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state or GAP state definition. The GAP state definition may include UI screen sequences GUI elements of the GAP the function types of the GUI elements the properties of the GUI elements and the values of the GUI elements. SMART extends certain aspects of Coins briefly discussed below.

Accessibility technologies provide different aids to disabled computer users including as examples screen readers for the visually impaired visual indicators or captions for users with hearing loss and software to compensate for motion disabilities. Under 36 CFR part 1194 the Architectural and Transportation Barriers Compliance Board s Electronic and Information accessibility Standards requires that when Federal agencies develop procure maintain or use electronic and information technology the electronic and information technology allows Federal employees with disabilities access and use of information and data comparable to Federal employees without disabilities. Accordingly because the Federal Government s large appetite for technology and the desire of the technology industry to sell technology to the Federal Government most computing platforms include accessibility technologies. For example Microsoft designed Microsoft s Active Accessibility MSAA technology to improve the way accessibility aids work with applications running on Windows and Sun Microsystems accessibility technology assists disabled users who run software on top of Java Virtual Machine JVM . Many computing platforms as well as libraries and applications incorporate accessibility technologies in order to expose information about user interface elements. Accessibility technologies provide a wealth of sophisticated services useable to retrieve UI elements attributes set and retrieve UI element values and generate and intercept different events. SMART uses accessibility technology to access an accessibility interface that UI elements expose. The accessibility interface exports method for accessing and manipulating the properties and behaviour of the UI elements. For example a Windows UI element employs the IAccessible interface to allow access and control of the UI element using the MSAA API calls. Accessibility API calls may include get into object perform action on object get value from object set value on object navigate to object and set property on object.

SMART generates a test framework for a target application TAP from a GAP that serves as the reference application. SMART interacts with the GAP through an accessibility layer to capture a structural representation of a GAP graphical user interface GUI screen including a GUI element. SMART also establishes a GAP state definition. The GAP state definition includes a function type for the GUI element an element property for the GUI element and an element value for the GUI element. SMART generates the test framework including a test case specifying an interaction with the GAP through the accessibility layer based on the structural representation. The test framework also includes a test data element that provides an input parameter for the interaction of the test case with the GAP.

Coins addresses the technical challenge of enabling GAPs to exchange information i.e. interoperate with each other and web services over the Internet and solves the technical problem of composing integrated systems using GAPs and web services efficiently and non invasively. Coins allows users to create composite web services from multiple GAPs and web services. Coins identifies and registers multiple GAPs as a result of the Coins capturing through the accessibility layer i.e. accessibility API information regarding GAPs and user interface UI elements of the GAPs. Coins registers GAPs and web services using a design tool user interface to capture user interface interaction specifications that create user interface element correspondence between a UI element of one GAP and a different UI element in a different GAP. Coins defines a web service parameter relationship between a web service parameter and one or more UI elements of a GAP and defines a composite web service definition for a composite web service from one or more web service parameters. Coins generates and deploys composite web services based on composite web service definitions one or more user interface interaction specifications and one or more web service parameter relationships. Coins may also generate and deploy web services based on web service definitions that include one or more user interface interaction specifications between UI elements of different GAPs and one or more web service parameter relationships.

Coins uses proxies to command and control GAPs and UI elements of GAPs to fulfil web service requests. When a proxy receives a response from a GAP the proxy extracts data from the GAP and forwards the extracted data to one or more web services. Proxies use hooks to perform various actions on UI elements and GAPs programmatically through accessibility API calls. Accessibility technologies allow hooks to register for different events produced by UI elements and GAPs monitored by accessibility APIs. One or more GAPs may run with a proxy and corresponding hooks on a single designated GAP host computer along with a accessibility API.

Coins uses a dispatcher as a central point for coordinating proxies in a distributed environment. A proxy registers with the dispatcher under a unique name collects GAP identification data and information about GAPs running with the proxy on a GAP host computer and sends the collected GAP identification and information about GAPs to the dispatcher. The dispatcher uses the information collected from the proxies to route web service requests to proxies. The dispatcher routes web service request components of composite web services to one or more GAP host computers where corresponding proxies ultimately command and control GAPs and UI elements. The dispatcher acts as an intermediary that enables web services and GAPs to run on separate computers while presenting a common view to client programs. Because organizations may move web services and GAPs around the enterprise computing environment for various reasons e.g. to improve business processes efficiencies or the performance of applications the dispatcher provides web services and GAPs migration and location transparency to client programs.

The elements illustrated in the Figures interoperate as explained in more detail below. Before setting forth the detailed explanation however it is noted that all of the discussion below regardless of the particular implementation being described is exemplary in nature rather than limiting. For example although selected aspects features or components of the implementations may be depicted as being stored in memories all or part of systems and methods consistent with Coins may be stored on distributed across or read from other machine readable media for example secondary storage devices such as hard disks floppy disks and CD ROMs a signal received from a network or other forms of ROM or RAM either currently known or later developed.

Furthermore although this document describes specific components of Coins and SMART methods systems and articles of manufacture consistent with SMART and Coins may include additional or different components. For example a processor may be implemented as a microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other type of circuits or logic. Similarly memories may be DRAM SRAM Flash or any other type of memory. Logic that implements the processing and programs described below may be stored e.g. as computer executable instructions on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. Flags data databases tables and other data structures may be separately stored and managed may be incorporated into a single memory or database may be distributed or may be logically and physically organized in many different ways. Programs may be parts of a single program separate programs or distributed across several memories and processors and may be implemented or distributed as shared libraries application programming interfaces APIs or in other forms. Furthermore the programs or any portion of the programs may instead be implemented in hardware.

In one implementation when proxy receives a web service request component the proxy interacts with one or more UI elements of the GAP with UI elements through the hook in response to the web service request component. The accessibility layer may support hook to perform various actions on GAP with UI elements programmatically. Proxy in communication with GAP host computer for GAP with UI elements and hook may register the GAP with UI elements with the dispatcher resulting in a second composite web service request component of the composite web service to route through the dispatcher to the GAP host computer . In one implementation when proxy receives the second web service request component the proxy interacts with one or more of the UI elements of the GAP with UI elements through the hook in response to the second web service request component. The accessibility layer may support hook to perform various actions on GAP with UI elements programmatically. The dispatcher may use a load balancer to route web service requests to multiple GAP host computers.

In one implementation of the Integrated System multiple instances of a GAP e.g. Acme Expense GAP AEG run concurrently on separate GAP host computers e.g. GAP host computer GAP host computer and GAP host computer . The dispatcher assigns each instance of AEG a unique GAP identifier enabling the dispatcher to coordinate parallel execution of multiple instances of AEG so that when the composite web service sends a composite web service request component to the dispatcher in response to a request from a client program the dispatcher routes the composite web service request component to the correct instance of AEG.

In one implementation the accessibility layer supports hook and hook to perform various actions programmatically on GAP GAP UI elements and GAP and GAP UI elements respectively. The accessibility layer may also assist with capturing a structural representation of GUIs of a GAP and UI elements of the GAP as a result of interactions with the GAP. The structural representation of GUIs of a GAP and UI elements of the GAP may provide the proxy hook and hook comprehensive information to locate control and manipulate GAP GAP GAP UI elements and GAP UI elements . The structural representation of GUIs of a GAP and UI elements of the GAP may be implemented with a data structure e.g. an XML file that captures a depth first traversal of the GUI breadth first traversal of the GUI or that otherwise stores the interface elements and screen sequences of the GUI. The proxy may analyze the structural representation of GUIs of a GAP and UI elements of the GAP to locate a GAP UI element in the GAP GUI.

The proxy may include registration logic an accessibility layer command coordinator and a GAPs identification table . The proxy may use the registration logic to register GAP and GAP with the dispatcher. The accessibility layer command coordinator may control GAP and GAP UI elements through hook in response to a web service request component. To that end the accessibility layer command coordinator may receive web service request components extract the graphical user interface element identifiers a structural representation of a GAP and the requested action on the identified graphical user interface element. The accessibility layer command coordinator may then traverse the structural representation to determine where the identified graphical user interface element resides in the GAP user interface and make calls to the hook to navigate the GAP to the interface that includes the identified graphical user interface element. Once at the appropriate interface the accessibility layer command coordinator may then exercise the graphical user interface element through the hook to perform the requested action.

In another implementation proxy uses an accessibility layer command coordinator running on and dedicated to GAP host computer to control GAP with UI elements through hook in response to a web service request component. The proxy may collect GAP identification data and information about GAPs e.g. GAP and GAP hosted with proxy on the multiple GAPs host computer and stores the collected GAP identification data and information about the GAPs in the GAPs identification table . In one implementation the proxy may store GAP Identifiers for multiple locally hosted GAPs e.g. GAP and GAP in the GAP identification table . The proxy may periodically send the collected GAP identification data and information about the GAPs to the dispatcher . The multiple GAPs host computer may use the external storage to store the GAP exe and GAP exe programs.

In an alternative implementation the dispatcher receives a web service request message from the web service that includes a GAP UI element Identifier and an action request identifier for a specific GAP UI element e.g. GAP UI elements . The GAP UI element may correspond to a GAP e.g. GAP executing in memory . The dispatcher may send the web service request message to proxy which extracts the GAP UI element identifier and action request identifier from the web service request message. The proxy may perform an action against the GAP UI elements specified in the action request identifier through hook . The action request identifier may include a GUI element data setting action or a GUI element data retrieval action that the proxy performs through hook against the GAP UI elements specified in the action request identifier.

In one implementation when a client program invokes a method of a web service or composite web service the web service or composite web service to which the method belongs sends a web services registration request to the dispatcher . The dispatcher may identify the GAPs required to fulfil a method of a web service or a composite web service . The dispatcher may use registration logic to receive GAP registration requests from GAPs and web services registration requests from web services and composite web services . The dispatcher may also use the registration logic to control GAPs to web services assignments logic to analyze the proxy GAPs identification tables to assign GAPs and UI elements to methods of web services and methods of composite web services . In one implementation the registration logic instantiates the proxy GAPs identification table e.g. proxy GAPs identification table and proxy GAPs identification table in response to a GAP registration request from a GAP. The dispatcher may include a GAPs request queue to store web service requests and web service request components when a web service requests an unavailable GAP which will be explained in further detail below.

The interaction logic captures one or more GAP UI elements and one or more GAP UI elements using the accessibility layer . In other words the Interaction logic may capture a structural representation of GUIs of a GAP and UI elements of the GAP through the accessibility layer using the hook logic to communicate with the GAPs e.g. GAP GAP and corresponding GAP UI elements and GAP UI elements . Proxy logic may control the GAPs through the hook logic and the proxy logic may use the registration logic to send GAP registration requests to the dispatcher . The structural representation of GUIs of a GAP and UI elements of the GAP may include a GAP UI element label a UI element Identifier and location information in the GAP GUI for the GAP UI elements e.g. GAP UI elements and GAP UI elements and may also include a GAP GUI screen sequence representation for each GAP GUI screen sequence.

The design tool user interface logic may generate the design tool user interface that includes the input parameter area and a screen sequence area monitor and determine an operator s selection of at least one of the GAP UI elements in the GAP GUI represented in the structural representation of GUIs of a GAP and UI elements of the GAP and add the selected GAP UI elements to the input parameter area . The definition logic may establish the web service definition with at least one of the web service parameters e.g. WS parameter WS parameter and WS parameter that will interact with the at least one of the GAP UI elements . The relation logic may establish a web service parameter relationship between at least one of the web service parameters e.g. WS parameter WS parameter and WS parameter and at least one of the GAP UI elements . The relations logic may establish multiple web service parameter relationships with multiple web service parameters e.g. WS parameter WS parameter and WS parameter and each of the GAP UI elements .

The user interface tool may include an input parameter area UI screen sequence area and input logic area . In one implementation SMART may divide the user interface tool input parameter area into a reference application RAP view RAV and target application TAP view TAV . The RAV interacts with the RAP through a proxy that controls the RAP through an accessibility layer in communication with a hook . The RAV captures structural representations of a GAP and UI elements of the GAP and GAP state definitions through interactions with the RAP . The GAP state definition may include a GAP UI screen sequence a GAP Screen and a GUI element associated with the GUI screen . The GAP state definition may also include various attributes of the GUI element including GUI element functions GUI element property and GUI element value . The RAV may establish a test framework based on the GUI element GAP state definition and test logic defined in the input logic area . The test framework may define a test case that includes a test data element associated with the GUI element and a test oracle . The test case may associate the test oracle with the GAP state definition and test logic that determine a return value response for the test oracle . The test framework may include multiple test cases and the each test case may include a test case description that indicates the scope and purpose of a test case.

The user interface tool input parameter area target application TAP view TAV may capture a TAP interface definition including a TAP data parameter and TAP return value parameter . Once SMART captures a TAP interface definition and establishes a test framework SMART may establish a test harness associating the TAP to the test framework . SMART may define the test harness to include a test framework description a test harness data parameter and a test harness return value parameter . Test harness may establish a relationship between the test framework and TAP interface using the test framework description to identify the test framework and corresponding test case that the test harness will use to test the TAP . The test harness may use the test harness data parameter to establish a relationship between the TAP data parameter and test data element . The test harness may also use the test harness return value parameter to establish a relationship between the TAP return value parameter and the test oracle . Once SMART establishes the test harness which associates the TAP and test framework the test harness may send test data corresponding to the test data element representing TAP data to the TAP through the test harness data parameter . The TAP interface may send the test framework a TAP return value through the test harness return value parameter . In response to the TAP return value the test oracle may apply test logic to the TAP return value and return a test oracle return value to the test harness . SMART may store the test framework and test harness in external storage for reuse and further testing.

In one implementation the RAV may capture a GUI element that includes multiple GUI element functions including an action producer input data acceptor an output data retriever and a state checkpoint . The GUI element may include any combination of the GUI element functions . For example the Search pull down box GUI element has a GUI element value equal to Down and the GUI element property the functions of the GUI element may operate to cause the action producer function to set a GUI Screen to scroll in the downward direction and cause the GAP state to change e.g. from editing a document to searching a document . In the Search pull down box example the output data retriever function retrieves a list of search options from a container e.g. listviews and edit boxes to display in the Search pull down box e.g. Up Down and All while the input data acceptor function receives the selected Down value as input data. Following the example above the state checkpoint function may indicate an intermediate GAP GUI screen state corresponding to the execution of the Search function. Alternatively the state checkpoint function may indicate a final state or exception state where the action producer causes an application to complete an action e.g. close an application or result in an error e.g. invalid input to the input data acceptor .

In one implementation SMART may calculate or analyze a SMART ratio . The SMART ratios may include a GAP utilization ratio and TAP testing coverage ratio . The GAP utilization ratio represents a ratio of the number of GUI elements that SMART may associate with test data elements to substitute as TAP data to the number of GAP data elements optionally including non GUI elements used to run the GAP. For example if a GAP employs 6 543 data elements e.g. the total number of both non GUI elements and GUI elements and 2 768 of the data elements GUI elements may be used as test data then the GAP utilization ratio is 42.30 . In an alternative implementation SMART may establish the TAP testing coverage provided by a GAP. In other words SMART may determine the TAP testing coverage ratio that indicates the percentage of TAP functionality that any particular GAP may test. Thus if the TAP testing coverage ratio is 100 SMART may extract test cases from a GAP to test 100 of the functionality of a TAP.

A GAP utilization ratio or TAP testing coverage ratio that exceeds a pre selected ratio threshold may indicate the suitability of the GAP as a RAP for a TAP . SMART may compare the SMART ratios against the ratio threshold to determine a suitability result. SMART may report the suitability result to the operator who may determine whether to proceed with test extraction based on the suitability results. Alternatively or additionally SMART may automatically analyze one or more SMART ratios from multiple GAPs against the ratio threshold to determine one or more GAPs from which to extract tests. Accordingly SMART may use any number of GAPs to build a composite test framework see and may select a set of GAPs based on their GAP utilization ratio or TAP testing coverage ratio . As examples an operator may pre select a ratio threshold of 50 75 or 90 which may depend on whether the operator desires to extract tests from one or more GAPs or the number of GAPs available to build a comprehensive i.e. 100 coverage test framework. An operator may select different two GAPs that individually provide 100 coverage to build a composite test framework to enhance the quality of the testing.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other implementations are within the scope of the following claims.

