---

title: Trusting an unverified code image in a computing device
abstract: A method and an apparatus for configuring a key stored within a secure storage area (e.g., ROM) of a device including one of enabling and disabling the key according to a predetermined condition to execute a code image are described. The key may uniquely identify the device. The code image may be loaded from a provider satisfying a predetermined condition to set up at least one component of an operating environment of the device. Verification of the code image may be optional according to the configuration of the key. Secure execution of an unverified code image may be based on a configuration that disables the key.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291480&OS=08291480&RS=08291480
owner: Apple Inc.
number: 08291480
owner_city: Cupertino
owner_country: US
publication_date: 20070107
---
The present invention relates generally to electronic security. More particularly this invention relates to securely executing an unverified code image in a computing device.

As more and more computing devices are being used in people s daily life security has become a widespread concern for users and content providers. Viruses worms Trojan horses identity theft software and media content piracy and extortion using threats of data destruction are rampant. Usually these attacks involve installing and executing malicious software codes to expose access to device resources that would otherwise be private to the system the content provider the user or an application.

For example a hacker program when running in consumer computing devices developed to play audio video content such as Hollywood movies or music could potentially allow the cracking of the encryption used to secure the A V content. Therefore high levels of security are usually required for such devices.

An operating system may provide some security features to guard against such attacks. However the security features of an operating system often fail to keep up wit new attacks occurring on a daily basis. Moreover when booting a computing device security features may not yet be initialized and are vulnerable to bypass and or tampering.

Another way to guard against these attacks is to completely seal a computing device from installing and or running any additional software after shipped out from manufacturers. Such a strict measure however severely limits the capabilities and the flexibilities of the underlying computing device. Not only does it make upgrading a computing device costly and difficult it is not able to take advantage of increasing number of applications which do require downloading and running software codes from outside the device. In addition the rapid technology advancement usually renders the applications or functionalities originally built inside a computing device obsolete within a very short period of time.

Therefore current security measures do not deliver a robust solution to protect applications and content inside a computing device while at the same time providing the flexibility to update the software and or firmware for the device.

An embodiment of the present invention includes a method and apparatus that configure a key stored within a secure storage area e.g. ROM of a device including one of enabling and disabling the key according to a predetermined condition to execute a code image. The key may uniquely identify the device. The code image may be loaded from a provider satisfying a predetermined condition to set up at least one component of an operating environment of the device. Verification of the code image may be optional according to the configuration of the key. Secure execution of an unverified code image may be based on a configuration that disables the key.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.

A method and an apparatus for secure booting of a computing device are described herein. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

The term host and the term device are intended to refer generally to data processing systems rather than specifically to a particular form factor for the host versus a form factor for the device.

In one embodiment secure booting a device may be designed to ensure critical resources within the device will be protected in an operating environment. In the mean time secure booting a device may provide a flexibility to allow software running inside the device to be updated and installed under different policies and procedures without requiring unnecessary management material and or performance costs. In one embodiment the security of booting a device may be performed by the code and data stored inside a secure storage area such as a ROM Read Only Memory also referred to as a secure ROM integrated together within the device. The content of a secure ROM may he stored during a manufacturing stage of the device. The secure ROM may he associated with a UID Unique Identifier of the device which uniquely identifies the device. A trust of a software code running in the device may be rooted from a code image signed through the secure ROM based on the UID.

According to one embodiment the secure ROM of a device may include a fingerprint of a root certificate of a trusted entity. A code image certified through the trusted entity may be trusted to be executed in the device according to a certification process via the secure ROM based on the fingerprint. In one embodiment secure booting the device may recover trusted software codes when coupled with the trusted entity according to the secure ROM. The secure ROM may extend a trust to a code image certified through the fingerprint based on the device UID stored. In one embodiment the secure ROM may allow application software restoration by certifying a code image downloaded from an external connection. In another embodiment the secure ROM may force cleaning up user data stored inside the device by a trusted software code downloaded through external connection.

In one embodiment codes may cause loading a code image into a device memory such as memory component or RAM . A code image may be loaded from a storage component coupled with the chip . The storage component may be a flash memory such as a NAND flash a NOR flash or other mass storage e.g. hard disk components. In another embodiment a code image may he loaded though a connection interface from a source external to the device. The connection interface may be based on a US B connection an Ethernet connection or a wireless network connection e.g. IEEE 802.1x etc. In one embodiment codes may cause storing a code image from a device memory into the storage component after verifying the code image includes only trusted codes.

Before the device may start executing the code image loaded in the device memory codes may perform verification operations on the loaded code image to ensure the code image could be trusted. In one embodiment codes may verify a loaded code image according to data included in the chip such as the data section inside the ROM a UID and or a GID Global Identifier . UIDs may be unique for each device. In one embodiment all devices are associated with a single GID . In one embodiment a GID may be used to encrypt a code image to prevent code inspection. Data section of the ROM may store a fingerprint based on a signature from a trusted entity such as a public key certificate. In one embodiment separate devices may include fingerprints based on the same trusted entity.

Code image iBoot according to one embodiment may be loaded into memory component from storage based on code image iBoot according to execution of LLB . Code image iBoot may cause hardware initialization for an operating system that provides an operating environment for the device housing system . A device may enter an operating environment after a successful booting. An operating environment may support various user and or system applications running in the device. In one embodiment code image iBoot may enable mass storage components of the device initialize graphic components for user interface and or activate screen components for the device etc. Code image iBoot may be stored from RAM based on code image iBoot via execution of code image LLB .

In one embodiment code image Kernelcache may be loaded from storage to memory based on code image Kernelcache . Code image Kernelcache may be part of the kernel of an operating system to support the operating environment for the device. In one embodiment code image Kernelcache causes a kernel and operating system components to be loaded into memory from storage . Operating system components may include user applications libraries graphic user interface components and or user data . User data may include music images videos or other digital content associated with a user of the device. For example such user data may be DRM digital rights management compliant data having restricted usages. Code image Kernelcache may enable loading the kernel and the operating system components into memory . In one embodiment code image Kernelcache may cause a verification process to ensure the kernel is trusted before being executed in memory . In another embodiment code image Kernelcache may cause a verification process to ensure an operating system component is trusted before being executed in memory . Code image Kernelcache may be executed to determine an operating system component is trusted based on UID or fingerprints . In one embodiment code image Kernelcache may cause decryption of an operation system component in memory according to GID . In one embodiment code image Kernelcache may be executed to store operating system components from memory into storage . Code image Kernelcache may enable encrypting operating system components before being stored in the storage .

In one embodiment UID may be accessible to some operating system components running in a privileged mode. The kernel of the operating system may deny or approve an application to access UID by an application depending on whether the application is running in a privileged mode. In one embodiment the kernel of the operating system may determine whether an application can be run in a privileged mode based on whether the corresponding code image of the application includes a properly signed signature. A DRM Digital Right Management system may be running in a privileged mode to control access to user data of the operating system components based on UID . An application may access user data through a DRM system. In some embodiments network utilities of the operation system may be privileged. Network utilities may enable the device to interconnect with outside resources though an interface chip such as base band chip. In another embodiment virus protection software may be provided by the operating system to run in a privileged mode.

Thus any software components that will be running within the system must be verified or authenticated prior to the execution unless the software components satisfy certain predetermined conditions e.g. provided by a trust vendor or during certain circumstances such as manufacturing of the device or testing of the software components . In one embodiment the settings of a secure storage area in the system may be associated with a predetermined condition. As a result any data such as DRM compliant data would not be accessed or compromised without proper verification or authentication.

At block according to one embodiment the processing logic of process may verify whether the loaded code image could be trusted based on a UID associated with the device such as UID of . The processing logic of process may extract a header value from the code image. The location of the header value inside the code image may be predetermined. In one embodiment the header value may be extracted based on a preset attribute in an attribute value pair inside the code image. The header value may include a signature value signed over the code image according to the UID of the device through well known hashing and encryption algorithms. In one embodiment the processing logic of process derives another signature value from the code image according to the UID through the same well known hashing and encryption algorithms at block . The processing logic of process may compare the derived signature value and the extracted signature value to verify whether the code image is trusted. In one embodiment the verification may be successful if the derived signature value and the extracted signature match with each other. Otherwise the verification may fail. If the verification is not successful the processing logic of process may cause the device to enter a DFU mode at block . In one embodiment the processing logic of process may remove the code image from the memory before the device enters the DFU mode at block .

If the verification is successful the processing logic of process may execute the code image at block . In one embodiment the code image may be an LLB an iBoot or a Kernelcache as shown in and in . The processing logic of process may perform booting operations for the device at block . Booting operations may include product identifications starting device power management enabling mass storage components initializing graphic components for user interface activating screen components and or device hardware initialization etc. In one embodiment booting operations may include loading an operating system to the memory including a kernel and certain operating system components such as shown in of . The processing logic of process may attach a trust indicator to a trusted code image in the memory to indicate a successful verification. In one embodiment a code image associated with a trust indicator located in a memory may be executed as a trusted code without verification. At block the processing logic of process may determine if the device is completely booted. If the device is completed booted the device may become operational and enter a normal operational mode at block . In one embodiment a Kernelcache may start a user application running in a user mode after the device enters a normal operation. An application running in a user mode may not access device hardware related information such as UID and GID of . The device may enter a DFU mode if a booting operation fails at block .

At block according to one embodiment the booting process may continue when the processing logic of process determines the device booting process is not complete at block . The processing logic of process may locate another code image at block based on executing the current code image. In one embodiment executing code image LLB may locate code image iBoot as shown in . In another embodiment executing code image iBoot may locate code image Kernelcache as shown in . In some embodiments executing code image Kernelcache may locate code images including the kernel and operating system components as shown in . The processing logic of process may loop back to block to proceed on the booting process according to the result of locating the next code image at block .

According to one embodiment network may include a device coupled with a host . Device may be a media player such as for example an iPod from Apple Computer Inc. running restoring daemon application to restore operating system components from the coupled host . Device may be coupled with host through a connection interface supporting TCP IP protocols. The connection interface may be based on USB a wireless network or an Ethernet etc. In one embodiment host may be a Mac or Windows based computer running application software such as for example an iTune application from Apple Computer Inc. Host may be connected to a central server through the network such as wide area network e.g. Internet or local area network e.g. Intranet or peer to peer network . In one embodiment central server may be based on a publicly accessible web server. Alternatively server may be an Intranet or local server.

According to one embodiment at block the processing logic of process may extract a certificate accompanying the code image received in the memory of the device. The code image may be a LLB an iBoot and or a Kernelcache as shown in . The code image may be encrypted according to public key cryptography such as RSA Ralph Shamir Adelman public key cryptography. The certificate may include a key based on X.509 standard. At block the processing logic of process may verify the certificate according to the code stored in a secure ROM of the device such as code shown in . In one embodiment the processing logic of process may certify a chain of certificates to verify the extracted certificate with a root certificate as the last certificate in the chain. The processing logic of process may retrieve certificates from the connected host computer. In one embodiment the root certificate may be verified based on the fingerprint stored in a secure ROM of the device such as fingerprint as shown in . The root certificate may be issued by Apple Computer Inc. If the verification fails the processing logic of process may return the device back to DFU mode to be recovered at block .

If the certificate from the code image is successfully verified the processing logic of process may continue the recovery process at block to decrypt the code image based on the key included in the verified certificate. At block the processing logic of process may derive a hash signature from the code image based on a UID stored in a secure ROM of the device such as UID as shown in . In one embodiment the hash signature may be obtained for example according to the process as shown in . At block the processing logic of process may sign the derived signature into the code image. In one embodiment the derived signature may be signed as a header value of the code image. The processing logic of process may store the signed code image into a storage of the device at block such as for example storage shown in . In one embodiment a signed code image may be stored to repair another code image failed to be verified in the device. In one embodiment the code image may be executed before being stored into a storage of the device. In another embodiment the code image may be stored into the storage of the device after being successfully executed.

computer to perform a recovery process such as shown in . In one embodiment the device may publish a status based on state Recovery . The host computer may send a code image corresponding to the status received from the device. In one embodiment the code image may be an LLB as shown in . The device may perform a chain of certifications to verify the received code image is trusted based on a UID and a fingerprint stored inside a secure ROM of the device such as UID and fingerprints of . The chain of certifications may be performed based on a process similar to process at block in . If the code image is successfully loaded and verified in one embodiment the state of the device may be transitioned from state Recovery to state LLB through transition Load .

In one embodiment during state LLB the device may execute the verified low level boot program e.g. LLB or low level library as described above to locate another boot image such as iBoot shown in within the device. The boot image may be located and loaded into a memory component of the device during state LLB . In one embodiment the boot image may be verified to be a trusted code image according to a process such as described at block of . If the boot image is successfully located and verified state may enter state iBoot from state LLB . Otherwise according to one embodiment state may enter state Recovery as the device enters a DFU mode.

During state Recovery the device may be coupled with a host computer to perform a recovery process such as shown in . In one embodiment the device may publish a status based on state Recovery . The host computer may send a code image corresponding to the status received from the device at state Recovery . In one embodiment the code image may be an iBoot as shown in . The device may perform a chain of certifications to verify the received code image is trusted based on a UID and a fingerprint stored inside a secure ROM of the device such as UID and fingerprints of . The chain of certifications may be performed based on a process similar to process at block in . If the code image is successfully loaded and verified in one embodiment the state of the device may be transitioned from state Recovery to state Kernelcache .

During state iBoot according to one embodiment the device may execute the verified boot program to locate a kernel image such as Kernelcache shown in within the device. The kernel image may be located and loaded into a memory component of the device during state iBoot . In one embodiment the kernel image may be verified to be a trusted code image according to a process such as described at block of . If the kernel image is successfully located and verified state may enter state Kernelcache from state iBoot . Otherwise according to one embodiment state may enter state Recovery as the device enters a DFU mode.

During state Recover the device may be coupled with a host computer to perform a recovery process such as shown in . In one embodiment the device may publish a status based on state Recovery . The host computer may send a code image corresponding to the status received from the device at state Recovery . In one embodiment the code image may be a kernel image such as Kernelcache of . The device may perform a chain of certifications to verify the received code image is trusted based on a UID and a fingerprint stored inside a secure ROM of the device such as UID and fingerprints of . The chain of certifications may be performed based on a process similar to process at block in . If the code image is successfully loaded and verified in one embodiment the state of the device may be transitioned from state Recovery to state Kernelcache.

In one embodiment during state Kernelcache the device may execute a verified kernel image to locate operating system components such as in . A located operating system component may be loaded into a memory component of the device to be verified as trusted according to the execution of the verified kernel image during state Kernelcache . In one embodiment the kernel image may determine whether an operating system component is trusted according to a process such as described at block of . A privileged mode may be assigned to a trusted operating system component based on the kernel image for accessing hardware level interface of the device such as UID or GID of . An operating system component without a signed signature may be assigned a user mode privilege during state Kernelcache . In one embodiment an operating system component may not be permitted to access hardware level interface of the device. After the operation system is successfully loaded in to the memory of the device state may transition from state Kernelcache to state OS corresponding to a normal operating environment. A user application may start running in assigned user mode during state OS . In one embodiment a device at state Kernelcache may enter a DFU mode to receive a root image from a coupled host computer to restore or update operating system components for the device.

At block according to one embodiment the processing logic of process may receive boot images from the connected host computer. The boot images may include a boot loader such as LLB or iBoot as shown in . In one embodiment the boot images may include a kernel cache such as Kernelcache in . A boot image may be received based on the status published to the host computer at block . In one embodiment the boot images may be loaded into a memory component of the device such as memory of . The processing logic of process may receive a root image from the connected host computer at block . A root image may be a RAM disk based on a stripped down version of operating system for the device. In one embodiment the root image may include a restore application.

At block according to one embodiment the processing logic of process may receive a command from the connected host computer to execute a received boot image. The boot image may be a boot loader. In response the processing logic of process may verify the boot image is trusted at block . In one embodiment the processing logic of process may perform a process such as shown in to determine whether the boot image could be trusted based on a secure ROM chip such as chip in . In one embodiment the processing logic of process may verify a Kernelcache received from the connected host computer is trusted by executing a trusted boot image at block . The processing logic of process may perform a process such as shown in to determine whether the Kernelcache could be trusted based on a root certificate fingerprint stored in the device such as Fingerprints in . At block the processing logic of process may verify a restore daemon application from the root image is trusted by executing the trusted Kernelcache. In on embodiment the processing logic of process may determine the restore daemon application could be trusted by verifying the root image is a trusted code image. The processing logic of process may perform a process such as shown in to determine whether the restore daemon application included in the root image could be trusted.

At block according to one embodiment the processing logic of process may receive and execute commands calls from the host computer via the restore daemon application to perform software restoration operations. In one embodiment software restoration operations may include the partitioning and formatting of file systems of mass storage device level restoration or loading new firmware into the device. The processing logic may start the OS included in the root image to launch the restore daemon in the device. In one embodiment only the reduced portion or minimal portion of the OS is started. This daemon application may communicate with the restore software running in the connected host computer based on an XML Extensible Markup Language protocol. In one embodiment the restore daemon may allow the restore software running on the host computer to issue arbitrary commands to be executed by the device. The commands may include executing auxiliary tools included in the RAM disk and or making library calls. In one embodiment the commands may cause replacing the entire set of software stored in the mass storage and the programmable ROM of the device. At block the processing logic of process may receive a command from the connected host computer to restart the device. In response the processing logic of process may reset the device. Subsequently the device may reboot from the operating system stored in the mass storage of the device.

At block according to one embodiment the processing logic of process may receive a code images from the connected host computer. The code image may include a software package related to an updated version of an application based on the version ID from the published status received by the host computer at block . In one embodiment the code image may be loaded into a memory component of the device such as memory as shown in . At block according to one embodiment the processing logic of process may verify the code image is trusted. The processing logic of process may perform a process such as shown in to determine whether the code image could be trusted based on a fingerprint of a root certificate in a secure ROM chip such as Fingerprints in chip shown in . In one embodiment the processing logic of process may execute the verified code image to unpack files from the included software package and lay down those files inside the file system of the device at block . A file from the software package may be a new file or an updated version of an existing file for the device. The processing logic of process may perform an integrity check against a file from the software package to ensure the file is not compromised or corrupted before laying down the file into the file system of the device. In one embodiment the integrity of a file may be checked based on a signature according to a hash on the file content. At block the processing logic of process may reset the device to reboot from the operating system stored inside the device.

At block the processing logic of process may activate a programming interface to access device hardware by executing the code image. Device hardware may be accessed by reading or setting values of device hardware parameters. The processing logic may derive a hash value from the loaded code image to determine if the code image is not compromised e.g. not corrupted . The determination may be based on a comparison between the derived hash value and a header value from the code image. In one embodiment the processing logic of process may determine a UID is inactive at block . The programming interface to access device hardware may cause an execution of codes inside a secure ROM such as codes in for determining whether the UID is active or not. At block the processing logic of process continues executing the code image without accessing the device hardware. In one embodiment accessing to the device hardware may be controlled by the codes inside a secure ROM of a device based on whether the associated UID is active or not. In another embodiment user data may not be accessible when a UID is not active. Even when an unverified application is loaded and executed in a device no device hardware or user sensitive data may be compromised if the MID is not active.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s and a ROM Read Only Memory and volatile RAM and a non volatile memory . The microprocessor coupled with cache may retrieve the instructions from the memories and execute the instructions to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory.

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem an Ethernet interface or a wireless network. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

A display controller and display device provide a visual user interface for the user this digital interface may include a graphical user interface which is similar to that shown on a Macintosh computer when running OS X operating system software. The system also includes one or more wireless transceivers to communicate with another data processing system such as the system of . A wireless transceiver may be a WiFi transceiver an infrared transceiver a Bluetooth transceiver and or a wireless cellular telephony transceiver. It will be appreciated that additional components not shown may also be part of the system in certain embodiments and in certain embodiments fewer components than shown in may also be used in a data processing system.

The data processing system also includes one or more input devices which are provided to allow a user to provide input to the system. These input devices may be a keypad or a keyboard or a touch panel or a multi touch panel. The data processing system also includes an optional input output device which may be a connector for a dock. It will be appreciated that one or more buses not shown may be used to interconnect the various components as is well known in the art. The data processing system shown in may be a handheld computer or a personal digital assistant PDA or a cellular telephone with PDA like functionality or a handheld computer which includes a cellular telephone or a media player such as an iPod or devices which combine aspects or functions of these devices such as a media player combined with a PDA and a cellular telephone in one device. In other embodiments the data processing system may be a network computer or an embedded processing device within another device or other types of data processing systems which have fewer components or perhaps more components than that shown in 

At least certain embodiments of the inventions may be part of a digital media player such as a portable music and or video media player which may include a media processing system to present the media a storage device to store the media and may further include a radio frequency RF transceiver e.g. an RF transceiver for a cellular telephone coupled with an antenna system and the media processing system. In certain embodiments media stored on a remote storage device may be transmitted to the media player through the RF transceiver. The media may be for example one or more of music or other audio still pictures or motion pictures.

The portable media player may include a media selection device such as a click wheel input device on an iPod or iPod Nano media player from Apple Computer Inc. of Cupertino Calif. a touch screen input device pushbutton device movable pointing input device or other input device. The media selection device may be used to select the media stored on the storage device and or the remote storage device. The portable media player may in at least certain embodiments include a display device which is coupled to the media processing system to display titles or other indicators of media being selected through the input device and being presented either through a speaker or earphone s or on the display device or on both display device and a speaker or earphone s . Examples of a portable media player are described in published U.S. patent application numbers 2003 0095096 and 2004 0224638 both of which are incorporated herein by reference.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

