---

title: Test data management
abstract: Methods and apparatuses enable generating test content for test system from an executed transaction of an execution system. The data resulting from the execution of the transaction in the execution system is accessed and used to generate test content for a test case. The test case can include the transaction data unmodified, or the transaction data can be modified and stored as the test content. The test system executes the test case to generate a result, and the result can be compared against what is expected based on the test content.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08151247&OS=08151247&RS=08151247
owner: SAP AG
number: 08151247
owner_city: Walldorf
owner_country: DE
publication_date: 20071008
---
This application claims priority to pending Provisional Patent Application No. 60 828 764 filed on Oct. 9 2006 and entitled Adaptive Business Process Change Verification .

Embodiments of the invention relate to verifying business process changes and more particularly to business process test case composition with componentized test case building blocks.

Businesses increasingly rely on business processes to accomplish various tasks within the organization. The business software that is used to implement the business processes becomes critical to the organization. Some software e.g. SAP business software of SAP AG of Walldorf Germany allows customization and modification of the business process applications. Changes to the business processes may be made frequently e.g. quarterly in some organizations. Prior to implementing a change in the business process software the organization would ideally verify validate the change to ensure the change accomplishes what is desired and does so correctly without interruption to the normal flow of the organization. However current methods of verification of the business process changes are expensive time consuming and often require tradeoffs between reliability and cost and or time.

Currently business software is tested in one of two ways manually or via record and playback scripting. Manual testing suffers from being very time consuming and having a small scope of possible tests. The risk that an error will make its way through the testing is relatively high. The inefficiency and cost aspects to manual testing makes manual testing a generally unacceptable procedure. Automated tests are generally considered to improve quality but generating and maintaining test content is traditionally time consuming and expensive.

Test content is traditionally generated to recreate scenarios and processes that occur in normal execution of the execution system. Thus test content traditionally must be created with configuration and data inputs to simulate a real transaction. However accurately creating test content can be difficult. Where test content can be accurately created it is typically costly to generate and maintain.

Methods and apparatuses enable generating test content for test system from an executed transaction of an execution system. The data resulting from the execution of the transaction in the execution system is accessed and used to generate test content for a test case. The test case can include the transaction data unmodified or the transaction data can be modified and stored as the test content. The test system executes the test case to generate a result and the result can be compared against what is expected based on the test content.

In one embodiment the transaction data is distributed across multiple systems. In one embodiment accessing the transaction data may refer to accessing a data container that references data objects distributed across multiple systems or stored in different locations of a single system. The transaction data may be a posted document that provides parameters and results of a business process transaction associated with the transaction data.

The correct execution of the business process and correct database update of the test system is evaluated based on comparing the results of the test system with the transaction data as the test data against an expected result. The expected result may be a successful execution. In one embodiment the actual transaction data may produce an error in the execution system and a similar error may be expected in the test system. The transaction data may be modified to produce an expected error and such an error may be tested for in the test system.

Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein. An overview of embodiments of the invention is provided below followed by a more detailed description with reference to the drawings.

As provided herein a test system is able to access transaction data of an executed transaction and generate a test case from the transaction data. In contrast to traditional methods of test data creation via manual preparation of data or copying and saving data as a test data file the test suite can access posted transaction data and execute the test case with the transaction data as test data. In one embodiment the transaction data is simply identified to the test suite which may then access and use the data as test data rather than accessing a test file for example. In one embodiment the transaction data is a posted document which refers to a data container that includes an identifier and references to multiple data elements in one or more databases systems.

The posted document not only includes the data of an already executed transaction but it will also include the correct fields and formatting or semantics removing the need for creating the fields and formatting or semantics in a test case. The fields refer to separate data interface points input and or output for user consumption and or interaction within a display screen. The formatting or semantics refers to the form and content of data required for a particular system or service to be accessed in execution of the business process to be executed in the execution system or to be tested in the testing system.

The posted document may be the result of a successful transaction which would be expected to generate a successful result from the testing. Additionally the posted document may act as a starting point for test data and the posted document modified to create the test data. Furthermore the posted document could be the result of a test transaction that causes an error in the original system and would be expected to result in the same or similar error in the test system. Alternatively the test system could be designed to correct such an error and be expected to handle the transaction without error in contrast to the previous execution system and thus no error would occur on the test transaction that caused an error in the execution system .

In one embodiment the original posted document acts as a starting point for test execution data labeled as negative data. The original document that allowed the business transaction to successfully finish the transaction represents positive data and negative test data will cause the target system to fail at a defined step. With such defined negative test data the test administrator can ensure the system will respond with an error message or warning in case of incomplete or faulty data. Verifying the generation of the error message or warning can be highly important to test so called automated controls built into an ERP Enterprise Resource Planning application whether an application from SAP Oracle Corporation of Redwood Shores Calif. Negative test data ensures that the control gets activated and stops the transaction which behavior cannot be tested with positive test data. Negative test data can be generated as simply as changing one or two field values from the original posted document while leaving all other data as correct.

Productive system may also be referred to as a P system and test system may also be referred to as a T system. P system executes a system from resources accessed from an enterprise backend system. P system may also execute based on data input such as from a user or an automated source or a service. Such data resources are represented as P system data . T system may also access data from an enterprise backend and or from input from other sources and such data is represented as T system data . As described herein T system data is derived from the posted data of a business transaction executed in P system .

In one embodiment T system data can be considered to be test base content which is test data derived from data that exists within system . In one embodiment the base content represents a previously known good version or a previously tested version of a business process or application where the execution results are known. In one embodiment known bad data may be used in the test system referring to data with a known or expected error or result. Such data may be the result of a failed transaction or a modified executed transaction. As provided herein accessing and using the previous transaction data is contrasted to simply accessing electronic data to supply data for a test case. In one embodiment the data from the executed transaction is not simply accessed but linked to the test case. For example rather than pulling data and generating a list of fields to which to apply the data the data is simply linked to the test case so the test case can actively access the data itself. Thus in contrast to generating a test case by accessing data itself the test case can have one or more identifiers linked to it or associated with it which enables the test system to obtain the data for execution. Rather than pulling data for the test case from a database of records data during test execution the actual data may be accessed.

Business process BP application represents an application in which one or more business processes are executed. To support execution of an executed transaction in one embodiment BP application includes mapper with multiple read modules . Traditional BP applications are unable to recognize the data structure of the transaction data. Thus traditional applications would be unable to execute a test case having transaction data as the test data. Mapper provides the ability to recognize the data structure of the various pieces of data that represent the executed transaction results as may be provided in an executed transaction document . In one embodiment BP application includes multiple mappers each with multiple read modules one mapper for each different data type e.g. object class with read modules for the various types of methods and interfaces of the data. With mapper and read modules BP application can access the various elements of data stored in one or many systems that result from execution of P system data in P system .

When P system executes a business process with P system data the P system generates P system results from which T system data is derived. P system results may be generated throughout the execution of the associated business process or end to end application. That is data may be stored each time input is provided to P system and business logic executed to generate a result. Thus results may be stored across multiple different systems and all identified as part of a particular transaction. A data container can simultaneously be updated assuming it is already generated the data container can be generated at the beginning of the transaction or when results begin to be generated with the results data. The data container can then store a reference to the data which can be identified with an identifier associating the data with the data container. Linking the data container to a test case in T system can link all the referenced data to the test case.

Execution of the process in T system with T system data will also result in the generation of test results as depicted by T system results . T system results will typically be stored in a different database from P system results . Databases and represent one or more databases that are part of enterprise system . In one embodiment test results are stored in a separate virtual system from P system results. Thus the results of the T system execution execution of the test case may be stored on the same or separate hardware systems as the P system results as well as the same or separate logical systems as the P system results.

As illustrated any number of transactions may be performed in P system . Depending of the size and operation of the company the number of transactions may be dozens or even thousands per day. In one embodiment each transaction result is stored in one or more backend systems . Each transaction result is depicted as a posted document doc such as . As illustrated each posted doc is a data container that is stored in a particular backend system although the underlying data that is part of the transaction results may be stored in any of a number of backend systems. Thus posted doc for example may reference data stored in any of backend systems .

Each backend system may include a system identifier ID which represents a unique identifier within system for the backend system. In one embodiment each posted document may be located with reference to the system ID and the posted document ID for the document. For example posted document may be identifiable by reference to system ID e.g. CRM ID customer relationship management identifier and the ID associated with posted document e.g. CRM DOC  . Linking the posted documents may be performed by referencing the system and document IDs for the desired transaction data. Such information may be provided by a user or administrator who is configuring the test system.

As illustrated posted document is shown expanded having document ID such as CRM DOC  and data references . Data references can point to any system storage database etc. within the enterprise. As shown data reference points to object of database DB data reference references object of database and data reference references object of database . Such is meant only as an example and any number of associations may be created.

Posted document is the result of execution of a transaction in P system and which can be referenced within T system to link the document into the test case. By linking in the test case the data itself may be accessible to the test system.

Data mapper of business process application represents logic that is able to interpret the semantics of particular data types. Data mapper includes read modules which represent an arbitrary number of read modules that provide data access and manipulation functionality to data mapper . In one embodiment the read modules include interfaces such as agent interfaces or application programming interfaces APIs that can send requests and receive information from a particular data element. Note the implementation of the data mapper and associated read modules is significantly different than what is previously known. In previous systems the business process application would simply be passive and receive data that already included the correct semantics. As depicted the business process application is able to execute the test case by accessing the appropriate data and interpreting the data via the read modules for use in the test case transaction.

Business process application also includes business logic which represents the business logic associated with the business process application. Business logic enables business process application to perform operations on the data including the execution of algorithms the calling of methods and routines the invoking of interfaces etc. Business logic allows the manipulation and use of data to achieve a business result e.g. in one simple example consider receiving an input value representing an order for a particular identified part number and creating a purchase order PO for the input .

System includes test environment which represents a test suite or one or more components of a test suite that enables the execution of tests on business process application . Note that in one embodiment business process application exists as a logical entity and not as a particular defined software application to be loaded and executed. That is an application as used herein may refer to an access program e.g. a browser that has a defined flow of logic from one phase or function to another which may execute a particular business process. Thus test environment may provide test data and a test flow which represents the flow of a transaction to be tested.

Test environment may include test generator which represents one or more functional modules that accesses transaction data e.g. via a transaction data container to provide previous transaction data as test data to data receiver of business process application . Test generator may generate data request which requests the transaction data identified by whatever identifiers are required in the system such as document ID and system ID. Execution environment represents the management of the execution system including management of the results data generated in execution of a transaction. Thus transaction data represents the data created via execution of the transaction in a business transaction. In one embodiment transaction data is linked as part of a test case which then includes the transaction data as data available for execution in a test system.

Processor represents one or more processing elements including general purpose processors and or specialized hardware microprocessor or microcontrollers. Processor may also represent multi core and virtual machine technologies that can be employed within the enterprise. Memory represents generally volatile storage of instructions and data for execution by processor . Data interfaces represent agent and APIs that provide access to data. Data interfaces may also include the physical interconnects and support logic used to communicate with other systems to access data. Storage represents non volatile storage i.e. the data values are retained despite an interruption of power to the storage device . Program code and management logic may be included within storage .

System includes test generator which includes test data manager . Test data manager is an abstraction of logic and functional modules that provide the functionality to test data manager . Such logic may be included within a single component or may be distributed over various components. For example system ID module enables test data manager to identify and locate a system where transaction data is stored. The particular system identified is the system that stores the data or data container for transaction data that will be referenced in a test case created by test generator . System ID module may include user interface components e.g. a prompt or an input field box etc. to allow a user to specify transaction data to be used as test data.

Document ID module enables test data manager to identify and locate particular transaction data resulting from execution of a transaction in the productive system. In one embodiment the document is identified by a user and the test system is able to locate an associated system via a location mechanism e.g. a search a query system a lookup table etc. available within system . In one embodiment a user specifies both the document and the system. Note that the document ID can be a unique identifier for the entire enterprise system e.g. a GUID global unique identifier or may be an identifier unique within a particular system.

In one embodiment test data manager includes data modifier which enables test data manager to modify execution data prior to providing the test case for execution. In one embodiment modifications are recorded in a file description table or data structure that is included within the test case. Thus the test case may include test specifics based on changes made to linked or referenced data. In another embodiment modifications are stored in a separate file or data structure and linked into the test case. Thus changes data can be accessed as execution data is accessed. In one embodiment a copy of a data container representing the transaction data is made with changes made to the data container. For example one or more of the transaction results may be replaced with different data stored in a system and referenced in the copied test transaction data copy. In such an implementation the test data may be an exact copy of the transaction results data or a modified version or otherwise based on or derived from the transaction data. Other methods of changing the transaction data for use in the test system may be employed.

In one embodiment changes to accessed execution data are performed manually by a user. That is one or more aspects of the data are changed by manipulation of the data such as in a test development environment. The modified data can then be stored as the test data. In one embodiment accessed execution data can be modified automatically from the test suite via business logic built into the test suite. Thus the test system can be created to automatically make a change to test data upon a particular input by the user or when accessed execution data has a particular property.

In one embodiment test generator includes script generator which may generate a test script that is derived from the flow of the transaction data. Note that it may not be necessary in all cases to generate a test script when using the transaction data. For example the transaction data may act as a flow manager for a test transaction which may require in test processing of data to determine what operation to perform next. Alternatively the flow of the transaction can be extracted and generated for the test case which can then call the data as needed to provide configuration and input parameters for execution the test case. Other than the details provided herein script generation in test systems is known and will not be discussed in detail.

Various components described herein may be a means for performing the functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc. Software content e.g. data instructions configuration may be provided via an article of manufacture including a machine readable medium which provides content that represents instructions that can be executed. The content may result in a machine performing various functions operations described herein. A machine readable storage medium includes any mechanism that provides i.e. stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . The content may be directly executable object or executable form source code or difference code delta or patch code . A machine readable medium may also include a storage or database from which content can be downloaded. A machine readable medium may also include a device or product having content stored thereon at a time of sale or delivery.

Within an enterprise a worker executes a transaction in a productive system as part of the course of business. In one embodiment part of the execution of the transaction is the posting of transaction data which represents the transaction and its parameters. The transaction data includes all necessary fields and is already formatted according to the proper semantics for use in a system. The transaction data also reflects actual data values within the proper parameters of the system which need not be further verified or changed if the desired result is to produce the result in the test system that was generated in the productive system.

Either the same or a different user generally a different user such as an administrator or quality assurance QA expert initiates the test system and triggers test data creation . Initiating the test system may include providing an indication of backend systems to enable the test system to discover the systems for later data access. In one embodiment initiating the test system refers to instantiating a test from a test class. Triggering the test data creation may be part of initiating the system it requires data to execute.

The system via indication from the user identifies one or more executed transactions and associated posted data documents for the transactions . The user identifies the posted data documents by a reference identifier. Note that thousands of P system documents are likely to exist in a real world implementation of the systems described herein. The ability to search the system via reference number of the posted data documents enables the user e.g. QA expert to efficiently locate appropriate P system documents suitable for use as test execution data. In one embodiment the search capability provides complex search support allowing a user to provide key word concept searches that will identify any of multiple posted documents that may be suitable as test data. Thus the test system can provide a mechanism for a user to generate an input query and perform a search based on the query. The search results e.g. a list can then be presented to a user who selects the appropriate posted data documents.

Whether selected manually or with assistance from a search query the test system can then access test transaction data . Note that actual access of the data may not occur until execution of the test. However in one embodiment data can be presented to a user for review prior to using the data for testing purposes. In such a case the system may determine via the user whether to modify the transaction data for testing . If data does not need to be accessed at this point the system may be configured to not access any data and wait until data is requested for a test execution scenario. If the decision is to not modify the data the system saves the transaction data as the test data . As discussed above there may not be any actual data access at such a point in time. Saving the transaction data may refer merely to the system referencing the data within its test case and need not imply accessing and storing actual data values.

If data is to be modified the relevant portion s of the transaction data are changed within the test environment . The changes can be saved according to any mechanism described above or other mechanisms not listed with the unchanged data base content . The entirety of the base content and the changes is the test data for the test system. Whether or not the data is modified the test suite provides the test data to the test system which executes the test data in the test system to evaluate or determine a performance of the test system . In one embodiment the test system is expected to behave identically to the execution system. In one embodiment the test system results are expected to vary from the transaction data results in certain ways. All results expectations can be programmed into the test system for evaluation of the test performance. Also comparing results to expectations can be performed manually.

The evaluation includes determining whether errors results from execution of the test data . The evaluation also includes determining whether or not errors were expected . Thus if errors were not expected but resulted from execution of the test case the test system may be considered to have failed the test. If error were expected but did not result such performance may also represent a failure of the test system. Thus performance should match expectations for a successful end result of the target test system.

Besides what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

