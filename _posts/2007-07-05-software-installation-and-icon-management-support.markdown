---

title: Software installation and icon management support
abstract: Methods, systems, and apparatus, including medium-encoded computer program products, for software installation and icon management support. In one aspect, a method includes obtaining a cross-platform package of information stored in a platform independent format, the cross-platform package information including a cross-platform icon and one or more descriptors for the cross-platform icon; translating the cross-platform icon to a predefined icon format for a specific operating system (OS) on a computer; and providing the translated icon in the predefined icon format for display by the OS on the computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08136100&OS=08136100&RS=08136100
owner: Adobe Systems Incorporated
number: 08136100
owner_city: San Jose
owner_country: US
publication_date: 20070705
---
This application is a continuation in part application of and claims the benefit of priority to U.S. application Ser. No. 11 512 764 entitled SOFTWARE INSTALLATION AND SUPPORT to O. Goldman et al. filed Aug. 29 2006 and this application is related to U.S. patent application Ser. No. 11 773 890 entitled SOFTWARE INSTALLATION AND PROCESS MANAGEMENT SUPPORT to E. Malasky et al. filed on the same day as the present application.

The present disclosure relates to software installation and icon management support on a computer platform. A computer platform is a computer including a particular operating system OS for that computer e.g. W OS M OS or L OS . Software developers often create source code that can be appropriately compiled for respective computer platforms and then independently generate native installation packages for each target platform. Each native installation package is associated with a specific computer platform and these native installation packages can then be distributed for installation on appropriate machines. For a particular target platform the appropriate native installation package is obtained from the software developer and an OS installer can be used to process the native installation package in order to install the application. For example I software can be used to produce an .msi file for installation on W machines and a different software tool can be used to produce .pkg files for installation on M machines.

In order to facilitate this process of generating native installation packages for distribution some software developers have used a common specification of the installer package for different platforms. This common specification can then be used to create each respective platform specific installation package where the common specification indicates information such as which source files and which compiler to use for different target platforms. In any event the distributor of the desktop application distributes different installation packages for different target platforms and the customer generally must ensure when acquiring a software application that they are purchasing the correct installation package for their system.

Other software developers have created cross platform installation packages such as the J Archive JAR file format that get deployed to the end user system. The cross platform package can then be expanded e.g. decrypted and uncompressed and written directly to disk using code provided by the software developer and or the developer of the cross platform package format. Typically such cross platform software relies on a virtual machine such as the J Virtual Machine JVM available from Sun Microsystems Inc. to run on the target platform.

The JVM provides a runtime environment and Java interpreter for most operating systems including W OS M OS AND L OS. Java source code files files with a .java extension are compiled into a format called bytecode files with a .class extension which can then be executed by a Java interpreter. Bytecode can be converted directly into machine language instructions by a just in time compiler JIT .

Flash Player available from Adobe Systems Incorporated is another virtual machine which is used to run or parse Flash files including ActionScript or Shockwave Flash SWF . The Flash Player and Flash Authoring software allow development of projectors self running SWF movies that run on a specific target platform by embedding the SWF data in the Flash Player executable to create a new .exe file and manipulating a byte pattern in the .exe file to indicate the presence of the SWF data. Such projectors can then be distributed for use on the target platform.

This specification describes technologies relating to software installation and icon management support. In general one or more aspects of the subject matter described in this specification can be embodied in one or more methods that include obtaining a cross platform package of information stored in a platform independent format the cross platform package information including a cross platform icon and one or more descriptors for the cross platform icon translating the cross platform icon to a predefined icon format for a specific operating system OS on a computer and providing the translated icon in the predefined icon format for display by the OS on the computer. Other embodiments of this aspect include corresponding systems apparatus and computer program products. For example other embodiments can be implemented in various types of computers that include one or more user interface devices such as a personal computer or a mobile computing device.

These and other embodiments can optionally include one or more of the following features. The obtaining the translating and the providing can be performed at runtime to dynamically create icons for the software application. This can be done by a virtual machine including a collection of utility functions configured to support a software application while the software application is running on the computer. Moreover the translating and the providing can include using an application programming interface API of the OS to define the translated icon in the predefined icon format for use by the OS to change icon representation of the software application to indicate status of the software application while running.

The translating can include checking the one or more descriptors for the cross platform icon with respect to icon features of the specific OS and modifying images in the cross platform icon based on the checking. The checking can include checking image sizes color depth and transparency encoding. The translating can include writing a header for the translated icon writing a descriptor block containing size and color depth information for each of the images for the translated icon writing color data for each of the images for the translated icon and writing a transparency mask for each of the images for the translated icon. In addition the images can include vector graphics and the modifying can include rasterizing the vector graphics.

Particular embodiments of the subject matter described in this specification can be implemented to realize one or more of the following advantages. Software applications can be developed using a cross platform code format such as SWF and such applications can then be installed on a computer platform and function within the OS user interface as a normal desktop application e.g. with a separate non generic icon for program launch and a presence in OS utilities interfaces . The application can thus operate as a native application allowing a developer to customize the application name and icon such that when a task list is observed an instance of the customized application executable is observed rather than a generic instance of the runtime on which the applications depends.

Cross platform applications that run in an application execution environment which sits on top of the operating system of a computer can be provided full support for process independence within the operating system. Each instance of a cross platform application can be viewed and managed through the operating system as a distinct application process including application information e.g. application name and application icon that is specific to the cross platform application rather than the application execution environment in which it operates. Moreover various OS process management tools can be readily used such as those used to inspect and track the resources used by a given instance of an application or to manage the priority of the application s process relative to other applications.

Moreover the icon customization support can be provided to cross platform applications both at the time of installation and while the application is running after installation. A cross platform software application can provide e.g. in its installation package icon images in a format different from that used on the target platform and a runtime environment can provide icon conversion facilities to the application to translate icons into platform specific icon formats. This icon management support can also be used to dynamically create new icons as the application is running again from image formats that need not be used on the target platform. Thus both static and dynamic icons can be made cross platform for the application developers who need not know the details of how a particular operating system handles icons.

The application executable can be built from template s included with the runtime. The runtime can include template executable files for multiple different computer platforms and can include directions to install new applications by reading relevant data for an application to populate an appropriate template executable for a platform to make the executable operate as desired and to place the new application executable into the appropriate install directory with appropriate renaming based on the application s metadata on the target platform. Thus an application developer can program the application entirely in the cross platform code format e.g. SWF and need not create multiple versions of the application s installation package for different computer platforms.

A software publisher need only create a single installation package that is suitable for all target platforms. The customer need only obtain a single installation package and need not check whether the installation package matches their platform. By converting a cross platform installation package into a native installation package which can be installed using the native installer the installation sequence can leverage all available native installation features. A cross platform installation package can be converted into a platform specific package on the fly in an installation engine. Thus a single installation package can be used to distribute and install an application on multiple different computer platforms e.g. both Windows and Mac OS systems and a cross platform application can be installed and function as a normal desktop application even though dependent on a non OS runtime environment.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims.

In the example system a single cross platform installation package can be used to install an application on multiple different platforms. A user such as an end user or administrator can obtain the cross platform installation package from a distributor to create a native installation package corresponding to a target computer . The native installation package can be used to install the application on the target computer. In some cases native installation packages can be generated using the cross platform installation package for computers other than the generating computer the native installation packages can be created for computers some of which can have the same platform as the generating computer and some of which can have different platform s than the generating computer .

The distributor makes a cross platform installation package available. The distributor can be a software developer publisher reseller or other entity which distributes software. The distributor makes available a cross platform installation package which includes source materials that are used for installing the application. The source materials can be source code machine code libraries data documentation configuration information icons or any other resource that can be used by an application or installation procedure. Portions of the source materials can be platform dependent or independent for example in a web browsing application code for handling bookmarks may be the same across all computer platforms while code for handling copying and pasting may be platform dependent. In another example configuration files for different platforms can be included. Although the source materials can be targeted to multiple platforms a single cross platform package can be created which can be used to install the application on any of the supported platforms.

The user can obtain the cross platform installation package from the distributor . The cross platform installation package can be distributed on physical media such as Compact Discs CDs Digital Versatile Discs DVDs floppy disks etc. via networks such as Local Area Networks LANs the Internet peer to peer links wireless networks etc. by being preinstalled on computer equipment such as hard drives flash drives portable music players etc. or any other technique that can be used to deliver digital content. In addition the cross platform installation package can be included in a data file for the application. Thus the data file for an application can include an installable copy of the application itself.

When such a data file is to be opened the data file can first be handled by enabling software separate from the application such as the virtual machine transcoder and or runtime library described further below. This enabling software checks whether the application has already been installed and if not installs the application using the techniques described herein. In either event installation or confirmation of previous install the application is then provided with access to the original data installation file for further processing in accordance with the functions provided by the application.

A native installation package can be created from the cross platform installation package . In some implementations the user can create the native installation package by double clicking on an icon representing the cross platform installation package to open it for transcoding. As used herein the term transcoding refers to a process of converting a cross platform installation package into a native installation package. A transcoding program can run on the user s computer and use the included source materials to generate the native installation package specific to the platform of the target computer . In some cases a native installation package can be generated for a different target computer with a platform different than the platform of the generating computer . In such cases the transcoder can be designed to generate native installation packages for multiple platforms. In some implementations several different transcoders can be used where each transcoder generates a native installation package for a given platform. In some implementations a transcoder can be run on multiple platforms by being written in a cross platform language such as Java or Shockwave Flash SWF .

The user can install the application using the native installation package generated from the cross platform installation package . The native installation package uses the native operating system installer to install the application this enables use of the installation procedures that are native to the platform. Maintenance performed on the target computer e.g. setup reinstallation removal etc. can be done using the utilities native to the OS. In some implementations execution of the native installation package can be initiated automatically after generation of the native installation package. In other words the same action that initiates creation of the native installation package such as a double click on an icon can also initiate the execution of the native installation package when generation is complete.

Users can create native installation packages for other computers. Native installation packages can be generated for computer platforms that are different than the platform used to create the native installation package. For example a computer running a Windows operating system available from Microsoft Corporation could generate a native installation package for a Mac OS operating system available from Apple Computer Inc. or vice versa. The same cross platform installation package can be used to create native installation packages for multiple different computers. For example an administrator can create native installation packages on a single computer running a Windows operating system to install an application on a laptop running a Mac OS operating system multiple desktop PCs running a Windows operating system and a cluster of servers running a Linux operating system an open source operating system developed by Linus Torvalds et. al. . In some instances a user can create multiple different native installation packages to install an application on a single computer that is capable of running multiple operating systems such as a Windows operating system or Linux operating system by booting off different disk partitions or running virtualization software.

As an example an administrator who uses a computer running a Windows operating system can obtain from a software distributor a CD ROM which includes a cross platform installation package for an image editing tool. If not already present the administrator can install an appropriate transcoder from the CD ROM to generate a native installation package corresponding to his or her computer. The administrator can choose to have the transcoder initiate installation using the native installation package once this package is finished generating causing the image editing tool to be installed on the computer using the installer native to the Window OS. As an alternative the administrator can choose to have the transcoder only generate the native installation package which can then be processed by the native installer at a later time such as when a user clicks on a single icon representing the generated native installation package i.e. the install file generated by the transcoder .

Continuing the above example the administrator can evaluate the image editing application and can choose to deploy the application throughout the company. If needed the administrator can install transcoders onto his or her computer via the Internet or from the CD ROM as needed to generate native installation packages for a Mac OS operating system and a Linux operating system. In some implementations a single transcoder can support generating native installation packages for multiple different target computers. The administrator can use the transcoder s to generate native installation packages for a Mac OS operating system and Linux from the cross platform installation package. Generation of a package for a Windows operating system may not be needed since this was generated for the installation on the administrator s computer prior to evaluation in this example. The administrator can then make the Mac OS installation package and Windows installation package available on a LAN for users in his or her organization. User A downloads the Mac OS native installation package and installs on his or her laptop. Users B and C download the Windows native installation package and install the application on their desktops. The administrator can also transfer the Linux native installation package to the server cluster and install the application on each server.

A cross platform package can include package information and program content . A virtual machine which can be located on the target computer or another computer can include the transcoder which creates a native installation package using the package information and the program content from the cross platform package . A native operating system installer can use the native installation package to install a platform specific application on a target computer.

The package information describes the content of the cross platform package . The cross platform package can include instructions related to generating native operating system installers. The package information can include information useable in an installation sequence which can be stored in eXtensible Markup Language XML or other platform independent format. For example the cross platform installation package can be stored as a compressed and or encrypted file e.g. a Zip file and the package information can be stored in an XML file included within the compressed and encrypted file. This XML file can contain information used by the transcoder such as the application name the application version publisher name an icon for the application e.g. in .png format a default installation directory file extensions registered by the application and Multipurpose Internet Mail Extensions MIME content types registered by the application. Moreover this XML file can contain one or more references to the information used by the transcoder rather than the actual data itself in which case these reference s also constitute information useable in an installation sequence. In general the package information can include a description of all the items an installation sequence uses but abstracted away from platform specific notions.

The program content in the cross platform package can include source code object code configuration files icons libraries documentation etc. In some implementations some source material for creating the native installation package can be pulled from a remote source over a network connection. In some implementations some source material for creating the native installation package can already be present on the target computer or in the transcoder . In some implementations the cross platform package can include transcoders for multiple different platforms so that the user can find all the required elements to begin installation already present regardless of which type of platform is used for a target.

In general the program content can include first second and third sets A B C of information. The first set A includes the information that is copied by the transcoder directly from the cross platform package to the native package without any modifications. For example this program content can be interpreted code that relies on a runtime library to operate such as SWF. The second set B includes the information that is modified by the transcoder during conversion from the cross platform package to the native package . For example this program content can include an application icon stored in Portable Network Graphics PNG format which can be translated into the Windows Icon format ICO for a Windows platform. The third set C includes any information that is specific to a first platform and thus need not be added to the native package when generated for a second different platform although such information may be included in the package and just not used on the second platform .

The transcoder can be included with a virtual machine . The virtual machine is a runtime environment that provides software services for processes or programs while a computer is running. The virtual machine includes the runtime library which is a collection of utility functions that support a program while it is running often working with the OS to provide facilities. It should be appreciated that the runtime library and the virtual machine can be considered one and the same in some implementations. The virtual machine can be client based software that runs Flash applications supports vector and raster graphics bidirectional streaming of audio and video and one or more scripting languages e.g. ActionScript . Moreover the virtual machine can deeply integrate Flash applications with the OS providing services such as file system access multiple windows running in the background etc. Inclusion of the transcoder with the virtual machine can be implemented by building the transcoder s functionality directly into the virtual machine or by simply associating the transcoder with the virtual machine such that they are delivered as a package together.

Moreover the transcoder can be a stand alone program e.g. a platform specific program in native machine code interpreted and or partially compiled code that relies on the runtime library to operate e.g. SWF code or a combination of these. The transcoder can include program content e.g. a Flex script Flash file etc. that when compiled and or interpreted creates code to provide functionality to the transcoder . For example the transcoder can include program content that provides a presentation layer for the transcoder during the installation process. This program content can be in the form of SWF containing code video images etc. e.g. SWF generated from another tool or language such as Flex or it can be in another form.

The program content can be compiled and or interpreted using the runtime library to create a SWF file that can access information from a to be installed application such as the package information in the cross platform package . During installation of an application the SWF file can run as a movie providing an install user interface UI . This install UI can include user input controls to affect the installation process e.g. full install to the current platform or target install to create a specified target native installation package and the install UI can present ongoing install process updates e.g. a progress bar generated from communications received by UI from the OS installation mechanism . Moreover this Flash movie install UI can run through the native OS installer process for a full install and mask the user interface of the OS installer while the transcoder controls the installation through the native OS installer to generate the final OS integrated and installed platform specific application .

Note that while the install UI masks the native OS install UI the look and feel of the new install UI can be made to match that of a native OS installer UI. The UI can dynamically present an appearance that matches the native OS installer UI of the target platform. Thus the UI can appear to be a Mac OS install UI when the transcoder generates the application for a Mac target even while running on a Windows computer.

A user can obtain and install the transcoder and or virtual machine for installing a first application then subsequently reuse the transcoder and or virtual machine for installation and or application support. The transcoder and virtual machine can be made available for multiple different platforms e.g. different platform specific versions of the transcoder and virtual machine can be freely distributed such as over a public network or by pre installation on computer equipment prior to sale . If the transcoder and or virtual machine are not already present on a given machine they can be included with the cross platform package as well. In some implementations the transcoder can run natively on a generating computer without requiring a virtual machine. In some implementations use of a virtual machine can increase portability of a transcoder by reducing the number of transcoders developed for generating native OS installation packages. In some implementations the transcoder can have the ability to generate multiple native installation packages for different target platforms.

Moreover the transcoder can be pre installed and include a copy of the runtime library and the transcoder can add the runtime library to the native installation package so that the runtime library is installed on the target computer along with the application . The runtime library can be bound to the application i.e. a dedicated copy of the library which only the application can use or the runtime library can be simply bundled with the application i.e. the library is installed along with the application but is then available for other applications on the target computer .

The transcoder can generate a native installation package using the cross platform package . The transcoder can use the package information and program content included in the cross platform package to generate the native installation package . Some of the program content can be platform specific such as hardware drivers used for a specific peripheral device. In some implementations the transcoder can use preexisting components from the OS such as Dynamic Link Libraries DLLs or other installed components. In some implementations the transcoder can use components included with the virtual machine . The transcoder can use multiple template executables and one or more template installation packages to create the native installation package as described in more detail below.

When generation of the native package is complete the transcoder or the virtual machine can initiate the native operating system installer . In some implementations the native operating system installer can be automatically invoked when generation is complete. In some implementations the user can choose to manually execute the native installation package at a later time or transfer the native installation package to another computer.

The target computer s native operating system installer can be used to install the application in a fashion that is natural for the platform. For example computers running a Windows operating system can use an .msi file to control application installations a native operating system user interface can be used to perform maintenance functions on an application installed using an .msi file such as reinstalling adding components to or removing the application.

After installation the installed platform specific application can be used. The conversion to the native installation package and use of the native operating system installer to perform application setup can result in the application being tightly integrated with the OS even when the new logic for the new application is written in cross platform interpreted code such as Flash code and the new application relies on the runtime library to operate. For example menu icons can be appropriately placed in program groups or on desktops local settings can be used and icons which are appropriate for the target system can be used.

In some cases applications can be linked to other components. In some implementations the transcoder can construct the native installation package in such a manner so that the native operating system installer creates an application startup icon that initiates linked resources such as the runtime library when the application is started. In some implementations the instance of the runtime library can be dedicated to supporting the application . In some implementations the application can share an instance of the runtime library with other applications.

The generation process creates the native installation package in a format specific to the target platform e.g. .msi file for a Windows operating system. Since the installation process uses the platform s native installer the installation process can proceed as though the cross platform installation package was developed specifically for that target i.e. installation and maintenance follows the native operating system installation procedure s the user is familiar with on his or her computer.

When installation is complete the user can use the native installation package and the native operating system to perform maintenance or to uninstall the application . For example the user can maintain the application e.g. install a missing component or uninstall the application using the procedure that is natural and appropriate to the platform such as using the Add Remove Software tool in a Windows operating system.

Application information can be supplied with a cross platform package or by other means. This application information can be combined with information from the platform specific template executable to generate the application executable . The application information includes information specific to the application such as code implementing algorithms data or documentation. The template executable is specific to the target computer and contains machine code common to executables of that platform.

The template is copied and renamed according to information included in the application information . The template can include generic filler material such as a generic icon that is overwritten when creating the application executable . The template executable can include other resources such as common code that can be used for performing common tasks or links to system libraries such as DLLs. In some implementations the template executable can include a version resource to which version information about the application can be added when generating the application executable .

The application information can include an application name which is used as the name for the application executable . An application icon can be included in the application information and can be integrated with the template executable when generating the application executable . For example the application icon can be an application specific graphic in PNG format that overwrites the generic icon e.g. after conversion to ICO format to form the application icon in the application executable . This application icon is then used to start the application such as by presenting the icon in the OS user interface for double clicking by a user. A version number can also be provided with the application information for further identification of the application executable and the version resource in the copied template executable can be updated with the version number to form the version number in the application executable . Additionally the application information can include code which can be cross platform code such as SWF and HyperText Markup Language HTML platform specific code such as machine code native to the target platform or a combination of these. The code can be in source compiled fully compiled or partially compiled and or interpreted form and can be inserted into the application executable as code . For example an SWF file that provides the logic and user interface for a new application can be embedded as a resource in the executable. A resource in this context is a section of an executable file reserved for storing data of various types. Typically an OS provides a programming interface which can be used to manipulate the resources programmatically and embedding SWF code as a resource can be done using an OS programming interface or by modifying the executable image directly note that the specification for the executable format for any given platform describes how to structure the executable file to include these resources . Moreover the application information can include additional files including both data and code such as Portable Document Format PDF files and JavaScript files.

Thus in general a copy of the template executable is made which becomes the application executable . Some items present in the template executable are replaced in the application executable with items used in whole or in part from the application information provided. Some information or resources may need to be converted prior to use for populating the application executable . Some platforms may require icons to be converted to a particular graphics format different from that provided with the application information e.g. conversion from .png to .ico format . In some instances the application name provided with the application information or the install directory location can be changed to follow the conventions of the target platform in such cases the application name and application executable location can be converted to a suitable equivalent. In any event the resulting application executable is generated from the template can run as native software on the target platform and includes new functionality added to the executable without recompiling the executable from source code.

Application information can be obtained for installing a software application on a target platform. The application information can include for example an application name an application icon version information and application code. The application information can be used to form an application executable for installation on a target computer.

A user may attempt to reinstall the application unnecessarily for example the user may be unaware that the application has already been installed on the target computer. The method can include checking the target computer to determine whether a current version of the software application is installed. In some implementations if the software has already been installed a user interface can prompt the user whether they wish to continue the installation possibly giving the option of installing over the existing version or choosing a new location or abort the installation process.

A template executable can be obtained which includes machine code native to the target platform. This machine code enables the executable to run as a native application on the target platform. Application information can be added to the template executable to form an application executable for the software application. The application executable then includes the native machine code from the template and new code e.g. SWF code added to the executable which together form the application.

In some implementations the method can include determining if a runtime library is installed on the target platform. The runtime library can be installed on the target platform if not already installed. The application executable can be placed into an install directory using a file name corresponding to the application name. The application executable is then ready to run. Alternatively the application executable can be added to a native installation package which is in turn processed by the native OS installer.

A first installation package can be obtained for installing software. The package can be pulled from a specific location local or remote or be received in response to another action and the first package can be authenticated by checking a digital signature of the first package to make sure the package hasn t been modified since being signed. The first installation package is a cross platform installation package distributed for installation on multiple different platforms. The first installation package can be used to install an application on multiple different computer platforms. The first installation package can include interpreted and or partially compiled code e.g. scripts SWF compiled code e.g. native machine code or a combination of these.

The first installation package can be converted into a second installation package stored in a format native to a target platform. For instance the first installation package can be used to create a .msi file to install an application on a computer running a Windows operating system. The contents of the first package can be read e.g. including program content and an XML manifest then the elements of the first package can be translated to corresponding elements in the second native installation package. For example the application name can be copied into the native installation package all content files can be copied into the native installation package instructions for installing the copied content files can be placed in the native installation package component definitions can be created for executables and libraries to be installed and the application icon is converted into the native icon format if necessary and placed in the native installation package.

Installation can be initiated on the target platform with the second native installation package. In some implementations the program used to create the second native installation package can cause it to run when its creation is complete either locally or on a remote computer. In some implementations the installation process can be initiated through the act of sending the second native installation package to the target computer. The installation can then proceed at a later time when the second native installation package is processed by a native installer on the target platform.

The native installer can execute the second native installation package to install an application and this will typically involve more than just copying files into appropriate locations on the target machine. Native installers can perform additional actions such as 1 enable disable the installation of optional features 2 register products 3 activate or license products 4 install Component Object Model COM components 5 install system services 6 register file extensions and MIME content types 7 register instructions for uninstallation and 8 create desktop shortcuts and start menu entries. Such additional actions can be implemented through the generated native installation package thus achieving tight integration with the target computer s operating system.

In some implementations the first installation package can be a single file that includes all the components needed to install the software on multiple different platforms. For example a single installation package can be used to create various installation files for installing an application on a computer running a Windows operating system a computer running a Mac OS operating system and a computer running a Linux operating system. In some implementations the second installation package or resulting application can use a runtime library.

The one or more selected templates can be copied to an appropriate location. In some implementations the copy of the template s can be to memory prior to filling. In some implementations a copy is made directly to non volatile storage such as a disk drive and modified with information obtained from the cross platform package. For example a cross platform installation package can be expanded in a newly created output directory and a template native installation package and a template executable can be copied into the output directory for further processing.

At least a portion of the package information can be transferred to the one or more templates. For example for a Windows platform a first set of information from the package can be applied to a template executable a .exe file for the Windows platform to create an application executable. Note that for a Mac OS platform the template executable can be copied e.g. into the native installation package but need not be modified since the location of the copied executable can designate associated application components to use when running the executable. A second set of information from the package can be applied to a template installation package a .msi file for the Windows platform to create the second installation package in which the populated template executable is placed. This can be done using the Windows Application Program Interface API to modify the .msi file.

At least a portion of the program content can be copied from the first installation package to the second installation package without modification. For example code e.g. SWF code can be copied to an executable without modification aside from possibly being added to the executable . At least a portion of the package information or the program content can be transformed from a first format to a second format before inclusion in the second installation package. For example an application icon can be transformed from a portable network graphics format to a bit mapped graphics format and the template installation package copied to the new directory can be modified to include references to the files copied from the cross platform installation package and application attribute read from an XML manifest can be used to modify the native installation package appropriately e.g. set the application name etc. In some implementations additional content can come from other sources such as a remote server accessed over a network.

As discussed above the transcoder can be integrated with the runtime environment or be a stand alone program. In either case the runtime environment can manage the installation process e.g. using a cross platform package a native package or a combination of these for new applications that depend on the runtime for operation. Thus the runtime environment can serve as both an application execution environment and an installation environment for those applications.

The target computer includes both hardware and software. The hardware includes input output devices one or more processors and at least one computer readable medium e.g. memory device s a storage device s or combinations of one or more of them . The software includes an operating system on which the software elements provided by the distributor operate. The runtime environment uses the operating system to interact with other elements of the computer . The runtime environment can provide various utility services for use by applications that run in the environment. These utility services can include file system access window and menuing integration with the OS shell e.g. W OS Explorer or M OS Finder file extension registration document processing support e.g. Hypertext Markup Language HTML and Portable Document Format PDF engines string manipulation graphics networking notification facilities addressing peripherals or other types of functionality that can be provide using a runtime library. Moreover the runtime environment can include a cross platform application program interface API that provides services to applications that run in the runtime environment and serves to abstract away details of the various hardware and OS platforms on which the runtime environment program has been designed to run.

Thus the runtime environment can be a cross platform runtime environment such as the Adobe Integrated Runtime AIR software provided by Adobe Systems Inc. of San Jose Calif. In some implementations the runtime environment can load an application from an encoded representation of the application. For example the encoded representation can have a predefined syntactic structure such as a programming language e.g. source code or can include well defined virtual instructions e.g. platform independent bytecode such as Macromedia Flash bytecode . To load such applications the runtime environment can decode the encoded representation of the application into instructions and can execute the instructions of the application.

In addition to serving as an application execution environment the RE can also serve as an application installation environment both for itself and the applications that run on the RE . The user interface and language facilities of the RE e.g. HTML MXML Multimedia eXtensible Markup Language and scripting support such as for ActionScript and JavaScript can be used when writing the installer for the RE an application or a combination of them . This can help in reducing the size of the installer since much of the programming logic that would normally be needed in the installer can be incorporated into the RE .

The extent of the install uninstall facilities to be put into the RE can vary among implementations. In some cases the RE can provide APIs that perform all installation operations based on requests from one or more appropriate installers. In other cases some installation operations can be provided in the one or more installers and lower level API s of the runtime e.g. file system access API can be used complete the installation operations on the computer .

When a request is received to install an application which requires the RE for operation a check is made to determine if the RE is already installed on the computer . For example in the network download context functionality built into a web browser and the page being viewed can be employed to determine if the runtime environment program is already present on the computer or the runtime environment can employ a browser plug in useable to detect presence of the runtime environment on the computer. If the RE is already installed this installed RE can be used to install the application from an application package . If not the appropriate RE e.g. for a W OS M OS or L OS computer can be installed from the RE package and then be used to install the application from the application package .

The installation of the software application and the runtime environment can be tied together as a single installation transaction such that they succeed or fail together and the installation sequence can include a user interface panel that includes a notification regarding the runtime environment program to be installed. Regardless of how received e.g. on CD or by network download a first installer of the runtime environment program can be started with a reference to an installation package of the software application . The first installer can be designed to install the runtime environment but also be designed to accept an argument indicating a location of the installation package of the software application e.g. a Universal Resource Locator either to a local or a remote repository .

A second installer for the installation package can be called from the first installer with an indication that the runtime environment program is to be installed. The second installer can be designed to install software applications that run on the runtime environment. The second installer can be part of an install uninstall facility built into the runtime environment as shown and described in connection with . Thus the second installer can be part of the runtime environment itself such that installing applications is one of the services the environment provides.

The second installer can present a user interface that includes a notification regarding the application execution environment AEE program to be installed along with the software application. This allows the user to be fully informed about the planned combined installation of the application and the underlying environment on which it runs but this information is provided within the context of the installation sequence for the software application itself. Thus the application execution environment program can be handled from the user s perspective like an element of the application which cannot be unselected even though it is a fully independent separate software program that serves as a runtime environment for the software application.

Also because the runtime environment is a separate software program the installation sequence can also include a request for user acceptance of an end user license agreement for the runtime environment program. If the user acceptance is received the application execution environment program and then the software program can be installed transactionally as one install using an install progress bar that spans the two installs.

The installer package can be equated with the runtime installer since in some implementations e.g. for Windows OS computers the package is an executable that begins the installation process. In other implementations the installer package can be the compressed archive file. For example for M OS computers the installer package can be a .dmg file in disk image format. In this case the user can open the .dmg file e.g. double click it and then launch the RE installer included therein. Moreover the runtime installer class can have very different implementations on a M OS based computer versus a W OS based computer.

On a W OS based computer the runtime installer can operate using API s that are in the RE and that are related only to installation because they use the W installation services to perform the installation operations. On a M OS based computer or a L OS based computer the runtime installer can operate using the file system API s that are in the RE . In any event the runtime installer class can define a cross platform interface that installer s can access and use in the same manner regardless of whether it is running on a M OS based computer or a W OS based computer i.e. the installer need not have any native code in it . Other approaches are also possible. For example the RE can provide a mechanism for invoking native code and this mechanism can also be used by the installer .

The runtime can include an application installer used to install applications that run on the runtime. When copied to the target computer the installer package can create a local copy of the runtime installer that can be called with a reference REF to an application install package which can be local or remote and can extract a first copy of the runtime an x copy of the runtime that will run in place at the temporary location on the computer . The local copy of the runtime installer can then call into the application installer in the first runtime copy with the reference and with an indication instruction to also perform runtime installation RTI e.g. a flag indicating that the runtime should also be installed . The application installer in the first runtime copy can present user interface panels at least one of which has an inserted notification regarding the runtime to also be installed. Furthermore an initial installation user interface panel of panels presented by the application installer can be one that relates to the software application thus making clear to the user that the primary objective is the installation of the software application the runtime installation is presented as an ancillary process.

The application installer in the first runtime copy e.g. ActionScript code that uses native code built into the runtime can then drive installation of the software application and the runtime on which it depends transactionally as one install if either installation fails or is cancelled the entire combined installation can be rolled back and undone. An installed copy of the runtime can be created from the first runtime copy and registered on the target computer. Then an installed copy of the application can be created from the application install package . Finally the first runtime copy and the runtime installer copy can be deleted from the target computer or otherwise transitioned to a new state e.g. they can be moved and converted into an uninstaller for the application and the runtime . Thus the runtime can provide both an execution environment for applications and a installation uninstallation environment for applications and itself.

In any event once the application and the runtime on which it depends are installed the application which may be created using only cross platform code such as SWF code can function within the computer s operating system as a normal desktop application e.g. with a separate non generic icon for program launch and a presence in OS utilities interfaces .

The application executable can be installed on the target platform having the operating system. This can involve using installation services of the operating system e.g. on a W OS based computer to perform the installation operations extracting application components from an installation package to an appropriate location on the target computer platform e.g. on a M OS based computer or a L OS based computer or a combination of these. Moreover as described in further detail above the obtaining and the installing can be performed at least in part by the runtime environment.

The application executable can run in the operating system. This can involve identifying the runtime environment needed for the application code and loading the identified runtime environment. Thus the application executable need not contain any native code effecting the application aside from the call to the runtime environment to handle the application code. Alternatively the application executable can include additional native code for use in supporting the software application. For example the application executable can include native code used to facilitate access to OS specific features that may not be exposed by the runtime program directly to obtain better performance for some computations that run more quickly in native code than in bytecode or script to enable re use of existing native code or various combinations of these.

The application code can be run in the runtime. The application code need not include any native code at all. For example the application code can include bytecode or scripting code or both that is just in time compiled or interpreted by the runtime environment. Thus the application executable which runs in the operating system provides a link into the operating system while the application code which runs in the runtime environment provides the application s functionality.

The software application can then be maintained and presented as a native application in the operating system. The operating system views the software application as a native application distinct from other applications that depend on the runtime environment to operate. This can involve presenting a task list with a customized instance of the software application. For example as shown in a task manager user interface can be presented e.g. the Windows Task Manager interface presented on a W OS based computer . The user interface includes representations of the software applications that operate through the runtime environment where those representations include the application names APP and APP and application icons and that are specific to the respective software applications.

Because a separate native executable is generated for each of the applications the cross platform applications show up on the given computer platform as separate processes. Note that whether or not the different applications use the same dynamic link libraries DLLs doesn t matter e.g. on a W OS computer where the runtime can be accessed by applications loading a DLL . In general two applications will be presented by the OS in a similar fashion even if one application uses the runtime either a dedicated copy or a shared copy and the other application does not. The applications run in the runtime environment but are separately managed and visually distinguishable through the operating system . In general this allows the runtime application to be monitored rather than the runtime itself whenever an OS based resource e.g. firewalls virus checkers task managers process managers etc. is to be utilized. In other words it is the application on top of the runtime that is recognized as the OS managed application rather than a given instance of the runtime.

In any event the cross platform package can define a cross platform abstraction of what makes up an icon including a set of images for the icon. The set can contain different variations of the same image e.g. stored at different sizes and color depths and different images e.g. multiple images of an animated icon . The set of images can be defined in a file e.g. XML or programmatically e.g. a list in memory . The individual images can be stored in various cross platform formats such as PNG and JPEG Joint Photographic Experts Group formats and the one or more descriptors can be stored as associated XML data.

The cross platform icon can be translated to a predefined icon format for a specified operating system on a computer. For example the cross platform icon can be an icon stored in PNG format which can be translated into the Windows Icon format ICO for a Windows platform. Thus an instance of the cross platform icon can be transformed into a proprietary icon format for a selected operating system. Note that the conversion can happen on a platform different than that of the target format e.g. a M OS icon can be created on a W OS system and vice versa . In addition the translation process can include various error checks and handling such as cross checking the actual size of images with the sizes indicated in the descriptor s and confirming that the icon images are in a supported format.

The translated icon can be provided in the predefined icon format for display by the operating system. This can involve placing the translated icon into the application executable or into a separate file associated with the application executable where the translated icon is then available to the OS for presentation in the OS user interface e.g. to represent the application in an interface element to be activated by a user or to represent associated file types and so on .

In addition the translating can be done while the application is running rather than just at the time the application is installed. In fact the obtaining the translating and the providing can be performed at runtime to dynamically create icons for the software application. Moreover the translating and the providing can involve using an API of the OS to define the translated icon in the predefined icon format for use by the OS to change icon representation of the software application to indicate status of the software application while it is running. Thus new icons can be created on the fly using OS APIs associated with a proprietary icon format of the OS and the icon associated with an aspect of the application can be changed to indicate status of the application while the application is running.

Referring again to a user interface for APP includes a dynamically created version of the application icon which represents the application itself. The icon can be changed by the application while the application is running in the runtime environment . The application can inform the runtime environment of the desired change to the icon through the cross platform API at runtime and the runtime environment can then translate the icon in accordance with the requirements of the operating system and provide the translated icon to the operating system for display. Note that many different types of icons can be dynamically updated through the runtime environment in this manner such as an icon used to represent the application e.g. in the dock on a M OS computer icons representing associated file types or other icons employed by the operating system to represent various aspects of the software application. User interface icons and employed by the application can also be dynamically updated through the runtime environment although in most cases going through the runtime environment is only necessary when the OS is needed to render an icon because the application cannot e.g. because the application is not running or the icon is to be rendered to a part of the screen the application cannot draw to .

The translating process can be implemented in scripting code e.g. ActionScript that runs in the runtime environment . This scripting code can use an image loading facility built into the runtime environment to load individual image files and then produce the proprietary representation of the theses images in the target icon format. This can involve inspecting attributes of the input images such as their width height color depth and transparency attributes.

As shown in this example the XML tags themselves include information describing the images i.e. the image size and the XML data includes Universal Resource Locator URL data for the images which URLs can point to local resources or remote resources.

The check of the descriptor s can involve checking image sizes color depth and transparency encoding. Images in the cross platform icon can be modified based on the check. For example the cross platform icon can include multiple images including vector graphics and the modifying can involve rasterizing the vector graphics e.g. conversion to bitmap images . Other types of modifications can include scaling images to different sizes converting color depths adding or removing transparency information or a combination of these. Converting color depths can involve determining the actual number of real colors that are used by a set of images and producing lower color icons if the number of colors fits inside the threshold set of the OS e.g. 256 colors or 16 000 colors . Changing the transparency information can involve converting an eight bit alpha channel into a one bit transparency mask although in some cases the OS can support 256 level alpha transparencies . The modifications can also include dropping some of the images such as when the particular size or color depth of an image is not compatible with a given OS.

Information for the cross platform icon can be written into the native icon in the predefined icon format. This can include writing a header for the translated icon writing a descriptor block containing size and color depth information for each of the images for the translated icon writing color data for each of the images for the translated icon and writing a transparency mask for each of the images for the translated icon. The translating process can be performed in two passes e.g. on a W OS computer a first pass to determine which images are available in the cross platform icon and to write header information into the proprietary icon format file and a second pass to convert the image data between image formats.

In addition the process can also inspect the target OS version to determine which icon formats are supported newer OS versions often support additional formats. Conversion to those additional formats can also be performed if the target OS supports those versions. Some OS icon formats allow or require the use of compression for certain icon images. Thus the translating process can also include compression of the converted image e.g. via flate deflate compression . Moreover the icon data in some OS icon formats is laid out in the file so that it can be loaded into memory and used without further translation. This can require a minimum stride typically 4 bytes for the layout of the data in each row. For example if an icon is two pixels wide the data for each row can be stored in two bytes followed by two unused bytes so that each row starts on a multiple of 4 bytes.

Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specifics these should not be construed as limitations on the scope of the invention or of what may be claimed but rather as descriptions of features specific to particular embodiments of the invention. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

