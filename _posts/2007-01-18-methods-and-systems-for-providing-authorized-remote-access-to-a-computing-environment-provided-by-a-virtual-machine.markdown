---

title: Methods and systems for providing authorized remote access to a computing environment provided by a virtual machine
abstract: A method for providing authorized remote access to a computing environment provided by a virtual machine, includes the step of requesting, by a client machine, access to a resource. A collection agent gathers information about the client machine. A policy engine receives the gathered information. The policy engine makes an access control decision based on the received information. A computing environment already associated with the user is identified in response to the received information, the identified computing environment provided by a virtual machine. A broker server establishes, responsive to the access control decision, a connection between the client machine and the identified computing environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07949677&OS=07949677&RS=07949677
owner: Citrix Systems, Inc.
number: 07949677
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20070118
---
The present application claims priority to U.S. Provisional Patent Application Ser. No. 60 761 674 entitled Methods and Systems for Providing Access to a Computing Environment filed Jan. 24 2006 which is incorporated herein by reference.

The invention generally relates to providing access to computing environments. More particularly the invention relates to methods and systems for providing authorized remote access to a computing environment provided by a virtual machine.

Conventionally users on a client machine have used a combination of a web browser and other client based applications to access a content file or application retrieved from a remote location. Conventional processes require downloading the file and or associated application to a client machine for viewing and manipulation. However downloading networked resources to a client machine typically creates administrative and security related challenges. For example client machines or particular users of client machines may or may not have authorization to access files or the applications required to process retrieved files. Ensuring compliance with various corporate policies creates additional concerns for administrators of typical enterprise environments. Assessing and authorizing execution of particular application programs on target machines on an individual application may be impractical.

In an attempt to solve these concerns conventional methods of access control may require particular authentication credentials from the client prior to granting access and may deny access from inappropriate locations or devices. However a limitation to conventional methods typically requires that the access control decision result in either a denial or a grant of access to a resource. In the event of a denial the methods fail to provide any alternative methods of access. In the event of a grant the methods can provide only full and complete disclosure of the resource.

In one aspect problems of current desktop deployment strategies are addressed. An array of inexpensive physical machines may be partitioned into multiple virtual machines creating a virtual PC for each user. The physical machines may be servers such as rack mount servers blade servers or standalone servers. The physical machines may also be workstations or workstation blades or personal computers. A policy based dynamic deployment system provisions the virtual machines and associates the virtual machine with an execution machine i.e. a physical machine and a user. Centralized hosting provides the manageability of server based computing while the dedicated environment provides the flexibility and compatibility with applications that a desktop PC enables. However the system has a much lower total cost of ownership because the system is implemented in software rather than being dependent on hardware the system has a much lower total cost of ownership.

In another aspect the hardware lifecycle may be extended by increasing the amount of hardware resources assigned to virtual machines as computational demands increase over time. Additionally the use of virtualization eases the difficulty in dealing with multiple OS images.

In one embodiment machines are configured to run multiple copies of one or more operating systems e.g. different versions releases of WINDOWS from Microsoft Corporation . Users transmit requests for access to computing resources to the deployment system which may use a configuration policy to decide how with what physical and or virtual resources and where on which physical machine in the machine farm and on which virtual machine to provide access to the requested computing resource. The virtual machine can be created on demand and the requested software resource may be downloaded and installed in the virtual machine as required. Alternatively the virtual machine may be pre configured with a plurality of software and or virtual hardware resources to provide a particular computing environment to the user. The user request is directed to the selected configured virtual machine and a remote display connection is established between the virtual machine and a remote display client on the user s access device which will be referred to generally as a client machine. Devices such as CD ROM drives floppy drives USB drives and other similar devices that are connected to the client machine are connected and remotely accessible to the virtual machine thereby allowing the use of these devices in a manner similar to a standard desktop computer.

A deployment system may manage a pool of virtual machines a machine farm to which new virtual machines can be added on demand. Alternatively a plurality of software modules including a session management component and a virtual machine management component may provide management functionality. Executing virtual machines may be migrated from one physical machine to another under control of the deployment system to provide load balancing or to facilitate hardware maintenance. Inactive virtual machines may be suspended to free physical computing resources. Active virtual machines may be migrated from one physical machine to another to consolidate them onto a smaller number of physical machines to allow the unused physical machines to be shutdown to save power during off peak periods or to free the physical resource to be reassigned for a different purpose e.g. process web requests. Suspended virtual machines may be resumed prior to users requiring access. This can be done manually or automatically via policies or preferences or through a learning process by monitoring a user s behavior over time.

Performance requirements of the requested resource may be considered when allocating computing resources to virtual machines. For example a financial analysis package may require twice as many CPU resources as a generic productivity application such as those included in MICROSOFT OFFICE manufactured by Microsoft Corporation of Redmond Wash. A virtual machine providing the financial analysis package may execute on a physical machine determined to have sufficient spare computational capacity or existing virtual machines may be relocated to other available physical machines to ensure sufficient available capacity on a particular physical machine.

Each user is provided a separate virtual machine environment which provides increased flexibility in that each user may run any version or configuration of an operating system independently of other users and also allows users to run potentially dangerous or destabilizing applications with little risk of affecting other users. This is particularly useful for developers testers information technology personnel who frequently need to reinstall and modify the operating system and run potentially destabilizing applications.

Since sharing computing resources and CPU scheduling occurs outside of the virtual machine environment users can run computing resource intensive resources with no risk of affecting other users. Virtual machines also provide increased security isolation between users. Because each user is running a separate copy of the OS there is much less chance of security breaches and virus infections over the between users boundaries than in the shared OS case.

A solution is also provided for problems that arise from a situation where in a hardware based system of machines the hardware is mixed whether due to an initial purchasing decision or due to the acquisition of different types of physical machines over time. Even if initially all of the hardware was uniform purchasing additional hardware to replace failing modules and increasing the capacity typically leads to non uniform hardware throughout a machine farm. Even if all hardware is purchased from the same vendor it is likely that the hardware purchased later will use different chipsets and components and will require different drivers. Non uniform hardware has traditionally translated into the need to maintain multiple versions of the operating system images which means higher costs and limits flexibility of moving users between machines because the operating system image may be incompatible which also translates into higher cost. Virtual machines allow efficient use of the same operating system image even in a hardware farm that includes heterogeneous machines. The use of the same operating system image helps to significantly reduce the management cost.

Adding remote display capability e.g. presentation layer protocols such as ICA RDP or X11 to virtualization techniques allows virtualization to be used for interactive computing. Hosting multiple virtual machines on an execution machine allows better utilization of the available physical computing resources e.g. space power processing power processing capacity RAM bandwidth etc. thereby lowering costs. The use of virtualization also allows hardware to be updated and maintained independently of OS version and specific device drivers hosted in the operating systems or virtual machines. Additionally virtual machines enhance system security by isolating computing environments from each other.

In one aspect a method for providing authorized remote access to a computing environment provided by a virtual machine includes the step of requesting by a client machine access to a resource. A collection agent gathers information about the client machine. A policy engine receives the gathered information. The policy engine makes an access control decision based on the received information. A computing environment already associated with the user is identified in response to the received information the identified computing environment provided by a virtual machine. A broker server establishes responsive to the access control decision a connection between the client machine and the identified computing environment.

In one embodiment a first computing environment and a second computing environment are identified in response to the received information the first and second computing environments already associated with the user. In another embodiment a first computing environment and second computing environment are identified in response to the received information the first computing environment executing on a first server and the second computing environment executing on a second server the first and second computing environments already associated with the user. In still another embodiment a computing environment comprising a first application session and already associated with the user is identified in response to the received information and a second computing environment already associated with the user and comprising a second application session is identified.

In another aspect a system for providing authorized remote access to a computing environment provided by a virtual machine includes a collection agent a policy engine and a broker server. The collection agent gathers information about the client machine. The policy engine receives the gathered information and requests an enumeration of computing environments associated with a user of the client machine the request including the access control decision. The broker server enumerates a computing environment associated with the client machine responsive to the access control decision the enumerated computing environment provided by a virtual machine.

In one embodiment the collection agent executes on the client machine. In another embodiment the policy engine transmits the collection agent to the client machine. In still another embodiment the policy engine transmits instructions to the collection agent determining the type of information the collection agent gathers. In yet another embodiment the policy engine makes an access control decision based on applying a policy to the gathered information.

In one embodiment the broker server enumerates a first computing environment and a second computing environment the first and second computing environments already associated with the user. In another embodiment the broker server enumerates a first computing environment executing on a first server and a second computing environment executing on a second server the first and second computing environments already associated with the user. In still another embodiment the broker server enumerates an identified computing environment already associated with the user the identified computing environment comprising a first application session and enumerates a second computing environment already associated with the user and comprising a second application session.

Referring now to a block diagram of one embodiment of an environment in which a client machine accesses a computing resource provided by a remote machine is shown.

A remote machine such as remote machine or hereafter referred to generally as remote machine accepts connections from a user of a client machine . Although only two client machines and only four remote machines are depicted in the embodiment shown in it should be understood that the system may provide multiple ones of any or each of those components. For example in one embodiment the system may include multiple logically grouped remote machines one or more of which is available to provide a client machine access to computing resources. In these embodiments the logical group of remote machines may be referred to as a server farm or machine farm indicated in as machine farm . In some of these embodiments the remote machines may be geographically dispersed. Thus the group of remote machines logically grouped as a machine farm may be interconnected using a wide area network WAN connection metropolitan area network MAN connection a local area network LAN a storage area network SAN or a public network such as the Internet. For example a machine farm may include remote machines physically located in geographically diverse locations around the world including different continents regions of a continent countries regions of a country states regions of a state cities regions of a city campuses regions of a campus or rooms. Data transmission speeds between remote machines in the machine farm can be increased if the remote machines are connected using a local area network LAN connection or some form of direct connection. A machine farm may be administered as a single entity.

A centralized service may provide management for machine farm . In some embodiments one or more remote machines elect a particular remote machine to provide management functionality for the farm. The elected remote machine may be referred to as a management server management node or management process. The management node may gather and store information about a plurality of remote machines respond to requests for access to resources hosted by remote machines and enable the establishment of connections between client machines and remote machines . In other embodiments an administrator designates one or more remote machines to provide management functionality for machine farm .

Alternatively management of the machine farm may be de centralized. In some embodiments one or more remote machines comprise components subsystems and modules to support one or more management services for the machine farm . In one of these embodiments one or more remote machines provide functionality for management of dynamic data including techniques for handling failover data replication and increasing the robustness of the machine farm . In another of these embodiments one or more remote machines include communications capabilities to enable the one or more remote machines to interact with one another to share responsibility for management tasks. Each remote machine may communicate with a persistent store and in some embodiments with a dynamic store.

Persistent store may be physically implemented on a disk disk farm a redundant array of independent disks RAID writeable compact disc or any other device that allows data to be read and written and that maintains written data if power is removed from the storage device. A single physical device may provide storage for a plurality of persistent stores i.e. a single physical device may be used to provide the persistent store for more than one machine farm . The persistent store maintains static data associated with each remote machine in machine farm and global data used by all remote machines within the machine farm . In one embodiment the persistent store may maintain the server data in a Lightweight Directory Access Protocol LDAP data model. In other embodiments the persistent store stores server data in an ODBC compliant database. For the purposes of this description the term static data refers to data that do not change frequently i.e. data that change only on an hourly daily or weekly basis or data that never change.

The data stored by the persistent store may be replicated for reliability purposes physically or logically. For example physical redundancy may be provided using a set of redundant mirrored disks each providing a copy of the data. In other embodiments the database itself may be replicated using standard database techniques to provide multiple copies of the database. In further embodiments both physical and logical replication may be used concurrently.

As described above the remote machines store static data i.e. data that persist across client sessions in the persistent store. Writing to the persistent store can take relatively long periods of time. To minimize accesses to the persistent store the remote machines may develop a logical common database i.e. the dynamic store that is accessible by all of the remote machines in the machine farm for accessing and storing some types of data. The dynamic store may be physically implemented in the local memory of a single or multiple remote machines in the machine farm . The local memory can be random access memory disk disk farm a redundant array of independent disks RAID or any other memory device that allows data to be read and written.

In general data stored in the dynamic store are data that are typically queried or changed frequently during runtime. Examples of such data hereafter referred to as runtime data are the current workload level for each of the remote machines in the machine farm the status of the remote machines in the machine farm client session data the number of virtual machines supported by a remote machine the identity of the operating systems supported by a remote machine and licensing information.

In one embodiment the dynamic store comprises one or more tables each of which stores records of attribute value pairs. Any number of tables may exist but each table stores records of only one type. Tables are in some embodiments identified by name. Thus in this embodiment two remote machines that use the same name to open a table refer to the same logical table.

The dynamic store i.e. the collection of all record tables can be embodied in various ways. In one embodiment the dynamic store is centralized that is all runtime data are stored in the memory of one remote machine in the machine farm . That server operates in a manner similar to the management node described above that is all other remote machines in the machine farm communicate with the server acting as the centralized data store when seeking access to that runtime data. In another embodiment each remote machine in the machine farm keeps a full copy of the dynamic store. Here each remote machine communicates with every other remote machine to keep its copy of the dynamic store up to date.

In another embodiment each remote machine maintains its own runtime data and communicates with every other remote machine when seeking to obtain runtime data from them. Thus for example a remote machine attempting to find an application program requested by the client machine may communicate directly with every other remote machine in the machine farm to find one or more servers hosting the requested application.

For machine farms having a large number of remote machines the network traffic produced by these embodiments can become heavy. One embodiment alleviates heavy network traffic by designating a subset of the remote machines in a machine farm typically two or more as collector points. Generally a collector point is a server that collects run time data. Each collector point stores runtime data collected from certain other remote machines in the machine farm . Each remote machine in the machine farm is capable of operating as and consequently is capable of being designated as a collector point. In one embodiment each collector point stores a copy of the entire dynamic store. In another embodiment each collector point stores a portion of the dynamic store i.e. it maintains runtime data of a particular data type. The type of data stored by a remote machine may be predetermined according to one or more criteria. For example remote machines may store different types of data based on their boot order. Alternatively the type of data stored by a remote machine may be configured by an administrator using administration tool . In these embodiments the dynamic store is distributed among two or more remote machines in the machine farm .

Remote machines not designated as collector points know the remote machines in a machine farm that are designated as collector points. A remote machine not designated as a collector point communicates with a particular collector point when delivering and requesting runtime data. Consequently collector points lighten network traffic because each remote machine in the machine farm communicates with a single collector point remote machine rather than with every other remote machine when seeking to access the runtime data.

The machine farm can be heterogeneous that is one or more of the remote machines can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other remote machines can operate according to another type of operating system platform e.g. Unix or Linux . Additionally a heterogeneous machine farm may include one or more remote machines operating according to a type of operating system while one or more other remote machines execute one or more types of hypervisors rather than operating systems. In these embodiments hypervisors may be used to emulate virtual hardware partition physical hardware virtualize physical hardware and execute virtual machines that provide access to computing environments. Hypervisors may include those manufactured by VMWare Inc. of Palo Alto Calif. the Xen hypervisor an open source product whose development is overseen by XenSource Inc. of Palo Alto the VirtualServer or virtual PC hypervisors provided by Microsoft or others.

In some embodiments a hypervisor executes on a machine executing an operating system. In one of these embodiments a machine executing an operating system and a hypervisor may be said to have a host operating system the operating system executing on the machine and a guest operating system an operating system executing within a computing resource partition provided by the hypervisor . In other embodiments a hypervisor interacts directly with hardware on a machine instead of executing on a host operating system. In one of these embodiments the hypervisor may be said to be executing on bare metal referring to the hardware comprising the machine.

Remote machines may be servers file servers application servers appliances network appliances gateways application gateways gateway servers virtualization servers deployment servers or firewalls. The remote machine may be an SSL VPN server. The remote machine may be an application acceleration appliance. For embodiments in which the remote machine is an application acceleration appliance the remote machine may provide functionality including firewall functionality application firewall functionality or load balancing functionality. In some embodiments the remote machine comprises an appliance such as one of the line of appliances manufactured by the Citrix Application Networking Group of San Jose Calif. or Silver Peak Systems Inc. of Mountain View Calif. or of Riverbed Technology Inc. of San Francisco Calif. or of F5 Networks Inc. of Seattle Wash. or of Juniper Networks Inc. of Sunnyvale Calif.

In some embodiments a remote machine comprises a remote authentication dial in user service referred to as a RADIUS server. In other embodiments remote machines may have the capacity to function as a master network information node monitoring resource usage of other machines in the farm . In still other embodiments a remote machine may provide an Active Directory. Remote machines may be referred to as execution machines intermediate machines broker machines intermediate broker machines or worker machines.

In one embodiment remote machines in the machine farm may be stored in high density racking systems along with associated storage systems and located in an enterprise data center. In this embodiment consolidating the machines in this way may improve system manageability data security the physical security of the system and system performance by locating machines and high performance storage systems on localized high performance networks. Centralizing the machines and storage systems and coupling them with advanced system management tools allows more efficient use of machine resources.

The client machines may also be referred to as endpoints client nodes clients or local machines. In some embodiments the client machines have the capacity to function as both client machines seeking access to resources and as remote machines providing access to remotely hosted resources for other client machines . In some embodiments remote machines may request access to remotely hosted resources. In one of these embodiments the remote machines may be referred to as client machines .

In one embodiment the client machine communicates directly with one of the client machines in a machine farm . In another embodiment the client machine executes an application to communicate with the remote machine in a machine farm . In yet another embodiment the client machine communicates with one of the remote machines via a gateway such as an application gateway. In some embodiments the client machine communicates with the remote machine in the machine farm over a communications link . Over the communications link the client machine can for example request access to or execution of various resources provided by remote machines such as applications computing environments virtual machines or hypervisors hosted by or executing on the remote machines and in the machine farm . The client machine receives for display output of the results of execution of the resource or output of interaction between the client machine and the applications or computing environments provided by the remote machines . In another of these embodiments over the communications link the client machine can receive the output of applications executing in one or more virtual machines on a remote machine and in the machine farm .

The communications link may be synchronous or asynchronous and may be a LAN connection MAN connection or a WAN connection. Additionally communications link may be a wireless link such as an infrared channel or satellite band. The communications link may use a transport layer protocol such as TCP IP or any application layer protocol such as the Hypertext Transfer Protocol HTTP Extensible Markup Language XML Independent Computing Architecture Protocol ICA manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. or the Remote Desktop Protocol manufactured by the Microsoft Corporation of Redmond Wash. In one embodiment the communications link uses a Wi Fi protocol. In still another embodiment the communications link uses a mobile internet protocol.

The communications link may provide communications functionality through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 SNA DECNET broadband connections ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET and wireless connections or any combination thereof. Connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET SONET SDH Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g CDMA GSM WiMax and direct asynchronous connections . In one embodiment the remote machine and the client machine communicate via any type and or form of gateway or tunneling protocol such as Secure Socket Layer SSL or Transport Layer Security TLS or the Citrix Gateway Protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. The computer system may include a network interface comprising a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computer system to any type of network capable of communication and performing the operations described herein.

The computer system may support installation devices such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive network interface card tape drives of various formats USB device hard drive or any other device suitable for installing software programs data or files such as any software or portion thereof.

The computer system may also include a storage device of any type and form for storing an operating system and other related software and for storing application software programs. In one embodiment the storage device includes one or more hard disk drives or redundant arrays of independent disks. In other embodiments the storage device comprises any type and form of portable storage medium or device such as a compact flash card a micro hard drive or pocket drive embedded flash storage or USB storage drive. Portable storage devices may be generally referred to by a variety of names including but not limited to finger drive flash disk flash drive flash memory drive jump drive jump stick keychain drive keydrive memory key mobile drive pen drive thumb drive thumb key vault drive USB drive or USB stick. Optionally any of the installation devices or mediums could also provide a storage medium or device.

In some embodiments the client machine includes a client agent which may be for example implemented as a software program and or as a hardware device such as for example an ASIC or an FPGA. An example of a client agent with a user interface is a Web Browser e.g. INTERNET EXPLORER manufactured by Microsoft Corp. of Redmond Wash. or SAFARI manufactured by Apple Computer of Cupertino Calif. . The client agent can use any type of protocol such as a remote display protocol and it can be for example an HTTP client agent an FTP client agent an Oscar client agent a Telnet client agent an Independent Computing Architecture ICA client agent manufactured by Citrix Systems Inc. of Fort Lauderdale Fla. or a Remote Desktop Protocol RDP client agent manufactured by Microsoft Corporation of Redmond Wash. In some embodiments the client agent is configured to connect to the remote machine . In other embodiments not shown the client machine includes a plurality of client agents each of which may communicate with a remote machine respectively.

In many embodiments the remote machines and the client machines are provided as computers or computer servers of the sort manufactured by Apple Computer Inc. of Cupertino Calif. International Business Machines of White Plains N.Y. Hewlett Packard Corporation of Palo Alto Calif. or the Dell Corporation of Round Rock Tex. In some embodiments the remote machines may be blade servers servers workstation blades or personal computers executing hypervisors emulating hardware required for virtual machines providing access to computing environments. In these embodiments a single physical machine may provide multiple computing environments.

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM .

In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computer system in which the processor communicates directly with main memory via a memory port. For example in the main memory may be DRDRAM.

In the embodiment shown in the processor communicates with various I O devices via a local system bus . Various buses may be used to connect the central processing unit to the I O devices including a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. For embodiments in which the I O device is a video display the processor may use an Advanced Graphics Port AGP to communicate with the display. depicts an embodiment of a computer system in which the main processor communicates directly with I O device via HyperTransport Rapid I O or InfiniBand. also depicts an embodiment in which local busses and direct communication are mixed the processor communicates with I O device using a local interconnect bus while communicating with I O device directly.

A wide variety of I O devices may be present in the computer system . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. An I O device may also provide mass storage for the computer system such as a hard disk drive a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive DVD RW drive DVD RW drive tape drives of various formats and USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif. and the iPod Shuffle line of devices manufactured by Apple Computer Inc. of Cupertino Calif.

In some embodiments the client machine may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices may comprise a display device or any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the client machine . For example the client machine may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices. In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices. In other embodiments the client machine may include multiple video adapters with each video adapter connected to one or more of the display devices. In some embodiments any portion of the operating system of the client machine may be configured for using multiple displays. In other embodiments one or more of the display devices may be provided by one or more other computing devices such as remote machine connected to the client machine for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the client machine . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a client machine may be configured to have multiple display devices.

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

General purpose computers of the sort depicted in and typically operate under the control of operating systems which control scheduling of tasks and access to system resources. In some embodiments the computers operate under control of hypervisors which represent virtualized views of physical hardware as one or more virtual machines. Operating systems may execute in these virtual machines to control the virtual machine in a manner analogous to the way a native operating system controls a physical machine. Typical operating systems include the MICROSOFT WINDOWS family of operating systems manufactured by Microsoft Corp. of Redmond Wash. the MacOS family of operating systems manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah among others.

The client machines and may be any personal computer e.g. a Macintosh computer or a computer based on processors manufactured by Intel Corporation of Mountain View Calif. Windows based terminal Network Computer wireless device information appliance RISC Power PC X device workstation mini computer main frame computer personal digital assistant television set top box living room media center gaming console mobile gaming device NetPC s thin client or other computing device that has a windows based desktop and sufficient persistent storage for executing a small display presentation program. The display presentation program uses commands and data sent to it across communication channels to render a graphical display. Windows oriented platforms supported by the client machines and can include without limitation WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS 2000 Windows 2003 WINDOWS CE Windows XP Windows Vista MAC OS Java Linux and UNIX. The client machines can include a visual display device e.g. a computer monitor a data entry device e.g. a keyboard persistent or volatile storage e.g. computer memory for storing downloaded application programs a processor and a mouse. Execution of a small display presentation program allows the client machines to participate in a distributed computer system model i.e. a server based computing model .

In other embodiments the general purpose computers of the sort depicted in and may have different processors operating systems and input devices consistent with the device and in accordance with embodiments further described herein. The computer system can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone or other portable telecommunication device media playing device a gaming system or any other type and or form of computing telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. For example the computer system may comprise a device of the IPOD family of devices manufactured by Apple Computer of Cupertino Calif. a PLAYSTATION 2 PLAYSTATION 3 or PERSONAL PLAYSTATION PORTABLE PSP device manufactured by the Sony Corporation of Tokyo Japan a NINTENDO DS NINTENDO GAMEBOY NINTENDO GAMEBOY ADVANCED or NINTENDO REVOLUTION device manufactured by Nintendo Co. Ltd. of Kyoto Japan or an XBOX or XBOX 360 device manufactured by the Microsoft Corporation of Redmond Wash.

For embodiments in which a client machine is a mobile device the device may be a JAVA enabled cellular telephone such as those manufactured by Motorola Corp. of Schaumburg Ill. those manufactured by Kyocera of Kyoto Japan or those manufactured by Samsung Electronics Co. Ltd. of Seoul Korea. In other embodiments in which the client machine is mobile it may be a personal digital assistant PDA operating under control of the PalmOS operating system such as the devices manufactured by palmOne Inc. of Milpitas Calif. In further embodiments the client machine may be a personal digital assistant PDA operating under control of the PocketPC operating system such as the iPAQ devices manufactured by Hewlett Packard Corporation of Palo Alto Calif. the devices manufactured by ViewSonic of Walnut Calif. or the devices manufactured by Toshiba America Inc. of New York N.Y. In still other embodiments the client machine is a combination PDA telephone device such as the Treo devices manufactured by palmOne Inc. of Milpitas Calif. In still further embodiments the client machine is a cellular telephone that operates under control of the PocketPC operating system such as those manufactured by Motorola Corp.

In some embodiments a client machine communicates with a remote machine to determine an enumeration of resources available to the client machine or to a user of the client machine . Resources may include without limitation computing environments applications documents and hardware resources. In another of these embodiments the remote machine provides the client machine with address information associated with a remote machine hosting a resource identified by the enumeration of resources. In still another of these embodiments the client machine communicates with the remote machine to access the identified resource. In one embodiment the client machine executes a resource neighborhood application to communicate with the remote machines and . In some embodiments each of the remote machines provides the functionality required to identify and provide address information associated with a remote machine hosting a requested resource.

Referring now to a block diagram depicts one embodiment of a system for providing access to a resource. In brief overview a request to enumerate computing resources is transmitted from a client machine step . In some embodiments the request includes an identification of a user of the client machine . An enumeration of a plurality of resources available to the user of the requesting machine is provided by the remote machine step . The client machine transmits a request for access to a particular resource included in the enumeration step .

Still referring to and in more detail the transmitted request is a request for an enumeration of computing environments available to the client machine . In another embodiment the request is a request for an enumeration of computing environments supporting a particular application requested for execution by the client machine . In still another embodiment the request is a request for access to a computing environment supported by a particular plurality of hardware resources.

In some embodiments information associated with the client machine or with a user of the client machine is received with the request. In one of these embodiments credentials associated with the user or with a user of the client machine are received. In one embodiment the remote machine receives a request for an enumeration of available computing environments from the client machine with the information associated with the client machine or the user of the client machine . In another embodiment the remote machine receives a transmission from a policy engine including the information. In still another embodiment the remote machine receives a transmission from a collection agent including the information. In yet another embodiment the remote machine comprises a component receiving requests and associated information.

In some embodiments a remote machine functioning as a web server receives communications from the client machine . In one of these embodiments the web server forwards the communications to a remote machine . In one of these embodiments the web server forwards the communications to a service on the remote machine . In another of these embodiments where communications from the client machine are routed to a remote machine by the web server the remote machine may be selected responsive to an Internet Protocol IP address of the client machine .

In some embodiments the user provides credentials to the remote machine via a graphical user interface presented to the client machine by the remote machine . In other embodiments a remote machine having the functionality of a web server provides the graphical user interface to the client machine . In still other embodiments a collection agent transmitted to the client machine by the remote machine gathers the credentials from the client machine .

In some embodiments collected data regarding available resources is accessed. In some of these embodiments collected data regarding computing environments is accessed. In some of these embodiments the accessed data includes an indication of a virtual machine providing access to one of the computing environments. In one of these embodiments the accessed data includes an indication of a location of the virtual machine. In other embodiments the accessed data concerning computing environments includes an indication of a plurality of hardware resources required to support the computing environments. In still other embodiments the accessed data concerning computing environments includes an indication of a user or type of user authorized to access the computing environments. In yet other embodiments the accessed data is provided responsive to a request for identification of a computing environment providing access to an application program.

In some embodiments the collected data is stored on a server such as a remote machine . In other embodiments the server is in communication with a database storing the collected data. In still other embodiments the server collects the data from a plurality of machines in a machine farm . In one of these embodiments the data is received from at least one server responsive to a request for the information concerning the computing environments. In another of these embodiments the server collects the data from a hypervisor executing on a machine in the machine farm . In still another of these embodiments the server collects the data from a management component residing in a guest operating system provided by a virtual machine launched into a hypervisor executing on a machine in the machine farm .

In some embodiments the data is collected by an intermediate brokering machine. In one of these embodiments the brokering machine maintains a database of a status of at least one computing environments and collects information from at least one machine providing access to at least one computing environments. In another of these embodiments the brokering machine collects information from a virtual machine service component residing in a virtual machine providing the computing environments. In still another of these embodiments the brokering machine collects information from a virtual machine providing management functionality for a virtual machine providing a computing environment. In yet another of these embodiments the brokering machine collects information from a hypervisor on which an executing virtual machine provides a computing environment. In other embodiments the brokering machine comprises a machine including a brokering module.

In some embodiments a determination is made for each available computing environment as to whether that computing environment is available to a user of the client system. In other embodiments data is gathered about the client system and a data set is generated from the gathered information. In one of these embodiments the accessed data is transmitted to the client system with an indication to the client system made responsive to the generated data set of each computing environment available to the client system. In another of these embodiments the accessed data is transmitted to the client system indicating to the client system responsive to the application of a policy to the generated data set each computing environment available to the client system. In still another of these embodiments the indication includes at least one method of access available to the user seeking access to the computing environment. In yet another of these embodiments the indication includes at least one type of action associated with the computing environment which may be taken by or on behalf of the user of the client system.

An enumeration of a plurality of resources available to the client machine is provided step . In one embodiment the enumeration is provided responsive to an application of a policy to received information associated with the user of the client machine or the remote machine . In another embodiment the enumeration is provided responsive to a request from the user for a particular type of computing environment. In still another embodiment the enumeration is provided responsive to a request from the user for computing environments providing access to a type of application program. In yet another embodiment the enumeration is provided responsive to a request from the user for computing environments supported by a specified plurality of hardware resources.

In some embodiments an indication is transmitted to the client machine of a plurality of computing environments available to a user of the client machine . In one of these embodiments the indication is generated responsive to accessing collected data associated with the plurality of computing environments. In another of these embodiments the accessed data is transmitted to the client machine with an enumeration of computing environments available to the client machine . In some embodiments a determination is made for each stored computing environment as to whether that computing environment is available to the client machine . In one embodiment the collected information is transmitted to the client machine the transmitted information displayable at the client machine as icons in a graphical user interface window representing computing environments available to the client system. In another embodiment the collected information is transmitted to the client machine the transmitted information displayable at the client machine as icons in a graphical user interface window representing computing environments unavailable to the client machine .

In some embodiments an enumeration of available computing environments is presented to a user of the client machine . In other embodiments an enumeration of applications is presented to a user of the client machine . In one of these embodiments a physical machine provides access to an enumerated application. In another of these embodiments a virtual machine provides access to an enumerated application. In still another of these embodiments a virtual machine provides access to a computing environment from which a user of the client machine may access the application. In still other embodiments an enumeration of standard operating environments such as a guest operating system pre configured with a plurality of application programs is provided to the user of the client machine .

In some embodiments the enumeration of available resources includes an enumeration of a plurality of actions associated with a requested resource. In one of these embodiments the enumeration of the plurality of actions enables the user to request execution of a computing environment. In another of these embodiments the enumeration of the plurality of actions enables the user to request cloning of a computing environment. In still another of these embodiments the enumeration of the plurality of actions enables the user to request shutdown of a computing environment. In yet another of these embodiments the enumeration of the plurality of actions enables the user to request that a computing environment be rebooted. In some embodiments the enumeration of the plurality of actions enables the user to request that a snapshot be taken of an existing state of a computing environment. In other embodiments the enumeration of the plurality of actions enables the user to request that a previous snapshot of a computing environment be provided.

A request is transmitted for access to a particular resource step . In one embodiment a user of the client machine requests a resource responsive to a received enumeration of available resources. In another embodiment the user requests a resource independent of a received enumeration. In some embodiments the user requests a resource by selecting a graphical representation of the resource presented on the client machine by a client agent. In other embodiments the user requests a resource by selecting a graphical or textual representation of the resource presented to the user on a web server or other remote machine .

In some embodiments the user requests an action associated with a resource. In one of these embodiments the user requests execution of the resource. In another of these embodiments the user requests termination of the resource. In still another of these embodiments the user requests transmission of the resource including transmission across an application streaming session. In yet another of these embodiments the user requests that a resource be shutdown. In other embodiments a request to execute an application is received from the client machine the requested application requiring one of the computing environments. In still other embodiments a request to access a file is received from the client machine the requested file requiring execution within one of the computing environments.

Still referring to a remote machine launches the Resource Neighborhood RN application and presents results of the RN application to the client machine . The remote machine can launch the RN application in response to a request by the client machine for an enumeration of available resources. The remote machine provides an enumeration of available resources to the client machine step . The client machine and remote machine establish a connection arrows and . By this connection the remote machine can transfer the executable code of the particular application to the client machine when the client machine and remote machine are operating according to the client based computing model. Alternatively the remote machine can execute the particular application and transfer the graphical user interface to the client machine when the client machine and remote machine are operating according to the server based computing model. In some embodiments the remote machine can execute the Resource Neighborhood application and push the results back to the client machine so that when the client machine requests the Resource Neighborhood application the Resource Neighborhood results are already available at the client machine .

The client machine via the web browser transmits a request to access a Uniform Resource Locator URL address corresponding to an HTML page residing on remote machine . In some embodiments the first HTML page returned to the client machine by the remote machine is an authentication page that seeks to identify the client machine or the user of the client machine .

The authentication page allows the client machine to transmit user credentials via the web browser to the remote machine for authentication. Transmitted user credentials are verified either by the remote machine or by another remote machine in the farm . This allows a security domain to be projected onto the remote machine . For example if the remote machine runs the WINDOWS NT operating system manufactured by Microsoft Corporation of Redmond Wash. and the authenticating machine runs the UNIX operating system the UNIX security domain may be said to have been projected onto the remote machine . User credentials may be transmitted in the clear or they may be encrypted. For example user credentials may be transmitted via a Secure Socket Layer SSL connection which encrypts data using algorithms such as the RC4 algorithm manufactured by RSA Security Inc. of Bedford Mass.

In some embodiments an access control decision is made based on received information about the user resources available to the user of the client system are identified responsive to the access control decision. In other embodiments a policy is applied to the received information about the user. The remote machine may verify the user credentials received from the client machine . Alternatively the remote machine may pass the user credentials to another remote machine for authentication. In this embodiment the authenticating server may be in a different domain from the remote machine . Authenticated user credentials of the client machine may be stored at the client machine in a per session cookie in fields that are not displayed by the web browser or in any other manner common in maintenance of web pages. In some embodiments a machine farm with which the remote machine is associated may allow guest users i.e. users that do not have assigned user credentials to access resources hosted by the farm . In these embodiments the authentication page may provide a mechanism for allowing a client machine to identify that it is a guest user such as a button or menu selection. In other of these embodiments the remote machine may omit the authentication page entirely.

Still referring to once the client machine is authenticated by the remote machine the remote machine prepares and transmits to the client machine an HTML page that includes a Resource Neighborhood window in which appears graphical icons representing resources to which the client machine has access. A user of client machine requests access to a resource represented by icon by clicking that icon .

In this embodiment the Resource Neighborhood application not shown on runs on the client machine . The client machine display has a Resource Neighborhood window in which appears a graphical icon representing a second resource. A user of the client machine can access the second resource by double clicking the icon with the mouse. The request passes to the remote machine via connection . The remote machine indicates to the client machine via connection that the sought after resource is available on remote machine . The client machine signals the remote machine to establish a second connection . The remote machine requests the user credentials from the client machine to authenticate access to the second resource. Upon a successful authentication the client machine and remote machine establish the second connection and exchange information regarding status of or execution of the second resource. In some embodiments the remote machine does not request user credentials to establish the second connection . In these embodiments the remote machine may use the credentials supplied by the user of client machine to establish the connection to also establish the second connection . Accordingly the client machine and the remote machine communicate with each other over multiple connections.

In this embodiment the Resource Neighborhood application runs on the remote machine . The remote machine includes software providing a server based client engine enabling the remote machine to operate in the capacity of the client machine . The client machine display has a Resource Neighborhood window in which appear graphical icons representing a second resource and a third resource respectively. A user of the client machine can access the second resource by double clicking the icon . The request to launch the second resource passes to the remote machine via active connection and the remote machine forwards the request to the master remote machine arrow .

The master remote machine indicates arrow to the remote machine that the sought after resource is available on server . The remote machine contacts the server to establish a connection . To authenticate access to the application the server obtains the user credentials of the client machine from the remote machine . The remote machine and server establish the connection arrow by which the remote machine requests access to the second resource and the server returns the results to the remote machine . The remote machine forwards the results to the client machine where the results are displayed. Accordingly the information exchanged between the client machine and the server passes through the remote machine .

Similarly the client machine can launch the third resource by double clicking the icon . The request to launch the third resource passes to the remote machine . The remote machine forwards the request to the master remote machine . In this example the master remote machine indicates that the server can be used to access the third resource.

The remote machine and the server establish a connection arrow by which the remote machine requests access to the third resource and the server returns the results to the remote machine . To permit access to the third resource the server can authenticate the user credentials of the user of the client machine which are obtained from the remote machine . The remote machine forwards the results to the client machine where the results are displayed. Accordingly the results of accessing the third resource pass between the client machine and the server through the remote machine .

In this embodiment the Resource Neighborhood application runs on the server . The client machine display has a Resource Neighborhood window in which appears a graphical icon representing a second resource. A user of the client machine can access the second resource by double clicking the icon . The request to access the second resource passes to the server . The server responds i.e. calls back to the client machine by returning resource related information such as the name of the resource and capabilities needed by the client machine to access the second application.

With the information provided by the server the client machine then communicates with the master remote machine via connection to determine the server for accessing the second resource. In this example that server is server . The client machine then establishes a connection to the server . Server requests the user credentials from the client machine to authenticate the user of the client machine . The client machine accesses the second resource on the server and the server returns the results to the client machine via the established connection . Accordingly the client machine can have multiple active connections between the multiple servers.

In this embodiment the template is a standard SGML HTML or XML document containing Resource Neighborhood specific tags that are replaced with dynamic information. The tags indicate to the server where in the output display to insert information corresponding to available resources such as icon images. In one particular embodiment the Resource Neighborhood specific tags are embedded within comments inside a file allowing the file to remain compatible with standard interpreters. In another embodiment the Resource Neighborhood specific tags are extensions of the markup language used as the base for the template.

Other tags can be provided to set control fields and to provide conditional processing relating to the Resource Neighborhood application.

In one embodiment the template is constructed dynamically using for example COLD FUSION manufactured by Allaire Corp. of Cambridge Mass. or ACTIVE SERVER PAGES manufactured by Microsoft Corporation of Redmond Wash. Alternatively the template may be static. The Resource Neighborhood application parses the template replacing Resource Neighborhood specific tags as noted above. Tags that are not Resource Neighborhood specific are left in the file to be parsed by the browser program executing on the client .

In one embodiment a template parser object is provided that accepts an HTML template as input interprets Resource Neighborhood specific tags present in the template and outputs the original template with all Resource Neighborhood tags replaced with appropriate text. The template parser object can be passed a cookie a URL query string or a control field from a web server interface to provide the information with which Resource Neighborhood specific tags should be replaced.

In some embodiments a web server receives a request from the client machine for an enumeration of available computing environments. In one of these embodiments the web server executes an application to access data regarding the computing environments. In another of these embodiments a page template is retrieved from a database. In still of these embodiments a page is created at the web server describing a display of stored computing environment images available to the client machine responsive to the collected information and the retrieved page template and the created page is transmitted to the client machine indicating to the client machine each computing environment available to the client machine . In some embodiments computing environment images may comprise virtual machine images resource images screenshots of suspended virtual machines and other images selected by a user or administrator for presentation to the user. In yet another of these embodiments an output display is created indicating each computing environment available to the client machine and transmitting the created output display to the client machine .

In some embodiments an output display is created comprising a page constructed in a markup language the output display indicating each computing environment available to the client system and transmitted to the client system.

In another embodiment the Resource Neighborhood application allows scripts to access information via an application programming interface. Scripts may be written in for example VBScript or Jscript. In this embodiment the scripting language is used to dynamically generate an output display using information returned by the application in response to queries posed by the script. Once the output display is generated it is transmitted to client machine for display by the browser program .

A user of the client machine can access a resource by clicking an icon displayed in the Resource Neighborhood web page. In some embodiments each icon is associated with an encoded URL that specifies the location of the resource i.e. on which remote machines it is hosted or alternatively the address of a master remote machine a gateway or other remote machine a launch command associated with the resource and a template identifying how the results of accessing the resource should be displayed i.e. in a window embedded in the browser or in a separate window . In some embodiments the URL includes a file or a reference to a file that contains the information necessary for the client to create a connection to the remote machine hosting the resource. This file may be created by the Resource Neighborhood application dynamically. The client machine establishes a connection arrow with the remote machine identified as hosting the requested resource and exchanges information regarding access to the desired resource. In some embodiments the connection is made using the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the connection is made using the RDP protocol manufactured by Microsoft Corp. of Redmond Wash. the X11 protocol or the Virtual Network Computing VNC protocol manufactured by AT T Bell Labs. Thus the client machine may display the results of accessing the resource in a window separate from the web browser or it may embed application output within the web browser.

The broker module accesses collected data regarding resources including application programs computing environments and hardware resources. In some embodiments the broker module accesses collected data regarding resources and determines for each resource whether that resource image is available to a client machine . In some embodiments the server further comprises a database storing the collected data. In one of these embodiments the broker module determines for each resource whether that resource image is available to a client machine based on the collected data. In other embodiments the broker module receives user credentials and determines for each resource whether that resource image is available to a client machine based on the user credentials and the collected data.

In some embodiments the server further comprises an output display creation engine creating output displays indicating each resource available to the client machine . In one of these environments the output display creation engine creates a page describing a display of the resources available to a client system the page created responsive to the collected information and a page template.

The transmitter transmits accessed data to the client machine indicating to the client machine each resource determined to be available to the client machine . In some embodiments the transmitted data is displayable at the client system as icons in a graphical user interface window representing resources available to the client system. In other embodiments the transmitted data is displayable at the client system as icons in a graphical user interface window representing resources unavailable to the client system. The receiver receives a request to access one of the available resources. In some embodiments the receiver receives user credentials from the client machine . In other embodiments the receiver receives a request to access an application program available through one of the available resources such as an available computing environment. In still other embodiments a database storing the collected information and the service module determines for each resource stored by the plurality of servers whether that resource image is available to a client machine based on the user credentials and the collected information. In yet other embodiments a determination is made as to an availability of resources such as virtual machines or application servers providing access to the available resources.

The transceiver provides a connection between the client machine and a virtual machine providing the requested resource. In some embodiments the transceiver provides a connection between the client machine and a virtual machine providing the requested resource and the transceiver establishes a presentation layer protocol connection. In one of these embodiments the transceiver establishes an X11 or VNC connection. In another of these embodiments the transceiver establishes an ICA connection. In still another of these embodiments the transceiver establishes an RDP connection.

An intermediary machine of the sort just described may be used as any one of the remote machine described above in A B and A D.

The remote machine for example includes the service component RNSVC and the resource authorization cache . The client machine which is a representative example of a client machine that can support a client based implementation of the Resource Neighborhood application includes the application program interface RNAPI the user interface user interface component and the local cache components. The RNAPI communicates with the user interface component and the local cache . The RNSVC communicates with the resource authorization cache and with the RNAPI on the client machine via communications link .

The communications link can be established by for example using the ICA protocol the RDP protocol the X11 protocol the VNC protocol or any other suitable presentation level protocol designed to run over industry standard transport protocols such as TCP IP IPX SPX NetBEUI using industry standard network protocols such as ISDN frame relay and asynchronous transfer mode ATM and which provides for virtual channels which are session oriented transmission connections that can be used by application layer code to issue commands for exchanging data. The communications link may also be established by protocols that support RPC or RPC equivalents such as SOAP and HTTP. The communications link may also be a communications link as described above. The virtual channel commands are designed to be closely integrated with the functions of client machines. The ICA protocol can support the Resource Neighborhood virtual channel.

 2 Single authentication related commands that can be supported by each client machine wanting a copy of the user credentials 

The resource authorization cache may be a cache of the authorized user and group information for all the public i.e. published resources in a machine farm or in a group of trusted domains. Each remote machine in a machine farm can maintain its own resource related information in persistent storage and build up the resource authorization cache in volatile storage. In another embodiment all collected resource related information in the resource authorization cache can be stored in persistent storage and made accessible to each other server in the machine farm . The resource authorization cache can be implemented in a proprietary format e.g. as a linked list in memory or using Novell s Directory Services NDS or any directory service adhering to the X.500 standard defined by the International Telecommunication Union ITU for distributed electronic directories. The resource authorization cache may be implemented as a standard relational database.

The resource authorization cache includes a list of remote machines. Each remote machine in the list has an associated set of resources. Associated with each resource is resource related information that can include the resource name a list of remote machines and client users that are authorized to use that resource. An overly simplified example of the resource related information maintained in the database is illustrated by the following Table 2. Users A and B are users of the client machines n a indicates that a desired application program is hosted but is not available to client machine users and indicates that the application program is not hosted.

Table 2 shows a list of servers applications hosted by the servers Spreadsheet Customer Database Word Processor and Calculator and those users who are authorized to use the applications. For example the server hosts the Spreadsheet program the Customer Database and the Word Processor. User A is authorized to use the Spreadsheet User B is authorized to use the Customer Database and no users are authorized to use the Word Processor. It is to be understood that other techniques can be used to indicate who is authorized to use a particular application. For example the user information stored in the database can be used to indicate those users who are unauthorized to use a particular application rather than those who are authorized or to indicate that multiple users may access a resource on a remote machine or to indicate that a predetermined group of users are authorized to access a particular resource. Although Table 2 depicts an embodiment in which the resources that are available are application programs a similar technique may be used for computing environments and other resources.

To obtain the information that is stored in the resource authorization cache the remote machine obtains the resource related information from each other machine in the machine farm regarding the resources on those remote machines including control information that indicates which client users and remote machines are permitted to access each particular resource. The resource related information maintained in the database may or may not persist across re boots of the remote machine .

Each remote machine having the Resource Neighborhood application installed thereon executes the RNSVC software . The RNSVC software operating on each remote machine establishes a communication link e.g. a named pipe with at least one other and in some embodiments each other remote machine . The remote machines exchange resource related information on the communications links. In another embodiment the RNSVC software collects the resource related information from the other remote machine in the machine farm through remote registry calls e.g. the service component transmits a datagram to other remote machine in the farm requesting the resource related information corresponding to the resources hosted by those remote machine . In some embodiments the resource authorization cache is populated by system administrators of by programs and scripts communicating with remotes machines . The RNSVC software also maintains the relationships of groups and users to published resources in the resource authorization cache and accesses the information when authenticating a client user. An administrator of the remote machine can use a user interface to configure the RNSVC .

Other functions of the RNSVC software include implementing the services and functions requested by the RNAPI and communicating with the RNAPI on the client machine using a Resource Neighborhood virtual channel driver VCRN . The VCRN operates according to the Resource Neighborhood virtual channel protocol described.

The RNAPI is a set of software functions or services that are used by the Resource Neighborhood application to perform various operations e.g. open windows on a display screen open files and display message boxes . The RNAPI provides a generic mechanism for accessing user interface elements e.g. icons produced by running the Resource Neighborhood application and objects in a legacy i.e. predecessor or existing for some time client user interface. When the client machine accesses an available resource the accessing mechanism can launch the resource on the remote machine if necessary e.g. when the client machine is unable to locally execute the application .

The RNAPI provides all published resource information to the user interface component for display on the screen of the client machine . The RNAPI also manages machine farm logons in a local database of logon credentials e.g. passwords for users of the client machine to support the single authentication feature. Credentials may or may not be persistent across a reboot power off and on cycles of the client machine .

The RNAPI provides automatic and manual management for Resource Neighborhood objects stored in the local cache . The local cache can either be refreshed manually by the user of the client machine or at a user definable refresh rate or by the server at any time during a connection. In a Windows implementation the RNAPI can build remote application file resource associations and manage the Start menu and desktop icons for resource object shortcuts.

The user interface module interfaces the RNAPI and can be a functional superset of an existing client user interface e.g. Remote Resource Manager . The user interface module accesses the information stored in the local cache through the RNAPI and visually presents that information to the user on the display screen of the client machine . The displayed information is a mixture of information generated by a user of the client machine and information obtained by the Resource Neighborhood application. The user interface module can also show the user all resources that the user is currently accessing and all active and disconnected sessions.

In a Windows based embodiment the user interface module can present a variety of graphical components such as windows and pull down menus to be displayed on the display screen . A display of a combination of such graphical user interface components is generally referred to as a desktop. A desktop produced by the user interface module can include a Resource Neighborhood window displaying the neighborhood of resources available to the user of the client machine . These resources may be a filtered combination of the published resources hosted by a machine farm . The user interface module can generate a Resource Neighborhood window for each machine farm or merge the resources from different machine farms under a single Resource Neighborhood window.

At a top level the Resource Neighborhood window includes a folder for each machine farm . Clicking on one of the folders produces a window containing a representation e.g. an icon of each hosted resource available to the user e.g. see . The Resource Neighborhood window becomes the focal point for accessing published resources and the user interface module can be used to access resources and launch applications through the RNAPI . For example the user of the client machine can use the mouse to select one of the displayed icons and launch the associated resource.

A feature of a client based implementation is that the user can browse the objects displayed in the Resource Neighborhood window although the client machine is offline that is the connection is inactive. Also a user of the client machine can drag application objects and folders out of the Resource Neighborhood window and into other graphical components e.g. other windows folders etc. of the desktop.

Similar to that described in for the client machine the client machine logs on to the network the server develops and maintains a database containing the resource related information collected from the other machines in the machine farm and a communication link is established between the server and the client machine . The application server may be in communication with the client machine via an ICA connection .

To run the Resource Neighborhood application in a server based implementation the user of the client machine connects to an initial desktop at the server and launches the Resource Neighborhood application from within that desktop environment. The connection to the initial desktop can occur automatically e.g. via a logon script of the client machine via an entry in a Startup group or by another centrally managed server specific mechanism. All remote application management and launching is accomplished through this initial desktop.

Similar to that described in for the server the server uses the user credentials to determine those resources that the user of the client machine is authorized to use. A Resource Neighborhood graphical window is returned to the client machine and displayed on the client screen . This window can contain icons representing the available and possibly the unavailable resources that are in the Resource Neighborhood of the client machine .

In one embodiment the web based Resource Neighborhood application includes a group of objects that manage various aspects of a resource. In one embodiment the Resource Neighborhood application includes three primary object classes that plug in to a web server a gateway object class a credentials object class and a resources object class. In some specific embodiments the object classes are provided as JavaBeans. The three primary object classes facilitate validation of user credentials into a server farm generation of lists of published resources that a specified user may access provisioning of detailed information about a specific published resource and conversion of resource application information into a format compatible with the protocol over which connection will be made.

When provided as JavaBeans the objects can be accessed in a number of different ways. For example they may be compiled as COM objects and made available to the web server as ActiveX components. In another embodiment the JavaBeans can be used in their native form such as when the server uses Java Server Pages technology. In yet another embodiment the JavaBeans can be instantiated and used directly in a Java Servlet. In still another embodiment the remote machine can instantiate the JavaBeans as COM objects directly.

A credentials object class manages information necessary to authenticate a user into a target machine farm . A credentials object passes stored user credentials to other Resource Neighborhood objects. In some embodiments the credentials object is an abstract class that cannot be instantiated and represents a user s credentials. Various class extensions may be provided to allow different authentication mechanisms to be used including biometrics smart cards token based authentication mechanisms such as challenge response and time based password generation or others. For example a clear text credentials extension may be provided that stores a user s name domain and password in plain text.

A gateway object class handles communications with a target machine farm . In one embodiment the gateway object class is provided as an abstract Java class that cannot be instantiated. A particular gateway object may retrieve resource information by communicating with a machine farm using a particular protocol reading cached resource information a combination of these two methods or other various methods.

As noted above the gateway object class may cache information to minimize communication with a target machine farm . Extensions to the gateway object may be provided to communicate with the machine farm over specific protocols such as HTTP. In one embodiment an extension class is provided that allows the gateway object to communicate with the machine farm via WINDOWS NT named pipes. The gateway object may provide an application programming interface hook that allows other Resource Neighborhood objects to query the object for application information.

A resources object class contains information about published resources and returns information about resources hosted by the machine farm in order to create the Resource Neighborhood web page. The resources object class creates objects representing resources by retrieving information relating to the resources either from an object created by the gateway object or directly from the machines in the machine farm . A resources object acts as a container for certain properties of the resource some settable and some not settable such as the name of the resource not settable the width of the client window in pixels for this resource settable the height of the client window in pixels for this resource settable the number of colors to use when connecting to the resource settable the severity of audio bandwidth restriction settable the level of encryption to use when connecting to the resource settable the level of video to use when connecting to this resource settable whether the resource should be placed on a client s start menu settable whether the resource should be placed on the client s desktop settable the identity of the Resource Neighborhood folder to which the resource belongs settable the description of the resource settable the source of the graphics icon file for the resource settable the type of window that should be used when connecting to the resource not settable and whether to override default parameters for the object.

Each resource represented by one of the icons is unavailable to the user of the client machine although such resources are present in the server farm. The unavailability of these resources can be noted on the display screen e.g. X s can be drawn through the icons . An attempt to access such a resource can trigger a message indicating that the user is not authorized to access the resource. Alternatively the attempt may invoke a method allowing the user of the client machine to request access to the resource.

In some embodiments the resource comprises a computing environment. In one of these embodiments a connection is established between the client machine and a virtual machine hosting the requested computing environment. In one embodiment a presentation layer protocol is used in establishing the connection between the client system and the virtual machine. In another embodiment the X11 protocol is used in establishing the connection. In still another embodiment the Remote Desktop Protocol RDP is used in establishing the connection. In yet another embodiment the Independent Computing Architecture ICA protocol is used in establishing the connection.

In some embodiments a connection is established between the client machine and a physical machine such as a traditional workstation or server hosting the requested computing environment. In other embodiments a connection is established between the client machine and a hardware partition hosting the requested computing environment.

In some embodiments an enumeration of a plurality of resources available to the client machine is provided step responsive to a determination by a policy engine regarding whether and how a client machine may access a resource. The policy engine may collect information about the client machine prior to making the determination. Referring now to one embodiment of a computer network is depicted which includes a client machine a machine farm a collection agent a policy engine a policy database and a resource server . In one embodiment the policy engine is a remote machine . Although only one client machine collection agent policy engine machine farm and resource server are depicted in the embodiment shown in it should be understood that the system may provide multiple ones of any or each of those components.

In brief overview when the client machine transmits the policy engine a request for a resource enumeration the collection agent communicates with the client machine retrieving information about the client machine and transmits the client machine information to the policy engine . The policy engine makes an access control decision by applying a policy from the policy database to the received information .

In more detail the client machine transmits to the policy engine a request for resource enumeration. In one embodiment the policy engine resides on a resource server . In another embodiment the policy engine resides on a remote machine . In still another embodiment a resource server receives the request from the client machine and transmits the request to the policy engine . In yet another embodiment the client machine transmits a request for resource enumeration to an intermediate remote machine not shown which transmits the request to the policy engine .

In some embodiments the client machine transmits the request over a network connection such as those described above. Upon receiving the request the policy engine initiates information gathering by the collection agent . The collection agent gathers information regarding the client machine and transmits the information to the policy engine .

In some embodiments the collection agent gathers and transmits the information over a network connection. In some embodiments the collection agent comprises bytecode such as an application written in the bytecode programming language JAVA. In some embodiments the collection agent comprises at least one script. In those embodiments the collection agent gathers information by running at least one script on the client machine . In some embodiments the collection agent comprises an Active X control on the client machine . An Active X control is a specialized Component Object Model COM object that implements a set of interfaces that enable it to look and act like a control.

In one embodiment the policy engine transmits the collection agent to the client machine . In some embodiments the policy engine requires another execution of the collection agent after the collection agent has transmitted information to the policy engine . In some of these embodiments the policy engine requires another execution of the collection agent because the policy engine may have insufficient information to determine whether the client machine satisfies a particular condition. In other embodiments the policy engine requires a plurality of executions of the collection agent in response to received information .

In some embodiments the policy engine transmits instructions to the collection agent determining the type of information the collection agent gathers from the client machine . In those embodiments a system administrator may configure the instructions transmitted to the collection agent from the policy engine . This provides greater control over the type of information collected. This also expands the types of access control decisions that the policy engine can make due to the greater control over the type of information collected. The collection agent gathers information including without limitation machine ID of the client machine operating system type existence of a patch to an operating system MAC addresses of installed network cards a digital watermark on the client device membership in an Active Directory existence of a virus scanner existence of a personal firewall an HTTP header browser type device type network connection information such as internet protocol address or range of addresses machine ID of the remote machine date or time of access request including adjustments for varying time zones and authorization credentials.

In some embodiments the device type is a personal digital assistant. In other embodiments the device type is a cellular telephone. In other embodiments the device type is a laptop computer. In other embodiments the device type is a desktop computer. In other embodiments the device type is an Internet kiosk. In still other embodiments the device type is a game console.

In some embodiments the digital watermark includes data embedding. In some embodiments the watermark comprises a pattern of data inserted into a file to provide source information about the file. In other embodiments the watermark comprises hashed data files to provide tamper detection. In other embodiments the watermark provides copyright information about the file.

In some embodiments the network connection information pertains to bandwidth capabilities. In other embodiments the network connection information pertains to the Internet Protocol address of the client machine . In still other embodiments the network connection information consists of the Internet Protocol address of the client machine . In one embodiment the network connection information comprises a network zone identifying the logon agent to which the client machine provided authentication credentials.

In some embodiments the authorization credentials include a number of types of authentication information including without limitation user names client names client addresses passwords Personal Identification Numbers PINs voice samples one time passcodes biometric data digital certificates tickets etc. and combinations thereof. After receiving the gathered information the policy engine makes an access control decision based on the received information .

Referring now to a block diagram depicts one embodiment of a policy engine including a first component including a condition database and a logon agent and a second component including a policy database . The first component applies a condition from the condition database to information received about client machine and determines whether the received information satisfies the condition.

In some embodiments a condition may require that the client machine execute a particular operating system to satisfy the condition. In other embodiments a condition may require that the client machine execute a particular operating system patch to satisfy the condition. In still other embodiments a condition may require that the client machine provide a MAC address for each installed network card to satisfy the condition. In some embodiments a condition may require that the client machine indicate membership in a particular Active Directory to satisfy the condition. In another embodiment a condition may require that the client machine execute a virus scanner to satisfy the condition. In other embodiments a condition may require that the client machine execute a personal firewall to satisfy the condition. In some embodiments a condition may require that the client machine comprise a particular device type to satisfy the condition. In other embodiments a condition may require that the client machine establish a particular type of network connection to satisfy the condition.

If the received information satisfies a condition the first component stores an identifier for that condition in a data set . In one embodiment the received information satisfies a condition if the information makes the condition true. For example a condition may require that a particular operating system be installed. If the client machine has that operating system the condition is true and satisfied. In another embodiment the received information satisfies a condition if the information makes the condition false. For example a condition may address whether spyware exists on the client machine . If the client machine does not contain spyware the condition is false and satisfied.

In some embodiments the logon agent resides outside of the policy engine . In other embodiments the logon agent resides on the policy engine . In one embodiment the first component includes a logon agent which initiates the information gathering about client machine . In some embodiments the logon agent further comprises a data store. In these embodiments the data store includes the conditions for which the collection agent may gather information. This data store is distinct from the condition database .

In some embodiments the logon agent initiates information gathering by executing the collection agent . In other embodiments the logon agent initiates information gathering by transmitting the collection agent to the client machine for execution on the client machine . In still other embodiments the logon agent initiates additional information gathering after receiving information . In one embodiment the logon agent also receives the information . In this embodiment the logon agent generates the data set based upon the received information . In some embodiments the logon agent generates the data set by applying a condition from the database to the information received from the collection agent .

In another embodiment the first component includes a plurality of logon agents . In this embodiment at least one of the plurality of logon agents resides on each network domain from which a client machine may transmit a resource request . In this embodiment the client machine transmits the resource request to a particular logon agent . In some embodiments the logon agent transmits to the policy engine the network domain from which the client machine accessed the logon agent . In one embodiment the network domain from which the client machine accesses a logon agent is referred to as the network zone of the client machine .

The condition database stores the conditions that the first component applies to received information. The policy database stores the policies that the second component applies to the received data set . In some embodiments the condition database and the policy database store data in an ODBC compliant database. For example the condition database and the policy database may be provided as an ORACLE database manufactured by Oracle Corporation of Redwood Shores Calif. In other embodiments the condition database and the policy database can be a Microsoft ACCESS database or a Microsoft SQL Server database manufactured by Microsoft Corporation of Redmond Wash.

After the first component applies the received information to each condition in the condition database the first component transmits the data set to second component . In one embodiment the first component transmits only the data set to the second component . Therefore in this embodiment the second component does not receive information only identifiers for satisfied conditions. The second component receives the data set and makes an access control decision by applying a policy from the policy database based upon the conditions identified within data set .

In one embodiment policy database stores the policies applied to the received information . In one embodiment the policies stored in the policy database are specified at least in part by the system administrator. In another embodiment a user specifies at least some of the policies stored in the policy database . The user specified policy or policies are stored as preferences. The policy database can be stored in volatile or non volatile memory or for example distributed through multiple servers.

Using the policy engine as just described an access control decision based upon information received about a client machine is made. Upon receiving gathered information about the client machine the policy engine generates a data set based upon the information. The data set contains identifiers for each condition satisfied by the received information . The policy engine applies a policy to each identified condition within the data set . That application yields an enumeration of resources which the client machine may access. In some embodiments the enumeration of resources includes an enumeration of levels of access to the resource. In one of these embodiments a plurality of allowable actions associated with the resource is enumerated. In another of these embodiments a plurality of methods of execution of the resource is enumerated. The policy engine then presents that enumeration to the client machine . In some embodiments as described above in connection with the policy engine creates a Hypertext Markup Language HTML document used to present the enumeration to the client machine.

In some embodiments the policy engine transmits the enumeration to a different remote machine . In one of these embodiments the remote machine transmits the enumeration to the client machine . In another of these embodiments the remote machine applies additional policies to the enumeration. In still another of these embodiments the remote machine is an appliance such as an application gateway or a firewall. In some of these embodiments the policy engine transmits an assigned level of action applicable to a requested resource to a remote machine functioning as a broker server. The broker server establishes responsive to the assigned level of access a connection between the client machine and a computing environment providing the requested resource.

Referring now to a flow diagram depicts one embodiment of the steps taken to provide access to a resource. In brief overview a request for access to a resource is received step . A method for providing access to the resource is identified step . An application execution server may be selected to provide access to the resource step . A virtualized environment may be selected to provide access to a resource step . An application streaming service may be selected to provide access to the resource step . If the virtualized environment is selected to provide access to the resource an execution machine is identified step . A virtual machine is selected step . The virtual machine is configured step . Access to the resource is provided step .

Still referring to and in more detail a request for access to a resource is received step . In one embodiment a remote machine receives the request. In some embodiments the remote machine is an intermediate broker server. In other embodiments the remote machine is a gateway. In still other embodiments the remote machine is a policy engine. In yet other embodiments the remote machine is an appliance.

In one embodiment the remote machine verifies that the user is authorized to access the resource. In still another embodiment the remote machine receives with the request information verifying authorization for access by the user.

In one embodiment the remote machine receives a request for an application program. In another embodiment the remote machine receives a request for access to a file. In yet other embodiments the remote machine receives a request for access to a computing environment. In one of these embodiments the computing environment is a desktop environment from which the client machine may execute application programs. In another of these embodiments the computing environment provides access to one or more application programs. In some embodiments the remote machine receives a request for access to a computing environment supported by a plurality of hardware requirements. In some embodiments a remote machine functioning as deployment system receives a request for access to a resource such as execution of an application program from a client machine .

A method for providing access to the resource is identified step . In one embodiment a remote machine consults a database to identify the method for providing access. In another embodiment a remote machine consults a policy or rules database to identify the method for providing access. In still another embodiment a remote machine receives from a policy engine an identification of a method to select.

For embodiments in which the resource is an application program a policy may allow execution of the application program on the client machine . In another of these embodiments a policy may enable the client machine to receive a stream of files comprising the application program. In this embodiment the stream of files may be stored and executed in an isolation environment on the client. In still another of these embodiments a policy may allow execution of the application program only on a remote machine such as an application server and require the remote machine to transmit application output data to the client machine . In yet another of these embodiments a policy may allow execution of the application program only in a computing environment hosted on a virtual machine. In either of these cases a stream of files comprising the application programs may be sent to the remote machine.

For embodiments in which the resource is a computing environment a policy may allow installation of the computing environment on the client machine . In another of these embodiments a policy may enable the client machine to access a copy of the computing environment executing in a virtual machine on a remote machine . In still another of these embodiments a policy may forbid the user of the client machine to access the requested computing environment and offer an alternative computing environment.

For embodiments in which the resource is a computing environment supported by a plurality of hardware resources a policy may enable the client machine to access a copy of the computing environment executing in a virtual machine which in turn executes on a hypervisor providing access to the requested plurality of hardware resources. In still another of these embodiments a policy may forbid the user of the client machine to access the requested computing environment and offer a computing environment supported by an alternative plurality of hardware resources.

The remote machine may choose to provide access to an application execution server which provides access to a requested application program step . The application execution server executes the application program and transmits application output data to the client machine . The application execution server may transmit the application output data over a presentation layer protocol such as X11 VNC ICA or RDP.

Referring back to step the remote machine may choose to provide access to an application streaming service capable of transmitting a requested application program to the client machine step for execution. Embodiments of application streaming services are described in greater detail below.

Referring back to step the remote machine may choose to respond to the client s request by allowing access to a computing environment provided by a virtual machine the computing environment providing access to the requested resource step . The computing environment may be provided by a virtual machine launched into a hypervisor executing on a remote machine . In other embodiments the remote machine determines to provision on the client machine a virtual machine providing access to the computing environment.

In embodiments where a remote machine determines to provide access to the requested resource via a virtualized environment the remote machine identifies an execution machine providing access to a computing environment requested by the client machine step . In one of these embodiments the remote machine identifies an execution machine capable of hosting the computing environment. In another of these embodiments the remote machine determines that the user requesting access to the computing environment lacks authorization to access the requested computing environment. The remote machine may identify an alternative computing environment which the user is authorized to access. In still another of these embodiments the remote machine identifies an execution machine on which a hypervisor provides access to a requested plurality of hardware and in which the requested computing environment may execute.

In other embodiments the remote machine is an execution machine capable of hosting the computing environment. In some of these embodiments the computing environment is installed on the execution machine. In others of these embodiments a hypervisor on the execution machine emulates a plurality of hardware resources required by the requested computing environment and the computing environment is launched in the hypervisor.

In some embodiments the remote machine identifies a remote machine functioning as an execution machine capable of providing access to the computing environment supported by a requested plurality of hardware resources. In one of these embodiments the remote machine functions as an execution machine on which a hypervisor emulating the requested plurality of hardware resources executes and on which a computing environment supported by the hypervisor executes.

In some embodiments an execution machine providing hardware resources physical or virtual capable of supporting a particular virtual machine is identified responsive to a load balancing determination. In one of these embodiments the execution machine is selected responsive to load balancing information maintained by a management server . In some embodiments the management server is a single machine. In still other embodiments several remote machines may be capable of acting as a management server but only one of such nodes is designated the management server. In some embodiments a client request is directed to the management server in the first instance. In other embodiments a remote machine queries the management server to determine the identity of a suitable execution machine.

The master network information server node maintains a table of addresses for the remote machines . In addition the master network information server node receives messages from the remote machines indicating their level of activity which may comprise CPU load or may comprise an identification of the number of a virtual machines currently hosted by a remote machine . The level of activity of the remote machines is maintained in a table along with the address of each of the remote machines .

For embodiments in which a single management server is used it is desirable to dynamically select a master network information server node from the available remote machines on the network. In this way if the active management server fails a new management server may be selected as soon as the failure of the previous management server is detected. In one embodiment a management server is selected by an election process among the remote machines .

In one embodiment any machine client machine or remote machine may force an election at any time by broadcasting a request election datagram to the machine farm . The election results are determined by a comparison of the set of election criteria which is transmitted within the request election datagram transmitted by the requesting node with the set of election criteria maintained on each receiving node. That is the first election criterion from the datagram of the requesting node is compared by the receiving node to the first criterion of the receiving node. The highest ranking of the two criteria being compared wins the comparison and the node with that criterion wins the election. If the two criteria tie then the next criteria are sequentially compared until the tie is broken. If a remote machine receiving the request election datagram has a higher election criterion than that received in the request election datagram the remote machine receiving the request election datagram issues its own request election datagram. If the receiving remote machine has a lower election criteria than the criteria received in the request election datagram the receiving remote machine determines it is not the master network information server node and attempts to determine which remote machine in the machine farm is the management server .

In one embodiment the criteria which determine the outcome of the election include whether or not the node is statically configured as a master network information server node whether the remote machine has the higher master network information server software version number whether the remote machine is an NT domain controller whether the remote machine is the longest running node and whether the remote machine has a lexically lower network name. In one embodiment the datagram structure for the election request includes an unsigned shortword for the server version number an unsigned shortword in which the bits are flags which designate whether the node is statically configured as a master network information server node or is executing on a NT domain controller and an unsigned longword containing the amount of time the server has been running.

Periodically the management server transmits a declare message to the other remote machines declaring itself to be the management server . If another remote machine believes itself to be a management server the other remote machine will request an election. In this way erroneous master network information server nodes of the same protocol are detected and removed. In addition an election will also be requested by any remote machine when that remote machine reboots by any remote machine to whom the master network information server node has failed to acknowledge an update message or any client machine to whom the master network information server node has failed to respond to a request for information.

In more detail and referring to once any remote machine which may be referred to as a node broadcasts a request election datagram requesting an election Step the remote machine receiving the request election datagram Step first compares its election criteria to the criteria in the request election datagram Step to determine if the receiving remote machine has higher criteria Step . If the remote machine receiving the datagram has lower election criteria Step than the criteria contained in the request election datagram the remote machine receiving the request election datagram drops out of the election process and awaits the results of the election Step .

If the remote machine receiving the request election datagram has higher election criteria than that contained in the request election datagram then the remote machine receiving the request election datagram broadcasts its own request election datagram containing the remote machine s own election criteria Step . If in response to the transmission of the request election datagram by the second remote machine another remote machine responds with a request election datagram with even higher election criteria then the second remote machine drops out of the election and the remote machine with higher criteria broadcasts it s own request election datagram. If no other remote machine responds with higher election criteria the node which has apparently won the election for master network information server node sends n more election requests in one embodiment three requests Step and then if still no other remote machine responds with higher election criteria the remote machine which has sent the n election requests is the new management server .

After the election has occurred and the new management server has been determined all the remote machines send all of their configured gateway addresses to the new network information server node . In this way the new management server becomes a gateway node.

Referring again to once the management server is elected the remote machines send update datagrams to the master network information server providing information about each remote machine transmitting the update datagram. In one embodiment the update datagram sent to the master network information server node from a remote machine includes the remote machine name the network address the cluster name the network transport protocol the total number of remote machines configured with this transport the number of ports available for connection with a client using this transport protocol the total number of users permitted to be active at one time number of available user slots and server load level. Upon receipt of the update datagram the master network information server node returns an acknowledgment to the remote machines that transmitted the update datagram indicating that the update datagram was received. If the remote machine transmitting the update datagram does not receive an acknowledgment from the master network information server node the transmitting remote machine assumes that the master network information server node has failed and transmits an election request.

In more detail and referring to a remote machine after the election of a management server waits a random period of time and then sends a datagram to the management server with its latest load information Step . In one embodiment the delay is between four and six seconds. If the management server receives Step an update datagram from a remote machine then the master network information server node replies to the transmitting remote machine with an acknowledgment Step and forwards the data to any remote machine configured as a gateway node. If the master network information server fails to receive data from a remote machine Step then the master network information server discards the old data from the remote machine after a predetermined amount of time Step .

If the remote machine does not receive an acknowledgment from the master network information server node after the remote machine has sent an update datagram Step the remote machine retransmits the update datagram. The remote machine will attempt n retransmits in one embodiment three before it assumes that the master network information server has failed and then transmits an election request Step . If the remote machine receives an acknowledgment then it periodically updates the master network information server node in one embodiment every 5 to 60 minutes Step .

In some embodiments a remote machine s participation in the activities just described is controlled by a virtual machine executing in the hypervisor rather than by an operating system. is a block diagram depicting one embodiment of a machine farm including a first and second network management processes. The first network management process executes in a native operating system such as WINDOWS NT and accesses a native memory element storing i a data table and ii at least one election criteria for allowing the first network management process to be dynamically selected as a management process the data table having an entry for each of said at least two network management processes. The second network management process executes in a virtualized operating system and accesses a virtualized memory element storing i a data table and ii at least one election criteria for allowing the second network management process to be dynamically selected as the management process the data table having an entry for each of said at least two network management processes. The client machine communicates with the one of the first network management process and the second network management process selected as the management process and receives from the management process an address of a remote machine with which to communicate. In some embodiments a plurality of client machines is in communication with a master network information process.

The first network management process executes in a native operating system . The second network management process executes in a virtualized operating system . In one embodiment the at least two network management processes are grouped into clusters. In another embodiment one of the at least two network processes is a gateway process. In still another embodiment the gateway process is a master network management process. In some embodiments the master network management process is selected by a process comprising the steps of a broadcasting an election datagram to the at least two network management processes the election datagram comprising election criteria and b selecting a master network management process in response to the election criteria. In one of these embodiments the master network management process broadcasts a declare datagram to detect multiple master network management processes using the same transport protocol. In another of these embodiments the master network management process is selected by a process that occurs after an event selected from the group of events consisting of a system reboot a master network management process failing to respond to a datagram sent from a network management process a master network management process failing to respond to a request from a client machine detection of at least two master network management processes configured with the same transport and a new network management process appearing on said network.

In some embodiments the network includes a third network management process using a different network transport protocol from the first network management process. In one of these embodiments the third network management process comprises a master network management process for the different network transport protocol.

For embodiments in which machine farm management is decentralized each remote machine may include a load management subsystem LMS providing a load management capability. In general the LMS manages overall server and network load to minimize response time to client requests.

In some embodiments an apparatus for selecting a server from a network plurality of servers to service a client request comprises a plurality of network management processes. In one of these embodiments each of said plurality of network management processes includes an event bus and a subsystem in communication with the event bus. In another of these embodiments a first one of the plurality of network management processes receives from a client machine a request for access to a computing resource and sends the client request to a second one of the plurality of network management processes. In still another of these embodiments the second one of the plurality of network management processes executes in a virtualized operating system and comprises a dynamic store and a load management subsystem.

The dynamic store loads information associated with at least some of the plurality of network management processes in a virtualized memory element. In some embodiments the dynamic store contains information relating to server processor load. In other embodiments the dynamic store contains information relating to server input output transaction load.

The load management subsystem i receives via said event bus a request to identify a server for servicing a client request ii retrieves from said dynamic store the loading information iii chooses based on the retrieved loading information one of the plurality of servers for servicing the client request and iv transmits via said event bus a message including information identifying the chosen server. In some embodiments the load management subsystem stores run time information in the dynamic store at predetermined intervals. In other embodiments the apparatus further includes a persistent store the load management subsystem in communication with the persistent store via the event bus the persistent store containing an identification of at least one rule to be used to manage server load.

In one embodiment the LMS is rule based and an administration tool can be used to modify or create rules for managing server load. A rule is one or more criteria that influences how a LMS will direct requests. Rules may be individualized to a specific remote machine . Rules can also be individualized to a specific application or computing environment on a per server basis. That is one or more rules may be associated with a copy of an application or a computing environment residing on a first remote machine in the machine farm and different rules may be associated with a copy of the same application or computing environment residing on a second remote machine in a machine farm . The output of rules individualized to a specific application may be combined with the output of general server rules to direct a client request.

Rules use the output from one or more operational meters. Operational meters may measure any aspect of server performance and the result is used by rules to help determine which remote machine is most appropriate to service a client request. For example operational meters may measure processor load context switches memory usage page faults page swaps transmission rate of input output reads or writes number of input output operations performed or number of virtual machines hosted. In one embodiment operational meters are used by a LMS to measure server performance during the occurrence of certain events such as a request for a client connection. In another embodiment operational meters are used by a LMS to measure server performance at predetermined intervals which may be configured by an administrator. A LMS on each remote machine in the machine farm evaluates various performance metrics for the remote machine for each predetermined period of time and stores that information in the dynamic store. For example every thirty seconds an evaluation of server load may include a query to operational meters for server s CPU utilization and memory utilization. The results from the query will be used in conjunction with other applicable load factors to calculate a load number for this server load. The new load number is then sent to the dynamic store.

Rules and operational meters are in one embodiment executable code modules that query specific system conditions resources and performance metrics for remote machines in the machine farm . Some of the rules accept user configurable parameters that are entered by the administrator via the administration tool. Rules may be provided to the LMS using a dynamic link library DLL and the rules and rule parameters applicable to a specific server may be stored in the persistent store. That is the administrator s selection of rules is stored together with a weighting factor and applicable settings associated with those rules in the persistent store. For example some operational meters may measure load at a predetermined interval the predetermined interval may be set by the administrator.

Examples of conditional rules that may be used by the LMS to determine to which remote machine to direct a request include whether the number of client machines that may connect to a remote machine is limited whether the number of client sessions that may be serviced by a remote machine is limited whether the number of virtual machines that may be hosted by a remote machine is limited the number of application or connection licenses available to a remote machine whether the application requested by the client machine is currently executing on the remote machine whether a client is physically proximate to or is connected by a high bandwidth link to a server and whether a client request is being made during a time period for which the remote machine is available to service client requests.

A set of rules may be grouped together by the group subsystem to form a load evaluator associated with a particular server or a particular application. A server load evaluator is a load evaluator that applies to all applications published on the server. An application load evaluator is a load evaluator that encapsulates rules specific to certain applications. In one embodiment loads for published application programs are the sum of a server load evaluator and an application load evaluator. The load evaluator associated with a particular server may be stored in the persistent store . When a LMS initializes it queries persistent store to determine whether a load evaluator is associated with the remote machine on which the LMS resides. If so the rules and operational meters are loaded and the LMS begins using those elements of the load evaluator. The outputs of the constituent parts of the load evaluator are combined to calculate composite indicia of the load on particular servers and each LMS stores the results of its load evaluator in dynamic store. Each rule encapsulated in a load evaluator may have a configurable weighting factor. Many rules have user configurable parameters that control the way LMS loads are calculated. For example in one embodiment a CPU Utilization rule has two parameters Report Full Load when processor utilization is greater than X percent report no load when processor utilization is less than X percent. In one particular embodiment the load reported by a load evaluator equals the sum of each rule s load times each rule s weight.

In another example a remote machine that hosts four applications may have three load evaluators with which it is associated. The server itself and a first application may by associated with a first load evaluator the second and third applications may be associated with a second load evaluator and the fourth application may be associated with a third load evaluator. When the remote machine boots it read the first second and third load evaluators from the persistent store . Periodically or perhaps after certain events the remote machine calculates the output for each of the load evaluators and sends those values to the dynamic store. When a connection request is received those values are used to determine if the remote machine should service a client request.

For example using operational meters the LMS can obtain information about the processor load on a particular remote machine the memory load on that remote machine and the network load of that remote machine . The LMS combines these results to obtain an overall load number that indicates the total aggregate load on that remote machine . In determining the aggregate load the load evaluator may weight each piece of information differently. For embodiments in which a rule is associated with a remote machine the rule may disqualify a remote machine from servicing a client request. For example a rule may limit the number of client sessions a remote machine may initiate. In this embodiment if a remote machine is currently servicing the maximum number of client sessions allowed by the rule it will not be chosen by the LMS to service a new client request even if the outputs of its operational meters indicate that it is the most favorable remote machine to which to route the client request.

Referring back to after an execution machine has been selected a virtual machine providing a requested computing environment is identified step . In some embodiments declarative policies such as rules databases policy databases or scripts are consulted to direct requests to a virtual machine. In other embodiments a remote machine functioning as an application server hosting a plurality of virtual machines is identified. In one of these embodiments one of the plurality of virtual machines hosted by the application server may be selected and associated with the client machine . In another of these embodiments an identifier for the selected virtual machine may be transmitted to the client machine .

In some embodiments a session management component identifies the virtual machine. In one of these embodiments an intermediate machine receiving the request invokes a session management component. In another of these embodiments the intermediate machine launches the session management component in a terminal services session executing on the intermediate machine. In still another of these embodiments the intermediate machine launches the session management component in a terminal services session executing on the identified execution machine.

In one embodiment the session management component provides functionality for identifying a location of a virtual machine providing access to a computing environment. In still another embodiment the session management component is provided as a program module published on a server such as an application server. In yet another embodiment the session management component identifies launches and monitors virtual machines.

In some embodiments the session management component communicates with a virtual machine management component to identify a virtual machine. In one of these embodiments the virtual machine management component provides functionality for locating virtual machines. In another of these embodiments the virtual machine management component provides functionality for allocating an available virtual machine to a user from a plurality of available virtual machines. In still another embodiment the virtual machine management component provides functionality for reallocating shared virtual machines to the plurality of available virtual machines. In yet another embodiment the virtual machine management component provides functionality for tracking a state associated with a virtual machine for each virtual machine in a plurality of virtual machines.

Referring now to a block diagram depicts one embodiment of a virtual machine management component . In one embodiment the virtual machine management component provides functionality for accessing and updating a database including a virtual machine catalog. In another embodiment the virtual machine management component provides functionality for allowing an administrator or virtual machine provisioning system to add remove or modify entries in the database including a virtual machine catalog. In some embodiments the virtual machine management component includes a virtual machine providing administrative functionality. In other embodiments the virtual machine component includes a virtual machine providing management functionality.

In some embodiments the virtual machine management component may receive a request from a provisioning system or from a session management component. In one of these embodiments a provisioning system contacts the virtual machine management component when a virtual machine is created or destroyed. In another of these embodiments the session management component contacts the virtual machine management component when the session management component is invoked to request a virtual machine to launch. In still another of these embodiments the session management component contacts the virtual machine management component when the session management component identifies a change in a state of a launched virtual machine. The session management component may send messages such as heartbeat messages to the virtual machine management component while a virtual machine is active. If the virtual machine may be accessed by more than one user the virtual machine management component may reassign the virtual machine to the plurality of available virtual machines after a user has terminated a session with the virtual machine.

In some embodiments virtual machines of the same machine type may be categorized into a plurality of standard operating environments SOE . In one of these embodiments an SOE may be a group of virtual machine images of a particular configuration that implement the function of a particular Machine Type e.g. a machine type C Developer Workstation may have one SOE containing images with WinXP Pro SP2 with Visual Studio 2003 installed and another SOE containing images with Win Vista with Visual Studio 2005 installed.

In other embodiments the virtual machine management component may provide functionality for one or more of the following actions related to a standard operating environment an SOE creating an SOE updating an SOE deleting an SOE finding an SOE and retrieving an SOE. In still another embodiment the virtual machine management component may provide functionality for one or more of the following actions related to virtual machines create a virtual machine update a virtual machine delete a virtual machine find a virtual machine and assignment to or removal from a standard operating environment.

A machine type may refer to a non technical description of a computing environment provided by a virtual machine. Some examples of machine types are C Developer Workstation or Secretarial Workstation. Many virtual machines may be grouped in a single machine type. In one embodiment the virtual machine management component may provide functionality for one or more of the following actions related to machine types creating machine types updating a machine type deleting a machine type finding a machine type and retrieving a machine type.

In some embodiments the virtual machine management component may provide functionality for creating virtual machines. In one of these embodiments an administrator or provisioning service creates a new machine type in a database of virtual machines. The machine type is given a meaningful name such as HR Manager Workstation. In one embodiment the machine type name is the name for a class of standard operating environment SOE rather than a specific SOE and multiple SOEs may be assigned to the machine type name. In another embodiment the machine type may be used to publish the class of virtual machines.

In another of these embodiments a standard operating environment SOE is created for the machine type and assigned to the machine type in the database of virtual machines. In one embodiment the SOE is a virtual machine with a specific hardware and software configuration. A snapshot of the SOE virtual machine may be taken and used as a template for virtual machine clones. In one embodiment clones of the SOE virtual machine are assigned to users.

In one embodiment an administrator clones an SOE for use by users by creating linked clones of the snapshot of the SOE virtual machine. The linked clone virtual machines may be created in consecutively numbered subfolders in the SOE folder. The linked clones of the SOE may be assigned to the SOE in the database of virtual machines.

In another embodiment an administrator updates a machine type by creating a new SOE and new linked clones of the SOE. The administrator updates an SOE pointer within a machine type record in the database of virtual machines to point to the new SOE and marks the old SOE as being superseded. The administrator may create the new SOE by creating a new virtual machine and installing the software or by creating a full clone of an existing SOE and updating it. As an example the administrator could create a new virtual machine and install Microsoft Windows XP Professional followed by Windows XP SP1 followed by Microsoft Office 2003 or the administrator could have taken a full clone of an existing SOE with Windows XP and Microsoft Office 2003 already installed and installs Windows XP SP1 to achieve the same SOE. The new SOE may be created in a new SOE folder and a new SOE record is created in the database of virtual machines. Linked clones of the superseded SOE can be deleted when users have finished with them and the superseded SOE can be deleted when all linked clones have been deleted.

In some embodiments a virtual machine may be designated as a shared virtual machine. In one of these embodiments a shared virtual machine is an instance of a virtual machine image that is designated for use by multiple users. In another of these embodiments the shared virtual machine is used by one user at a time and returned to a pool of available virtual machines when not in use. In still another of these embodiments as the image of a shared virtual machine is executed users may change the image but may not persist any changes to the image once it is shutdown. In this embodiment all changes are discarded when the image is shutdown or a user terminates a session.

In other embodiments a virtual machine may be designated as a private virtual machine. In one of these embodiments a private virtual machine is an instance of a virtual machine image that is designated for use by a specific user. Only that user may be allocated to the image launch the image or execute the image. In another of these embodiments private images will be configured to permit changes to be persisted when the image is shutdown. In still another of these embodiments changes may be configured to be discarded upon image shutdown as per shared images depending on the requirements of the user.

In some embodiments a session management component is launched and identifies a virtual machine. In one of these embodiments the session management component transmits an identification of a user and a virtual machine type identified responsive to a request for access to a resource to the virtual machine management component . In another of these embodiments the session management component requests an identification of a specific virtual machine to launch. In still another of these embodiments the session management component requests an identification of a location of the configuration and virtual disk files of the identified virtual machine.

In some embodiments a virtual machine is identified responsive to the received identification of the user of the requesting machine. In other embodiments a virtual machine is identified responsive to a request by the user for a type of virtual machine. In still other embodiments a virtual machine is identified responsive to a request by the user for a type of computing environment.

In some embodiments the virtual machine management component transmits to the session management component an identification of a specific virtual machine to launch. In one of these embodiments the session management component then proceeds to launch the virtual machine. In another of these embodiments the virtual machine management component launches the virtual machine.

In other embodiments the virtual machine management component transmits to the session management component an identification of a plurality of virtual machines to launch. In one of these embodiments the session management component may present an enumeration of available virtual machines to a user. In another of these embodiments the session management component receives a selection of a virtual machine from the enumeration of available virtual machines and the session management component launches the selected virtual machine. In still other embodiments the virtual machine management component transmits to the session management component an indication that no virtual machines are available for the user requesting the access. In yet other embodiments the virtual machine management component transmits to the session management component an indication that an existing executing virtual machine has now been allocated to the user.

In yet other embodiments the virtual machine management component transmits to the session management component an identification of an available virtual machine responsive to accessing a database storing information associated with a plurality of virtual machines the information including but not limited to an identification of the plurality of virtual machines an identification of a location of files associated with the plurality of virtual machines an identification of an access control list associated with the plurality of virtual machines and an indication of availability of the plurality of virtual machines.

In one embodiment when a virtual machine has been identified as a machine to launch the virtual machine management component modifies an access control list associated with the virtual machine responsive to the identification of the user received from the session management component in the initial request. In another embodiment the virtual machine management component modifies the access control list to allow the virtual machine to be launched for the user. In still another embodiment the virtual machine management component transmits additional information associated with the virtual machine to the session management component. The additional information may include network share details relating to a folder storing files associated with the virtual machine. In yet another embodiment the session management component uses the additional information to map the folder to a mount point such as a drive letter in the virtual machine.

In some embodiments virtual machine images configuration and data files comprising the virtual machine are stored on a storage area network. In other embodiments virtual machine images are stored in network attached storage. In one of these embodiments a file server in communication with the storage area network makes the virtual machine images accessible as if they were located on network attached storage.

Referring back to an identified virtual machine is configured step . In brief overview an execution machine identified by the intermediate machine executes a hypervisor emulating hardware resources required by the requested computing environment. A session management component launches a configured virtual machine in the hypervisor. Configuration occurs of the virtual machine for a particular client machine . A connection is established between the client machine and the virtual machine.

Referring now to a block diagram depicts one embodiment of a session management component in a system providing access to a computing environment by an intermediate machine to a requesting machine. In brief overview the session management component includes an identification component an execution component and a management component .

The identification component is in communication with a virtual machine management component and receives an identification of a virtual machine providing a requested computing environment. In some embodiments the identification component is in communication with the virtual machine management component . In one embodiment the identification component receives an identification of an execution machine into which to launch the virtual machine. In some embodiments the identification component identifies an execution machine on which a required hypervisor executes and into which to launch the virtual machine. In other embodiments the identification component receives an identification of the execution machine. In one of these embodiments the identification component receives the identification from the intermediate machine .

In some embodiments the identification component further comprises a transceiver. In one of these embodiments the transceiver in the identification component receives an identification of a user of the requesting machine and transmits the identification of the user to the virtual machine management component. In another of these embodiments the transceiver receives an identification by a user of a type of computing environment requested and transmits the identification to the virtual machine management component . In still another of these embodiments the transceiver receives an identification by a user of a type of virtual machine requested and transmits the identification of the type of virtual machine requested to the virtual machine management component .

In some embodiments the identification component receives an identification of a virtual machine providing a requested computing environment the virtual machine selected responsive to a received identification of a user of the requesting machine. In other embodiments the identification component receives an identification of a virtual machine providing a requested computing environment the virtual machine selected responsive to a received identification of a type of computing environment requested. In other embodiments the identification component receives an identification of a virtual machine providing a requested computing environment the virtual machine selected responsive to a received identification of a type of virtual machine requested.

The execution component launches the virtual machine into a hypervisor. In one embodiment the hypervisor executes on an execution machine . In another embodiment the execution component is in communication with the identification component. In still another embodiment the execution component receives from the identification component an identification of an execution machine executing a hypervisor into which to launches the virtual machine. In yet another embodiment the execution component launches the virtual machine into a hypervisor emulating hardware resources required to support the computing environment. In some embodiments a virtual machine service component executes in the hypervisor. In other embodiments a virtual machine service component executes in a guest operating system provided by a virtual machine executing in the hypervisor. In one of these embodiments the virtual machine service component is in communication with the session management component and receives configuration information associated with the client machine .

The management component establishes a connection between the requesting machine and the virtual machine and manages the connection. In one embodiment the management component provides an internet protocol address associated with the virtual machine to the user of the requesting machine. In another embodiment the management component provides an internet protocol address associated with an execution machine to the user of the requesting machine. In still another embodiment the management component provides a proxy for communication between the requesting machine and the virtual machine. In yet another embodiment the management component establishes a connection between the requesting machine and the virtual machine using a presentation layer protocol.

Although described above as separate functional entities it should be understood that the identification component the execution components and the management component may be provided as a single functional unit or the functions provided by those components may be grouped into two or more components.

In some embodiments the session management component establishes and manages a user s virtual machine session. In one of these embodiments the session management component provides functionality for without limitation locating a virtual machine launching a hypervisor launching a virtual machine in the hypervisor connecting a user to the virtual machine and managing the established connection. In another of these embodiments the session management component publishes a plurality of available virtual machines. In still another of these embodiments the session management component provides without limitation enumeration into client drives mapping of client drives to shared folders on the virtual machine monitoring of the hypervisor monitoring of an operating system provided by the virtual machine and a virtual machine control panel to the user.

In one embodiment the session management component provides a virtual machine control panel to the user. The virtual machine control panel may enable a user to switch to the virtual machine power off the virtual machine reset the virtual machine or suspend the virtual machine. In some embodiments the session management component provides the virtual machine control panel only to users authorized to access the functionality of the virtual machine control panel.

In some embodiments a virtual machine service component executes in the hypervisor. In one of these embodiments the virtual machine service component is in communication with the session management component and receives configuration information associated with the client machine . In another of these embodiments the session management component creates a connection to the virtual machine service component such as a TCP IP connection and communicates with the virtual machine service component over the created connection. In still another of these embodiments the session management component transmits information associated with the client machine such as initialization parameters or client monitor geometry to the virtual machine service component.

In some embodiments the session management component identifies a folder containing an image of the identified virtual machine. In one of these embodiments the folder contains configuration and data files comprising the virtual machine. In another of these embodiments the session management component mounts the folder in the execution machine prior to launching the virtual machine. In still another of these embodiments the session management component copies definition data files associated with the virtual machine onto the execution machine. The session management component may copy the definition data files back into the identified folder when a session is completed. In yet another of these embodiments the configuration and data files are streamed to the execution machine as described below.

In other embodiments the session management component enumerates in the virtual machine a plurality of drives associated with the client machine . In one of these embodiments the session management component creates a folder associated with each drive in the plurality of drives. In another of these embodiments the session management component stores a folder associated with a drive in the plurality of drives in the mounted folder containing the identified virtual machine. In still another of these embodiments an enumeration of the stored folder associated with the drive is provided to a user of the client machine . In some embodiments a protocol stack located in the hypervisor or in the guest operating system enables drive mapping through other techniques including techniques enabled by presentation layer protocols.

Referring now to a block diagram depicts one embodiment of a system in which a drive associated with the client machine is made available to a computing environment. In brief overview the client machine has a connection 1 to an execution machine and a connection 2 to a plurality of drives available to a user of the client machine .

The session management component creates a folder associated with each drive in the plurality of drives 3 . In one embodiment the session management component stores the created folder associated with a drive in the plurality of drives in a virtual machine folder the mounted folder containing configuration and data files associated with the identified virtual machine. In another embodiment the session management component generates a list of shared folders stored in the virtual machine folder .

The session management component notifies the virtual machine service component of the change to the virtual machine folder 4 . In some embodiments the session management component responds to changes in the client device by rebuilding a shared folder list in the virtual machine folder . In one of these embodiments the session management component receives an identification of a modification to the drive associated with the client machine . In another of these embodiments the session management component transmits a notification to the virtual machine service component identifying the change to the virtual machine .

For each folder associated with a drive in the virtual machine folder the virtual machine service component provides an indication of a mapped client drive to the virtual machine 5 . In one embodiment the virtual machine service component associates the mapped client drive with a drive letter on the virtual machine. In another embodiment the virtual machine service component monitors for changes to the shared folder list in the virtual machine folder . In some embodiments an enumeration of the stored folder associated with the drive is provided to a user of the client machine .

In some embodiments the session management component enumerates in the virtual machine a plurality of printers associated with the client machine . In one of these embodiments the session management component accesses a printer service to acquire an authorization level required to enumerate a printer in the plurality of printers.

In one embodiment a printer associated with the client machine is shared as a network printer and made accessible to the virtual machine as a network resource. In another embodiment the virtual machine generates printer output using the TCP IP and LPR protocols and this output is intercepted and transmitted to the printer associated with the client machine . In still another embodiment the virtual machine transmits printer output to a virtualized hardware resource provided by the hypervisor such as a COM port on the virtual machine. The output is captured and transmitted to the printer associated with the client machine . In yet another embodiment a hypervisor may provide access to a virtual printer or printer port.

Referring back to as part of the configuration process an execution machine identified by the intermediate machine executes a hypervisor emulating hardware resources required by the requested computing environment. In one embodiment the hypervisor executes on the intermediate machine. In another embodiment the hypervisor executes in a terminal services session executing on the intermediate machine. In still another embodiment the hypervisor executes on the execution machine. In yet another embodiment the hypervisor executes in a terminal services session executing on the execution machine. In some embodiments the hypervisor may be executed on the client machine .

In one embodiment the hypervisor provisions a plurality of hardware resources on the execution machine for use by the requested computing environment. In another embodiment the hypervisor partitions a plurality of hardware resources on the execution machine and makes the partition available for use by the requested computing environment. In still another embodiment the hypervisor emulates a plurality of hardware resources on the execution machine for use by the requested computing environment. In yet another embodiment the hypervisor may partition hardware resources emulate hardware resources or provision hardware resources or all three. For example a hypervisor may emulate a device such as a graphics card network card and disk partition the execution time of the CPU and virtualize registers storage and underlying devices which they use to fulfill operations on their emulated hardware such as RAM and network interface cards .

In some embodiments the session management component executes the hypervisor. In one of these embodiments the session management component executes the hypervisor in full screen mode. In other embodiments the session management component monitors execution of the hypervisor. In one of these embodiments the session management component transmits a notification to the virtual machine management component that the virtual machine has terminated when the session management component receives an indication that a virtual machine executing in the hypervisor has terminated. In another of these embodiments the session management component receives a notification when the user logs out of a session.

In some embodiments the hypervisor provides a hardware abstraction layer between hardware on the execution machine and a computing environment provided by a virtual machine. In one of these embodiments there is no operating system between the execution machine hardware and the hypervisor. The hypervisor may be said to be executing on bare metal. In another of these embodiments there is an operating system executing on the execution machine referred to as a host operating system and the hypervisor executes from within the operating system. Computing environments provided by a virtual machine may be referred to as guest operating systems.

In one embodiment the hypervisor executes in a terminal server session on a host operating system on the execution machine. The hypervisor may emulate hardware resources required by a computing environment provided by a virtual machine. The hypervisor may partition hardware and provide access to the partition. The hypervisor may also virtualize existing hardware making it appear to at least one domain on the hardware as if that domain were the only domain accessing the hardware. In another embodiment output from the computing environment or an application or resource executing within the computing environment is passed from the computing environment to a virtualized hardware resource provided by the hypervisor. In still another embodiment the hypervisor transmits the output to a component such as the session management component . The session management component may transmit the received output to a client machine from which a user accesses the computing environment. In yet another embodiment the hypervisor redirects the output from the virtualized hardware resource to an actual hardware resource such as a network interface card.

In some embodiments the hypervisor provides a hardware abstraction layer and creates an environment into which a virtual machine may be launched the virtual machine comprised of configuration and data files creating a computing environment which may comprise a guest operating system and application programs or other resource. In other embodiments the hypervisor provides functionality for transmitting data directed to a virtualized hardware resource and redirecting the data to a requesting machine via the session management component . In one of these embodiments the communication between the session management component and the hypervisor enable transmission of updates such as audio updates updates associated with a graphical user interface or updates associated with serial COM port input output from the virtual machine to the requesting machine. In another of these embodiments the communication enables transmission of keyboard or mouse or audio updates from the requesting machine to the virtual machine. In still another of these embodiments where the hypervisor executes within a terminal server session the hypervisor may map terminal server drives to the computing environment.

Referring still to a virtual machine is configured for access by a particular client machine . In some embodiments the management component receives an identification of a virtual machine already executing in the hypervisor. In other embodiments the session management component launches the virtual machine in the hypervisor. In one embodiment the session management component receives an identification of a folder containing configuration and data files comprising the virtual machine. In another embodiment the session management component mounts the identified folder in the execution machine.

In some embodiments a virtual machine service component executes in a guest operating system executing within the virtual machine. In one of these embodiments the virtual machine service component is a system service running in a network service account. In another of these embodiments the virtual machine service component is configured to initiate execution automatically upon the execution of the computing environment. In still another of these embodiments the virtual machine service component communicates with the session management component . In other embodiments the virtual machine service component executes in the hypervisor.

In some embodiments a virtual machine service component executes within the virtual machine. In one of these embodiments after launching the virtual machine in the hypervisor the session management component establishes a connection such as a TCP IP connection with the virtual machine service component. In another of these embodiments the virtual machine service component establishes the connection. The connection may be a single multiplexed connection between the components or multiple independent connections.

In still another of these embodiments the session management component uses the connection to transmit configuration information to the virtual machine service component. The configuration information may be associated with a presentation layer protocol session executing on the client machine in which output from the virtual machine is presented. The configuration information may also include information associated with display settings and changes client drive information and authentication data.

In other embodiments the virtual machine service component receives information associated with a printer to which the requesting machine has access. In one of these embodiments the virtual machine service component access a network printer service to create in the virtual machine a printer connected to the printer to which the requesting machine has access.

In still other embodiments the virtual machine service component transmits session status messages to the session management component . In one of these embodiments the virtual machine service component transmits heartbeat messages to the session management component . In another of these embodiments the virtual machine service component transmits keep alive messages to the session management component to prevent the session management component from shutting down the virtual machine. In still another of these embodiments the virtual machine service component transmits a message to the session management component providing an indication that the user of the client machine has logged off shut down or suspended a session with the computing environment. The virtual machine service component may receive the indication of the user s activity from an authentication module.

Referring still to as described above a request for access to a resource is received step a method for providing access to the resource is identified step and a virtualized environment may be selected to provide access to a resource step . In some embodiments a client machine receives the request identifies a method for providing access and selects a virtualized environment to provide access to a resource. In one of these embodiments a mobile computing device connects to a client machine referred to as a computing device which identifies a method for providing access to a computing environment selects a portable computing environment residing in storage on the mobile computing device and provides access to the portable computing environment.

Referring ahead to a storage device and a computing device are depicted. In brief overview the storage device stores data associated with a computing environment such as a portable computing environment which in some embodiments includes virtualization software a virtual machine image and user data. A computing device connecting to the storage device executing a virtual machine and providing access to the computing environment responsive to data stored in the storage device.

Still referring to and in further detail the storage device stores the portable computing environment of one or more users. In one embodiment the storage device may be any type and form of hard drive including a micro hard drive. In another embodiment the storage device may be any type and form of portable storage device such as a flash drive or USB drive or any type and form of portable storage medium such as a CD or DVD. In still another embodiment the storage device comprises a flash card a memory stick multi media card or a secure digital card. In some embodiments the storage device may store applications including word processing or office applications ICA clients RDP clients software to establish any type and form of virtual private network VPN or SSL VPN connection software to accelerate network communications or application delivery or any other type and form of application.

In one embodiment the storage device may store a virtual machine image. In another embodiment the storage device may comprise a transmitter for transmitting stored data to a computing device . In still another embodiment the storage device may comprise a transceiver for accessing stored data transmitting stored data and receiving data for storage. In yet another embodiment the storage device may comprise stored data comprising an application program for executing a virtual machine on a computing device.

In some embodiments the storage device is embedded in a mobile computing device. In other embodiments the storage device is connected to a mobile computing device. In still other embodiments the storage device comprises a portable storage device removable from a computing device.

The storage device stores data associated with a computing environment. The data may comprise a portable computing environment . In one embodiment the portable computing environment is considered portable in that the portable computing environment may be easily or conveniently carried and transported from one computing device to another computing device . In another embodiment the portable computing environment is considered portable in that the computing environment may be established or executed on any suitable computing device with little or no changes to the computing device or in a further embodiment with little or no maintenance or administration. In still another embodiment the portable computing environment includes a plurality of files representing a desktop environment or a portion thereof of a computer system which a user desires to execute on the computing device . In yet another embodiment the portable computing environment may represent an environment under which a user operates a home or office desktop computer. In some embodiments the portable computing environment represents one or more applications to which a user has access.

The portable computing environment may include a virtual machine image . In one embodiment the virtual machine image comprises a computing environment image including any of the information data files software applications and or operating system needed to execute a computing environment including files needed to execute the computing environment via the virtualization software . In another embodiment the virtual machine image comprises configuration and data files required to execute a virtual machine providing access to a computing environment requested by a user. In still another embodiment the virtual machine image comprises a virtual machine image as described above.

The portable computing environment may also include user data including without limitation any data information files software or applications of a user. In one embodiment the user data is stored in or as a part of the virtual machine image . In another embodiment the user data may be created edited or provided by any software program or application of the storage device or of the computing device .

The portable computing environment may include virtualization software . In some embodiments the virtualization software may comprise any suitable means or mechanisms for a user to access read and or write any user data included in or provided by the virtualization software and or virtual machine image . In one of these embodiments the virtualization software may track manage and synchronize the access reading and or writing of user data during an established computing environment with the user data provided on the storage device . In another of these embodiments the user data may only be accessed via the virtualization software or the established computing environment . In still another of these embodiments any software programs or applications of the storage device may access the user data when the storage device is not connected to the computing device or when a computing environment is not executing. In yet another of these embodiments the user data may comprise data and files created during a session of an established computing environment .

The computing device may be any type and form of computer system as described in connection with and above. In one embodiment the computing device is a client machine as described above. In another embodiment a connection between a computing device and a storage device provides a user of a client machine with access to a requested resource. In still another embodiment the computing device receives a request for access to a resource when a connection is made between the computing device and the storage device . In yet another embodiment a method for providing access to the resource is identified responsive to information received from the storage device .

In one embodiment the computing device has a storage element . In another embodiment the computing device has a network interface connected to network . In still another embodiment the computing device has a transceiver for accessing data stored in a storage device or in a computing device .

In some embodiments the computing device comprises an operational or performance characteristic not provided by the storage device . In one of these embodiments the computing device comprises elements such as a processor or a memory which the storage device does not include. In another of these embodiments the computing device provides an I O device display device installation medium or other peripherals such as a keyboard or printer not available to the storage device . In still another of these embodiments the computing device may provide a feature a resource or peripheral desired to be used by the user of the storage device . For example the user may want to access a file or an application provided on a remote machine available via a connection across the network . In yet another of these embodiments the computing device provides access to a network such as machine farm not available to the storage device or to a user of the storage device .

In one embodiment the computing device establishes a computing environment based on the portable computing environment provided by the storage device . The computing device establishes a virtual machine and a virtualization layer to execute the computing environment based on the virtualization software or virtual machine image and or user data .

In some embodiments virtualization allows multiple virtual machines with heterogeneous operating systems to run in isolation side by side on the same physical machine . In one embodiment the virtualization software may include a virtual machine image. Virtual machines may include cross platform X86 PC emulators such as the products distributed by The Bochs Project at bochs.sourceforge.net or VMware products manufactured and distributed by VMware Inc. of Palo Alto Calif. or products manufactured and distributed by Softricity Inc. or the Virtuozzo products manufactured and distributed by SWSoft Inc. of Herndon Va. or the Microsoft Virtual PC products manufactured and distributed by Microsoft Corporation of Redmond Wash. In another embodiment the virtualization software includes any the AppStream products manufactured and distributed by AppStream Inc of Palo Alto Calif. or the AppExpress products manufactured and distributed by Stream Theory Inc of Irvine Calif.

The computing device may use any other computing resources of computer system required by the computing environment . In some embodiments the hypervisor provides a virtualized hardware resource required by the computing environment . In other embodiments a hypervisor provides via a virtualization layer access to a hardware resource required for execution of a computing environment. In one of these embodiments the hypervisor provisions the hardware resource. In another of these embodiments the hypervisor virtualizes the hardware resource. In still another of these embodiments the hypervisor partitions existing hardware resources and provides access to a partitioned hardware resource.

In some embodiments a virtual machine executing on a virtualization layer provides access to a computing environment . In other embodiments a session management component executes the virtual machine . In still other embodiments virtualization software or execute the virtual machine . In one of these embodiments the portable computing environment includes any type and form of software for virtualizing on a computing device a user accessible resource such as an operating system desktop application and any hardware computing resources. In yet other embodiments virtual machine image is accessed to execute a virtual machine . In one of these embodiments the virtualization software or accesses the virtual machine image.

In some embodiments the virtualization software may include software for virtualizing a server such as the Microsoft Virtual Server products manufactured and distributed by Microsoft Corporation of Redmond Wash. or the Linux Vserver products distributed by the Linux Vserver Project located at linux vserver.org. In other embodiments the virtualization software may also include an interpreter or just in time compiler such as the JAVA Virtual Machine JVM originally manufactured by Sun Microsystems of Santa Clara Calif. or the Common Language Runtime CLR interpreter manufactured by the Microsoft Corporation.

In some embodiments the computing device has the virtualization software stored or installed in storage element prior to a connection with the storage device . In one embodiment the virtualization software does not need to be installed on the computing device and can instead be executed from the storage device . In another embodiment the computing device installs and executes the virtualization software on a per connection basis. In this embodiment the computing device may remove the virtualization software from storage element upon termination of the established computing environment . In still another embodiment the computing device installs and executes the virtualization software on a first connection. In yet embodiment upon other connections if the computing device detects changes to the virtualization software such as a newer version the computing device updates the virtualization software or installs a newer version of the virtualization software . In other embodiments the computing device obtains the virtualization software from a storage element or a remote machine accessible via network .

In one embodiment the virtualization software is used to establish a virtualization layer on the computing device . In another embodiment the virtualization layer provides an abstraction layer that decouples or isolates an application or a hardware resource from the operating system. In still another embodiment the virtualization layer comprises an application to host or run another operating system or application such as virtual machine .

In some embodiments the hypervisor comprises the virtualization software . In other embodiments the session management component comprises the virtualization software . In still other embodiments the host computing device stores virtualization software in storage element . In yet other embodiments the computing device accesses a remotely located copy of virtualization software .

In some embodiments the virtualization layer and or virtual machine provide an execution environment on the computing device . In one of these embodiments each execution environment is a unique instance of the same execution environment while in another of these embodiments each execution environment may be an instance of different execution environments. Each execution environment may be isolated from and or not accessible by another execution environment. In other embodiments the virtualization layer and or virtual machine provides an execution context space or sandbox to isolate processes and tasks running on the same operating system.

In one embodiment the virtualization layer communicates with a session management component . In some embodiments the session management component is software executing in a layer between a hypervisor or operating system of the computing device and one or more virtual machines that provide a virtual machine abstraction to guest operating systems. In other embodiments as described above the session management component may reside outside of the computing device and be in communication with a hypervisor or operating system of the computing device . In still other embodiment the session management component can load run or operate the virtual machine image from the storage device to execute a virtual machine . In yet other embodiments the session management component and hypervisor are incorporated into the same application software or other executable instructions to provide the virtualization layer . In further embodiments the session management component is in communication with a virtual machine service component executing within the computing environment .

In some embodiments and still referring to the computing device includes a loading mechanism which may comprise software hardware or any combination of software and hardware. In one embodiment the loading mechanism comprises an autorun configuration file. In another embodiment the storage device may include the loading mechanism . In still another embodiment the storage device includes the loading mechanism in an autorun file. In some embodiments a loading mechanism on the storage device establishes the computing environment on the computing device based on the portable computing environment stored in the storage device . In other embodiments the loading mechanism of the computing device establishes of the computing environment . In still other embodiments the loading mechanism of the storage device works in conjunction with the loading mechanism of the computing device to establish the computing environment .

In one embodiment the loading mechanism comprises a driver such as a device driver or a kernel or user mode driver for connecting to and or accessing the storage device or the storage element thereof. In another embodiment the loading mechanism comprises any type and form of executable instructions such as a program library application service process thread or task for accessing the storage element or storage device . In still another embodiment the loading mechanism accesses any type and form of data and information on the storage to establish the user environment in accordance with the operations discussed herein. For example in some embodiments the loading mechanism reads an autorun configuration file in storage element or on storage device . In some embodiments the loading mechanism comprises a plug n play PnP mechanism by which the operating system of the host computing device recognizes the storage device upon connection and loads the drivers to connect to the storage device .

In one embodiment the loading mechanism upon detection of a connection between the storage device and computing device initiates the loading establishing and or executing of the virtualization software and or the user environment on the computing device . In another embodiment the loading mechanism may comprise any rules logic operations and or functions regarding the authentication and or authorization of establishing a computing environment on the computing device based on the portable computing environment . In still another embodiment the loading mechanism may determine the existence of the virtualization software on the computing device and or the difference in versions between the virtualization software and virtualization software . In yet another embodiment the loading mechanism may store load and or execute the virtualization software or on the computing device . In a further embodiment the loading mechanism may store load and or execute the virtual machine image on the computing device as a virtual machine providing access to the computing environment . In still another embodiment the loading mechanism may comprise or provide any type and form of user interface such as graphical user interface or command line interface.

In some embodiments the virtualization software portable computing environment and or loading mechanism are designed and constructed in accordance with the U3 application design specification or USB smart drive provided by U3 LLC of Redwood City Calif. For example the loading mechanism may comprise a U3 launchpad program and the virtualization software and or portable user environment may comprise a U3 based application.

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for providing access to a computing environment on a computing device via a storage device. In brief overview a method for providing access to a computing environment includes the step of storing in a storage device data associated with a computing environment step . A computing device connects to the storage device step . A virtual machine executing on the computing device provides access to the computing environment based on the data stored in the storage device step .

In further detail a storage device stores data associated with a portable computing environment step . In one embodiment the storage device stores user data associated with the computing environment. In another embodiment the storage device stores a virtual machine image . In still another embodiment the storage device stores data associated with a computing environment the computing environment comprising at least one application program. In yet another embodiment the storage device stores data associated with a computing environment the computing environment comprising an operating system.

In one embodiment the storage device stores data comprising an operating system. In another embodiment the storage device stores data comprising an application program. In still another embodiment the storage device stores an application program for executing a virtual machine on a computing device. In yet another embodiment the storage device stores virtualization software for executing a virtual machine on a computing device.

In some embodiments the storage device may include a connector for establishing a connection between the storage device and a computing device. In other embodiments the storage device resides in a computing device such as a mobile computing device. In one of these embodiments the storage device is embedded in a mobile computing device. In still other embodiments the storage device comprises a portable storage device removable from a computing device.

A computing device connects to the storage device step . The storage device may connect to the computing device by any suitable means and or mechanism. In one embodiment the storage device connects to a computing device via a mobile computing device. In another embodiment the storage device is embedded in a mobile computing device connectable to the computing device .

Upon connection a request may be received by the computing device for access to a resource. In one embodiment the request is for a desktop environment. In another embodiment the request is for an application or for a plurality of applications. In still another embodiment the request is for a virtual machine.

In some embodiments a determination may be made to provide access to the requested resource via a virtualized environment. In one of these embodiments the determination is made as described above in connection with . In another of these embodiments the determination is made responsive to information received from the storage device such as a rule requiring the determination.

In one embodiment the computing device accesses the storage device to access the portable computing environment . In another embodiment the computing device obtains the virtualization software from the storage device to establish a computing environment . In still another embodiment the computing device does not obtain the virtualization software from the storage device as the computing device has access to the virtualization software in storage element or via network . In yet another embodiment the computing device obtains portions of the virtualization software from the storage device . For example the virtualization software on the storage device may be an updated version or have updated files to the virtualization software on the computing device . In some embodiments the storage device transmits information to the computing device . In one of these embodiments the storage device transmits the information with a request for access to a resource.

A virtual machine executing on the computing device provides access to the computing environment based on the data stored in the storage device step . In one embodiment the computing device retrieves data from the storage device . In another embodiment the computing device accesses the storage device to obtain a virtual machine image used to execute the virtual machine. In still another embodiment the computing device accesses the storage device to obtain data or information identifying a location of the portable computing environment that may be accessible to the computing device . For example the storage device may comprise user data identifying a Uniform Resource Locator URL associated with a location on which a virtual machine image is stored the URL accessible by the computing device via network . In yet another embodiment the computing device accesses a storage element identified by the user data for example a storage element or remote machine on the network storing the virtual machine image .

In some embodiments the computing device mounts the storage device as a storage such as a disk available to the computing device . In one of these embodiments the computing device mounts the storage device as removable media. In other embodiments the loading mechanism accesses the storage device .

The computing device establishes an environment for executing or providing access to the computing environment . In one embodiment a virtual machine may be executed in the computing environment to provide access to a requested resource. In another embodiment a virtual machine is the requested resource. In still another embodiment a virtual machine executes a virtual machine .

In one embodiment the computing device executes a virtual machine responsive to a virtual machine image stored in the storage device . In another embodiment the computing device executes a virtual machine responsive to the data stored in the storage device . In still another embodiment the computing device executes the virtual machine responsive to a policy stored in the storage device.

In one embodiment the computing device retrieves data stored in the storage device . In another embodiment the computing device uses an application program stored in the storage device to access the data. In still another embodiment the computing device provides access to a computing environment by executing an operating system providing access to one or more applications identified by information stored in the storage device the operating system and the one or more applications having access to user data stored in the storage device .

In one embodiment the computing device installs and or loads the virtualization software to establish the virtualization layer . In some embodiments the virtualization software is designed and constructed as a portable application that can execute load or establish the virtualization layer on the computing device without requiring installation of the virtualization software . In other embodiments the virtualization software is automatically installed on the computing device via an installation script. In one of these embodiments the virtualization software is installed without requiring a reboot. In another of these embodiments the virtualization software is installed and the virtualization layer established transparently to a user. In still other embodiments the virtualization layer is established using the virtualization software stored on the computing device or accessed via network .

In some embodiments the computing device executes a hypervisor to establish the virtualization layer . In other embodiments a hypervisor on the computing device and in communication with a hypervisor on a remote machine establishes the virtualization layer . In still other embodiments a hypervisor in communication with a session management component establishes the virtualization layer . In one of these embodiments upon establishment of the virtualization layer the session management component identifies provisions and or executes a virtual machine in the virtualization layer as described above in connection with . In yet other embodiments the loading mechanism establishes the virtualization layer . In further embodiments the computing device establishes a virtualization layer in which a virtual machine service component executes.

In one embodiment the virtualization layer has been established prior to the storage device connecting to the computing device . For example the virtualization layer may have been established for another computing environment or during a previous connection of the same or a different storage device . In some embodiments the computing device and or loading mechanism establishes the virtualization layer and actuates starts or executes a session management component and or hypervisor . In other embodiments the computing device and or loading mechanism executes session management component and or hypervisor upon loading or executing a virtual machine .

The computing device provides access to the computing environment based on the portable computing environment step . In one embodiment the computing device and or loading mechanism accesses the virtual machine image from storage device and executes the virtual machine image as a virtual machine in the established virtualized environment . In another embodiment the computing device and or loading mechanism automatically loads executes or otherwise establishes the computing environment with the virtualization layer upon detection of a connection over network . In still another embodiment the computing device and or loading mechanism automatically loads executes or otherwise establishes the computing environment and the virtualization layer upon detection of existence or identification of the portable computing environment in storage element .

In some embodiments a user may select the virtual machine image from the storage device for execution as a virtual machine via any type and form of user interface. In one of these embodiments the virtualization software virtualization layer hypervisor or loading mechanism may display a user interface for a user to identify a virtual machine image and or to execute a virtual machine based on a virtual machine image . In another of these embodiments a client such as an ICA client an RDP client or an X11 client executes on the computing device and provides the user interface to the user.

In some embodiments a user may access read and or write user data during the course of using the established computing environment . In one of these embodiments a user of the computing device may access read and or write the user data to the storage device . In another of these embodiments a user of the computing device may edit or modify user data or may create new data and information in user data .

In other embodiments a user of the computing device may access read and or write user data to the storage of the computing device . In still other embodiments the computing device may synchronize user data on the computing device with user data on the storage device . In one of these embodiments the computing device uses the virtualization layer or the loading mechanism to synchronize the user data . In yet other embodiments the storage device may have a program or application for synchronizing data between the storage device and the computing device .

In some embodiments the storage device may disconnect from the computing device at any point in time during the established computing environment . In other embodiments the storage device may disconnect after the computing environment is terminated on the computing device . In still other embodiments the computing environment is automatically terminated upon disconnection of the storage device to the computing device . In yet other embodiments the computing environment may remain established on the computing device after the storage device disconnects from the computing device . In one of these embodiments once the computing environment is established on the computing device the storage device may be disconnected.

In some embodiments the storage device can access read and or write user data to any portion of the portable computing environment . In one of these embodiments although the portable computing environment is not established or virtualized on computing device the storage device can still access read and or write to and from the user data . In other embodiments a user may use a first application in the established computing environment to access a file of the user data . In still other embodiments the user may use a second application on the storage device to access the same file of the user data . In yet other embodiments the virtualization software or virtual image allows access to the user data even though virtualization software or virtual machine image is not executing or operating.

Although are generally discussed with one portable computing environment stored in the storage device the storage device may store a plurality of portable computing environments for establishing a corresponding plurality of computing environments on the computing device . In some embodiments the computing device loading mechanism or the virtualized layer provides a user interface for the user to select a portable computing environment from storage to establish the computing environment . For example the storage device or the computing device may have a portable computing environment selection mechanism as is further discussed in connection with and with . In other embodiments the computing device loading mechanism or the virtualized layer uses one of the plurality of portable computing environments based on a characteristic of the computing device such as operating system type or based on user data identifying the portable computing environment to use for the computing device.

Referring now to a mobile computing device is depicted. In brief overview the mobile computing device may be any type and form of computer system as described in connection with and above. In one embodiment the mobile computing device comprises a storage device such as a storage device as described in connection with and . In another embodiment the mobile computing device is connected to a storage device . In still another embodiment the mobile computing device comprises a portable storage device removable from a computing device. In yet another embodiment the mobile computing device has a network interface used to connect to remote machines or client machines on the network such as the computing device . The storage device may store a portable computing environment which in some embodiments includes virtualization software a virtual image and user data .

In some embodiments the mobile computing device stores data associated with a computing environment executes a virtual machine and provides access to the computing environment responsive to data stored in the mobile computing device . In one of these embodiments the mobile computing device comprises a stored virtual machine image. In another of these embodiments the mobile computing device comprises an application program for executing a virtual machine on a computing device. In still another of these embodiments the mobile computing device provides access to a computing environment by executing an operating system with access to one or more applications identified via data stored on the mobile computing device the operating system and the one or more applications having access to the user data on the mobile computing device. In other embodiments the mobile computing device stores the portable computing environment of one or more users in storage provided by a storage device such as a storage device as described above in connection with .

In one embodiment the mobile computing device decrypts stored data. In another embodiment the mobile computing device prevents one of unauthenticated and unauthorized access by a user of the mobile computing device to a computing environment provided by the mobile computing device .

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for providing a computing environment by a mobile computing device. In brief overview a method includes the step of storing in a mobile computing device data associated with a computing environment step . A virtual machine executing on the mobile computing device provides access to the computing environment based on the stored data step .

In further detail the mobile computing device stores data associated with a computing environment step . In one embodiment the mobile computing device receives the data associated with the computing device from a storage device connected to the mobile computing device . In another embodiment the mobile computing device stores the data associated with the computing environment in a storage device embedded in the mobile computing device. In still another embodiment the mobile computing device stores user data associated with the computing environment. In yet another embodiment the mobile computing device stores a virtual machine image.

In one embodiment the mobile computing device stores data associated with a computing environment the computing environment comprising at least one application program. In another embodiment the mobile computing device stores data associated with a computing environment the computing environment comprising an operating system. In still another embodiment the mobile computing device stores data comprising an operating system. In yet another embodiment the mobile computing device stores data comprising an application program. In some embodiments the mobile computing device stores an application program for executing a virtual machine. In other embodiments the mobile computing device stores virtualization software for executing a virtual machine.

In some embodiments a request may be received by the mobile computing device for access to a resource. In one of these embodiments the request is for a desktop environment. In another of these embodiments the request is for an application or for a plurality of applications. In still another of these embodiments the request is for a virtual machine. In yet another of these embodiments the request is for access to a computing environment.

In some embodiments a determination may be made to provide access to the requested resource via a virtualized environment. In one of these embodiments the determination is made as described above in connection with . In another of these embodiments the determination is made responsive to information received from the mobile computing device such as a rule requiring the determination.

A virtual machine executing on the mobile computing device provides access to the computing environment based on the stored data step . In one embodiment an application program stored in the mobile computing device executes to access data associated with the computing environment. In another embodiment the mobile computing device executes virtualization software at least a portion of which is stored on the mobile computing device . In still another embodiment the mobile computing device provides access to a computing environment by executing an operating system with access to one or more applications stored on the mobile computing device the operating system and the one or more applications having access to user data stored in the mobile computing device .

In one embodiment the mobile computing device executes a virtual machine responsive to data stored in the mobile computing device . In another embodiment the mobile computing device executes a virtual machine responsive to a policy stored in the mobile computing device . In still another embodiment the mobile computing device executes a virtual machine that provides access to a requested resource or computing environment the virtual machine executed responsive to a virtual machine image stored in the mobile computing device . In yet another embodiment the mobile computing device transfers execution of the virtual machine to a computing device .

Although are generally discussed with one portable user environment stored in storage of the mobile computing device the mobile computing device may store a plurality of portable computing environments for establishing a corresponding plurality of computing environments on the mobile computing device .

Referring now to a mobile computing device and a computing device are depicted. In brief overview the mobile computing device stores data associated with a computing environment. The computing device connects to the mobile computing device executes a virtual machine and provides access to the computing environment responsive to data stored in the mobile computing device. In one embodiment the virtual machine executing on the computing device provides access to the computing environment.

In one embodiment the mobile computing device may be any type and form of computer system as described in connection with and above. In another embodiment the mobile computing device comprises a storage device as described above in connection with and . In another embodiment the mobile computing device may be a mobile computing device as described above in connection with and . In some embodiments the mobile computing device provides access to a portable computing environment of one or more users in storage provided by a storage device such as a storage device as described above in connection with .

In some embodiments the mobile computing device and the computing device may have the same processor or computer architecture such as an X86 based processor architecture. In other embodiments the mobile computing device may have a different processor or architecture than the computing device . For example the computing device may be a SPARC Scalable Processor Architecture and the mobile computing device may be an ARM based architecture. In some embodiments the mobile computing device and the computing device may both operate a processor or a data address or bus using the same numbers of bits such as a 32 bit or 64 bit processor or bus. In other embodiments the mobile computing device and the computing device may operate on processors and or a data bus with different bit architectures. Furthermore the mobile computing device and computing device may operate the same operating system in one embodiment and different operating systems in another embodiment. For example the mobile computing device may operate a PALM operating system while the computing device runs a WINDOWS operating system.

In one embodiment a mobile computing device has multiple processors. One processor may have higher performance characteristics than the other processor and each processor may share one or more storage and memory elements. For example a storage element such as a disk drive or portable storage device may include a computing environment. The mobile computing device may also have a switching mechanism to switch between using a first processor having higher performance characteristics and a second processor having lower performance characteristics based on operating conditions and applications executing on the device. The processor having lower performance characteristics may be used to execute applications with lower power requirements such as typical PDA functionality of calendar access and email. When an application requires more power the mobile computing device may automatically switch execution of such applications to the more powerful processor.

The computing device connects to the mobile computing device executes a virtual machine and provides access to the computing environment responsive to data stored in the mobile computing device . In one embodiment the computing device may mount the storage device of the mobile computing device as a removable hard drive or storage element of the computing device . In some embodiments the mobile computing device may be a plug and play device PnP of the computing device such that a PnP protocol manufactured by Microsoft Corporation of Redmond Wash. is used between the mobile computing device and computing device such as via I O devices or network interfaces .

In some embodiments the computing device comprises an operational or performance characteristic not provided by the mobile computing device . In one of these embodiments the computing device has a more powerful processor and or larger memory than the processor and memory of the mobile computing device . In another of these embodiments the computing device provides an I O device display device installation medium or other peripherals such as a keyboard or printer not available to the mobile computing device . In still another of these embodiments the computing device may provide a feature a resource or peripheral desired to be used by the user of the mobile computing device . For example the user may want to access a file or an application provided on a remote machine available via a connection across the network . In yet another of these embodiments the computing device provides access to machines on a network such as those in machine farm not available to the mobile computing device or to a user of the mobile computing device.

In one embodiment the computing device provides access to a computing environment based on the portable computing environment provided in the mobile computing device . The computing device executes a virtual machine and a virtualization layer to execute the computing environment based on the virtualization software or virtual machine image or user data . In some embodiments the computing device comprises a transceiver for accessing data stored in the mobile computing device .

In some embodiments a loading mechanism on the mobile computing device actuates the establishment of the computing environment on the computing device based on the portable computing environment stored in the mobile computing device . In other embodiments the loading mechanism of the computing device actuates the establishment of the computing environment . In yet another embodiment a loading mechanism on the mobile computing device works in conjunction with the loading mechanism of the computing device to establish the computing environment .

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for providing access to a computing environment on a computing device via a mobile computing device. In brief overview a method includes the step of storing in a mobile computing device data associated with a computing environment step . A computing device connects to the mobile computing device step . A virtual machine executing on the computing device provides access to a computing environment based on the data stored in the mobile computing device step .

A mobile computing device stores data associated with a computing environment step . In one embodiment the mobile computing device may store data associated with a computing environment as described above in connection with . In one embodiment the mobile computing device may comprise a storage device embedded in the mobile computing device such as the storage device described in connection with through .

The computing device connects to the mobile computing device by any suitable means and or mechanism step . In one embodiment the computing device connects to a storage device such as a storage device as described above in connection with and via the mobile computing device . Upon connection a request may be received by the computing device for access to a resource. In one embodiment the request is for access to a desktop environment. In another embodiment the request is for an application or for a plurality of applications. In still another embodiment the request is for a virtual machine. In some embodiments a determination may be made to provide access to the requested resource via a virtualized environment. In one of these embodiments the determination is made as described above in connection with . In another of these embodiments the determination is made responsive to information received from the mobile computing device such as a rule requiring the determination.

In one embodiment the computing device accesses the mobile computing device to obtain the portable user environment . In another embodiment the computing device obtains the virtualization software to establish the virtualized environment . In still another embodiment the computing device does not obtain the virtualization software from the mobile computing device as the computing device has access to the virtualization software in storage element or via network . In yet another embodiment the computing device obtains portions of the virtualization software from the mobile computing device . For example the virtualization software on the mobile computing device may be an updated version or have updated files to the virtualization software on the computing device . In some embodiments the mobile computing device transmits information to the computing device . In one of these embodiments the mobile computing device transmits the information with a request for access to a resource.

In one embodiment the computing device accesses the mobile computing device to obtain the virtual machine image . In another embodiment the computing device accesses the mobile computing device to obtain data or information identifying a location of the portable user environment in any storage that may be accessible to the computing device . For example the mobile computing device may comprise user data identifying a Uniform Resource Locator URL associated with a location on which a virtual machine image is stored the URL accessible by the computing device via network . In still another embodiment the computing device accesses a storage element identified by the user data for example a storage element on network storing the virtual machine image . In some embodiments the computing device mounts the mobile computing device as a storage element such as a disk available to the computing device . For example in one embodiment the computing device mounts the mobile computing device as removable media. In one embodiment the loading mechanism accesses the mobile computing device .

In some embodiments the computing device provides access to a computing environment by executing an operating system with access to one or more applications identified via data stored on the mobile computing device the operating system and the one or more applications having access to the user data on the storage device. In other embodiments the computing device prevents one of unauthenticated or unauthorized access by a user of the mobile computing device to a computing environment provided by the computing device . In still other embodiments the computing device decrypts data stored on the mobile computing device .

A virtual machine executing on the computing device provides access to a computing environment based on data stored in the mobile computing device step . In one embodiment the computing device establishes a virtualized environment for providing access to the computing environment by executing the virtual machine . In another embodiment a virtual machine may be executed in the user environment to provide access to a requested resource. In still another embodiment a virtual machine is the requested resource. In some embodiments the computing device executes a virtual machine responsive to a virtual machine image stored in the mobile computing device . In other embodiments the computing device executes a virtual machine responsive to data stored in the mobile computing device .

In one embodiment an application program stored in the mobile computing device is executed to access data associated with a computing environment. In another embodiment the computing device executes virtualization software by accessing at least a portion of the virtualization software stored in the mobile computing device .

In one embodiment the computing device executes the virtualization software to establish the virtualization layer . In some embodiments the virtualization software is automatically installed on the host computing device via an installation script. In one of these embodiments the virtualization software is installed without requiring a reboot. In another of these embodiments the virtualization software is installed and the virtualization layer established transparently to a user.

In some embodiments the computing device executes a hypervisor to establish the virtualization layer . In other embodiments a hypervisor on the computing device and in communication with a hypervisor on a remote machine establishes the virtualization layer . In still other embodiments a hypervisor in communication with a session management component establishes the virtualization layer . In one of these embodiments upon establishment of the virtualization layer the session management component identifies provisions and or executes a virtual machine in the virtualization layer as described above in connection with . In yet other embodiments the loading mechanism establishes the virtualization layer . In one embodiment the computing device establishes a virtualization layer in which a virtual machine service component executes.

In one embodiment the virtualization layer has been established prior to the mobile device connecting to the computing device . For example the virtualization layer may have been established for another user environment or during a previous connection of the same or different mobile computing device . In some embodiments the computing device and or loading mechanism establishes the virtualization layer and actuates starts or executes a session management component and or hypervisor . In other embodiments the computing device and or loading mechanism executes the session management component and or hypervisor upon loading or executing a virtual machine .

In some embodiments the computing device establishes executes or otherwise provides the computing environment based on the portable computing environment . In one embodiment the computing device and or loading mechanism accesses the virtual image from the mobile computing device and loads or executes the virtual machine image as a virtual machine in the established virtualized environment . In another embodiment the computing device and or loading mechanism automatically loads executes or otherwise establishes the computing environment with the virtualization layer upon detection of a connection over network . In still another embodiment the computing device and or loading mechanism automatically loads executes or otherwise establishes the computing environment and the virtualization layer upon detection of existence or identification of the portable computing environment on the mobile computing device .

In some embodiments a user may select the virtual machine image from the mobile computing device for execution as a virtual machine via any type and form of user interface. In one of these embodiments the virtualization software virtualization layer hypervisor or loading mechanism may display a user interface for a user to identify a virtual image and or to execute a virtual machine based on a virtual image . In another of these embodiments a client such as an ICA client an RDP client or an X11 client executes on the computing device and provides the user interface to the user.

In some embodiments a user may access read and or write user data during the course of using the established user environment . In one of these embodiments the user host computing device may access read and or write the user data to the mobile computing device . In another of these embodiments the user of the computing device may edit or modify user data or may create new data and information in user data .

In other embodiments a user of the computing device may access read and or write user data to the storage element of the computing device . In still other embodiments the computing device may synchronize user data on the computing device with user data on the mobile computing device . In one of these embodiments the computing device uses the virtualization layer or the loading mechanism to synchronize the user data . In yet other embodiments the mobile computing device may have a program or application for synchronizing data such as files and folders between the mobile computing device and the computing device .

In one embodiment the mobile computing device may disconnect from the computing device . In some embodiments the mobile computing device may disconnect at any point in time during the use of the established computing environment . In other embodiments the mobile computing device may disconnect after the computing environment is terminated on the computing device . In still other embodiments the user environment is automatically terminated upon disconnection of the mobile computing device from the computing device . In one embodiment the computing environment may remain established on the computing device after the mobile computing device disconnects from the computing device . In some embodiments once the computing environment is established on the computing device the mobile computing device may be disconnected.

In some embodiments the mobile computing device can access read and or write user data to any portion of the portable computing environment . For example in one embodiment although the portable computing environment is not established or virtualized on computing device the mobile computing device can still access read and or write to and from the user data . In one embodiment the user may use a first application in the established computing environment to access a file of the user data . In another embodiment the user may use a second application on the mobile computing device to access the same file of the user data . In some embodiments the virtualization software or virtual machine image allows access to the user data even though virtualization software or virtual image is not executing or operating.

In some embodiments the computing device loading mechanism or the virtualized layer provides a user interface for the user to select a portable computing environment from storage to establish the computing environment . For example the mobile computing device or the computing device may have a portable computing environment selection mechanism as discussed in greater detail below. In other embodiments the computing device loading mechanism or the virtualized layer uses one of the plurality of portable computing environments based on a characteristic of the computing device such as an operating system type or based on user data identifying the portable computing environment to use for the computing device .

Referring now to in one embodiment the computing device further comprises a computing environment selector . In brief overview depicts a mobile computing device connected to a computing device via a network . The mobile computing device further comprises a storage element an I O device or interface and a loading mechanism . The mobile computing device stores one or more portable computing environments in storage element . In some embodiments the storage element comprises a storage device such as the storage device described above in connection with .

In some embodiments the mobile computing device does not have a user input I O device and or a user output I O device . In other embodiments the mobile computing device obtains or derives power from the connection to the computing device such as for example from a USB connection. In still other embodiments the mobile computing device is a card of the following type CompactFlash Memory Stick MultiMediaCard Secure Digital or SmartMedia.

In one embodiment the storage element stores a plurality of computing environments and a plurality of virtual machine images. In another embodiment the storage element stores one or more of a plurality of virtual machine images providing one of a different operating system or a different application than at least one virtual machine images accessible to the computing device. In still another of these embodiments the storage element stores one of the data associated with at least one computing environment and the at least one virtual machine image in an encrypted format.

In some embodiments the mobile computing device stores data associated with at least one portable computing environment . In one of these embodiments the mobile computing device stores data associated with a plurality of portable computing environments . In another of these embodiments each of the portable computing environments comprises the same virtualization software . In still another of these embodiments the portable computing environments comprise different virtualization software 

In other embodiments the portable computing environments may comprise at least one virtualization software that is the same as another virtualization software . In other embodiments the portable computing environments may comprise at least one virtualization software that is different from another virtualization software . In yet another embodiment there may be one copy of the virtualization software to be used for each of the virtual images in storage .

In one embodiment one or more of the virtual machine images provides access to the same operating system or are used on the same operating system. In another embodiment one or more of the virtual machine images comprises a different operating system or executes on a different operating system. In some embodiments the virtual machine images share the same user data . In other embodiments the virtual machine images may each have distinct sets of user data . In one embodiment one of the virtual machine images may provide access to a first computing environment for example a work desktop environment. In another embodiment one of the virtual machine images may provide access to a second computing environment for example a home desktop environment. In some embodiments a virtual machine image may provide access to a computing environment comprising a set of one or more portable applications of the user. The mobile computing device may store any desired set of one or more user environments 

The mobile computing device includes a connector for connecting the mobile computing device to a computing device such as the computing device . In one embodiment the connector is connectable to a computing device via one of the following a wireless connection a USB connection a Firewire connection a Bluetooth connection a Wi Fi connection a network connection and a docking connection.

The mobile computing device includes a loading mechanism for automatically loading the at least one computing environment from the storage element onto a computing device upon connection of the mobile computing device to the computing device via the connector. In one embodiment the loading mechanism automatically installs the at least one computing environment on the computing device . In another embodiment the loading mechanism automatically executes the at least one computing environment on the computing device . In still another embodiment the loading mechanism accesses at least one virtual machine image stored in the storage element to execute a virtual machine the virtual machine providing access to a computing environment.

In some embodiments the mobile computing device includes a user interface provided for a user to select one virtual machine image to execute on the computing device from a plurality of virtual machine images. In other embodiments the computing device provides the user interface.

In one embodiment a selection mechanism such as a computing environment selector provides a user interface for a user to select one of the portable computing environments to execute or establish on the computing device . The computing environment selector may comprise software hardware or any combination of software and hardware. In some embodiments the computing environment selector has a graphical user interface providing a list of the one or more portable computing environment stored in the mobile computing device . In other embodiments the computing environment selector may comprise a command line interface. In one embodiment the computing environment selector comprises software stored on or provided by either the mobile computing device or the computing device . In one embodiment the virtualized software virtualized layer or portable computing environment comprises the computing environment selector . In another embodiment the computing environment selector is executed on the mobile computing device . In some embodiments the computing environment selector comprises a hardware and software mechanism on the mobile computing device for a user to select one of the portable computing environments . For example the mobile computing device may provide via a screen or visual display unit a text based user interface with a thumb wheel to select a portable computing environment 

Referring now to a flow diagram depicts another embodiment of the steps taken in a method for establishing a computing environment on a computing device via a mobile computing device. By connecting the mobile computing device carrying a portable computing environment to a computing device a user establishes a virtualized computing environment on the computing device . In brief overview at step the mobile computing device is connected to the computing device and at step the computing device detects the connection. At step and in some embodiments the user selects a portable computing environment from storage to be used on the computing device . At step a portable computing environment in the storage element is decrypted. At step the virtualization software is automatically loaded on the computing device . At step the computing device executes a virtual machine in the virtualized environment based on the portable computing environment such as by accessing virtual image . At step the computing device controls access to the computing device via the virtualized computing environment .

In further detail at step the mobile computing device is connected to the computing device by any suitable means and or mechanisms. At step the computing device detects the connection. In some embodiments the operating system of the computing device detects connection of the mobile computing device . In other embodiments a device manager detects the connection of the mobile computing device . In still other embodiments a plug and play manager detects the connection of the mobile computing device . In other embodiments a device driver for the computing device detects the connection. In yet another embodiment the loading mechanism detects the connection of the mobile computing device .

In some embodiments upon detection of the connection the computing device may automatically install load and execute a device driver software application process service thread or task to perform any of the operations described herein as described above in connection with and . In other embodiments upon detection of the connection computing device may perform any type and form of authentication and authorization of the user of the mobile computing device .

At step the user selects a portable computing environment from storage element to establish as the computing environment on the computing device . For example the user may identify or select via the computing environment selector the portable computing environment to run on the computing device . In one embodiment the computing device displays a user interface providing a list of portable computing environments from the mobile computing device for the user to select to establish on the computing device . In some embodiments the computing device executes an application program identified via the storage element of the mobile computing device such as via an autorun file. In another embodiment the mobile computing device has a visual display unit displaying a user interface for the user to select one of the portable computing environments . In some embodiments one of the portable computing environments is identified as a default computing environment to establish on the computing device . In another embodiment the portable computing environments are identified in an order or preference or priority. In one embodiment the mobile computing device comprises one portable computing environment . In this embodiment the portable computing environment may not need to be selected by the user and is automatically used by the computing device . In another embodiment although there is one portable computing environment on the mobile computing device the user may select the one portable computing environment .

At step the computing device may perform decryption on any portion of storage element which may be encrypted. In one embodiment the storage element comprises an encrypted file system. In another embodiment the virtualization software virtual image and or user data or any portions thereof may be encrypted. In one embodiment the computing device decrypts the portion of storage using a key via the loading mechanism the virtualization layer or another set of executable instructions. In some embodiments the key may a public key. In other embodiments the key may be a private key. In one embodiment the decryption key may be identity based such as based on the identity of a user authenticated via the computing device . In another embodiment the user s authentication credentials such as user id and or password may be used to generate or obtain a key for decryption. For example the user s authentication credentials may be used to obtain a key stored in the database. In another embodiment the computing device generates a private key based on performing an algorithm on the user s authentication credentials and a public key such as a public key provided by a trusted third party. In yet another embodiment the mobile computing device may store a key that is used by the computing device to authenticate the user and or generate a decryption key. In some embodiments the computing device uses a ticket authority to obtain a ticket for decrypting the encrypted portions of storage . Any type and form of authentication technologies may be used in performing the operations described herein such as password based authentication or biometric authentication. In one embodiment a token is used to provide two factor authentication such as a token manufactured by RSA Security Inc. of Bedford Mass.

At step the computing device provides or establishes the virtualization layer on the host computing device as described above in connection with and .

At step the computing device automatically loads executes or otherwise establishes a virtual machine to provide access to a portable computing environment on the virtualized layer . In one embodiment the computing device and or loading mechanism accesses the virtual machine image from the storage element and loads or executes the virtual machine image as a virtual machine in the established virtualized environment . In another embodiment the computing device loads executes or establishes a virtual machine as described above in connection with and .

At step in some embodiments the computing environment or virtual machine is established in a secured manner. In one embodiment the established computing environment protects access to user data or portions of the computing environment from the environment of the computing device external to the computing environment . In one embodiment the virtualization software and or virtualization layer ensures that contents of the virtual machine remain secure while running on the computing device . In some embodiments the virtualization software and or virtualization layer ensures that no input or no output is made available to the environment of the computing device in a persistent fashion. For example in one embodiment the virtualization software and or virtualization layer may disable clipboard access between the host environment and the virtual machine . In another embodiment the virtualization software and or virtualization layer disables access to a file system or portion thereof of the computing device . In other embodiments the virtualization software and or virtualization layer prevents paging by the virtual machine to the page file of the computing device . In one embodiment the virtual machine uses the storage element on the mobile computing device for file and data operations. In some embodiments the virtualization layer acts as firewall between the virtual machine and the host environment. In yet another embodiment the virtualization software and or virtualization layer may provide a configuration mechanism such as a user interface to select which actions may be performed and or data shared between the computing device and the virtual machine .

Although this method is generally discussed as establishing a computing environment from one of a plurality of portable computing environments a plurality of computing environments may be established on the computing device . For example a first computing environment may be established on the computing device using a first portable computing environment from the mobile computing device and a second computing environment may be established on the computing device using a second portable computing environment from the mobile computing device .

Referring now to block diagrams depict embodiments of systems and methods for a mobile computing device to one or more hardware resources. The hardware resource may provide access to resources such as a processor or memory with greater power size capacity or performance as compared to corresponding resources of the mobile computing device. depicts an embodiment of a mobile computing device connecting to a docking station or device having a processor memory and other computing resources for use by the mobile computing device. depicts an embodiment of a mobile computing device connecting to a second hardware resource via a docking mechanism to use a processor memory and or resources of the second hardware resource. depicts an embodiment of a docking station providing connectivity to a second hardware resource such as a computing device to use a processor memory and or resources of the second hardware resource. depicts one embodiment of the steps taken in a method of providing to a mobile computing device one or more hardware resources as described in the environments illustrated in . In some embodiments a portable computing environment may be established on the hardware resource in accordance with any of the systems and method described in conjunction with A B A C A B. In other embodiments the computing environment of the mobile computing device is accessed using the processor memory and or resources of the hardware resource.

Referring now to in brief overview the depicted system includes a mobile computing device connected to a hardware resource . The mobile computing device has a central processing unit . The hardware resource has a central processing unit . In one embodiment the hardware resource includes a docking station providing access to the hardware resource . In another embodiment the docking station includes a processor and memory . In still another embodiment the mobile computing device provides the functionality of a mobile computing device as described above in connection with B A B A and B.

The mobile computing device comprises a connection mechanism for connecting the mobile computing device to the hardware resource . The mobile computing device uses the central processing unit to effect an initial quanta of work and uses the central processing unit of the hardware resource to effect subsequent quanta of work when connected to the hardware resource . In one embodiment the mobile computing device uses the connection mechanism to switch to using the processing or computing capabilities of the hardware resource upon or after connecting to the hardware resource . For example the mobile computing device may execute a computing environment on the hardware resource after connecting to the docking station .

In one embodiment the mobile computing device connects to the hardware resource via connection across network . In another embodiment the mobile computing device is docked to the hardware resource via a I O device mechanism designed and constructed to connect to and or interface or communicate with the type and form of mobile computing device . In one embodiment the mobile computing device is docked to the hardware resource via a docking connector. For example one of the devices or may have a docking connector and one of the device or may have a corresponding interface or connection mechanism designed to receive the connector.

The connection mechanism may comprise software hardware or any combination of software and hardware enabling the mobile computing device to access the hardware resource . In some embodiments the connection mechanism comprises any type and form of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC capable of performing any of the operations described herein.

In one embodiment the connection mechanism comprises one of the following a wireless connection a USB connection a Firewire connection a Bluetooth connection a Wi Fi connection a network connection and a docking connection.

In some embodiments the connection mechanism is enables the system or mother board of the mobile computing device to use a processor and or memory of the hardware resource . In other embodiments the connection mechanism communicates with any system or data bus of the mobile computing device to transmit and receive signals directing the mobile computing device to use a resource of the hardware resource such as the processor and memory of the docking station . In some embodiments the connection mechanism may communicate with a system or data bus of the hardware resource to enable the use of resources of the hardware resource by the mobile computing device .

In one embodiment the connection mechanism may have the mobile computing device reboot restart or reset when connected or docked to the hardware resource . In another embodiment the connection mechanism may allow real time switching to use a computing resource of the hardware resource without a reboot or restart. In some embodiments the connection mechanism transfers data from memory on the mobile computing device to memory of hardware resource . In other embodiments the connection mechanism transfers execution of a process from a processor on the mobile computing device to processor of the hardware resource . In still other embodiments the mobile computing device transfers central processing control and management to the hardware resource . In yet other embodiments the connection mechanism provides for the use of the processor and or memory on the mobile computing device in conjunction with the processor and or memory of the hardware resource . For example when connected to the hardware resource the mobile computing device may operate as a multi processor device.

In some embodiments the mobile computing device and or connection mechanism maintains the state of the processor and or memory on the mobile computing device . As such in some of these embodiments upon disconnection from the hardware resource the mobile computing environment continues from a state prior to connection to the hardware resource . In others of these embodiments the connection mechanism transfers data information and execution or control from a processor and or memory to the processor and or memory of the mobile computing device .

In one embodiment the connection mechanism comprises any type and form of user interface to receive user input regarding connection to the hardware resource use of hardware resources and transfer of data and control between hardware resources. For example the connection mechanism may display a graphical user interface upon docking to the hardware resource for the user to setup configure control and or manage the use of the hardware resource .

In some embodiments the hardware resource uses the storage element of the mobile computing device to provide access to a computing environment. In one of these embodiments the hardware resource executes an operating system stored in storage element of the connected mobile computing device . In another of these embodiments the hardware resource mounts the storage element of the connected mobile computing device for access by the hardware resource . In still another of these embodiments the user uses the operating system or computing environment of the hardware resource but executes applications and accesses data on the storage element of the mobile computing device . In yet another of these embodiments the mobile computing device may store portable applications to execute in the hardware resource .

In one embodiment the hardware resource executes a virtual machine to provide access to a computing environment stored in the mobile computing device . In another embodiment the hardware resource executes a virtual machine the virtual machine providing access to a virtualized computing environment. In still another embodiment a file from a storage location provided by the mobile computing device is accessed by a user via the hardware resource when the mobile computing device is connected to the hardware resource and the file is accessed by the user via the mobile computing device when the mobile computing device is not connected to the hardware resource .

Still referring to and in one embodiment the hardware resource comprises a docking station the docking station comprising a computer system . In some embodiments the docking station may be any type and form of computer system as described above in connection with . In one of these embodiments and as described in connection with the docking station may comprise components including but not limited to a processor memory storage a network interface and or one or more I O devices . In another of these embodiments the docking station is connected to a display device a keyboard and or a pointing device . The docking station may also be connected to or provide access to other hardware resources and computing peripherals. In some embodiments the docking station provides access to resources of another computer system via a network .

In one embodiment the hardware resource has a processor having a higher processor speed than the processor of the mobile computing device . In another embodiment the hardware resource has a processor comprising a processor architecture different than a processor architecture of the processor of the mobile computing device . In still another embodiment the mobile computing device uses the processor to effect an initial quanta of work and upon connection to the hardware resource via the connection mechanism uses the processor to effect a subsequent quanta of work. In yet another embodiment the mobile computing device determines that a memory of the hardware resource has a memory size larger than a memory size of a memory of the mobile computing device and uses the memory of the hardware resource to effect subsequent quanta of work.

In some embodiments the mobile computing device uses a first operating system executing on the first central processing unit when not connected to the hardware resource and a second operating system executing on the second central processing unit when connected to the hardware resource. In one of these embodiments the second operating system is different than the first operating system.

Referring now to another embodiment of the hardware resource and the mobile computing device is depicted. In brief overview the mobile computing device connects to a docking station across a network and in turn docking station connects to a computing device . In this embodiment the hardware resource includes a docking station connected to or in communication with a computing device . Instead of providing resources such as a processor and memory as depicted in the docking station provides access to resources of a second computing device via the connection across network . In one embodiment after connection to the docking station the mobile computing device uses resources of the computing device via connections across networks and .

Referring now to another embodiment of the hardware resource and the mobile computing device is depicted. In brief overview the mobile computing device connects to the computing device via docking mechanism . In this embodiment the hardware resource includes a computing device having a docketing mechanism such as an I O device or mechanism to dock the mobile computing device . After connection via docking mechanism the mobile computing device uses the resources of the computing device such as a processor and or memory. In some embodiments the hardware resource provides access the mobile computing device with access to a peripheral computing device.

In any of the embodiments depicted in the hardware resource may provide resources and capabilities offering improved power performance or other operating or performance characteristics desired by the user of the mobile computing device or suitable for one or more applications of the mobile computing device as described in more detail above in connection with A B A B and A B.

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for providing to a mobile computing device one or more hardware resources. In brief overview the mobile computing device uses a first central processing unit of the mobile computing device to effect an initial quanta of work step . The mobile computing device connects to a hardware resource including a second central processing unit step . The mobile computing device uses a second central processing unit of the hardware resource to effect subsequent quanta of work step .

A mobile computing device uses a first central processing unit to effect an initial quanta of work step . In one embodiment the mobile computing device is a computer as described above in connection with . In another embodiment the mobile computing device is a mobile computing device as described above in connection with .

The mobile computing device connects to a hardware resource including a central processing unit step . In one embodiment the mobile computing device connects to the hardware resource by any suitable means and or mechanisms. In some embodiments the mobile computing device connects or docks to a docking station providing one or more resources. In one of these embodiments the mobile computing device connects to a docking station having a processor and or memory . In another of these embodiments the mobile computing device connects to a docking station providing a connection to a second computing device the second computing device including a processor . In still another of these embodiments the mobile computing device connects or docks to a docking mechanism of a host computing device .

In some embodiments the mobile computing device and the docking station may connect via any type and form of connection wired wireless or otherwise including but not limited to via a wireless connection a Wi Fi connection a USB connection a Firewire connection a Bluetooth connection a network connection and a docking connection. The mobile computing device and docking station may communicate via any type and form of protocol such as a device bus communication application data or network protocol.

The mobile computing device uses a central processing unit of the hardware resource step . In one embodiment the mobile computing device initiates use of a processor and or memory of the hardware resource via a connection mechanism . In another embodiment the mobile computing device transfers execution control and management to the central processing unit of the hardware resource . In still another embodiment the mobile computing device transfers data and information to the processor and or memory of the hardware resource . In some embodiments the mobile computing device uses the processor and or memory of the hardware resource as a second processor and or memory for the mobile computing device .

In one embodiment the mobile computing device connects to a hardware resource comprising one of the following a first docking station having the second central processing unit a second computing device having the second central processing unit and a second docking station providing access to a third computing device having the second central processing unit.

In some embodiments an application program on the mobile computing device executes in the processor and uses memory of the computing environment and displays on a visual display unit of the mobile computing device . In other embodiments an application program executing on the processor and using the memory of the hardware resource receives user input from an input device of the mobile computing device . In still other embodiments an application program executing on the processor and using the memory of the hardware resource displays on a display device of the hardware resource while receiving input from an input mechanism of the mobile computing device .

In one embodiment an application program executing on the processor and using the memory of the hardware resource displays on a visual display unit of the mobile computing environment while receiving input from an input device of the hardware resource such as keyboard and pointing device . In some embodiments the computing environment of mobile computing device executes on the processor and memory of the mobile computing device but also uses a resource of the hardware resource such as a network connection printer display device input device or any I O device .

In one embodiment the mobile computing device determines that the second central processing unit has a processor speed greater than a processor speed of the first central processing unit and uses the second central processing unit of the hardware resource to effect subsequent quanta of work. In another embodiment the mobile computing device determines that the second central processing unit has a processor architecture different than a processor architecture of the first central processing unit and uses the second central processing unit of the hardware resource to effect subsequent quanta of work. In still another embodiment the mobile computing device identifies a memory of the mobile computing device and identifies a second memory of the hardware resource . In yet another embodiment the mobile computing device determines that the second memory of the hardware resource has a memory size larger than a memory size of the first memory of the mobile computing device and uses the second memory of the hardware resource to effect subsequent quanta of work.

In some embodiments the hardware resource uses one or more resources of the mobile computing device . In one of these embodiments the hardware resource accesses a storage element or storage device of the mobile computing device such as the storage element . In some embodiments the hardware resource mounts the storage element . In another of these embodiments the hardware resource boots or reboots or otherwise establishes an environment based on a computing environment stored on the mounted storage element . In still another of these embodiments the hardware resource uses the processor and or memory of the mobile computing device in addition to the processor and or memory of the hardware resource .

In some embodiments the hardware resource uses a display device and or input device of the mobile computing device . In other embodiments the hardware resource executes a computing environment based on a portable computing environment in the storage element of the mobile computing device . In some embodiments the portable computing environment may execute in the hardware resource but display on and receive input from the mobile computing device .

In one embodiment the hardware resource provides the mobile computing device with access to a peripheral computing device of the hardware resource. In another embodiment the mobile computing device uses a first operating system executing on the first central processing unit on the mobile computing device when not connected to the hardware resource and a second operating system executing on the second central processing unit of the hardware resource when connected to the hardware resource . In still another embodiment the first operating system is different than the second operating system. In yet another embodiment a virtual machine executing on the hardware resource provides the mobile device with access to a first operating system. In some embodiments the hardware resource executes a virtual machine to provide access to a computing environment stored in the mobile computing device . In other embodiments the mobile computing device provides access to a computing environment on the hardware resource . In still other embodiments a user accesses via the hardware resource a file stored in the mobile computing device when the mobile computing device is connected to the hardware resource and accessing by the user via the mobile computing device the file stored in the mobile computing device when the mobile computing device is not connected to the hardware resource .

In one embodiment the mobile computing device uses a processor of the hardware resource to provide access to a computing environment stored on the mobile computing device . In another embodiment the mobile computing device uses a processor of the hardware resource to provide access to an operating system stored on the mobile computing device . In still another embodiment the mobile computing device uses a processor of the hardware resource to provide access to an application program stored on the mobile computing device . In yet another embodiment the mobile computing device uses a processor of the hardware resource to execute a virtual machine on the hardware resource responsive to a virtual machine image stored on the mobile computing device. In some embodiments the mobile computing device uses a processor of the hardware resource to provide access to a computing environment stored on the hardware resource.

Referring now to a block diagram depicts one embodiment of a mobile computing device having a plurality of processors. In brief overview mobile computing device comprises a first processor and a second processor . The processors may access a memory and or storage element on the mobile computing device . The mobile computing device includes a switching mechanism for switching between using the first processor and the second processor . In some cases the mobile computing device may have a lower powered processor for minimal functionality or standby operations and have a higher powered processor for normal operations or for applications suitable or requiring more powerful processor capability. While mobile the user may want to access features such as email calendar and contact information much like a PDA or smartphone. When accessing such applications the mobile computing device may use the lower powered processor to lengthen battery life and conserve power. The user may at any time want to access an application having higher processor requirements or suitability. When accessing these applications the mobile computing device may use the higher powered processor .

In further detail the processor and processor may be the same type and speed of processor. In other embodiments the processor and processor may be a different type and speed of processor. In some embodiments processor comprises a processing speed and or capability greater than processor . In other embodiments processor comprises a processing speed and or capability greater than the processor . In some embodiments the processor and are single core processors. In other embodiments the processor and are multiple core processors. In one embodiment the processor is a single core processor and processor is a multiple core processor such as dual or quad core processor. In yet another embodiment the processors and comprise the same processor architecture and or are manufactured by the same processor manufacturer. In other embodiments the processors and comprise different processor architectures and or are manufactured by different processor manufacturers.

In some embodiments a first processor comprises operational characteristics designed and constructed for lower power consumption longer battery life performance and or applications of a mobile or portable computing device. In one of these embodiments a first processor may be referred to as a low powered CPU. In other embodiments a second processor comprises operational characteristics designed and constructed for the power performance and or application requirements of a desktop computing environment server computing environment or otherwise a non mobile computing environment. In one of these embodiments the second processor may be referred to as a high powered CPU. In other embodiments the processor provides a first level of processing or processor capability and the second processor provides a second level of processing or processor capability. In one of these embodiments the second level of capability is greater or higher than the first level. In another of these embodiments the second level of capability is preferred over the first level. In still other embodiments the mobile computing device uses the first processor for one or more applications suitable for the first level of power consumption and processing capability and the mobile computing device uses the second processor for one or more applications suitable for the second level of power consumption and processing capability.

The switching mechanism enables the mobile computing device to switch between using a first processor and a second processor or any plurality of processors. In some embodiments the switching mechanism comprises any type and form of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC capable of performing any of the operations described herein. In some embodiments the switching mechanism enables the system or mother board of the mobile computing device to use a first processor . In some embodiments the switching mechanism enables the system or mother board of the mobile computing device to use a second processor . In one embodiment the switching mechanism communicates with any system or data bus of the mobile computing device to transmit and or receive signals directing the mobile computing device to use a second processor instead of a first processor and likewise to use the first processor instead of the second processor . In some embodiments the switching mechanism may interface and or communicate with a system or data bus of the mobile computing device to transmit and or receive signals to use both the first processor and second processor instead of just the first processor or the second processor .

In another embodiment the switching mechanism transfers data and execution from processor to processor of the mobile computing device . In some embodiments the switching mechanism transfers central processing control and management from a first processor to a second processor or from the second processor to the first processor . In one embodiment the switching mechanism may have the mobile computing device reboot restart or reset when switching between using a processor . In another embodiment the switching mechanism may perform real time switching from processor to processor.

In some embodiments the switching mechanism identifies a condition event or trigger upon which to switch between using one processor and another processor. In other embodiments switching mechanism switches to one of the first processor or the second processor based on a user selection. In one of these embodiments the switching mechanism comprises a user interface such as a graphical user interface or a command line user interface for a user to identify specify or configure the conditions events or triggers for performing switching between processors. For example the switching mechanism may switch automatically manually or otherwise between a first processor and a second processor based on any operational characteristics of the mobile computing device or the processors . In still other embodiments the switch mechanism switches between use of a processor based on a level of load of the first processor or second processor. In yet other embodiments the switch mechanism switches between use of a processor based on a level of activity such as task processes applications of the first processor or second processor . In some embodiments the switch mechanism switches between using a first processor and a second processor based on a level of consumption of power and or battery life. In still another embodiment the switch mechanism switches between use of a processor based on a type of application actuated or executed on the mobile computing device .

In another embodiment the switching mechanism comprises a user interface for the user to switch between processors . For example using a hot key set of key strokes or selecting an icon in a task bar a user may instruct command or direct the mobile computing device and or switching mechanism to switch between processors use one processor instead of another or use the plurality of processors at the same time.

Referring now to a flow diagram depicts one embodiment of a method for switching by a mobile computing device between use of multiple processors. In brief overview the mobile computing device uses a first processor designed and constructed to provide a first level of power consumption and processing capability step . The switching mechanism determines to switch the mobile computing device to using a second processor based on an operating characteristic of the mobile computing device the second processor designed and constructed to provide a second level of power consumption and processing capability step . The mobile computing device uses the second processor responsive to the determination by the switching mechanism.

In further detail the mobile computing device uses the first processor step . In one embodiment the switching mechanism identifies the first processor as the default processor for use by the mobile computing device . In another embodiment the mobile computing device uses the first processor upon starting restarting or booting of the operating system on the mobile computing device . In some embodiments a user selects the first processor as the default processor. In one of these embodiments the use may have identified the first processor to the switching mechanism .

The switching mechanism determines to switch the mobile computing device to using the second processor based on an operating characteristic of the mobile computing device the second processor designed and constructed to provide a second level of power consumption and processing capability step . In some embodiments the switching mechanism determines to switch based on operating conditions or characteristics of the mobile computing device such as the operating system resource usage memory usage power consumption load and numbers of processes applications services or tasks.

In one embodiment the second level of power consumption and processing capability of the second processor comprises a level greater than the first level of power consumption and processing capability of the first processor. In another embodiment the mobile computing device uses the first processor for one or more applications suitable for the first level of power consumption and processing capability and uses the second processor for one or more applications suitable for the second level of power consumption and processing capability. In still another embodiment the switching mechanism switches to one of the first processor or the second processor automatically based on the initiation of execution of an application.

In some embodiments the switching mechanism switches to one of the first processor or the second processor automatically based on one or more of the following operating characteristics a level of load of one of the first processor or the second processor a level of activity of one of the first processor or the second processor and a level of power consumption of one of the first processor or the second processor. In one of these embodiments the switching mechanism determines the load activity or power consumption of the first processor is near equal or greater than the processing capability of the first processor . In another of these embodiments the switching mechanism determines the processor requirements of an application executed by the user or requested by the user for execution is near equal or greater than the processing capability of the first processor .

In other embodiments the switching mechanism determines the mobile computing device would perform at a more suitable performance or operational level or in a manner desired by the user if the mobile computing device was using the second level of processing capability of the second processor . In still other embodiments a user selects to switch to using the second processor . In one of these embodiments a user via a user interface directs or instructs the switching mechanism to switch the mobile computing device to use the second processor .

The mobile computing device uses the second processor step . In one embodiment the mobile computing device uses the second processor instead of the first processor . In another embodiment the mobile computing device uses the second processor in addition to the first processor . In some embodiments the mobile computing device and or switching mechanism transfers information data control and or management to the second processor to continue operation of the operating system applications process services or tasks executing on the first processor . In other embodiments new applications or processes initiated by the user are executed on the second processor .

In some embodiments the switching mechanism switches to having the mobile computing device use the first processor for a first level of processing capability. As with step the switching mechanism determines to switch based on the operating conditions or characteristics of the device such as the operating system resource usage memory usage power consumption load and numbers of processes applications services or tasks. For example in one embodiment the switching mechanism determines the load activity or power consumption of the second processor is greater than the processing capability needed for operating the mobile computing device in its current state. In another embodiment the switching mechanism determines the processor requirements of an application executed by the user or requested by the user for execution is near or equal to the processing capability of the first processor . In some embodiments the switching mechanism determines the processor requirements of an application executed by the user or requested by the user for execution is less than the second level of processing capability of processor . In other embodiments the switching mechanism determines the mobile computing device would perform at a suitable performance or operational level or in a manner desired by the user if the mobile computing device was using the first level of processing capability of the first processor . For example the mobile computing device would perform in a suitable manner for the user using the first processor but would also save on battery life or reduce power consumption. In yet another embodiment a user selects to switch to using the first processor . For example in one embodiment the user via a user interface directs or instructs the switching mechanism to switch the mobile computing device to use the first processor . The method may be performed again to switch the mobile computing device to using the first processor at step .

Referring still to in some embodiments the session management component uses a connection to transmit information associated with a monitor on the client machine to the virtual machine service component. In one of these embodiments multi monitor geometry support is provided. In another of these embodiments the session management component accesses multi monitor information and enables the virtual machine service component to create a version of the multi monitor information in the virtual machine.

In one embodiment techniques are provided for virtualizing a display environment of a client by modifying and controlling the behavior and appearance of an application s window based on a desired display layout for the client. The techniques may be used for simulating or providing a multiple display setup for a single display environment. One embodiment provides a window processing mechanism to intercept a selected message to a window of an application and modify the message to the window to display the window on the client based on the desired display layout. The message to the window provides for the behavior or appearance of a window used or displayed by the application. In one embodiment the window processing mechanism provides a hooking mechanism to an application s window procedure and replaces the original window procedure with a window procedure designed to intercept a selected window message and modify values of arguments or parameters of the intercepted window message based on the desired display layout of the client. As such selected window messages are processed to provide or translate the behavior or appearance of the window to the desired display layout.

The techniques and mechanisms described may be practiced in a server based computing environment such as between a client machine and a remote machine communicating via a remote display protocol. A remote machine or a virtual machine executing in a hypervisor on the remote machine may be setup or configured for a single display environment while the client machine may be setup or configured for one or more display devices. For example a session on a machine such as a session on a WINDOWS server operating system may only be able to be configured or setup for a single display. The server may obtain a preferred or desired display layout for the client and store the display layout in association with the client such as associating the display layout with a remote session for the client. The window message processing mechanism may be used by the server to intercept and modify selected messages to windows of the application running on the server on behalf of the client. The window messages are modified to provide a behavior or appearance of the window based on the display layout associated with the client. As such the display output communicated by the server to the client includes display output to be displayed on the client according to the client s display layout rather than the display layout e.g. single display layout of the session on the server.

Using the techniques and mechanisms described herein allows a user to access a remotely available application in a server based computing environment regardless of the monitor layout of the client. Instead of the server associating a single display with the remote session the server will provide display output based on the client s display layout. Furthermore remotely provided application may maximize to the proper display from the perspective of the client. Also menu items and other windows of an application may be displayed appropriately within an application for example without appearing disjoint from the application. Additionally the issue of a window being rendered off screen after changes to the display layout is handled by automatically moving the window to a viewable upon detection of an off screen window.

Furthermore these techniques and mechanisms may also be practiced in a local computing environment to virtualize simulate or otherwise provide a multiple monitor environment for a client having a single display device. Although the client may have a single display device a desired display layout may be configured or provided to specify multiple displays. The window processing mechanism may be used to intercept and modify window messages for an application on the client to control the behavior or appearance of the window based on the desired display layout instead of the actual monitor layout. As such a user may gain the functionality benefits and advantages of a multiple monitor environment without having multiple display devices.

Referring now to one embodiment of an environment is depicted. In brief overview a client machine may be connected to or otherwise use a display device in one embodiment or multiple display devices in another embodiment. The client machine includes a display layout comprising a desired display configuration for the client machine such as for display device . The client machine includes a storage element for storing the display layout of the client machine . The client machine also includes a window processing mechanism .

In further detail the display layout comprises any type and or form of information or data to identify specify or describe a desired display layout configuration for the client. In one embodiment the display layout may comprise a file or set of files in any format. In another embodiment the display layout may comprise any information or data stored in any type and or form of storage or memory element provided by the client machine . In an additional embodiment the display layout may be provided or stored in any suitable type and or form of database. In further embodiments the display layout may be provided via any object data structure or application programming interface API . The display layout may comprise any graphical textual or combination of graphical and textual elements. The display layout may be created edited configured or otherwise provided by any suitable means and or mechanisms such as a graphical and or text based tool program or application. In one embodiment a graphical tool with a user interface may be used to design create edit and configure the display layout .

The display layout may include attributes properties characteristics values settings profiles and other display configuration information to define each display for the client. The display layout may include display configuration for each of the desired displays physical virtual or otherwise. In some embodiments the display layout includes a description of the layout location position organization or arrangement for each display device . In one embodiment the display layout includes a visual or graphical arrangement identifying the location and or size of each monitor with respect to each other. In some embodiments each display is identified by an identifier such as a name or number. Also the display configuration may include a monitor type a screen refresh rate adapter type adapter information screen resolution a color quality a color scheme a font size a background a style for buttons and menus and a screen saver.

Additionally the display configuration may include information or data to identify or specify a resolution and or a work area for each display such as the display corresponding to a display device . In one embodiment the resolution identifies the number of pixels or individual points of color contained on a display monitor expressed in terms of the number of pixels on the horizontal axis and the number of pixels on the vertical axis. As those ordinarily skilled in the art will appreciate the sharpness of the image displayed on the display device may depend on the resolution and the size of the display device . In another embodiment the work area identifies the usable dimensions of the screen area of the display device in pixels. In some embodiments the work area does not include the dimensions of the screen area not useable by the user such as the portion of the screen area having a menu tool or task bar such as the task bar on a desktop provided via a WINDOWS operating system.

In one embodiment the display layout is configured to correspond to the number of display devices and their available features and characteristics accessible by the client. In other embodiments the display layout does not match or correspond to the number of display devices connected to the client. For example the client machine may have a single display device but the display layout may be configured for multiple display devices . In one aspect the display layout may be configured for a display device that is virtual or a virtual display device. A virtual display device is rendered off the screen area of the physical display device and may be placed on and off the visible screen area by any suitable mechanism and or means such as for example tabbing between desktops or panning and scrolling beyond the work area of the physical display device . A virtual display device may comprise a resolution a work area and any other data or information in a display configuration as if it was a physical display device connected or to be connected to a client machine .

In some embodiments the work area of the virtual display device is relative to and or adjacent horizontally or vertically to the screen area of the physical display device . In other embodiments the resolution of the virtual display device is the same resolution of the physical display device or one of the resolutions supported by the physical display device . In some embodiments a display corresponding to a physical display device is not required to be configured as the top left monitor. In other embodiments the display layout may comprise any arrangement of positive and or negative coordinate systems and any displays or display devices virtual or otherwise may be configured to be located with any positive and or negative coordinates or in any portion of the positive and or negative coordinate system.

The storage element illustrated in the client machine of may comprise any type and or form of storage or memory such as random access memory a disk drive a disk array a rewriteable optical drive shared memory a database a file an object a data structure or any other type and or form of storage or memory element that allows the storing of and access to information or data such as the display layout . In one embodiment storage element provides the display layout as a globally mapped data file which may be accessible by any of the applications of the client machine . In some embodiments the storage element stores the display layout or a portion of the display layout . In other embodiments the display layout may be converted translated transformed or otherwise altered to be stored in the storage element . Although the storage element is illustrated on the client machine another client machine accessible to the client machine such as a server may have a storage element for storing the display layout .

In some embodiments the client machine executes or otherwise provides one or more applications . The application can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client machine . In some embodiments the application provides one or more windows also sometimes collectively referenced herein as . In one embodiment the window is a graphic sometimes rectangular in shape having either some kind of user interface or graphical or textual representation of the output of and in some cases allowing input for the application . In another embodiment the window comprises an area on the screen that displays information including user documents as well as communications such as alert boxes and dialog boxes. Additionally the user may open or close a window move it around on the display and sometimes change its size scroll through it and edit its contents.

In one embodiment the user interface for the application is the window . In other embodiments the application provides a top level window for the presentation and or navigation structure or framework for the application and provides additional windows in response to input or other events. For example the application may have a menu system and screen area for a user interface represented by a top level window and based on user input displays a secondary or smaller window to provide output to the user and or receive input from the user regarding the application .

The application and or any windows of the application may receive a message such as a window message as input. The message may be any type and or form of communication via any type and or form of medium. In some embodiments the message comprises a communication to a window to control or direct the behavior appearance attributes or properties of the window . In an exemplary embodiment of a WINDOWS based environment the application is event driven and waits for the operating system or system to pass input to them. The system passes all input for an application to the various windows in the application . Each window has a function called a window procedure which the operating system calls in response to receiving input for the window. A window procedure is a function that receives and processes all messages sent to the window. A window class may have a window procedure and every window created with that class uses that same window procedure to respond to messages. The window procedure processes the input and returns control to the system. The system passes input to a window procedure in the form of a message which may be generated by the operating system or other applications . A message may be generated for an input event for example when the user types moves the mouse or clicks a control such as a scroll bar. A message may also be generated in response to changes in the operating system or computing device brought about by an application . An application can generate messages to direct windows of the application to perform tasks or to communicate with windows in other applications.

In the exemplary embodiment of a WINDOWS based system a message is sent to a window procedure with parameters. In one embodiment the message comprises a set of four parameters a window handle a message identifier and two values referred to as message parameters. The window handle identifies the window for which the message is intended and is used to determine which window procedure should receive the message. A message identifier identifies a purpose or function of the message . When a window procedure receives a message it uses the message identifier to determine how to process the message. For example a message identifier WM PAINT of a message may indicate to a window procedure that the window s client area has changed and must be repainted. The parameters of a message may specify data or the location of data used by a window procedure when processing a message . The meaning and value of the parameters may depend on the message . A message parameter can include an integer a string packed bit flags a pointer to a structure containing additional data or any type and or form of data or information.

Although a message is generally described in the context of a WINDOWS based environment a message may be any type and or form of communication in any type of operating system or environment as one ordinarily skilled in the art would recognize and appreciate to control or direct the appearance behavior and attributes of a window being displayed or otherwise being used processed or provided by the application . As such the message may be in a form and have content suitable to the environment or operating system for which the operations described herein may be practiced.

Still referring to the window processing mechanism also referred to as a window message processing mechanism provides the means and mechanism for changing controlling or directing an appearance behavior or attribute of the window of an application based on the desired display layout of the client . The window processing mechanism may comprise an application programming interface API application module software component library service process task or any other form and or type of executable instructions designed to and capable of executing or providing the functionality described herein. The window processing mechanism may comprise software hardware or any combination of software and hardware. In some embodiments an application may be designed or constructed to include the functionality of the window processing mechanism while in some other embodiments the window processing mechanism is designed and constructed to be used by existing applications for example without changing the application .

In one embodiment the window processing mechanism comprises a mechanism for subclassing window procedures of a window of the application and providing a window procedure that gets called or used in place of the original window procedure of the window .

In one embodiment a hooking mechanism is used by the window processing mechanism to provide the replacement window procedure. In some embodiments a hooking mechanism comprises using an application programming interface API to replace the executable instructions or code of a function procedure or API with a desired set of executable instructions or code. For example the window processing mechanism may introduce a hooking mechanism for any API related to creating establishing or providing a window for example the CreateWindowA CreateWindowW CreateWindowExA and CreateWindowExW APIs of the WINDOWS operating system environment. In some embodiments the window procedure is replaced via the Windows application programming interface API calls of GetWindowLong and SetWindowLong. In other embodiments the replaced window procedure is stored in a list of any suitable type and or form along with a window handle or reference to the replaced window procedure. As such the window procedure used by the window processing mechanism may call the replaced window procedure. For example the window processing mechanism may pass through a message to the original window procedure for processing.

The window procedure of the window processing mechanism may be constructed and designed to intercept all or a portion of the messages communicated to or received by the window . In some embodiments the window procedure intercepts all messages and any messages not to be modified are communicated to the original or replaced window procedure. In one embodiment of a Microsoft Windows based environment the window procedure of the window processing mechanism intercepts messages with a message identifier comprising one of the following 1 WM DISPLAYCHANGE 2 WM WINDOWPOSCHANGED 3 WM WINDOWPOSCHANGING and 4 WM GETMAXMININFO. A WM DISPLAYCHANGE message communicates to a window a change in a resolution of a display . A WM WINDOWPOSCHANGED message communicates to a window a change in a size position or a place in the Z order for the window . A WM WINDOWPOSCHANGING message is communicate to a window when a change in a size position or a place in the Z order for the window is about to occur. A WM GETMAXMININFO message is communicated to a window when a size or position or a window is about to change.

The window processing mechanism intercepts a message and modifies a return value or parameter of the message to correspond to or be based on the display layout . In some embodiments the window processing mechanism intercepts messages for a top level window and in other embodiments the window processing mechanism intercepts messages for windows that are not a top level window. In further embodiments the window processing mechanism intercepts messages for a certain set of windows . For example the window processing mechanism may be configured to intercept windows defined in a list database storage or any other type and or form of configuration medium.

The message intercepted by the window processing mechanism may have return values arguments and or parameters designed or targeted for the actual display layout of the client machine or remote machine but the window processing mechanism changes the return values arguments and or parameters to be designed or targeted for the display configuration provided by the desired display layout . The window processing mechanism may read access acquire or otherwise obtain the display layout from the storage element by any suitable means and or mechanism. The window processing mechanism may comprise any type of logic functionality business rules or operations to obtain the values arguments and parameters of the message and analyze compare or otherwise process the values arguments and parameters of the message in view of the display layout and determine any changes or modifications to the values arguments or parameters or the message to display the window on a display identified by the display layout . The window processing mechanism modifies the message according to the determined changes and communicates the message to the window . In some embodiments the window processing mechanism determines the message does not need to be modified and thus communicates the message in the same form as intercepted by the window processing mechanism . In other embodiments the window processing mechanism replaces the message with a second message.

Referring now to another embodiment of a networked computer environment is shown in which the client machine communicates with a remote machine via one or more communication networks . The client machine may be connected to or otherwise use one or more display devices . The client machine includes a display layout comprising a desired display configuration for the client machine such as for display devices . The client machine may also include a client agent . The remote machine includes an application providing one or more windows and a storage element for storing the display layout of the client machine . The remote machine also includes a server agent a session login mechanism and a window processing mechanism .

The environment may provide a server based or thin client computing environment for practicing the operations described herein. For example the application may be an application executed on the remote machine on behalf of the client machine . The display output from execution of the application may be communicated to the client machine for display on the client for example via the client agent . The display output may be communicated between the remote machine and client machine via a remote display protocol. The display output may be based on a window of the application running on the remote machine but to be displayed on the client machine . As will be described in further detail below the window processing mechanism on the remote machine intercepts and modifies messages of the application running on the remote machine communicates the message to the window . As such the display output communicated to the client machine reflects the modified message processed by the window .

In one embodiment as shown in a client agent is included within the client machine . The client agent can be for example implemented as a software program and or as a hardware device such as for example an ASIC or an FPGA. An example of a client agent with a user interface is a Web Browser e.g. Internet Explorer and or Netscape Navigator browser . The client agent can use any type of protocol such as a remote display protocol and it can be for example an HTTP client agent an FTP client agent an Oscar client agent a Telnet client agent an Independent Computing Architecture ICA client agent from Citrix Systems Inc. of Fort Lauderdale Fla. or a Remote Desktop Protocol RDP client agent from Microsoft Corporation of Redmond Wash. In some embodiments the client agent is configured to connect to the remote machine . In some embodiments not shown the client includes a plurality of client agents each of which may communicate with a remote machine respectively.

Additionally the remote machine may comprise a server agent which may be capable of and configured to work in conjunction with the client agent . For example the server agent may be a server side component that accepts connections and requests from the client agent . In another embodiment the server agent may be capable of and configured to accept or establish remote access connections or sessions for the client machine . In one embodiment the client agent and server agent may communicate using a protocol such as http ICA or RDP over the network . In some embodiments the client agent and or server agent are used to establish re establish maintain or otherwise provide a server based computing or thin client computing based connection or session. In another embodiment the client agent and the server agent establish the start and end points of communications for a connection between the client machine and the destination remote machine .

In some embodiments the remote machine includes a storage element for storing the display layout. In one embodiment storage element provides the display layout as a globally mapped data file which may be accessible by any of the applications of the remote machine . In some embodiments the display layout is stored in the same form as provided to or received by the remote machine . Although the storage element is illustrated on the remote machine in the client machine may also include a storage element and in some embodiments the client machine stores the display layout in the client s storage element and or to the remote machine s storage element .

The remote machine may also include a session login mechanism which may include any type and or form of service process task or program application or executable instructions on the remote machine to handle and process login or session requests. The session login mechanism or any portion thereof may be provided via the operating system of the remote machine . In one embodiment the session login mechanism includes the windows logon process winlogon a component of the Microsoft Windows families of operating systems. As such the session login mechanism may provide interactive logon support and may include a Graphical Identification and Authentication dynamically linked library DLL referred to as the GINA and any number of network providers. The session login mechanism may include any interfaces such as an application programming interface API or dynamically linked libraries i.e. a dll to allow any resource application network or network provide gather obtain any identification and authentication information during a logon process.

The session login mechanism may perform an authentication process and password updating operations for the operating system and or for one or more resources programs applications networks or network providers. In one embodiment the session login mechanism provides authentication services for the operating system and in additional embodiments also provides authentication services for access to applications to be executed on the remote machine on behalf of the client machine such as in a server based or thin client computing model. Additionally the session login mechanism may monitor any mouse and or keyboard activity related to logging on or secure access of the remote machine or any resource application network or network provider. In some embodiments the session login mechanism may establish any initial services processes or tasks for a user or session on the remote machine .

The remote machine may execute or otherwise provide one or more applications . The application can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client machine or communicating via a network . The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In some embodiments the application uses a remote display or presentation level protocol. In other embodiments the application comprises any type of software related to Voice Over Internet Protocol VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio. In some embodiments the application provides one or more windows also sometimes collectively referenced herein as .

In some embodiments the remote machine or a machine farm may be running one or more applications such as an application providing a thin client computing or remote display presentation application. In one embodiment the remote machine or machine farm executes as an application any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application is an ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the application includes a Remote Desktop RDP client developed by Microsoft Corporation of Redmond Wash.

Additionally the remote machine may run an application which for example may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond Wash. a web or Internet server or a desktop sharing server or a collaboration server. In some embodiments any of the applications may comprise any type of hosted service or products such as GoToMeeting provided by Citrix Online Division Inc. of Santa Barbara Calif. WebEx provided by WebEx Inc. of Santa Clara Calif. or Microsoft Office LiveMeeting provided by Microsoft Corporation of Redmond Wash.

Although in and the window processing mechanism is illustrated as included in the application the window processing mechanism may reside in any portion of the remote machine the client machine and or external to the application for example as illustrated in . In one embodiment the window processing mechanism comprises a service process or task that runs in a system context or with the system privileges of the operating system. In some embodiments the windows processing mechanism may monitor messages communicated to windows of an application and intercept and modify the message to the windows . One ordinarily skilled in the art will recognize and appreciate that the windows processing mechanism may comprise any type and or form of executable instructions capable of performing the operations described herein.

In another embodiment of illustrated in the session login mechanism may be used to provide for or use any of the functionality of the window processing mechanism . In some embodiments the session login mechanism may read access acquire or otherwise obtain the display layout from the storage element . In other embodiments the session login mechanism accesses loads or uses the functionality of the window processing mechanism via a dynamically loaded library such as a library provided via a network provider to the winlogon process of a WINDOWS operating system. In other embodiments the session login mechanism interfaces with or communicates to the window processing mechanism to provide the techniques described herein. In further embodiments the session login mechanism may use the techniques described herein during reconnection re establishment and or re authentication of a login or user session such as a remote session in a server based computing environment .

In another aspect techniques for virtualizing a display environment of a client machine by controlling or directing the appearance behavior and attributes of a window of an application based on the desired display layout for a client machine are described. In view of the systems and structure of the environments and depicted in the operations functionality and techniques will be addressed by the methods depicted in . depicts a method for practicing an embodiment using the window processing mechanism . depicts examples of window messages and processing used in conjunction with the method . depicts a method for practicing an embodiment when reconnecting re establishing or re authenticating via the session login mechanism . depicts illustrative method for changing the client s display layout for example during execution of an application .

Referring now to in brief overview one embodiment of a method for providing a desired display layout of the client machine is shown. At step and at step the display layout is stored in the storage element and the display layout is associated with the client . At step the window processing mechanism accesses the display layout from the storage element to obtain the desired display layout information for the client machine . At step the window processing mechanism intercepts messages to a window displayed on a client machine by an application . At step the window processing mechanism modifies the message to provide the window on the client machine based on the desired display layout for the client machine . At step the window is displayed on the client machine based on the modified message . As such the appearance and behavior of the window is translated to and based on the display layout .

In further detail at step of the method the desired display layout for the client is provided. In one embodiment the display layout is communicated from the client machine to the remote machine . For example the client machine establishes a connection or communication session with the remote machine . In some cases the remote machine requests the display layout from the client machine and the client communicates the display layout in response to the request. In another embodiment the display layout is communicated via the session login mechanism during a logon or authentication process and in some embodiments upon a re logon or re authentication process. In one embodiment the display layout is stored in a database and queried by the client machine or remote machine to obtain the display layout . In other embodiments the display layout is downloaded by either the client machine or the remote machine from a web server a web site an application server another remote machine or via the Internet. In further embodiments a user may configure the display layout with a program application or tool and store the display layout on a client machine remote machine or another client machine .

At step the display layout is stored in the storage element and associated with the client machine . In some embodiments the remote machine receives the display layout from the client machine and stores the display layout in the storage element . In one embodiment the remote machine stores the display layout as a globally mapped data file on the remote machine accessible by one or more applications . In another embodiment the remote machine stores the display layout to another client machine accessible to the remote machine such as via the network . In some embodiments the client machine stores the display layout to a storage element on the remote machine to a storage element on the client machine or to a storage element accessible via the network or via the Internet.

The display layout may be stored to the storage element in any form suitable to the storage element and may be converted transformed altered translated or otherwise processed for storage in the storage element . For example in one embodiment the display layout may comprise data such as a file on the client machine transmitted via network packets to the remote machine and then translated into a globally mapped data file on the remote machine . In another embodiment the display layout is stored into any type and or form of database such as a relational database. In other embodiments the display layout is stored in storage comprising memory. For example the display layout may comprise or be represented by any type of object data structure or portion of memory on the client machine and or remote machine .

The display layout may be associated with the client machine by any suitable means and or mechanisms. In one embodiment the name or any portion thereof of the globally mapped data file may identify the client machine . In another embodiment any portion of content of the globally mapped data file may identify the client machine . In additional embodiments the client machine or remote machine may use any type of object data structure process or other elements in memory to associate the display layout with the client machine . In other embodiments the client machine or remote machine may use portions of the storage element or other types of storage such as another file to associate the display layout with the client.

The window processing mechanism at step of illustrative method accesses the display layout from the storage element to obtain the desired display layout information for the client machine . In one embodiment the executable instructions of the window procedure used by the window processing mechanism comprises instructions to load read or otherwise acquire the display layout . For example the window processing mechanism may perform any type and or forms of file input output i.e. file I O operations to read a globally mapped data file having the display layout . In another embodiment the instructions of the hooking application programming interface API for the window processing mechanism provides instructions for obtaining the display layout . In another embodiment the application reads or accesses the display layout for example upon execution or start up. In some embodiments the application may be executed during a session such as a user or remote session. In one embodiment the globally mapped data file may only be accessible by an application associated with or available via the remote session. In further embodiments access to the globally mapped data file may have access locked by a mutex or semaphore which is global for the remote session. One ordinarily skilled in the art will recognize and appreciate that any type and or form of locking mechanism can be used to control access the storage element such as a globally mapped data file.

At step the window processing mechanism intercepts messages to a window displayed on a client machine by an application . In one embodiment upon obtaining the display layout a hooking mechanism is introduced into the remote machine or the application on the remote machine which hooks one or more window creation application programming interfaces APIs such as for example a create window type of API in a WINDOWS based environment. In some embodiments the window processing mechanism intercepts all messages to windows of the application . In other embodiments the window processing mechanism intercepts messages of a certain message identifier or name. In one embodiment the message may have arguments parameters or values that are used by the window processing mechanism to determine that the message should be intercepted. In additional embodiments the window processing mechanism intercepts messages to some of the windows of the application and in further embodiments only for a portion of the types of messages communicated to these windows . In yet another embodiment the window processing mechanism is configurable for example by a user to select the messages by name type or otherwise to be intercepted.

In some embodiments the window processing mechanism intercepts messages communicated to or intended for a top level window of the application . In other embodiments the window processing mechanism may intercept any level of window or only certain levels of windows in a hierarchy of windows . For example the window processing mechanism may ignore any popup dialog windows of a second level window displayed on top of or in front of a top level window .

In one embodiment the window processing mechanism may intercept a message but pass the message through or communicate the message to the original or replaced window procedure. In some embodiments the window processing mechanism ignores certain messages . In another embodiment the window procedure of the window processing mechanism also includes the functionality and operations of the replaced window procedure. As such the window processing mechanism may intercept a message and have either the replaced window procedure or the window procedure hooked into the application process the message .

At step the window processing mechanism modifies the message to provide the window on the client machine based on the desired display layout for the client machine . In some embodiments the window processing mechanism examines inspects analyzes or otherwise processes any values arguments or parameters of the message in comparison to the display layout for the client machine displaying the application . Based on the comparison the window processing mechanism may modify adjust edit change alter replace translate or otherwise set or provide values arguments and or parameters for the message that will provide the desired behavior appearance and attributes of the window as displayed or to be displayed by the application on the client machine in accordance with the display layout . For example the values and or parameters of the message may indicate a size position location resolution or other attributes of the window . These characteristics may be based on a display environment different than as specified in the display layout . As such in some embodiments the window processing mechanism may modify the size position location resolution or other attributes of the message for a display specified in the display layout .

By way of further example and referring now to the window processing mechanism may intercept and modify a message identified as one of the following 1 WM GETMAXMININFO 2 WM WINDOWPOSCHANGING 3 WM WINDOWPOSCHANGED and 4 WM DISPLAYCHANGE. At illustrative step for a message intercepted and identified as a WM GETMINMAXINFO the window processing mechanism analyzes the position of the application i.e. a top level window relative to the one or more displays of the display layout and determines which of the displays the application should be maximized to. The window processing mechanism modifies the message to provide values corresponding and translated to the resolution based on the desired display layout . For example a remote machine may provide window resolution for a single monitor session and the window processing mechanism translates the resolution to the multiple display environment provided via the display layout . As such this technique enables the application to maximize to a desired location in accordance with the display layout instead of the single monitor session.

At illustrative step for a message intercepted and identified as WM WINDOWPOSCHANGING the window processing mechanism determines if the window is in the maximized state and if so the message is modified to set the window flag to a no move style of window or otherwise to fix the location or position of the window or not allow the position of the window to change. As such in the maximized state a user may not be able to move the window . This technique enables the application or a window of the application to be maximized to a set or fixed location on a display specified by the display layout . In some embodiments either in response to the WM WINDOWPOSCHANGING message or otherwise the window processing mechanism determines the window is not in the maximized state and modifies the message to remove the no move style e.g. the window s position is no longer fixed or to otherwise allow the position of the window to be moved.

At illustrative step for a message intercepted and identified as WM WINDOWPOSCHANGED the window processing mechanism compares the position or location of the window to the display layout and if the window is to be rendered outside the screen or work area of display then the position or location of the window is changed to be rendered in at least a portion of the screen or work area of the display . This technique enables the user not to lose the application or window of the application to an off screen location.

At illustrative step for a message intercepted and identified as WM DISPLAYCHANGED the window processing mechanism suspends passing of messages until a new or second display layout is obtained or provided for the client . In one embodiment the window processing mechanism suspends the processing of all messages . In some embodiments the window processing mechanism suspends messages that are intercepted and communicated to the replaced or original window procedure. In other embodiments the window processing mechanism suspends messages for the replaced or original window procedure while continuing to process other messages . This technique enables a client machine to dynamically change the display layout at any time for example during the execution of an application .

Although the techniques of are generally described above in relation to message one ordinarily skilled in the art will recognize and appreciate that any message of any type and or form may be used. Furthermore the window processing mechanism may perform any logic function operations or rules based on the message and or the display layout and even for the same type of message may perform a different operation or function for each instance of the message depending on changes to the display layout or any events conditions or status of the environment or .

Referring back to at step of method the window is displayed on the client machine based on the message processed via the window processing mechanism . As such when the window processing mechanism modifies the message based on the display layout the window is displayed on the client machine according to the display layout . In some embodiments the window processing mechanism does not modify the message and therefore the window is displayed on the client machine according to the unmodified message . The technique as illustrated above enables for example in one embodiment of a server based computing environment an application running on remote machine to provide display output to the client machine that controls and directs the behavior appearance and attributes of windows in the display output in any manner desired and specified by the display layout which may not correspond to the physical display layout of the client machine .

In another aspect although techniques described herein are generally described with a window management system from WINDOWS operating system one ordinarily skilled in the art will recognize and appreciate that techniques described herein may be practiced with any type and or form of window manager or management system such any type and or form of X windows managers including any custom or open source based window manager running on any type of operating system.

Referring now to these techniques may be practiced during the re connection re establishment or re authentication of any communication session or user session for example a remote display session between the client machine and the remote machine . In one embodiment the session login mechanism as illustrated on the remote machine of may include the window processing mechanism or any portion thereof. In brief overview of method the session login mechanism at step accesses or obtains the display layout from the storage element . At step there may be a disconnection and reconnection processed by the session login mechanism . Upon re establishing and or re authenticating the session the session login mechanism at step compares a location of a window to the client s display layout and at step modifies the window to display on the client machine based on the client s display layout .

At illustrative step the session login mechanism obtains information on the display layout by any suitable means and or mechanisms. For example the window processing mechanism included in or used by the session login mechanism may have executable instructions such as file I O operations to access a globally mapped data file . In another embodiment the session login mechanism may load dynamically linked libraries that load read or otherwise access the storage element having the display layout information. In one embodiment as part of establishing or re establishing the session the session login mechanism may obtain the display layout from the client . For example the session login mechanism requests the display layout from the client machine along with any identification or authentication credentials.

At illustrative step any type of disconnection or disruption to a session between the client machine and remote machine may occur and any type of reconnection or re establishment of the session may be facilitated via the session login mechanism . In some cases a user may cause a disconnection or disruption temporary or otherwise to a session between the client machine and the remote machine due to physical changes in the client s display environment or because the user moves to another client machine . In one case the user moves from a first client machine such as a work computer to a second client machine such as a home computer. The remote machine may maintain the same user session between computing devices but the display layout may have changed. In another case the user and or the client machine may traverse network segments or network access points that cause changes in the network address or host name e.g. internet protocol IP address of the client machine or causes the client machine to disconnect. The client machine may reconnect manually or automatically to the network such as via the client agent . As such the session login mechanism may facilitate or be used to facilitate the reconnection.

At step of method the session login mechanism compares the location or position of a window of an application in relation to the desired display layout . In some embodiments the session login mechanism intercepts a message to a window and examines inspects or analyzes any portion of the message such as a value or parameter. In one embodiment the session login mechanism queries acquires or obtains the current location or position of one or more windows of the application via an application programming interface API . In another embodiment the session login mechanism requests from the application the location or position of any of the application s windows. The session login mechanism compares the location position size and any other attributes of the window to any information in the display layout .

At step the session login mechanism may modify the window based on the desired display layout . From the comparison of the information about the window to the information of the display layout the session login mechanism in some embodiments modifies the window to display on the client machine via a display identified in the display layout in a desired manner. In one embodiment via the functionality of the window processing mechanism embodied in or interfaced with the session login mechanism a message to a window may be intercepted and modified in accordance with the operations described herein. In another embodiment the session login mechanism may modify one or more windows of the application via any application programming interface API to modify such windows . The techniques depicted by method enable client sessions to be disconnected and reconnected and have the display of windows be adjusted accordingly to any new or changed display environments of the client machine new or changed display layouts of the client machine or changes from one client machine to another client machine

In another aspect dynamically changing a display layout for a client machine is described. Referring now to the techniques described may be practiced for a change to a display layout that occurs during the execution of an application . In brief overview of illustrative method at step a client s display layout is changed. At step the window processing mechanism suspends window message processing when the client s display layout is changed. At step an updated or a second display layout is obtained by the window processing mechanism and at step the window processing mechanism resumes intercepting and modifying messages to windows based on the second display layout .

In further detail at step the display layout may be changed at any time and for any reason. In one embodiment the display environment for the client machine may change and the display layout may be updated to reflect the changed display environment. For example another display device may be connected to the client machine . In another embodiment a user of the client machine may be making adjustments updating or otherwise changing the display layout to suit the user s desire for a behavior and appearance of applications and the display of windows of the application on the client machine . In yet a further embodiment a first session may be on a first client machine with a first display layout and the user switches to a second session or maintains the first session on a second client machine with a second or updated display layout .

At step the method suspends intercepting and modifying messages for windows of an application upon notification of a change to the display layout . In one embodiment the window processing mechanism intercepts a message such as the WM DISPLAYCHANGE message indicating a change in any attribute or characteristic for example the resolution of the display environment. In another embodiment the client machine communicates a notice to the remote machine the window processing mechanism or the session login mechanism indicating a change has occurred or is about to occur to the display layout . In yet another embodiment the application may comprise a user interface mechanism for a user to indicate a change to the display environment or to have the application suspend processing of window messages according to the display layout .

The window processing mechanism may suspend the processing of messages for all applications a portion of applications or for a portion of windows of one some or all of the application . In one embodiment the window processing mechanism queues any messages received until the window processing mechanism obtains another display layout . In another embodiment the window processing mechanism only suspends processing of window messages to be modified according to the display layout and continues passing the messages not to be modified to the original or replaced window procedure.

At step of the method an updated or a second display layout is obtained to use for window message processing. The updated or second display layout may be provided by any suitable means and or mechanisms. In one embodiment the updated or second display layout is stored with the first display layout in the storage element . In another embodiment the updated or second display layout is stored as an updated version of the first display layout and in further embodiments the second display layout may replace the first display layout in the storage element . In one embodiment the client machine communicates the updated or second display layout to the remote machine or stores the second display layout to the storage element on the remote machine . In some embodiments the client machine via a reconnection or re establishment to the remote machine may provide an updated display layout . In one embodiment the client machine communicates an unchanged display layout or a display layout to the remote machine that the remote machine already has stored in the storage element . In yet other embodiments the remote machine or client machine may obtain the second display layout from another client machine on the network such as downloading the second display layout form a remote machine . As described above in connection with illustrative method the window processing mechanism may obtain the display layout from the storage element by a variety of means and or mechanisms.

At step of method the window processing mechanism resumes intercepting and modifying messages to windows based on the second display layout . In one embodiment if the window processing mechanism queued any messages the window processing mechanism analyzes and modifies the queued messages based on the second display layout . Otherwise the window processing mechanism uses the second display layout to modify any messages intercepted after obtaining the second display layout . Using the techniques described herein a client display environment and a client s display layout can be dynamically changed during the course of executing one or more applications and the display of windows for the application appear and behave according to the changes to the display layout. For example another display device may be added to the client and an application may be minimized during a change in the display layout. When the display layout is updated the user can maximize the application and have the application appear in the appropriate display even though the display environment changed when the application was minimized.

In view of the functions structures and operations described above systems and methods are provided to control and direct the appearance behavior and attributes of windows of an application in a flexible manner for virtualizing simulating or providing a multiple display environment without restricting or limiting the client side display configuration. For example the display layout of the client may not be limited to configure the physical monitor of the client as the primary display i.e. as the top left most monitor in the display layout configuration. The systems and methods described may be practiced in a server based or thin client based computing environment with clients having multiple display devices or with clients having a single display device. Additionally the configuration of a display layout that is not restricted or limited to the physical display environment of the client is provided. The display environment of the client may extend to include additional virtual displays so if the client has two display devices three or more displays may be virtualized or simulated for the client. A single display configuration for a single display device may be implemented while still changing the appearance and behavior of windows based on a desired or customized display layout. A client or user may gain the functionality benefits and advantages of a multiple display environment without having multiple display devices or having all the display devices desired.

In one embodiment multi monitor support provides maximizing of windows to fill a single monitor rather than the full screen and centering of dialogs on a monitor rather than on a screen. In another embodiment the session management component the virtual machine service component and a multi monitor hook component executing in a computing environment provided by a virtual machine together provide multi monitor support in a virtual machine environment. In still another embodiment a multi monitor hook component and a component acquiring client geometry data provide multi monitor support in a virtual machine environment.

In one embodiment the session management component reads the monitor configuration for the client machine from a multi monitor hook file mapping. In some embodiments where a user of the client machine establishes a connection to a presentation server executing on an execution machine in which the virtual machine provides access to a computing environment the presentation server generates the multi monitor hook file mapping upon establishment of the connection by the user.

In one embodiment the session management component sends a message to the virtual machine service component containing the monitor layout for the user. In some embodiments the message is sent when the session management component detects a user reconnection so that the monitor layout remains synchronized with the client machine .

The virtual machine service component receives the monitor layout messages provided by the session management component . In some embodiments the virtual machine service component creates a file mapping in the computing environment and updates the file to include monitor layout data.

In other embodiments the virtual machine service component also creates a checksum for the data that is used by the multi monitor hook component to ensure that it has correctly read the layout data. In one of these embodiments a checksum is used rather than a locking scheme to synchronize access to the layout data. In this embodiment the checksum does not cause any blocking between the processes reading the data. The layout data is updated infrequently and may be small in size so the checksum calculation may complete quickly. In another of these embodiments the reader processes save the checksum read the data and recalculate the checksum. If the calculated checksum does not match the saved checksum it indicates that the data was updated while it was being read and the process is repeated. As the data is usually only updated when the user reconnects to another client and given the short time required to read the data it is unlikely that a reader would have to reread the data more than once for a particular change. In some embodiments the virtual machine service component uses a stored default display setting for the client machine the stored default selected to ensure that the computing environment has valid display settings upon initialization of the session.

In some environments a multi monitor hook component executes in a computing environment provided by a virtual machine. In one of these embodiments the multi monitor hook component receives an event for each window created just before the window is created including a window handle for the window being created. The multi monitor hook component may identify a window type of the window and determine to hook window messages for the window. In some embodiments windows having window types indicating that the window can be maximized or that the window is a dialog will be hooked. Hooked windows may be added to an array that contains the window handle and an original window procedure. In other embodiments the multi monitor hook component receives an event indicating that a window is about to be destroyed. In one of these embodiments the multi monitor hook component removes the entry in the hook array associated with the window.

In some embodiments the multi monitor hook component receives an identification of a window after the window is created and before the window is displayed. In one of these embodiments the multi monitor hook component checks the position of the dialog and if it spans multiple monitors the multi monitor hook component repositions the window to the centre of the monitor that contains most of the dialog or the first monitor containing the dialog if the dialogs area is equally split between two monitors. In other embodiments the multi monitor hook component receives an event when a window is about to be maximized. The multi monitor hook component ensures that when the window is maximized from the minimized state it will be positioned on the correct monitor.

In some embodiments the multi monitor hook component receives an event when a window is being maximized. The multi monitor hook component checks the state of the window and if the window is minimized the multi monitor hook component retrieves an identification of a monitor in which the window is minimized from the window hook array. If the window is not minimized the multi monitor hook component identifies the monitor that contains most of the window. If no monitor is found or if the monitor does not exist as after a reconnection monitor is used. The multi monitor hook component then removes the origin and size of the monitor from its saved monitor information and updates the MINMAXINFO structure pointed to by the message. This causes the window to maximize to the specified monitor only.

In some embodiments the virtual machine service component receives authentication information associated with a user of the client machine . In one of these embodiments the virtual machine service component receives the authentication information from a protocol stack component receiving the credentials from the client machine . In another of these embodiments the virtual machine service component receives authentication information from the session management component . In still another of these embodiments the virtual machine service component uses the received authentication information to authenticate the user of the client machine to the computing environment provided by the virtual machine.

In one embodiment when the communications channel is established and the initial session related information is passed to the virtual machine service component the virtual machine service component automatically logs the user into the computing environment. In one embodiment the virtual machine service component receives credentials from the session management component . In another embodiment the virtual machine service component receives credentials previously provided by the user. In some embodiments the user provides credentials to the client machine prior to requesting access to a resource. In one of these embodiments the user provides credentials to a client agent such as an ICA client. The virtual machine service component automatically reconfigures the display settings of the guest operating system to match those of the ICA client. The virtual machine produces graphics and sound output to the virtual devices that redirect that output to a client agent such as an ICA client on the requesting machine. The virtual machine receives audio input mouse and keyboard device data redirected from the ICA client. When the virtual machine is shutdown or suspended the session management component cleans up and shuts down the ICA session.

The remote machines and can belong to the same authentication domain. A domain may comprise a group of machines such as application servers execution machines or client nodes under control of one security database. A domain can include one or more machine farms linked together to act as a single system to provide centralized administration. Conversely a machine farm can include one or more domains. For servers of two different domains to belong to the same machine farm a trust relationship may need to exist between the domains. A trust relationship is an association between the different domains that allows a user to access the resources associated with each domain with just one log on authentication.

In one embodiment the remote machine is in a different domain than the farm . In another embodiment the remote machine is in the same domain as machines and . For either embodiment machines and can belong to one server farm while the remote machine belongs to another machine farm or all of the machines and can belong to the same machine farm. When a new machine is connected to the network the new machine either joins an existing machine farm or starts a new machine farm.

The machines may be in a domain or may be unconnected with any domain. In one embodiment the client machine is in the domain . In another embodiment the client machine is in another domain that does not include any of the machines and . In another embodiment the client machine is not in any domain.

In one embodiment the client machine is in the domain and a user of the machine provides user credentials to log onto the client machine . User credentials typically include the name of the user of the machine the password of the user and the name of the domain in which the user is recognized. The user credentials can be obtained from smart cards time based tokens social security numbers user passwords personal identification PIN numbers digital certificates based on symmetric key or elliptic curve cryptography biometric characteristics of the user or any other means by which the identification of the user of the client node can be obtained and submitted for authentication.

From the user provided credentials the client machine generates user authentication data. The client machine transmits this user authentication data to the remote machine . In this embodiment the user credentials are not transmitted over a network only the resulting user authentication data is transmitted by the client machine .

The remote machine may determine which resources hosted by the machine farm containing remote machine are available for use by the user of the client machine . In one embodiment the remote machine consults user authentication data to make this determination. In another embodiment the remote machine consults information associated with a resource requested by the user to make the determination. The remote machine transmits information representing the available resources to the client machine .

The user authentication performed by the remote machine can suffice to authorize the use of each hosted resource presented to the client machine although such resources may reside at another machine. Accordingly in this embodiment when the client machine accesses or launches i.e. initiates execution of one of the hosted resources additional input of user credentials by the user will be unnecessary to authenticate access to that resource. Thus a single entry of the user credentials can serve to determine the available resources and to authorize the access or launching of such resources without an additional manual log on authentication process by the user.

In the embodiment shown in the machine also includes a security service . In some embodiments the authentication module and the security service are provided as the same dynamically linked library. The security service provides security services to modules and applications on the machine including the authentication module and the thin client application such as authentication to the machine and authentication to remote machines or network services. For example the security service which may be the GSSAPI specified by the Internet Engineering Task Force IETF or the SSPI manufactured by Microsoft Corporation of Redmond Wash. may obtain a Kerberos ticket in response to receipt of the user authentication credentials and use this ticket to obtain additional Kerberos tickets to authenticate the user to remote machines or network services at the request of modules or applications on the machine . The security service may then generate user authentication data using these Kerberos tickets if needed for remote authentication. In one embodiment the security service may generate the user authentication data using an external authentication service such as a Key Distribution Center in a Kerberos environment or Active Directory in a Windows based environment.

The security service provides the generated user authentication data e.g. Kerberos ticket and associated Kerberos authenticator to the thin client application . The thin client application transmits the user authentication data to a remote machine for remote authentication of the user. Thus unlike existing single sign on mechanisms for server based computing user provided authentication credentials are not transmitted over the network to a remote machine . The user authentication data generated by the security service is independent of the method used by the user to authenticate to the machine . Thus for example a Kerberos ticket for the user of machine is obtained whether the user uses a username password combination or a biometric to authenticate to the machine .

In the embodiment shown in the thin client application communicates with the remote machine via a thin client protocol having one or more virtual channels . In these embodiments the thin client application loads a virtual channel driver and uses it to send and receive messages on the authentication virtual channel. In some embodiments the virtual channel driver exposes functions for opening the virtual channel and sending data over it.

The thin client application passes a data structure to the remote machine for the virtual channel when the thin client protocol connection is established indicating to the server side thin client application that the authentication virtual channel is available. In one embodiment the virtual channel data structure for the authentication virtual channel contains the virtual channel information and a representation of the size of the largest data packet the machine can accept from or send to the remote machine over the virtual channel . The data packet size is constrained by the maximum thin client size and any specific memory restrictions imposed by the client machine . In one particular embodiment the data structure for the authentication virtual channel is defined as 

The server side thin client application indicates to the thin client application its intention to perform authentication using the authentication virtual channel by opening the virtual channel and sending a bind request message onto the channel. Once the virtual channel has been opened the virtual channel driver in the thin client application in one embodiment reads a message requesting a binding from the virtual channel sends a message onto the virtual channel responding to the bind request and reads a commit message from the channel. In one embodiment the message requesting a binding includes data specifying the protocol version that is supported. In other embodiments the protocol version can be negotiated between the thin client application and the server side thin client application using the bind request and bind response messages.

The bind request bind response and bind commit initialization messages allow the server side thin client application and the thin client application to conduct a 3 way handshake initiated by the server side thin client application and negotiate capabilities. A 2 way handshake may be initiated by the server side thin client application when the current set of virtual channel capabilities can be negotiated using a 2 way handshake only but a 3 way handshake is supported to allow more flexibility that might be required by new capabilities or future enhancements to current capabilities. For example in a 3 way handshake after receiving a menu of capabilities from the server side thin client application the thin client application can exhibit a specific preference or could instead acknowledge a whole set of options pertaining to a specific capability thus letting the server side thin client application decide on a specific option. In a 2 way handshake to be initiated by the thin client application the thin client application could not exhibit a specific preference because it might not be supported by the host.

Following channel setup the virtual channel driver of both the thin client application and the server side thin client application does the following in a loop until a stop message or an error message is received retrieve authentication data from the security service providing as input any authentication data sent by the other party via the virtual channel and send the retrieved authentication data if any onto the virtual channel in a data message. If the retrieval of data from the security service returned a STOP message then signal stop and close the authentication virtual channel. In some embodiments the virtual channel driver may reset itself on a stop signal. If the retrieval of data from the security service returned a CONTINUE message then continue. If the retrieval of authentication data from the security service returned an ERROR then signal that an error has occurred and close the authentication virtual channel.

As long as stop or error are not signaled the virtual channel driver of the thin client application and the server side thin client application are free to exchange data messages until the security service stops producing data buffers to be sent. In some embodiments the number of messages exchanged may be limited by the virtual channel driver the server side thin client application or the virtual channel . In other embodiments the virtual channel driver of the thin client application and the server side thin client application exchange messages sequentially that is two messages are not sent in one direction without a reply to the first being sent in the other. In either embodiment message exchange can stop after a message has been sent in either direction.

In some particular embodiments the data messages are sent over the virtual channel Least Significant Double Word LSDW Least Significant Word LSW Least Significant Byte LSB first. In other particular embodiments the data messages are aligned at a byte boundary and fully packed in memory. In these embodiments data fields will be aligned in memory as written to or read from the virtual channel.

Some messages transmitted on the authentication virtual channel span multiple virtual channel packets. To support this every message must be preceded by a message specifying the length of the next transmitted command. An example of a message that may be used to specify the length of the next command is 

In some of these embodiments PKT CMDLEN also contains a command number to indicate what type of message is to follow 

A PKT CMDLEN packet containing Length 0 indicates that no more data will follow i.e. a logical channel close .

The server side thin client application passes the authentication data it receives over the authentication virtual channel to its security service . If the server side security service is able to verify the data it generates an access token representing a logon session for the user allowing the user to authenticate to the remote machine without resubmitting authentication credentials. An access token is a data object that includes among other things a locally unique identifier LUID for the logon session. If the server side security service is not able to verify the data the user is prompted to resubmit authentication credentials.

In some embodiments until the server side security service authenticates the user the only virtual channel over which the user may communicate with the remote machine is the authentication virtual channel. In some of these embodiments after authentication new virtual channels are initiated for communication. In other embodiments only one virtual channel exists and it may only be used for authentication related communications until the user is authenticated and it may be used for other communications after the user is authenticated.

For embodiments in which the remote machine operates under control of a MICROSOFT WINDOWS operating system the access token generated by the server side security service is an impersonation token that has only network logon rights. That is the generated access token is not suitable to use for starting applications to run interactively as is required in the WINDOWS server based computing environment. To allow applications to run interactively a primary access token is needed that has interactive logon rights. In one embodiment the generated access token is modified to provide the appropriate rights. In another embodiment a new token is generated for the user.

For embodiments in which the server side computing device operates under control of a Unix based operating system if the server side security service verifies the authentication data it receives over the authentication virtual channel from the server side thin client application the server side thin client application will grant the user access to the resources. In these embodiments the server side security service does not generate an access token.

In some embodiments after the remote machine has authenticated the user the remote machine presents an enumeration of resources available to the user. In these embodiments the remote machine may create a page describing a display of resources hosted by a plurality of machines available to the machine . The remote machine may then transmit the created page to the machine for display and receive from the machine a request to access one of the hosted resources.

In some of these embodiments the selected one of the available resources hosted by one of the plurality of machines is then executed without requiring further receipt of user authentication data from the machine . In some of these embodiments the remote machine initiates in response to successful authentication by the user a connection from the remote machine to a second remote machine which is hosting a resource available to the user. In these embodiments the available resource is executed over the connection. In some embodiments the connection is a virtual channel.

In other embodiments the first remote machine is hosting the selected one of the available resources. In some of these embodiments the remote machine makes the resource available to the user over the existing connection. In others of these embodiments the remote machine makes the resource available to the user over a new connection. In some of those embodiments the new connection comprises a virtual channel.

In some embodiments a plurality of components are provided for authenticating a user of the client machine to a virtual machine on a remote machine . In one of these embodiments functionality is provided for a Kerberos based Single Sign On process between the client machine and a guest operating system provided by the virtual machine.

In some embodiments a user seeking to access a resource provided by a virtual machine provides authentication credentials multiple times to different entities. In one of these embodiments the user is authenticated by a client agent on the client machine by a remote machine and by a computing environment provided by a virtual machine in the remote machine . In some of these embodiments single sign on support would enable authentication of the user to different entities with only one transmission of authentication credentials from the user.

Authentication of the user to the client machine and the remote machine may be accomplished as described above in connection with . In some embodiments an authentication component a GINA Graphical Identification and Authentication component an authentication module in the session management component and an authentication module for the virtual machine service component are provided. In one embodiment a bi directional virtual channel enables communication between a service management component on the remote machine and a virtual machine service component executing in the guest operating system. In one embodiment the remote machine includes client side single sign on functionality and the virtual machine includes server side single sign on functionality. In still another embodiment the service management component implements an authentication module and communicates with an authentication module in the virtual machine service component to authenticate the user.

In one embodiment the session management component creates a Kerberos SSPI channel between itself and the virtual machine service component. When the channel is established the session management component acquires the credentials of the user and initializes a security context using this data. The initialization data returned is sent to the virtual machine service component which accepts the data and starts an exchange of SSPI messages between the two components until the security context is established in the virtual machine service component. This context is then used to log the user on to the virtual machine using a single sign on GINA component.

In some embodiments the session management component authenticates the user to a host operating system on the remote machine . In one of these embodiments the host operating system then authenticates the user to the virtual machine. In other embodiments the session management component authenticates the user to a hypervisor. In one of these embodiments the hypervisor then authenticates the user to the virtual machine. In still other embodiments the session management component authenticates the user to a virtual machine providing management functionality for the virtual machine to which the user seeks access.

Referring back to a remote machine may determine to provide access to a resource streaming service capable of transmitting a requested resource to the client machine step . In some embodiments the remote machine determines to implement a resource streaming service to transmit to the client machine or to a remote machine a requested resource. In other embodiments the remote machine determines to use a resource streaming service to stream the resource to a computing environment provided by a virtual machine. In still other embodiments the resource is a computing environment and the remote machine determines to use a resource streaming technique to stream the computing environment to a virtual machine. In some embodiments the plurality of resource files resides on the remote machine . In other embodiments the plurality of resource files resides on a separate file server or remote machine . In still other embodiments the plurality of resource files may be transmitted to a client machine . In yet other embodiments a file in the plurality of resource files may be executed prior to transmission of a second file in the plurality of resource files to the client machine .

In some embodiments the remote machine retrieves information about the enumerated resource from a remote machine . In one of these embodiments the remote machine receives an identification of a remote machine hosting a plurality of resource files. In another of these embodiments the remote machine receives identification of a location of a plurality of resource files the identification conforming to a Universal Naming Convention UNC . In still another of these embodiments the identification includes a network location and a socket for a resource streaming protocol.

In one embodiment the remote machine retrieves a file containing information about the enumerated resource. The file may include an identification of a location of a remote machine hosting the enumerated resource. The file may include an identification of a plurality of versions of the enumerated resource. The file may include an enumeration of a plurality of resource files comprising the enumerated resource. The file may include an identification of a compressed file comprising a plurality of resources files comprising the enumerated resource. The file may include an identification of pre requisites to be satisfied by a machine executing the enumerated resource. The file may include an enumeration of data files associated with the enumerated resource. The file may include an enumeration of scripts to be executed on a machine executing the enumerated resource. The file may include an enumeration of registry data associated with the enumerated resource. The file may include an enumeration of rules for use in an embodiment where the enumerated resource executes within an isolation environment. In one embodiment the file may be referred to as a manifest file. The information that the file may contain is described in further detail below.

The stream of data packets may include resource files comprising the enumerated resource. In some embodiments resource files include data files associated with an resource. In other embodiments resource files include executable files required for execution of the resource. In still other embodiments the resource files include metadata including information about the files such as location compatibility requirements configuration data registry data identification of execution scripts rules for use in isolation environments or authorization requirements.

In some embodiments the streamed resource executes prior to the transmission of each resource file in a plurality of resource files comprising the streamed resource. In one of these embodiments execution of the streamed resource begins upon receipt by a client machine of one resource file in the plurality of resources. In another of these embodiments execution of the streamed resource begins upon receipt by a client machine of an executable resource file in the plurality of resource files. In still another of these embodiments the client machine executes a first received resource file in a plurality of resource files and the first received resource file requests access to a second resource file in the plurality of resource files.

In one embodiment the streamed resource executes on the client machine without permanently residing on the client machine . In this embodiment the streamed resource may execute on the client machine and be removed from the client machine upon termination of the streamed resource. In another embodiment the streamed resource executes on the client machine after a pre deployed copy of each resource file is stored on the client machine . In still another embodiment the streamed resource executes on the client machine after a copy of each resource file is stored in an isolation environment on the client machine . In yet another embodiment the streamed resource executes on the client machine after a copy of each resource file is stored in a cache on the client machine .

In some embodiments the remote machine streams the enumerated resource to the remote machine executes the enumerated resource on the remote machine and provides to the client machine resource output data generated by the execution of the enumerated resource. In other embodiments a resource is streamed to a virtual machine and resource output data is transmitted to a client machine using a presentation layer protocol such as X11 VNC ICA or RDP.

In one embodiment the remote machine receives a plurality of resource files comprising the enumerated resource. In another embodiment the remote machine provides the resource output data via a presentation level protocol such as an ICA presentation level protocol or a Remote Desktop Windows presentation level protocol or an X Windows presentation level protocol.

In some embodiments the remote machine also provides access information associated with the enumerated resource the access information generated responsive to the selected method. In one of these embodiments the access information provides an indication to the client machine of the selected method for execution of the enumerated resource. In another of these embodiments the access information includes an identification of a location of the enumerated resource the identification conforming to a Universal Naming Convention UNC . In still another of these embodiments the access information includes an identification of a session management server.

In some embodiments the access information includes a launch ticket comprising authentication information. In one of these embodiments the client machine may use the launch ticket to authenticate the access information received from the remote machine . In another of these embodiments the client machine may use the launch ticket to authenticate itself to a second remote machine hosting the enumerated resource. In still another of these embodiments the remote machine includes the launch ticket in the access information responsive to a request from the client machine for the launch ticket.

Referring now to flow diagram depicts one embodiment of the steps taken to access a plurality of files comprising a resource such as a computing environment or an application program. A client machine performs a pre launch analysis step . In one embodiment the client machine performs the pre launch analysis prior to retrieving and executing a plurality of resource files comprising a resource. In another embodiment the client machine performs the pre launch analysis responsive to a received indication that the pre launch analysis is a requirement for authorization to access the plurality of resource files comprising a resource.

In some embodiments the client machine receives from a remote machine access information associated with the plurality of resource files. In one of these embodiments the access information includes an identification of a location of a remote machine hosting the plurality of resource files. In another of these embodiments the client machine receives an identification of a plurality of resources comprising one or more versions of the resource. In still another of these embodiments the client machine receives an identification of a plurality of resource files comprising one or more resources. In other embodiments the client machine receives an enumeration of resources available to the client machine for retrieval and execution. In one of these embodiments the enumeration results from an evaluation of the client machine . In still other embodiments the client machine retrieves at least one characteristic responsive to the retrieved identification of the plurality of resource files comprising a resource.

In some embodiments the access information includes a launch ticket capable of authorizing the client machine to access the plurality of resource files. In one of these embodiments the launch ticket is provided to the client machine responsive to an evaluation of the client machine . In another of these embodiments the launch ticket is provided to the client machine subsequent to a pre launch analysis of the client machine by the client machine .

In other embodiments the client machine retrieves at least one characteristic required for execution of the plurality of resource files. In one of these embodiments the access information includes the at least one characteristic. In another of these embodiments the access information indicates a location of a file for retrieval by the client machine the file enumerating the at least one characteristic. In still another of these embodiments the file enumerating the at least one characteristic further comprises an enumeration of the plurality of resource files and an identification of a remote machine hosting the plurality of resource files.

The client machine determines the existence of the at least one characteristic on the client machine . In one embodiment the client machine makes this determination as part of the pre launch analysis. In another embodiment the client machine determines whether the client machine has the at least one characteristic.

In one embodiment determining the existence of the at least one characteristic on the client machine includes determining whether a device driver is installed on the client machine . In another embodiment determining the existence of the at least one characteristic on the client machine includes determining whether an operating system is installed on the client machine . In still another embodiment determining the existence of the at least one characteristic on the client machine includes determining whether a particular operating system is installed on the client machine . In yet another embodiment determining the existence of the at least one characteristic on the client machine includes determining whether a particular revision level of an operating system is installed on the client machine . For embodiments in which a remote machine acts as a client machine such as for example a terminal services session in which the remote machine executes computing resources on behalf of a user of a client machine determining the existence of at least on characteristic may include determining whether the remote machine executes a hypervisor or alternatively whether the remote machine executes a hypervisor which itself executes in the native operating system.

In some embodiments determining the existence of the at least one characteristic on the client machine includes determining whether the client machine has acquired authorization to execute an enumerated resource. In one of these embodiments a determination is made by the client machine as to whether the client machine has received a license to execute the enumerated resource. In another of these embodiments a determination is made by the client machine as to whether the client machine has received a license to receive across a resource streaming session a plurality of resource files comprising the enumerated resource. In other embodiments determining the existence of the at least one characteristic on the client machine includes determining whether the client machine has sufficient bandwidth available to retrieve and execute an enumerated resource.

In some embodiments determining the existence of the at least one characteristic on the client machine includes execution of a script on the client machine . In other embodiments determining the existence of the at least one characteristic on the client machine includes installation of software on the client machine . In still other embodiments determining the existence of the at least one characteristic on the client machine includes modification of a registry on the client machine . In yet other embodiments determining the existence of the at least one characteristic on the client machine includes transmission of a collection agent to the client machine for execution on the client machine to gather credentials associated with the client machine .

The client machine requests from a remote machine authorization for execution of the plurality of resource files the request including a launch ticket step . In some embodiments the client machine makes the request responsive to a determination that at least one characteristic exists on the client machine . In one of these embodiments the client machine determines that a plurality of characteristics exist on the client machine the plurality of characteristics associated with an enumerated resource and received responsive to a request to execute the enumerated resource. In another of these embodiments whether the client machine receives an indication that authorization for execution of the enumerated resource files depends upon existence of the at least one characteristic on the client machine . In one embodiment the client machine received an enumeration of resources requested execution of an enumerated resource and received access information including the at least one characteristic and a launch ticket authorizing the execution of the enumerated resource upon the determination of the existence of the at least one characteristic on the client machine . In one embodiment the client machine receives from the remote machine a license authorizing execution of the plurality of resource files. In some embodiments the license authorizes execution for a specified time period. In one of these embodiments the license requires transmission of a heart beat message to maintain authorization for execution of the plurality of resource files. For embodiments in which a virtual machine is streamed or otherwise downloaded to the client machine a license pool may be provided that authorizes the virtual machine its guest operating system and all the licensed software installed within that guest operating system. In some of these embodiments a single license is provided that authorizes those entities.

In another embodiment the client machine receives from the remote machine the license and an identifier associated with a remote machine monitoring execution of the plurality of resource files. In some embodiments the remote machine is a session management server as described below in connection with . In one of these embodiments the session management server includes a session management subsystem that monitors the session associated with the client machine . In other embodiments a separate remote machine is the session management server .

Referring back to the client machine receives and executes the plurality of resource files step . In one embodiment the client machine receives the plurality of resource files across a resource streaming session. In another embodiment the client machine stores the plurality of resource files in an isolation environment on the client machine . In still another embodiment the client machine executes one of the plurality of resource files prior to receiving a second of the plurality of resource files. In some embodiments a remote machine transmits the plurality of resource files to a plurality of client machines each client machine in the plurality having established a separate resource streaming session with the remote machine .

In some embodiments the client machine stores the plurality of resource files in a cache and delays execution of the resource files. In one of these embodiments the client machine receives authorization to execute the resource files during a pre defined period of time. In another of these embodiments the client machine receives authorization to execute the resource files during the pre defined period of time when the client machine lacks access to a network. In other embodiments the client machine stores the plurality of resource files in a cache. In one of these embodiments a resource streaming client described in further detail below in connection with establishes an internal resource streaming session to retrieve the plurality of resource files from the cache. In another of these embodiments the client machine receives authorization to execute the resource files during a pre defined period of time when the client machine lacks access to a network.

The client machine transmits at least one heartbeat message to a remote machine step . In some embodiments the client machine transmits the at least one heartbeat message to retain authorization to execute the plurality of resource files comprising the enumerated resource. In other embodiments the client machine transmits the at least one heartbeat message to retain authorization retrieve a resource file in the plurality of resource files. In still other embodiments the client machine receives a license authorizing execution of the plurality of resource files during a pre determined period of time.

In some embodiments the client machine transmits the heartbeat message to a second remote machine . In one of these embodiments the second remote machine may comprise a session management server monitoring the retrieval and execution of the plurality of resource files. In another of these embodiments the second remote machine may renew a license authorizing execution of the plurality of resource files responsive to the transmitted heartbeat message. In still another of these embodiments the second remote machine may transmit to the client machine a command responsive to the transmitted heartbeat message.

Referring now to the client machine may include a resource streaming client a streaming service and an isolation environment .

The resource streaming client may be an executable program. In some embodiments the resource streaming client may be able to launch another executable program. In other embodiments the resource streaming client may initiate the streaming service . In one of these embodiments the resource streaming client may provide the streaming service with a parameter associated with executing a resource. In another of these embodiments the resource streaming client may initiate the streaming service using a remote procedure call.

In one embodiment the client machine requests execution of a resource and receives access information from a remote machine regarding execution. In another embodiment the resource streaming client receives the access information. In still another embodiment the resource streaming client provides the access information to the streaming service . In yet another embodiment the access information includes an identification of a location of a file associated with a plurality of resource files comprising the resource.

In one embodiment the streaming service retrieves a file associated with a plurality of resource files. In some embodiments the retrieved file includes an identification of a location of the plurality of resource files. In one of these embodiments the streaming service retrieves the plurality of resource files. In another of these embodiments the streaming service executes the retrieved plurality of resource files on the client machine . In other embodiments the streaming service transmits heartbeat messages to a remote machine to maintain authorization to retrieve and execute a plurality of resource files.

In some embodiments the retrieved file includes an identification of a location of more than one plurality of resource files each plurality of resource files comprising a different resource. In one of these embodiments the streaming service retrieves the plurality of resource files comprising the resource compatible with the client machine . In another of these embodiments the streaming service receives authorization to retrieve a particular plurality of resource files responsive to an evaluation of the client machine .

In some embodiments the plurality of resource files are compressed and stored on a file server within an archive file such as a CAB ZIP SIT TAR JAR or other archive file. In one embodiment a plurality of resource files stored in an archive file comprises a resource. In another embodiment multiple pluralities of resource files stored in an archive file each comprise different versions of a resource. In still another embodiment multiple pluralities of resource files stored in an archive file each comprise different resources. In some embodiments an archive file includes metadata associated with each file in the plurality of resource files. In one of these embodiments the streaming service generates a directory structure responsive to the included metadata. As will be described in greater detail below the metadata may be used to satisfy requests by resources for directory enumeration.

In one embodiment the streaming service decompresses an archive file to acquire the plurality of resource files. In another embodiment the streaming service determines whether a local copy of a file within the plurality of resource files exists in a cache on the client machine prior to retrieving the file from the plurality of resource files. In still another embodiment the file system filter driver determines whether the local copy exists in the cache. In some embodiments the streaming service modifies a registry entry prior to retrieving a file within the plurality of resource files.

In some embodiments the streaming service stores a plurality of resource files in a cache on the client machine . In one of these embodiments the streaming service may provide functionality for caching a plurality of resource files upon receiving a request to cache the plurality of resource files. In another of these embodiments the streaming service may provide functionality for securing a cache on the client machine . In another of these embodiments the streaming service may use an algorithm to adjust a size and a location of the cache.

In some embodiments the streaming service creates an isolation environment on the client machine . In one of these embodiments the streaming service uses an isolation environment application programming interface to create the isolation environment . In another of these embodiments the streaming service stores the plurality of resource files in the isolation environment . In still another of these embodiments the streaming service executes a file in the plurality of resource files within the isolation environment. In yet another of these embodiments the streaming service executes the resource in the isolation environment. In some embodiments the streaming service accesses an isolation environment provided by a virtual machine.

For embodiments in which authorization is received to execute a resource on the client machine the execution of the resource may occur within an isolation environment . In some embodiments a plurality of resource files comprising the resource is stored on the client machine prior to execution of the resource. In other embodiments a subset of the plurality of resource files is stored on the client machine prior to execution of the resource. In still other embodiments the plurality of resource files does not reside in the isolation environment . In yet other embodiments a subset of the plurality of resources files do not reside on the client machine . Regardless of whether a subset of the plurality of resource files or each resource file in the plurality of resource files reside on the client machine or in isolation environment in some embodiments a resource file in the plurality of resource files may be executed within an isolation environment .

In some embodiments isolation environments are used to provide additional functionality to the resource streaming client . In one of these embodiments a resource is executed within an isolation environment. In another of these embodiments a retrieved plurality of resource files resides within the isolation environment. In still another of these embodiments changes to a registry on the client machine are made within the isolation environment.

In one embodiment the resource streaming client includes an isolation environment . In some embodiments the resource streaming client includes a file system filter driver intercepting resource requests for files. In one of these embodiments the file system filter driver intercepts a resource request to open an existing file and determines that the file does not reside in the isolation environment . In another of these embodiments the file system filter driver redirects the request to the streaming service responsive to a determination that the file does not reside in the isolation environment . The streaming service may extract the file from the plurality of resource files and store the file in the isolation environment . The file system filter driver may then respond to the request for the file with the stored copy of the file. In some embodiments the file system filter driver may redirect the request for the file to a file server responsive to an indication that the streaming service has not retrieved the file or the plurality of resource files and a determination the file does not reside in the isolation environment .

In some embodiments the file system filter driver uses a strict isolation rule to prevent conflicting or inconsistent data from appearing in the isolation environment . In one of these embodiments the file system filter driver intercepting a request for a resource in a user isolation environment may redirect the request to a resource isolation environment. In another of these embodiments the file system filter driver does not redirect the request to a system scope.

In one embodiment the streaming service uses IOCTL commands to communicate with the filter driver. In another embodiment communications to the file server are received with the Microsoft SMB streaming protocol.

Referring now to a flow diagram depicts one embodiment of steps taken by a client machine to execute a resource. As described above in regarding step a client machine receives and executes the plurality of resource files. In brief overview the client machine receives a file including access information for accessing a plurality of resource files and for executing a first client capable of receiving a resource stream step . The client machine retrieves an identification of the plurality of resource files responsive to the file step . The client machine retrieves at least one characteristic required for execution of the plurality of resource files responsive to the file step . The client machine determines whether the client machine includes the at least one characteristic step . The client machine executes a second client the second client requesting execution of the plurality of resource files on a remote machine responsive to a determination that the client machine lacks the at least one characteristic step .

Referring to and in greater detail the client machine receives a file including access information for accessing a plurality of resource files and for executing a first client capable of receiving a resource stream step . In one embodiment the client machine receives access information including an identification of a location of a plurality of resource files comprising a resource. In another embodiment the client machine receives the file responsive to requesting execution of the resource. In still another embodiment the access information includes an indication that the plurality of resource files reside on a remote machine such as a resource server or a file server. In yet another embodiment the access information indicates that the client machine may retrieve the plurality of resource files from the remote machine over a resource streaming session.

The client machine retrieves an identification of the plurality of resource files responsive to the file step . In one embodiment the client machine identifies a remote machine on which the plurality of resource files resides responsive to the file including access information. In another embodiment the client machine retrieves from the remote machine a file identifying the plurality of resource files. In some embodiments the plurality of resource files comprises a resource. In other embodiments the plurality of resource files comprises multiple resources. In still other embodiments the plurality of resource files comprises multiple versions of a single resource.

Referring ahead to a block diagram depicts one embodiment of a plurality of resource files residing on a remote machine such as file server . In a plurality of resource files referred to as a package includes resource files comprising three different versions of one or more resources.

In one embodiment each subset of resource files comprising a version of one or more resources and stored within the package is referred to as a target. Target 1 for example includes a version of a word processing resource and of a spreadsheet program the version compatible with the English language version of the Microsoft Windows 2000 operating system. Target 2 includes a version of a word processing resource and of a spreadsheet program the version compatible with the English language version of the Microsoft XP operating system. Target 3 a version of a word processing resource and of a spreadsheet program the version compatible with the Japanese language version of the Microsoft Windows 2003 operating system with service pack 3.

Returning back to in some embodiments the file retrieved from the remote machine hosting the plurality of resource files includes a description of the package and the targets included in the plurality of resource files. In other embodiments the file retrieved from the remote machine identifies the plurality of resource files comprising a resource requested for execution by the client machine .

The client machine retrieves at least one characteristic required for execution of the plurality of resource files responsive to the file step . In some embodiments the client machine may not execute a resource unless the client machine includes certain characteristics. In one of these embodiments different resources require client machines to include different characteristics from the characteristics required by other resources. In another of these embodiments the client machine receives an identification of the at least one characteristic required for execution of the plurality of resource files comprising the resource requested by the client machine .

Still referring to the client machine determines whether the client machine includes the at least one characteristic step . In one embodiment the client machine evaluates an operating system on the client machine to determine whether the client machine includes the at least one characteristic. In another embodiment the client machine identifies a language used by an operating system on the client machine to determine whether the client machine includes the at least one characteristic. In still another embodiment the client machine identifies a revision level of an operating system on the client machine to determine whether the client machine includes the at least one characteristic. In yet another embodiment the client machine identifies a resource version of a resource residing on the client machine to determine whether the client machine includes the at least one characteristic. In some embodiments the client machine determines whether the client machine includes a device driver to determine whether the client machine includes the at least one characteristic. In other embodiments the client machine determines whether the client machine includes an operating system to determine whether the client machine includes the at least one characteristic. In still other embodiments the client machine determines whether the client machine includes a license to execute the plurality of resource files to determine whether the client machine includes the at least one characteristic.

In one embodiment the client machine determines whether the client machine comprises a required amount of available disk space to access the resource. In another embodiment the client machine determines whether a central processing unit of the client machine provides a required processing speed. In still another embodiment the client machine determines whether the client machine comprises a required amount of available RAM. In yet another embodiment the client machine determines whether the client machine comprises a required level of graphical processing and display capabilities.

The client machine executes a second client the second client requesting execution of the plurality of resource files on a remote machine responsive to a determination that the client machine lacks the at least one characteristic step . In one embodiment when the client machine determines that the client machine lacks the at least one characteristic the client machine does not execute the first client capable of receiving a resource stream. In another embodiment a policy prohibits the client machine from receiving the plurality of resource files over a resource stream when the client machine lacks the at least one characteristic. In some embodiments the client machine determines that the client machine does include the at least one characteristic. In one of these embodiments the client machine executes the first client the first client receiving a resource stream comprising the plurality of resource files from a remote machine for execution on the client machine .

In some embodiments the client machine executes the second client requesting execution of the plurality of resource files on a remote machine upon determining that the client machine lacks the at least one characteristic. In one of these embodiments the second client transmits the request to a remote machine hosting the plurality of resource files. In another of these embodiments the remote machine executes the plurality of resource files comprising the resource and generates resource output data. In still another of these embodiments the second client receives resource output data generated by execution of the plurality of resource files on the remote machine . In yet another of these embodiments the second client displays the resource output on the client machine . In one embodiment the client machine requests execution of the plurality of application files on a physical machine . In another embodiment the client machine requests execution of the plurality of application files on a virtual machine executing on a remote machine .

In some embodiments the second client receives a file comprising access information for accessing a plurality of resource files and requests responsive to a determination by the first client that the client machine lacks the at least one characteristic execution of the plurality of resource files on a virtual machine providing a computing environment having the least one characteristic. In other embodiments the client machine executes the second client requesting execution of the plurality of resource files on a remote machine upon determining that the client machine lacks the at least one characteristic. In one of these embodiments the second client transmits the request to a remote machine hosting the plurality of resource files. In another of these embodiments a virtual machine executing on the remote machine executes the plurality of resource files comprising the resource and generates resource output data. In still another of these embodiments the second client receives resource output data generated by execution of the plurality of resource files on the virtual machine. In yet another of these embodiments the second client displays the resource output on the client machine .

In some embodiments the second client transmits the request to a remote machine that does not host the plurality of resource files. In one of these embodiments the remote machine may request the plurality of resource files from a second remote machine hosting the plurality of resource files. In another of these embodiments the remote machine may receive the plurality of resource files from the second remote machine across a resource streaming session. In still another of these embodiments the remote machine stores the received plurality of resource files in an isolation environment and executes the resource within the isolation environment. In yet another of these embodiments the remote machine transmits the generated resource output data to the second client on the client machine .

In some embodiments the second client transmits the request to a remote machine that does not host the plurality of resource files. In one of these embodiments the remote machine may request the plurality of resource files from a second remote machine hosting the plurality of resource files. In another of these embodiments the remote machine may receive the plurality of resource files from the second remote machine across a resource streaming session.

In other embodiments the remote machine stores the received plurality of resource files in a computing environment provided by a virtual machine executing on the remote machine the computing environment having the at least one characteristic. In yet another of these embodiments the remote machine executes the resource within the computing environment provided by the virtual machine and transmits the generated resource output data to the second client on the client machine .

In some embodiments a virtual machine on the remote machine executes the plurality of resource files. In one of these embodiments the virtual machine receives for execution a resource stream comprising the plurality of resource files. In some embodiments a virtual machine may receive for execution a resource stream responsive to an application of a policy. In one of these embodiments the result of the application of the policy depends on an availability of the requested resource in the machine farm including availability of a suitably configured physical machine or virtual machine the sensitivity of the requested resource including whether a policy prevents the transmission of the requested resource to an unsecured environment information associated with the user of the client machine including authorization to execute or access the requested resource in an unsecured environment .

Referring back to in one embodiment the first client machine capable of receiving the resource stream is a resource streaming client . The resource streaming client receiving the file retrieving an identification of a plurality of resource files and at least one characteristic required for execution of the plurality of resource files responsive to the file and determining whether the client machine includes the at least one characteristic. In another embodiment the second client is a client agent . In some embodiments the client agent receives the file from the resource streaming client responsive to a determination by the resource streaming client that the client machine lacks the at least one characteristic.

A remote machine includes functionality for monitoring resource usage by a client machine . The remote machine may monitor the status of each resource used by the client machine for example upon execution or termination of a resource. In one embodiment the remote machine requires the client machine to transmit messages about the status of a resource executed by the client machine . In another embodiment when a client machine connects to a network on which the remote machine resides the client machine transmits a message indicating that the client machine has connected to the network.

In one embodiment the client machine is said to have a session when the client machine interacts with the remote machine and executes one or more resources. In another embodiment the remote machine requires the client machine to maintain for the duration of a session a license authorizing execution of resources received from a remote machine . In still another embodiment sessions have unique session identifiers assigned by the remote machine .

In one embodiment the client machine transmits the messages to the remote machine with which it interacted to receive and execute the resource. In another embodiment the client machine receives from the remote machine an identifier of a second remote machine such as a session management server the second remote machine receiving and storing all transmitted messages associated with the session on the client machine .

In some embodiments the session management server is a remote machine providing license management and session monitoring services. In one of these embodiments the session management server includes a server management subsystem providing these services.

In one embodiment the client machine transmits messages directly to the session management server . In another embodiment the client machine transmits messages to a remote machine the remote machine forwarding the messages to the session management server with an identification of the client machine .

A client machine may transmit a heartbeat message to the remote machine . In one embodiment the heartbeat message includes a request for a license. In this embodiment the client machine may transmit the heartbeat message after receiving access information associated with a resource which the client machine requested authorization to execute. The client machine may transmit the heartbeat message prior to executing the resource. In one embodiment the client machine includes with the heartbeat message a launch ticket received with the access information. In this embodiment the remote machine may grant the client machine a license upon successful verification of the launch ticket.

In another embodiment the heartbeat message includes an indication that the client machine has initiated execution of a resource. In still another embodiment the heartbeat message includes an indication that the client machine has terminated execution of a resource. In yet another embodiment the heartbeat message includes an indication of a failure to execute a resource.

In one embodiment the heartbeat message includes a request for an identification of a second session management server such as a session management server . In another embodiment the heartbeat message includes an indication that the client machine has connected to a network on which the remote machine resides.

In some embodiments the heartbeat message includes a request to reset a resource streaming session. In one of these embodiments the client machine transmits this heartbeat message when an error has occurred and a connection is terminated between a network on which the remote machine resides and the client machine . In another of these embodiments the client machine transmits with the heartbeat message information associated with the session. In still another of these embodiments the remote machine may transmit to the client machine session related data if the session has not expired.

In another of these embodiments if a remote machine disconnects from a network on which it replies the client machine may not receive a reply to a heartbeat message transmitted to the remote machine . In one embodiment the client machine may re establish a session by transmitting a message requesting a session reset to the remote machine . In another embodiment the client machine may re establish a session by transmitting a message requesting a session reset to a second remote machine . In some embodiments when the remote machine reconnects to the network it will create a new session for each session reset request received while the remote machine was disconnected. In one of these embodiments the new session will be associated with the reconnected and unlicensed state. In another of these embodiments no new license will be acquired for the new session. In still another of these embodiments when the client machine executes a resource a new license will be acquired and all sessions associated with the client machine will be associated with an active and licensed state.

In some embodiments a resource streaming client on the client machine generates the heartbeat message. In one of these embodiments the resource streaming client forwards the heartbeat message to a web interface for transmission to the client machine for transmission to the remote machine . In other embodiments the management service on the remote machine receives the heartbeat message from the client machine via the web interface . In still other embodiments a remote machine comprising a collector point described above receives and stores the heartbeat messages.

In some embodiments the resource streaming client requests a license from the remote machine . In one of these embodiments the license authorizes execution of a resource on the client machine . In another of these embodiments the remote machine may access a second remote machine to provide the license. In still another of these embodiments the remote machine may provide the license to the client machine . In yet another of these embodiments the remote machine may provide a license acceptable for authorization purposes to a second remote machine . In some embodiments the license is revoked upon termination of execution of a resource.

Referring back to a request for access to a resource is received step . In some embodiments the resource is a file. In one of these embodiments an application program is selected and executed to provide access to the file. In another of these embodiments a type of file associated with the requested file is identified to select an application program for execution. In still another of these embodiments prior to the request for access to the file an application program is associated with a type of file enabling automatic selection of the application program upon identification of a type of file associated with the requested file. In some embodiments file type association FTA functionality permits users to automatically initiate the execution of application programs associated with a data file even though the data file and the executable program are hosted on different computing nodes.

Typically file type association functionality permits users to transparently execute executable programs by selecting data files located on a computing machine that differs from the machine s where the executable programs are located. In one embodiment a user of a client machine can transparently invoke the execution of an executable program on a remote machine by selecting a data file located on the client machine . In another embodiment a user can transparently invoke the execution of an application program on their client machine by selecting a data file located on a remote machine . In still another embodiment a user can select a data file stored on a remote machine such as a web server and transparently invoke the execution of an associated executable program on a remote machine such as an application execution server. Typically execution permits processing of the contents of the selected data file the output of which is then provided to the user at the client machine .

It is to be understood that examples using filename extensions necessarily reflect the idiosyncrasies of embodiments utilizing the WINDOWS family of operating systems. Other embodiments implement methods and apparatus in accord using special parameters stored in the data file itself the data contained in the data file the file system records associated with the data file or a separate data file or database. For example embodiments using the MacOS family of operating systems utilize file and application creator types and store file type association data in the Desktop file associated with each storage device. Embodiments using a UNIX variant operating system utilize file extensions embedded parameters or other mechanisms as appropriate. Accordingly the scope of the claims should not be read to be limited to embodiments relying on filename extensions or embodiments utilizing WINDOWS operating systems.

Referring to a flow diagram depicts one embodiment of the steps taken in a method of enabling transparent distributed program execution on a remote machine through the selection of graphical indicia representative of a data file located on the client machine . The client machine receives from one of a plurality of remote machines a mapping specifying an association between a type of data file and an executable program for execution on one of a plurality of remote machines Step . In some embodiments the mapping specifies an association between a type of data file and an executable program for execution on a virtual machine located on one of a plurality of remote machines .

The client machine presents a graphical depiction of a data file stored on the client machine Step and receives a selection of the graphical depiction of the data file Step . The client machine identifies an executable program associated with the type of the selected data file using the received mapping Step and sends a request to a remote machine for execution of the identified executable program Step . In one embodiment the client machine initiates the execution of a local display application Step to receive application output data from the executing program Step which it displays to the end user Step .

Still referring to when the client machine receives the mapping Step the mapping may be received by itself with several other mappings or with other messages or data such as software updates. Table 3 illustrates an exemplary mapping provided in one embodiment of the invention 

In one embodiment the mapping identifies an association between a particular executable program for use with a particular data file or type of data file stored on the user s client machine . In another embodiment the mapping specifies the relationship between an executable program and a data file in terms of a client machine application that launches the executable program on a remote machine and displays the output from execution at the client machine . For example as described in connection with step the mapping could specify that when a .DOC file is selected the client machine is to execute METAFRAME from Citrix Software of Ft. Lauderdale Fla. which in turn sends a request to one of a plurality of remote machines to execute WORD receiving the output data from execution for display to the user at the client machine . In some embodiments a remote machine receiving the request to execute the application program chooses a method for providing access to the application program as described above in connection with step . In one of these embodiments the remote machine determines to execute the application and provide the application output data to the client machine . In another of these embodiments the remote machine identifies a remote machine that executes the application and provides the application output data to the client machine . In still another of these embodiments the remote machine identifies an application streaming service that transmits the application program to the client machine for local execution. In yet another of these embodiments the remote machine identifies a remote machine on which a virtual machine provides a computing environment capable of executing the application program and transmitting the application output data to the client machine .

In still another embodiment mapping specifies the relationship between an executable program and a data file in terms of a client machine application that requests transmission of the executable program to the client machine from an application streaming service provided by a remote machine . In other embodiments the mapping could specify that when a file is selected the client machine is to establish a connection to a virtual machine provided by one of a plurality of remote machines to initiate execution of an application program on the virtual machine and to receive application output data from the execution for display to the user at client machine . In some of these embodiments as described in connection with step a virtual machine and an execution machine onto which the virtual machine is launched are identified configured and provide the user of the client machine with access to the file.

In some embodiments the client machine displays a list of file names associated with data files stored on the client machine . In still another embodiment indicia representative of files stored on the client machine are intermingled with indicia representative of files stored on one or more remote machines or on virtual machines executing on remote machines . In this embodiment client based FTA is operative when indicia representative of a file stored on the client machine is selected. In another embodiment multiple forms of FTA see below are operative with the appropriate form of FTA activated based on the location of the file associated with the selected indicia.

Referring now to a flow diagram depicts another embodiment of the steps taken in a method for enabling transparent distributed program execution on a client machine through the selection of graphical indicia representative of a data file located on a remote machine . The client machine presents a graphical depiction of a data file stored on one of a plurality of remote machines Step . The client machine receives a selection of the graphical depiction of the data file Step and transmits the selection to one of the plurality of remote machines Step . The client machine receives a request from one of the plurality of remote machines to execute an executable program associated with the selected data file Step and executes the associated executable program Step .

Still referring to the client machine presents a user with a graphical depiction of at least one data file stored on at least one remote machine Step . In one embodiment indicia representative of files stored on one or more remote machines and on virtual machines executing on the one or more remote machines are intermingled with indicia representative of files stored on the client machine . In this embodiment server based FTA is operative when indicia representative of a file stored on a remote machine is selected. In another embodiment multiple forms of FTA see above below are operative with the appropriate form of FTA activated based on the location of the file associated with the selected graphical indicia.

As described above in connection with step a remote machine receiving a request to access a selected data file chooses a method for providing access to the data file. In one embodiment the data file resides on the remote machine . In another embodiment the data file resides on a remote machine such as a web server. In some embodiments the remote machine consults a mapping to identify an application program associated with the requested data file.

In some embodiments the remote machine chooses to provide the client machine with access to the file via execution of the associated application program in a computing environment provided by a virtual machine step . In one of these embodiments the remote machine may identify a remote machine to execute the application program and transmit application output data to the client machine . In another of these embodiments the remote machine identifies a remote machine to execute the application program in a computing environment provided by a virtual machine executing on the remote machine as described in connection with step .

In other embodiments the remote machine identifies a remote machine providing an application streaming service capable of transmitting the application program to the client machine for execution on the client machine as described in connection with step . In one of these embodiments the application streaming service transmits the application program to a remote machine for execution and the remote machine transmits application output data resulting from the execution to the client machine .

In some embodiments the remote machine selects one of a predetermined number of methods for executing a requested application program responsive to a policy the predetermined number of methods including a method for executing the requested application in a computing environment provided by a virtual machine. In one of these embodiments the application streaming service transmits the application program to a remote machine for executing in a computing environment provided by a virtual machine executing in the remote machine . In another of these embodiments the remote machine selects a method for streaming the requested application program to a virtual machine and executing the enumerated application in the virtual machine environment. In still another of these embodiments the virtual machine is evaluated and a determination to stream the requested application is made responsive to the evaluation. In other embodiments the determination to stream one of a plurality of files comprising an enumerated application program to a virtual machine is made responsive to credentials gathered from a client machine .

Having received data associated with the selected data file the client machine typically processes the received data using the executing program and displays the result of the processing to the end user.

As described above a client machine connects to one or more of the remote machines in the machine farm . In some of these embodiments the client machine may communicate with remote machines to receive application output data generated by an execution of an application program on a remote machine or on a virtual machine executing on the remote machine . In some embodiments protocol stacks are implemented to enable communications between the client machine and remote machines .

In one embodiment a remote machine is on line and monitoring activity on a specific transport system e.g. LAN or WAN and has initialized its protocol stack with the minimal necessary protocol modules to support a TTY communication mode. This mode is a raw ASCII stream mode with no protocol assumptions above the transport layer i.e. there are no protocol layers for compression encryption reliability framing or modem . Similarly a client machine seeking access to the remote machine establishes a connection to the common transport system with the minimum protocol set needed to support a TTY communication mode.

Upon detecting that a client machine has established transport system connection step the application server broadcasts a TTY data stream DETECT.sub. STRING in step that indicates service is available. The method used for detecting a client machine connection is transport system dependent e.g. in the case of the TCP transport when a client machine connects to a known port . If the client machine does not respond within a prescribed time period step a re broadcast of mission of the message occurs in step . Otherwise the process proceeds to step where the client machine sends the TTY string DETECT STRING . In step the client machine waits for the remote machine to respond and if the response is within a prescribed time interval the process proceeds to steps where the client machine enables the required protocol for supporting its application. Otherwise the client machine repeats the transmission of the message in step . The server responds in step by enabling the required set of protocols. At step the TTY mode of communication ends because the next message sent by the server is a presentation layer protocol packet PACKET.sub. INIT.sub. REQUEST which indicates that the client s required DETECT.sub. STRING has been received and accepted. In response to step the client at step sends a set of presentation layer protocol packets PACKET.sub. INIT.sub. RESPONSE each of which is used to specify a required or optional protocol module that is being negotiated with the server. At step the server sends a set of PACKET.sub. INIT.sub. CONNECT packets. The number of packets is variable one for each client packet sent in step thus giving the remote machine the opportunity to negotiate the parameters under which communications will take place by overriding the parameters of the client machine or the remote machine may indicate that all of the parameters of the client machine are acceptable by sending the parameters unchanged. At step the remote machine enables the negotiated protocols including any optional protocols of step . After the client machine receives the packets from step the client machine enables the negotiated protocols in step .

Still referring to in some embodiments a virtual machine host server communicates with the client machine to enable negotiated protocols. As described above a request is received from a client machine for access to a computing environment or for application execution the request including an identification of a user of the client machine . In some embodiments a virtual machine is launched in communication with a hypervisor. In other embodiments a virtual machine host server is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism wherein the common transport mechanism is for raw ASCII stream mode communications. In still other embodiments a virtual machine host server is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism.

A virtual machine host server creates a first portion of a protocol stack. In one embodiment a hypervisor creates the first portion of the protocol stack. In another embodiment the hypervisor transmits a request protocol message to the client machine . In still another embodiment the hypervisor receives from the client machine a plurality of protocol packets specifying one or more protocol parameters desired by the client machine . In yet another embodiment the virtual machine host server generates in response to each received protocol packet a packet counter specifying one or more protocol parameters.

The virtual machine host server transmits a request protocol message to the client machine . The virtual machine host server receives from the client machine a plurality of protocol packets specifying one or more protocol parameters desired by the client machine . The virtual machine host server transmits in response to each received protocol packet a packet counter specifying one or more protocol parameters. In one embodiment the virtual machine host server sends an acknowledgment message to the client machine indicating that at least one of the protocols specified by the client machine has been enabled. In another embodiment the virtual machine host server responds to each received protocol packet transmitted by the client machine with a virtual machine host server protocol packet at least one of the virtual machine host server protocol packets modifying at least one of the associated protocol parameters. The virtual machine host server creates on the virtual machine host server a second portion of a protocol stack the first portion and the second portion of the protocol stack establishing a communication channel for communicating with the client machine having the negotiated protocol parameters.

Still referring to in some embodiments a virtual machine communicates with the client machine to enable negotiated protocols as described above. As described above a request is received from a client machine for access to a computing environment or for application execution the request including an identification of a user of the client machine . A virtual machine in communication with a hypervisor is identified. In one embodiment a virtual machine is launched in communication with a hypervisor. In another embodiment a virtual machine in communication with a hypervisor is allocated. In one embodiment a second virtual machine is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism. In another embodiment the second virtual machine is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism wherein the common transport mechanism is for raw ASCII stream mode communications.

The second virtual machine creates a first portion of a protocol stack. The second virtual machine transmits a request protocol message to the client machine . The second virtual machine receives from the client machine a plurality of protocol packets specifying one or more protocol parameters desired by the client machine . The second virtual machine transmits in response to each received protocol packet a packet counter specifying one or more protocol parameters. In one embodiment the second virtual machine sends an acknowledgement message to the client machine indicating that at least one of the protocols specified by the client machine has been enabled. In another embodiment the second virtual machine responds to each received protocol packet transmitted by the client machine with a response protocol packet at least one of the response protocol packets modifying at least one of the associated protocol parameters. The first virtual machine creates a second portion of a protocol stack the first portion and the second portion of the protocol stack establishing a communication channel for communicating with the client machine having the negotiated protocol parameters. In one embodiment the first virtual machine sends an acknowledgment message to the client machine indicating that at least one of the protocols specified by the client machine has been enabled. In another embodiment the first virtual machine responds to each received protocol packet transmitted by the client machine with a response protocol packet at least one of the response protocol packets modifying at least one of the associated protocol parameters.

Still referring to in some embodiments a virtual machine host server communicates with the client machine to enable negotiated protocols as described above. As described above a request is received from a client machine for access to a computing environment or for application execution the request including an identification of a user of the client machine . In one embodiment a virtual machine is launched in communication with a hypervisor. In another embodiment a virtual machine in communication with a hypervisor is allocated. In one embodiment the virtual machine host server is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism. In another embodiment the virtual machine host server is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism wherein the common transport mechanism is for raw ASCII stream mode communications.

The virtual machine host server transmits a request protocol message to the client machine . The virtual machine host server receives from the client machine a plurality of protocol packets specifying one or more protocol parameters desired by the client machine . The virtual machine host server transmits in response to each received protocol packet a packet counter specifying one or more protocol parameters. In one embodiment the virtual machine host server sends an acknowledgement message to the client machine indicating that at least one of the protocols specified by the client machine has been enabled. In another embodiment the virtual machine host server responds to each received protocol packet transmitted by the client machine with a virtual machine host server protocol packet at least one of the virtual machine host server protocol packets modifying at least one of the associated protocol parameters. The virtual machine host server generates a data structure representing the connection and associated with an initial protocol stack. The virtual machine host server identifies a virtual machine in communication with a hypervisor and generates a client space in the identified virtual machine. The virtual machine host server generates a second protocol stack associated with the generated client space and transfers the established connection between the virtual machine host server and the client machine from the initial protocol stack to the second protocol stack by associating the data structure with the second protocol stack.

Still referring to in some embodiments a virtual machine communicates with the client machine to enable negotiated protocols as described above. As described above a request is received from a client machine for access to a computing environment or for application execution the request including an identification of a user of the client machine . A first virtual machine in communication with a hypervisor is identified. In one embodiment a second virtual machine is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism. In another embodiment a second virtual machine is initialized with a prescribed set of protocols and associated protocol parameters providing a common transport mechanism wherein the common transport mechanism is for raw ASCII stream mode communications.

The second virtual machine transmits a request protocol message to the client machine . The second virtual machine receives from the client machine a plurality of protocol packets specifying one or more protocol parameters desired by the client machine . The second virtual machine transmits in response to each received protocol packet a packet counter specifying one or more protocol parameters. In one embodiment the second virtual machine sends an acknowledgement message to the client machine indicating that at least one of the protocols specified by the client machine has been enabled. In another embodiment the second virtual machine responds to each received protocol packet transmitted by the client machine with a response protocol packet at least one of the response protocol packets modifying at least one of the associated protocol parameters. The second virtual machine generates a data structure representing the connection and associated with an initial protocol stack. The second virtual machine generates a client space in the identified first virtual machine. The second virtual machine generates a second protocol stack associated with the generated client space and transfers the established connection between the second virtual machine and the client machine from the initial protocol stack to the second protocol stack by associating the data structure with the second protocol stack.

Referring now to a block diagram depicts one embodiment of a client machine in communication with a remote machine . When a client machine wishes to access a resource provided by a remote machine the client machine may transmit a request to the general communications port previously defined by the communications protocol or to the well known communications port on the remote machine . In one embodiment the communication takes place by way of a datagram service. The remote machine accesses the table of server addresses and returns a message containing the address of the remote machine providing access to the requested resource and having the least load. In some embodiments an address of a virtual machine executing on a remote machine having the least load is provided. For embodiments in which the message identifies the execution machine having the lightest load the operating system or hypervisor may forward the communication request and all subsequent traffic to the appropriate virtual machine.

Subsequent communications are automatically addressed by the client machine also to a well known or predefined general communications port on the remote machine . In one embodiment the type of protocol with which the initial query was made to the remote machine determines the protocol of the information returned by the remote machine to the client machine . Thus if the request were made using a TCP IP datagram the remote machine would return the TCP IP address of the remote machine to the client machine and the client machine would subsequently establish contact with the remote machine using that protocol. In another embodiment the datagram requesting an application address by a client machine includes a request for a different type of protocol than the one used to send the request to the remote machine . For example the client machine may make a request to the remote machine using the IPX protocol and request the address of the remote machine as a TCP IP protocol address.

As described above in connection with steps a remote machine receives a request for access to a resource and chooses a method for providing access to the requested resource. In some embodiments the remote machine returns the network address of a remote machine having the desired resource to the client machine . The client machine then uses the information received from the remote machine to request connection to the specified remote machine . As is described above such a connection is first established to a well known communications port and is later transferred to a specific communications port under control of a connection manager. The specific communications port is associated with the resource executing on the remote machine which then communicates with the client machine through the specific communications port.

In more detail and referring to in some embodiments a client process on client machine makes a request to the remote machine to obtain the address of a remote machine which includes the desired resource . The remote machine returns to the client machine a message containing the address of the remote machine which includes the resource . In one embodiment the protocol used at this point of the connection is a datagram service.

The client machine uses the returned address to establish a communication channel with the remote machine . The port number used by the client machine corresponds to the well known port in the remote machine which has been defined by the network protocol as the port by which the remote machine establishes communication connections with client machines . The well known port has a rudimentary protocol stack which includes primarily an endpoint data structure .

The endpoint data structure points to the communication protocol stack and client connection thereby establishing a unique representation or handle for the client machine . The endpoint data structure permits the connection between the remote machine and the client machine to be moved at will between the connection manager and the various resources on the machine . In some embodiments the endpoint data structure permits the connection between the remote machine and the client machine to be moved at will to or from a virtual machine providing management functionality for a virtual machine on the remote machine .

The endpoint data structure in one embodiment not only contains the handle to the client machine but may also contain other information relating to the client connection. In the embodiment shown the machine monitors activity on a specific communications system e.g. LAN or WAN and has initialized this minimum protocol stack with only the necessary protocol modules needed to support a TTY communication mode. The TTY communication mode is a simple ASCII stream with no protocol assumptions above the transport layer. That is there are no protocol layers for compression encryption reliability framing or presentation of transmitted data. Thus a client machine seeking a resource running on the client machine establishes a connection to the well known communications port with the minimum protocol set needed to support a TTY communication mode.

A connection manager executing on the machine is listening to the well known communications port for a connection request . When a connection request is received from the client machine the connection manager is notified . The connection manager knows which protocol is being used based on the notification .

With this information the connection manager creates a new minimum protocol communications stack starts a computing environment referred to throughout this discussion as an execution environment and binds the new minimum protocol stack to the execution environment . In some embodiments the connection manager creates a new minimum protocol stack in a virtual machine on the remote machine . In other embodiments the connection manager creates a new minimum protocol stack in a virtual machine providing administrative or management functionality for a virtual machine executing on the remote machine . In still other embodiments the connection manager creates a plurality of minimum protocol stacks each of which may be located on the remote machine in a computing environment provided by a virtual machine executing on the remote machine or on a virtual machine providing administrative or management functionality for a virtual machine executing on the remote machine .

In one embodiment the remote machine includes a number of execution environments which have been previously been started but which have not been associated with a communications port. In this embodiment the pre connection starting of the execution environments permits a faster response time than if each execution environment is started when the connection request is received from the client machine . When the execution environment is started the resource requested by the client machine is also started. In another embodiment if the client machine does not specify a resource either a default application is started or the execution environment with no resource started. In some embodiments the execution environment is the requested resource.

The connection manager then moves the client connection including the unique client identifier or handle from the well known port to the new minimum protocol stack . In some embodiments the connection manager moves the client connection to the new minimum protocol stack in a virtual machine on the remote machine . In other embodiments the connection manager moves the client connection to the new minimum protocol stack in a virtual machine providing administrative or management functionality for a virtual machine executing on the remote machine . In still other embodiments the connection manager moves portions of the client connection to a plurality of minimum protocol stacks each of which may be located on the remote machine in a computing environment provided by a virtual machine executing on the remote machine or on a virtual machine providing administrative or management functionality for a virtual machine executing on the remote machine .

The connection manager using the minimum protocol stack sends a TTY data stream that indicates service is available. Thus this method for detecting a client connection is independent of the port to which the connection is first established. If the client machine does not respond within a prescribed time period e.g. 5 seconds to the service available message a resend of the service available message is performed by the machine .

If the client machine receives the message the client machine sends a TTY string indicating that the service available message was detected. The client machine waits for the machine to respond and if the response is not within a prescribed time interval e.g. 5 seconds the client machine resends the message. The connection manager then queries the client machine asking for the client s default communication parameters. This query takes the form of a message which is passed back to the client machine and which indicates that the client machine should respond with details regarding what protocols the client machine would like to use in the connection.

In response the client machine sends a set of protocol packets each packet of which is used to specify a required or optional protocol module that is being requested from the remote machine . In one embodiment the number of packets in the set is variable with one packet being sent for each protocol requested. In another embodiment the number of packets that is being sent is included in the header of the first packet. In a third embodiment the remaining number of packets being sent is included in the header of each packet and is decremented with each succeeding packet sent. Thus the client machine may respond to the query by indicating that for example encryption and data compression will be used. In such a case two protocol packets will be sent from the machine client to the remote machine and in one embodiment the header of the first packet will indicate the number of packets as two.

Once the responses to the query have been received the connection manager builds a protocol stack using protocol drivers which correspond to the protocols requested by the client machine . In one embodiment the connections manager places each of the required protocol drivers corresponding to the requested client protocols e.g. an encryption driver if encryption is desired by the client into the protocol stack container and links them together. In some embodiments the connections manager places protocol drivers into a plurality of protocol stack containers residing in different locations and links the plurality of protocol stack containers . This dynamic process allows a client machine to specify the contents of a protocol stack dynamically without requiring that the machine have a prior protocol stack description for a particular client machine . Using this method multiple client machines may be served by a single machine even if the separate client machines have vastly differing requirements for the associated communications channel. In the embodiment shown each client machine is associated with a respective communications protocol stack and . Such dynamically extensible protocol stacks are described in more detail below.

In the embodiment just discussed the container is a user level or kernel level device driver such as an NT device driver. This container driver provides ancillary support for the inner protocol modules or drivers generally which correspond to the protocol requirements of the client machine . This ancillary support is in the form of helper routines that for example aid one protocol driver to transfer data to the next driver. Alternatively in another embodiment each protocol driver is a complete user level or kernel level driver in itself.

Referring now to the viewing user uses a so called browser program to display an HTML page having a resource window on the screen of the user s client machine . Once the viewing user has indicated that execution of the resource should commence the browser application instantiates a parameter handler and passes the instantiation parameters associated with the resource window by the generic embedded window tag . The parameter handler instance spawns a network executive and passes to it the parameters of the resource window . The network executive determines which resource is to be invoked and on what machine that resource resides. Generally this information is passed to it by the parameter handler instance which gets it from the browser application in the form of the generic embedded window tag but the network executive may need to query another remote machine in order to determine which servers if any host the desired resource . The network executive then begins execution of the resource and displays the output of the resource in the resource window as described in detail above.

The network executive continues to directly display resource output in the resource output window until the viewing user indicates that execution of the resource should stop e.g. by closing the resource window or until the viewing user clicks on a tag indicating that a different HTML page should be displayed. When this occurs execution of the resource can be terminated. It is preferred however is to cache the connection. In effect the first parameter handler instance is not immediately terminated. However the resource continues executing with a reduced priority level i.e. in background mode because the first parameter handler no longer has focus .

In general it is desirable to accomplish connection caching by providing the parameter handler source code with a globally accessible data structure for registering instances. For example the parameter handler may be provided with a globally accessible linked list data structure data array data table or other data structure. Because the data structure is globally available each instance of the parameter handler is able to read and write the data structure. This allows each instance of the parameter handler to register with every other instance by writing to the data structure to signal its existence.

For embodiments in which no other connection information is stored a predetermined limit on the number of connections that may be cached at any one time can be set. In these embodiments if registration of an instance would result in an excess number of cached connections one of the cached connections is removed i.e. the parameter handler instantiation associated with that connection is notified that it should terminate. Before termination the parameter handler notifies its associated network executive that it should terminate. In turn the network executive closes its session with the server hosting the resource and then terminates.

In embodiments in which other information is stored the additional information may be used to more effectively manage the cached connections. For example if a user has not actively viewed an HTML page in a predetermined number of minutes e.g. ten minutes the parameter handler instantiation is instructed to terminate the session with the hosting server is terminated and the parameter handler instance removes its entry in the registry.

Cached connection information may be managed using any known cache management scheme. Connection entries may be discarded on a first in first out basis i.e. the oldest entry is discarded each time a new entry must be added. Alternatively cached connection information entries may be discarded on a least recently used basis which discards information relating to connections which have been used the least amount by the user. Other cache management techniques such as random replacement may also be used.

If the viewing user returns to a previous HTML page having a cached connection the network executive associated with the HTML page is returned to the foreground i.e. it regains focus and processing of the associated resource resumes at a normal priority level. If necessary the network executive re establishes the connection with the resource . Although no output data is stored by the network executive for cached connections as soon as a connection is re established for a resource window the connection to the resource is re established and the resource again writes directly to the resource window .

Referring to an HTML file located on a machine and constructed in accordance with an embodiment of the invention includes a generic embedded window tag . The generic embedded window tag is any data construct which indicates to a browser displaying the HTML file that a generic embedded window should be displayed at a particular location in the HTML page described by the HTML file . The generic embedded window tag may include additional information such as height of the window width of the window border style of the window background color or pattern in the window which resources may be displayed in the window how often the output display should be updated or any other additional information that is useful to enhance display of the resource output.

In each case above the tag indicates that a window having a height of 295 pixels and a width of 436 pixels should be drawn to receive resource output. Each tag also specifies that the resource should automatically start execution and that the window in which the resource output is displayed should be drawn with a border. The ActiveX and Netscape Plugin tags have the remote resource parameters specified in the file direct.ica located in the directory ica. The JAVA tag specifies the remote resource parameters directly. In the example above the address of the machine hosting the resource is specified as well as the name of the resource to be executed.

The browser application accesses the HTML file by issuing a request to a specific Uniform Resource Locator URL address. The machine hosting the HTML file transmits the HTML file data to the browser application which displays text and translates any tags that are included in the HTML file . The browser application displays the HTML file data as an HTML page . If a generic embedded window tag is present in the HTML file such as one of the tags described above the browser draws a blank window in the displayed HTML page .

Execution of the desired resource may commence immediately upon display of the HTML page or execution may await some signal e.g. a specified user input which indicates execution of the resource should begin. Once execution of the resource is commenced the browser application instantiates a parameter handler associated with the resource window . The parameter handler instance may be spawned as a child process of the browser application as a peer process of the browser application a statically linked thread of execution a dynamically link thread of execution or as a Dynamically Linked Library DLL associated with the browser application .

The browser application passes any specific parameters associated with the resource window that were provided by the generic embedded window tag to the parameter handler instance. Additionally the browser application may pass the handle for the resource window to the parameter handler instance or the parameter handler instance may query the browser application to retrieve the handle for the resource window . The parameter handler instance also spawns a network executive . The network executive may be spawned as a child process of the parameter handler instance a statically linked thread of execution a dynamically link thread of execution or as a peer process of the parameter handler instance.

The parameter handler instance forwards any specified resource window parameters to the network executive . Parameters which are not specified by the parameter handler instance or the embedded generic window tag may be set to default values. The network executive may have certain parameter defaults hard coded or the network executive may access a file which contains parameter defaults.

The network executive creates its own resource output window . The network executive creates its resource output window as a child of the displayed resource window and displays its resource output window directly over the parent window drawn by the browser application . Since the resource output window drawn by the network executive is a child of the resource window drawn by the browser application the resource output window inherits various properties of its parent including position information. Accordingly the resource output window will follow the resource window as the viewing user scrolls the screen of the browser application or performs other actions which vary the position of the resource window .

The network executive also establishes a communications channel with the machine and invokes execution of the desired resource by the machine using the connection methodology described above. The network executive which acts as the client machine in the above description passes any parameters it received from the parameter handler instantiation to the machine along with any necessary default values. If a parameter is not passed to the machine the machine may request the parameter if it is a necessary parameter which has no default value e.g. user id or it may provide a default value for the parameter e.g. execution priority. The machine begins execution of the desired resource and directs the output to the network executive . The network executive receives data from the resource and displays the output data in its resource output window . Since the resource output window is drawn on top of the resource window drawn by the browser application the resource output data is displayed in the HTML page . As noted above the resource output window drawn by the network executive is a child of the resource window drawn by the browser application . This allows the resource output window to scroll as the HTML page is scrolled

The resource output window also receives input from the viewing user. Raw input data e.g. a mouse click is received into the resource output window by the network executive . The network executive forwards the raw input data to the resource executing on the machine In this manner the viewing user is able to interact with the resource via the HTML page .

Referring now to and in brief overview an embodiment of an interactive hypermedium system of the invention includes a client machine a network remote machine and an execution remote machine interconnected by a communications link herein referred to without any loss of generality as a network or web. The network remote machine may be provided by a remote machine . The execution machine may be provided by a physical machine or a virtual machine.

A user on a client machine wishing to access the resource which is located on the execution machine on the web does so through a graphical user interface which is herein referred to without any loss of generality as a hypermedium located on the client machine . The graphical interface is displayed on a graphical display device . Data is entered by a mouse and a keyboard located on the client machine . The graphical display or page which the user first views on the hypermedium is referred to herein without any loss of generality as the home page or web page of the resource . A page or home page of the hypermedium includes a graphic link or textual link herein referred to without any loss of generality as a hyperlink. The web page is displayed by a process referred to herein without any loss of generality as a network browser executing on the client machine .

The network browser obtains the first page or web page from a network remote machine and displays the web page on the hypermedium for the user to view on the graphical display device . When the user selects a resource to access by selecting a graphical or textual hyperlink using the mouse or keyboard the network browser obtains a network configuration file corresponding to the selected resource from a predetermined network server and starts a client agent which will communicate with the selected resource . This will be discussed in more detail below.

The client agent reads the configuration file and establishes a communications link to a server agent on the execution server specified by the configuration file . In one embodiment the configuration file includes the name of the resource and the node location of the resource corresponding to the hyperlink . The configuration file may also contain optional information such as authentication or authorized user information. Server agent performs the operations necessary such as authentication to permit the client agent access to the resource and once access is permitted allows access to the resource requested by the user. The server agent may execute in a hypervisor a virtual machine or on an operating system. In some embodiments the functionality provided by the server agent is split between a hypervisor and a virtual machine or between two virtual machines. In still other embodiments the functionality provided by the server agent is split between a hypervisor and a guest operating system executing in a virtual machine. In some embodiments a connection to a computing environment including the resource is established as described in further detail below.

Once the resource is available on the execution server the client machine may access the resource through the server agent directly with the client agent without intervention by the network browser . The client agent is then responsible for receiving data from the user through the mouse and keyboard and transmitting it to the resource on the execution machine . Similarly the client agent is responsible for receiving data from the resource on the execution machine and displaying the data in a display window on the graphical display device on the client machine . It should be noted that the display window may be located within the boundaries or outside the boundaries of the hypermedium . When the resource is completed the server agent instructs the client agent to disconnect the communication link between the client agent and the server agent . In some embodiments the server agent may reside outside of the execution machine . In other embodiments the client agent may reside outside of the client machine .

When a user wishes to access a resource from a hypermedium environment for example a database program the hypermedium is displayed in a manner that is well known to those skilled in the art. When the user selects a hyperlink on the page of the hypermedium step by using the mouse or keyboard on the client machine a request is made to the network browser for the corresponding data file step . In this example the file type .RMT is requested.

The network browser obtains the corresponding configuration file from the network server which is specified in the file request made by the hyperlink to the network browser step . The network browser then compares the obtained configuration file with the registration file of client agent names which it maintains step . In one embodiment the network browser compares a file type of the obtained configuration file with the registration file . In another embodiment the network browser compares an entry in the obtained configuration file with the registration file . If the client agent specified by the configuration file is found in the registration file the client agent is started step .

The invoked client agent reads the configuration file step and based upon the information in the configuration file begins to establish a communication link with the server agent on the execution server step in this case the sales database application execution server generally .

Considering the process of beginning the communications link of step in more detail communication begins with the server agent monitoring communication activity on the network . At this point no protocol assumptions are made by the server agent beyond those necessary for the transport layer. Similarly the client agent also makes no assumption of the communications protocol beyond that required by the transport layer. Once the server agent determines that a client agent is attempting to communicate with it the server agent transmits a message to the client agent indicating that service is available.

Once the client agent determines that service is available on the execution remote machine the client agent transmits a message to the server agent indicating that it is ready to proceed with the communication protocol. Once the server agent has responded that it is ready to continue the communication protocol the client agent enables the protocol necessary for it to run the application . In response to the message from the client agent the server agent also enables the required protocol. The server agent then transmits a message using the required protocol indicating that the client agent s request has been received and accepted.

In response the client agent and the server agent exchange a set of messages which negotiate the parameters under which communications will occur. Once negotiations are complete the client agent and the server agent are able to communicate as necessary for the resource to be run by the user.

Once the communications protocol has been established and the server agent has authenticated the client agent step for example determining that the user has permission to read and write to the database access to the resource step is provided by the application execution server . At this point resource on the execution server is communicating via the server agent with the client agent on the client machine . The client agent is now responsible for transmitting data input by the user using the mouse and keyboard to the resource on the execution machine . Further the client agent is responsible for receiving data for display from the resource and displaying that data in the application window on the graphical display device of the client machine .

It should be noted that the underlying presentation protocol which passes data to a transport layer such as TCP IP must be capable of transferring graphical information. Examples of such protocols which may be used for interactive hypermedia communication include public domain X11 protocol the proprietary Independent Computing Architecture ICA protocol of Citrix Systems Inc. or the proprietary Remote Desktop Protocol RDP of Microsoft Corporation.

Thus the above described system permits a user on a client machine which may have very limited resources to start and interact with a resource located on an execution machine . The resource then runs on the execution machine and the data is input and the results displayed on the client machine . In some embodiments the accessed resource executes in a virtual machine provided by the remote machine .

Referring now to a flow diagram depicts an embodiment of method of making a hypermedium page interactive the hypermedium page displayed by a network browser. As described above a hyperlink on a hypermedium page displayed on a client machine is selected the hyperlink identifying a desired computing resource step . A hyperlink configuration file is retrieved the hyperlink configuration file corresponding to the hyperlink and identifying a remote machine step . A client agent is started on a client machine step . The client agent creates a communication link to a virtual machine executing on the remote machine identified by the hyperlink configuration file step . The client agent receives data from the virtual machine and displays on the client machine the received data without intervention by the network browser step .

A hyperlink on a hypermedium page displayed on a client machine is selected the hyperlink identifying a desired computing resource step . In one embodiment the hypermedium page is obtained from a remote machine prior to selection of the hyperlink on the hypermedium page. In another embodiment the hypermedium page is received responsive to a request for an enumeration of available resources.

A hyperlink configuration file is retrieved the hyperlink configuration file corresponding to the hyperlink and identifying a remote machine step . In one embodiment a remote machine functioning as a brokering machine identifies the remote machine . In another embodiment the remote machine functions as an execution machine. In still another embodiment a hypervisor executes on the remote machine . In yet another embodiment a virtual machine is launched into a hypervisor executing on the remote machine . In some embodiments a server agent starts on a virtual machine in the remote machine .

A client agent is started on the client machine step . In one embodiment the client agent is started by the network browser upon a successful match of an entry in the hyperlink configuration file with an identifier associated with the client agent in a registration file accessible by the network browser. In another embodiment the client agent is registered with the network browser.

The client agent creates a communication link to a virtual machine executing on the remote machine identified by the hyperlink configuration file step . In one embodiment execution of an identified application program begins on the virtual machine in response to the created communication link. In another embodiment the client agent creates the communication link without intervention by the network browser.

The client agent receives data from the virtual machine and displays on the client machine the received data without intervention by the network browser step . In one embodiment the data received from the virtual machine is displayed in a display window on the client machine . In some embodiments a presentation layer protocol is employed for communication over the communication link.

Referring back to in some embodiments of a system for making a hypermedium page interactive access to a requested computing environment is provided through the interactive hypermedium page. The client machine executes a browser application . A remote machine functions as a network server and transmits a network configuration file to the client machine . A client agent executing on the client machine establishes a communications link with a remote machine functioning as an execution machine .

As described above the client machine executes a browser application which displays a hypermedium page including a hyperlink identifying a resource . A remote machine functions as a network server and transmits in response to selection of said hyperlink a network configuration file to the client machine the network configuration file corresponding to said identified computing resource . In some embodiments a process obtains the hypermedium page from the network server and provides the hypermedium page to the client machine .

In one embodiment the network configuration file comprises a resource identifier corresponding to said hyperlink and a virtual machine address corresponding to said hyperlink. In some embodiments the virtual machine address is a virtual IP address provided by a hyperlink in which the virtual machine executes. In other embodiments the virtual machine address is an IP address associated with an execution machine on which the virtual machine executes.

A client agent executing on the client machine establishes a communications link with a remote machine functioning as an execution machine . The client agent establishes the link responsive to data in the network configuration file. In one embodiment a hypervisor executes on the execution machine and a virtual machine providing the resource executes in the hypervisor. In some embodiments the virtual machine transmits data to the client agent for display without intervention by the browser application . In one of these embodiments the virtual machine provides access to the requested resource and the data is output from an execution of the requested resource .

In some embodiments the client agent establishes responsive to data in the configuration file a communications link with a management program executing on a remote machine. In one of these embodiments the management program executes on the network server . In another of these embodiments the management program executes on the execution machine . In still another of these embodiments the management program executes on a virtual machine in the execution machine . In yet another of these embodiments the management program executes on a virtual machine having management privileges on the execution machine or on a remote machine . In other embodiments the management program launches the virtual machine providing the desired computing resource into a hyperlink on the execution machine .

In some embodiments the client agent displays data received from said virtual machine in a display window located at the client machine . In one of these embodiments the display window is located within the boundaries of the hypermedium page. In another of these embodiments the display window is located outside the boundaries of the hypermedium page.

Referring to in some embodiments of the methods described above data transmitted by the resource is sent to other remote machines prior to being sent to client machines . In this manner data transmitted by the resource is transmitted to an increasing number of client machines as the network fans out.

When each client machine terminates its connection with the machine each client protocol stack generally and its associated minimal stack generally is destroyed. Similarly the minimal protocol stack generally associated with the first client protocol stack is also destroyed. When the last of the minimal and second and subsequent client protocol stacks has terminated the configuration is as it was initially with only a first client communications protocol stack associated with the execution environment . Note that until all the second and subsequent client protocol stacks are terminated the first client protocol stack may not be destroyed even if the client machine is no longer present.

As shown in above each execution environment communicates with each protocol stack through a multiplexer . Now referring also to it is possible for more than one machine to receive data being transmitted to the client machine for example in order to shadow or monitor the transmission of data from a machine or to broadcast data from a specialized broadcast application such as a stock quotation application from which the same data is broadcast or transmitted substantially simultaneously to a number of clients generally 10 .

In such a case the client machine causes the specialized resource to execute and transmit its data to the client machine as discussed previously. When a client machine requests access to the broadcast resource the connection manager begins to construct the protocol stack for the second client machine as previously discussed with regard to the first client machine . However because the resource is a broadcast application the connection manager recognizes that it need not start an additional execution environment and instead takes the steps necessary to send the data from the broadcast resource to the client machine and any additional machine .

First the connection manager creates a first minimal communications protocol stack which it associates with a communications protocol stack of the first client machine . The connection manager next creates a second minimal protocol stack and associates it with the communications protocol stack of the second client machine . As each additional client machine requests access to the broadcast resource another minimal protocol stack is created and associated with the first client protocol stack and another minimal protocol stack and client protocol stack is created for each new client machine . The first client protocol stack and all the minimal protocol stacks associated with the first client protocol stack and each pair of client protocol stacks and minimal protocol stacks associated with each additional machine are in communication by way of a multiplexer .

In some embodiments the connection manager resides outside of a virtual machine executing on a remote machine and creates minimal protocol stacks within the virtual machine executing on the remote machine . In other embodiments the connection manager resides outside of a virtual machine executing on a remote machine and creates minimal protocol stacks within a second virtual machine providing management and administrative functionality for the virtual machine executing on the remote machine . In still other embodiments the connection manager resides outside of a virtual machine executing on a remote machine and creates minimal protocol stacks within a hypervisor providing management and administrative functionality for the virtual machine executing on the remote machine . In yet other embodiments the connection manager resides outside of a virtual machine executing on a remote machine and creates minimal protocol stacks within a host operating system on the remote machine providing management and administrative functionality for the virtual machine executing on the remote machine . In some embodiments the connection manager resides inside a virtual machine executing on a remote machine and creates minimal protocol stacks within the virtual machine executing on the remote machine .

When a multiplexer is directing data to or receiving data from only one machine the multiplexer is acting as a simple pass through device. However when there is more than one client machine receiving data from or transmitting data to a single resource each multiplexer generally takes on two additional configurations. In one configuration the multiplexer is configured to send resource data to or receive data from both the first client protocol stack and each of the minimal communications protocol stacks associated with it. In the second configuration the multiplexer is configured to send data received by the minimal protocol stack to the client protocol stack respectively associated with it. In this embodiment the multiplexer may receive input data directly from each client protocol stack .

The connection manager connects the minimal protocol stacks associated with the client machine with the minimal protocol stacks respectively of the second client machine and subsequent client machines and instructs the multiplexer to direct output from the resource to the communications protocol stack of the client machine and its associated minimal protocol stacks . The multiplexer is also instructed by the connection manager to connect each second and subsequent client minimal protocol stack to its associated client protocol stack respectively. Data transmitted to the client machine by way of the first client protocol stack is therefore also transmitted to the minimal protocol stacks associated with the client machine and hence to the client machine and subsequent client machines by way of their associated protocol stacks respectively and associated minimal protocol stacks respectively. In one embodiment the protocol stack container includes a data structure to keep track of the number and type of protocols associated with a given resource .

Referring to as discussed above it is possible that the clients of one machine be other remote machines and only two being shown for simplicity . The remote machines and then transmit the data to client machines or to additional remote machines . In this embodiment the output of the server protocol stack generally is connected to the protocol stacks of the secondary remote machines and . Then as described previously the data is transmitted between the protocol stacks and out to the client machines . In this manner the data may fan out and be distributed to many more clients than may reasonably be supported by one server. In some embodiments the output of the server protocol stack may be connected to protocol stacks created in virtual machines executing on remote machines .

In brief overview in one embodiment of the methods described above a user of a client machine requests access to one or more resources from a remote machine which may provide web server functionality. After authenticating the user s credentials the web server accesses user specific and resource specific parameters from a memory coupled to the web server. The web server subsequently communicates these parameters to one or more remote machines hosting the requested resources and software processes operating on the resource servers execute and initialize the requested resources using the communicated parameters. In this manner each instance of the resources is personalized for a particular requesting user. The particular network addresses of the resource servers hosting these personalized application programs are then forwarded to the user s client machine which establishes a communications link and client server session therewith.

Commands events graphical data and window attribute information associated with the executing resources are communicated between the user device and the resource servers during the client server session to ensure that the resource output data is displayed seamlessly on the desktop of the user device. Seamless display of the resource output data refers to the presentation of the data on the user desktop in a manner that is consistent with how locally executing resources are presented and manipulated in the local desktop of the user device. A user may therefore view and interact with the resource output data generated by the remote resources as if the resources were being executed locally.

In one embodiment the output of the resources is displayed in one or more resource output windows positioned within a web page displayed by a web browser of the user s device. The resource may be executing on a remote machine or on a virtual machine executing on the remote machine . In a further embodiment the attributes of the resource output windows can be modified so that the resource output windows are moveable and resizeable within the boundaries of the web page. In another embodiment the resource output windows initially appear within the boundaries of the web page and are subsequently moveable so that they are positioned outside the boundaries of the web page and thus give the appearance that the application output windows correspond to locally executing applications rather than to remotely executing applications. In yet another embodiment the application output windows initially appear outside the boundaries of the web page and thus also appear to correspond to locally executing applications. In one embodiment the application output displayed in the application output windows and the attributes of the application output windows themselves are communicated and manipulated by software processes on the user s device and on the resource servers without involvement of the web server or web browser that initially provided access to the resources.

In more detail and with reference to a server based computing architecture capable of providing remote users with web access to the full functionality of web and legacy applications e.g. unmodified application programs that are not designed for web based delivery includes a client machine e.g. any digital data processing device a web server one or more remote machines that are either standalone or clustered within a machine farm and which are preferably protected by a firewall and a data communications network e.g. Internet Intranet etc. that provides the necessary connectivity to enable each of these elements to communicate with each other.

In other embodiments the web server is a remote machine . In some of these embodiments virtual machines may be executing on one or more of the remote machines the virtual machines providing computing environments in which a requested resource resides and generates resource output data.

In operation and also with reference to a user of the client machine directs a browser executing on the client machine to submit a request for access to particular web page content accessible via the web server . In one embodiment the user enters a universal resource locator URL address into the browser . The URL is associated with the web page content hosted by the web server and the browser responds by transmitting the request for access to the appropriate URL address. The web server receives the request for access which typically includes user credential information e.g. user ID password group project membership identifier etc. and authenticates the user to the machine farm or to the individual servers that provide at least some of the web page content .

The web server authenticates the user by accessing an authentication process that compares the credentials entered by the user with previously assigned credentials. In one embodiment the authentication process and database of previously assigned credentials are stored and maintained on the web server . In other embodiments the previously assigned credentials can be stored in the machine farm on individual application remote machines and or on an administrative server not shown that is coupled to the web server via the Internet or other data communication network.

In the scenario where the web page content corresponds to an enterprise portal which provides access to a resource set e.g. the set of resources that have been personalized for the user by a portal administrator the web server accesses one or more resource objects e.g. COM compliant Java objects ActiveX objects HTML tags etc. that call web server side scripts to authenticate the user and or to obtain the resource set information associated with the portal and user from the machine farm . The resource objects also include properties that are associated with the user and or the particular resources in the resource set that are provided via the portal. The user properties include for example group project information that identifies the particular resources and data that the user needs to access in order to allow the user to collaborate with other members of the group project. The resource properties include for example the user s preferences for each of the resources in the resource set .

The scripts called by the resource objects establish a network session between the web server and the machine farm via for example a central administrative process not shown which monitors and controls each resource machine in the machine farm . The administrative process selects one or more resource servers which host the resources in the resource set specified by the resource objects based for example on a server and or network performance basis. The desired resource set can be provided entirely by a single server by selecting allocating each resource in the resource set from a plurality of resources hosted on the server . Alternatively the resource set can be provided by a plurality of remote machines with each machine hosting at least one of the resources in the resource set .

The administrative process launches one or more server agents on the selected allocated remote machines in response to the scripts called by the resource objects . Server agents are software processes that execute initialize and interact with each of the resources in the resource set in accordance with the properties specified by the resource objects . In one embodiment there is a server agent for each resource in the resource set . In other embodiments there is a single server agent for the resource set to the extent that all of the resources are hosted on the same server . In yet another embodiment there is a single server agent for each server . The server agents then provide the output of the resources in the resource set as well as any other information relating to the resource set to the web server which subsequently formats the resource set information into the web page content . The web page content can include application icons corresponding to one or more of the resources in the resource set as well as resource output data from one or more of the resources . In one embodiment the resource output data provided by the resources corresponds to graphical data that is formatted to fit into a window which exhibits attributes e.g. window position on the web page size style z order etc. as initially specified by the properties of the resource objects .

In one embodiment and with reference to the browser receives and displays the web page content within a browser window which includes many possible graphical user interface GUI elements e.g. menu local window etc. that form the client desktop displayed on a display device coupled to the client machine . In this embodiment the web page content is displayed within a web page displayed in the browser window and includes one or more resource icons and or one or more resource output windows which are associated with the resource set . In one embodiment one or more of the resource objects also form part of the web page content of the web page and can therefore set the initial attributes size z order position of the resource output windows . The initial orientation size position and z order of each of the resource output windows displayed on the web page can be modified as described below so that the resource output windows exhibit different orientations sizes positions and z orders relative to the web page and or relative to the client desktop .

The resource objects can be any data constructs which indicate to the browser displaying the web page content that a resource output window should be displayed at a particular location in the web page . The resource objects may include additional information such as the height width border style background color or pattern in the resource output window along with indicia of which resources may be displayed in the window how often the output display should be updated or any other additional information that is useful to enhance the display of the resource output.

In one embodiment the resource objects are window tags that are embedded in an HTML file examples of such tags are delineated below.

In each case above the tag indicates that a resource output window having a height of 295 pixels and a width of 436 pixels should be drawn to receive output data from the resource . Each tag also specifies that the resource should automatically start execution and that the resource output window in which the resource output is displayed should be drawn with a border. The ActiveX and Netscape Plugin tags have the properties of the remote resource specified in the file direct.ica located in the directory ica. The JAVA tag specifies the properties of the remote resource directly. In the example above the address of the server hosting the resource is specified as well as the name of the resource to be executed.

In one embodiment the resource executes substantially at the same time as the display of the web page . In another embodiment the resource executes when instructed to do so by the server as part of providing web page content to the web server . In yet another embodiment the resource executes in response to a signal such as a user specified input e.g. selecting a resource icon on the web page . Once execution of the resource is commenced the browser instantiates a client agent on the client machine . Alternatively the client agent is instantiated substantially at the same time as the display of the web page or in response to user specified inputs.

The client agent comprises one or more software processes which execute on the client machine and which are configured to interact with the server agent browser resource output window and or web server . In one embodiment the client agent is spawned as a child process of the browser . In other embodiments the client agent is a peer process of the browser or a dynamically linked library associated with the browser . In one embodiment a client agent is instantiated for each resource output window displayed in the web page . In another embodiment a single client agent is instantiated for one or more resource output windows associated with a particular one of the resources in the resource set . In yet another embodiment a single client agent is instantiated for each server agent which contributed to the web page content . In yet another embodiment a single client agent is instantiated for the entire resource set .

The browser passes the properties of the resource objects relating to particular resources in the resource set to the client agent associated with those same resources . Additionally the browser may pass a handle for a resource output window to the client agent or the client agent may query the browser to retrieve the handle for the resource output window . Resource properties which are not specified by either the browser or the resource objects may be set to default values. The client agent may also have certain property defaults hard coded or the client agent may access a file which contains property defaults.

The client agent uses the name of the resource and the address of the resource server which are both provided as part of the properties of the resource objects to establish a communications link and initiate a client server session with the server agent associated with the resource server and resource . The client agent passes some or all of the properties of the resource objects to the server agent along with any necessary default values. Alternatively the server agent may have already received some or all of the properties of the resource objects from the web server prior to contributing to the web page content which was subsequently displayed in the web page . If a particular property is not passed to the server agent the server agent may request it from the client agent if it is a necessary property to which it has no default value e.g. user ID or the server agent may provide its own default value for the property e.g. execution priority .

The server agent uses the properties received from the client agent to authenticate the client agent and to execute the desired resource if it has not previously been started. Once the resource is executing and the client agent has been authenticated the resource communicates through the server agent directly with the client agent without intervention of the browser or web server . The client agent receives output data from the resource and displays the output data in the appropriate resource output window in the web page . The client agent also detects input events such as mouse clicks and keyboard inputs associated with the resource output window and forwards any such input events to the resource via the server agent . This type of client server session is repeated for each resource in the application set that is selected by the user and thus enables the user to interact with all of the resources in the resource set .

The data exchanged between the client agent and server agent during the client server session includes not only input events and the graphical output data of the resource but also window attribute information e.g. window position z order size style color etc. . The window attribute information of the resource output windows is initially specified by the resource objects embedded in the web page . For example the resource objects can include an ActiveX control which specifies and controls the window attributes of the resource output windows during the client server session. In one embodiment the resource output windows exhibit the same dimensions as the corresponding ActiveX controls.

The client agent communicates the initial window attributes of the local application output windows to the server agent along with information relating to the client desktop e.g. size resolution etc. . The server agent responds by conforming the size of its server desktop to that of the client desktop and by conforming the window attributes of local server windows to those of the resource output windows on the client desktop . The resource output windows on the client desktop and the server windows on the server desktop thus exhibit the same window attributes and display the same graphical output data that is generated by the resource . Note that the server desktop can correspond to either an offscreen surface contained within the server s video memory or to an onscreen surface displayed on a display device coupled to the server .

The user of the client machine can move resize and or alter the z order or other initial window attributes of the resource output windows during the client server session by entering an input event that is detected by the client agent and then communicated to the server agent . The server agent conforms its desktop and or windows to be consistent with the input event and then transmits updated graphical output data and window attribute information corresponding to the input event to the client agent with instructions to update the resource output windows so that they match the windows on the server .

For example if the user of the client machine resizes one of the resource output windows from that originally specified by the resource objects such as by clicking with the mouse and dragging the border of the application output window to the desired location size the client agent detects the input event generated by the mouse action and communicates it to the server agent which effects the same resize event in the on or offscreen surfaces of the server . The server agent then sends repaint and resizes command messages to the client agent along with updated graphical output data and window attribute information. In response the client agent modifies the appropriate resource object affected by the resize event e.g. the ActiveX control discussed above so that the corresponding resource output window is resized and the updated graphical output data is painted within the borders of the output window .

These embodiments thus enable the window attributes of the resource output window to be modified so that the resource output window can be moved resized etc. within the boundaries of the browser window . With reference to and by way of nonlimiting example resource output window B can be resized using the methodology described above to form resource output window B which overlaps thus exhibiting a different z order from resource output window F . Alternatively the resource output window can be moved or resized to extend beyond or be entirely outside of the browser window . By way of nonlimiting example and with reference to resource output window J lies within the boundaries of the browser window while resource output window K extends beyond the boundaries of the browser window and resource output window L is entirely outside the browser window . Note that the resource output windows can exhibit varying z orders with respect to other elements in the client desktop . For example local window exhibits a z order between that of the browser window and resource output window L . In this embodiment the client agent instructs the operating system of the client machine to draw the desired resource output window in response to command messages received from the server agent without having to first modify the properties of the resource objects embedded in the web page which initially established the window attributes of the resource output window .

In one embodiment each input event affecting the resource output window is transferred to and processed by the server agent which then instructs the client agent to effect corresponding changes in the resource output window . In another embodiment one or more input event types e.g. click and drag mouse actions directed at moving the resource output window to another grid location on the web page are processed entirely by the client agent and not reported to the server agent where the graphical output data displayed within the resource output window remains unchanged.

In more detail and with reference to the client agent comprises a monitor process a command process a message receiving process and a message transmission process . In one embodiment each process is a separately functioning code segment that operates independently of the other processes. For example the message receiving process and the command process can be implemented as separate threads which communicate with each other via a named pipe or shared memory. Use of a common data set allows the message receiving process and the message transmission process to be synchronized.

The message receiving process receives graphical data window attribute information and commands from the server agent via the communications link that provides the connectivity between the client agent and server agent during the client server session. The communications link preferably includes a first virtual channel and a second virtual channel . Command event and window attribute information is passed between the client agent and the server agent via the first virtual channel while graphical data corresponding to the graphical contents of the resource output windows is passed via the second virtual channel . The message receiving process informs the command process of the commands window attributes and graphical data received from the server agent and the command process further processes this data.

In one embodiment the command process processes the commands received from the server agent by instructing the client operating system to form and or modify affected resource output windows in accordance with the window attributes specified by the server agent . The command process also instructs the client operating system to display the graphical data provided by the server agent in the appropriate resource output windows . In one embodiment the command process implements changes to the resource output windows in the client desktop by issuing GDI commands. In other embodiments the command process issues commands directly to an associated graphics subsystem or via graphics API commands.

The command process also instructs the monitor process to periodically monitor the client desktop in order to detect changes affecting the resource output windows . In one embodiment the monitor process instructs the client operating system to return information relating to the client desktop at predetermined polling intervals. In other embodiments the monitor process monitors the message queue maintained by the client operating system in order to detect changes affecting the resource output windows. The monitor process communicates some or all of the detected desktop changes to the command process for further processing.

In one embodiment the command process instructs the message transmission process to transmit all of the changes detected by the monitor process to the server agent via the first virtual channel. In another embodiment the command process instructs the message transmission process to transmit a subset of the detected changes such as changes which only affect the graphical data and or window attributes of the resource output windows . The server agent receives the detected changes along with any commands from the command process and any input events made by the user of the client machine that triggered the detected changes. The server agent then modifies its local desktop to accommodate the detected changes and transmits associated commands window attributes and graphical data back to the client s message receiving process . In this manner desktop elements such as the resource output windows that are common in the client and server desktops remain in lock step.

The command process of the client agent ensures that analogous common elements in the client and server desktops remain in lock step by maintaining a common window list. The common window list includes the window attribute information for each window in the client desktop and for each corresponding window in the resource server desktop. In embodiments in which a plurality of client agents is executing on the client machine the command process of a single client agent has primary responsibility for maintaining the common window list. If the single client agent terminates while other client agents remain in operation the remaining client agents will elect another primary client agent to maintain the common window list.

Each remote machine also includes at least one agent . In some embodiments each remote machine includes one agent for each client machine connected to the remote machine . Client machine may also host an agent . In some embodiments a client machine hosts a separate local agent for each remote machine to which the client machine is connected. In other embodiments the client machine hosts a single agent that manages connections to multiple remote machines . Each of the agents may monitor their associated desktop environment for windows which change position are opened are closed change size are minimized are maximized or are brought to the top of the desktop i.e. windows which gain focus that do not previously have focus. Each agent transmits messages indicative of changes in their associated desktop to other agents. For example local agent may receive messages transmitted from server node agents . The local agent commands the client machine to modify the local desktop environment in response to the messages received from server agents that is the local agent issues commands to the client machine to conform the local desktop environment to the desktop environment In other embodiments agents for remote machine receive messages from a local agent and command the machine to modify the desktop environment in response to messages received from the local agent .

In one embodiment the agents monitor changes to their associated desktop environment by periodically issuing one or more of a set of commands provided by the operating system that allow details of the graphical user interface desktop to be determined. For embodiments in which the agents reside on nodes that execute a version of the WINDOWS operating system the agents may periodically issue the Enum Windows command to the WINDOWS operating system which returns a list of all windows present on the desktop together with information related to those windows. The agents can issue the Enum Windows command every 50 milliseconds every 100 milliseconds every 500 milliseconds or at any period that allows the agent to rapidly determine when changes to its associated desktop environment have occurred without putting a significant computational burden on the node. In this embodiment the agent maintains a data structure storing information about the desktop windows and compares the values returned by the Enum Windows command to the data structure to determine changes.

Information determined and stored by the agent can include the title bar associated with each window the location of each window in the desktop environment the size of each window and the z order positioning of each window in the desktop environment . In another embodiment the agent monitors an intranode graphics message queue to determine changes to its associated desktop environment. Server agents monitor an intraserver message queue and local agent monitors an intraclient message queue. In this embodiment changes to the desktop environment are affected via messages sent to a graphics subsystem from system applications or the operating system itself. Thus a resource executing on a remote machine would send a message to a graphics engine residing on the server in order to change the server desktop environment . Other commands which return graphical user interface data are readily apparent to those of ordinary skill in the art. For embodiments in which the agents reside on nodes executing a version of the WINDOWS operating system the agents monitor the Windows Message Queue for messages affecting the desktop environment associated with the node on which the agent resides. Examples of such messages include WM SETFOCUS which indicates to which window focus will be given i.e. brought to the top of the desktop WM KILLFOCUS which removes focus from an indicated window and WM WINDOWPOSCHANGING which indicates a change in the position of a window. Other messages that can be posted to the Windows Message Queue are readily known to those of ordinary skill in the art.

Referring now to the steps taken during a server initiated event are shown. The agent for remote machine senses a change in its associated desktop step . The agent may do this by intercepting a window event on the server message queue or the agent may determine a change in the desktop by comparing the results returned from serially issued operating system commands as described above. The agent sends a message to a client agent indicating the change in the server desktop step . For example if a new window has been given focus the agent can transmit a message to a client agent indicating the identity of the new top window. In one embodiment the agent broadcasts its message to all client agents that exist in the system. Alternatively the agent may transmit its message only to a predetermined subset of client agents . For example when a client machine makes a connection to a remote machine the client agent may register with the agent . In this embodiment the agent would transmit change messages only to those client agents that have registered with the remote machine .

The client agent receives the transmitted message step . In embodiments in which the remote machine broadcasts commands the client agent must have some mechanism for determining whether a transmitted command affects its associated desktop. For example the client agent may maintain a list of remote machines to which it is connected. In these embodiments the client agent responds to messages broadcast by any remote machine present in its list. For embodiments in which the agent does not broadcast messages no such mechanism is necessary.

The client agent implements a change to its associated desktop responsively to the received message step . The client agent may accomplish this by directly issuing graphics Application Programming Interface commands that cause the client machine to change the display of its associated desktop. Alternatively the client agent may issue GDI commands to change its associated desktop. In still other embodiments the client agent issues commands directly to the system whether implemented in hardware or software responsible for displaying graphics on the client machine .

Referring now to the steps taken when a client machine initiates a desktop change are shown. The client agent senses a change in its associated desktop step . As noted above this may be done on an event driven basis or by polling the operating system operating on the client machine . The client agent determines to which remote machine the affected window belongs step . To facilitate this process the client agent may maintain a list that associates remote windows with a particular remote machine . The client agent then sends a message to the identified remote machine indicating the change in its desktop step . Alternatively the client agent may skip step entirely and broadcast its change message to all remote machines . The server agent receives the transmitted message step and implements the change in its associated desktop step as described above.

In one particular embodiment a client machine and a remote machine communicate using the ICA protocol and the client machine and the remote machine execute a version of the WINDOWS operating system. Client machine hosts a local agent that may be provided as a dynamically linked library module. The remote machine hosts an agent that may be provided as a separate thread.

In this embodiment the local agent and the agent exchange graphical data i.e. the data actually displayed in each window on the desktop via a first ICA virtual channel. Information about window positioning window size z access ordering of window and other such information is communicated between the client machine and the remote machine via a second ICA virtual channel. Throughout the description when the client machine and the remote machine are actively exchanging information via the second ICA virtual channel the client machine will be referred to as being in seamless windowing mode. 

Referring now to the process for enabling seamless windowing mode between the local agent and agent is shown. In this embodiment all communication between a server agent and a client agent is packet oriented and takes place over a dedicated ICA virtual channel making the functioning of the agents independent from the underlying communication protocol. All packets start with packet type 1 byte followed by packet data length 2 bytes can be zero and data optional . Agents will try to send as much data in a single network packet as possible but it will always send complete packets. That is the size of seamless window virtual packets never exceeds the allowable size of an ICA packet. Packet flow control and delivery confirmation is implemented by the transport level of the ICA protocol. Individual packets are executed immediately on reception.

The client agent waits for an initial packet from the server agent . After user logon to the server a server agent will be invoked step .

The server agent sends a TWI PACKET START packet to the client agent which includes some essential information about the remote machine desktop environment desktop resolution desktop size version number of ICA protocol supported by the server etc. step . This packet is sent by the server agent on initial connection or on reconnect and is used to 1 detect seamless windowing capabilities of the client machine and 2 requests basic machine information.

The client agent receives the TWI PACKET START packet step and responds with a TWI PACKET C2H START ACK packet confirming TWI PACKET START and supplying machine version capabilities information step . This packet is sent by the client agent to confirm reception of TWI PACKET START packet and to send the requested basic machine information to the server agent .

If there is no response from the client agent step the server agent assumes that the client machine is unable to enter seamless windowing mode and the seamless windowing virtual channel is not used by the remote machine to communicate window information. In this case the remote machine continues to communicate graphical data to the client machine via another virtual channel and the client machine desktop displays the server desktop without incorporating windows from other nodes.

The client agent uses the information sent by the server agent in step to determine if a seamless windowing session can be established between the server agent and the client agent . In one embodiment the client agent compares information relating to the version of the virtual channel protocol supported by the server agent to makes the determination If the client agent determines that it is possible to enable seamless windowing mode step the client agent sends a TWI PACKET C2H OPEN packet to the server agent step . This packet requests that the server agent enable seamless windowing mode.

On reception of a TWI PACKET C2H OPEN packet step the server agent I resets its internal data structures ii sends a TWI PACKET SYSINFO packet to the client agent to communicate some general information regarding the window settings on the remote machine to the client agent iii sends a TWI PACKET OPEN packet to the client agent step indicating the establishment of seamless windowing mode and iv enables its main polling loop step that will poll the operating system on the server node for desktop changes. If the client agent and the server agent do not support the same version of the seamless window protocol the server agent ignores the TWI PACKET C2H OPEN packet.

On reception of TWI PACKET OPEN packet step the client agent resets its internal data structures step and seamless windowing mode between the client agent and the server agent is established.

During a seamless windowing mode session the server agent will send window information such as window position size styles window text etc. for all top level windows on the server node. Also foreground window information is sent i.e. which window on the server node desktop is the foreground window. In accordance with this information the client agent creates windows with the same size position as the server node windows on the machine desktop. In some embodiments window elements are transmitted as bitmaps from the server node . Examples of packets sent by the server agent include TWI PACKET CLOSE which is sent to switch the client agent out of seamless windowing mode and back to regular or full screen mode that is the client machine is switched back to displaying the server node desktop environment without incorporating windows from other desktop environments TWI PACKET CREATEW which is sent to create new windows on the client machine TWI PACKET DELETEW which is sent to destroy a window on the client machine TWI PACKET CHANGEW which is sent to change a window displayed by the local node TWI PACKET SYSINFO which is sent to report remote machine system settings normally it is sent only once but the packet can be sent multiple times TWI PACKET FOREGROUNDW which is sent during normal seamless windowing mode operation to change the foreground window TWI PACKET SETTOPW which is sent during normal seamless windowing mode operation to change the top window that is to bring a new window to top TWI PACKET SETFOCUS which is sent during normal seamless windowing mode operation to change the focus window TWI PACKET FOCUSACK which is sent in response to TWI PACKET C2H SETFOCUS see below and reports the result of a SetFocus attempt and TWI PACKET SPA STATUS which is sent in response to TWI PACKET C2H START PUBLICAPP see below and is used to report the result of the requested operation.

Examples of packets that can be sent by the client agent to the server agent include TWI PACKET C2H PAUSE which is sent to suspend the server agent that is the server agent will stop sending window information clear its internal data structure and send a TWI PACKET CLOSE packet see above TWI PACKET C2H RESUME which is sent to resume the server agent the server agent will clear its internal data structure and send a TWI PACKET OPEN packet see above TWI PACKET C2H SETPOS which is sent to report window size position change on the machine TWI PACKET C2H SETFOCUS which is sent to report a change in the focus window on the machine TWI PACKET C2H RESTORE which is sent to request restoration of a minimized window TWI PACKET C2H TERMINATE which is sent to request termination of a program executing on the remote machine TWI PACKET C2H STARTAPP which is sent to start a new resource on the remote machine TWI PACKET C2H LOGOUT which is sent to end the current session TWI PACKET C2H START PUBLICAPP which is sent to start a new published resource on the remote machine and TWI PACKET C2H CLIENTINFO which is sent to report client desktop settings to the server agent this packet is generally sent on startup but can also be used during seamless windowing session.

The client agent will try to perform some operations such as window move and resize locally sending update information back to the remote machine afterwards. Proper window behavior is emulated by intercepting the WM NCHITTEST message for the client created windows.

Foreground window changes can happen on both the client machine and the remote machine so the client machine and remote machine will negotiate and balance actual foreground window changes. For example if the remote machine changes its foreground window that change should be properly represented on the client machine desktop. The server agent sends information regarding the new foreground window to the client agent using the TWI PACKET FOREGROUNDW packet. Similarly if the client agent detects a foreground window change on the client machine desktop the client agent sends information regarding the change to the server agent and the server agent implements the change on the remote machine desktop.

When focus is taken away from a window representing a server window and is given to a local machine window the client machine notifies the remote machine of the change and the remote machine gives focus to an invisible window. For embodiments in which the client machine is connected to two server nodes and focus is shifted from a window representing a window from the first remote machine and is given to a window representing a window from the second remote machine the client machine sends a packet informing the current remote machine or that its window no longer has focus. Once the remote machine or responds by giving focus to an invisible window the client agent instructs the other remote machine that its window now has focus on the client machine desktop.

In some embodiments it is desirable to add some complexity to the agent s main polling loop to reduce network traffic. In these embodiments the main polling loop includes a comparison between the current foreground window and the identity of the window last requested to be moved to the foreground. If the current foreground window matches the window identified in the most recent request the agent does not need to send information acknowledging the change. This technique is useful in both server agent and client agents .

Window z ordering on the client machine is a superset of the server node z ordering machine will always have more windows than the host . Server node Bordering is reproduced on the client machine by reproducing owner owned relationship among windows and the TOP MOST flag in the window style. Owner owned relationships refer to windows which are children of other windows such as dialog boxes associated with resource windows. The dialog box is said to be owned by the resource window and the dialog box will always appear on top of its owner. The TOP MOST flag indicates that a particular window should appear on top of the desktop for example the status bar in WINDOWS 95.

When a user disconnects the server agent switches itself to suspended mode and will not send information to the client agent . On a reconnect the server agent sends a TWI PACKET START packet reporting HostAgentState as already running reconnect. 

Based on the version number of the protocol supported by the server the client machine will decide whether it is possible to enable seamless windowing mode from the client machine point of view . If it is possible to switch to seamless windowing mode the client agent will send a TWI PACKET C2H OPEN packet asking the server agent to enable seamless windowing mode.

Each agent responsible for monitoring an associated desktop may be implemented as a stand alone software routine such as an executable file on DOS based systems a dynamically linked library routine DLL or as an integral piece of the operating system. Referring now to and in brief overview each agent includes a message receiving facility a command facility a monitor facility and a message transmission facility . Agent agent communication is full duplex i.e. agents can transmit and receive messages simultaneously. Thus each facility can be implemented as a separately functioning code segment that operates independently of the other facilities. For example message receiving facility and command facility can be implemented as separate threads which communicate with each other via a named pipe or shared memory. Use of a common data allows the message receiving facility and the message transmitting facility to be synchronized.

Message receiving facility receives messages transmitted from other agents indicating changes in the desktop environments associated with those agents. Message receiving facility may connect directly with the physical layer of the communications protocol the agents use to communicate or the message receiving facility may operate at a higher layer of the protocol by cooperating with one or more communications subsystems. For embodiments in which messages are broadcast by agents the message receiving facility has some mechanism for determining whether a broadcast message is intended for it. For example the message receiving facility may store a list of the windows which its associated desktop displays. The message receiving facility would compare the target of any received message to its list of windows to determine whether or not to take action on the received message. The message receiving facility may be implemented as a blocking function. Alternatively the message receiving facility can be implemented a call back function invoked by the ICA virtual channel transport.

Once the message receiving facility has determined that a received message is intended for its desktop the command facility is invoked to effect the change indicated by the message to the associated desktop environment. The command facility may be passed the received message facility or the message receiving facility may process the received message before communicating with the command facility . The command facility may implement the desktop change indicated by the received message by issuing GDI commands. In other embodiments the command facility may issue commands directly to an associated graphics subsystem or may issue other graphics API commands.

During a seamless windowing session a number of desktops are associated with a single machine one desktop on the client machine itself and one desktop per remote machine to which the client machine is connected. The client agent in conjunction with the server agent creates a combined window list representing the z order of all desktops. All participating desktops are linked together by the client agents and the server agents and any z order changes on any desktops will be propagated to other desktops.

In one embodiment each remote machine has knowledge only of its own graphical desktop representation and the remote machine desktops are individually represented within the client machine . The client machine display is updated by combining all remote machine and machine desktop images into a single display image based on the window information that has been obtained from each server node by the client agent . The resulting image is displayed at the client machine .

The combining process involves building a common window list based on the windows information exchanged by all agents. Using the combined window list the graphical desktop data is clipped and merged for representation by the client machine . The node takes care of clipping displayed windows resulting from the commands issued by the command facility . Such clipping functions are well known to those of ordinary skill in the art. In some embodiments however the command facility maintains a shadow bitmap of clipped windows. That is the command facility maintains a bit image of windows that are obscured by other windows. This allows the agent to change its associated desktop without requiring it to reload the window image of an obscured window from the appropriate source. In other embodiments the node determines whether graphical data is obscured at the time it is received. If it is the node ignores the received graphical data. If it is not the node displays the data. The node makes a determination as to whether the graphical data is obscured by applying clipping functions.

Monitoring facility monitors the desktop associated with the agent. Monitoring facility may monitor the desktop by periodically issuing commands provided by the operating system executing on the node which return information about the node s desktop. Alternatively the monitoring facility may watch for messages posted to an intranode message queue. As noted above in one particular embodiment the monitoring facility monitors the Windows Message Queue. Once a desktop change occurred the message transmission facility transmits a message indicating the change that has occurred. In some embodiments the message transmission facility broadcasts notification of the change.

In one embodiment message transmission facility can be implemented in the form of non blocking function that can be called from any window procedure. If the function can not send a data packet immediately for example the communication subsystem has no buffer space a timer will be set and retry attempts will be done until the send succeeds.

Referring now to an embodiment of a system for enabling seamless windowing mode between a client machine and remote computing environments is shown. In brief overview the system includes a first virtual channel a first remote desktop environment a native operating system a remote window a second virtual channel a third virtual channel a second remote desktop environment a virtualized operating system a remote window a fourth virtual channel a local agent and a local desktop environment .

In some embodiments the methods and systems described above in connection with may be implemented in systems including virtual machines. In some embodiments the local agent resides on a client machine . In one of these embodiments the client machine establishes a connection to a physical machine providing access to a resource requested by the client machine . In this embodiment the local agent on the client machine may receive window attribute data and graphical data associated with a remote window from an agent on a remote machine as described above.

In other embodiments the client machine has established a connection to a virtual machine providing access to a resource. In one of these embodiments an agent for the remote machine may reside in the virtual machine. In another of these embodiments the agent for the remote machine may reside in a hypervisor into which the virtual machine is launched. In still another of these embodiments the agent for the remote machine may reside in a second virtual machine providing management functionality for the virtual machine on the remote machine . In these embodiments the client machine may receive window attribute data and graphical data associated with a remote window through the implementation of the methods and systems described above in connection with .

The client machine may access multiple resources from different remote machines . In some embodiments the client machine may access resources on different machines substantially simultaneously over multiple established connections to for example both physical machines on remote machines and to virtual machines executing in a hypervisor on remote machines .

Referring still to and in greater detail a block diagram depicts one embodiment of a system for receiving window attribute data and graphical data associated with remote windows from virtualized operating systems and from native operating systems. The first virtual channel is coupled to the first remote desktop environment which is provided by the native operating system . The first virtual channel conveys graphical data associated with the remote window provided by the first remote desktop environment . The second virtual channel coupled to the first remote desktop environment conveys window attribute data associated with the remote window provided by the first remote desktop environment .

The third virtual channel is coupled to the second remote desktop environment provided by a virtualized operating system the third virtual channel conveying graphical data associated with the second remote window provided by the third remote desktop environment . The fourth virtual channel coupled to the second remote desktop environment and conveying window attribute data associated with the second remote window provided by the second remote desktop environment . In one embodiment the window attribute data associated with the remote windows and and conveyed by the second virtual channel and the fourth virtual channel includes the size and z order of the remote windows.

The local agent coupled to the first remote desktop and the second remote desktop via the first second third and fourth virtual channels directs the formation of a first window in the local desktop environment corresponding to the remote window provided by the first remote desktop environment and the formation of a second window in the local desktop environment corresponding to the second remote window provided by the second remote desktop environment . The first local window displays the graphical data conveyed by the first virtual channel in accordance with the window attribute data conveyed by the second virtual channel and the second local window displaying the graphical data conveyed by the third virtual channel in accordance with the window attribute data conveyed by the fourth virtual channel . In one embodiment the local agent forms and maintains a combined windows list representing a modifiable z order of a corresponding window in the local desktop environment .

In some embodiments a local operating system forms the local desktop environment . In one of these embodiments the local agent periodically polls the local operating system to detect an attribute change in one of the first local window and the second local window. In another of these embodiments upon detection of attribute change the local agent transmits a message to one of the first remote desktop environment and the second remote desktop environment indicative of the attribute change. In some embodiments corresponding windows on the local desktop environment and on the remote desktop environments and exhibit window attribute data substantially similar relative to the local desktop environment as to the window attribute data of the remote windows relative to their respective remote desktop environment.

Referring now to a flow diagram depicts one embodiment of the steps taken in a method of receiving window attribute data and graphical data associated with remote windows from virtualized operating systems and from native operating systems. In brief overview graphical data associated with a remote window provided by a first remote desktop environment provided by a native operating system is received via a first virtual channel coupled to the remote desktop step . Window attribute data associated with the remote window provided by the first remote desktop environment is received via a second virtual channel coupled to the first remote desktop environment step . Graphical data associated with a remote window provided by a second remote desktop environment provided by a virtualized operating system is received via a third virtual channel coupled to the remote desktop environment step . Window attribute data associated with the remote window provided by the second remote desktop environment is received via a fourth virtual channel coupled to the second remote desktop environment step . A first window is formed in the local desktop environment the first window displaying the graphical data received from the first virtual channel in accordance with the window attribute data received from the second virtual channel step . A second window is formed in the local desktop environment the second window displaying the graphical data received from the third virtual channel in accordance with the window attribute data received from the fourth virtual channel step .

In some embodiments a combined windows list is formed and stores at least some of the window attribute data. In other embodiments a local operating system associated with the local desktop environment is polled to detect an attribute change in one of the first local window and the second local window and transmitting a message to one of the first remote desktop environment and the second remote desktop environment indicative of the detected attribute change. In still other embodiments the local windows exhibit window attribute data substantially similar relative to the local desktop environment as the window attribute data of the remote windows relative to the remote desktop environments.

Referring to one embodiment of a system for providing a client with a reliable connection to a host service is shown. In a broad overview a system for network communications includes a client machine e.g. a first computing device in communication with a first protocol service e.g. a second computing device over a network . Also included in the system are a plurality of host services e.g. third computing devices that are in communication over a network with the first protocol service and through the first protocol service and over the network with the client machine . Alternatively in another embodiment and with reference now to the first protocol service and the host services are not implemented as separate computing devices as shown in but rather they are incorporated into the same computing device such as for example a remote machine . The system can include one two or any number of remote machines . The protocol service may also be provided as a remote machine .

In one embodiment the networks and are separate networks as in . The networks and can be the same network as shown in .

Referring still to the embodiments of the client machine is configured to establish a connection between the client machine and a first protocol service over the network using a first protocol. For its part the first protocol service is configured to accept the connection . The client machine and the first protocol service can therefore communicate with one another using the first protocol as described below in reference to and .

In some embodiments as shown in a client agent is included within the client machine . The client agent can be for example implemented as a software program and or as a hardware device such as for example an ASIC or an FPGA. The client agent can use any type of protocol and it can be for example an HTTP client agent an FTP client agent an Oscar client agent a Telnet client agent an Independent Computing Architecture ICA client agent from Citrix Systems Inc. of Fort Lauderdale Fla. or a Remote Desktop Procedure RDP client agent from Microsoft Corporation of Redmond Wash. In some embodiments the client agent is itself configured to communicate using the first protocol. In some embodiments not shown the client machine includes a plurality of client agents each of which communicates with a host service respectively.

In another embodiment a standalone client agent is configured to enable the client machine to communicate using the first protocol. The standalone client agent can be incorporated within the client machine or alternatively the standalone client agent can be separate from the client machine . The standalone client agent is for example a local host proxy. In general the standalone client agent can implement any of the functions described herein with respect to the client agent .

As also described further below the first protocol service is in one embodiment itself configured to communicate using the first protocol. The first protocol service is configured to establish a connection between the first protocol service and the host service respectively. For example the first protocol service can establish a connection between the first protocol service and one host service and a connection between the first protocol service and another host service . In one embodiment the first protocol service separately establishes such connections i.e. the first protocol service establishes one connection at a time . In another embodiment the first protocol service simultaneously establishes two or more of such connections 

In yet another embodiment the first protocol service can concurrently establish and maintain multiple connections . The first protocol service is configured to provide two or more connections without interrupting the connection with the client machine . For example the first protocol service can be configured to establish the connection between the first protocol service and the host service when a user of the client machine requests execution of a first application program residing on the host service . When the user ends execution of the first application program and initiates execution of a second application program residing for example on the host service the first protocol service is in one embodiment configured to interrupt the connection and establish the connection between the first protocol service and the host service without disrupting the connection between the first protocol service and the client machine .

The first protocol service and the host services can communicate over the connections respectively using any one of a variety of secondary protocols including but not limited to HTTP FTP Oscar Telnet the ICA remote display protocol from Citrix Systems Inc. of Fort Lauderdale Fla. and or the RDP remote display protocol from Microsoft Corporation of Redmond Wash. For example the first protocol service and the host service can communicate over the connection using the ICA remote display protocol while the first protocol service and the host service can communicate over the connection using the RDP remote display protocol.

In one embodiment the secondary protocol used for communicating between the first protocol service and a host service such as for example the ICA remote display protocol includes a plurality of virtual channels. A virtual channel is a session oriented transmission connection that is used by application layer code to issue commands for exchanging data. For example each of the plurality of virtual channels can include a plurality of protocol packets that enable functionality at the remote client machine . In one embodiment one of the plurality of virtual channels includes protocol packets for transmitting graphical screen commands from a host service through the first protocol service to the client machine for causing the client machine to display a graphical user interface. In another embodiment one of the plurality of virtual channels includes protocol packets for transmitting printer commands from a host service through the first protocol service to the client machine for causing a document to be printed at the client machine .

In another embodiment the first protocol is a tunneling protocol. The first protocol service encapsulates a plurality of secondary protocols each used for communication between one of the host services and the first protocol service within the first protocol. As such the host services and the first protocol service communicate with the client machine via the plurality of secondary protocols. In one embodiment the first protocol is for example an application level transport protocol capable of tunneling the multiple secondary protocols over a TCP IP connection.

Referring to communications between the client machine and the first protocol service via the connection take the form of a plurality of secondary protocols e.g. HTTP FTP Oscar Telnet ICA and or RDP encapsulated within a first protocol . This is indicated by the location of secondary protocols inside the first protocol . Where secure communication is not called for the first protocol can be as illustrated in communicated over an unsecured TCP IP connection .

Referring now to if secure communication is used the first protocol is communicated over an encrypted connection such as for example a TCP IP connection secured by using a secure protocol such as the Secure Socket Layer SSL . SSL is a secure protocol first developed by Netscape Communication Corporation of Mountain View Calif. and is now a standard promulgated by the Internet Engineering Task Force IETF as the Transport Layer Security TLS protocol and described in IETF RFC 2246.

Thus the plurality of secondary protocols are communicated within the first protocol with or without a secure protocol over the connection . The secondary protocols that can be used to communicate over the connections include but are not limited to HTTP FTP Oscar Telnet ICA and RDP. Moreover in one embodiment at least one of the secondary protocols as described above includes a plurality of virtual channels each of which can include a plurality of protocol packets enabling functionality at the remote client machine . For example in one embodiment one host service is a web server communicating with the first protocol service over the connection using the HTTP protocol and another host service is an application server communicating with the first protocol service over the connection using the ICA protocol. The host service generates both protocol packets for transmitting graphical screen commands to the client machine for causing the client machine to display a graphical user interface and protocol packets for transmitting printer commands to the client machine for causing a document to be printed at the client machine .

In another embodiment the method and systems described herein reduce the number of times network connections are opened and closed. In one embodiment the first protocol allows the secondary protocol connections tunneled therein such as for example an HTTP connection to be opened and or closed repetitively without also requiring the transport connection over which the first protocol is communicated e.g. TCP connection and or the secure protocol connection or the first protocol connection itself to similarly be repetitively opened and or closed. Without the encapsulation of the first protocol the secondary protocol may frequently open and close network connections such as TCP connections. This would add significant delays and overhead to the system. These delays and overhead would be further increased by the use of a secure encapsulation protocol such as SSL which have significant overhead in establishing network connections. By encapsulating the secondary protocol within the first protocol and maintaining the connection of the transport connection the secondary protocols as part of the payload of the first protocol do not need to perform frequent and costly open and closes of the network connection . Furthermore since the secondary protocols can be communicated within the first protocol with a secure protocol the secondary protocols also do not need to open and close secured connections such as with SSL. The transport connection establishes and maintains the network connection so that the encapsulated second protocols can be communicated without repetitively opening and closing the secured or unsecured network connection . This significantly increases the speed of operation in communicating the secondary protocols 

As described above the secondary protocols carry protocol packets related to applications using such protocols as HTTP FTP Oscar Telnet RDA or ICA. The secondary protocol packets transport data related to the application functionality transacted between the client machine and the host service . For example a user on the client machine may interact with a web page provided by a host service . In transactions between the client machine and the host service the secondary protocol encapsulated in the first protocol may have http protocol packets related to displaying the web page and receiving any user interaction to communicate to the host service . Since the transport connection is not maintained by the secondary protocols the secondary protocols do not need to handle any network level connection interruptions. As such the secondary protocols may not provide any network level connection interruption information in their payloads. In the above example the http related secondary protocol packets of the secondary protocol transmitted to the client machine would not provide a notification that a network interruption occurred e.g. an error message on a web page. Therefore the user on the client machine will not be notified of any network level connection interrupts through the secondary protocol . This effectively hides the network connection interruptions from the user during the use of the applications related to the secondary protocols 

Referring to an example process used by the first protocol service and the client agent of the client machine encapsulates the plurality of secondary protocols e.g. HTTP FTP Oscar Telnet ICA and or RDP within the first protocol for communication via the connection . Optionally as described below the example process used by the first protocol service and the client agent of the client machine also compresses and or encrypts the communications at the level of the first protocol prior to communications via the connection . From the point of view of the first protocol service secondary protocol packets are received via the connections at the first protocol service . For example two secondary protocol packets and are received by the first protocol service . One two or any number of secondary protocol packets can be received. In one embodiment the secondary protocol packets are transmitted by the host services to the first protocol service over the connection . The secondary protocol packets include a header and a data packet also referred to as a data payload.

Following receipt of the secondary protocol packets the first protocol service encapsulates one or more of the secondary protocol packets within a first protocol packet . In one embodiment the first protocol service generates a first protocol packet header and encapsulates within the data payload of the first protocol packet one or more secondary protocol packets such as for example two secondary protocol packets and . In another embodiment only one secondary protocol packet is encapsulated in each first protocol packet .

In one embodiment the first protocol packets are then transmitted over the connection for example over the connection described with reference to to the client agent of the client machine . Alternatively in another embodiment the first protocol service is further configured to encrypt prior to the transmission of any first protocol packets communications at the level of the first protocol . In one such embodiment the first protocol packets are encrypted by using for example the SSL protocol described with reference to . As a result a secure packet including a header and an encrypted first protocol packet as a data payload is generated. The secure packet can then be transmitted over the connection for example over the secure TCP IP connection illustrated in to the client agent of the client machine .

In another embodiment the first protocol service is further configured to compress prior to the transmission of any first protocol packets communications at the level of the first protocol . In one embodiment prior to encrypting the first protocol packet the first protocol service compresses using a standard compression technique the first protocol packet . As such the efficiency of the system is improved.

Referring again to in one embodiment the system provides the remote client machine with a persistent connection to a remote machine such as for example the remote machine . For example if the client machine establishes a connection between the client machine and the first protocol service and the first protocol service establishes a connection between the first protocol service and the remote machine then either the client agent the first protocol service or both are configured to maintain a queue of the first protocol data packets most recently transmitted via the connection . For example the queued data packets can be maintained by the client agent and or the first protocol service both before and upon a failure of the connection . Moreover upon a failure of the connection the first protocol service and likewise the remote machine are configured to maintain the connection

Following a failure of the connection the client machine establishes a new connection with the first protocol service without losing any data. More specifically because the connection is maintained upon a failure of the connection a newly established connection can be linked to the maintained connection . Further because the most recently transmitted first protocol data packets are queued they can again be transmitted by the client machine to the first protocol service and or by the first protocol service to the client machine over the newly established connection . As such the communication session between the remote machine and the client machine through the first protocol service is persistent and proceeds without any loss of data.

In one embodiment the client agent of the client machine and or the first protocol service number the data packets that they transmit over the connection . For example each of the client agent and the first protocol service separately numbers its own transmitted data packets without regard to how the other is numbering its data packets. Moreover the numbering of the data packets can be absolute without any re numbering of the data packets i.e. the first data packet transmitted by the client agent and or the first protocol service can be numbered as No. 1 with each data packet transmitted over the connection by the client agent and or the first protocol service respectively consecutively numbered thereafter.

In one such embodiment following a disrupted and re established connection the client agent and or the first protocol service informs the other of the next data packet that it requires. For example where the client agent had received data packets Nos. 1 10 prior to the disruption of connection the client agent upon re establishment of the connection informs the first protocol service that it now requires data packet No. 11. Similarly the first protocol service can also operate as such. Alternatively in another such embodiment the client agent and or the first protocol service informs the other of the last data packet received. For example where the client agent had received data packets Nos. 1 10 prior to the disruption of connection the client agent upon re establishment of the connection informs the first protocol service that it last received data packet No. 10. Again the first protocol service can also operate as such. In yet another embodiment the client agent and or the first protocol service informs the other upon re establishment of the connection of both the last data packet received and the next data packet it requires.

In such embodiments upon re establishment of the connection the client agent and or the first protocol service can retransmit the buffered data packets not received by the other allowing the communication session between a host service and the client machine through the first protocol service to proceed without any loss of data. Moreover upon re establishment of the connection the client agent and or the first protocol service can flush from each of their respective buffers the buffered data packets now known to be received by the other.

By providing the client machine with a reliable and persistent connection to a remote machine the process of opening a new user session with the remote machine is avoided by maintaining the user session through network connection interruptions. For each user session with a remote machine the client machine and the remote machine may maintain session specific context and caches and other application specific mechanisms related to that instance of the user session. For each new user session established these session specific context and caches need to be re populated or re established to reflect the new user session. For example a user on the client machine may have an http session with a remote machine . The remote machine may keep context specific information of this instance of the http session with the client machine . The context may be stored in the memory of the server in files of the server a database or other component related to providing the functionality of the remote machine . Also the client machine may have local context specific to the instance of the http session such as a mechanism for keeping track of an outstanding request to the remote machine . This context may be stored in memory of the client machine in files on the client machine or other software component interfaced with the client machine . If the connection between the client machine and the remote machine is not persistent then a new user session needs to be established with new session specific context on the remote machine and the client machine . The session is maintained so that a new session and therefore new specific session context does not need to be re established.

In some embodiments the user session is maintained through network level connection interruptions and without notification to the user of the client that the session was interrupted. In operation of these embodiments the first protocol service establishes and maintains a first connection with a client machine and a second connection with a host service . Via the first connection and the second connection a session between the client machine and the remote machine is established. The first protocol service can store and maintain any session related information such as authentication credentials and client machine and remote machine context for the established session. A user on the client machine will exercise the functionality provided by the remote machine through the established session. As such related secondary protocol packets will contain data related to the transaction of such functionality. These secondary protocol packets as part of the secondary protocol are encapsulated and communicated in a first protocol . Upon detection of a disruption in either the first connection or the second connection the first protocol service can re establish the disrupted connection while maintaining the other connection that may have not been disrupted. The network connection disruption may cause an interruption to the session between the client machine and the remote machine . However since the transport mechanism is not maintained by the secondary protocols the session can be re established after the network connection is re established without the user on the client machine having notification that the session was interrupted. The secondary protocol does not need to contain any interruption related information to transmit to the client machine . Thus the interruption of the session caused by the network connection disruption is effectively hidden from the user because of the encapsulation of the first protocol .

The first protocol service maintaining session related information can re establish the session between the client machine and the remote machines . For example if the first connection between the client machine and the first protocol service is disrupted the first protocol service can keep the client machine s session active or open between the first protocol service and the remote machine . After the first connection is re established the first protocol service can link the session of the client machine to the maintained session between the first protocol service and the host service . The first protocol service can send to the client machine any data that was queued prior to the disruption in the first connection. As such the client machine will be using the same session prior to the disruption and the remote machine and client machine can continue to use any session specific context that may have in memory or stored elsewhere. Furthermore because of the intermediary of the first protocol service the remote machine may not be aware of the network disruption between the first protocol service and the client machine .

In another example if the second connection between the first protocol service and the remote machine is disrupted the first protocol service can maintain the first connection with the client machine while re establishing the second connection with the remote machine . After re establishing the second connection the first protocol service can re establish the client s session on behalf of the client with the remote machine . Since the first protocol service was maintaining any session relation information the first protocol service may re establish the same session or a similar session so that the client machine is not aware of the disruption in the second network connection and the resulting disruption to the session between the first protocol service and the remote machine . During re establishing the second network connection and the session the first protocol service can queue any session transactions sent by the client machine during the disruption. Then after re establishing the session with the remote machine the first protocol service can transmit the queued transactions to the remote machine and the session can continue normally. In this manner the client machine continues to operate as if there was not an interruption to the session.

Additionally by providing a reliable and persistent connection some embodiments also avoid interruptions to transactions commands or operations as part of the functionality exercised between the client machine and a remote machine or a remote machine . For example a file copy operation using Windows Explorer has not been designed to continue working after there is a disruption in a network connection. A user on the client machine may use the file copy feature of Windows Explorer to copy a file from the client machine to a remote machine . Because of the size of the file or files this operation may take a relatively extended period of time to complete. If during the middle of the operation of the copy of the file to the remote machine there is an interruption in the network connection between the client machine and the remote machine the file copy will fail. Once the network connection is re established the user will need to start another file copy operation from Windows Explorer to copy the file from the client machine to the remote machine . Under some embodiments of the methods described above the user would not need to start another file copy operation. The network connection would be re established as part of the first protocol connection. The file copy operations would be encapsulated in the payload of the secondary protocols . As such the file copy of Windows Explorer would not get notified of the interruption in the network connection and therefore would not fail. The first protocol service would re establish any connections and transmits any queued data so that operation can continue without failure. The first protocol service would maintain a queue of the data related to the file copy operations that has not been transferred to the remote machine because of the interruption in the network connection. Once the network connection is re established the first protocol service can transmit the queued data and then continue on with transferring the data related to the file copy operation in due course.

Although these embodiments are described in terms of a file copy operation example one ordinarily skilled in the art will recognize that any operation transaction command function call etc. transacted between the client machine and the remote machine or remote machines can be maintained and continued without failure from the network connection disruption and furthermore without the client machine recognizing there was a disruption or having notice of the disruption.

Furthermore by providing a reliable and persistent connection a client machine is able to traverse through different network topologies without re starting a session or an application on the client machine . For example the client machine may be a computer notebook with a wireless network connection. As the client machine moves from a first wireless network to a second wireless network the client s network connection may be temporarily disrupted from the first wireless network as a network connection is established with the second wireless network. The second wireless network may assign a new network identifier such as a host name or internet protocol address to the client machine . This new network identifier may be different than the network identifier assigned to the client machine by the first wireless network. In another example the client machine may be physically connected through an Ethernet cable to a port on the network. The physical connection may be unplugged and the client machine moved to another location to plug into a different port on the network. This would cause a disruption into the network connection and possible a change in the assigned network identifier. By the method and systems described herein the network connection is maintained for the client and automatically re established the network connection of the client machine including handling changes in the network topology and network identifier. The client machine and any applications or sessions on the client machine can continue to operate as if there was not a network connection disruption or a change in the network identifier. Furthermore the user on the client machine may not recognize there were any interruptions or changes and the client machine may not receive any notice of such interruptions.

Even with a reliable and persistent communication session as described above network connections are still disrupted. When re establishing the client s connection to the host service the client machine also needs to be re authenticated to the remote machine . In one embodiment systems and methods authenticate a client machine to a host service and re authenticate the client machine to the remote machine without re entering authentication credentials.

In another embodiment securely establishing a communication session between the client machine and the host service is enabled via multiple connections or hops that traverse multiple network components such as a proxy security gateway firewall or router. The establishment of the multiple hop secure communication session may further be initiated via a secure client web server communication channel for example between the web browser and a first remote machine using SSL. The ticket authority can provide tickets for each of the hops such as the client first protocol service connection and the first protocol service to host service connections . In this manner the client machine is authenticated through all the connections between the client machine and the host service 

In some embodiments a first remote machine functioning as a web server receives a request from the client machine for an application and the first remote machine validates the request with the ticket authority . The ticket authority then generates an N part ticket e.g. Tto T . In one embodiment the ticket authority then transmits a portion Tof the N part ticket e.g. the first part of the ticket or first ticket T to the first remote machine . The first remote machine then transmits the ticket Tto the client machine . In one embodiment the ticket authority also transmits the address of the next hop e.g. the first protocol service to the first remote machine which then transmits the address to the client machine . This address is the address of the next hop e.g. first protocol service that this hop e.g. client machine needs to communicate with for the client machine to eventually be authenticated to the remote machine .

The client machine uses the address to then contact the next hop e.g. first protocol service and initiates a communication session with the first protocol service by transmitting a proxy connection request over the client first protocol service communication channel . The first protocol service then extracts the first ticket Tfrom the proxy connection request and forwards this ticket to the ticket authority for validation. The ticket authority then validates the first ticket T.

Upon proper verification of the first ticket T the ticket authority transmits the next ticket Tfrom the N part ticket e.g. T to the next first protocol service e.g. first protocol service . In some embodiments the ticket authority also transmits the address of the next hop e.g. the second first protocol service to this hop e.g. the first protocol service . The first protocol service transmits this ticket to the next hop e.g. the second first protocol service . In one embodiment the second first protocol service verifies Tby transmitting the ticket to the ticket authority . The ticket authority validates the second ticket Tand the process continues. Once the last part of the N part ticket has been validated the application is launched on the client machine .

In one embodiment each first protocol service i.e. each hop validates T e.g. T with a ticket authority associated with the first protocol service i.e. hop . In this embodiment after each first protocol service validates the ticket T e.g. T with a ticket authority the ticket authority at which the validation took place transmits the next ticket T e.g. T and the address of the next first protocol service i.e. the next hop destination to the first protocol service that had validated the ticket T. Thus each first protocol service is associated with a ticket authority that has been configured with the current and next hop tickets i.e. validating Tand transmitting Tfor the next hop . Consequently the next first protocol service acts as the client for that hop. This process is repeated until reaching the remote machine . Thus each hop has been validated individually without revealing all of the ticket to any one hop.

In other embodiments the ticket authority may issue more than one ticket rather than issuing one ticket having many parts. For example the ticket authority generates a first hop ticket and a second hop ticket where the first hop ticket has no association with the second hop ticket. The ticket authority subsequently transmits the first hop ticket to the first remote machine and the first remote machine transmits the first hop ticket to the client machine . The client machine transmits this first hop ticket to the first protocol service e.g. first protocol service for validation by the ticket authority . Upon validation the ticket authority transmits the second hop ticket to the next first protocol service e.g. second first protocol service while the first hop ticket is independent from the second hop ticket.

In a further embodiment one or more of the ticket authorities provides proxies either as part of the first protocol service or separated from the first protocol service with any necessary information needed to connect to the next hop such as but without limitation encryption keys SSL method configuration information and authentication information to connect to a SOCKS server e.g. SOCKS5 server developed by NEC Corporation of Tokyo Japan .

In yet another embodiment a ticket authority only generates a single ticket. The ticket authority transmits the single ticket to the first remote machine . The first remote machine forwards the single ticket to the client machine . The first protocol service subsequently receives the ticket from the client machine and consumes the single ticket upon validation. As a result a single ticket can provide the ability to use arbitrary communication protocols over the client proxy communication channel and the client web server communication channel. Additionally because the remote machine does not receive or verify the single ticket the ticket is transparent to the remote machine and consequently the remote machine is not aware of the use of the ticket.

By exploiting the security of the secure communications between the client machine and the first remote machine over the secure client web server communication channel the system establishes a secure communication link over the non secure client proxy communication channel to remotely display desktop applications securely on the client machine .

In yet another embodiment the ticket authority transmits a disabled version of the first protocol service ticket with the client ticket to the first remote machine for transmission to the client machine . The client machine subsequently transmits the first protocol service ticket along with the client ticket to the first protocol service as part of the proxy connection request. The first protocol service then forwards both tickets to the ticket authority . Upon receiving a disabled first protocol service ticket the ticket authority enables the first protocol service ticket after validating the client ticket. The ticket authority then transmits the enabled first protocol service ticket to the first protocol service for authentication to the host node .

Alternatively in another embodiment the first remote machine receives a disabled first protocol service ticket and an enabled client ticket from the ticket authority and only transmits the client ticket to the client machine . The client machine transmits the client ticket to the first protocol service as part of the proxy connection request. The first protocol service then forwards the client ticket to the ticket authority . The ticket authority validates the client ticket and upon validation enables the first protocol service ticket previously transmitted to the first remote machine . In yet another embodiment the ticket authority transmits an enabled first protocol service ticket to the first remote machine upon validation of the client ticket for authentication to the remote machine .

Thus at any given time the ticket authority provides only one ticket that is enabled to the client machine or first protocol service that the ticket authority can validate. The ticket authority may provide another ticket that can t be validated i.e. a disabled ticket until the enabled ticket is validated. Alternatively the ticket authority may not transmit the first protocol service ticket to the first protocol service until the ticket authority validates the enabled ticket. As discussed in further detail below this enforces network routing of communications using embodiments of this system because the client machine cannot traverse the first remote machine or the first protocol service without having the ticket authority validate the enabled ticket and transmit the ticket needed to communicate with the remote machine .

In another embodiment instead of transmitting the first protocol service ticket to the first protocol service the ticket authority transmits the first protocol service ticket to the first remote machine directly over a web server authority communication channel. The first remote machine then automatically transmits the first protocol service ticket to the remote machine . In other words the first remote machine pushes the first protocol service ticket to the remote machine . The ticket authority can also push the first protocol service ticket to the remote machine without transmission of the first protocol service ticket to the first protocol service or the first remote machine .

In yet another embodiment the remote machine retrieves the first protocol service ticket from the ticket authority over the ticket content server communication channel . In other words the remote machine pulls the first protocol service ticket from the ticket authority .

Moreover the system enforces the routing of the client machine through the first protocol service . As stated above the client machine has to possess the first protocol service ticket to establish a communication session with the remote machine . More specifically to establish a connection with the remote machine the first remote machine first has to validate the request of the client machine with the ticket authority . Once validated the client machine obtains the first ticket and transmits this first ticket to the ticket authority for validation. However upon validation the ticket authority transmits the first protocol service ticket back to the first protocol service rather than the client machine . The communication session between the client machine and the host service is established when the host service receives the first protocol service ticket. Thus the client machine has to communicate with the first protocol service in order to have the first protocol service ticket transmitted to the host service thereby enforcing the routing of the client machine through the first protocol service . Thus the invention can ensure the proper traversal of a security device e.g. the first protocol service before granting access to the remote machine .

For example a remote machine executes several applications such as MICROSOFT WORD and MICROSOFT EXCEL both developed by Microsoft Corporation of Redmond Wash. In one embodiment the client machine uses NFUSE developed by Citrix Systems Inc. of Fort Lauderdale Fla. to obtain information from the machine farm in which applications can be accessed by the client machine . If a client user wants to access and use MICROSOFT WORD the client machine requests the application from the first remote machine . However only users who pay an application fee for MICROSOFT WORD can become authorized to access the application.

To ensure the payment of the application fee the system includes the first protocol service and the ticket authority to enforce the routing of the client machine through the first protocol service . The routing of the client machine through the first protocol service is valuable to the application provider if the first protocol service is used to collect the application fee and authorize the user for access to the application.

The ticket authority subsequently generates a ticket associated with the request for the application. An enabled first ticket is then transmitted to the client machine . Because the client machine does not have the address of the host node the client machine cannot access the application. Further the client machine has not been authorized by the first protocol service yet i.e. has not yet paid . Thus the client machine has to communicate with the first protocol service to become authorized. The first protocol service can then transmit the enabled first ticket to the ticket authority upon payment of the application fee.

The ticket authority then validates the client ticket and subsequently transmits or enables a first protocol service ticket to the proxy. The first protocol service then transmits the first protocol service ticket to the remote machine e.g. assuming the client user has paid the application fee which enables the remote machine to transmit the application to the client machine .

The ACR Service running on the remote machine includes a key generator a session identifier SID generator an encryptor a key destroyer and a decryptor . The key generator generates a key when the remote machine or the ACR Service receives authentication credentials from the client machine . In one embodiment the key generator derives the key from a characteristic of the remote machine . Particular examples include the key generator deriving the key from the temperature of the processor the time that remote machine received the authentication credentials and the number of keys stored in memory . In a further embodiment the key and the authentication credentials are the same size e.g. eight bits . In one embodiment the key generator is a software module. In another embodiment the key generator is a random number generator.

The SID generator generates the unique SID to enable the remote machine to identify a particular communication session. In one embodiment the SID generator is a software module. In another embodiment the SID generator is a random number generator. In another embodiment the SID generator transmits the SID to the host service . In one embodiment the SID generator obtains the SID from a host service running on the server. In yet another embodiment the SID generator generates the SID by receiving a session identifier from the host service establishing a user session.

The encryptor encrypts the key with the authentication credentials to create encrypted authentication credentials. In one embodiment the encryptor encrypts the key with the authentication credentials by performing an exclusive OR operation i.e. XOR on the key and the authentication credentials. In another embodiment the encryptor adds the authentication credentials to the key to encrypt the authentication credentials that is the encryptor performs a Caesar Cipher on the authentication credentials using the key as the shift value. In another embodiment the encryptor performs a hash function such as MD4 MD5 or SHA 1 on the authentication credentials. It should be clear that the encryptor can perform any type of manipulation on the authentication credentials as long as the ACR Service can decrypt the encrypted authentication credentials with the key.

In one embodiment the encryptor is a software module that executes mathematical algorithms on the key and the authentication credentials to create the encrypted authentication credentials. In another embodiment the encryptor is a logic gate of the remote machine such as an exclusive OR XOR gate.

In one embodiment the encryptor stores the encrypted authentication credentials with the SID in a table in memory . In another embodiment the encryptor stores the encrypted authentication credentials in the table and the SID generator stores the SID in the table . In one embodiment the table is an area in memory allocated by the processor for us by the encryptor . In another embodiment the encryptor stores the encrypted authentication credentials with the SID in a database not shown in separate from memory .

In one embodiment the ACR Service uses the SID as a vector to the location of the encrypted authentication credentials in the table . In another embodiment the ACR Service uses the SID as a database key to locate and retrieve the encrypted authentication credentials in a database not shown in . Each encrypted authentication credential created by the encryptor is associated with only one unique SID. Thus the ACR Service can locate and retrieve the encrypted authentication credentials by using a particular SID.

The key destroyer deletes the key once the ACR Service determines that the key is no longer needed. In one embodiment the key destroyer is a delete function of a software program such as the operating system of the remote machine .

The decryptor decrypts the encrypted authentication credentials once the ACR Service receives the key and the SID from the client machine . In one embodiment the decryptor is a software module that performs the inverse function or algorithm that the encryptor performed to create the encrypted credentials. In another embodiment the decryptor is a hardware component e.g. a logic gate to perform the inverse operation of the encryptor .

In one embodiment one or more of the key generator the SID generator the encryptor the key destroyer and the decryptor are joined into one software module representing the ACR Service . In another embodiment these components can be hardware components such as logic gates. In a further embodiment these components are included in a single integrated circuit. In yet another embodiment some of the components for example the key generator and the SID generator can be hardware components and other components for example the encryptor the key destroyer and the decryptor can be software components.

In another embodiment methods for reconnecting a client machine to a remote machine when there is a disruption in the client s connection to the network are provided. The methods include re establishing the client s connection to the remote machine and using the ACR Service to re authenticate the client to the host service.

Referring to the client machine establishes a first communication session with the remote machine over the communication channel . The client machine obtains step authentication credentials from a user of the client machine . In a system not using an Open System Interconnection OSI protocol as the transmission protocol for communications between the client machine and the remote machine the authentication credentials may be a login password that is needed to establish the first communication session. In this embodiment the obtaining of the authentication credentials from the user precedes the establishment of the communication session. In another embodiment the authentication credential is personal information of the user that the client machine obtains after the first communication session has been established. Examples of authentication credentials include a login password a social security number a telephone number an address biometric information a time varying pass code and a digital certification. The client machine then transmits step the authentication credentials to the remote machine over the communication channel so that the remote machine can authenticate the client machine or the user of the client machine .

After the remote machine receives the authentication credentials the ACR Service provides its auto client reconnect services. The key generator creates step a first encryption key for use with the authentication credentials. In one embodiment the encryption key is a random number. In another embodiment the encryption key is any standard cryptographic key. The encryptor then encrypts step the authentication credentials with the first key to generate encrypted authentication credentials. This prevents an attacker who gains access to the remote machine from accessing the authentication credentials without the key. The SID generator then creates step a first SID to identify the first communication session between a client machine and the remote machine . In one embodiment the first communication session is with a host service hosted by the remote machine . The encryptor then stores step the encrypted authentication credentials with the first SID in the table described above.

In one embodiment the encryptor stores the encrypted authentication credentials with the first SID in a certain location for more efficient retrieval at a later time. For instance the encryptor stores all encrypted authentication credentials and SIDs that have been created within a predetermined amount of time in RAM. The ACR service transfers all encrypted authentication credentials and SIDS created before a predetermined time to a second external memory not shown . In another embodiment the encryptor stores the encrypted authentication credentials with the SID in a database not shown .

The SID and the encrypted authentication credentials stored in the memory can be arranged in any particular order and or format. For example the SID and encrypted authentication credentials can be stored in chronological order with respect to the creation time of the encrypted authentication credentials.

The remote machine then transmits step the first key and associated first SID to the client machine over the network . The client machine stores step the first key and the first SID in memory not shown . Then the key destroyer of the ACR Service deletes step the key stored in memory .

In another embodiment the ACR Service does not delete the first key from memory until the ACR Service has notification that the client machine has received the key. For example the client machine transmits an acknowledgment message to the remote machine after the client machine successfully received the key. Once the ACR Service receives notification the key destroyer then deletes step the key from the memory . This prevents the ACR Service from deleting the key before the client machine successfully received the key. By not deleting the key until the acknowledgment message the ACR Service can retransmit the key and the SID to the client machine upon a failure in the transmission.

By deleting the key in step the ACR Service does not have the mechanism needed to decrypt the encrypted authentication credentials stored in the table . Thus if an attacker accesses the memory of the remote machine the attacker can retrieve the encrypted authentication credentials but cannot decrypt the encrypted authentication credentials. Therefore the attacker cannot read the authentication credentials. In short the encrypted authentication credentials stored on the remote machine do not provide any information that the attacker can interpret or understand. As such the remote machine does not possess any information to decrypt the encrypted authentication credentials.

In addition the client machine is the only device that can provide the key to the encrypted authentication credentials. With the possibility of many client machines as part of the network an attacker may have to attempt to gain access to each client e.g. individually to find the client machine that possesses the correct key. This can be time consuming and tedious and as a result may deter an attacker from an attempt to decrypt the encrypted authentication credentials.

In another embodiment the remote machine has a timeout feature with respect to accessing the encrypted authentication credentials. For instance the remote machine starts a timer after the first communication is abnormally terminated. If the timer reached a predetermined value before the client machine re establishes the second communication session and transmits the key to the remote machine for decryption the ACR Service deletes the encrypted authentication credentials from the table . If no timer is used the key acts as a de facto password for future sessions.

Once the client machine receives the first key and the first SID from the remote machine as described above in reference to the session can be re established as shown in without requiring the user to reenter his or her authentication credentials. When a disruption or break occurs in the first communication session step between the client machine and the remote machine the first communication session needs to be re established and the client machine re authenticated to the remote machine . The ACR Service provides a system and method for re establishing and re authenticating the client machine to the remote machine .

When the client machine and the remote machine re establish a second communication session the client machine transmits the first key and the first SID step to the remote machine . The ACR Service uses the SID step to locate and retrieve the encrypted authentication credentials in the server s memory and uses the key step to decrypt the retrieved authentication credentials. The remote machine then re authenticates the client machine to the remote machine step by validating the authentication credentials from the client machine . In one embodiment the authentication and re authentication is facilitated through the security services provided by the operating system of the computing device of the remote machine . For example the authentication credentials are a login and password to the remote machine . In another embodiment the authentication and re authentication is facilitated through application level security services of an application or software program on the remote machine . For example the authentication credentials are an application login and password to a specific host service .

To illustrate upon an abnormal termination of a first communication session step in which the user s login password was the authentication credential the client machine attempts to establish a second communication session with the remote machine . As part of the request to the remote machine to establish a second communication session with the remote machine the client machine transmits the key and the SID step of the first terminated communication session to the remote machine . Instead of prompting the user to enter the user s login password again the remote machine through the ACR Service uses the SID step to locate and retrieve the encrypted authentication credentials associated with the user uses the key step to decrypt the retrieved authentication credentials and reauthenticates the client using the decrypted authentication information step .

In one embodiment during the second communication session the ACR Service creates step a second key for the authentication credentials and then encrypts step the authentication credentials using the second key. A second SID is created step to identify the second communication session and associate the session with the client machine . The second encrypted authentication credentials are stored step with the second SID in the table .

In this embodiment the server then transmits step the second key and the second SID to the client machine . The client machine then stores step the second key and the second SID in memory not shown for future retrieval. The ACR Service then deletes Step the second key from the memory . Thus the ACR Service can only decrypt the second encrypted authentication upon obtaining the second key and the second SID from the client machine . The ACR Service has created a new key and a new SID for the second communication session that is used with the same authentication credentials that the user had transmitted during the first communication session. Therefore a user s authentication credentials do not have to be retransmitted upon a second communication channel after an abnormal termination of the first communication session.

Although the invention is discussed in terms of authentication credentials any confidential information which can be maintained across sessions if there is a communication failure can be used. Thus if credit card information is required by an application and the credit card information is sent to the server the subsequent disconnect between the client and the server does not require the credit card information to be reentered if this invention is issued. Further although a session identifier or SID is discussed as providing a pointer to the stored authentication credentials any number or value which is suitable as a pointer may be used.

In a further embodiment not shown the system includes multiple intermediary machines that are in communication with one or more client machines through a network over additional communication channels . Although illustrated in with a single intermediary machine over a communication channel any number of intermediary nodes and number of communication channels can part of the system .

In another embodiment the invention relates to methods to facilitate establishing and authenticating a client machine s connection to a remote machine using one or more intermediary machines . As shown in an intermediary machine establishes a session with the remote machine .

The client machine establishes a first communication session with the intermediary machine over the communication channel . The client machine obtains step authentication credentials from a user of the client machine . The client machine then transmits step the authentication credentials to the intermediary machine over the communication channel so that the intermediary machine can authenticate the user with the remote machine .

After the intermediary machine receives the authentication credentials the ACR Service provides its auto client reconnect services. The ACR Service creates step a first encryption key for use with the authentication credentials and then encrypts step the authentication credentials with the first key to generate encrypted authentication credentials. This prevents an attacker who gains access to the remote machine from accessing the authentication credentials without the key. Then a session is established with the remote machine step A and the client machine is authenticated to the remote machine using the authentication credentials. Thereby the ACR Service creates a first SID to identify the first communication session. The encrypted authentication credentials are stored step with the first SID in the table described above. The intermediary machine then transmits step the first key and the first SID to the client machine over the network . The client machine stores step the first key and the first SID in the client machine s memory not shown . The ACR Service then deletes step the key stored in memory .

Once the client machine receives the first key and the first SID from the intermediary machine as described above in reference to the communication session can be re established and re authenticated as shown in without requiring the user to reenter his or her authentication credentials. For example there may be a disruption in the first communication session step between the client machine and the intermediary machine from an abnormal termination.

When the client machine and the intermediary machine re establish a second communication session the client machine transmits the first key and the first SID step to the intermediary machine . The ACR Service of the intermediary machine uses the SID step to locate and retrieve the encrypted authentication credentials in the server s memory and uses the key step to decrypt the retrieved authentication credentials. The key generator creates step a second key for the authentication credentials and the key encryptor then encrypts step the authentication credentials using the second key. The SID generator also creates step a second SID to identify the second communication session and associates it with the maintained session between the intermediary machine and the remote machine . The encryptor stores the second encrypted authentication credentials with the second SID in the table .

In this embodiment the remote machine then transmits step the second key and the second SID to the client machine . The client machine then stores step the second key and the second SID for future retrieval. The key destroyer then deletes Step the second key from the memory . Thus the ACR Service can only decrypt the second encrypted authentication upon obtaining the second key and the second SID from the client machine . The ACR Service has created a new key and a new SID for the second communication session that is used with the same authentication credentials that the user had transmitted during the first communication session. Therefore a user s authentication credentials do not have to be retransmitted upon a second communication channel after an abnormal termination of the first communication session.

In another embodiment there may be a disruption or abnormal termination in the second communication session step between the intermediary machine and the remote machine . As described in the second communication session can be re established and re authenticated without requiring the user to reenter his or her authentication credentials.

When the intermediary machine and the remote machine re establish a second communication session the intermediary machine requests step the first key and first SID from the client machine to re establish a session with the remote machine on the client s behalf. In response the client machine transmits the first key and the first SID step to the intermediary machine . The ACR Service of the intermediary machine uses the SID step to locate and retrieve the encrypted authentication credentials in the server s memory and uses the key step to decrypt the retrieved authentication credentials. The ACR Service then re establishes the client s session with the server step using the decrypted authentication credentials to re authenticate the client machine to the remote machine .

In another embodiment after re establishing and re authenticating the client over the second communication session the ACR Service of the intermediary machine creates a replacement second SID and second key as previously described in . In reference to the embodiment of the ACR Service illustrated in the key generator creates step a second key for the authentication credentials and the key encryptor then encrypts step the authentication credentials using the second key. The SID generator also creates step a second SID to identify the second communication session and associates it with the re established session between the intermediary machine and the remote machine . The encryptor stores the second encrypted authentication credentials with the second SID in the table . In this embodiment the server then transmits step the second key and the second SID to the client machine . The client machine then stores step the second key and the second SID for future retrieval. The key destroyer then deletes Step the second key from the memory .

In other embodiments one or more of the first protocol service and ACR Service can be distributed across any of the host service nodes. As such the functionality of re establishing and re authenticating or automatically reconnecting a client machine connect to a host service can be flexibly distributed in different system and deployment architectures across host services and or remote machines .

In one embodiment an ACR Service can be associated with each of the host services in system to provide auto client reconnect services dedicated to each host service respectively. A single first protocol service can be deployed to handle all of the host services . As shown in each of the multiple ACR Services is associated with each of the host services respectively. By way of example a client machine establishes a communication session with the host service using the first protocol service . The ACR Service associated with host service provides auto client reconnect services for the connection of the client machine to the host service . If there is a disruption in a network connection the first protocol service will re establish the connection with the client machine and the ACR Service will re authenticate the client machine to the host service . A second client machine may concurrently with the first client machine establish a communication session with the host service using the first protocol service . The ACR Service provides auto client reconnect services for the client s connection to the host service . If there is a network disruption the first protocol service in conjunction with the ACR Service will reconnect the client machine to the host service

In another embodiment of these methods an ACR service can be associated with each of the multiple host services running on each of the remote machines of the system . A first protocol service can be deployed on each remote machine to service each of the multiple remote machines running on that host node . As shown in each ACR service is associated with each host service respectively. Each remote machine has a dedicated first protocol service servicing each of its host services and each ACR Service . For example a client machine establishes a communication session with host service on remote machine by using the first protocol service . The ACR Service on remote machine provides auto client reconnect services for the connection of the client machine to the host service on remote machine .

If a network disruption is detected the first protocol service re establishes the client s connection to the host service on remote machine and the ACR service on remote machine re authenticates the client machine to the host service on remote machine . Concurrently with the first client machine a second client machine establishes a communication session with host service on remote machine using the first protocol service and ACR Service . If there is a network disruption the first protocol service in conjunction with the ACR Service reconnect the client machine with host service on remote machine . Concurrently with the first client machine and the second client machine a third client machine establishes a communication session with host service on remote machine using the first protocol service and ACR Service on remote machine . In a similar manner the first protocol service and ACR Service can reconnect the client machine to the host service of remote machine .

In other embodiments one or more of the ACR Services can be distributed with the first protocol services across any of the intermediary or first protocol services nodes. As such the functionality of reconnecting a client machine to a host service can be flexibly distributed in different system and deployment architectures associated with the first protocol service .

In one embodiment of this aspect of the invention the ACR Service can be associated with each first protocol service to provide auto client reconnect services dedicated to the first protocol service . A single first protocol service and ACR Service can be deployed to handle all of the host services . As shown in the ACR Service resides with the first protocol service on the same computing device to provide auto client reconnect services to host services . For example a client machine establishes a communication session with any of the host services by using the first protocol service and ACR Service . The first protocol service and ACR Service provide reconnecting functionality from a client machine to any of the host services 

In another embodiment of this aspect of the invention each of the ACR Services can be associated with each of the multiple of first protocol services . For example as shown in a first protocol service and an ACR Service can be deployed on a remote machine to service each of the multiple host services running on that remote machine . As further shown in each ACR service is associated with each first protocol service to provide dedicated auto client reconnect services to the multiple host services of each remote machine . By way of example client machine establishes a communication session with host service on remote machine by using the first protocol service and ACR Service on the same remote machine . If there is a network disruption the first protocol service in conjunction with the ACR Service reconnects the client machine to the host service on the remote machine .

Although the invention is discussed above in terms of various system and deployment architectures in any other system and or deployment architecture that combines and or distributes one or more of the first protocol service s ACR Service s and host service s across any of the remote machines intermediary machines or other computing devices can be used.

Furthermore instead of using an ACR Service to provide authentication and re authentication services a ticket authority service can be used. A ticket authority generates and validates tickets for connection and authentication purposes. A ticket can comprise a session identifier and key. It can also comprise a random number an application server certificate a nonce a constant or null value or any other type of identification confidential or security based information that may be used for such purposes.

In an embodiment of a network communication system for reconnecting a client machine to a host service as shown in a ticket authority can run on a node separate from the intermediary machine first protocol service or any of the host services . depicts an intermediary machine and ticket authority which could be a single computing device as part of the system . In addition to the networks and the system includes a client machine first protocol service and the host services all of which are described above. In one embodiment the intermediary machine is a security gateway such as for example a firewall and or a router through which messages between the client machine and the first protocol service must pass due to the configuration of the network . The ticket authority can be for example a stand alone network component that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. The ticket authority also can be a specific host service dedicated to providing ticket related services on a remote machine .

As shown in an embodiment of the intermediary machine is configured to accept a connection initiated by the client machine and to establish a second connection with the first protocol service . Together the connection and the second connection constitute the connection described above over which the client machine and the first protocol service communicate using the first protocol.

The intermediary machine as shown is also configured to communicate with the ticket authority . In one embodiment the ticket authority is configured to receive a request for a first reconnection ticket from the intermediate node and to thereafter generate the first reconnection ticket. The first reconnection ticket can include for example a large random number. The first reconnection ticket allows the client machine to automatically re establish a connection with the host service after an abnormal disruption of service without requiring the client machine to provide authentication credentials again.

In another embodiment the ticket authority is configured to receive a request for a first re connection ticket for each of the hops between the client machine and host service . For example the intermediary machine may request re connection tickets for the connection between the client machine and the intermediary machine between the intermediary machine and the first protocol service and between the first protocol service and the host service . These re connection tickets may only be valid for each of the hops . For example a first re connection ticket for the first protocol service to host service connection is valid only for authenticating the first protocol service to the host service on behalf of the client machine .

After generation of the first reconnection ticket the ticket authority encrypts the authentication credentials supplied by the client machine using the first reconnection ticket so that an attacker who gains access to the intermediary machine or the ticket authority cannot access the authentication credentials without the first reconnection ticket. The ticket authority may also generate a SID to identify the communication session that is established between the client machine and the intermediary machine . The ticket authority then stores the encrypted authentication credentials with the SID in memory and transmits the SID and the first reconnection ticket to the client machine over the network . Upon the client s receipt of the SID and the first reconnection ticket the ticket authority destroys i.e. deletes the ticket from its memory not shown .

In another embodiment the ticket authority is configured to generate a handle. The handle can be for example a random number that is associated with e.g. mapped to the first reconnection ticket. In one embodiment the handle is a smaller random number than the random number forming the first reconnection ticket. For example the handle may be a 32 bit random number. In a further embodiment the handle associated with a ticket or a re connection ticket is an address of or pointer to the next hop in the multiple hop connection between the client machine and the host service . In this case a ticket or re connection ticket is validated for a single hop with a pointer to the next hop . The next hop will need to obtain and validate a different ticket or re connection ticket and so forth until the last hop is validated and connected to the host service on behalf of the client machine .

The ticket authority transmits the first reconnection ticket and the handle to the intermediary machine while keeping a copy of the first reconnection ticket and a copy of the handle. The copy of the first reconnection ticket can later be used by the ticket authority to validate the first reconnection ticket originally transmitted to the client machine when it is later presented to the ticket authority during the process of reconnecting the client machine . In one embodiment the ticket authority also keeps an address for the first protocol service which as explained below is associated with the first reconnection ticket and upon validation of the first reconnection ticket is transmitted to the intermediary machine .

In one embodiment the intermediary machine is further configured to use the handle transmitted to it by the ticket authority to delete the copy of the first reconnection ticket kept at the ticket authority . In another embodiment as described below the ticket authority is further configured to delete during the process of reconnecting the client machine to a host service the first reconnection ticket and thereafter generate a replacement first reconnection ticket. Additionally in another embodiment the first reconnection ticket is configured for automatic deletion after a pre determined period of time. In the embodiment of re connection tickets for each of the hops between the client and the host service one some or all of the re connection tickets may be configured for automatic deletion after a pre determined period of time. In other embodiments the ticket authority or the intermediary machine is configured to delete each of the multiple hop tickets and generate replacement tickets

In another embodiment the first protocol service is configured to generate a second reconnection ticket which as in the case of the first reconnection ticket can include for example a large random number. In one embodiment the first protocol service generates second re connection tickets for each of the hops between the client machine and the host service . The first protocol service can also be configured to transmit the second reconnection ticket to the client machine while keeping a copy of the second reconnection ticket and a session number. The copy of the second reconnection ticket can later be used by the first protocol service to validate the second reconnection ticket originally transmitted to the client machine when it is later presented to the first protocol service during the process of reconnecting the client machine . In one embodiment the first protocol service transmits the second reconnection ticket to the client machine via the intermediary machine . In another embodiment the first protocol service transmits the second reconnection ticket to the client machine directly. In a further embodiment the first protocol service may transmit second re connection tickets to other first protocol services or intermediary machines that may comprise the multiple hop connection between the client machine and the host service .

Moreover as described in greater detail below the first protocol service can be further configured to delete during the process of reconnecting the client machine to a host service the second reconnection ticket and thereafter generate a replacement second reconnection ticket. Additionally in another embodiment the second reconnection ticket is configured for automatic deletion after a pre determined period of time. In further embodiments a first protocol service of one or more first protocol services in a multiple hop connection is configured to delete the second re connection tickets for each of the hops and thereafter generate replacement second re connection tickets for one some or all of the hops. 

In one embodiment the intermediary machine serves as an intermediary for the first and second reconnection tickets. The intermediary machine receives for example the first reconnection ticket generated by the ticket authority and the second reconnection ticket generated by the first protocol service . The intermediary machine can then transmit the first reconnection ticket and the second reconnection ticket to the client machine . Moreover during the process of reconnecting the client machine to a host service the intermediary machine can accept the first reconnection ticket and the second reconnection ticket from the client machine and thereafter transmit the first reconnection ticket to the ticket authority and if appropriate the second reconnection ticket to the first protocol service .

In another embodiment the intermediary node serves as an intermediary for the re connection tickets for the multiple hops between the client machine and the host service . The intermediary machine receives for example the first re connection ticket for the client machine to first protocol service connection and the first re connection ticket for the first protocol service to the host service . In a further embodiment the intermediary machine receives a first re connection ticket for the connection between the intermediary machine and the first protocol service . The intermediary machine can then transmit the first re connection ticket for the client to the client machine and the first re connection ticket for the first protocol service to the first protocol service . Moreover during the process of re connecting the client machine to a host service the intermediary machine can accept the first re connection ticket from the client machine to validate the ticket to re establish the client s connection to the intermediary machine or the first protocol service .

If the first communication session between the client machine and the host service terminates for example abnormally the new session can be re established without requiring the user to reenter his or her authentication credentials. When the client machine and the host service re establish a second communication session the client machine retransmits the first and second reconnection tickets and the SID to the intermediary machine . The intermediary machine transmits the first and second reconnection tickets and the SID to the ticket authority which uses the SID to locate and retrieve the encrypted authentication credentials for the first connection and uses the first reconnection ticket to decrypt the retrieved authentication credentials. The ticket authority then authenticates the client by validating the decrypted authentication credentials. After re authentication the second reconnection ticket is forwarded to the first protocol service to re establish the second connection with the host service .

In another embodiment of a network communications system as shown in the client machine uses the web browser to request access to a resource and a first remote machine authenticates the user. After receiving the request the first remote machine validates the request with the ticket authority . The ticket authority then generates a ticket which includes a first ticket or client ticket and a second ticket or first protocol service ticket. The first and second tickets are one time use tickets having no further value after their first use. In still another embodiment the first and second tickets must be used within a predetermined time period.

In one embodiment the ticket authority stores the first and second tickets in memory e.g. RAM until the ticket is used. Alternatively the ticket authority stores the first and second tickets in a storage device not shown until the ticket is used. The storage device may include for example a database or a persistent memory e.g. on a floppy disk or hard disk drive . The ticket authority subsequently transmits the client ticket to the first remote machine and the first remote machine then forwards the client ticket to the client machine .

The client machine then initiates a communication session with the first protocol service by transmitting a proxy connection request over the client first protocol service communication channel . The proxy connection request includes the client ticket. In one embodiment the proxy connection request also includes a dummy password that can be replaced by the first protocol service when establishing a communication session with a remote machine . In another embodiment the first remote machine transmits the dummy password to the client machine for future generation of a proxy connection request having a format acceptable to the first protocol service . The first protocol service then extricates the client ticket from the proxy connection request and forwards the client ticket to the ticket authority for validation. The ticket authority then validates the first ticket. In one embodiment the ticket authority verifies the first ticket by searching its storage device e.g. database for the first expected ticket.

If the ticket authority does not find the first ticket in the storage device such as if the first ticket has been used already the ticket authority ends the communication session. If the received ticket matches the client ticket that the ticket authority expects the client ticket is validated. The ticket authority then transmits the second or first protocol service ticket to the first protocol service . Additionally the ticket authority deletes the client ticket from the storage device as the client ticket has now been used once. In another embodiment the ticket authority also transmits the Internet protocol IP address of the remote machine to the first protocol service . In yet another embodiment the ticket authority transmits the domain name of the remote machine to the first protocol service for future conversion into the IP address.

The first protocol service receives the second ticket or the first protocol service ticket and subsequently opens communications across the proxy server communication channel by transmitting the second ticket to the remote machine . The remote machine receives the first protocol service ticket and then transmits the ticket over a ticket server communication channel to the ticket authority for validation. In one embodiment if the ticket authority determines that the first protocol service ticket received from the remote machine has been used previously or does not have the correct value i.e. the same value as the value stored in the associated storage device the ticket authority transmits an error message to the first protocol service or the first remote machine to terminate the established communication session with the client machine . If the ticket authority validates the first protocol service ticket the remote machine then launches the ICA published application. The remote machine then transmits application information to the first protocol service for remote displaying of the application on the client machine using the client agent .

In one embodiment the client machine launches the client agent when initiating communications with the first protocol service . In other embodiments the client machine launches the client agent when the client machine receives the application information from the first protocol service .

Thus the client machine is not aware of the first protocol service ticket but only the client ticket. Moreover the client agent cannot access the remote machine without communicating with the first protocol service and presenting the client ticket.

The ticket authority could also transmit the first protocol service ticket to the first protocol service as the user password for the user of the client machine . This allows the first protocol service to use the first protocol service ticket as the login password to gain access to the remote machine without exposing the user s login password over the untrusted part of the web i.e. the non secure client first protocol service communication channel . Thus in one embodiment the communications system could include a centralized password mapping database managed by the ticket authority and co located with the remote machine to map the first protocol service ticket with a user s password.

Therefore the password can accompany both tickets i.e. the first protocol service ticket and the client ticket or the password can accompany one of the two tickets. As described above if the password accompanies one of the two tickets such as the client ticket then the first protocol service ticket is the password. In one embodiment the password can be a system password that does not change in value or may be a one time use password such as those generated by SecurID tokens developed by RSA Security Inc. of Bedford Mass.

Additionally the methods described above can be expanded to a communications system having any number of first protocol services or hops with which the client machine has to communicate before establishing a communication session with the remote machine . Although described in relation to a first protocol service a hop can comprise any network component such as a proxy firewall router and relay.

For instance a four hop example is a communication system having a first protocol service a first protocol service and a first protocol service each protocol service including a proxy and located within the demilitarized zone . The protocol services may communicate with each other over a proxy proxy communication channel. The client machine communicates with the first protocol service which communicates with the second first protocol service . In turn the second first protocol service communicates with the third first protocol service and then the third first protocol service communicates with the remote machine over a proxy server communication channel to establish the communication session with the remote machine. Furthermore although the embodiment described above includes a ticket having a client ticket and a first protocol service ticket another embodiment includes the ticket comprising numerous tickets.

In still another embodiment of a network communications system as shown in an ACR Service can be used instead of the ticket authority for reconnecting the client machine to any of the host services . In this embodiment the ACR Service can provide similar services as described above with regards to the ticket authority . As previously described the ACR Service generates validates and manages a SID and a key for connecting and reconnecting a client communication session. A SID and a key can form a ticket as in the type of ticket generated validated and managed by the ticket authority as described above. As such in another embodiment a ticket may be used interchangeably for the combination of a session identifier and a key.

The intermediary machine as shown in is configured to communicate with the ACR Service . In one embodiment the ACR Service is configured to receive a request for a first SID and a first key from the intermediary machine and to thereafter generate the first SID and first key. The ACR Service uses the first SID to identify the communication session that is established between the client machine and a host service . The first SID and the first key allow the client machine to automatically reconnect with the host service after an abnormal disruption of service without requiring the client machine to provide authentication credentials again.

After generation of the first SID and the first key the ACR Service encrypts the authentication credentials supplied by the client machine using the first key so that an attacker who gains access to the intermediary machine or the ACR Service cannot access the authentication credentials without the first key. The ACR Service then stores the encrypted authentication credentials with the SID in memory and transmits the first SID and the first key to the client machine over the network . Upon the client s receipt of the SID and the key the ACR Service destroys i.e. deletes the key from its memory .

In another embodiment the first protocol service is configured to generate a second SID and second key. The first protocol service can also be configured to transmit the second SID and second key to the client machine while keeping a copy of the second SID and second key. The copy of the second SID and second key can later be used by the first protocol service to validate the second SID and second key originally transmitted to the client machine when it is later presented to the first protocol service during the process of reconnecting the client machine . In one embodiment the first protocol service transmits the second SID and second key to the client machine via the intermediary machine . In another embodiment the first protocol service transmits the second SID and second key to the client machine directly. Moreover as described in greater detail below the first protocol service can be further configured to delete during the process of reconnecting the client machine to a host service the second SID and second key and thereafter generate a replacement second SID and second key. Additionally in another embodiment the second SID and second key is configured for automatic deletion after a pre determined period of time.

In one embodiment the intermediary machine serves as an intermediary for the first and second SIDs and keys. The intermediary machine receives for example the first SID and first key generated by the ACR Service and the second SID and second key generated by the first protocol service . The intermediary machine can then transmit the first SID and first key and the SID and second key to the client machine . Moreover during the process of reconnecting the client machine to a host service the intermediary machine can accept the first SID and first key and the second SID and second key from the client machine and thereafter transmit the first SID and first key to the ACR Service and if appropriate the second SID and second key t to the first protocol service .

If the first communication session between the client machine and the host service terminates for example abnormally the new session can be re established without requiring the user to reenter his or her authentication credentials. When the client machine and the host service re establish a second communication session the client machine transmits the first and second SIDs and keys to the intermediary machine . The intermediary machine transmits the first SID and first key to the ACR Service which uses the SID to locate and retrieve the encrypted authentication credentials for the first connection and uses the first key to decrypt the retrieved authentication credentials. The ACR Service then authenticates the client by validating the decrypted authentication credentials. After re authentication the second SID and second key is forwarded to the first protocol service to re establish the second connection with the host service .

Referring to another embodiment of a system for network communications includes the networks and the client machine the first protocol service the host services the intermediary machine and the ticket authority as described above and further depicts a first remote machine and a second remote machine both of which are used in one embodiment for initially connecting the client machine to a host service . Moreover in the embodiment of the client machine further includes a web browser such as for example the INTERNET EXPLORER program from Microsoft Corporation of Redmond Wash. to connect to the World Wide Web.

In one embodiment not shown the system includes two or more intermediary machines and or two or more first protocol services . The intermediary machine through which messages between the client machine and the first protocol service must pass and or the first protocol service can as explained below each be chosen based on for example a load balancing equation.

Each of the first remote machine and the second remote machine can be any computing device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. For example in one embodiment the first remote machine is a web server providing one or more websites or web based applications. In another embodiment the second remote machine provides an XML service or web service.

In one embodiment the client machine and the network form an external network separated from the rest of the system by a first firewall depicted as a dashed line. The intermediary machine and the first remote machine can be located in a demilitarized zone i.e. a network region placed between a company s private network and the public network separated from the rest of the system by the first firewall and a second firewall also depicted by a dashed line. In some embodiments the first firewall and the second firewall prohibit unauthorized communications to or from the remote machines . Then as shown the network the first protocol service the host services the ticket authority and the second remote machine form an internal network separated from the rest of the system by the second firewall .

In some embodiments the demilitarized zone includes a ticket protocol service shown in shadow in comprising a proxy not shown and the first remote machine which may be a web server. The proxy may comprise a security gateway through which messages over the client first protocol service communication channel pass. In one embodiment the network firewall repudiates any incoming message from the client first protocol service communication channel that does not have the first protocol service as its destination. Likewise the network firewall repudiates any outgoing message for the client first protocol service communication channel unless its source is the first protocol service . The security gateway can alternatively be a router firewall relay or any network component that can provide the necessary security. The proxy may also be a network component separate from the first protocol service that may run on the same computing device of the first protocol service or on a different computing device. In some embodiments the proxy is an intermediary for securely passing communications between the client machine and the first protocol service .

Alternatively in another embodiment not shown in the system further includes a third remote machine positioned in the demilitarized zone between the network and the intermediary machine . The third remote machine can be any computing device that is capable of networked communication and that has sufficient processor power and memory capacity to perform the operations described herein. As described below the third remote machine is used in some embodiments during the process of initially connecting the client machine to a host service and or during the process of reconnecting the client machine to a host service . More specifically as described below where the system includes two or more intermediary machines the third remote machine can based on a load balancing equation for example choose the intermediary machine through with communications between the client agent of the client machine and the first protocol service must pass.

Moreover referring to the intermediary machine in an alternative embodiment can be replaced by two or more levels a n of intermediary machines . As illustrated each level a n can include two or more intermediary machines . As described below the client agent of the client machine can be routed through any combination of the intermediary machines based on for example load balancing equations. For example as illustrated the client agent can be routed through the intermediary machines via connection . For additional security each of the hops via connection may require a ticket or re connection ticket for validating and authenticating the multiple hop connection between the client machine and the host service . Other configurations of the system as would be readily apparent to one skilled in the art are also possible.

Referring again to in one embodiment the web browser communicates over the network with the first remote machine which itself interfaces with the second remote machine and the ticket authority . More specifically the first remote machine is configured with the address of the second remote machine and the ticket authority . In one embodiment as explained further below the first remote machine is configured to relay information between and thereby prevent direct communication between the web browser of the client machine the second remote machine and the ticket authority . By preventing such direct communication the first remote machine adds an additional level of security to the system . The first remote machine can also be configured with the address of the intermediary machine or alternatively with the address of two or more intermediary machines .

For its part the second remote machine is configured to determine which of the application programs running on the host services are available to a user of the client machine . In other words the second remote machine is configured to determine which of the application programs the user is authorized to access. In one embodiment after the user selects his desired application program as described further below the second remote machine is further configured to determine which of the host services will be used to run the user s desired application for purposes of load balancing. The second remote machine returns the address of that host service to the first remote machine . The second remote machine also returns the address of the first protocol service which can also be selected from amongst a plurality of first protocol services through the use of a load balancing equation to the first remote machine . In turn the first remote machine transmits the address of the chosen first protocol service and the chosen host service to the ticket authority .

For its part the ticket authority generates connection tickets. In one embodiment the ticket authority transmits an initial connection ticket to the first remote machine for transmission to the client machine . In another embodiment the ticket authority transmits a first reconnection ticket to the intermediary machine .

In one embodiment the ticket authority issues one or more tickets to authenticate the client machine . In particular the ticket authority enables authentication of the client machine over one communication channel i.e. a client web server communication channel based on authentication credentials. The ticket authority further enables the client machine to be authenticated to another communication channel i.e. the client first protocol service communication channel without having the client machine repeatedly provide authentication credentials on the other communication channel.

In one embodiment the ticket authority is a stand alone network component. In other embodiments a modular ticket authority is a software module residing on one or more remote machines . For example there may be a ticket authority for each of the remote machines . In some embodiments a first remote machine such as a web server in the demilitarized zone may communicate with the ticket authority and or the remote machine over an agent server communication channel. In another embodiment the ticket authority may reside on an intermediary remote machine separate from other remote machines .

In one embodiment the ticket authority generates a first ticket and a second ticket. In some embodiments the tickets are both nonces. In further embodiments the tickets are generated using a cryptographic random number generator that has been suitably seeded with randomness. The first ticket is transmitted to the client machine and is used to establish a first communication session between the client machine and the first protocol service . The second ticket is transmitted to the first protocol service and is used to establish a second communication session between the first protocol service and a remote machine .

In some embodiments the first remote machine is a web server. In one of these embodiments the first remote machine delivers web pages to the client machine . In another of these embodiments the first remote machine is capable of establishing a secure client web server communication channel with the client machine .

In other embodiments the first remote machine is a web server providing a corporate portal also referred to as an enterprise information portal to the client machine . In one of these embodiments enterprise portals are company web sites that aggregate personalize and serve applications data and content to users while offering management tools for organizing and using information more efficiently. In other embodiments the first remote machine provides a web portal or Internet portal to the client machine . A web portal is similar to a corporate portal but typically does not include business specific information.

In one embodiment a user of the client machine employs the web browser to authenticate the user to the first remote machine . In one embodiment the client machine transmits user credentials such as log in and password information to the first remote machine . The first remote machine verifies that the user has access to the machine farm .

In a further embodiment the web browser uses SSL to establish a secure client web server communication channel. The web browser can alternatively connect to the first remote machine over a client web server communication channel using other security protocols such as but not limited to Secure Hypertext Transfer Protocol SHTTP developed by Terisa Systems of Los Altos Calif. HTTP over SSL HTTPS Private Communication Technology PCT developed by Microsoft Corporation of Redmond Wash. and the Transport Level Security TLS standard promulgated by the Internet Engineering Task Force IETF . In one embodiment the first remote machine transmits a web portal or enterprise portal as described above to the client machine upon validation of the user to enable the client machine to request a resource such as for example an application or a server desktop to be remotely displayed on the client machine .

The client web server communication channel may be any secure communication channel. In some embodiments communications over the channel are encrypted. In certain of these embodiments the client machine and the first remote machine may communicate using the Secure Socket Layer SSL of the HyperText Transfer Protocol HTTPS . Alternatively the client machine and the first remote machine may use other encryption techniques such as symmetric encryption techniques to protect communications.

Further in one embodiment the client first protocol service communication channel can be established by using for example a presentation services protocol such as ICA X11 protocol VNC or RDP. Although described as establishing a first communication session between the client machine and the first protocol service and a second communication session between the first protocol service and the remote machine the communication session can be viewed as a single logical communication session between the client machine and the host service .

In another embodiment of a network communication system as shown in the ACR Service can be used instead of the ticket authority to reconnect a client machine to a host service . Instead of using tickets as with the ticket authority the ACR Service generates validates and manages SIDs and keys for connecting and reconnecting client communication sessions. The ACR Service authenticates and re authenticates the client to a host service or remote machine using a SID and key or a ticket associated with the client machine . As previously mentioned a ticket can be used to refer to the combination of a SID and key or a ticket can comprise a SID and a key.

The system of includes the networks and the client machine the first protocol service the host services the intermediary machine and the ACR Service as described above and further depicts a first remote machine and a second remote machine both of which are used in one embodiment for initially connecting the client machine to a host service . Moreover the client machine further includes a web browser to connect to the World Wide Web.

In one embodiment not shown the system includes two or more intermediary machines and or two or more first protocol services or two or more ACR Services . The intermediary machine through which messages between the client machine and the first protocol service must pass and or the first protocol service can and or the ACR Service as explained below each be chosen based on for example a load balancing equation.

In another embodiment the system of can include an external network separated from a demilitarized zone by a first firewall which in turn is separated from an internal network by a second firewall . Although the invention is discussed above in terms of various network topologies in any other network topologies can be used such as for example a topology including combinations of internal networks external networks sub networks intranets firewalls security zones single servers a server network or server farms.

Alternatively in another embodiment not shown in the system further includes a third remote machine positioned in the demilitarized zone between the network and the intermediary machine . The third remote machine is used in some embodiments during the process of initially connecting the client machine to a host service and or during the process of reconnecting the client machine to a host service .

In another embodiment of the system in the intermediary machine can be replaced by two or more levels a n of intermediary machines . The client agent of the client machine can be routed through any combination of the intermediary machines based on for example load balancing equations.

In one embodiment the web browser communicates over the network with the first remote machine which itself interfaces with the second remote machine and the ACR Service . The first remote machine is configured with the address of the second remote machine and the ACR Service . In another embodiment to provide an additional level of security in the system the first remote machine is configured to relay information between and thereby prevent direct communication between the web browser of the client machine the second remote machine and the ACR Service . The first remote machine can also be configured with the address of any of the intermediary machines .

For its part the second remote machine is configured to determine which of the application programs running on the host services are available to a user of the client machine and to provide the address of the host service selected by the user to the first remote machine . The second remote machine also provides the address of one of the multiple first protocol service through the use of a load balancing equation to the first remote machine . In turn the first remote machine transmits the address of the chosen first protocol service and the chosen host service to the ACR Service .

For its part the ACR Service generates validates and manages connection SIDs and key to provide authentication and re authentications services to re establish a client s communication session with a host service or remote machine as described herein. In one embodiment the ACR Service transmits a first SID and first key to the first remote machine for transmission to the client machine . In another embodiment the ACR Service transmits a first SID and first key to one of the intermediary machines .

In other embodiments methods for network communications enable reconnecting a client machine to a host service using a plurality of secondary protocols encapsulated within a first protocol. The method includes establishing a first connection between a client machine and a first protocol service using a first protocol and communicating between the client machine and the first protocol service via a plurality of second protocols encapsulated within the first protocol. Moreover at least one of the second protocols includes a plurality of virtual channels.

In one embodiment of this aspect of the invention a second connection is established between the first protocol service and a host service using one of the secondary protocols. Communication between the first protocol service and the host service occurs via one of the secondary protocols. Specifically each of the plurality of second connections is established between the first protocol service and a different host service and each of the plurality of second connections is established using one of the plurality of secondary protocols. In yet another embodiment the first connection between the client machine and the first protocol service is established through one or more intermediary machines .

Referring now to one embodiment of a method for reconnecting a client to a host service after a network failure is illustrated. At step the client machine initially connects to one of a plurality of host services . Generally the client machine is required to transmit authentication credentials to the host service to initiate the communication session. After the client machine is connected to the host service the client machine and the host service communicate through the first protocol service and at step via a plurality of secondary protocols encapsulated within the first protocol as discussed above in reference to and . In one embodiment the first protocol service encrypts prior to the transmission of any first protocol packets communications at the level of the first protocol thereby securing the communications. In another embodiment the first protocol service compresses prior to the transmission of any first protocol packets the communications at the level of the first protocol thereby improving communication efficiency.

At step the client agent determines whether the connection between the client agent and the first protocol service has failed. For example the connection between the client agent and the intermediary machine may have failed the connection between the intermediary machine and the first protocol service may have failed or both the connection and the connection may have failed. If the client agent determines that the connection has not failed the method proceeds to step . If on the other hand the client agent determines that the connection has failed the client machine is at step reconnected to the host service .

The step of reconnecting in step after a first communication session ends abnormally can comprise in a system deploying a ticket authority and the client machine transmitting the SID and the first and second reconnection tickets to the intermediary machine . The intermediary machine uses the first reconnection ticket to authenticate the client machine and re establish the connection between the client machine and the intermediate node . The intermediary machine then transmits the second reconnection ticket to the first protocol service which uses the second reconnection ticket to authenticate re establish the connection to the host service . The reconnection tickets thus allow the client machine to automatically establish a second communication session to the host service without retransmitting the authentication credentials a second time.

In another embodiment the step of reconnecting in step can also comprise a system deploying an ACR Service . In such an embodiment the client machine transmits a first SID and first key to the intermediary machine to authenticate the client machine and reestablish the connection of the client machine to the host service .

It is determined at step whether the client machine wishes to cleanly terminate its connection with the first protocol service and consequently its connections with the host services . If not communication between the client machine and the first protocol service via the plurality of secondary protocols encapsulated within the first protocol continues at step . If so then at step all connections and are broken and all reconnection tickets are deleted. In another embodiment using an ACR Service at step all connections and are broken and all SIDS and keys are deleted. In one embodiment the intermediary machine uses a handle it receives from the ticket authority to delete a copy of a first reconnection ticket kept at the ticket authority . In another embodiment deploying a ticket authority the first protocol service deletes a copy of a second reconnection ticket kept at the first protocol service . In yet another embodiment deploying the ACR Service the first protocol service deletes a copy of a second SID and second key kept at the first protocol service .

In a further embodiment using a ticket authority if for some reason a secondary protocol connection fails a copy of the second reconnection ticket associated therewith and kept at the first protocol service is deleted by the first protocol service . In yet another embodiment a first reconnection ticket and or a second reconnection ticket is automatically deleted after a pre determined period of time following a failure in the connection as at step and or following a clean termination of the connection as at step .

In another aspect this invention relates to methods for reconnecting the client machine to the host service using the ACR Service . Referring now to one embodiment of step in is illustrated. The client machine transmits the first SID and the first key to the ACR Service to reconnect to the host service step . The ACR Service uses the SID step to locate and retrieve the encrypted authentication credentials and uses the key step to decrypt the retrieved authentication credentials. In one embodiment not shown the ACR Service uses the decrypted authentication credentials to re authenticate the client machine to the maintained session between the first protocol service and the host service . After re authenticating the reestablished connection of the client machine to the first protocol service is re linked to the maintained session between the first protocol service and the host service .

In another embodiment during the second communication session the ACR Service generates step a second key for the authentication credentials and then encrypts step the authentication credentials using the second key. The ACR Service creates a second SID step . Then the decrypted authentication credentials are re authenticated with the host service and the second SID is associated with the maintained communication session with the host service step . The ACR Service then transmits the second SID and second key to the client machine step . In one embodiment the ACR Service may transmit the second SID and second key through an intermediary machine . The client machine stores the second SID and second key step . The ACR Service then deletes the second key step .

Referring to one embodiment of a method for initially connecting the client machine to the host service using an ACR Service is illustrated. At step the client machine using the browser sends a request such as for example an HTTP request to the first remote machine . The first remote machine returns a web page such as for example an HTML form requesting authentication information e.g. a username and a password . A user of the client machine enters his authentication credentials and transmits the completed form to the first remote machine .

The first remote machine at step then informs the user of the client machine of applications available for execution. In one embodiment the first remote machine extracts the user s credentials from the login page and transmits them to the second remote machine together with a request for the second remote machine to enumerate the applications available to the user. Based on the user s credentials the second remote machine returns a list of specific applications available to the first remote machine which then forwards the list in the form of a web page for example to the user of the client machine .

At step the user selects the desired application and a request for that application is sent to the first remote machine . For example in one embodiment the user clicks on a desired application listed in the web page presented to him by the first remote machine and an HTTP request for that application is forwarded to the first remote machine . The request is processed by the first computing node and forwarded to the second remote machine .

At step the second remote machine determines the host service on which the desired application will be executed. The second remote machine can make that determination based for example on a load balancing equation. In one embodiment the second remote machine also determines a first protocol service from amongst a plurality of first protocol services that will be used to communicate with the host service via a connection . Again the second remote machine can make that determination based for example on a load balancing equation. The second remote machine returns the address of the chosen host service and the chosen first protocol service to the first remote machine .

The client machine at step is then provided with an initial connection session id and key a first SID and first key and an address for the intermediary machine which is either its actual address or its virtual address as described below . In one embodiment the first remote machine provides the address for the chosen host service and the chosen first protocol service to the ACR Service together with a request for the initial connection session id and key. The ACR Service generates the initial session id and key and transmits the session id and key to the first remote machine while keeping a copy for itself.

In some embodiments the ticket authority generates an initial connection ticket. In one of these embodiments the ticket authority keeps the address of the chosen host service and the chosen first protocol service generates the initial connection ticket and transmits the initial connection ticket to the first remote machine while keeping a copy for itself. In one embodiment the ticket authority in response to the request for the initial connection ticket by the first remote machine generates connection tickets for each of the hops between the client machine and the host service . In another embodiment the first remote machine requests initial connection tickets for each of the hops either in a single request or in multiple requests.

The first remote machine configured in one embodiment with the actual address of the intermediary machine then transmits the actual address of the intermediary machine and the initial connection session id and key to the browser of the client machine . In some embodiments an initial connection ticket is transmitted. The first remote machine can for example first create a file containing both the actual address of the intermediary machine and the initial connection ticket and then transmitting the file to the browser of the client machine . Optionally in another embodiment the first remote machine is configured with the actual address of two or more intermediary machines . In such an embodiment the first remote machine first determines the intermediary machine through which messages between the client machine and the first protocol service will have to pass. The first remote machine then transmits the actual address of that chosen intermediary machine and the initial connection ticket to the browser of the client machine using for example the file described above. In one embodiment the first remote machine chooses the intermediary machine using a load balancing equation. The client agent of the client machine is then launched and uses the address of the intermediary machine to establish at step a first protocol connection between the client agent of the client machine and the intermediary machine .

Alternatively in another embodiment the first remote machine is configured with an actual address of the third remote machine which serves as a virtual address of an intermediary machine . In such an embodiment the first remote machine transmits at step the actual address of the third remote machine and the initial connection session id and key to the browser of the client machine using for example the file described above. The client agent of the client machine is then launched and uses the actual address of the third remote machine to establish at step a first protocol connection between the client agent of the client machine and the third remote machine . The third remote machine then determines the intermediary machine through which messages between the client machine and the first protocol service will have to pass. In one embodiment the third remote machine chooses the intermediary machine using a load balancing equation. Having chosen the intermediary machine the third remote machine establishes a first protocol connection to the intermediary machine . A first protocol connection therefore exists through the third remote machine between the client agent of the client machine and the intermediary machine . The actual address of the third remote machine is therefore mapped to the actual address of the intermediary machine . To the client agent of the client machine the actual address of the third remote machine therefore serves as a virtual address of the intermediary machine .

In one embodiment where more than one level of intermediary machines exist as described above the first remote machine or the third remote machine respectively only choose the intermediary machine to which the client agent will connect at level a. In such an embodiment at each of the levels a n 1 the intermediary machine through which the client agent is routed at that level thereafter determines based on a load balancing equation for example the intermediary machine to which it will connect at the next level. Alternatively in other embodiments the first remote machine or the third remote machine respectively determine for more than one or all of the levels a n the intermediary machines through which the client agent will be routed.

Having established the first protocol connection between the client agent of the client machine and the intermediary machine for example the intermediate node at level n hereinafter referred to in method as the intermediary machine the client agent then transmits the initial connection ticket to the intermediary machine .

It is then determined at step whether the initial connection SID and key is valid. In one embodiment the intermediary machine transmits the initial connection SID and key to the ACR Service for validation. In one embodiment the ACR Service validates the SID and key by comparing it to the copy of the SID and encrypted authentication credentials it kept at step . If the ACR Service determines the SID and key to be valid the ACR Service transmits at step the address of the first protocol service and the address of the chosen host service to the intermediary machine . The first protocol service can also delete the SID and key and any copy thereof. If on the other hand the ACR Service determines the SID and key to be invalid the client machine is at step refused connection to the first protocol service and consequently connection to the host service . In some embodiments the ticket authority receives an initial connection ticket from the intermediary machine for validation and validates the ticket as described above.

Following step the intermediary machine uses the address of the chosen first protocol service to establish at step a first protocol connection between the intermediary machine and the first protocol service . In one embodiment the intermediary machine uses an initial connection ticket to establish the first protocol connection between the intermediary machine and the first protocol service . In one case the intermediary machine uses the same initial connection ticket received from the client machine to validate the connection . In another case the intermediary machine uses an initial connection ticket generated for and valid for the first protocol connection . A first protocol connection therefore now exists through the intermediary machine between the client agent of the client machine and the first protocol service . The intermediary machine can also pass the address of the chosen host service to the first protocol service .

In one embodiment at step the first protocol service uses the address of the chosen host service to establish a secondary protocol connection between the first protocol service and the chosen host service . For example the chosen host service is in fact the host service and a secondary protocol connection is established between the first protocol service and the host service

In one embodiment following step the user chooses at step a second application to be executed and the second remote machine determines at step the host service on which the second application is to be executed. For example by calculating a load balancing equation the second remote machine may choose the host service to execute the second application program. The second remote machine then transmits the address of the chosen host service to the first protocol service . In one embodiment the second remote machine is in direct communication with the first protocol service and directly transmits the address thereto. In another embodiment the address of the chosen host service is indirectly transmitted to the first protocol service . For example the address can be transmitted to the first protocol service through any combination of the first remote machine the ACR Service the intermediary machine and the first protocol service . Having received the address of the chosen host service the first protocol service establishes at step a secondary protocol connection between the first protocol service and the chosen host service

The secondary protocols that can be used to communicate over the connections and include but are not limited to HTTP FTP Oscar Telnet ICA and RDP. Moreover in one embodiment at least one of the secondary protocols as described above includes a plurality of virtual channels each of which can include a plurality of protocol packets enabling functionality at the client machine . For example in one embodiment one host service is a web server communicating with the first protocol service over the connection using the HTTP protocol and another host service is an application server communicating with the first protocol service over the connection using the ICA protocol. The host service generates both protocol packets for transmitting graphical screen commands to the client machine for causing the client machine to display a graphical user interface and protocol packets for transmitting printer commands to the client machine for causing a document to be printed at the client machine .

Steps and can be repeated any number of times. As such any number of application programs can be executed on any number of host services the outputs of which can be communicated to the first protocol service over the connections using any number of secondary protocols.

Turning now to step the first protocol service can as described above encapsulate the plurality of secondary protocols within the first protocol. As such the client machine is connected to and simultaneously communicates with a plurality of host services .

In another embodiment prior to performing steps and to execute a new application program on a host service such as for example the host service a user of the client machine ends execution of another application program such as for example an application program executing on host service . In such a case the first protocol service disrupts the connection between the first protocol service and the host service . The first protocol service then establishes by implementing steps and the connection between the first protocol service and the host service without interrupting the connection between the client machine and the first protocol service .

In one embodiment a first SID and key is generated at step . In some embodiments a first re connection ticket is generated. For example the intermediary machine requests a first SID and key from the ACR Service . Upon receiving the request the ACR Service generates the first SID and key and can also generate a handle which is for example a random number. The ACR Service can then transmit at step the first SID and key and the handle to the intermediary machine while keeping a copy of the first SID and key and a copy of the handle. The ACR Service continues to maintain the address of the first protocol service that was transmitted to it by the first remote machine at step . The intermediary machine then transmits at step the first reconnection ticket to the client machine .

In some embodiments the intermediary machine requests a first re connection ticket from the ticket authority or requests a first re connection ticket for each of the hops between the client machine and the host service . Upon receiving the request the ticket authority generates the one or more first re connection tickets. A re connection ticket is for example a large random number and can also generate a handle which is for example a smaller random number. The ticket authority can then transmit at step the first re connection tickets and the handles to the intermediary node while keeping a copy of the first re connection tickets and a copy of the handles. The ticket authority continues to maintain the address of the first protocol service that was transmitted to it by the first remote machine at step . The intermediary node then transmits at step the client s first re connection ticket to the client machine .

At step a second SID and key is then generated. In one embodiment the first protocol service generates the second SID and key. The first protocol service at step then transmits the second SID and key through the intermediary machine to the client machine . In doing so the first protocol service keeps a copy of the key and a session number associated therewith for identifying the session to be reconnected following a disruption of the connection . In one embodiment for example the first protocol service maintains for a particular session number a table listing the secondary protocol connections associated with that session number.

At step one or more second re connection tickets are then generated. In one embodiment the first protocol service generates the second re connection ticket for the client machine which can be for example a large random number. In another embodiment the first protocol service generates second re connection tickets for one or more of the hops between the client machine and the host service . The first protocol service at step then transmits the client s second re connection ticket through the intermediary machine to the client machine . In doing so the first protocol service keeps a copy of the second re connection ticket and a session number associated therewith for identifying the session to be re connected following a disruption of the connection . In one embodiment for example the first protocol service maintains for a particular session number a table listing the secondary protocol connections associated with that session number. In a like manner the first protocol service may maintain the first and or second re connection tickets for each of the hops being validated to reconnect the client machine to the host service .

Accordingly following re establishment of the first protocol connection and validation of the second SID and key at the first protocol service or second re connection ticket as described below the first protocol service can identify the secondary protocol connections to be encapsulated within the re established first protocol connection for communication to the client machine .

In an embodiment not shown in a ticket authority can be used instead of the ACR Service to provide for reconnecting a client machine to a host service . In the method the ticket authority would generate and transmit reconnection tickets instead of SIDs and keys as with the ACR Service . For example at step a ticket authority would provide the client machine with an initial connection ticket and an address for the intermediary machine . Also in step the ticket authority would determine if the initial connection ticket is valid and at step would generate a first reconnection ticket. Additionally at steps and the ticket authority would generate and transmit the first and second reconnection tickets in accordance with method . As such the ticket authority facilitated the reconnecting of the client machine to the host service .

Referring now to one embodiment of a method for providing a client machine with a persistent and reliable connection to one or more host services and for reconnecting the client machine to the host services for example at step of is illustrated. In particular at step the secondary protocol connection between the first protocol service and each of the one or more host services is maintained. Moreover at step a queue of data packets most recently transmitted between the client agent of the client machine and the first protocol service via the connection that was determined to have broken for example at step of is maintained. In one embodiment the data packets are queued and maintained both before and upon failure of the connection . The queued data packets can be maintained for example in a buffer by the client agent . Alternatively the first protocol service can maintain in a buffer the queued data packets. In yet another embodiment both the client agent and the first protocol service maintain the queued data packets in a buffer.

At step a new first protocol connection is established between the client agent of the client machine and the first protocol service and linked to the maintained secondary protocol connection between the first protocol service and each of the one or more host services thereby reconnecting the client machine to the host services . After the client machine is reconnected the queued data packets maintained at step can be transmitted at step via the newly established first protocol connection . As such the communication session between the host services and the client machine through the first protocol service is persistent and proceeds without any loss of data. In one embodiment the ACR Service authenticates the client machine to the host service before reconnecting the client machine to a host service . In another embodiment the first protocol service validates a reconnection ticket with the ticket authority before reconnecting the client machine to a host service .

In an embodiment with multiple hops traversing multiple first protocol services a portion or all of the data packets may be maintained at one or more of the first protocol services so that each hop may be re established. After the client machine is re connected and re linked to the first of the one or more first protocol services as described above each of the remaining connections may be re established and re linked to the previously re linked hop until the final hop to the host service is re established. Either after the final hop is re established and re linked or as each hop is re established and re linked the queued data packets maintained can be transmitted.

At step any remaining connections between the client machine and the first protocol service are broken. For example where the connection has failed but the connection has not the connection is broken. Alternatively where the connection has failed but the connection has not the connection is broken.

In one embodiment using the actual address of the intermediary machine provided to the client machine the client agent of the client machine then re establishes at step the first protocol connection between the client agent and the intermediary machine . Alternatively in another embodiment using the actual address of the third remote machine provided to the client machine the client agent of the client machine then re establishes at step a first protocol connection between the client agent and the third remote machine . The third remote machine then determines the intermediary machine through which messages between the client machine and the first protocol service will have to pass. In one embodiment the third remote machine chooses the intermediary machine using a load balancing equation. The intermediary machine chosen by the third remote machine in reconnecting the client machine to the one or more host services can be different from that chosen to initially connect the client machine to the one or more host services . In one embodiment an initial connection ticket for the chosen intermediary machine is generated when re connecting the client machine to a host service .

Having chosen the intermediary machine the third remote machine re establishes a first protocol connection to the intermediary machine . A first protocol connection is therefore re established through the third remote machine between the client agent of the client machine and the intermediary machine . In one embodiment when the first protocol connection to the intermediary machine is re established the first protocol connection is validated by validating a first or second re connection ticket for this hop with the ticket authority .

In one embodiment where more than one level of intermediary machines exist the intermediary machine through which the client agent is routed at each of the levels a n 1 thereafter determines based on a load balancing equation for example the intermediary machine to which it will connect at the next level. Alternatively in another embodiment the third remote machine determines for more than one or all of the levels a n the intermediary machines through which the client agent will be routed. In other embodiments either the intermediary machine or one of the remote machines e.g. the third remote machine generates first or second re connection tickets for one or more of the connections or hops through which the client agent is routed.

Having re established the first protocol connection between the client agent of the client machine and the intermediary machine for example the intermediate node at level n hereinafter referred to in method as the intermediary machine the client agent then transmits at step the first SID and key and the second SID and key to the intermediary machine . In one embodiment the client agent transmits at step the first re connection ticket and the second re connection ticket for the client machine to the intermediary machine .

It is then determined at step whether the first SID and key is valid. In one embodiment the validity of the first SID and key is determined by using the ACR Service . For example the intermediary machine transmits the first SID and key to the ACR Service . In one embodiment the ACR Service determines the validity of the first SID and key by comparing it to a copy of the first SID stored in memory . If the ACR Service determines the first SID and key to be valid the ACR Service re authenticates the client machine to the host service and transmits at step the address of the first protocol service to the intermediary machine . Otherwise if the ACR Service determines the first SID and key to be invalid the client machine is at step refused reconnection to the first protocol service and consequently reconnection to the host services .

In one embodiment the validity of a first re connection ticket is determined by using the ticket authority . For example the intermediary machine transmits the first re connection ticket to the ticket authority . In one embodiment the ticket authority determines the validity of the first re connection ticket by comparing it to a previously kept copy of the first re connection ticket. If the ticket authority determines the first re connection ticket to be valid the ticket authority transmits at step the address of the first protocol service to the intermediary machine . Otherwise if the ticket authority determines the first re connection ticket to be invalid the client machine is at step refused re connection to the first protocol service and consequently re connection to the host services .

At step the first SID and key is deleted by for example the ACR Service and a replacement second SID and key is generated by the ACR Service . In some such embodiments the ACR Service transmits the second SID and key to the intermediary machine . In some embodiments the ACR Service waits for the client machine to acknowledge that it has received the second SID and key before it proceeds to delete the first SID and key.

In other embodiments at step a first re connection ticket is deleted by for example the ticket authority and a replacement first re connection ticket is generated by for example the ticket authority . Moreover a replacement handle can be generated by for example the ticket authority . In some such embodiments the ticket authority transmits the replacement first re connection ticket and the replacement handle to the intermediary machine . Moreover in some such embodiments the ticket authority keeps a copy of the replacement first re connection ticket. In some embodiments the ticket authority waits for the client machine to acknowledge that it has received the replacement first re connection ticket before it proceeds to delete the first re connection ticket.

After the first SID and key or in some embodiments the first re connection ticket is validated the intermediary machine using the address of the first protocol service re establishes at step the first protocol connection between the intermediary machine and the first protocol service . Having re established the first protocol connection between the intermediary machine and the first protocol service it is then determined whether the second SID and key or re connection ticket is valid.

In one embodiment the validity of the second SID and key is determined by using the first protocol service . For example the intermediary machine transmits the second SID and key to the first protocol service . In one embodiment the first protocol service determines the validity of the second SID and key by comparing it to a previously kept copy of the second SID and encrypted authentication credentials. If the first protocol service determines the second SID and key to be valid the re established first protocol connection between the first intermediary machine and the first protocol service is linked at step to the maintained secondary protocol connection between the first protocol service and each of the one or more host services . Otherwise if the first protocol service determines the second SID and key to be invalid the re established first protocol connection is not linked to the one or more maintained secondary protocol connections and the client machine is refused reconnection to the one or more host services .

In embodiments using re connection tickets the validity of the second re connection ticket is determined by using the first protocol service . For example the intermediary machine transmits the second re connection ticket to the first protocol service . In one embodiment the first protocol service determines the validity of the second re connection ticket by comparing it to a previously kept copy of the second re connection ticket. In another embodiment the first protocol service validates a first re connection ticket for the connection between the first protocol service and the host service or in another embodiment between the first protocol service and another first protocol service or an intermediary machine . In a similar manner each hop thereafter between the first protocol service and the host service may be validated with one or more tickets either initial or re connection tickets to validate the continued use of the hop on behalf of the client machine .

If the first protocol service determines the second re connection ticket to be valid the re established first protocol connection between the first intermediary machine and the first protocol service is linked to the maintained secondary protocol connection between the first protocol service and each of the one or more host services . Otherwise if the first protocol service determines the second re connection ticket to be invalid the re established first protocol connection is not linked to the one or more maintained secondary protocol connections and the client machine is refused re connection to the one or more host services . In the case of a multiple hop connection between the first protocol service and the host service each hop may be validated for re connection and be linked to the previous hop until the final hop to the host service is validated or until one of the hops is refused re connection.

At step the second SID and key is deleted by for example the first protocol service and a replacement second SID and key is generated by for example the first protocol service for transmission to the client machine . In such an embodiment the first protocol service keeps a copy of the replacement second SID and key. In some embodiments the first protocol service waits for the client machine to acknowledge that it has received the replacement second SID and key before it proceeds to delete the second session id and key

In some embodiments the second re connection ticket is deleted by for example the first protocol service and a replacement second re connection ticket is generated by for example the first protocol service for transmission to the client machine . In such an embodiment the first protocol service keeps a copy of the replacement second re connection ticket. In some embodiments the first protocol service waits for the client machine to acknowledge that it has received the replacement second re connection ticket before it proceeds to delete the second re connection ticket. In the case of validating one or more of the hops for re connecting a client one or more replacement re connection tickets at step may be generated and or a copy saved by the ticket authority intermediary nodes any of the computing nodes or one or more of the first protocol services .

At step the replacement second SID and key are transmitted to the client machine . For example the ACR Service can transmit through the intermediary machine the replacement second SID and key to the client machine . Moreover in one embodiment the first protocol service transmits through the intermediary machine the replacement second SID and key to the client machine .

In some embodiments the replacement first re connection ticket and the replacement second re connection ticket are transmitted to the client machine . For example the ticket authority can transmit through the intermediary machine the replacement first re connection ticket to the client machine . Moreover in one embodiment the first protocol service transmits through the intermediary machine the replacement second re connection ticket to the client machine . In other embodiments the replacement re connection tickets for one or more hops may be transmitted to one or more of the intermediary machine any of the computing nodes or one or more of the first protocol services .

Alternatively in other embodiments the methods described above provide for only a single re connection ticket for the client machine and or a single re connection for each of the hops between the client machine and a host service . As such rather than using both first and second re connection tickets in these embodiments only the aforementioned single re connection ticket is used. In one such embodiment the client agent of the client machine is also provided with the address of the first protocol service . To re connect to the host services the client agent transmits the single re connection ticket directly to the first protocol service . The first protocol service then determines whether the single re connection ticket is valid. In one embodiment the first protocol service determines the validity of the single re connection ticket by comparing it to a previously kept copy of the single re connection ticket. If the first protocol service determines the single re connection ticket to be valid the re established first protocol connection between the client machine and the first protocol service is linked to the maintained secondary protocol connection between the first protocol service and each of the one or more host services . Otherwise if the first protocol service determines the single re connection ticket to be invalid the re established first protocol connection is not linked to the one or more maintained secondary protocol connections and the client machine is refused re connection to the one or more host services .

After the single re connection ticket is validated the single re connection ticket is deleted by for example the first protocol service and a replacement single re connection ticket is generated by for example the first protocol service for transmission to the client machine . In transmitting the replacement single re connection ticket to the client machine the first protocol service keeps a copy of the replacement single re connection ticket. In some embodiments the first protocol service waits for the client machine to acknowledge that it has received the replacement single re connection ticket before it proceeds to delete the single re connection ticket.

In yet another embodiment like the first and second re connection tickets the single re connection ticket is configured for automatic deletion after a pre determined period of time following a failure in the connection and or following a clean termination of the connection .

In an embodiment not shown in a ticket authority could also be used instead of the ACR Service for reconnecting a client machine to a host service . In the method the ticket authority would generate and transmit reconnection tickets instead of SIDs and keys as with the ACR Service . For example at step a ticket authority would determine in step if a first reconnect ticket received from the intermediary machine in step is valid. At step the ticket authority would delete the first reconnection ticket and generates a second reconnection ticket with a handle. As such the ticket authority facilitates re establishing and re authenticating the communication session of the client machine to the host service .

Performance of the network can be monitored to increase performance perceived by the user of a client machine . The bandwidth and latency of the network is a factor that affects the interaction experience of the end user of the client machine . Other factors include the number of virtual machines executing on a remote machine or the number of applications executing within a virtual machine on the remote machine the amount of data being executed or load of the applications the amount of processing or load being done by the client machine . During operation each of these factors fluctuates. As data is transmitted through the network the amount of available bandwidth of the network is reduced. The number of requests to a remote machine increases and decrease thereby varying the load of the remote machine . One aspect of the invention features systems and method for determining whether and how these independent changes affect the interaction experience of the end user.

The client software is in communication with a transceiver module of the client machine . The client software includes a trigger module in communication with the transceiver module . The trigger module generates a message that is transmitted to the remote machine software . The message is configured to generate a response from the remote machine software when the message is processed by the remote machine . For example the message can include a user input event that results in a graphical response from the remote machine. In one embodiment the trigger module generates the message on a periodic basis. The length of the period can be configurable by the user of the client machine or another user such as a system administrator. In another embodiment the trigger module generates the message in response to a specific end user input using input device .

The transceiver module is in communication with network and is configured to transmit the message from the client machine to the remote machine via the network and receive a response from the remote machine . If necessary the transceiver module formats the message for transmission via the network and formats the response for execution by the client software .

Optionally the client software can include a timer module and a calculation module . The timer module is in communication with the trigger module and the calculation module . The timer module is configured to measure the elapsed time from the generation of the message until the client machine completes the instructions included in the response from the remote machine. In one embodiment the timer module generates a start timestamp and a completion timestamp and determines the elapsed time therebetween. In another embodiment the timer module acts as a stopwatch and generates the elapsed time without performing calculations. In one embodiment the elapsed time is sent to another remote machine for further processing such a calculation of an expected elapsed time trending analysis and storage. In another embodiment the elapsed time is forwarded to the calculation module from comparison against an expected value to determine if the environment is operating within specification. In still another embodiment the elapsed time is forwarded to the remote machine that the client is communicating with.

The remote machine software is in communication with a transceiver module of the remote machine . The remote machine software includes an echo application an optional initiation module and an optional confirmation module . In one embodiment the remote machine software is in communication with the application programs and the operating system that are executing on the remote machine . In another embodiment the remote machine software is in communication with a computing environment and a hypervisor executing on the remote machine . In still other embodiments the remote machine software executes in a virtual machine provided by a hypervisor and in these embodiments communicates with application programs provided by the computing environment and the virtualized operating system of the virtual machine. The echo application is in communication with the transceiver module and if present each of the initiation module and the confirmation module . In one embodiment the echo application is invisible to the end user of the client machine . For example the echo application can be a windowless e.g. stealth application . The end user does not interact directly with the echo application .

The echo application generates a graphical response to the message from the client software . The graphical response message includes instructions to manipulate modify update alter or change the display of the client machine in a manner that is not perceivable by the end user of the client machine but is perceivable by client software of the client machine . In one embodiment the echo application executes invisibly alongside the application programs . In such an embodiment the echo application is subject to the same environmental effects and changes as the application programs .

The transceiver module is in communication with network and is configured to transmit the response from the remote machine to the client machine via the network and receive the message from the client machine . If necessary the transceiver module formats the response for transmission via the network and formats the message for execution by the remote machine . The transceiver module forwards the received message to the operating system of the remote machine .

The operating system is configured to read and process the message to generate an input event for the echo application . The input event can be a known WINDOWS input event or a custom input event. Conceptually the input event is configured to cause the echo application generate the graphic response .

The initiation module is in communication with the application programs and the operating system . In one embodiment the initiation module monitors the application programs and automatically initiates the echo application when a specific one of the application of the application programs begins executing on the remote machine . In another embodiment the initiation module initiates the echo application when the remote machine receives the message . In another embodiment the echo application is initiated when a client remote machine session begins and remains quiescent until the message is received. It should be understood that the initiation module can initiate one or more instances of the echo application . For example the initiation module may start a respective echo application for each client machine that connects to the remote machine or that connects to a virtual machine provided by the remote machine .

The confirmation module is in communication with the echo application . In one embodiment a function performed by the confirmation module includes monitoring the echo application to ensure an instance of the echo application is executing for each connection between a client machine and a remote machine that is of interest. The confirmation module may report whether the echo application is running and functioning properly to another remote machine such as a management server described above or the confirmation module may report whether the echo application is running and functioning properly to the operating system of the remote machine or to a virtual machine provided by a hypervisor.

With reference to an embodiment of a method of operation and interaction between the client machine and remote machine is described. As a general overview the method can be conceptualized as a generating a measurement for use in calculating an end user experience metric in the remote machine based computing environment . The operation of the client software and the remote machine software includes transmitting the message to the application step receiving a graphic response step from the application and determining an elapsed time step that represents the end user s interaction experience.

In one embodiment the trigger module on the client software transmits the message via the transceiver on a periodic basis. In another embodiment the trigger module generates the message in response to end user input. The message can include instructions to generate a WINDOWS message that is forwarded to the application . Alternatively the message can be the WINDOWS message and represent an input event to the application . In one embodiment the message is transferred over a separate virtual channel within the ICA protocol stream and a WINDOWS message generated by the remote machine software when the message is received.

When the remote machine software receives the message the echo application processes the instructions of the message and generates the graphic response . In one embodiment the graphic response generates a change on the display of the client that is undetectable by the end user. In various embodiments the graphic response can include instructions to change a small number of pixels on the client display instructions to change single pixel at the origin i.e. top left corner of the client display instructions to cycle a pixel of the display through a range of values or instructions to cycle a change through a range of pixel locations of the display.

When the client software processes the graphic response the elapsed time between the transmission of the transmission of the message and the completion of the processing of the graphic response is determined. In one embodiment the client software determines the elapsed time and forwards the elapsed time to a management remote machine for storage and trending analysis. In another embodiment a start timestamp and an end timestamp are forwarded from the timer module the management remote machine . In such an embodiment the management remote machine determines the elapsed time. It should be understood that the elapsed time measurement is equivalent to the interaction experience as used herein.

The management remote machine can store multiple interaction experience measurements. The stored measurements can be used to isolate which portion of a client machine connection is not performing as expected. For example network timing measurement for the same time period can be compared to the interaction experience to isolate application virtual machine and execution machine load trends. Also the stored interaction experience measurements can be analyzed using known methods to determine an expected interaction experience value. The expected value can be compared to the measured value either by the calculation module of the client software or the management remote machine .

With reference to an embodiment of the operational method of the remote machine and remote machine software is described. After the client machine initiates step established a session with a remote machine the remote machine software initiates step the echo application . The remote machine receives step the message from the client machine . Once the message is received the confirmation module confirms step that the echo application is executing. From the message the operating system or the hypervisor generates step the input event that is processed by the echo application to generate step the graphic response .

The remote machine software initiation module initiates step the echo application when the client machine starts the session. In one embodiment a single echo application is initiated. In other embodiments an echo application is started for each of the applications programs executing on the remote machine . In such embodiments the interaction experience can be measured on an application by application basis. In other embodiments an echo application is started for each of the virtual machines executing on the remote machine . In these embodiments the interaction experience can be measured on a virtual machine basis. In another embodiment a single echo application is started for an execution machine executing multiple program application programs . For example a remote machine may communicate with multiple client machines . Each of the client machines connects to the remote machine through a different network path and thus has a different interaction experience. The echo application is not visible to the user. That is the user does not interact directly with the echo application and the echo application is not show on the display of the client. In one embodiment the echo application is a windowless application.

The transceiver module receives step the message from the client machine . In one embodiment the transceiver module includes a network interface card that communicates with the network . The transceiver module can format the received message so that the message is readable by the operating system .

Prior to generating the graphic response the confirmation module confirms step that the echo application is executing in user space assigned by the operating system. In some embodiments the user space is assigned by the native operating system that is the operating system of the execution machine. In other embodiments the user space is assigned by a virtualized operating system that is an operating system of a virtual machine provided by a hypervisor. In one embodiment the confirmation module communicates an indication that the echo application is executing to the operating system. In one embodiment the remote machine creates a log even on the remote machine to indicate that echo application was not running when the message was received or when the session was initiated.

Once confirmation of the execution of the echo application is received the operating system processes the message thereby generating step the input event . In one embodiment the input event is a WINDOWS message that is forwarded to the echo application to model a normal input event WINDOWS message. The input event is designed to cause the echo application to generate a graphic response . Exemplary input events can include but are not limited to mouse movements keyboard strokes window generation window destruction or any other event that generates a graphic response from the echo application . In another embodiment the input event is a custom user defined application specific WINDOWS message.

The echo application processes the input event and generates step the graphic response which is in turn forwarded to the client machine . In various embodiments the graphic response is generated once the echo application has performed a set of tasks such as calculations memory usage disk access and network resource access. The echo application can be configured by an administrator to perform specified tasks. In another embodiment the echo application can perform execution tasks that mirror an application program executing on the remote machine and generate the graphic response . I

In one embodiment the graphic response includes instructions that cause a change on the display of the client machine that is not detectable by the end user. For example the graphic response includes instructions to change a single pixel at the origin of the display. More complex graphic responses can be used to differentiate from graphic generated by the application programs or to detect any response indicators lost from graphic protocol optimizations. For example the pixel value can cycle through an expected range of values. In another embodiment the graphic response causes a pixel location to cycle through an expected range of pixel locations. Another example of a graphic response is a BitBlt with an unexpected Raster Operation either to the display or an off screen surface e.g. an off screen buffer .

In addition to measuring the overall end user interaction experience in various embodiments sub metrics that comprise the overall end user interaction experience metric can be measured and recorded. Generally these sub metrics include the time required by the client machine to generate and send the trigger message the network latency the time required by the remote machine to process the message and generate and transmit the graphic response and the time required by the client machine to process the graphic response .

With reference to and embodiments of a method of generating client machine sub metrics are described. From the perspective of the client machine there are two types of sub metrics that are generated a those related to generating and transmitting the trigger message as shown in and b those related to detecting and processing the graphic response as shown in .

With reference to one embodiment of a method for capturing sub metrics related to generating the trigger message is described. Assuming that the trigger message is generated in response to use of the input device the trigger module detects step use of the input event and marks step the time of detection. The trigger module generates step the message and marks step the time the message generating is completed. The trigger module forwards the message to the transceiver which then transmits step the message to the remote machine . The trigger module or the transceiver module marks step the time the message is transmitted to the remote machine .

With reference to one embodiment of a method for capturing sub metrics related to processing the response is described. The transceiver receives step the graphic response from the remote machine and marks step the time of receipt. The client software process step the graphic response . Upon completion of processing the graphic response the client software marks step the time of completion. Once complete the client software displays the graphic response and detects step that the graphic response is displayed. The client software also marks step the time of detection on the display.

The above described actions of marking certain times that indicate the occurrence of certain events can occur in different ways. In one embodiment multiple timers are started and stopped by the timer module upon the occurrence of each of the above described events. In another embodiment a single timer is used and the split times i.e. the time elapsed between the occurrence of the events are saved in a table that is accessible by the calculation module . In still another embodiment a time stamp is added to the message and the graphic response for each of the marking actions. In such an embodiment prior to transmitting the message the time stamps are reported to the calculation module where the elapsed time between each time stamp is determined. These elapsed times represent the above described different sub metrics. It should be understood that various combinations of the elapsed times can also be used. For example the time stamp related to the detection of the use of the input device and the time stamp that indicates the transmission of the message can be processed to determine the total elapsed used by the client machine to generate and send the message to the remote machine . The principles described above with respect to the generation of the message are equally applicable to the processing of the graphic response by the client machine .

With reference to one embodiment of a method for capturing sub metrics related to generating the graphic response is described. The transceiver receives step the message from the client machine and marks step the time of receipt. The operating system then generates step the input event . The remote machine software marks step the time of completion of the generation of the input event . The echo application receives step the input event and the remote machine software marks step the time of receipt of the input event . Once the echo application receives the input event the echo application generates step the graphic response . The remote machine software marks step the time the echo application completes generating the graphic response . In one embodiment the time required to generate the graphic response by the echo application includes the echo application performing additional executions tasks that similar to those performed by the application programs . The transceiver module receives the graphic response and transmits step the graphic response to the client machine . The remote machine software also marks steps the time the graphic response is sent.

Similar to the marking of events described with reference to the client machine the same methods can be employed with regard to the remote machine . In one embodiment multiple timers are started and stopped by the timer module upon the occurrence of each of the above described events. In another embodiment a single timer is used and the split times i.e. the time elapsed between the occurrence of the events are saved in a table that is accessible by the calculation module . In still another embodiment a time stamp is added to the graphic response for each of the marking actions. In such an embodiment upon receipt of the graphic response the time stamps are reported to the calculation module where the elapsed time between each time stamp is determined. These elapsed times represent the above described different sub metrics. It should be understood that various combinations of the elapsed times can also be used. For example the time stamp related to detecting receipt of the message and the time stamp that indicates the transmission of the graphic response can be processed to determine the total elapsed used by the remote machine to generate and send the graphic response to the client machine .

Referring now to another system for increasing the convenience and usability of the systems described above is shown. A client server computer system includes a first client machine a second client machine and a remote machine . The depiction of two client machines is for illustrative purposes only. The client server computer system can include any number of client machines.

In one embodiment the first client machine includes an input module a client process a network module and a display module . The input module provides an interface for a user of the first client machine to interact with the first client machine for example to request the remote execution of an application in an application session from the remote machine .

An application session is a process operating on the remote machine that provides access to or supports the execution of one or more resources such as application . An application can be a software program for example or any organized set of software code capable of being executed by a computer or hardwired into circuitry in the form of an Application Specific Integrated Circuit ASIC read only memory ROM microchip and the like. Example applications include but are not limited to Microsoft Word available from Microsoft Corporation Redmond Wash. Internet Explorer Microsoft Acrobat available from Adobe Systems Inc. San Jose Calif. etc. In one embodiment an application session includes a desktop application from which the execution of other application can be initiated. Application sessions can be nested within other application sessions . In another embodiment the application session includes an instance of the execution of a single application .

In one embodiment the input module is for example a graphical user interface that provides one or more icons or menu selections for a user to select. Each icon or menu selection represents a specific application available for remote execution. Selecting an icon or menu selection initiates the transmittal of a log on request to the remote machine for access to that application . In another embodiment an icon or menu selection does not represent any specific application but instead represents a general remote machine log on procedure. In another embodiment the input module is non graphical user interface. In this embodiment the user can enter a command to send a log on request to remote machine . Entering a command can include typing a predefined set of characters or depressing a specified key sequence on an input device e.g. a keyboard or keypad . The log on request at least includes user provided authentication information. The input module accepts the input of the user provided authentication information which can include any type of authentication information including without limitation any of user name password PIN combinations voice samples one time passcodes biometric data digital certificates smart card data etc. In some embodiments the input module is in communication with additional hardware peripherals not shown to facilitate acceptance of user authentication information. In other embodiments the input module can accept authentication information outside of the log on process.

The input module accepts authentication information and provides it to the client process . The client process then manages the client side functionality of the remotely executing application session. The client process forwards user input including the authentication information and requests for termination or disconnection of application sessions to the remote machine . The client process also handles data incoming from the remote machine for example by forwarding the graphical output of an application session to the display module .

The network module provides for communication between the first client machine and the remote machine . The network module sends user input such as authentication information and requests for access to disconnection from or termination of application sessions executing on the remote machine . The network module also receives output from the application sessions and forwards the output to the client process . In one embodiment the network module encapsulates user input into and reconstitutes application session output from a predetermined protocol for transmission to the remote machine . In another embodiment the network module encrypts outgoing transmissions and decrypts incoming transmissions.

The display module displays the output of an application from a remotely executing application session . The network module provides communication functionality for the remote machine . For example the network module receives communications from first and second client machines over one or more data networks or links . The network module also transmits resource output data to the first and second client machines . In one embodiment the network module encrypts outgoing communications and decrypts incoming communications. Likewise in one embodiment the network module encapsulates outgoing communications in a protocol for transmission and retrieves incoming data from transmissions received according to a protocol. Protocols can include for example and without limitation HTTP Independent Computing Architecture ICA protocol used by Citrix Systems Inc. Ft. Lauderdale Fla. Remote Desktop Protocol RDP Microsoft Corporation or Common Gateway Protocol CGP Citrix . The network module of the remote machine communicates with the network module of the first client machine over a network . The network can be implemented with any of a variety of suitable technologies. Incoming communications once decrypted or retrieved from a protocol if necessary are forwarded to an application session or to the server process as appropriate.

The server process manages the execution suspension to disk resumption of execution suspension without writing state to disk and termination of application sessions and the connections and disconnections of those application sessions to the first and second client machines . The server process can initiate new application sessions disconnect a client machine from an application session detect a client machine disconnection from an application session locate an application session from which a user has disconnected locate an application to which a user of the first client machine is connected to from the second client machine and connect a user to a disconnected application session . In some embodiments the application sessions are provided so as to be configured with the user s personal preferences and access allowances.

The server process may execute in the hypervisor a virtual machine provided by the hypervisor a guest operating system executing in a virtual machine an operating system provided by the physical machine or in combinations of those entities.

The application output transmitter transmits output from an application session to a client machine through the network module . The application output transmitter intercepts the output of an application session and determines which client machine is connected to the application session . In other embodiments the identity of the client machine that is connected to the application session is stored at the time the connection is made. If the application session is connected to a client station the application output transmitter transmits the application output data to the connected client machine via the network module . In one embodiment if the application session is not connected to a client machine the application output transmitter discards the application output data and waits to receive future application output data. In another embodiment if the application session is not connected to a client machine the application output transmitter disregards all further application output data until the application output transmitter receives notification that the application session has connected to a client machine . In another embodiment the application output transmitter stores the data until the application output transmitter receives notification that the application session has connected to a client machine . In another embodiment the application output transmitter attempts to send application output data to a client machine until the server process notifies the application output transmitter that the client machine is disconnected from the remote machine . In one embodiment the application output transmitter determines which client machine if any the application session is connected to by consulting the data store .

The data store includes information related to application sessions initiated by users. The data store can be stored in volatile or non volatile memory or for example distributed through multiple servers. In some embodiments the functionality of a data store is provided by a session server as described in connection with .

In one embodiment remote machine also includes a rules source . The rules source stores rules governing the reaction of the server process to a user transmitting authentication information to the remote machine . In one embodiment the rules stored in the rules source are specified at least in part by the system administrator. In another embodiment a user specifies at least some of the rules stored in the rules source . The user specified rule s are stored as preferences. The rules source can be stored in volatile or non volatile memory or for example distributed through multiple servers.

One rule stored in the rule source for example might require or forbid automatic connection to disconnected application sessions . Another rule might require or forbid automatic connection to active application sessions currently connected to a different client machine . Yet another rule might make connection and or connection contingent on the client machine that requests access being within a secure network. A further rule might only allow connection to application sessions after receiving user approval. Another rule might only allow connection for a predetermined time after disconnection. Still another rule only allows connection to application sessions that include specific application .

The authentication module is responsible for authenticating a user that attempts to log on to the remote machine . The authentication module receives user provided authentication information transmitted from the first client machine . The authentication module then authenticates the user based on the user provided authentication information. In response to a successful authentication the authentication module transmits the results of the authentication process e.g. allow or deny access the user s system ID client computer ID user access permissions etc. to the server process .

In one embodiment the above described modules and processes of the remote machine i.e. the network module the server process the application output transmitter and the authentication module and a client machine i.e. the input module the client process the network module and the display module are all implemented in software executable on one of several computer operating systems including without limitation the Windows family of operating systems Microsoft Corporation the MacOS family of operating systems Apple Computer Inc. Cupertino Calif. and Unix based operating systems e.g. Solaris Sun Microsystems Sunnyvale Calif. . In other embodiments one or more modules or processes are implemented in hardware as application specific integrated circuits ASICs Read Only Memory ROM devices or other digital hardware circuitry.

Unintentional termination of application sessions resulting from imperfect network connections and users failure to terminate their application sessions themselves can lead to user difficulties. One embodiment of the invention limits these difficulties by differentiating disconnection which is treated as if the user is not done working with an application session from termination which is assumed to be an intentional end to the application session and by correlating application sessions with users as opposed to client machines. When a user is finished using an application operating in an application session the user can terminate an application session . Termination generally involves the affirmative input of the user indicating that the server should no longer maintain the application session . Such affirmative user input can include selecting an Exit option from a menu clicking on an icon etc. In response to the server process receiving a termination request the execution of the application session and any application within that application session is halted. In one embodiment data related to the application session is also removed from the data store .

Disconnection either intentional or unintentional on the other hand does not result in termination of application sessions . Since the application or applications operating in an application session are executing on the remote machine a connection to the first client machine is not usually necessary to continue execution of the application and in one embodiment the application can continue to execute while waiting for the user to connect. In an alternative embodiment upon disconnection of a user the server process stalls the execution of the application operating in the application session . That is the server process halts further execution of the application and the server process stores the operational state of the application and any data the application is processing. In a further embodiment the server process can selectively stall execution of specific application after a user disconnects. For example in one embodiment the server continues execution of an application for a fixed time period and if a user fails to connect within that time period the server process stalls the application . In another embodiment the server stalls specified application sessions that cannot continue executing without user input. In each of the above described embodiments if the user of the first client machine disconnects from the remote machine and then connects to the remote machine while operating the first client machine the second client machine or a third client computer the server process can connect the client computer operated by the user to one or more previously initiated non terminated application session s associated with the user and reinitiate execution of any stalled application .

In one embodiment the server process detects a disconnection. A user can intentionally and manually instruct the server to disconnect an application session from the client machine that the user is communicating from. For example in one embodiment application sessions provide a menu option for disconnection as distinguished from termination above that a user can select. The server process can also detect an unintentional disconnection. For example in one embodiment the network module of the remote machine informs the server process when a predetermined number of data packets transmitted by the network module to a client machine have not been acknowledged by the client machine . In another embodiment the client machine periodically transmits a signal to the remote machine to confirm that a connection is still intact. If the server process detects that a predetermined number of expected confirmation signals from a client machine have not arrived the server process determines that the client machine has disconnected. If the server process detects that a user has disconnected from an application session either intentionally or unintentionally the entry in the data store related to the disconnected application session is modified to reflect the disconnection.

Referring also to a method of providing remote access to an application session in one embodiment begins with the network module of the remote machine receiving authentication information associated with a user step . Authentication information can include a number of types of authentication information including without limitation user names client names client addresses passwords PINs voice samples one time passcodes biometric data digital certificates tickets etc. and combinations thereof. The authentication information could be in the form of a log on request from a user. As described above a log on request can be initiated by a user through the input module of a client machine . The client s network module forwards the request to the server process .

In one embodiment upon receiving the request the server process forwards the user provided authentication information to the authentication module which authenticates the identity of the user. The server s authentication module can perform the authentication itself and or in cooperation with one or other modules or computers such as a domain server an authentication service etc. Successful authentication results in the authentication module transmitting identification information for the user e.g. a username or ID to the server process .

In response to receiving authentication information associated with the user the server process identifies any disconnected application sessions associated with the user that are executing stalled on the remote machine or suspended to disk step . In one embodiment the server process identifies the application sessions upon receiving the authentication information. In another embodiment the server process identifies the applications in response to receiving the authentication information after the authentication module verifies of the user s identity. In one embodiment server process determines whether any such disconnected application sessions exist by consulting the data store for sessions which is some embodiments is a persistent data store related to the user. For example the disconnected application session could have been disconnected by direction of the user of the application session resulting in the server process disconnecting the application session for example by modifying the status of application session in the data store to disconnected and deleting the identification of the connected client machine in the data store entry for the application session . In another embodiment the disconnection was unintentional. Unintentional disconnection results in the server process making the same modifications to the data store as would be made as a result of an intentional disconnection.

Upon identifying any disconnected application sessions step in one embodiment the server process prompts the user to indicate whether connection is desired. If connection is not desired the server process prompts the user to indicate whether the disconnected applications sessions should remain disconnected or whether the application sessions should be suspended to disk paused or terminated. In an alternative embodiment the server process consults a rule stored in the rules source to determine whether connection and or connection is permitted and or required.

In an alternative embodiment the user connects to the remote machine the server process and any disconnected application sessions by utilizing a single user interface element for example clicking an icon labeled Log on. In this embodiment activating the single user interface will automatically connect the user to any disconnected applications sessions .

In one embodiment the client can be configured to automatically send authentication information upon such user connection. If connection is permitted and is either assented to by user or is automatic the server process connects the user to the disconnected application sessions step . In one embodiment connection includes modifying the entry in the data store to indicate that the user is connected to the application session and to indicate from which client machine the user is connected to the server. Upon connection the remote machine resumes transmitting application output data from the application output transmitter to the client step . In another embodiment the application output transmitter consults the rules source before beginning transmitting application output to ensure such transmission is permitted.

Application sessions are associated primarily with users instead of the client machine which the user was operating when the user previously had connected to and then been disconnected from the server. As a result rules permitting the user can reconnect to an application session from the first client machine the second client machine or any other client computer. In other embodiments the user of the client machine may be given further options such as reconnect to all sessions not executing on a virtual machine suspend all sessions executing on a virtual machine reconnect all sessions currently hosted or reconnect to all session not suspended for example.

Referring to even if a session is not disconnected i.e. is active it can be useful to transfer the session from one client to another. For example it may be that an application session was disconnected but the server did not yet detect the disconnection. It may be that the user deliberately left a session running but would now like to access the session from another location.

A method for transferring active application sessions from a first client machine to a second client machine typically begins with the network module receiving authentication information from a user for example in the form of a log on request. In one embodiment the user submits the authentication information via the input module . The authentication information can be transmitted by the network module of second client machine to the remote machine . The network module of the remote machine can forward the request to the server process .

The server process receives the user provided authentication information step . In one embodiment the server process forwards the user provided authentication information to an authentication module which authenticates the identity of the user using for example any of the variety of authentication techniques described above. Successful authentication results in the authentication module transmitting for example identification information for the user to the server process .

After receiving authentication information step the server process consults the data store to identify any active application sessions that are associated with the user but that are connected to a different client computer such as the first client machine as an illustrative example step . In one embodiment if the server process identifies any such active application sessions the server process automatically disconnects the application session s from the first client machine step and connects the application session s to the current client machine step . In one embodiment the user can trigger the automatic consultation of the data store and subsequent connection with the selection of a single user interface element.

In an alternative embodiment the server process prompts the user as to whether the user wants to have the active application session s connected to the current client machine . If the user declines to transfer one or more of the active application session s the server process prompts the user to either keep the application session s active suspend the application session to disk pause the application session or to terminate the application session s . In an alternative embodiment the server process consults a rule stored in the rules source to determine whether transfer of the active application session s are permitted before transferring the active application session s .

If transfer of the application session s are permitted and transfer is automatic or requested by the user in one embodiment the server process carries out the disconnection step and connection step by modifying the entry maintained in the data store for the application session to substitute the identity of the stored client machine with the identity of the current client computer i.e. the client machine . Upon connection with the current client machine the application output transmitter begins transmitting application output to the current computer step . In another embodiment the application output transmitter consults the rules source before beginning transmitting application output to ensure such transmission is permitted.

It should be understood that the methods of and can be combined to allow a client to be connected to disconnected suspended paused and active sessions associated with a user. In addition prior to transfer or reconnection the active and or disconnected sessions could have been connected to the same or several different client machines.

Referring to as mentioned above the remote machine can be implemented as a machine farm . In one embodiment the machine farm includes several remote machines and which are linked together and which are jointly administered. Several client machines and typically many computers can connect to the machine farm over a network . The servers and share the computational load put on the machine farm . For example if a user is accessing three application sessions and each application session can be executing on a different server or . Similarly if the user is accessing two or more application through a single application session or the server process of the machine farm can assign one application to execute on one server and another application to execute on server . In a machine farm configuration the modules of the server and the data store and the rules source can be stored on a single server or or can be distributed among the servers and .

With respect to connecting to the machine farm after a disconnection or after changing client machines and without disconnecting the server process treats the servers and as a single server. That is if a machine farm is executing a user s application sessions and on separate servers and and the user disconnects from the machine farm or changes the client computer or at which the user is working upon subsequently connecting to the machine farm the server process of the machine farm can automatically connect the user s client computer or with all three application sessions and executing on all three severs and .

In one embodiment of the system a user of a first client computer which in this example is a mobile handheld computer logs on to the machine farm via a wireless modem and requests two application sessions and . The server process of the machine farm launches a first application session on a first server and a second application session on a second server . The wireless modem loses its connection with the machine farm when the user of the first computer enters an elevator. The server process of the machine farm determines that the user is disconnected and the server process updates the data store accordingly.

The user then logs on to the machine farm from a second client computer which in this example is a desktop computer in his office. The server process consults the data store and determines that two disconnected application sessions and are associated with the user. The server process assuming no rules to the contrary automatically connects the second client computer to both application sessions and executing on servers and respectively.

The user then leaves the second client computer without disconnecting from the machine farm and logs on to the machine farm from a third client computer for example a colleague s laptop. Upon logging on from the third client computer the server process consults the data store and determines that the user is associated with the two active application sessions and connected to the second client computer . The server process assuming no rules to the contrary then automatically disconnects both of the application sessions and from the second client computer and connects both of the application sessions and to the third client computer .

The user next selects a disconnect option for each application session and . The server process updates the data store to indicate that the application sessions and have been disconnected. The user then logs on to the machine farm from the second client computer . The server process consults the data store and determines that two disconnected application sessions and are associated with the user. The server process assuming no rules to the contrary automatically connects the disconnected application sessions and to the second client computer .

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for providing remote access to a computing environment provided by a virtualized operating system. In brief overview authentication information associated with a user of a client machine is received step . Based on the received authentication information a computing environment provided by a virtualized operating system and already associated with the user is identified step . A connection is established between the client machine and the identified computing environment step .

In some embodiments the methods and systems described above in connection with may be implemented in systems including virtual machines. In some embodiments the client machine has established a connection to a physical machine providing access to a resource requested by the client machine . In this embodiment the client machine may be connected to a disconnected application session and receive application output as described above in connection with .

In other embodiments the client machine has established a connection to a virtual machine providing access to a resource. In one of these embodiments the client machine may be reconnected to an application session executing on the virtual machine. In another of these embodiments the client machine may be reconnected to a plurality of application sessions executing within a computing environment provided by a virtual machine. In still another of these embodiments the client machine may be reconnected to an application session comprising a plurality of application programs executing within a computing environment provided by a virtual machine. In yet another of these embodiments the client machine may be reconnected to an application session comprising a plurality of computing environments provided by a virtual machine.

Referring still to and in greater detail authentication information associated with a user of a client machine is received step . In one embodiment responsive to the received authentication information a collection agent gathers information about the client machine . In some embodiments the user of the client machine is authenticated responsive to the received authentication information.

Based on the received authentication information a computing environment provided by a virtualized operating system and already associated with the user is identified step . In some embodiments the authentication information includes an access control decision generated as described above in connection with . As described above a client machine requests access to a resource a collection agent gathers information about the client machine and a policy engine makes an access control decision. In one of these embodiments the identification of the computing environment already associated with the user is made in response to the received authentication information. In another of these embodiments a connection is established between the client machine and the identified computing environment. In still another of these embodiments a remote machine acting as an intermediary server receives the authentication information including the access control decision and establishes a connection between the client machine and a remote machine acting as an execution machine providing the user of the client machine with access to the requested resource.

In one embodiment based on the received authentication information and gathered client machine information a computing environment provided by a virtualized operating system and already associated with the user is identified. In another embodiment stored data associated with at least one computing environment is consulted to identify based on the received authentication information a computing environment provided by a virtualized operating system and already associated with the user. In still another embodiment based on the received authentication information an identification is made of a first computing environment provided by a first virtualized operating system and a second computing environment provided by a second virtualized operating system the first and second computing environments already associated with the user. In yet another embodiment based on the received authentication information an identification is made of a first computing environment provided by a first virtualized operating system executing on a first server and a second computing environment provided by a second virtualized operating system executing on a second server the first and second computing environments already associated with the user

A connection is established between the client machine and the identified computing environment step . In one embodiment the connection is established between the client machine and the identified computing environment subject to a rule. In another embodiment a connection is established between the client machine and the identified computing environment subject to a policy applied to the received authentication information and gathered client machine information.

In some embodiments a request is received to disconnect the client machine from the identified computing environment. In one of these embodiments the connection between the client machine and the identified computing environment is terminated. In another of these embodiments a data record associated with the identified computing environment is updated to indicate that the client machine is disconnected. In still another of these embodiments an execution of the identified computing environment is continued. The execution may continue although the client is disconnected from the identified computing environment.

In some embodiments authentication information associated with the user is received. In one of these embodiments the user uses a second client machine . In another of these embodiments an identification is made based on the received authentication information of a computing environment provided by a virtualized operating system and already associated with the user. In still another of these embodiments a connection is established between the second client machine and the identified computing environment. In yet another of these embodiments the connection between the first client machine and the identified computing environment is terminated.

Referring now to a flow diagram depicts an embodiment of the steps taken in a method for providing remote access to a plurality of application sessions. In brief overview a selection of a single user interface element by a user of a client machine is received at the client machine step . In response to the user interface element selection authentication information associated with the user is transmitted step . Based on the transmitted authentication information a computing environment provided by a virtualized operating system and already associated with the user is identified step . A connection is established between the client machine and the identified computing environment step .

A selection of a single user interface element by a user of a client machine is received at the client machine step . In response to the user interface element selection authentication information associated with the user is transmitted step . In one embodiment a collection agent gathers information about the client machine in response to the received information. In another embodiment a policy engine makes an access control decision responsive to the gathered information as described above in connection with and . In some embodiments based on the received authentication information and on gathered client machine information an identification is made of a computing environment provided by a virtualized operating system and already associated with the user. In other embodiments the user is authenticated responsive to the received authentication information.

Based on the transmitted authentication information a computing environment provided by a virtualized operating system and already associated with the user is identified step . In one embodiment a connection is established between the client machine and the identified computing environment subject to a rule applied to the received authentication information and to gathered client machine information. In another embodiment based on the received identification an identification is made of a first computing environment provided by a first virtualized operating system and a second computing environment provided by a second virtualized operating system the first and second computing environments already associated with the user. In still another embodiment based on the received authentication information an identification is made of a first computing environment provided by a first virtualized operating system executing on a first server and a second computing environment provided by a second virtualized operating system executing on a second server the first and second computing environments already associated with the user. In some embodiments stored data associated with at least one computing environment is consulted to identify based on the received authentication information a computing environment provided by a virtualized operating system and already associated with the user.

A connection is established between the client machine and the identified computing environment step . In one embodiment the connection between the client machine and the identified computing environment is made subject to a rule. In some embodiments authentication information associated with the client machine is received including an access control decision generated as described above in connection with . In one of these embodiments the identification of the computing environment already associated with the user is made in response to the received authentication information. In another of these embodiments a remote machine acting as an intermediary broker server receives the authentication information including the access control decision and establishes a connection between the client machine and a remote machine acting as an execution machine providing the user of the client machine with access to the requested resource.

In some embodiments a request is received to disconnect the client machine from the identified computing environment. In one of these embodiments the connection between the client machine and the identified computing environment is terminated. In another of these embodiments a data record associated with the identified computing environment is updated to indicate that the client machine is disconnected. In still another of these embodiments execution of the identified computing environment is continued. The execution may continue although the user has terminated the connection between the client machine and the identified computing environment.

In some embodiments authentication information associated with the user is received the user using a second client machine . In one of these embodiments based on the received authentication information an identification is made of a computing environment provided by a virtualized operating system and already associated with the user. In another of these embodiments a connection is established between the second client machine and the identified computing environment. In yet another of these embodiments a connection between the first client machine and the identified computing environment is terminated.

Referring now to a block diagram depicts one embodiment of a server for providing remote access to a computing environment. In brief overview a remote machine is a server and includes a network module a data store and a broker process . In some embodiments the remote machine the components modules and subsystems described above in connection with .

The network module receives authentication information associated with a user operating a client machine such as client machine . In some embodiments the network module is in communication with an authentication module for authenticating the user in response to the received authentication information. In other embodiments the network module includes the authentication module.

The data store contains an identifier of a computing environment associated with the user. In one embodiment the data store contains a first identifier of a first computing environment associated with the user and a second identifier of a second computing environment associated with the user. In another embodiment the first computing environment executes on a first remote machine and the second computing environment executes on a second remote machine . In some of these embodiments the broker process transmits the enumeration from the data store to the client machine .

The broker process connects the client machine to the identified computing environment enumerated in the data store in response to the received information. In one embodiment the broker process connects the client machine to the identified computing environment subject to a rule. In another embodiment the broker process disconnects the client machine from the identified computing environment in response to a received disconnect signal. In still another embodiment the broker process updates a data record associated with the identified computing environment to indicate the client machine is disconnected from the identified computing environment.

In some embodiments the remote machine includes a collection agent and a policy engine. In one of these embodiments the collection agent gathers information about the client machine . In another of these embodiments the collection agent comprises at least one script. In still another of these embodiments the collection agent comprises bytecode. In yet another of these embodiments the collection agent gathers the information by running at least one script on the client machine . In some of these embodiments the collection agent executes on the client machine . In others of these embodiments the collection agent is transmitted to the client machine . In one of these embodiments the policy engine transmits the collection agent to the client machine .

In some of these embodiments the remote machine includes a policy engine receiving the gathered information and assigning one of a plurality of levels of access responsive to application of a policy to the received information the broker process connecting the client machine to the identified computing environment enumerated in the data store responsive to the assigned access level. In one embodiment the policy engine further comprises a database storing configurable policies. In another embodiment the policy engine transmits instructions to the collection agent determining the type of information the collection agent gathers.

In others of these embodiments the policy engine further comprises a logon agent. In one of these embodiments the logon agent receives the gathered information from the collection agent. In another of these embodiments the logon agent identifies for the policy engine authentication information received from the collection agent. In still another of these embodiments the policy engine further comprises a plurality of logon agents. In yet another of these embodiments at least one of the plurality of logon agents resides on each network domain from which a client machine may transmit a resource request. In some embodiments the client machine transmits the resource request to a particular logon agent. In other embodiments the logon agent identifies for the policy engine the network domain from which the client machine transmits the resource request.

In some embodiments a virtual machine farm provides functionality for relocating a session from one requesting machine to a second requesting machine. In one of these embodiments the virtual machine farm provides access to information required for relocating a session. In another of these embodiments a hypervisor provides functionality for relocating a virtual machine session. In some embodiments the hypervisor implements well known techniques including pre copying post copying and lazy copying for moving session information associated with a virtual machine session from one execution machine to a second execution machine.

In some embodiments the virtual machine farm is in communication with a system as described in and and provides functionality for relocation of an application session within a virtual machine session.

Referring to one embodiment of a network constructed in accordance with the invention is depicted which includes a client machine a collection agent a policy engine a policy database a condition database a client machine a session server a stored application database a remote machine a first database a remote machine and a second database . In brief overview when the client machine transmits to the policy engine a request for access to an application program the collection agent communicates with client machine retrieves information about client machine and transmits client machine information to the policy engine . The policy engine makes an access control decision as discussed above in and . The client machine receives an enumeration of available applications associated with the client machine .

In some embodiments the session server establishes a connection between the client machine and a plurality of application sessions associated with the client machine . In one of these embodiments the connection is established to a virtual machine providing access to a computing environment in which the application sessions execute. In other embodiments the policy engine determines that the client machine has authorization to retrieve a plurality of application files comprising the application and to execute the application program locally. In one of these embodiments the remote machine stores application session data and a plurality of application files comprising the application program. In another of these embodiments the client machine establishes an application streaming session with a remote machine storing the application session data and the plurality of application files comprising the application program.

Referring now to a flow diagram depicts one embodiment of the steps taken by the session server to provide access for the client machine to its associated application sessions. The session server receives information about the client machine from the policy engine containing the access control decision the policy engine made step . In one embodiment the information also includes the client machine information . In another embodiment the information includes authorization to execute the application program locally. In still another embodiment the information includes authorization to provide access to computing environment in which the application program executes.

In some embodiments the policy engine identifies a plurality of application sessions already associated with the client machine . In other embodiments the session server identifies stored application sessions associated with the client machine step . In some of these embodiments the session server automatically identifies the stored application sessions upon receiving the information from the policy engine . In one embodiment the stored application database resides on the session server . In another embodiment the stored application database resides on the policy engine .

The stored application database contains data associated with a plurality of machines in the machine farm executing application sessions or providing access to application session data and application files comprising application programs or providing access to computing environments in which application sessions may execute including virtual machines which may be active suspended paused or disconnected. In some embodiments identifying the application sessions associated with the client machine requires consulting stored data associated with one or more machines . In some of these embodiments the session server consults the stored data associated with one or more machines . In others of these embodiments the policy engine consults the stored data associated with one or more machines . In some embodiments a first application session runs on a remote machine and a second application session runs on a remote machine . In other embodiments all application sessions run on a single remote machine within the machine farm . In still other embodiments one or more application sessions run on a remote machine executing a virtual machine providing access to a computing environment in which the application sessions execute.

The session server includes information related to application sessions initiated by users. The session server can be stored in volatile or non volatile memory or for example distributed through multiple servers. Table 4 shows the data included in a portion of an illustrative session server 

The session server in Table 4 includes data associating each application session with the user that initiated the application session an identification of the client machine if any from which the user is currently connected to the remote machine and the IP address of that client computer . The session server also includes the status of each application session. The data may include an identification of a virtual machine providing a computing environment in which the application session executes. An application session status can be for example active meaning a user is connected to the application session or disconnected meaning a user is not connected to the application session . In an alternative embodiment an application session status can also be set to executing disconnected meaning the user has disconnected from the application session but the applications in the application session are still executing or stalled disconnected meaning the user is disconnected and the applications in the application session are not executing but their operational state immediately prior to the disconnection has been stored . The session server further stores information indicating the application that are executing within each application session and data indicating each application s process on the server. For embodiments in which the session is hypervisor based the session server may store an identification of a hypervisor domain or a virtual machine instance identifier. In embodiments in which the remote machine is part of the machine farm the session server is at least a part of the dynamic store in addition to the data in the last three rows of Table 4 that identify a remote machine in the machine farm on which each application is was executing and the IP address of that remote machine . In alternative embodiments the session server includes a status indicator for each application in each application session.

For example in the example of Table 4 three application sessions exist App Session 1 App Session 2 and App Session 3. App Session 1 is associated with User 1 who is currently using terminal 1. Terminal one s IP address is 172.16.2.50. The status of App Session 1 is active and in App Session 1 a word processing program is being executed. The word processing program is executing on Server A as process number 1. Server A s IP address is 172.16.2.55. App Session 2 in Table 1 is an example of a disconnected application session . App Session 2 is associated with User 2 but App Session 2 is not connected to a client machine or . App Session 2 includes a database program that is executing on Server A at IP address 152.16.2.55 as process number 3. App Session 3 is an example of how a user can interact with application sessions operating on different remote machines . App Session 3 is associated with User 1 as is App Session 1. App Session 3 includes a spreadsheet program that is executing on Server B at IP address 152.16.2.56 as process number 2 whereas the application session included in App Session 1 is executing on Server A. Although only one App Session 1 is described in the application session the application session may comprise a plurality of executing resources including application sessions executing in computing environments and computing environments executing in a virtual machine.

In another example a user may access a first application program through an application session executing on a remote machine such as Server A while communicating across an application streaming session with a second remote machine such as Server B to retrieve a second application program from the second remote machine for local execution. The user of the client machine may have acquired authorization to execute the second application program locally while failing to satisfy the local execution pre requisites of the first application program.

In one embodiment the session server is configured to receive a disconnect request to disconnect the application sessions associated with the client machine and disconnects the application sessions in response to the request. The session server continues to execute an application session after disconnecting the client machine from the application session. In this embodiment the session server accesses the stored application database and updates a data record associated with each disconnected application session so that the record indicates that the application session associated with the client machine is disconnected.

After receiving authentication information associated with a client machine connecting to the network the session server consults the stored applications database to identify any active application sessions that are associated with a user of the client machine but that are connected to a different client machine such as the client machine if the authentication information is associated with client machine for example. In one embodiment if the session server identifies any such active application sessions the session server automatically disconnects the application session s from the client machine and connects the application session s to the current client machine step . In some embodiments the received authentication information will restrict the application sessions to which the client machine may reconnect. In other embodiments the received authentication information authorizes execution of an application program on the client machine where the authorization may have been denied to client machine . In one of these embodiments the session server may provide the client machine access information for retrieving the application program for second execution. In still other embodiments the received authentication information authorizes execution of an application program in a computing environment provided by a virtual machine.

Referring now to a block diagram depicts one particular embodiment of a system for providing by a virtual machine access to a computing environment. A client agent on a client machine connects to a remote machine . In some embodiments the client agent establishes a connection with a session management component . In other embodiments the session management component is executed by the remote machine to which the client machine connects. In one embodiment the session management component queries a virtual machine management component for the location of the configuration and virtual disk files of a virtual machine to run for the current user and a hypervisor in which the virtual machine may execute. In some embodiments the identified hypervisor and virtual machine execute on remote machine . In other embodiments the identified hypervisor and virtual machine execute on a remote machine . In one embodiment the session management component launches the virtual machine within the specified hypervisor in full screen mode. In another embodiment a previously executing virtual machine is allocated to the client machine .

In some embodiments a virtual machine service component executes within a computing environment provided by a virtual machine on a remote machine . In one of these embodiments the virtual machine service component receives an IP address and a port with which to establish a communication channel between the session management component and the virtual machine service component . In one embodiment this communication channel is used to pass session related configuration information from the client agent session into the virtual machine session. In some embodiments the configuration information includes display settings and changes client drive information and authentication data with which to enable single sign on for a user of the client machine .

In some embodiments once the communications channel is established and the initial session related information is passed to the virtual machine service component the virtual machine service component automatically connects the user to a computing environment such as a guest operating system using the same credentials as were provided to the client agent by the user if any . In one of these embodiments the virtual machine service component automatically reconfigures the display settings of the guest operating system to match those of the client . The virtual machine produces graphics and sound output to virtual devices that redirect that output directly or indirectly to the client agent on the client machine . The virtual machine receives audio input mouse and keyboard device data redirected from the client machine . When the virtual machine is shutdown or suspended the session management component terminates the client agent session.

Referring now to a block diagram depicts one embodiment of a system for providing to a first client agent via a second client agent on a first remote machine output data generated by a resource executing in a virtual machine provided by a second remote machine. A client agent on a client machine connects to a remote machine and requests access to a resource. In one embodiment the remote machine is an intermediate machine. In another embodiment the remote machine determines to provide access to the requested resource via a virtual machine. In still another embodiment the remote machine identifies a remote machine to provide access to the requested resource via a virtual machine executing on the remote machine . The remote machine may be referred to as an execution machine .

In one embodiment the client machine communicates with the remote machine using a presentation layer protocol such as ICA RDP VNC or X11. In some embodiments protocol stacks are implemented to enable communications between the client machine and remote machines as described above in connection with step and with .

In one embodiment an agent on the remote machine establishes a connection to the remote machine . In another embodiment the remote machine communicates with the remote machine using a presentation layer protocol such as ICA RDP VNC or X11. In still another embodiment the remote machine establishes a connection with the remote machine and communicates with the remote machine using a presentation layer protocol such as RDP from within a terminal services session executing on the remote machine . In some embodiments protocol stacks are implemented to enable communications between the agent on the remote machine and the remote machine as described above in connection with step and with .

In one embodiment as depicted by the remote machine provides access to the requested resource by providing access to a virtualized environment or by providing access to an application streaming service as described above in connection with . In another embodiment the remote machine executes the resource in a virtual machine executing on the remote machine . In still another embodiment the remote machine transmits output data generated by the execution of the resource to the remote machine using a presentation layer protocol. In another embodiment the remote machine forwards the output data received from the remote machine to the client machine using a presentation layer protocol. In some embodiments the virtual machine executes on the remote machine . In other embodiments the virtual machines execute on a remote machine .

In one embodiment the remote machine provides access to a published desktop computing environment. In another embodiment the remote machine provides access to a published desktop computing environment selected from an enumeration of a plurality of published desktop computing environments available to the client machine . In some embodiments as described above in connection with the description of the virtual machine management component virtual machines may provide access to standard operating environments.

Referring now to a block diagram depicts an embodiment of a system for providing to a first client agent via a second client agent on a first remote machine output data generated by a resource executing in a virtual machine provided by a second remote machine. A client agent on a client machine connects to a remote machine and requests access to a resource. In one embodiment the remote machine is an intermediate machine. In another embodiment the remote machine determines to provide access to the requested resource via a virtual machine. In still another embodiment the remote machine identifies a remote machine to provide access to the requested resource via a virtual machine executing on the remote machine . The remote machine may be referred to as an execution machine .

In one embodiment the client machine communicates with the remote machine using a presentation layer protocol such as ICA RDP VNC or X11. In some embodiments protocol stacks are implemented to enable communications between the client machine and remote machines as described above in connection with step and with .

In one embodiment an agent on the remote machine establishes a connection to the remote machine . In another embodiment the remote machine communicates with the remote machine using a presentation layer protocol such as ICA RDP VNC or X11. In still another embodiment the remote machine establishes a connection with the remote machine and communicates with the remote machine using a presentation layer protocol such as ICA. In some embodiments protocol stacks are implemented to enable communications between the agent on the remote machine and the remote machine as described above in connection with step and with .

In one embodiment as depicted by the remote machine provides access to the requested resource by providing access to a virtualized environment or by providing access to an application streaming service as described above in connection with . In another embodiment the remote machine executes the resource in a virtual machine executing on the remote machine . In still another embodiment the remote machine transmits output data generated by the execution of the resource to the remote machine using a presentation layer protocol. In another embodiment the remote machine forwards the output data received from the remote machine to the client machine using a presentation layer protocol. In some embodiments the virtual machine executes on the remote machine . In other embodiments the virtual machines execute on a remote machine .

Referring now to a block diagram depicts one embodiment of a system for identifying by a coordinator machine a worker machine providing via a virtual machine access to a computing environment. A client agent on a client machine connects to a remote machine and requests access to a resource. In one embodiment the remote machine is a coordinator machine providing the functionality of an intermediate broker machine. In another embodiment the remote machine identifies a remote machine to provide access to the requested resource.

In some embodiments the remote machine is a remote machine in a plurality of remote machines functioning as intermediate broker machines. In one of these embodiments the coordinator machines receive requests and identify other remote machines from a second plurality of remote machines the identified machines responding to the requests. In another of these embodiments the identified remote machines are referred to as worker machines. In still another of these embodiments the client machine communicates with the coordinator machine using a presentation layer protocol such as ICA RDP VNC or X11.

In one embodiment the coordinator machine identifies a pool of worker machines each capable of providing access to the requested resource. In some embodiments the coordinator machine identifies a worker machine from the pool of worker machines capable of providing access to the requested resource. In other embodiments the coordinator machine identifies a worker machine and transmits information for accessing the worker machine to the client machine . In still other embodiments the coordinator machine transmits information for accessing the client machine to the worker machine . In one of these embodiments the coordinator machine provides no additional information or communication to the client machine after transmitting the access information associated with the worker machine . In yet other embodiments the coordinator machine establishes a connection between the client machine and a worker machine .

In one embodiment the client agent of the client machine establishes a connection to the worker machine . In another embodiment the client machine communicates with the worker machine using a presentation layer protocol such as ICA RDP VNC or X11.

In some embodiments the worker machine provides access to the requested resource by executing an application on the worker machine and transmitting application output data generated by the execution of the application to the client . In other embodiments as depicted by the worker machine provides access to the requested resource by providing access to a virtualized environment or by providing access to an application streaming service as described above in connection with .

In some embodiments upon identification of a worker machine the client agent of the client machine establishes a connection with a session management component associated with or residing on the worker machine . In other embodiments the worker machine executes the session management component to which the client machine connects. In one embodiment the session management component queries a virtual machine management component for the location of the configuration and virtual disk files of a virtual machine to run for the current user and a hypervisor in which the virtual machine may execute. In still other embodiments the client machine connects directly to the worker machine .

In some embodiments the identified hypervisor and virtual machine execute on the worker machine . In other embodiments the identified hypervisor and virtual machine execute on a remote machine . In one of these embodiments the worker machine communicates with the remote machine using a presentation layer protocol to receive output data generated by a resource executed by the virtual machine.

In one embodiment the session management component launches the virtual machine within the specified hypervisor in full screen mode. In another embodiment a previously executing virtual machine is allocated to the client machine .

In some embodiments a virtual machine service component executes within a computing environment provided by a virtual machine on a worker machine . In one of these embodiments the virtual machine service component receives an IP address and a port with which to establish a communication channel between the session management component and the virtual machine service component . In one embodiment this communication channel is used to pass session related configuration information from the client agent session into the virtual machine session. In some embodiments the configuration information includes display settings and changes client drive information and authentication data with which to enable single sign on for a user of the client machine .

In some embodiments once the communications channel is established and the initial session related information is passed to the virtual machine service component the virtual machine service component automatically connects the user to a computing environment such as a guest operating system using the same credentials as were provided to the client agent by the user if any . In one of these embodiments the virtual machine service component automatically reconfigures the display settings of the guest operating system to match those of the client . The virtual machine produces graphics and sound output to virtual devices that redirect that output directly or indirectly to the client agent on the client machine . The virtual machine receives audio input mouse and keyboard device data redirected from the client machine . When the virtual machine is shutdown or suspended the session management component terminates the client agent session.

In some embodiments the coordinator machine provides functionality for managing a pool of worker machines . In one of these embodiments for example the coordinator machine receives information identifying the worker machines as physical machines providing access to particular resources or as virtual machines providing access to particular resources. In another of these embodiments the coordinator machine receives information identifying a plurality of types of resources provided by the pool of worker machines . For example the coordinator machine may receive information identifying a pool of worker machines as providing access to a type of computing environment such as a desktop or application. In still another of these embodiments the coordinator machine communicates with a virtual machine management component to receive information about virtual machines in the pool of worker machines .

In other embodiments the coordinator machine monitors one or more worker machines in the pool of worker machines . In one of these embodiments the coordinator machine identifies a worker machine to provide access to a resource for a client machine and identifies a worker machine to provide access to the resource upon a failure of the worker machine . In another of these embodiments the coordinator machine identifies a worker machine to provide access to the resource responsive to a load balancing technique. In still another of these embodiments the coordinator machine identifies a worker machine to provide access to the resource responsive to a change associated with the client machine . For example the coordinator machine may identify a first worker machine to provide access to the resource for the client machine and the receive a second request for access by the client machine after the client machine has established a connected via a different network or has lost a first network connection and re established a second network connection.

In some embodiments the coordinator machine identifies a worker machine that provides access to a resource for a client machine according to a method chosen responsive to an evaluation of the client machine an application of a policy to the client machine and to the worker machine and an evaluation of the capabilities and requirements of the resource the client machine and the worker machine .

The previously described embodiments may be implemented as a method apparatus or article of manufacture using programming and or engineering techniques to produce software firmware hardware or any combination thereof. The term article of manufacture as used herein is intended to encompass code or logic accessible from and embedded in one or more computer readable devices firmware programmable logic memory devices e.g. EEPROMs ROMs PROMs RAMs SRAMs etc. hardware e.g. integrated circuit chip Field Programmable Gate Array FPGA Application Specific Integrated Circuit ASIC etc. electronic devices a computer readable non volatile storage unit e.g. CD ROM floppy disk hard disk drive etc. a file server providing access to the programs via a network transmission line wireless transmission media signals propagating through space radio waves infrared signals etc. The article of manufacture includes hardware logic as well as software or programmable code embedded in a computer readable medium that is executed by a processor. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention.

Having described certain embodiments of methods and systems for providing authorized remote access to a computing environment provided by a virtual machine it will now become apparent to one of skill in the art that other embodiments incorporating the concepts of the invention may be used. Therefore the invention should not be limited to certain embodiments but rather should be limited only by the spirit and scope of the following claims.

