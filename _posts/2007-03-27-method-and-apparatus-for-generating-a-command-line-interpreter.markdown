---

title: Method and apparatus for generating a command line interpreter
abstract: A method of exposing the functionality of an application in a command interface includes generating a command line interpreter (“CLI”) from a component of an application. The application's components are used to automatically generate the CLI to interpret commands to access the functionality of the application. The generated CLI parses, maps, and dispatches the commands and any associated arguments in accordance with the application's components. Application metadata is used to modify the generated CLI to customize the exposure of the functionality of the application in the command interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08347265&OS=08347265&RS=08347265
owner: Network Appliance, Inc.
number: 08347265
owner_city: Sunnyvale
owner_country: US
publication_date: 20070327
---
At least one embodiment of the present invention pertains to a command line interpreter CLI to interpret commands received via a command interface to an application on a computer system and more particularly to a technique for generating the CLI from an application component.

An application program interface API to an application program is used to expose the functionality of the application to other programs and systems in a uniform manner. Often it is desirable to also provide a command interface to the same functionality of the application that is exposed via the API. A command interface to an application program as opposed to an API is used to expose the functionality of the application to a user entering commands into a computer terminal or other user input device through which the application may be accessed. A command interface is typically supported by software that is referred to as a command line interpreter CLI . Among other things the CLI contains the logic to interpret commands received via the command interface. For example an application for managing databases on a storage system may have an API to access functionality to carry out a backup process such as a method to initiate the backup on the storage system and various parameters to specify the name of the database and a label to apply to the backup. A corresponding CLI might contain logic to interpret a backup command to access that same functionality to carry out the backup process via the command interface.

The CLI logic typically performs at least three core tasks. The first task is to parse and optionally error check and or otherwise validate the command and any arguments entered with the command. The second task is to map the parsed command and its arguments to the corresponding functionality in the application. The third task is to dispatch the command and its arguments by invoking the corresponding functionality of the application.

In some programming environments there are techniques to automate one of the tasks of parsing mapping and dispatching or to otherwise shorten the time required to develop the CLI logic for a given task. For example in some cases programmers can at least partly automate the task of parsing or error checking and or otherwise validating a command received in a command interface with reusable code components. The reusable code may be obtained from a common library of reusable objects for processing a command including parsing and validating i.e. error checking the syntax of the command and validating the values. The common library of reusable objects is typically stored in a library external to the specific application for which the CLI logic is being developed. An example of such an external library is described in the Apache Commons CLI http jakarta.apache.org commons cli . While such external libraries of reusable code components may be useful there is nothing to connect a common library to a specific application.

As another example some programming environments may provide an external file that can be used to at least partly automate the task of mapping a command. The external file specifies the mapping of the command and argument to the corresponding functionality of the application. While such external mapping files may be helpful they require constant manual synchronization to the functionality in the current version of the application.

Despite the availability of such techniques there is currently no satisfactory comprehensive way to automatically perform all three of the core CLI tasks of parsing mapping and dispatching. As a result the CLI logic is often written entirely by hand which is error prone and time consuming. As with the external files to specify mapping hand coded CLIs also require constant manual synchronization to the functionality in the current version of the application. For example adding new functionality to an application having a command interface typically requires numerous modifications to the CLI including 1 a modification of the parsing logic to accept a new command and arguments corresponding to the new functionality 2 a modification of the mapping logic to map the new command and arguments to the new application components that carry out the new functionality and 3 a modification of the dispatching logic to invoke the new application components when the new command is issued. Consequently a CLI to interpret commands in a command interface to an application can be cumbersome to develop and maintain.

The present invention includes a method and apparatus for exposing the functionality of an application in a command interface by automatically generating a command line interpreter from the application including generating a CLI from an application program interface API component or other type of component representing the functionality of the application. In one embodiment the method includes receiving a request to generate a CLI to interpret a command to access a functionality of an application obtaining an API component or other type of component representing the functionality of the application and generating from the application component a CLI component to facilitate accessing the functionality of the application using the command including parsing the command according to the application component mapping the parsed command to the application component and dispatching the command according to the application component.

Other aspects of the invention will be apparent from the accompanying figures and from the detailed description which follows.

A method and apparatus for exposing the functionality of an application in a command interface including generating a CLI from an application s components are described. References in this specification to an embodiment one embodiment or the like mean that the particular feature structure or characteristic being described is included in at least one embodiment of the present invention. However occurrences of such phrases in this specification do not necessarily all refer to the same embodiment.

The described embodiments include a method and apparatus for exposing the functionality of an application in a command interface by automatically generating a command line interpreter CLI from an application s components. The application s components may include any components that represent the functionality of the application such as the components of an application program interface API .

In a typical embodiment a CLI generator receives a request from a developer of an application or the application itself to generate a CLI to interpret a command to access a functionality of the application either before or during execution of the application. The CLI generator then obtains information about one or more components representing the functionality of the application and automatically generates from those components various CLI components to facilitate accessing the functionality of the application using the command.

In a typical embodiment the CLI generates logic to parse the command according to the application s component to map the parsed command to the application s component and to dispatch the command according to the application s component. In some embodiments a CLI annotator will obtain any metadata associated with the application s components and apply the metadata to the various CLI components that were generated by the CLI generator. In this way the CLI annotator customizes the exposure of the functionality of the application via the command interface.

As will be appreciated from the description that follows the CLI generator advantageously provides application developer s a superior alternative to the laborious and error prone task of developing the CLI logic by hand. In addition the CLI generator eliminates the need to manually synchronize the CLI to the functionality in the current version of their application thereby simplifying the task of maintaining the CLI as new functionality is added to the application.

Before describing embodiments of the invention in further detail certain terminology relating to CLIs applications and their APIs is defined and explained below and used throughout the rest of the description.

In a typical application programming environment the functionality of the application is embodied in a number of components of the application. For example in an object oriented programming environment the components are typically implemented in class method and parameter objects of an API that provide access to the functionality of the application in a uniform manner. For example an application to backup a database on a storage system may have an API that includes one or more method objects and parameter objects that carry out the backup process such as a method to initiate the backup on the storage system and various parameters to specify the name of the database and a label to apply to the backup.

In some application programming environments the application s functionality may be represented in other types of components other than objects. For example another application to backup a database on a storage system may include in the application a function call to a third party application to carry out a particular task such as generating a tracking number to associate with the backup. In a procedural programming environment the call to the third party application could take the form of a procedure call to an function including a remote procedure call where the call may pass certain arguments to the function in the form of parameters similar to the methods and parameters of an API. In a messaging type of programming environment the call might be implemented in the form of a request to a remote function or process that is accessible over a network via a web service or web API using a Simple Object Access Protocol SOAP message embedded in the application. The function call remote procedure call or SOAP request embedded in a SOAP message are therefore examples of other types of application components from which the CLI may be generated. Accordingly any particular embodiment of the invention does not limit the generation of a CLI from an application s components to API objects.

As noted earlier a CLI has logic to perform at least three core tasks parsing validating mapping and dispatching. The logic for a particular command may be organized into separate components of the CLI referred to as a parser validator a mapper and a dispatcher. The parser validator parses commands and arguments received from the command interface. The mapper maps the parsed commands and arguments to their functional counterparts in the application i.e. to create an association between a command and arguments received in the command interface and the corresponding functionality in the application. In some of the embodiments described below this association may be referred to as a link between the command and arguments received in the command interface and the corresponding components of the application such as the corresponding API method and parameter objects. In some embodiments the association may be referred to as a binding object that links the command and arguments to the corresponding components of the application. It should be understood however that any particular embodiment of the invention described below does not limit the implementation of the association as a link or a binding object. Lastly the dispatcher dispatches the parsed and mapped command and arguments by invoking the corresponding components of the application using the link or binding object.

In some application programming environments the components of the application may be modified by data to customize a particular implementation of the application s components referred to as metadata. For example in a Java programming platform a developer may use metadata in the form of annotations to annotate or tag an API object with metadata. In the embodiments of the invention described below the metadata such as annotations may be used advantageously to expose the functionality of the application in the command interface in a more accessible and user friendly manner. It should be understood however that any particular embodiment of the invention does not limit the implementation of the application metadata to annotations and other techniques for annotating an application s components may be employed without departing from the scope of the claimed embodiments of the invention.

In some application programming environments the components of the application such as an API object may be inspected at runtime using reflection. Reflection is a technique that enables programmers to obtain information about an object at runtime. For example in the Java programming platform a developer may use a reflection interface to among other things determine the class of an object get information about the class s modifiers fields methods constructors and superclasses find out what constants and method declarations belong to an interface and create an instance of a class whose name is not known until runtime. In some of the embodiments of the invention described below a reflection interface may be used advantageously to obtain information about the components of an API to facilitate the generation of a CLI from the API components.

In other embodiments other techniques may be used to obtain information about the components of an application to facilitate the generation of the CLI from the application such as pre compiling interpreting or scanning an application that includes function calls in order to identify and parse the function call component representing the functionality of the application. In a messaging programming environment information about the components of an application may be obtained from the Web Services Description Language WSDL used to describe the application service available on a remote system hosting the application service . It should be understood therefore that any particular embodiment of the invention described below does not limit the implementation of the generation of a CLI from application components to the use of reflection other techniques for obtaining information about an application s components before or at runtime may be employed in the generation of a CLI from the application s components without departing from the scope of the claimed embodiments of the invention.

It will be apparent from the description of the embodiments that follow that certain aspects of the present invention may be embodied at least in part in software. That is the techniques may be carried out in a computer system or other data processing system in response to its processor such as a microprocessor executing sequences of instructions contained in a memory or other type of internal or external storage device. In various embodiments hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system. In addition throughout this description various functions and operations are described as being performed by or caused by software code to simplify description. However those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor such as a microprocessor.

In addition to the foregoing it should be noted that various different software architectures may be used to implement the functions operations logic modules or other components described herein. The following discussion provides some examples of such an architecture but it will be understood that alternative architectures may also be employed to achieve the same or similar results.

The storage subsystem is managed by the storage server . The storage server receives and responds to various read and write requests from the clients directed to data stored in or to be stored in the storage subsystem . The mass storage devices in the storage subsystem may be for example conventional magnetic disks optical disks such as CD ROM or DVD based storage magneto optical MO storage or any other type of non volatile storage devices suitable for storing large quantities of data.

Although illustrated as a self contained element the storage server may have a distributed architecture. Alternatively the storage server may have an integrated architecture where the network and data components are all contained in a single box. The storage server further may be coupled through a switching fabric to other similar storage servers not shown which have their own local storage subsystems. In this way all of the storage subsystems can form a single storage pool to which any client of any of the storage servers has access.

It should be noted that embodiments of the CLI generator may be adapted for use in other types of storage systems such as storage servers which provide clients with block level access to stored data. In addition embodiments of the CLI generator may be adapted for use in processing systems other than storage systems.

As shown in the software architecture includes an API comprising API objects that embody the functionality of the application for which a CLI is to be generated. The API objects may include an API class object having one or more API method objects and related API parameter objects . In one embodiment the API objects may include one or more global parameter objects that are associated not with any particular API method object but rather with an entire API class . The API objects may optionally be annotated with API annotations that may be used to customize the exposure of the functionality embodied in the API objects on the command interface as will be described below.

The CLI generator comprises a CLI object generator and optionally a CLI object annotator . The CLI object generator generates a CLI comprising CLI objects that embody the CLI logic of the core tasks to be performed by the CLI when interpreting particular commands and arguments received in the command interface where the core tasks include parsing mapping and dispatching.

In the illustrated embodiment the CLI is generated by constructing a CLI interpreter class object from the API Class API Method and API Parameter objects that embody the functionality of the application. As such the CLI interpreter class object is the means by which a developer would initiate a request to the CLI generator to generate a CLI for their application and the API Class API Method and API parameter objects are the inputs to the CLI generator . In one embodiment the CLI interpreter class object provides a single public method execute to that provides the parsing mapping and dispatching functions of the generated CLI as will be described in more detail below. An example of the CLI interpreter class appears in Example 1.

In addition the CLI interpreter class object uses the CLI mapper object to create object bindings between each of the commands received in the command interface and their corresponding API Method objects. Within each command method object binding the CLI mapper creates additional object bindings between each of the arguments received in the command interface and their corresponding API Parameter objects. In one embodiment the argument parameter object bindings are created by instantiating an object binding subclass that matches the concrete type of the corresponding API Method s parameter object. Examples of concrete types that the illustrated embodiments could support include among others primitive types array types and java bean types.

In one embodiment the CLI mapper object optionally creates global object bindings between any global values i.e. global arguments received in the command interface and their corresponding API objects i.e. global parameters. As such the global object bindings represent command line options received in the command interface that are not associated with a particular command API method object but rather with an entire API class .

In a typical embodiment the CLI object annotator uses the API annotations to customize the exposure of the functionality embodied in the API Class API Method and API Parameter objects in the corresponding commands and arguments received via the command interface. For example the CLI object annotator may apply the API annotations to the CLI parser object to modify how a command or argument is to be interpreted by the CLI i.e. to modify the syntax of the command or argument received via the command interface.

As shown in the software architecture includes a web service that describes the SOAP requests that embody the functionality of an application for which a CLI is to be generated where the functionality of the application is accessible as part of the web service from a remote system hosting the application. The web service may describe a SOAP request having one or more SOAP method tags and related parameter tags using for example a WSDL formatted description. In one embodiment the SOAP request may include one or more global parameter tags that are associated not with any particular method tag but rather with an entire SOAP request . The SOAP requests may optionally be annotated with web service comments that may be used to customize the exposure of the functionality embodied in the SOAP requests on the command interface as will be described below.

In the illustrated embodiment the CLI is generated by constructing a CLI interpreter class object from the SOAP request method tag and related parameter tags that embody the functionality of the application. As such the CLI interpreter class object is the means by which a developer would initiate a request to the CLI generator to generate a CLI for their application and the SOAP request method tags and parameter tags are the inputs to the CLI generator .

In addition the CLI interpreter class object uses the CLI mapper object to create SOAP request bindings between each of the commands received in the command interface and their corresponding SOAP method tags . Within each command method tag binding the CLI mapper creates additional SOAP request bindings between each of the arguments received in the command interface and their corresponding SOAP parameter tags . In one embodiment the argument parameter tag bindings are created by instantiating an object binding subclass that matches the concrete type of the corresponding SOAP method s parameter tags . An example of concrete types that the illustrated embodiments could support include any data type that may be defined in the Extended Markup Language XML Schema embedded in the web services description of the application s components i.e. XML Schema embedded in the WSDL description of the SOAP requests .

In one embodiment the CLI mapper object optionally creates global SOAP request bindings between any global values i.e. global arguments received in the command interface and their corresponding SOAP requests i.e. global parameters. As such the global SOAP request bindings represent command line options received in the command interface that are not associated with a particular command SOAP request method tag but rather with an entire SOAP request .

In a typical embodiment the CLI object annotator uses web service comments if any to customize the exposure of the functionality embodied in the SOAP request SOAP method tags and SOAP parameter tags in the corresponding commands and arguments received via the command interface. For example the CLI object annotator may apply the web service comments to the CLI parser object to modify how a command or argument is to be interpreted by the CLI i.e. to modify the syntax of the command or argument received via the command interface.

Upon receiving a request from the MYAPP application to generate a MYAPP CLI to interpret commands and arguments received on the command interface of the MYAPP application the CLI generator generates a MYAPP Backup command Interpreter object comprising a Backup parser object a Backup mapper object and a Backup dispatcher object . Further the CLI generator uses the Backup mapper object to generate the Backup object bindings in preparation for interpreting the Backup command when received on the command interface. In particular the CLI generator uses the Backup mapper object to generate the Backup command object binding between a Backup command and the corresponding Backup method object as well as the Backup parameter object bindings between any Backup arguments and corresponding Backup parameter objects such as the DATABASE and LABEL Backup parameter objects .

In one embodiment the request to generate the MYAPP CLI is implemented by including code in the MYAPP application to instantiate a MYAPP Backup command Interpreter object as well as code to pass an args array to the execute method of the CLI Interpreter object. An example of the code to request the generation of the MYAPP CLI and execute a single input command line appears in Example 3.

Since the MYAPP API is further annotated with Annotations including the method annotation backup and the parameter annotations db and label the CLI Object annotator of the CLI generator uses the annotation values to modify the Backup parser object to modify the syntax of the BACKUP command to use db as the shortened argument name corresponding to the DATABASE parameter object and label as the argument name corresponding to the LABEL parameter object . Now a user can enter the BACKUP command using the syntax as it appears in Example 4 to execute a backup of a database named IMPORTANT DATABASE and label it as Important Backup. 

Upon receiving the command from the command interface the previously generated MYAPP CLI identifies the name of the command in this case BACKUP and invokes the MYAPP Backup Command Interpreter object to interpret the command using the Backup parser Backup Mapper and Backup dispatcher objects.

In the illustrated embodiment of the MYAPP links are implemented as a Backup binding object A which is operatively coupled to the MYAPP Backup Method and DB and LABEL binding objects B which are operatively coupled to the Backup Method and Database and Label Parameters objects of the MYAPP API. However other mechanisms for providing the links may be employed without departing from the scope of the claimed embodiments.

During operation a BACKUP command and arguments received on the command interface are interpreted by the MYAPP Backup Command Interpreter including being parsed and optionally validated by the Backup Parser . The parsed commands and arguments are then dispatched by the Backup Dispatcher by using the corresponding Backup Binding A and DB and LABEL Bindings objects B to invoke the corresponding Backup Method and Database and Label Parameters objects of the MYAPP API .

Referring to methods for implementing an embodiment of the present invention as described in are summarized in a flowchart illustrating certain aspects of generating a CLI from an application s components. In an exemplary process the method begins at reference block in which a processor having logic to generate a CLI in accordance with an embodiment of the invention receives a request from an application to generate a CLI to expose the functionality of the application via a command interface. At reference block the processor obtains the application s components that represent the functionality of the application. Processing continues at reference block in which the processor generates a CLI parsing component for each pertinent application component such as for each method and parameter object representing the functionality of the application. Likewise processing continues at reference blocks and to generate the mapping and dispatching components respectively.

At reference block the processor determines whether any metadata is associated with the application s component and if so applies the metadata to the CLI components to customize the exposure of the application via the command interface. In a typical embodiment the application of the metadata is performed on the CLI parsing component to modify the syntax of the command and arguments or otherwise modify the user visible aspects of the command and arguments in the command interface.

With reference to as well as the description of the embodiments thus far it should be noted that the process may be performed at runtime or prior to runtime such as at compile time or during a pre compilation depending on the embodiment and or the requirements of a particular application. For example it may be advantageous to use the process to generate a CLI for an application at runtime where the application supports a product that is a centralized manager of many systems. For such products the managed systems could register their APIs with the centralized manager which in turn would request the generation of the CLIs for the systems at runtime as described in and elsewhere in this application.

Referring to methods for implementing an embodiment of the present invention as described in are summarized in a flowchart illustrating certain aspects of interpreting commands in a command interface using a CLI that was generated from an API s components as in .

In an exemplary process the method begins at reference block in which a processor having logic to operate an application exposes the functionality of the application on a command interface according to a CLI that was previously generated from the application s components. At reference block the processor receives a command and arguments from the command interface and at reference block proceeds to parse the command and arguments using the command s CLI parsing component and any customizations applied to the CLI parsing component from the application component s metadata.

In one embodiment at reference block the processor maps the parsed command using the command s CLI mapping component. In one embodiment mapping the parsed command includes generating a link between the parsed command and arguments and the corresponding application s functional component s . In some cases the link may have been previously established for the command during an earlier receipt of the command and arguments or possibly during the generation of the CLI. In any event once the link is established processing continues at reference block in which the processor dispatches the command using the command s dispatching component. In one embodiment dispatching the command includes invoking the corresponding application s functional component s using the generated links between the application s components and the parsed commands and arguments.

Referring to methods for implementing an embodiment of the present invention as described in are summarized in a flowchart illustrating certain aspects of generating a CLI from an application s components where the components are objects such as class method and parameter objects or other types of components such as function calls remote procedure calls and SOAP requests. In an exemplary process the method begins at reference block in which a processor having logic to generate a CLI in accordance with an embodiment of the invention receives a request from an application to generate a CLI for an application. At reference block the processor obtains the application s components that represent the functionality of the application as well as any annotations applied to the application s components. Processing continues at reference block in which the processor generates a command parser to parse a command and arguments according to the application component. In the illustrated embodiment at reference block the processor applies the application component s annotations if any to the corresponding command parser to customize the exposure of the command and arguments on the command interface.

Processing continues at reference block in which the processor generates a command mapper to generate binding objects that link the parsed command and arguments to the corresponding application components such as the corresponding method and parameter objects of an API. Processing concludes at reference block in which the processor generates a command dispatcher to invoke the corresponding application components using the binding objects generated at reference block .

Referring to methods for implementing an embodiment of the present invention as described in are summarized in a flowchart illustrating certain aspects of interpreting commands in a command interface using a CLI that was generated from an application s components as in .

In an exemplary process the method begins at reference block in which a processor having logic to operate an application exposes the functionality of the application on a command interface according to a CLI that was previously generated from the application s components. At reference block the processor receives a command and arguments from the command interface and at reference block proceeds to parse the command and arguments using the command s CLI parser and any annotations applied to the CLI parser.

Processing continues at reference block in which the processor maps the parsed command using the command s CLI mapper. In one embodiment mapping the parsed command includes generating object bindings that link the parsed command and arguments to the corresponding application components such as the corresponding API method and parameter objects. In some cases the object bindings have been previously generated for the command during earlier processing of the command and arguments or possibly during the generation of the CLI. In any event once the object bindings are generated and available to the processor processing continues at reference block in which the processor dispatches the command using the command s dispatcher. In one embodiment the dispatcher invokes the application components using the corresponding object bindings that were generated for the parsed command and arguments.

The processors are the central processing units CPUs of the computer system and thus control its overall operation. In certain embodiments the processors accomplish this by executing software stored in memory . Such processor may be or may include one or more programmable general purpose or special purpose microprocessors digital signal processors DSPs programmable controllers application specific integrated circuits ASICs programmable logic devices PLDs or the like or a combination of such devices.

Memory includes the main memory of the computer system . Memory represents any form of random access memory RAM read only memory ROM flash memory or the like or a combination of such devices. Memory stores among other things the storage server s operating system which can implement the embodiments of the invention described herein.

Also connected to the processors through the bus system are a storage adapter and a network adapter . The storage adapter allows the computer system to access a storage subsystem and may be for example a Fibre Channel adapter or a SCSI adapter. The network adapter provides the computer system with the ability to communicate with remote devices such as clients over a network and may be for example an Ethernet adapter a Fibre Channel adapter or the like.

A method and apparatus for exposing the functionality of an application in a command interface have been described. Software to implement the described embodiments of the invention may be stored on a machine accessible medium. A machine accessible medium as the term is used herein includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. a computer network device personal digital assistant PDA manufacturing tool any device with a set of one or more processors etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc. The term logic as used herein can include for example hardwired circuitry programmable circuitry software or any combination thereof.

Although the present invention has been described with reference to specific exemplary embodiments it will be recognized that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. For example as noted elsewhere the invention may be implemented in a variety of application programming environments including object oriented procedural and messaging programming environments in which a CLI may be automatically generated from an application components of different types including API objects function and remote procedure calls and SOAP messages. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense.

