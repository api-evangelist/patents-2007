---

title: Translation of register-combiner state into shader microcode
abstract: An apparatus and method for translating fixed function state into a shader program. Fixed function state is received and stored and when a new shader program is detected the fixed function state is translated into shader program instructions. Registers specified by the program instructions are allocated for processing in the shader program. The registers may be remapped for more efficient use of the register storage space.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08004523&OS=08004523&RS=08004523
owner: NVIDIA Corporation
number: 08004523
owner_city: Santa Clara
owner_country: US
publication_date: 20071228
---
This application is a continuation of U.S. patent application Ser. No. 10 899 603 filed Jul. 27 2004 now U.S. Pat. No. 7 324 106 which is herein incorporated by reference.

One or more aspects of the invention generally relate to graphics data processing and more particularly to performing combiner operations in a programmable graphics processor.

Current graphics data processing includes systems and methods developed to perform a specific operation on graphics data e.g. linear interpolation tessellation rasterization texture mapping depth testing etc. More recently portions of graphics processors are programmable supporting a wider variety of operations for processing vertex data and fragment data. However these graphics processors also include fixed function computation units to perform specific operations particularly for performing texture mapping operations such as level of detail LOD computations texture blending and filtering. The fixed function computation units for performing texture blending are configured in a pipeline such as a prior art Texture Blend Unit shown in configured using fixed function state.

Each Combiner Unit within Texture Blend Unit may be configured to perform a limited set of texture blending operations using inputs read from registers. The fixed function state specifies which register value should be multiplexed to which multiplier or adder input. A Specular Combiner Unit is configured to blend specular color data with blended texture and color data. A Final Combiner Unit is configured to blend fog data with blended specular color and texture data and produce shaded fragment data.

As greater portions of graphics processors are programmable it is desirable to perform texture blending using one or more programmable computation units and remove the fixed function units to save die area and improve efficiency. However in order to execute code written for a processor supporting fixed function units the fixed function state must be converted into program instructions for execution by the one or more programmable computation units.

Accordingly it is desirable to have a graphics processor that can execute code written for a processor supporting fixed function unit and a program written for programmable computation units without requiring either a driver upgrade or inclusion of the fixed function units within the graphics processor.

The current invention involves new systems and methods for translating fixed function state into shader programs. An applications programming interface API call for a fixed function unit is converted into shader program instruction. A conventional driver designed to support fixed function state may convert API calls into fixed function state and an apparatus within a graphics processor may translate the fixed function state into a shader program. The apparatus enables the conventional driver to function with a graphics processor which does not include a fixed function unit for performing combiner operations. Alternatively another driver may convert the API calls directly into a shader program. The apparatus may be used to improve performance of the other driver by offloading the translation function for some API calls from the other driver. In either case when the apparatus generates a shader program the apparatus will allocate registers for processing the shader program. The apparatus may also remap the registers to more efficiently pack the registers.

Various embodiments of the invention include an apparatus for generating a shader program based on a set of fixed function state. The apparatus includes a storage unit and an instruction emulator. The storage unit is configured to receive and store the set of fixed function state. The instruction emulator is configured to generate the shader program by translating the set of fixed function state into the shader program.

Various embodiments of a method of the invention for generating shader program instructions include receiving a fixed function application programming interface call converting the fixed function application programming interface call into a fixed function state bundle and translating the fixed function state bundle into at least one shader program instruction.

Various embodiments of a method of the invention for translating fixed function state into a shader program includes receiving a packet determining whether or not the packet indicates a new fixed function program should be generated and translating the fixed function state into the shader program when the packet indicates the new fixed function program should be generated.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

Host Computer communicates with Graphics Subsystem via System Interface and a Graphics Interface within a Graphics Processor . Data received at Graphics Interface can be passed to a Front End or written to a Local Memory through Memory Controller . Graphics Processor uses graphics memory to store graphics data and program instructions where graphics data is any data that is input to or output from components within the graphics processor. Graphics memory may include portions of Host Memory Local Memory register files coupled to the components within Graphics Processor and the like.

Graphics Processor includes among other components Front End that receives commands from Host Computer via Graphics Interface . Front End interprets and formats the commands and outputs the formatted commands and data to an IDX Index Processor . Some of the formatted commands are used by Programmable Graphics Processing Pipeline to initiate processing of data by providing the location of program instructions or graphics data stored in memory. IDX Programmable Graphics Processing Pipeline and a Raster Operation Unit each include an interface to Memory Controller through which program instructions and data can be read from memory e.g. any combination of Local Memory and Host Memory . When a portion of Host Memory is used to store program instructions and data the portion of Host Memory can be uncached so as to increase performance of access by Graphics Processor .

IDX optionally reads processed data e.g. data written by Raster Operation Unit from memory and outputs the data processed data and formatted commands to Programmable Graphics Processing Pipeline . Programmable Graphics Processing Pipeline and Raster Operation Unit each contain one or more programmable processing units to perform a variety of specialized functions. Some of these functions are table lookup scalar and vector addition multiplication division coordinate system mapping calculation of vector normals tessellation calculation of derivatives interpolation and the like. Programmable Graphics Processing Pipeline and Raster Operation Unit are each optionally configured such that data processing operations are performed in multiple passes through those units or in multiple passes within Programmable Graphics Processing Pipeline . Raster Operation Unit includes a write interface to Memory Controller through which data can be written to memory.

In a typical implementation Programmable Graphics Processing Pipeline performs geometry computations rasterization and fragment computations. Therefore Programmable Graphics Processing Pipeline is programmed to operate on surface primitive vertex fragment pixel sample or any other data. Programmable processing units within Programmable Graphics Processing Pipeline may be programmed to perform combiner operations using a shader program. Combiner operations may also be performed by the programmable processing units within Programmable Graphics Processing Pipeline when Programmable Graphics Processing Pipeline translates conventional combiner state bundles into a shader program as described further herein.

Shaded fragment data output by Programmable Graphics Processing Pipeline are passed to a Raster Operation Unit which optionally performs near and far plane clipping and raster operations such as stencil z test and the like and saves the results or the samples output by Programmable Graphics Processing Pipeline in Local Memory . When the data received by Graphics Subsystem has been completely processed by Graphics Processor an Output of Graphics Subsystem is provided using an Output Controller . Output Controller is optionally configured to deliver data to a display device network electronic control system other computing system such as Computing System other Graphics Subsystem or the like. Alternatively data is output to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

Combiner IPU outputs shader programs which emulate combiner programs to an Instruction Processor . Combiner IPU outputs the raster stream with inserted tokens described further herein to an Attribute Interpolator within Shader Pipeline . Instruction Processor receives some shader program instructions from IDX and reads other program instructions from graphics memory via Memory Controller . In some embodiments of the present invention Instruction Processor includes an instruction cache and program instructions which are not available in the instruction cache for example when a branch instruction is executed are read from graphics memory. Shader programs generated by Combiner IPU are output by Instruction Processor .

Instruction Processor outputs shader program instructions to Attribute Interpolator . Attribute Interpolator processes pixel packets received from Combiner IPU in the raster stream as specified by the shader program instructions and any state bundles that are not translated into shader program instructions. For example Attribute Interpolator may produce interpolated attributes including texture coordinates barycentric coefficients and depth and perform clipping. The barycentric coefficients may be used for computing interpolated primary and secondary colors and interpolated fog distance. Attribute Interpolator outputs the interpolated attributes to a Shader Computation Unit .

Shader Computation Unit also receives shader program instructions and state bundles that are not translated into shader program instructions from Instruction Processor . Shader Computation Unit performs perspective correction of the interpolated attributes input operands . Shader Computation Unit may also receive input operands from a Shader Register File via a Fragment Shader . Shader Computation Unit may be programmed to clamp input operands and scale perspective corrected attributes. Shader Computation Unit outputs the perspective corrected attributes to a Texture Unit . Shader Computation Unit also outputs input operands that are received from Shader Register File for Texture Unit .

Texture Unit receives the perspective corrected attributes and any input operands and performs texture lookups to read texels stored in graphics memory. Texture Unit remaps texels to a format that may be stored in Shader Register File for example a 16 bit or 32 bit floating point value. Texture Unit may be programmed to clamp the texels. Texture Unit may also pass perspective corrected attributes through from Shader Computation Unit to Fragment Shader .

Fragment Shader may be configured by shader program instructions to perform combiner operations receiving color data and texels and producing shaded fragment data. Fragment Shader includes multiply accumulate units and a computation unit capable of executing scalar instructions such as log sine cosine and the like. Fragment Shader may read source data stored in Shader Register File . The shaded fragment data and or the source data may be output by Fragment Shader to Shader Computation Unit . Fragment Shader may also write destination data e.g. shaded fragment data into output registers within Shader Register File which are output to Raster Operation Unit .

A conventional graphics processor including fixed function combiner unit is configured using fixed function state bundles specifically combiner state bundles produced by a conventional driver. In contrast Fragment Shader is programmed to perform combiner functions using shader program instructions. However Fragment Processor may receive combiner state bundles produced by the conventional driver for the conventional graphics processor and translate a combiner program represented by the combiner state bundles into a shader program. Alternatively when a new driver i.e. a driver supporting Fragment Shader shader programs for performing combiner operations is used the new driver may produce the shader program to emulate the combiner program in which case Combiner IPU is idle.

Raster State Machine determines when a new shader program should be generated to emulate the functions specified by a fixed function combiner program based on the dirty signal received from Combiner Control Storage Unit . Raster State Machine inserts block tokens in the output raster stream when a new program should be generated to drain Shader Pipeline . Raster State Machine receives an idle signal from Shader Pipeline indicating that the Shader Pipeline is idle and may receive a new shader program generated by an Instruction Emulator . In some embodiments of the present invention Combiner Control Storage Unit includes registers to store one set of combiner program state and Raster State Machine outputs a stall signal to Rasterizer to block the raster stream as needed to translate the program state into a shader program. In other embodiments of the present invention Combiner Control Storage Unit includes registers to store two or more sets of combiner program state and Raster State Machine only outputs the stall signal to Rasterizer when the two or more sets of combiner program state are in use.

Instruction Emulator receives a program stream including a program trigger and determines when to start and stop outputting shader program instructions to Instruction Processor as described in conjunction with . Instruction Emulator also reads the state bundle data from Combiner Control Storage Unit and generates shader program instructions to emulate the fixed function program specified by the state bundles. When a new shader program should be generated Raster State Machine outputs register allocation trigger to Instruction Emulator . Before generating and outputting the shader program instructions Instruction Emulator determines the number of registers in Shader Register File needed to execute the shader program and returns a register allocation count to Raster State Machine . In some embodiments of the present invention Instruction Emulator remaps the registers allocated for processing of the shader program as described in conjunction with . Raster State Machine outputs register allocation bundles to Instruction Processor including the number of registers.

If in step Raster State Machine determines that a new program should be generated then in step Raster State Machine signals Instruction Emulator to begin translating the program state into a shader program and proceeds to step . If in step Raster State Machine determines that a new program should not be generated then Raster State Machine also proceeds to step . In step Raster State Machine outputs the packet to Shader Pipeline .

In step Raster State Machine receives a packet. In step Raster State Machine determines if the packet is the first pixel packet received following one or more register load packets and if so in step Raster State Machine determines the packet is the first pixel packet received following one or more register load packets then in step Raster State Machine determines if the program state is dirty. The program state is dirty when either a reset has occurred or a fixed function state register has changed value via a register load packet. Raster State Machine receives a dirty signal from Combiner Control Storage Unit indicating whether or not the program state is dirty. 

If in step Raster State Machine determines the register allocation count is not dirty Raster State Machine proceeds to step and outputs the packet to Shader Pipeline . Otherwise in step Raster State Machine generates an allocation trigger that is output to Instruction Emulator which then initiates a register allocation count. In step Raster State Machine determines if the register allocation count is completed i.e. if a register count completed signal and the register count have been received by Raster State Machine from Instruction Emulator . Raster State Machine remains in step until Raster State Machine determines that the register allocation count has been completed and then Raster State Machine proceeds to step .

In step Raster State Machine inserts an allocation bundle including the register count into the output raster stream by outputting a packet including the allocation bundle to Shader Pipeline . In step Raster State Machine also outputs the pixel packet received in step .

If in step Raster State Machine determines that the packet is not the first pixel packet received following one or more register load packets then in step Raster State Machine determines if there has been a change in the program state as indicated by the dirty signal output by Combiner Control Storage Unit . If in step Combiner Control Storage Unit determines that the incoming packet is a register load packet that does not result in a change of the program state then Raster State Machine proceeds to step and outputs the packet to Shader Pipeline . If in step Combiner Control Storage Unit determines that the incoming packet is a register load packet that does result in a program state change then in step Raster State Machine blocks incoming packets in order for Shader Pipeline to complete execution of the shader program. Raster State Machine outputs a block token to drain the shader pipeline.

In an alternate embodiment of the present invention Combiner Control Storage Unit includes additional registers to store two or more sets of program state and Raster State Machine blocks incoming register load packets when all of the sets of program state are in use. In step Raster State Machine determines if Shader Pipeline has completed execution of the shader program based on the idle signal received from Shader Pipeline . When Raster State Machine determines that Shader Pipeline is idle Raster State Machine proceeds to step and outputs the packet received in step to Shader Pipeline . In step Raster State Machine unblocks incoming packets.

In step Instruction Emulator receives a register allocation trigger from Raster State Machine . In step Instruction Emulator generates register allocation count and optionally creates a mapping table of the allocated registers as described in conjunction with . Raster State Machine triggers Instruction Emulator to generate one register allocation count for each fixed function program. In step Instruction Emulator also outputs the register allocation count to Raster State Machine . In step Instruction Emulator reads the program state and generates up to N shader program instructions to emulate at least a portion of the fixed function program where N is a positive integer. In some embodiments of the present invention N is as many as 8 shader program instructions.

In step Instruction Emulator also outputs the N shader program instructions to Instruction Processor . In step Instruction Emulator determines if the program trigger has been received from the program stream and if not in step Instruction Emulator determines if execution of the shader program is complete as indicated by Raster State Machine . If in step Instruction Emulator determines that execution of the shader program is not complete then Instruction Emulator returns to step . If in step Instruction Emulator determines that execution of the shader program is complete then in step Instruction Emulator outputs an invalidate token to Instruction Processor to indicate that the previously output N shader program instructions are invalid and should be discarded and proceeds to step . In step when the program trigger is received the method proceeds to step where Instruction Emulator outputs a valid token to Instruction Processor to indicate that the previously output N shader program instructions are valid.

In step Instruction Emulator determines if additional shader program instructions need to be generated to emulate the fixed function program and if so in step Instruction Emulator generates the additional shader program instructions and outputs them to Instruction Processor . In step Instruction Emulator determines if execution of the shader program is complete as indicated by Raster State Machine and if so Instruction Emulator proceeds to step and emulation of the fixed function program is complete. If in step Instruction Emulator determines execution of the shader program is not complete then in step Instruction Emulator resends the shader program instructions to Instruction Processor . In an alternate embodiment of the present invention the shader program instructions are stored within Instruction Processor and Instruction Emulator does not resend the shader program instructions. In some embodiments of the present invention in Instruction Emulator also generates the shader program instructions by returning to step instead of proceeding to step . If in step Instruction Emulator determines additional shader program instructions do not need to be generated to emulate the fixed function program Instruction Emulator proceeds to step and either step or step as previously described.

In some embodiments of the present invention a portion of the API call conversion is offloaded from the driver to Combiner IPU to improve performance of the driver. For example the driver may convert fixed function API calls into fixed function state bundles and offload the translation of the fixed function state bundles into a shader program to Combiner IPU . Likewise a portion of the conversion of other API calls may also be offloaded i.e. translated by one or more fixed function instruction processing units within Graphics Processor .

In step Instruction Emulator within Combiner IPU remaps the registers specified by the fixed function state bundles generated in step . Even if the driver converts the fixed function API call directly into a shader program instruction Combiner IPU may perform register remapping to improve the efficiency of the registers used in Shader Register File possibly improving processing performance of Shader Pipeline .

Therefore persons skilled in the art will appreciate that any system configured to perform the method steps of B C or their equivalents is within the scope of the present invention. Furthermore persons skilled in the art will appreciate that the method steps of B C may be extended to support translation of other types of API calls such as API calls used to configure conventional fixed function computation units.

The invention has been described above with reference to specific embodiments. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order unless explicitly stated in the claim.

