---

title: Enhanced user interface manager and method for managing non-contemporaneous user interface modules
abstract: A user interface manager acts to cache state information and thread information provided to it by user interface modules, before the user interface modules cease execution. When a new user interface module commences execution, or the old user interface module recommences execution, the user interface module may request, from the user interface manager, the cached state information and thread information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484722&OS=08484722&RS=08484722
owner: Research In Motion Limited
number: 08484722
owner_city: Waterloo
owner_country: CA
publication_date: 20070817
---
This patent application is a continuation in part of U.S. patent application Ser. No. 11 465 297 entitled User Interface Manager And Method For Reacting To A Change In System Status and filed on Aug. 17 2006. Additionally the present application claims priority to U.S. Provisional Patent Application Ser. No. 60 946 549 filed Jun. 27 2007 the contents of which are hereby incorporated herein by reference.

The present application relates generally to user interfaces and more specifically to an enhanced user interface manager and method for managing non contemporaneous user interface modules.

It is common practice to configure a computer workstation so that the workstation can be used by several different users. To maintain personalized settings and privacy among the users in the context of the use of the workstation an operating system for such a workstation typically provides a logon user interface. A user completes an authentication process through interaction with the logon user interface to gain access to the applications that are available to be executed on the workstation. It follows that the workstation may be considered to have a logged off system status and a logged on system status. Furthermore responsive to direct user instruction or due a period of inactivity the workstation may become locked. That is the workstation may present the logon user interface and require the user to complete the authentication process over again to return to accessing various applications executed by the workstation. The locked system status may be considered very similar to the logged off system status.

There are known to exist computer peripheral devices for which a workstation to peripheral connection may be established without regard for the system status of the workstation. Such connections have corresponding authentication protocols and therefore need not rely on the authentication protocols handled by the workstation operating system. Notably establishment of a workstation to peripheral connection generally requires user input and the workstation may require multiple user interface modules with a selection of a particular user interface module being dependent upon system status.

It has been discovered that a problem arises in a scenario wherein the workstation performs a transition from the logged on system status to the locked system status while establishment of a workstation to peripheral connection is ongoing. If while the workstation had the logged on system status the user had started but not completed establishing a workstation to peripheral connection the user may be prevented from establishing a workstation to peripheral connection once the workstation has the locked system status. It is likely in such a scenario that the application executed by the workstation to allow for the establishment of a workstation to peripheral connection awaits further user input which user input is prevented by the locked system status.

According to one example embodiment there is provided at a user interface module a method of facilitating user interface management. The method includes receiving a command message to cease execution transmitting a state information message to a user interface manager the state information message including a control state data structure and ceasing execution. In other aspects of the present application an apparatus is provided for carrying out this method and a computer readable medium is provided for adapting a processor to carry out this method.

According to another example embodiment there is provided a method of managing multiple user interfaces on a computing apparatus. The method includes receiving from a providing user interface module a control data structure describing a state of the providing user interface module storing the control data structure receiving from a requesting interface module a request for user interface state and transmitting to the requesting user interface module the control data structure. In other aspects of the present application an apparatus is provided for carrying out this method and a computer readable medium is provided for adapting a processor to carry out this method.

According to another example embodiment there is provided a method of managing user interfaces. The method includes receiving a state information message from a first user interface module storing the state information receiving a request for the state information from a newly operational interface module and responsive to the receiving the request transmitting the state information to the newly operational interface module. In other aspects of the present application a computing apparatus is provided for carrying out this method and a computer readable medium is provided for adapting a processor to carry out this method.

It is noted at www.wikipedia.org that in computing Winlogon is a component of Microsoft Windows operating systems that is responsible for handling a secure attention key loading a user profile on logon and optionally locking the computer when a screensaver is running requiring another authentication step . The obtaining and verification of user credentials is left to other components.

Winlogon handles interface functions that are independent of authentication policy. Winlogon creates desktops for the workstation implements time out operations provides a set of support functions for a Graphical Identification and Authentication GINA library and takes responsibility for configuring Group Policy for machine and user.

The GINA library is a component of some Microsoft Windows operating systems that provides secure authentication and interactive logon services. The GINA library is a dynamically linked library DLL that is loaded in the context of the Winlogon process when the machine is started. The GINA library is responsible for handling a secure attention sequence typically Control Alt Delete and interacting with the user when this sequence is received. The GINA library alternatively referred to as simply GINA is also responsible for starting initial processes for a user such as the Windows Shell when the user first logs on.

Winlogon is by default configured to use a default GINA. Winlogon can be configured to use a different GINA thereby providing for non standard authentication methods and or providing for a visual user interface that is different than the visual user interface that is provided by the default GINA.

A file representative of the GINA DLL is typically located in the System32 folder and can be replaced with a file representative of a customized GINA DLL that provides alternative user identification and authentication procedures such as those authentication procedures that depend on communication with a biometric peripheral device.

Exemplary non standard authentication methods may involve a smart card reader and may involve identifying a user based on biometrics. Developers who implement a replacement GINA provide implementations for a set of application programming interface API calls which cover functionality such as displaying a workstation locked dialog processing the secure attention sequence in various user states responding to queries as to whether or not locking the workstation is an allowed action supporting the collection of user credentials on Terminal Services based connections and interacting with a screen saver. The Winlogon component is solely responsible for calling these APIs in the GINA library.

A Windows service is an application that starts when the Windows operating system is booted and runs in the background as long as Windows is running. Windows provides an interface called a Service Control Manager SCM that manages creating deleting starting and stopping of services. An application that is to be registered as a service needs to be written in such a way that the application can handle messages start stop pause etc. from the SCM. Then in one or more API calls the name of the service and other attributes such as the description of the service may be registered with the SCM.

Windows services are by default run as a virtual user that is associated with an account called LocalSystem . Since LocalSystem is not a real user some challenges present themselves when user specific data needs to be stored by the service as there is no home directory for the user associated with the LocalSystem account.

The SCM maintains a database of registered services and includes information on how each service should be started. The SCM also enables system administrators to customize security requirements for each service and thereby control user access to the service.

If a given service is running in the context of the LocalSystem account and has an attribute known as the SERVICE INTERACTIVE PROCESS attribute the given service is known as an interactive service. An interactive service can display a graphical user interface GUI and receive user input.

It is known that running an interactive service under the context of the LocalSystem account may impose some risk and should generally be avoided. It has been suggested that if a service that is running on a multi user system must interact with a user the service should do so through a separate GUI module where the separate GUI module is run under the context of a user account. It has been further suggested that the separate GUI module should be designed to communicate with the service through some method of interprocess communication such as a named pipe. This combination of a separate GUI module with a service is known as a client server implementation and serves as an alternative to running an interactive service under the context of the LocalSystem account.

When it is necessary for a thread of a GUI module to transmit a message to a Windows service where the message requires a response the thread may create an entry on a thread map implemented for example as a map or a list. Each entry in the thread map may be considered to include a response type and a reference to a message transfer object. Examples of response types may include among other things a response to a version check request a response to a synchronize settings request and a response to a set IT policy request.

The message transfer object may contain a flag indicating whether a response has been received an event on which the thread should wait and a response data field to hold data received in the response. Events on which the thread should wait can for example include an outstanding response to a previous request. An event can for example be a handle.

Before sending a message for which a response is expected a sending thread first creates a message transfer object. The sending thread then places an entry in the thread map. Recall that the entry includes an indication of a unique response type i.e. the response type for which the sending thread will wait and a reference to the message transfer object. The sending thread then transmits the message. The sending thread then waits for an event where the event is receipt of a response message having the unique response type.

A single thread known as a receiver thread is responsible for reading incoming messages determining whether the incoming message is a response to a message sent by one of the sending threads and if so waking up the appropriate sending thread. The receiver thread idles until a message is received. Upon receiving an incoming message the receiver thread reads the message type of the incoming message. The receiver thread compares the message type of the incoming message against the response type of each entry in the thread map. If the receiver thread finds an entry in the thread map with a response type that matches the message type of the incoming message the receiver thread sets the response flag of the matching entry to true copies the incoming message into the response data field removes the entry from the thread map and signals the receipt of a response message event.

The sending thread may continue upon recognizing that the receipt of a response message event has occurred. Upon continuing the sending thread reviews the response flag in the message transfer object. If the response flag has a value of true then a response has been received and the response data field of the message transfer object may be expected to contain the response. If the response flag has a value of false then a response has not been received.

Separate user interface modules may exist as clients to a Windows service. For instance a first user interface module may be used as a first client to a given Windows service when the workstation has a logged off system status or a locked system status and a second user interface module may be used as a second client to the given Windows service when the workstation has a logged on system status. The first user interface module has a first message engine for handling messages between threads in the first user interface module and the given Windows service. Similarly the second user interface module has a second message engine for handling messages between threads in the second user interface module and the given Windows service.

Consider the case wherein the given Windows service communicates with a proximate device using the known Bluetooth communication protocol. Such a Windows service may require user interaction to select a device to which to connect and may further require user entry of a passkey. Also consider a scenario in which a user is in the midst of establishing a Bluetooth connection through the use of the second user interface module i.e. while logged on when the workstation locks. Conventionally the user would be unable to use the first user interface module i.e. the user interface module designed for use when the workstation has a locked system status to establish a Bluetooth connection while faced with the logon user interface because a thread in the second user interface module is still waiting for user input for transmitting to the Windows service responsible for establishing the Bluetooth connection.

In overview to police the user interface modules and direct messages to the correct user interface module a user interface manager module may be implemented. Responsive to a change in system status the user interface manager module determines the state of the first user interface module and transmits an indication of the state of the first user interface module to the second user interface module. Additionally the user interface manager module copies entries from a thread map associated with the first user interface module to a thread map associated with the second user interface module.

The first user interface receives the information message from the user interface manager and generates a request message . Rather than send the request message directly to the Windows service the first user interface module transmits the request message to the user interface manager .

Where the request message requires a response from the Windows service the first user interface module creates a message transfer object and places an entry in a thread map associated with the first user interface module where the entry includes a reference to the message transfer object. The user interface manager then forwards the request message to the Windows service .

A change in system status then occurs. Exemplary system status changes include logged off to logged on logged on to logged off logged on to locked and locked to logged on. The GINA library typically handles the event e.g. a secure attention sequence such as Control Alt Delete that leads to the change in system status. As such the GINA library handles the sending of a message indicating the change in system status to the user interface manager .

Responsive to receiving the message indicating the change in system status the user interface manager transmits step a state request message to the first user interface module . The first user interface module formulates a state response message by generating a control state data structure that includes the state of the first user interface module . The information included in the control state data structure may include an indication of which dialog is displayed an indication of which field of the dialog is in focus and an indication of the contents of all of the fields of the dialog. The first user interface module then transmits the state response message to the user interface manager .

Upon receiving step the state response message the user interface manager formulates a state update message to include the control state data structure received in the state response message . The user interface manager then transmits step state update message to the second user interface module . Additionally the user interface manager copies step entries from the thread map associated with the first user interface module to a thread map associated with the second user interface module such that the thread map associated with the second user interface will include a thread waiting for the response to the request message .

The Windows service then transmits a response message to the user interface manager where the response message is a response to the request message . The user interface manager receives the response message and based on the system status having changed selects the second user interface module as the destination.

A receiver thread of the second user interface module receives the response message from the user interface manager and matches the message type of the response message with the entry associated with the request message in the thread map associated with the second user interface module . The receiver thread then generates an event that wakes up the thread waiting for a response to the request message .

Returning to the case wherein the given Windows service is a Bluetooth connection service and the scenario in which a user is in the midst of establishing a Bluetooth connection through the use of the second user interface module. The user may have for instance used a device selection dialog of the second user interface module to select a proximate Bluetooth enabled device. Additionally the user may have for instance entered the first two digits of a four digit passkey in an alphanumeric entry field of a passkey entry dialog of the second user interface module before the workstation locked. Responsive to the locking of the workstation the user interface manager transmits a state request to the second user interface module and receives a state response. The state response includes a control state data structure that indicates that a passkey entry dialog was open that two digits have been received and the value of the two digits.

In the locked system status the user requests initiation of a user interface module. The user interface manager based on the locked system status selects and initiates the first user interface module. Additionally the user interface manager sends a state update message to the first user interface module. The state update message includes the control state data structure that indicates that a passkey entry dialog was open that two digits have been received in the alphanumeric entry field and the value of the two digits. Upon initiation the first user interface module presents the user with the passkey entry dialog showing in the alphanumeric entry field that two digits have been received. Conventionally the indication that a digit of a passkey has been received is accomplished with displaying in the alphanumeric entry field an asterisk . However other symbols may be used such as a period . or a bullet .

While the copying step of the thread map associated with the second user interface module to the thread map associated with the first user interface module provides enough information to allow a thread of the first user interface module to await completion of the entry of the passkey it is the information contained in the control state data structure received in the state update message that allows the first user interface module to present the passkey entry dialog in the state that the dialog was in at the time of locking.

Advantageously the above proposed solution allows the user to seamlessly use a dialog interface to interact with and provide input for a Windows service in multiple situations including the following when a user is logged on when the work station is locked and when no user is logged on.

As will be apparent to a person of ordinary skill in the art the user interface module designed for use when the system status is logged off locked may be integrated into a customized GINA library.

As an alternative to determining and transferring an indication of state of user interface module responsive to receiving a message indicating a change in system status from GINA the user interface manager may simply arrange to cancel the currently active threads of whichever user interface module is in use. Thereafter in the new system status the user may initiate interaction with the Windows service. Responsively the user interface manager selects the appropriate one of the user interface modules and the user enters data from the beginning.

Canceling step the currently active threads of the logged on user interface module may involve for instance removing each entry from the thread map associated with the currently active threads and generating events instructing each of the currently active threads to terminate. Such canceling may be considered equivalent to the reaction such a user interface module would have to a user selecting a Cancel button on a dialog presented by the user interface module. The result is that the user interface module returns to an idle state.

Advantageously once the logged on user interface module has returned to an idle state the logged on user interface no longer awaits further user input and a new user interface module may communicate with the Windows service without restriction.

In the new system status the user interface manager may again receive step a request to initiate a user interface to the Windows service. The user interface manager then determines step the status of the system. If the user interface manager determines that the system status is logged off or locked the user interface manager selects the logged off locked user interface module and initiates step the logged off locked user interface module. While the logged off locked user interface module is executing the user interface manager may determine step that a system status change message has been received. If the user interface manager determines step that a system status change message has been received the user interface manager arranges to cancel step the currently active threads of the logged off locked user interface module. If the user interface manager determines step that a system status change message has not been received the user interface manager continues to monitor for such receipt.

Although as presented in the exemplary steps of the method of there are only two user interface modules to choose between a person of ordinary skill in the art would recognize that a plurality of user interface modules may be made available one user interface module for each system status. As such selecting step a candidate user interface module to initiate based on the system status may be more complex than simply determining whether the workstation has logged on system status.

When transferring state information between the first user interface module for a logged on state and the second user interface module for a logged off or locked state on Windows XP which may for instance be the operating system executed by the processor in the workstation of there exists an ability to assume that both the first user interface module and the second user interface module associated with GINA are always running. With Windows VISTA which may for instance be the operating system executed by the processor in the workstation of we have an added complication that the credential provider which in Vista replaces the GINA that is used in XP is not always running. Instead the credential provider and consequently the second user interface module associated with the credential provider is only executed when the locked logged off screen is displayed and correspondingly ceases execution when the user unlocks logs on.

This makes transferring dialog state information trickier in Vista than in XP because for example we cannot simply transfer state information from the second user interface module associated with the credential provider to the first logged on user interface module when logging on since the second user interface module will cease execution before the first user interface module commences execution. To further complicate matters there exists a possibility that there will be threads related to the Windows service that are waiting on responses from the dialogs maintained by the second user interface module . As described hereinbefore thread map entries can be moved step from the thread map associated with the second user interface module to the thread map associated with the first user interface module . In the Vista case however a destination is not immediately available to which to move the waiting thread map entries since the second user interface module and the first user interface module are not executing simultaneously. When the credential provider ceases execution any threads that were waiting for responses from the second user interface module are cancelled.

An example of the current problem begins in a scenario wherein no users are currently logged in to the workstation of the credential provider is executing and the first logged on user interface module is not executing.

a A user initiates a connection process to connect the workstation to a smart card reader which connection process uses a dialog controlled by the second user interface module 

b Part way through the connection process the user logs into the workstation using a username and a corresponding password leaving the connection process in progress 

d The user interface manager attempts to copy the state of the connection process dialog from the second user interface module to the first user interface module and

e Since the first user interface module is not yet executing there is no destination to which to transfer the state so the connection process is cancelled.

It is likely that the user would prefer to continue the connection process from the point in the process at which the process was left. However in this case if the user wishes to complete the connection process the user is obliged to restart the connection process.

A similar problem exists when the user logs off in Vista and XP in the midst of a connection process. There exists a requirement to transfer the state from the first user interface module to the second user interface module but the second user interface module is not yet executing.

In overview the second user interface module responsive to receiving a command to terminate while processes are ongoing transmits state information to the user interface manager before self terminating. The user interface manager stores the state information in a memory or cache . That is the user interface manager caches the state information. In addition the user interface manager may transfer the thread map entries associated with the second user interface module to the user interface manager to be cached. Subsequently when the first user interface module commences operation and contacts the user interface manager the user interface manager responds with the cached state information and transfers thread map entries from the cache to the thread map associated with the first user interface module .

The user interface manager holds the latest known state information in a cache and both the first user interface module and the second user interface module may retrieve the state information whenever the state information is required. Also both the first user interface module and the second user interface module are provided with a capability to update the cache at the user interface manager at anytime.

Rather than directly moving entries in one thread map to another thread map as was proposed in step it is now proposed to maintain in the user interface manager a cache of thread map entries until the entries may be transferred to the thread map associated with another user interface module. Such a transfer may take place in association with a transfer of state information to the other user interface module.

The user interface manager receives step the state information message transmitted by the second user interface module and stores step the state information. The user interface manager also moves step the thread map entries associated with the second user interface module to the cache. Subsequently responsive to the login by the user that caused the termination of the credential provider and the associated second user interface module the first user interface module commences operation and transmits a request message to the user interface manager . The user interface manager receives step the request message and responds by transmitting step a state response message including cached state information that had been earlier received from the second user interface module . Furthermore the user interface manager moves step the thread map entries from the cache to a thread map associated with the first user interface module which thread map entries had been earlier cached from the second user interface module .

a After initiating but not completing a connection process between the smart card reader and the workstation a user initiates a login process with a username and password combination to log in to the workstation of 

b The second user interface module associated with the credential provider detects that it is being terminated and transmits step a state message which includes the state of the connection process to the user interface manager 

c The user interface manager caches step the state of the connection process and also caches step the thread map entries 

d The first user interface module transmits to the user interface manager a request message requesting the current UI state 

e The user interface manager transfers the cached thread map entries to the thread map associated with the first user interface module so that the threads are waiting for responses from the appropriate UI module and

As will be apparent to a person of ordinary skill in the art instead of only two user interface modules the first user interface module and the second user interface module there can be many user interface modules. There are also two classes of UI information stateless UI information and thread associated UI information. Stateless UI information generally comprises any UI information that does not have a thread waiting on its response an information message box for example. Thread associated UI information generally comprises any UI information related to a thread that is waiting for a response as well as the semaphore responsible for blocking the thread.

Any user interface module can retrieve stateless UI information from the cache at the user interface manager and create a display based on the stateless UI information. Furthermore any user interface module can update the stateless UI information. Only one user interface module e.g. the active user interface module can access the thread associated UI information as well as the threads that go with the thread associated UI information checked out from the cache and only the active user interface module can check the thread associated UI information back into the cache. Once checked in another user interface module can check out the thread associated UI information.

In some cases neither a GINA library nor a credential provider may be installed on a workstation. GINA and credential provider are components whose installation is optional during the installation of Windows. Consequently a user interface module associated with GINA or the credential provider may never execute.

Consider the case wherein a message a user interface dialog is displayed on a workstation with timing associated with a user of the workstation walking away from the workstation such that the user does not see the message. The message could be important for instance the message could indicate that another device has paired with the user s smart card reader.

It is anticipated that the user may have previously established an option according to which the user is logged out of the workstation upon removal of a smart card. The user walks away from the workstation and the workstation logs off the user. Since neither GINA nor CP is installed the smart card application UI is not transferred to the logoff screen. Accordingly the user does not see the important message.

Where aspects of the present application are implemented at the workstation the scenario may proceed as follows 

a As the user walks away from the workstation a wireless connection between the workstation and a smart card reader associated with the user terminates due to an out of range condition the processor interprets the loss of connection to the smart card reader as a removal of a smart card in the reader and the processor initiates a logoff operation 

b The first user interface module detects the initiation of the logoff operation and transmits a state message and a thread message to the user interface manager before ceasing execution 

c The user interface manager receives step the state message caches step the UI state included in the state message receives step the thread message and caches step included information on threads and locks 

e Execution of the first user interface module recommences and the first user interface module transmits a request message to the user interface manager 

f Upon receiving a response to the request message the response including state information the first user interface module redisplays the user interface view that was on the display before the user was logged off the workstation .

Workstation security is improved because there is no availability for an attacker to dismiss a pairing notification message from the workstation lock screen. Before being able to interact with the notification message the user must first authenticate to the workstation using appropriate login information.

It is further contemplated that the user interface module manger could store the state information and thread map entries in a hash table so that cached state information or thread map information can be specific to distinct users of the workstation .

As will be clear to a person of ordinary skill in the art although the above embodiments are centered around a workstation executing a Windows operating system aspects of the disclosure may be applicable to the facilitation of user interface management for handheld computing devices and other mobile communication devices.

The above described embodiments of the present application are intended to be examples only. Alterations modifications and variations may be effected to the particular embodiments by those skilled in the art without departing from the scope of the application which is defined by the claims appended hereto.

