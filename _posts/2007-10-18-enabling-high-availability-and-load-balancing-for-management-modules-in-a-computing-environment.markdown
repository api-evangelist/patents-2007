---

title: Enabling high availability and load balancing for management modules in a computing environment
abstract: Provided is a method for programming module load balancing and failover in a distributed computing environment. The Java Management extensions (JMX) specification is enhanced to support load balancing and provide a high-availability of JMX management beans (Mbeans). Also provided are enhancements to the programming model and infrastructure to support the enhanced programming model. Two exemplary approaches for load balancing and failover are provided, one based both upon clustered Mbeans and one based upon unclustered Mbeans. In the unclustered approach, client affinity is supported in that a request from a particular client can be routed to a particular Mbean. In the clustered approach, a specific Mbean can be invoked by providing a special parameter in the Mbean invocation or by adding a special property to the specific Mbean's ObjectName to indicate that during runtime automatic routing should not be employed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07603256&OS=07603256&RS=07603256
owner: International Business Machines Corporation
number: 07603256
owner_city: Armonk
owner_country: US
publication_date: 20071018
---
The present application is a continuation and claims the benefit of the filing date of an application entitled Enabling High Availability and Load Balancing for JMX Mbeans Ser. No. 11 420 019 filed May 24 2006 now U.S. Pat. No. 7 295 952 assigned to the assignee of the present application and herein incorporated by reference.

The present invention relates generally to a computing system and more specifically to a method for providing load balancing and resource reliability in a distributed computing environment.

For the past several decades computers have become increasingly connected. Originally computers were stand alone devices each typically designed and programmed for a specific task. Soon however the advantages of combining computers into networks became apparent. Networks of computers were able to share resources such as printers and memory and eventually even able to share or distribute processing tasks. For example a search of a large database can often be broken into multiple mutually exclusive tasks by assigning different processors and or computers to search different segments of the database.

As computers have become increasingly interconnected techniques have been developed to enable multiple computers to work together. One such development is Java a high level programming language originally developed by Sun Microsystems Inc. of Mountain View Calif. Java enables programmers to develop code that is platform independent. Simply stated code written in the Java programming language is converted or interpreted into actual computer instructions corresponding to a particular computer by a Java Virtual Machine JVM that executes on the computer. In other words by installing a JVM that corresponds to particular computer hardware and the associated operating system a programmer can write code without regard to the particular hardware and operating system.

In addition to the increased connectivity of traditional computers many devices that incorporate computing components have also become both inter connected and Java enabled. Examples include Internet or web telephones cable boxes and televisions and application clients and servers. To facilitate the management of such Java enable resources Java Management Extensions JMX has been developed. JMX is a standard for managing and monitoring devices applications and services in a Java environment. JMX defines a management architecture design patterns application programming interfaces APIs and services for building web based distributes dynamic and modular solutions to manage Java resources.

JMX provides for the creation and implementation of Java managed beans or Mbeans which are programming objects that represent objects to be managed. Each Mbean has a management interface that enables a user or program to monitor manage and be notified of changes to particular configuration parameters of a corresponding resource. For example an Mbean representing an application may include attributes and methods corresponding to the application s cache size. In this example reading a cacheSize attribute would return the application s cache size and writing a cacheSize attribute would update the size of the application s cache thus changing the application s configuration.

Although the JMX specification has been updated to include invocation between client and server in a distributed environment the specification still does not address any type of load balancing or contingencies in the event an Mbean fails to execute. What are needed are techniques to address Mbean load balancing and failover.

Provided is a method for programming module load balancing and failover in a distributed computing environment. The following examples address how the Java Management extensions JMX specification can be enhanced to support load balancing and provide a high availability of JMX management beans Mbeans . Included in the following disclosure are enhancements to the programming model and infrastructure needed to support the enhanced programming model.

Two exemplary approaches and multiple scenarios for load balancing and failover based upon clustered and unclustered Mbeans respectively are described. In one scenario of the unclustered Mbean approach there is a single instance of an Mbean in which when that single instance fails another instance of the Mbean is created either on the same or a different server. The new instance of the Mbean is accessed using the same ObjectName as the original Mbean.

In a second scenario of the unclustered Mbean approach multiple similar Mbeans may be instantiated with one of the Mbeans designated to process all requests. The remaining Mbeans serve as backups and in the event of a processing request failure one of the remaining Mbeans is designated to process requests. Client affinity is supported in that a request from a particular client is routed to a particular Mbean until such time as that particular Mbean fails. In the unclustered approach each Mbean is referenced by a unique ObjectName property. However regardless of the ObjectName used the invocation reaches the current Mbean processing the requests.

In one scenario of a clustered approach to load balancing one or more logical ObjectName properties are employed to identify a cluster of Mbeans. The user of a particular Mbean does not need to be aware of either where an Mbean is located or how many Mbeans are within a particular cluster. A query or command directed to a particular ObjectName results in a single result from a single Mbean.

In a second scenario of the clustered approach to load balancing each Mbean in a particular cluster has a unique ObjectName property but each Mbean shares a particular naming pattern. When querying the cluster all Mbeans whose ObjectName properties that include a pattern of the query may return a result. When invoking an Mbean all ObjectNames that include a particular pattern are equivalent in that a runtime infrastructure routes a request to an available Mbean regardless of the ObjectName used for the request. A specific Mbean in a cluster can be invoked by providing a special parameter in the Mbean invocation or by adding a special property to the specific Mbean s ObjectName to indicate that during runtime automatic routing should not be employed.

Although described with particular reference to the Java Management Extensions JMX standard the claimed subject matter can be implemented in any information technology IT system in which load balancing and resource reliability is desirable. Those with skill in the computing arts will recognize that the disclosed embodiments have relevance to a wide variety of computing environments in addition to those described below. Further although described with respect to Java management beans MBeans and the JAVA environment the claimed subject matter also is applicable to modules applications or any other type of interdependent computer logic. In other words the disclosed technology is applicable to any situation in which there is interdependent computer code and a user or developer needs or wants to ensure that the computing environment is highly reliable.

In addition the methods of the disclosed invention can be implemented in software hardware or a combination of software and hardware. The hardware portion can be implemented using specialized logic the software portion can be stored in a memory and executed by a suitable instruction execution system such as a microprocessor personal computer PC or mainframe.

In the context of this document a memory or recording medium can be any means that contains stores communicates propagates or transports the program and or data for use by or in conjunction with an instruction execution system apparatus or device. Memory and recording medium can be but are not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device. Memory an recording medium also includes but is not limited to for example the following a portable computer diskette a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or flash memory and a portable compact disk read only memory or another suitable medium upon which a program and or data may be stored.

Turning now to the figures is a block diagram of an exemplary computing system architecture that incorporates the claimed subject matter. A central processing unit CPU is coupled to a monitor a keyboard and a mouse which together facilitate human interaction with computing system . Attached to CPU is a data storage component which may either be incorporated into CPU i.e. an internal device or attached externally to CPU by means of various commonly available connection devices such as but not limited to a universal serial bus USB port not shown . Data storage is illustrated storing several exemplary Java Management bundles or Mbeans including a first Mbean or Mbean  a second Mbean or Mbean  a third Mbean or Mbean  and a fourth Mbean or Mbean A . The significance of the names of Mbeans and with respect to the following description is explained in more detail below in conjunction with . It should be noted that a typical application or system may include many Mbeans but for the sake of simplicity only four are shown.

CPU is connected to the Internet which is also connected to a server computer . Although in this example CPU and server are communicatively coupled via the Internet they could also be coupled through any number of communication mediums such as but not limited to a local area network LAN not shown .

As mentioned above in this example OS is supporting JXE and JXE supports the Java programming language which is a product of Sun Microsystems Inc. of Santa Clara Calif. JXE includes a Java runtime engine JRE not shown which executes Java programs Java programs are compiled into byte codes which are interpreted by the JRE of JXE rather then being compiled into native machine code. In this manner a particular Java program can be written to execute on any hardware platform and OS that includes the JXE .

JXE provides an execution environment for among other things Mbeans which in this example include Mbean  Mbean  Mbean  and Mbean A . In the following description Mbeans and are used as examples of Mbeans grouped into an Mbean cluster as indicated by the fact that they are named according to a particular convention i.e. Mbean  which indicates that the names are composed of the word Mbean a   character and a numeric character. In the following description Mbean A is used as an example of a single instance of an unclustered Mbean as indicated that the fact that the term Mbean A does not follow the pattern for defining the cluster associated with Mbeans and i.e. the character A is not numeric. Although Mbeans and are illustrated as all residing on hardware platform each of Mbeans and could be located on different platforms e.g. stored in memory not shown associated with server and executed on server .

Another exemplary piece of information that may be associated with a particular Mbean is whether or not the methods of the Mbean are retryable. A particular method is retryable if a second call with parameters identical to a first call may yield the same or different yet relevant results. One example is an Mbean that returns performance statistics that change from moment to moment.

During a Clustered block process determines based upon the information received during block whether or not the registration request received during block corresponds to an Mbean that is organized as part of a cluster of Mbeans. If so process proceeds to a Max Exceeded block during which process determines whether or not the cluster to which the target Mbean has a upper limit upon the number of Mbeans that can be instantiated in conjunction with the cluster and if so whether or not that maximum would be exceeded by instantiating the target Mbean. If the maximum would be exceeded process proceeds to a Throw Exception block during which process takes action appropriate to the circumstances. An example of such action may be to transmit a message to the user or program that initiated process . Once the exception has been thrown process proceeds to an End Register Mbean block in which process is complete. It should be noted that the execution path represented by blocks and does not result in the instantiation of the target Mbean.

If during block process determines that the instantiation of the target Mbean would cause any parameters to be exceeded control proceeds to an Assign to Cluster block during which the target Mbean is associated with the appropriate cluster. For example if the target Mbean is Mbean  and Mbean  has already been instantiated then Mbean  is associated with Mbean  .

If process determines during block that the target Mbean is not part of a cluster of Mbeans or once the target Mbean is associated with a cluster during block process proceeds to a Store Parameters block during which process stores in memory the parameters associated with the metadata received during block . During an Update Counts block process updates any system parameters that may be affected by the instantiation of the target Mbean. For example the number of Mbeans within a particular cluster is updated so that the system can prevent the number of Mbeans in the cluster from exceeding some maximum number.

During a Load Mbean block process calls an initiator method associated with the target Mbean which is then loaded into the system. Finally process proceeds to End Register Mbean block in which as explained above process is complete.

Process then proceeds to a Multiple Instances block during which process determines whether or not there are multiple instantiations of the Mbean. If not process proceeds to a Transmit Request block during which the request received during block is transmitted to the subject Mbean. As explained above in conjunction with the existence of multiple instances of a particular Mbean implies that the Mbean is either associated with a cluster of Mbeans or one of two or more instantiations of the same Mbean. Whether or not a particular Mbean is associated with a cluster may be determined on the basis of metadata provided during register Mbean process or inferred from specified naming conventions.

If during block process determines there are multiple instances of Mbeans either in as part of a cluster of Mbeans or multiple instances of a particular Mbean process proceeds to an Assign to Instance block . During block process selects a particular instantiation to which to transmit the request received during block . As explained above in conjunction with the Summary JXE typically determines a particular Mbean instance to which to transmit the request based upon load balancing factors for clustered Mbeans or upon which particular Mbean is currently processing requests for un clustered Mbeans.

Those with skill in the computing arts should appreciate that there are several possible load balancing schemes and how various factors are employed to execute any particular scheme. The claimed subject matter also supports client affinity or in other words a specific Mbean in a cluster can be invoked by providing a special parameter in the Mbean invocation. Once the request received during block is assigned to particular Mbean process proceeds to block during which as described above the request is transmitted to the appropriate Mbean.

During a Request Successful block process determines whether or not the request transmitted during block was successfully completed. If not process proceeds to a transition point A. Transition point A leads to an execution path described in more detail below in conjunction with . The execution path described in conjunction with reenters the portion of process described in conjunction with at block from a transition point B or at an End Invoke Mbean block from a transition point C.

If during block process determines that the request transmitted during block was executed successfully process proceeds to a Transmit Result block during which the result of the operation typically either requested information or a signal that the request has been successfully completed is transmitted to the user program or Mbean that initiated the request received during block . Process then proceeds to End Invoke Mbean block in which process is complete.

If during block path determines that a retry of the invoked method is allowed control proceeds to a Limits Exceeded block during which path determines whether or not the targeted Mbean has reached a limit on the number of permissible retries. This limit may be either a system limit or defined for a particular Mbean or Mbean cluster. The purpose of a retry limit is to prevent an endless loop of retries to a particular broken or unavailable Mbean or cluster of Mbeans. If path determines that the retry limit has been exceeded control proceeds to Throw Exception block and processing continues as described above.

If during block path determines that the retry limit has not been exceeded control proceeds to a Multiple Instances block during which path determines whether or not the target Mbean has multiple copies available for processing. If so path proceeds to Identify Mbean block during which path identifies a copy of the target Mbean. The multiple copy identified can be either one of a cluster associated with the targeted Mbean or in an unclustered configuration an available backup member associated with the targeted Mbean. Path proceeds to Retransmit Request block during which the request method is invoked in an Mbean identified during block .

If during block path determines that there are not duplicate copies of the target Mbean path proceeds to a Spawn New Instance block during which path attempts to spawn or load a new copy of the target Mbean see process . Path then proceeds to a Spawn Successful block during which path determines whether or not the attempt to spawn a new Mbean was successful. If not control proceeds to Throw Exception block during which processing continues as described above. If in block path determines that a new Mbean has been successfully loaded then control proceeds to Retransmit Request block during which the requested method is invoked in an Mbean either loaded during block or identified during block . Finally control proceeds from block to Request Successful block via transition point B and processing continues as described above in conjunction with .

While the invention has been shown and described with reference to particular embodiments thereof it will be understood by those skilled in the art that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the invention including but not limited to additional less or modified elements and or additional less or modified blocks performed in the same or a different order.

