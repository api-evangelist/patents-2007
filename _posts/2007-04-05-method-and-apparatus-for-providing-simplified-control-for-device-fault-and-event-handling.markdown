---

title: Method and apparatus for providing simplified control for device fault and event handling
abstract: A method identifies, prior to runtime, a first device that is added to a system. Further, the method generates, prior to runtime, a statically precompiled database for the device that provides a first set of error handling data. In addition, the method identifies, during runtime, a second device that is added to the system. Finally, the method generates, during runtime, a dynamically allocated database for the second device that provides a second set of error handling data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694185&OS=07694185&RS=07694185
owner: General Instrument Corporation
number: 07694185
owner_city: Horsham
owner_country: US
publication_date: 20070405
---
This application claims priority to U.S. Provisional Application Ser. No. 60 777 731 entitled Method and Apparatus for Providing Simplified Control for Device Fault and Event Handling filed on Feb. 28 2006 the content of which is incorporated herein by reference in its entirety.

This disclosure generally relates to the field of systems. More particularly the disclosure relates to device error and fault handling.

Most embedded computerized systems include a number of devices that are focused on specialized functionalities for a particular system. The devices may be hardware devices such as a set top box cable modem or any other hardware device known to one skilled in the art. Further the devices may also be software components that are added to the system.

Software development for an embedded computerized system may involve controlling and configuring the hardware components within a device to interpret the incoming radio frequency RF signals and generate signals in MPEG2 format for television broadcasting. However any of the hardware components can degenerate or malfunction. As a result a hardware component may not perform the intended functionality. A safe run of the hardware devices can be performed to test whether the hardware devices are operating properly. For instance an internal auditing task may continuously run in the background to assess the health status of a hardware device. If a faulty hardware device is detected the reporting of the error to the end user may be very complicated based on the number of errors that could be the cause of the hardware device not working properly.

Event though a software project is essentially complete once the core software code has been developed the time frame for device fault and event handling is often significant. Further significant additional resources are often needed for analysis and preparation of code for the device fault and event handling.

In one aspect of the disclosure a method is disclosed. The method identifies during runtime a device that is added to a system. Further the method generates during runtime a dynamically allocated database for the device that provides error handling data in a tabular format.

In another aspect a method is disclosed. The method identifies prior to runtime a first device that is added to a system. Further the method generates prior to runtime a statically precompiled database for the device that provides a first set of error handling data. In addition the method identifies during runtime a second device that is added to the system. Finally the method generates during runtime a dynamically allocated database for the second device that provides a second set of error handling data.

In yet another aspect a method is disclosed. The method identifies prior to runtime a first device that is added to a system. Further the method generates prior to runtime a statically precompiled database for the device that provides a first set of error handling data in a first tabular format. In addition the method identifies during runtime a second device that is added to the system. Finally the method generates during runtime a dynamically allocated database for the second device that provides a second set of error handling data in a second tabular format.

A method and apparatus are disclosed which provide simplified control for device fault and event handling. The method and apparatus may be utilized to simplify the often complicated and tedious task of handling a potentially enormous number of errors that could occur within the system. A table driven algorithm is utilized to handle the control of fault and the recovery. As a result the amount of coding for identifying the hardware origin of an error deciding the appropriate time to act on the error executing the error and recovering from the error in all of the potential error scenarios is reduced.

A table having a pre defined data structure type may be created for each of the hardware devices. A pre defined data structure type may be composed for each of the hardware interfaces supported by the system . Accordingly the utilization of a table for each of the devices allows errors to be grouped for each of the identified hardware devices. As a result device fault and event handling issues can be systematically resolved more quickly and with fewer resources.

During the system power up sequence the system discovers each of these devices and a corresponding interface for the respective device. Each of the discovered device interfaces registers itself with an event handling manager in the system . The event handling manager can be implemented as a task thread process module component etc. in the system . Once a device is registered the pre defined table for the hardware interface corresponding to the device is retrieved. A copy of the pre defined table is then generated. Further the copy of the pre defined table is then populated with known values for handling all the potential errors for the particular hardware interface.

The table also has a set of known values that are populated for each of the predefined fields corresponding to an error and a hardware interface. For instance the event error id X event error id X thresh count X reset count X timer count X error message X and alarm event X are known values that are populated for the potential error X for the particular hardware interface. As a result a set of events to identify and correct the potential error X is preplanned. Similarly sets of events can be preplanned to identify and correct the potential error Y and the potential error Z . If a distinct table is generated for a different hardware interface that also has the potential error X a different set of known values e.g. event error id X event error id X thresh count X reset count X timer count X error message X and alarm event X may be utilized to deal with the particular nuances of that hardware interface.

The predefined fields in the table are utilized because they provide helpful information to simplify control for device fault and event handling. In another embodiment additional or different fields may be utilized.

In yet another embodiment a subset of all the potential errors that may occur for the particular hardware interface is pre defined in the table . A subset may be utilized because of the difficulty in identifying all the potential errors or size constraints for storing a large number of potential errors.

In one embodiment a table is generated for each identified hardware interface. Accordingly the pre defined data structure for one hardware interface may be different than another hardware interface. In other words a different set of errors and values may be pre defined and populated for different hardware interfaces.

In one embodiment the event managing handler composes a table for each hardware device and stores the table in the statically precompiled database or the dynamically allocated database . The table lists the potential errors for the hardware device. The event managing handler utilizes routines in the API to compose a table for a hardware device with a fixed configuration. The event managing handler retrieves data for the particular hardware device with the fixed configuration from a hardware interface database . In one embodiment the event managing handler retrieves the data by calling a routine in the API . The event managing handler then predetermines events and corresponding responses for errors of the particular hardware device with the fixed configuration. Finally the event managing handler composes a table with the predetermined events and corresponding responses for storage in the statically precompiled database .

The API may have various routines that may be utilized by the event managing handler and or module tasks in the system kernel . For example a routine entitled EVENT MGR CPU REGISTER may be utilized to associate the statically precompiled database with a central processing unit CPU hardware database. In one embodiment the statically precompiled database is a static error tracking and error responding database predefined at compiling time. Accordingly the EVENT MGR CPU REGISTER routine may be utilized to associate the statically precompiled database with the CPU hardware database for tracking down runtime software errors. In addition a routine entitled EVENT MGR CPU RESOURCE REGISTER may be utilized to associate the statically precompiled database with a CPU resource hardware database to control the operational state of the system initiated by the user. Other and or different routines may be utilized as the routines are provided above for illustrative purposes. Further a routine entitled EVENT MGR ALARM PANEL REGISTER may be utilized to associate the statically precompiled database with the components of an Alarm Panel hardware database to track down errors detected against Alarm Panel hardware.

Conversely the event managing handler may also utilize routines in the API to compose a table for a hardware device having an interface discovered at the time of system power up. At the time of system power up the event managing handler identifies any newly added devices to the system and retrieves data the particular hardware device during runtime from the hardware interface database . In one embodiment the event managing handler retrieves the data by calling a routine in the API . The event managing handler then predetermines events and corresponding responses for errors of the particular newly added hardware device. Finally the event managing handler composes a table with the predetermined events and corresponding responses for storage in the dynamically allocated database .

The API may also have various routines to register newly identified hardware devices. For example the API may have a routine entitled EVENT MGR MUX REGISTER that is utilized when a multiplexer MUX DSP is discovered. In one embodiment the dynamically allocated database is a dynamic error tracking and error responding database generated at runtime when a particular device is discovered. The EVENT MGR MUX REGISTER routine may be utilized to register the dynamically allocated database for the particular MUX DSP. In another embodiment multiple copies of the dynamically allocated database may be utilized for multiple devices such as multiple MUXs or any other device. The API may also have a routine entitled EVENT MGR QLP REGISTER that is utilized when a QuantiLization Processor QLP DSP is discovered. The EVENT MGR QLP REGISTER routine may be utilized to register the dynamically allocated database for the particular QLP DSP. Further the API may also have a routine entitled EVENT MGR TPE REGISTER that is utilized when a Transcoding Processing Element TPE is discovered. The EVENT MGR TPE REGISTER routine may be utilized to register the dynamically allocated database for the particular TPE DSP. In addition the API may also have a routine entitled EVENT MGR INP REGISTER that is utilized when an input board is discovered. The EVENT MGR INP REGISTER routine may be utilized to register the dynamically allocated database for the particular input board DSP.

Further the API may provide routines that are potentially accessed for both the statically precompiled database and the dynamically allocated database . For example the API may have a routine entitled EVENT MGR MSG FOUND that may be utilized as the entry point for the error handling and responding. Each error is updated to its own database e.g. the statically precompiled database or the dynamically allocated database for the corresponding device. The accumulated error counts are checked against a predefined threshold. Increased severity level is raised each time the predefined threshold is reached and the corresponding device database is updated. When the error reaches an allowed severity level a predefined message is generated and sent to all the devices that are listening. A corrective action may also be taken to prevent the system from malfunctioning.

As an example an interface for a first hardware device may be detected by the event managing handler prior to runtime. Further the event managing handler determines that the first hardware device has a fixed configuration. Accordingly the event managing handler may construct a table for the first hardware device by searching through the hardware interface database and generating the statically precompiled database with the table . Further a registration is performed to link the hardware interfaced database with the statically precompiled database . In another embodiment the statically precompiled database already exists and the event managing handler adds the table to the existing statically precompiled database . At a time when an error for the first hardware device is encountered the event managing handler may retrieve the predetermined response for the predetermined event from the table. A module task in the system kernel may call a routine from the API that is provided to the module task by the event managing handler to initiate the predetermined response for the predetermined event indicated in the table.

Further an interface for a second hardware device may be detected by the event managing handler during runtime. The event managing handler detects a new interface for a hardware device during system power up. Accordingly the event managing handler may construct a table for the second hardware device by searching through the hardware interface and generating during runtime the dynamically allocated database . Further a registration is performed to link the hardware interfaced database with the dynamically allocated database . At a time when an error for the second hardware device is encountered the event managing handler may retrieve the predetermined response for the predetermined event from the table . A module task in the system kernel may call a routine from the API that is provided to the module task by the event managing handler to initiate the predetermined response for the predetermined event indicated in the table.

In one embodiment the errors detected by the system may be posted to a task e.g. a task entitled eventMgrTask. The error code from the faulty module is utilized by the eventMgrTask to update the database of the module raise the severity post the offending alarm to the corresponding hardware interface database and communicate to the peer device if the module becomes non operational.

Various data structures may be utilized to implement the databases and table discussed above. The following code is provided for illustrative purposes of code that may be utilized for the data structures and flow control 

It should be understood that the device fault and event handling module may be implemented as one or more physical devices that are coupled to the processor through a communication channel. Alternatively the device fault and event handling module may be represented by one or more software applications or even a combination of software and hardware e.g. using application specific integrated circuits ASIC where the software is loaded from a storage medium e.g. a magnetic or optical drive or diskette and operated by the processor in the memory of the computer. As such the device fault and event handling module including associated data structures of the present invention may be stored on a computer readable medium e.g. RAM memory magnetic or optical drive or diskette and the like.

It is understood that the simplified control for device fault and event handling described herein may also be applied in other types of systems. Those skilled in the art will appreciate that the various adaptations and modifications of the embodiments of this method and apparatus may be configured without departing from the scope and spirit of the present method and system. Therefore it is to be understood that within the scope of the appended claims the present method and apparatus may be practiced other than as specifically described herein.

