---

title: Locked element for use in a graphical modeling environment
abstract: In a graphical modeling environment, a method of providing varying levels of protection relating to functionalities associated with at least some elements of a block diagram model, the method including: receiving a selection of one of the elements; receiving an indication of a desired authorization required to use at least one function of the selected element; implementing the indicated authorization for the use of the at least one function; and preventing, without obtaining of the authorization, an attempted use of the at least one function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08707190&OS=08707190&RS=08707190
owner: The MathWorks, Inc.
number: 08707190
owner_city: Natick
owner_country: US
publication_date: 20070820
---
This application is a continuation of U.S. patent application Ser. No. 11 227 462 filed Sep. 15 2005 the disclosure of which is hereby incorporated by reference herein.

The present invention relates to a graphical modeling environment for modeling a static or dynamic system. More particularly the present invention relates to providing a locked element that requires authorization to access the functionality of the locked element.

Many organizations are embracing the paradigm of Model Based Development in their production processes. Model Based Development refers to the practice of specifying analyzing and implementing systems using a common model consisting of a set of block diagrams and associated objects. System implementation typically consists of automatically generating code for portions of the model particularly portions corresponding to the system s control algorithm or other functions implemented in software.

Graphical modeling environments are programs that enable a user to construct and analyze a model of a process or system. Examples of graphical modeling formalisms include time based block diagrams such as Simulink from The MathWorks Inc. discrete event diagrams and reactive state machine diagrams such as those found within Stateflow also available from The MathWorks Inc. data flow diagrams such as LabVIEW available from National Instruments Corporation and software diagrams and other graphical programming environments such as Unified Modeling Language UML diagrams.

Some graphical modeling environments also enable simulation and analysis of models. Simulating a dynamic system in a graphical modeling environment is typically a two step process. First a user creates a graphical model such as a block diagram of the system to be simulated. A graphical model may be created using a graphical user interface such as a graphical model editor. The graphical model depicts relationships between the systems inputs states parameters and outputs. After creation of the graphical model the behavior of the dynamic system is simulated using the information entered into the graphical model and information available in its environment such as files and variables in a general purpose workspace. In this step the graphical model is used to compute and trace the temporal evolution of the outputs of the dynamic systems execute the graphical model . Furthermore it may automatically produce either deployable software systems or descriptions of hardware systems that mimic the behavior of either the entire model or portions of the model code generation .

Block diagrams are graphical entities having an executable meaning that are created within graphical modeling environments for modeling static and dynamic systems and generally comprise one or more graphical objects. For example a block diagram model of a dynamic system is represented schematically as a collection of graphical objects such as nodes that are interconnected by edges generally depicted as lines which represent relations between the graphical objects that are connected to each of the edges.

In one subset of block diagramming paradigms the nodes are referred to as blocks and drawn using some form of geometric object e.g. circle rectangle etc. . The line segments are often referred to as signals . Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant when connected to an enabled node. Each node may represent an elemental dynamic system and the relationships between signals and state variables are defined by sets of equations represented by the nodes. Inherent in the definition of the relationship between the signals and the state variables is the notion of parameters which are the coefficients of the equations. These equations define a relationship between the input signals output signals state and time so that each line represents the input and or output of an associated elemental dynamic system. A line emanating at one node and terminating at another signifies that in terms of computational causality the output of the first node is an input to the second node. Each distinct input or output on a node is referred to as a port. The source node of a signal writes to the signal at a given time instant when its system equations are solved. The destination node of this signal reads from the signal when their system equations are being solved. Those skilled in the art will recognize that the term nodes does not refer exclusively to elemental dynamic systems but may also include other modeling elements that aid in readability and modularity of block diagrams.

It is worth noting that block diagrams are not exclusively used for representing time based dynamic systems but also for other models of computation. For example in Stateflow flow charts are block diagrams used to capture behavior of reactive systems and the flow of discrete state changes. Data flow models are block diagrams that describe a graphical programming paradigm where the availability of data is used to initiate the execution of blocks where a block represents an operation and a line represents execution dependency describing the direction of data flowing between blocks.

In some instances a user may wish to prevent others from using an element or block without authorization. As such a user may wish to lock access to the functionality of an element such that the locked element may be displayed in the graphical modeling environment but authorization is required in order to execute or simulate using the locked element.

In some instances a user may wish to limit the amount of functionality. In such instances authorization may be required to access the implementation details of a locked element. For example a user may wish to share an element or a block diagram model with a third party. While the third party may need the element to function as part of a block diagram model the user may not wish the third party to have access to the implementation details of the element. For example the user may wish to provide a black box block element that can function as part of a block diagram model but does not provide the third party access to underlying functionality or implementation details of the element.

One embodiment of the present invention provides a locked element that displays within a block diagram model but requires authorization to access the functionality of the element.

In accordance with one aspect a computer readable medium configured to store instructions executable by at least one processor to cause the at least one processor to provide a plurality of blocks having associated functionalities related to operation of a block diagram model in a graphical modeling environment and limit subject to one or more different authorizations one or more corresponding functionalities of at least one of the blocks wherein the one or more different authorizations comprise at least two levels of authorization for at least two different functionalities of the at least one block.

In accordance with another aspect a graphical modeling application includes means for depicting operational relationships at least partially defined by functions associated with among a plurality of elements means for rendering the elements as part of a block diagram model and means for implementing access authorization for at least one the functions of at least one of the elements.

In accordance with another aspect in a graphical modeling environment a method of providing varying levels of protection relating to functionalities associated with at least some elements of a block diagram model the method includes receiving a selection of one of the elements receiving an indication of an authorization required to use at least one function of the selected element implementing the indicated authorization for the use of the at least one function and preventing when the authorization is not obtained use of the at least one function.

An illustrative embodiment of the present invention relates to a locked element that displays within a block diagram model but requires authorization to access the functionality of the element. The present invention will be described relative to illustrative embodiments. Those skilled in the art will appreciate that the present invention may be implemented in a number of different applications and embodiments and is not specifically limited in its application to the particular embodiments depicted herein.

For example the memory holds a diagramming application capable of creating and simulating computational versions of system diagrams such as time based block diagrams state diagrams signal diagrams flow chart diagrams sequence diagrams UML diagrams dataflow diagrams circuit diagrams ladder logic diagrams kinematic element diagrams or other models which may be displayed to a user via the display device . In the illustrative embodiment the diagramming application comprises a block diagram environment such as Simulink or another suitable graphical modeling environment. As used herein the terms block diagram environment and graphical modeling environment refer to a graphical application where a system is graphically modeled. Examples of suitable diagramming applications include but are not limited to MATLAB with Simulink from The MathWorks Inc. LabVIEW DasyLab and DiaDem from National Instruments Corporation VEE from Agilent SoftWIRE from Measurement Computing VisSim from Visual Solutions SystemVIEW from Elanix WiT from Coreco Vision Program Manager from PPT Vision Khoros from Khoral Research Halcon from MVTec Software and numerous others. The memory may comprise any suitable installation medium e.g. a CD ROM DVD floppy disks or tape device a computer system memory or random access memory such as DRAM SRAM EDO RAM Rambus RAM etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory may comprise other types of memory as well or combinations thereof.

In an alternative embodiment the electronic device is also interfaced with a network such as the Internet. Those skilled in the art will recognize that the diagrams used by the diagramming application may be stored either locally on the electronic device or at a remote location interfaced with the electronic device over a network. Similarly the diagramming application may be stored on a networked server or a remote peer.

The diagramming application of an illustrative embodiment of the invention includes a number of generic components. Although the discussion contained herein focuses on Simulink from The MathWorks Inc. of Natick Mass. those skilled in the art will recognize that the invention is applicable to other software applications. The generic components of the illustrative diagramming program include a block diagram editor for graphically specifying models of dynamic systems. The block diagram editor allows users to perform such actions as construct edit display annotate save and print out a graphical model such as a block diagram that visually and pictorially represents a dynamic system. The illustrative diagramming application also includes graphical entities such as signal lines and buses that represent how data is communicated between functional and non functional units and blocks . As noted above blocks are the fundamental mathematical elements of a classic block diagram model. A block diagram execution engine also implemented in the application is used to process a graphical model to produce simulation results or to convert the graphical model to executable code. For a block diagram graphical model the execution engine translates a block diagram to executable entities following the layout of the block diagram as provided by the user. The executable entities are compiled and executed on a computational device such as a computer to implement the functionality specified by the model. Typically the code generation preserves a model hierarchy in a call graph of the generated code. For instance each subsystem of a model in a block diagram environment can map to a user specified function in the generated code. Real Time Workshop from The MathWorks Inc. of Natick Mass. is an example of a suitable execution engine for generating code.

In the illustrative embodiment the diagramming program is implemented as a companion program to a technical computing program such as MATLAB also available from The MathWorks Inc.

The block diagram editor is the user interface component that allows a user to create and modify a block diagram model representing a dynamic system in step . The blocks in the electronic block diagram may model the behavior of specialized mechanical circuit or software components such as motors servo valves power plants blocks tires modems receivers and other dynamic components. The block diagram editor also allows a user to create and store data relating to graphical entities . In Simulink a textual interface with a set of commands allows interaction with the graphical editor. Using this textual interface users may write special scripts that perform automatic editing operations on the block diagram. A user generally interacts with a set of windows that act as canvases for the model. There is generally more than one window for a model because models may be partitioned into multiple hierarchical levels through the use of subsystems.

A suite of user interface tools within the block diagram editor allows users to draft a block diagram model on the corresponding windows. For example in Simulink the user interface tools include a block palette a wiring line connection tool an annotation tool a formatting tool an attribute editing tool a save load tool and a publishing tool. The block palette is a library of all the pre defined blocks available to the user for building the block diagram. Individual users may be able to customize this palette to a reorganize blocks in some custom format b delete blocks they do not use and c add custom blocks they have designed. The palette allows blocks to be dragged through some human machine interface such as a mouse or keyboard from the palette onto the window i.e. model canvas . The graphical version of the block that is rendered on the canvas is called the icon for the block. There may be different embodiments for the block palette including a tree based browser view of all of the blocks.

A block diagram model of a dynamic system created during step is generally represented schematically as a collection of interconnected graphical objects such as blocks ports and lines which represent signals. illustrates an example of a block diagram created using the diagramming application . Each block in the block diagram represents an elemental dynamic system. Each signal denoted by lines connecting the blocks represents the input and or output of an elemental dynamic system. The illustrative block diagram includes a subsystem block a source block and a destination block . A line emanating at one block and terminating at another signifies that the output of the first block is an input to the second block. Ports such as input port and output port of the subsystem block refer to a distinct inputs or outputs on a block. Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant when their connected blocks are enabled. The source block for a signal writes to the signal at a given time instant when its system equations are solved. As shown the signal from the source block passes to the subsystem . The signal output from the subsystem passes to the destination block . The destination block for a signal reads from the signal when the system equation is being solved. As shown the signal represents the output of the subsystem . One skilled in the art will recognize that the block diagram is merely illustrative of a typical application and is not intended to limit the present invention in any way.

Once a block diagram model or other graphical model has been constructed using the editor in step the execution engine simulates the model by solving equations defined by the model to trace the system outputs as a function of time in steps . The solution of the model which may be referred to as model execution is carried out over a user specified time span for a set of user specified inputs.

The compile stage in step marks the start of model execution and involves preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and block insertion. The compile stage involves checking the integrity and validity of the block interconnections in the block diagram. In this stage the engine also sorts the blocks in the block diagram into hierarchical lists that are used when creating the block method execution lists. The preparation of data structures and the evaluation of parameters create and initialize basic data structures needed in the compile stage. For each of the blocks a method forces the block to evaluate all of its parameters. This method is called for all blocks in the block diagram. If there are any unresolved parameters execution errors are thrown at this point.

The compilation step also determines actual block connectivity. Virtual blocks play no semantic role in the execution of a block diagram. During compilation the virtual blocks and signals such as virtual bus signals in the block diagram are optimized away removed and the remaining non virtual blocks are reconnected to each other appropriately. This compiled version of the block diagram with actual block connections is used from this point forward in the execution process.

In the link stage in step the execution engine uses the result of the compilation stage to allocate memory needed for the execution of the various components of the block diagram. The linking stage also produces block method execution lists which are used by the simulation linearization or trimming of the block diagram. Included within the link stage is the initialization of the model which consists of evaluating setup methods e.g. block start initialize enable and constant output methods . The block method execution lists are generated because the simulation and or linearization of a model must execute block methods by type not by block when they have a sample hit.

The compiled and linked version of the block diagram may be directly utilized to execute the model over the desired time span in step . In step the execution engine may choose to translate the block diagram model or portions of it into either software modules or hardware descriptions broadly termed code . The code may be instructions in a high level software language such as C C Ada etc. hardware descriptions of the block diagram portions in a language such as HDL or custom code formats suitable for interpretation in some third party software. Alternatively the code may be instructions suitable for a hardware platform such as a microprocessor microcontroller or digital signal processor etc. a platform independent assembly that can be re targeted to other environments or just in time code instructions that corresponds to sections of the block diagram for accelerated performance.

In certain embodiments code may be generated from the block diagram model . In some such embodiments the code generated from the locked block without authorization will be obfuscated. Code obfuscation in a graphical modeling environment is set forth in U.S. patent application Ser. No. 11 038 608 entitled Obfuscation of Automatically Generated Code filed on Jan. 18 2005 the specification of which is hereby incorporated by reference. With authorization the code may be generated normally.

An example of a block diagram model as provided in the method of step can be seen in . This exemplary block diagram model includes an input node an output node and the locked element here a locked block provided in the method of step . The input node provides the locked block with an input signal . Until authorization is provided the lock block will not operate in the model. Once access is granted the block may then perform some process on the received input and provides an output signal to the output port .

In another embodiment authorization may be required to access the implementation details of the locked block . Thus a block may be unlocked so as to function within the diagram model system but access to the implementation details of the block are still locked.

When used in a block diagram model the locked block may function as a black box. Like any other element the locked block represents some underlying functionality. Based on this underlying functionality the locked block can receive an input signal and provide an output signal . The locked block differs from other element in that access to its functionality requires authorization.

Without authorization the functionality of a locked element such as locked block may not be accessed. Likewise application program interfaces API s such the get param API of MATLAB will not function without authorization. depicts an example of an interface window showing what happens when the get param API is on the locked block of . Furthermore any code generated from the locked block without authorization may be obfuscated to prevent attempts to determine the implementation details of the block from the code. An example of such obfuscated code generated from the locked block can be seen if .

In another embodiment authorization may be required to access the implementation details of a locked element or block. For example the basic functionality of the element may be unlocked so that the element operates in a block diagram model but to view or edit the implementation details that provide the functionality authorization is required. Using such an implementation a locked element may be provided to a third party user without having to provide the implementation details of the locked element which may be proprietary. The third party user may use the locked element in a block diagram model perform simulations generate code and even execute the generated code but cannot access the implementation details of the locked element without authorization.

One method of determining if an element is locked is to check how the data for the element is stored on a physical medium. If the data for the element is stored on a restricted access device that requires a user to login before accessing it then the element could be designated as locked. Another method for when the data for the element is on a non restricted device is to provide a series of bytes at the beginning of the data file for the element indicating that the element is an encoded element that a graphical environment such as Simulink has access to. A password or phrase internal to the graphical environment could then be required to access the functionality of the element.

In one exemplary embodiment authorization for the locked element is provided by a password or authorization code. Thus in the example wherein a third party user is working with the block diagram model of when the third party user attempts to access the functionality of the locked block the third party is prompted to provide a password to gain access to the functionality. An example of window providing such a prompt can be seen in . Here the window prompts the third party user for a password and provides a field for the user to enter the password . In this example the third party user may then choose to submit a password by clicking the OK button or cancel the authorization using the Cancel button . If the third party does not provide the correct password or chooses to cancel the authorization the user may still continue to view the locked block without access to its functionality. Although in this embodiment access to the functionality of a locked element is obtained using a graphical user interface it should be understood that access may be obtained in other ways. For example a textual interface or Application Program interface API may be used to gain access to the functionality of a locked element.

It should also be understood that authorization is not limited to the use of passwords. Other authorization methods may also be used. For example in some embodiments a hardware dongle or key physically attached to the third party user s system may be required. Such a dongle or key could be attached to the serial parallel USB IEEE 1394 Firewire iLink port or the like of the system and be checked for before access to the functionality is provided. In other embodiments biometrics signatures such as fingerprints may be required for authorization. Other possible authorization techniques will be apparent to one skilled in the art given the benefit of this disclosure.

Returning now to the example wherein the third party user has been prompted for a password if the correct password is provided the third party user is then authorized to access the functionality of the now unlocked block. In this example the previously locked block of represents a subsystem shown in which is now accessible to the third party user.

The subsystem of is a block diagram model that determines the average for an array. An array is received at the input and is passed to a block that adds the elements of the array and a block that determines the number of elements in the array. The outputs of these blocks are then passed to a block that divides the sum of the elements by the number of elements of the array. The resulting average is then passed to the output .

Although in the present example the locked element represented a block diagram model subsystem it should be understood that the implementation details of a locked element are not limited to a block diagram model subsystem or referenced model. In some embodiments the locked element may represent a Stateflow model such as seen in . In other embodiments the locked element may represent an Embedded MATLAB system wherein the functionality of the block is described using MATLAB code as shown in . These and any number of other implementations of element may be locked under the present invention. In certain embodiments it may be advantageous to combine such different implementations together providing a nesting of systems. For example a locked element may represent a block diagram model subsystem comprising locked element representing both additional block diagram models and embedded systems wherein the functionality is described in code. In such a system each locked element may require is own separate authorization to gain access to its implementation details or access could be obtained globally.

Once an element is unlocked its functionality becomes accessible. The implementation details may also become accessible. For example if the implementation details become available an API such as get param may now operate on the element such as block of as shown in the example window of . In some embodiments access is limited to the ability to view the implementation details. In other embodiments access includes the ability to edit or otherwise modify the implementation details of the element. In such embodiments a graphical user interface GUI or programmatic interface may be used to interact with the implementation details of the element. For example if the element represents a block diagram model subsystem blocks or other elements may be added or removed from the system. If for example the functionality of the element is defined by code the code may be edited to modify the functionality of the element. Likewise any number of parameters for an element including but not limited to input size output size input type output type delay gain and ranges can be modified.

An example of a graphical user interface for editing the parameters of an element such as a block can be seen in . In this example the interface provides instructions for adding or subtracting inputs as well as the ability to specify data signal types change the shape of the block icon and set sample time for the block .

In certain embodiments wherein code generated from a locked element is obfuscated unlocking the element allows the code generated from the element to be non obfuscated. An example of non obfuscated code can be seen in . In this example the non obfuscated code is the code generated from the now unlocked block of .

In certain embodiments it may be beneficial to have different levels of authorization for a locked element. For example the locked element may have a first authorization for enabling the execution or simulation of the element a second authorization for viewing the implementation details a third authorization for editing or modifying the implementation details of the element and a forth authorization for generating non obfuscated code. Likewise different types of authorizations can be implemented for different levels. In embodiments having multiple or nested locked element different levels and types of authorization can be used for each element. In other embodiments a single authorization may give access to the implementation details of a number of locked elements. Other variations combinations and implementations will be apparent to one skilled in the art given the benefit of this disclosure.

In some embodiments the selection and locking of an element such as a block or block diagram model may be accomplished using a graphical user interface GUI . For example a user may select the block or block diagram model using an interface such as a mouse and then use a menu to lock the block or block diagram model. An example of this can be seen in . Here a block diagram model is selected and then locked using a pull down menu . In another embodiment an element or block diagram model may be locked using an Application Program Interface API . Other possible variations and implementations will be apparent to one skilled in the art given the benefit of this disclosure.

As part of the locking process the user may indicate what authorization is to be required to unlock the locked element. For example after the user has chosen to lock a selected block or block diagram model the user may be prompted to specify the desired authorization to unlock the block. In some embodiments this may be done using a GUI for example the user may be provided with a window allowing the user to select the desired authorization. An example of such a window can be seen in . Here the window prompts the user to specify a password that will unlock the locked block and provides a field for the user to enter the desired password .

One possible locking technique is encryption. Here to lock an element such as a block or block diagram the user specifies that the element is to be written to a persistent file such as an MDL file in an encrypted format. Once written in this format the implementation details of the element can only be read either by the environment that created the element or an environment that has the authorization to unlock the element. Suitable encryption methods include but are not limited to PGP DES3 Blowfish or the like.

It should be understood that the methodology for locking an element is not limited to encryption. Other methodologies may be employed depending on the level of protection required. In some embodiments different methodologies and levels of protection may be used together to lock different elements block diagram models and levels of authorization.

The examples to this point have focused primarily on the system where the graphical modeling environment was on a local computational device in one embodiment an electronic device. The graphical modeling environment may of course also be implemented on a network as illustrated in having a server and a client device . Other devices such as a storage device may also be connected to the network.

In one such embodiment a system for generating and displaying a graphical modeling application comprises a distribution server for providing to a client device a locked element requiring authorization to access the implementation details of the element and a client device in communication with the distribution server. Here the distribution server provides a client device such as an electronic device discussed above with a locked element. The client may then use the locked element in a block diagram model but would require authorization to access the functionality of the locked element. Without authorization the client cannot run a simulation of the block diagram model featuring the locked element.

In another embodiment a user may interact with a graphical modeling interface on the server through the client device. In one example of such a system a server and client device are provided. The server is capable of executing a graphical modeling environment. The client device is in communication with the server over a network. A block diagram model of a dynamic system having a locked element is provided at the server. A request for access to the functionality of the locked element is received at the server from the client. In response to request for access from the server the server requests authorization from the client. If the client provides the server with the proper authorization then the server grants the client access to the functionality of the locked element.

It will be understood by one skilled in the art that these network embodiments are exemplary and that the functionality may be divided up in any number of ways over a network.

The present invention has been described relative to illustrative embodiments. Since certain changes may be made in the above constructions without departing from the scope of the invention it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a limiting sense.

It is also to be understood that the following claims are to cover all generic and specific features of the invention described herein and all statements of the scope of the invention which as a matter of language might be said to fall therebetween.

