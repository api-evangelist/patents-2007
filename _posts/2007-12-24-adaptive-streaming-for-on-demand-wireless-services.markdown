---

title: Adaptive streaming for on demand wireless services
abstract: An adaptive media distribution system provides an on demand user experience across a limited throughput wireless network by selectively utilizing available storage on a handheld communication device, taking advantage of increased availability of extended memory solutions. Creation of an adaptable user interface (UI) widget (e.g., Trig) serves as a near real-time mechanism for delivery of media content, overcoming the over-the-air latency and difficulties with streaming interoperability. Yet, for handheld communication devices with limited storage, the adaptive media distribution system further allows legacy devices to receive on demand services via streaming, albeit with the requisite relatively long latency associated with cellular multimedia services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09313245&OS=09313245&RS=09313245
owner: QUALCOMM Incorporated
number: 09313245
owner_city: San Diego
owner_country: US
publication_date: 20071224
---
The present aspects generally relate to variable processing of software applications. More particularly the aspects relate to providing an improved multimedia delivery over a throughput limited cellular communication channel.

Streaming services over cellular access technologies are reaching ubiquity. The popularity of such services demonstrates that end users are willing at least in the near term to adapt to limited forms of video content in order to enjoy the mobility of a handheld environment. The limitations imposed by the available throughput and access costs can include low resolution for streaming content and or long latency periods to buffer at least a portion of the content. Meanwhile other communication devices with high bandwidth access e.g. Internet broadband Wi Fi etc. are increasingly being used to access multimedia content to provide a Video on Demand experience with better resolution and reduced latency.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the disclosed versions. This summary is not an extensive overview and is intended to neither identify key or critical elements nor delineate the scope of such versions. Its purpose is to present some concepts of the described versions in a simplified form as a prelude to the more detailed description that is presented later.

An adaptive media delivery system and method provides on demand media delivery over a reduced bandwidth communication channel by transmitting discrete media files from a network for storage on a mobile device. Thereby a user may access the media with reduced over the air latency as compared to accessing a streaming version of the media. In one aspect wherein the mobile device is too limited in available storage space the system and method allows reversion to streaming media content.

In one aspect a method for receiving media content across a limited throughput network accesses and plays a streaming version of a media content selection on a portable communication device in response to the amount of available local data storage being below a threshold. The method further stores a discretely formatted version of the media content selection in the available local data storage in response to the amount of available local data storage exceeding the threshold.

In another aspect a method for distributing media content across a limited throughput network transmits a discrete media content version across a limited throughput network in response to determining a capacity of a communication device to store the discrete media content version.

In an additional aspect at least one processor that is configured to receive media content across a limited throughput network has a first module for detecting an amount of available local data storage a second module for determining a user preference for a media content selection a third module for accessing and playing a streaming version of the media content selection on a portable communication device in response to the amount of available local data storage being below a threshold and a fourth module for storing a discretely formatted version of the media content selection in the available local data storage in response to the amount of available local data storage exceeding the threshold.

In yet a further aspect a computer program product has a computer readable medium comprising at least one instruction for causing a computer to detect an amount of available local data storage at least one instruction for causing the computer to determine a user preference for a media content selection at least one instruction for causing the computer to access and play a streaming version of the media content selection on a portable communication device in response to the amount of available local data storage being below a threshold and at least one instruction for causing the computer to store a discretely formatted version of the media content selection in the available local data storage in response to the amount of available local data storage exceeding the threshold

In yet another aspect an apparatus is provided with a means for detecting an amount of available local data storage a means for determining a user preference for a media content selection a means for accessing and playing a streaming version of the media content selection on a portable communication device in response to the amount of available local data storage being below a threshold and a means for storing a discretely formatted version of the media content selection in the available local data storage in response to the amount of available local data storage exceeding the threshold

In yet an additional aspect an apparatus for receiving media content across a limited throughput network has an adaptive media application responsive to the presence of removable storage to store discrete media content received from a wireless communication interface on the removable storage for playing by a media player.

In an additional aspect at least one processor is configured to distribute media content across a limited throughput network by having a first module for determining a selection of media content. A second module obtains a discrete media content version of the selection comprised of a data structure containing an update channel and user interface code. A third module for transmitting the discrete media content version across a limited throughput network in response to determining a capacity of a communication device to store the discrete media content version.

In yet an additional aspect a computer program product of a computer readable medium has at least one instruction for causing a computer to determine a selection of media content at least one instruction for causing the computer to obtain a discrete media content version of the selection comprised of a data structure containing an update channel and user interface code and at least one instruction for causing the computer to transmit the discrete media content version across a limited throughput network in response to determining a capacity of a communication device to store the discrete media content version.

In another aspect an apparatus provides a means for determining a selection of media content for obtaining a discrete media content version of the selection comprised of a data structure containing an update channel and user interface code and for transmitting the discrete media content version across a limited throughput network in response to determining a capacity of a communication device to store the discrete media content version.

In an additional aspect an apparatus has a communication interface connected to a limited throughput network. A media distributor is linked to media content for determining a selection of media content. Data storage contains a discrete media content version of the selection comprised of a data structure containing an update channel and a user interface code. A scheduling dispatcher distributes subject to a determined constraint the discrete media content version via the communication interface to a communication device.

To the accomplishment of the foregoing and related ends one or more versions comprise the features hereinafter fully described and particularly pointed out in the claims. The following description and the annexed drawings set forth in detail certain illustrative aspects and are indicative of but a few of the various ways in which the principles of the versions may be employed. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings and the disclosed versions are intended to include all such aspects and their equivalents.

Various aspects are now described with reference to the drawings. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of one or more aspects. It may be evident however that the various aspects may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to concisely describing these versions.

In the following description the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or. That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is in this example X could employ A or X could employ B or X could employ both A and B and thus the statement X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

The apparatus and methods provided are especially well suited for use in wireless environments but may be suited in any type of network environment including but not limited to communication networks public networks such as the Internet private networks such as virtual private networks VPN local area networks wide area networks long haul networks or any other type of data communication network.

In a communication system includes a media content distributor that accesses media content e.g. video audio etc. stored on a provider source e.g. database . The communication system further distributes the media content across a communication channel which in the illustrative version comprises a wireless network to recipient devices depicted as a storage capable mobile device and a storage limited mobile device .

The wireless network provides a limited data throughput sufficient for near real time media distribution of video on demand types of communication services. To that end a media distribution application utilized by the media content distributor may receive the media content . The media content is then converted to a video streaming format by a streaming content filter and thereafter buffered or stored in a streaming utility . A scheduling dispatcher responds to a request to transmit the media content. A communication interface then transmits a video streaming signal over the wireless network to the requesting storage limited mobile device .

A communication interface of the limited mobile device exchanges control signals as necessary and receives the streaming content. Internal data storage of the limited mobile device is constrained as depicted by a relatively small available storage portion of an internal storage device as compared to an unavailable storage portion e.g. vacant expansion dock large quantity of stored code or data limited storage architecture etc. . Thus a media application directs the streaming video signal across a data bus to an output device for rendering or playing as a human interpretable media presentation e.g. visual audible haptic etc. 

In some instances expanded storage can become available on the same mobile device e.g. deletion of stored content insertion of a memory storage device etc. or relatively more storage resources are provided by the original equipment manufacturer OEM . The storage capable mobile device has relatively larger available storage portion of a storage device as compared to an unavailable storage portion . Thus a downstream portion of a near real time media on demand system may mitigate the constraints of a limited throughput wireless network to provide more of the experience of video on demand experiences typical of high bandwidth but short range networks e.g. Internet Wi Fi . To that end a media application may always or selectively request and receive from the media content distributor via a communication interface and internal data bus discrete media files that are stored in the storage device for subsequent rendering or playing as a human interpretable media presentation e.g. visual audible and or haptic etc. on an output device . The media content distributor comprises an upstream portion of the near real time media on demand system depicted as the media distribution application directing media content to a discrete content filter for converting into discrete file format stored or buffered by a file utility for subsequent distribution by the communication interface over the wireless network . The scheduling dispatcher is responsive to constraints for optimally distributing the discrete file format. The near real time media on demand system thus avoids streaming by performing background downloads that advantageously avoid the latency in requesting streaming content played on a remote device. Such downloads may also advantageously occur in low demand periods to reduce costs and or free up transmission throughput for other purposes.

As an exemplary operating environment media streaming services over third generation 3G wireless systems such as High Speed Packet Access HSPA and 1 EV DO 1 Evolution Data Only later Evolution Data Optimized a.k.a. IS 856 as defined by the International Telecommunication Union ITU come across throughput limitations that can be found in similar services over broadband connections. For one the quality of service QoS may not be consistent in long wireless data sessions. In addition the average delay to stream is affected by the wireless link. As a result in order to ensure effective playback receiver buffering may need to increase or user experience suffers. For instance consider Universal Mobile Telecommunications System UMTS release five 5 i.e. High Speed Downlink Packet Access HSDPA where data is sent to individual users via a shared physical channel i.e. High Speed Downlink Shared Channel HS DSCH . As part of this data transfer a fast automatic repeat request ARQ method a.k.a. hybrid ARQ is used to ensure data reliability.

It has been shown theoretically that performance can be predicted for HSDPA in the context of hybrid ARQ determining a delay boundary for the expected amount of time necessary for sending a video file to a handheld device. This delay is affected by errors on the physical link. The two main sources of error are packets that are received incorrectly and missed packets due to misinterpretation of ARQ acknowledgements. Moreover retransmissions upon detection of an error do not arrive instantaneously. As a result an N phase stop and wait hybrid ARQ mechanism can be used. In this method several ARQ instances are initiated so that during the acknowledgement turnaround time no gaps in data transmission occur. For instance if the physical layer frame duration is specified as T it would take a time period of NT for a retransmission to occur upon detection of a frame error. T is about 2 milliseconds and N is about four 4 in HSDPA.

In the hybrid ARQ method defined for HSDPA after M transmissions the transmitted physical layer frame is considered unrecoverable. As a result the higher layer protocols such as the radio link protocol RLP or transport layer protocol TCP operate to recover the data. In one instance wherein the initial wireless error rate for which a frame is sent is designated by p then each successive retransmission results in an approximate reduction error by a factor of C.

The effects of hybrid ARQ are limited by errors in acknowledgements. More specifically negative acknowledgements NAKs that are received in error result in the HSDPA transmitter erroneously designating the associated data frame as having been correctly received. RLP or TCP would be used for error recovery in this case. Assuming the probability of acknowledgement error is f then the average delay per frame due to hybrid ARQ can be approximated as 

If the file size can be defined as F and the rate of transmission in bits per second is R then the minimum number of physical layer frames necessary to transmit the entire file is 

As an example we assume single code HSDPA transmission at 16 Quadrature Amplitude Modulation QAM at a forward error correcting code rate of and a physical layer data rate of 708 kilo bits per second kbps . In this case C 0.1. Assuming different values for f while M 4 then the delay with respect to different values of p is depicted in assuming a video file of approximately four 4 minutes in length encoded at 128 kbps. The aggregate delay approaches one minute for typical values of p i.e. 0.1 to 0.3 . Moreover 16 QAM which provides the highest data rates seen in either HSDPA or even 1 EV DO has a limited coverage range and is not typical of the mean throughput seen by end users. It should also be noted that the delay provided in is a lower bound as several other limiting factors have not been included such as additional protocol overhead e.g. RLP TCP IP and streaming protocol headers turnaround delay due to radio link protocol implementation and TCP associated delays e.g. startup retransmission delay .

This delay effect is readily observable in today s 3G networks and many users are comfortable with some of the sacrifices made to account for this effect e.g. reduced video duration lower quality encoding etc. . However this kind of lag begins to approach the point where an On Demand service is not possible. As a result video streaming with its considerable delay for source data of several minutes duration or more will likely not provide a suitable On Demand experience for the end user. Thus these types of wireless networks are termed herein sufficient for near real time media on demand services but fail to provide a satisfactory user experience via over the air streaming protocols.

In an exemplary version of a cellular communication system is depicted as a server wirelessly transmitting near real time media on demand over a 3G wireless network to a communication device in a manner that addresses the latency issues of video streaming services. According to some aspects the communication device may comprise any type of computerized communication device. For example the communication device may comprise a mobile communication device such as a wireless and or cellular telephone. Alternatively the communication device may comprises a fixed communication device such as a Proxy Call Session Control Function P CSCF server a network device a server a computer workstation etc. It should be understood that communication device is not limited to such a described or illustrated devices but may further include a Personal Digital Assistant PDA a two way text pager a portable computer having a wired or wireless communication portal and any type of computer platform having a wired and or wireless communications portal. Further the communication device can be a remote slave or other similar device such as remote sensors remote servers diagnostic tools data relays and the like which does not have an end user thereof but which simply communicates data across a wireless or wired network. In alternate aspects the communication device may be a wired communication device such as a landline telephone personal computer set top box or the like. Additionally it should be noted that any combination of any number of communication devices of a single type or a plurality of the afore mentioned types may be utilized in the cellular communication system . Therefore the present apparatus and methods can accordingly be performed on any form of wired or wireless device or computer module including a wired or wireless communication portal including without limitation wireless modems Personal Computer Memory Card International Association PCMCIA cards access terminals personal computers telephones or any combination or sub combination thereof.

Additionally the communication device may include a user interface for purposes such as requesting interacting with and or playing the media content . This user interface includes an input device operable to generate or receive a user input into the communication device and an output device operable to generate and or present information for consumption by the user of the communication device . For example input device may include at least one device such as a keypad and or keyboard a mouse a touch screen display a microphone in association with a voice recognition module etc. In certain aspects input device may provide for user input of a request for content or for user input of a request for additional information. Further for example output device may include a display an audio speaker a haptic feedback mechanism etc. Output device may generate a graphical user interface a sound a feeling such as a vibration etc. and such outputs may be associated for example with the presentation of media content .

Further communication device may include a computer platform operable to execute applications to provide functionality to the device and which may further interact with input device and output device . Computer platform may include a memory which may comprise volatile and nonvolatile memory portions such as read only and or random access memory RAM and ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM flash memory and or any memory common to computer platforms. Further memory may include active memory and storage memory including an electronic file system and any secondary and or tertiary storage device such as magnetic media optical media tape soft and or hard disk and removable memory components. In the illustrative version memory is depicted as RAM memory a nonvolatile local storage unit and a removable expanded memory unit each connected to a data bus of the computer platform.

Further computer platform may also include a processor which may be an application specific integrated circuit ASIC or other chipset processor logic circuit or other data processing device. In some aspects such as when communication device comprises a cellular telephone processor or other logic such as an application specific integration circuit ASIC may execute an application programming interface API layers that interfaces with any resident software components such as voice call data call and media related applications in memory . Device APIs may be a runtime environment executing on the respective communication device. One such API runtime environment is Binary Runtime Environment for Wireless BREW API depicted separately and developed by QUALCOMM Incorporated of San Diego Calif. Other runtime environments may be utilized that for example operate to control the execution of applications on wireless computing devices.

Additionally processor may include various processing subsystems embodied in hardware firmware software and combinations thereof that enable the functionality of communication device and the operability of the communication device on communications system . For example processing subsystems allow for initiating and maintaining communications and exchanging data with other networked devices as well as within and or among components of communication device . In one aspect such as in a cellular telephone processor may include one or a combination of processing subsystems such as sound non volatile memory file system transmit receive searcher layer layer layer main control remote procedure handset power management diagnostic digital signal processor vocoder messaging call manager Bluetooth system Bluetooth LPOS position determination position engine user interface sleep data services security authentication USIM SIM universal subscriber identity module subscriber identity module voice services graphics USB universal serial bus multimedia such as MPEG Moving Picture Experts Group protocol multimedia GPRS General Packet Radio Service short message service SMS short voice service SVS web browser etc. For the disclosed aspects processing subsystems of processor may include any subsystem components that interact with applications executing on computer platform .

Computer platform may further include a communications module that enables communications among the various components of communication device as well as being operable to exchange media content and content requests between the communication device and communications network . Communications module may be embodied in hardware firmware software and or combinations thereof and may further include all protocols for use in intra device and inter device communications. Further communications module is operable to transmit and or receive information such as requesting and receiving media content in accordance with the apparatus and methods described herein.

Certain of these capabilities of the communication device can be facilitated by code loaded from local storage retained in memory and executed by the processor such as an operating system OS . A user interface module facilitates interactive control with the user interface . A streaming media player renders or plays media content on the output device accessing streaming media content contained in a media buffer . Other applications may be active in memory for other functions e.g. communication call control alarm clock text messaging etc. . It should be appreciated with the benefit of the present disclosure that applications consistent with aspects of the present disclosure may omit other applications and or omit the ability to receive streaming content.

Near real time media on demand services are provided by discrete media content remotely stored on the server that is utilized by the communication device . In particular an adaptive media selection module is responsive to the availability of sufficient available data storage in the expanded memory unit to initiate download of the discrete media content depicted as Triglets . The media content of the Triglets are used to update Trigs composed of compiled TrigML code an update channel text strings and or images that are buffered in memory . The Trigs are processed by BREW API . The BREW APIs provide the ability for applications to call Device APIs and other functions without having to be written specifically for the type of communication device . Thus an application such as the adaptive media selection application may operate identically or with slight modifications on a number of different types of hardware configurations within the operating environment provided by BREW API which abstracts certain hardware aspects. A BREW extension can add additional capability to the programming platform of the BREW API such as offering MP3 players Java Virtual Machines etc. A Trig Player Trigs and Actors are components of the uiOne architecture developed by QUALCOMM Incorporated. These components refer to user interface aspects of the communication device . BREW uiOne is a set of BREW extensions that enables rapid development of rich and customizable UIs i.e. active content over the air OTA up gradable helps to evolve download business beyond applications provides theming of part or entire handset UI and utilizes BREW UI Widgets. Thus BREW uiOne reduces the time to market for handsets carrier customization and consumer personalization. To do this the BREW uiOne provides a clear set of abstractions adding two new layers to the application development stack for BREW.

To assist in developing an implementation for the communication system BREW User Interface UI utilizes a toolkit not shown to facilitate implementation. The Brew UI Toolkit is a model view controller MVC design pattern. MVC is at the heart of many of today s user interface frameworks including Java Swing. The MVC pattern breaks graphical UI applications up into three discrete parts the model view and controller. The model is responsible for managing the application domain data responding to requests for information about the state of the data from the view and changes state in response to requests from the controller . The view is responsible for managing the graphic output of the application. The controller is responsible for interpreting key events menu selections and other inputs and passing the requests those commands represent to the view to change its view of the model or the model to change its data .

In one implementation the controller accepts events from the system s event pump uses polymorphism or conditional logic to determine the appropriate action to take place within the view or model. In turn the view listens for change notifications from the model and controller querying the model for new data as needed when it receives a change notification. The model itself tracks the state of the application data. A common optimization for this pattern is to collapse the responsibilities of the view and the controller into a single programmatic entity the Brew UI Toolkit uses this letting an event handler to be specified for any view. In essence the Brew UI Toolkit provides default controllers for each view and such behavior can be overridden with a controller via a new event handler.

The Brew UI Toolkit provides base classes that represent the model IModel along with several subclasses for specific kinds of models including a model for text ITextModel lists and menus IListModel and IMenuModel respectively as well as a general purpose IValueModel with which you can encapsulate arbitrarily complex structures. The toolkit also provides a horde of user interface primitives from which you can build your user interface including Widgets for text input radio and checkbox selection buttons text and bitmap display and menu items and menus. All of these inherit the IWidget interface. Widgets can be nested and some Widgets perform layout and focus control for the Widgets they contain giving a decidedly desktop programming flavor to the process of building a UI. In turn Widgets occupy a form which is the top level of a UI from the perspective of application implementation.

Nesting Widgets can create complex yet easy to use UIs that are made with the Brew UI Toolkit. As in a desktop GUI Widgets can contain other Widgets some Widgets can act as containers containing other Widgets and controlling their layout. Other Widgets act as decorators letting you link their functionality to enhance a given Widget. For example a scrolling text view consists of two Widgets the text Widget showing the text and a scrollbar Widget that provides the scrolling behavior decorating the functionality of the text Widget.

Widgets which contain other Widgets are containers and implement the IContainer interface. The IContainer interface allows the user manipulate how a Widget performs its job as a container the IWidget interface allows the user manipulate the Widget itself. Classes like IXYContainer and IConstraintContainer have the primary function of containing objects. To use these objects as Widgets the corresponding Widget interface is obtained from an instance via ICONSTRAINTCONTAINER QueryInterface. This requests the Widget interface for the corresponding container object.

While a specific screen consists of a hierarchy of Widgets an entire application is a collection of forms. A form consists of a top level container the Brew UI Toolkit provides a mechanism for an application to track its state as a top level form the one currently on screen and a stack of forms. As the user use an application the application uses events like soft keys and selection items to create new forms fills them with Widgets and places them on the top of the stack. When the user exits a form e.g. pressing the clear key the form is popped from the stack. Just as Widgets and the MVC pattern provide an ability to conceptualize a value and its relationship to the user forms and the form stack provide a way to conceptualize application flow within the application. At the highest level then the application consists of one or more forms each of which has a collection of Widgets the view which act together on a set of models that represent the state of the application s data. Many Widgets will do their work automatically enabling the user to enter text or select choices from a menu others might need additional code in the form of a controller.

Applications can use Widgets without forms although forms facilitate conceptualization of application flow and groups Widgets. Any application that uses both Widgets and forms creates a root form a form for each screen and a top level container for each form. A top level form has two responsibilities. First it maintains the stack of forms and tracks the notion of which form has focus. Second it presents a container user interface for your form consisting of a title and soft key labels. By permitting the root form to own the responsibility of creating and configuring these Widgets device manufacturers can ensure a similar look and feel between all Widget based applications. The input form is created by the InputForm Create method which uses lazy instantiation to create the form and its Widgets.

TrigML code owned by QUALCOMM Incorporated is a data language based on eXtended Markup Language XML and may be used for user interface presentation language for authoring Trigs and includes advantages of mobile targeted functionality an interactive user interface event model and pixel positioning among other advantages. TrigML is a powerful lightweight language for UI development utilized by the uiOne Software Developer Kit SDK to accommodate the constraints of mobile devices small screens low allocation for memory space and constrained computing power. Even within the parameters of these limitations the language is remarkably powerful and extensible so that developers and OEMs can develop graphic and content rich UIs much faster with TrigML than with C the language generally known for UI development. Unlike C in TrigML the application logic and the presentation layers are decoupled. This difference represents a strategically important departure from the coding process used in C.

With TrigML when a developer wants to modify a UI the presentation layer alone requires customization there is no need to tamper with the application logic. Conversely code written in C commingles the presentation layer and the application logic. This monolithic architecture requires dissection of application logic from presentation logic greatly complicating the editing process. The difficulties imposed by this added step necessitate longer timeframes for UI development which are in increasingly short supply. In contrast the intelligent design of the TrigML language creates a huge time savings for the developer and OEM decreasing the UI development time for each device within a portfolio and allowing the foundation of many UI designs to be reused thereby reducing time to market for portfolios overall.

Returning to Actors are a particular type of underlying BREW extension that include underlying C code to connect Trigs to underlying Device APIs and or BREW APIs . Actors may also serve as executables for input output. And because Actors connect to the underlying Device and BREW APIs Actors have access to functions of the computer platform . The Trig Player may be implemented as a BREW Extension even though depicted separately. The Trig Player renders the user interface using the Trigs and Actors .

It should be appreciated that the server such as a Universal Directory Service UDS server can advantageously facilitate media content delivery by packaging and storing in advance resource laden user interface UI Widgets e.g. Trigs that contain multimedia resource files. Given that handheld communication devices often have display screens of limited size and limited keypad or other input devices it is further beneficial that the server create a graphical user interface GUI that is intuitive with perhaps a preselected list of suggested media content selections that are bundled with content descriptors and downloaded in advance or upon a user request for rendering playing content. Either the server and or the communication device may contain the Actor that handles the transfer and determines whether the resources are sufficient for storage on the communication device . Alternatively or in addition a Trig may be downloaded in advance to a communication device with only updates as required rather than having to transmit the full Trig again. It should be appreciated with the benefit of the present disclosure that the Trigs may contain advertising content.

In Trig Player runs on a BREW application as a BREW extension for rendering of interactive UI Trigs and Triglets . Trig Builder not shown authors TrigML application for Trigs . TrigML is a scripting language based on XML used to describe the UI layout flow and interactions as BREW UI application . BREW UI Widgets BUIW provide a framework to quickly develop UI components Widgets and forms . QUALCOMM uiOne SDK not shown facilitates development simulation and execution of the BREW UI application on a developmental workstation e.g. personal computer PC not shown and contains Trigbuilder and BREW simulator not shown . Trigs are compiled TrigML code and other resources into application or set of applications. Trig runs on Trig Player . A Parcel not shown is a file that specifies the source components of a Trig e.g. text strings images etc. . There are two types of parcels binary parcel and XML parcel not shown . Parcels are source of Trigs Triglets for any of the following uiOne static application single Trig uiOne dynamic application multiple Triglets and uiOneContent campaign multiple Trigs multiple Triglets. Parcels contain TrigML text images ringers wallpapers. Parcel is either a single binary file which is easy to transfer forward or is exploded into multiple files with an XML meta file. Parcel resources include TrigML fragments images PNG text unicode lists composite for menus etc. ringtones wallpapers channels themes Triglets . Parcel resources are organized into a tree of Trigs and Triglets with a Trig being usually equivalent to an application and a Triglet usually being a small modification to a Trig which can be deployed with a TRIG can be deployed over the air OTA and can be a theme. Triglets can update any part of a UI . Trig inheritance provides that Trigs can derive from other Trigs Triglets can derive from a Trig and Triglets can derive from other Triglets. Resources in a derived Trig Triglet with the same resource path override the parent s resource.

In traditional UI data supports UI i.e. data provides theme and resource information to UI application code. But in BREW uiOne everything is data. Data is the UI . Along with theme and resource information data also provides information on graphics layout focus movement and other graphical behavior page map simple application logic. TrigML mark up language advantageously makes a data driven UIs rather than other mark up languages like HTML and JavaScript that are not suitable for mobile UIs . So a new markup language TrigML was created retaining some features such as event model of JavaScript form links of HTML animation model of SMIL etc.

Trig Player starts rendering every Trig from the same point which is a fragment of TrigML called default defined under the startup folder. This fragment is automatically created by TrigBuilder when the user creates a new Trig . Just like any other mark up language TrigML uses tags. Few tags are explained below 

 Layers are a fundamental and compulsory part of the TrigML. A minimum UI must contain at least one layer. Layers are invisible full screen containers that are stacked in order they are defined. Each additional layer has memory and performance implications so it is not a good idea to have large number of layers.

 Group is the basic container element. It can be empty or can contain visible elements referred to as its children. Group element serves two purposes framing and association and can have dimensions borders and back ground colors. If coordinates are not specified groups and other visible elements will center within their parent boundaries.

 This tag is like group in that it can contain things however it has extra features of columns and rows to create cells.

 This tag takes a single image and repeats it in different locations. Trig Player provides that enough repetitions are made to cover the entire area specified.

Traditional BREW applications use the BREW APIs directly or perhaps leverage the BUIW for their user interface or perhaps interface to user extensions. The uiOne environment adds the notion of Trigs applications written using the TrigML XML vocabulary and played using the Qualcomm provided Trig Player on the handset. Trigs leverage Actors the interface between the XML within a Trig and existing or custom extensions to provide functionality left for C and C such as the interfaces to a messaging protocol. This architecture permits the development of truly data driven user interfaces. A BREW Trig based application or Triglet consists of a resource bundle that includes not just an XML definition of the application s interface but all of the resources required by the application. The Trig Player is not just a browser and Triglets are not merely the BREW equivalent of an MHTML file. Triglets can interact with Actors which encapsulate the behavior provided by BREW extensions facilitating more complex programmatic behavior.

The Actor interface just like the UI interface is an event driven one facilitating Triglets to throw events with named parameters like this 

This code snippet instructs the network Actor to perform its dial event with the named argument number given the value 1 888 555 4444 presumably dialing the indicated phone number. In turn Actors themselves can throw events back to a Triglet . For example an incoming voice call may be caught with a snippet like this 

These snippets point to another interesting facet of Triglets built on the Qualcomm BREW resource format BAR files the Triglet interface to a bar file s contents is that of a virtual file system. It should be appreciated that BREW uiOne has many applications beyond handset OEMs. One reason is that BREW uiOne simplifies application development for many kinds of applications. Today s applications have huge investments in user interface development in C and C although some built entire XML or HTML based user interfaces to help ease porting from one handset to another. Others had to continually tailor user interfaces to meet new screen sizes and handset capabilities on a port by port basis or else compromise on the look and feel of our application. BREW uiOne makes a separation of software logic and user interface placing the user interface in the data segment permitting far faster iteration during the software development process as you refine your user interface.

TrigML capabilities include a flexible layout model that is easy to learn and predictable. Layering is provided with arbitrary overlap. TrigML defines UI Behavior with built in event model and integrates with platform APIs . TrigML provides for partial page loading such that links load all or just a part of screen and can be triggered by any event. Template support is made for markup re use. TrigML is adapted for Mobile UIs including grids and lists for scrolling menus tickers for scrolling text and images and animation effects. TrigML builds on UI Widgets .

The element recursively nest instances of Trig Player with one applet and multiple Trig Player widgets and lives in the parent s hierarchy like any other visible element. Each Trig Player has its own private environment with .TMF file and list of .BAR files VFS var update channels Triglets persistent store. Thus benefits for robustness and modularity are provided in that a nested Trig Player has minimal controlled access to parent. The Trig Player provides a solution for sandboxing islands of updatable possibly third party content within the user interface . Triglets arriving for the nested Trig update only that Trig. BREW file system path to the nested Trig s TrigMetaFile .TMF file specifies the bar files to load into the nested Trig Player the name used to provide the nested Trig with a unique directory in the BREW.

In a method is depicted for distributing media content across a limited throughput wireless network. In block preferences for media content for all a portion or individual communication devices is accessed or predicted. An example of a prediction is accessing a list of most popular video downloads for a particular webpage portal. A more individually tailored approach may be express preference settings or comparing a categorization for new media offerings against the categories of media content accessed and played by an individual user of a communication device. The media content is accessed for availability to distribute in block which may comprise streaming media content. In block discrete media content e.g. Trig Triglet is built from the streaming media content in order to enhance the efficiency of media content distribution to communication devices having storage capability. In block distribution may be further enhanced by accessing configuration data for the population of communication devices determining current or predicted network throughput to the communication devices or other constraints. Then in block background scheduling of discrete media content is made as constrained by those devices capable of receiving such content and transmitted at a time at which the network has excess capability to handle the distribution. In block a determination is made as to whether an event trigger has occurred that warrants the transmission of media content. Such scheduling may be dynamically updated such as prioritizing communication devices that are currently sensed within a portion of the wireless device having excess capability or currently making a high bandwidth communication call that allows downloading to occur in conjunction thereto. Prioritization may be made to communication devices with a history of using near real time media on demand services. Alternatively or in addition the scheduling may utilize a low bandwidth low cost channel over an extended period in order to achieve the transmission. If no triggering event in block then processing returns to block to continue preparations for such distribution.

In the exemplary version the network side of the system retains an ability to stream media content to communication devices if unable to store discrete media content. Further the exemplary version is able to enhance the push of discrete media content by remotely managing the storage of discrete media content on the communication device. For example downloading one or more abbreviated Triglets can over write a resource on a nested Triglet or on a host Trig or otherwise command the deletion of expired content to free up additional resources. Alternatively or in addition the prediction of desired media content could be scaled down to a shorter listing to be supportable within the storage limits known for a particular model of communication device or as reported by the communication device as its current state. Thus in block a determination is made as to whether storage is available on the target communication device s . If not then a further determination is made as to whether efforts to free up resources limit download are successful in block . If not then streaming media content block is performed albeit with the requisite over the air latency inherent in a limited throughput network. If able to make storage available in either block or then discrete media content e.g. Triglets is transmitted for distribution to remote communication devices in block .

In a method is depicted for receiving media content across a limited throughput wireless network. In block media service is initiated on a handheld device. To enhance the media experience available media content may be summarized in a listing or other graphical user interface GUI presentation downloaded in advance for example with reference to favorites of the end user or as determined by frequency of request by the general audience of end users. The storage availability of the handheld device is determined in block . If not sufficient then media content is selected for streaming delivery and buffered as necessary in block . The received streaming media content is then rendered or played in block . If in block sufficient memory was determined then discrete media content e.g. UI widget Trig is requested in block and stored on the handheld device in block . To further enhance the user experience this request for media content delivery may be automated such that preferences are accessed. The content then may be transmitted using excess throughput e.g. during off peak hours during a communication call in which excess bandwidth is available when a more capable network connection is available etc. . Monitoring in block determines if storage is no longer available e.g. a removable memory storage device has been removed other applications have used the available memory storage etc. . If memory is not available in block then reversion to streaming media content is made by going to blocks and with checks made in block as to whether storage has become available again. If storage was found to be available in block or block then additional discrete media is reloaded as necessary in block and the stored media content is played in block with iterations made to monitor available storage in block .

The various illustrative logics logical blocks modules and circuits described in connection with the aspects disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration. Additionally at least one processor may comprise one or more modules operable to perform one or more of the steps and or actions described above.

Further the steps and or actions of a method or algorithm described in connection with the aspects disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers a hard disk a removable disk a CD ROM or any other form of storage medium known in the art. An exemplary storage medium may be coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. Further in some aspects the processor and the storage medium may reside in an ASIC. Additionally the ASIC may reside in a user terminal. In the alternative the processor and the storage medium may reside as discrete components in a user terminal. Additionally in some aspects the steps and or actions of a method or algorithm may reside as at least one instruction or any combination or set of codes and or instructions on a machine readable medium and or computer readable medium which may be incorporated into a computer program product operable to cause a computer to perform the steps and or actions.

While the foregoing disclosure discusses illustrative aspects and or implementations it should be noted that various changes and modifications could be made herein without departing from the scope of the described aspects and or implementations as defined by the appended claims. Furthermore although elements of the described aspects and or implementations may be described or claimed in the singular the plural is contemplated unless limitation to the singular is explicitly stated. Additionally all or a portion of any aspect and or implementation may be utilized with all or a portion of any other aspect and or implementation unless stated otherwise.

