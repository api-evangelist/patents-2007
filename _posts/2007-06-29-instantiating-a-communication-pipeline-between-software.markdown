---

title: Instantiating a communication pipeline between software
abstract: An embodiment not only instantiates a pipeline that allows communication between first and second executable nodes regardless of whether the nodes have compatible or incompatible interface views, but also structures the pipeline based on the relationship between the interface views so, for example, the pipeline does not consume unnecessary overhead or introduce unnecessary data-transfer delay. For example, an embodiment compares a first interface view of a first executable node to a second interface view of a second executable node. A first communication pipeline having a first structure is instantiated between the first and second nodes if the first view has a first pre-established relationship to the second view, and a second communication pipeline having a second structure is instantiated between the first and second nodes if the first view has a second pre-established relationship to the second view.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07856505&OS=07856505&RS=07856505
owner: Microsoft Corporation
number: 07856505
owner_city: Redmond
owner_country: US
publication_date: 20070629
---
This application is related to U.S. Patent Application Publication Nos. 2007 0016691 A1 filed on Jul. 14 2005 and 2007 0083512 A1 filed on Oct. 12 2005 which have a common owner and which are incorporated by reference.

In a runtime environment an executable software node may need the services of and thus may need to communicate with another executable software node. Generally an executable software node is a set of software instructions that when executed perform one or more functions. Examples of executable software nodes include software applications such as word processors and web browsers and include software add ins such as spell checkers and web browser toolbars.

As an example of one executable node needing to communicate with another executable node when a user of a word processor invokes a spelling tool to obtain a correct spelling of a word the word processor may call a spell checker add in to perform this service in which case the word processor and the add in need to communicate with one another. The user may invoke the spelling tool via the word processor s drop down menu and in response to this invocation the word processor makes a software call to the spell checker add in. Next the word processor transfers to the add in the word for which the user wants the correct spelling. After determining the correct spelling of the word the add in sends the correctly spelled word back to the word processor or sends an indication to the word processor that the word is spelled correctly.

To give a first executable node the ability to communicate with a second executable node one typically designs the first executable node to have the same interface view hereinafter shortened to view as the second executable node. A view of an executable node is itself an executable software node e.g. an application programming interface API via which the executable node can communicate with another executable node. Therefore designing the first executable node to have the same view as the second executable node allows the two executable nodes to communicate with one another via a common view. For example designing a spell check add in to have the same view as a word processor allows the add in to communicate with and thus to work with the word processor.

Executable software nodes are sometimes updated with such frequency and on such unpredictable schedules that it may be difficult to ensure that the current version of a first executable node will always have the same view as the current version of a second executable node that is designed to work with the first node. For example a software provider may update a word processor on an unpredictable schedule that is partially driven by the need to resolve unforeseen compatibility issues and some of these updates may involve a change to the view. Consequently there may be periods during which an add in designed for the word processor does not work with the current version of the word processor because the add in provider has yet to update the add in s view to be compatible with the word processor s new view.

Unfortunately if a current version of a first executable node does not have the same view as and thus does not work with a current version of a second executable node designed to work with the first node then the current version of the first node is not backwards compatible with the current version of the second node. Such lack of backwards compatibility may reduce the number of users who update to the current version of the first node and thus may reduce sales of the first node. For example suppose that the current version of a word processor is not backwards compatible with and thus does not work with the current version of a particular spell checker. If a user of the word processor wants to retain the ability to use the spell checker then he may forgo updating to the current version of the word processor at least until a compatible version of the spell checker is released.

One way to eliminate periods during which a first executable software node is not backwards compatible with a second executable node that is designed to work with the first node is to simultaneously release the latest versions of the first and second nodes.

But unfortunately simultaneously releasing the latest versions of the first and second software nodes is often impractical particularly where the first and second nodes are developed by different software providers.

This Summary is provided to introduce in a simplified form a selection of concepts that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

An embodiment is operable not only to instantiate a pipeline that allows communication between first and second executable nodes regardless of whether the nodes have compatible or incompatible views but is also operable to structure the pipeline based on the relationship between the views so for example the pipeline does not consume unnecessary overhead or introduce unnecessary data transfer delay.

For example an embodiment compares a first view of a first executable node to a second view of a second executable node. A first communication pipeline having a first structure is instantiated between the first and second nodes if the first view has a first pre established relationship to the second view and a second communication pipeline having a second structure is instantiated between the first and second nodes if the first view has a second pre established relationship to the second view.

As further discussed below an embodiment of the pipeline builder is operable to design and instantiate the pipeline regardless of whether the application and add in views and are interface compatible or incompatible consequently the pipeline builder is operable to provide a communication pathway between two executable software nodes even if the nodes have different views. Therefore the pipeline builder may allow the application to be backwards compatible with the add in even if the application view is not the same as or otherwise interface compatible with the add in view . Furthermore an embodiment of the pipeline builder is operable to structure the pipeline based on a relationship between the application and add in views and so that the pipeline does not consume unnecessary execution overhead or introduce unnecessary data transfer delay. In addition an embodiment of the pipeline constructor is operable to locate and instantiate the add in at the request of the application .

Still referring to the run time environment may include one or more execution domains that are resident on one or more processors not shown . If the environment resides on more than one processor then these processors may be disposed within one computer system not shown or within multiple computer systems not shown that are connected to one another via a network such as a local area network LAN or the internet not shown . As discussed below in conjunction with if the run time environment includes multiple execution domains then the components of the environment may be distributed among these domains in any suitable manner. Furthermore the components or the code that composes the components of the run time environment may be stored on a medium e.g. a magnetic or optical disc or a non volatile semiconductor device.

The software application may be any software application e.g. a word processor and the add in may be any add in e.g. a spell checker for the word processor.

The application view is a software node e.g. an application program interface API node that may be part of the application or that may be stored separately from the application and that may have any suitable format. For example the application view may be a portion of the application source code that is compiled and run at the same time as the rest of the source code for the application. Or the application view may be a group of extensive mark up language XML comments that are part of the code for the application . Alternatively as discussed below the application view may be a piece of source or managed code or a group of XML statements that is are stored in the store as a file that is separate from the application . In the embodiment described in conjunction with the application view is a portion of the source code for the application and is thus shown in as being part of the application.

Similarly the add in view is a software node e.g. an API node that may be part of the add in or that may be stored separately from the add in and that may have any suitable format. For example the add in view may be a portion of the add in source code that is compiled and run at the same time as the rest of the source code for the add in. Or the add in view may be a group of extensive mark up language XML comments that are part of the code of the add in . Alternatively as discussed below the add in view may be a piece of source or managed code or a group of XML statements that is are stored in the store as a file that is separate from the add in . In the embodiment described in conjunction with the add in view is a portion of the source code for the add in and is thus shown in as being part of the add in.

The pipeline includes one or more executable pipeline nodes that cooperate to transfer data from the application to the add in and from the add in to the application . Alternatively depending on the function of the add in the pipeline may be unidirectional instead of bidirectional. That is the pipeline may transfer data only from the application to the add in or only from the add in to the application . As discussed below the pipeline builder determines the structure of the pipeline e.g. the number type and arrangement of the pipeline nodes based on a relationship between the application and add in views and .

The store includes the following sub stores other software nodes and pipeline nodes . Alternatively the store may include no sub stores.

The other software nodes sub store may store one or more software nodes e.g. software applications such as the application and software add ins such as the add in that the application or other software nodes may call. Furthermore the stored software nodes may have any suitable format. For example these nodes may be written in source code that has been compiled prior to run time. Or these nodes may be written in managed code that can be compiled at run time. The sub store may also have any suitable format. For example the sub store may be a folder that includes each of the software nodes in the form of a respective file. Alternatively the sub store may be omitted from the store .

The pipeline sub store may store executable pipeline nodes from which the pipeline builder designs and instantiates the pipeline . More specifically an embodiment of the sub store stores three types of pipeline nodes view nodes e.g. API nodes adapter nodes and protocol nodes . The view adapter and protocol nodes and may have any suitable format. For example these nodes may be written in source code that has been compiled prior to run time. Or these nodes may be written in managed code that the pipeline builder can compile at run time. The functions of the view adapter and protocol nodes and are further discussed below in conjunction with . The sub store may have any suitable format. For example the sub store may be a folder that includes each of the view adapter and protocol nodes and in the form of a respective file. Furthermore some or all of the view nodes may be stored in the sub store as parts of other software nodes. For example if the application view is part of the application as shown then the application view may be stored in the sub store as part of the application. But if the application view is separate from the application then the application view may be stored in the sub store . A similar analysis applies to the add in view . If all of the views are part of respective other software nodes then no views may be stored in the sub store .

An embodiment of the pipeline builder is an executable software node that designs and instantiates the pipeline and that structures the pipeline based on the relationship between the application view and the add in view . Example relationships between the application and add in views and and example corresponding structures of the pipeline are discussed below in conjunction with . Typically the builder designs and instantiates the pipeline in response to a request from the software application although the builder may design and instantiate the pipeline in response to a request from the add in or from any other source. If the pipeline builder is not instantiated prior to the request then the request may serve to instantiate the builder. The pipeline builder may have any suitable format such as being written in object code or managed code and may be part of the software application part of the add in or separate from both the application and the add in. If part of the application or add in then the pipeline builder is stored wherever the application or add in is stored. If separate from the application and the add in then the pipeline builder may be stored in the other software nodes sub store or in any other suitable location.

Furthermore as discussed above an embodiment of the pipeline builder is operable to locate and instantiate the add in or any other software node in response to a request from the application or any other software node . For example suppose that the application is a word processor and a user requests the correct spelling of an English language word. The word processor provides to the builder a request for a spell check add in and also provides to the builder one or more requirements that the add in must meet such as the ability to spell check English language words. In response to this request the builder searches the sub store or other location for an add in that meets the specified requirements. Assuming that the builder finds that the add in meets the specified requirements it qualifies the add in as being suitable to satisfy the request and then designs the pipeline instantiates the add in if the add in is not already instantiated and instantiates the designed pipeline . If the builder finds multiple add ins that meet the specified requirements then it may ask the application to select the add in that the application wants the pipeline builder to instantiate or the builder itself may select one of the add ins based on pre established criteria. Techniques for locating and instantiating an add in are also discussed in U.S. Patent Application Publication No. 2007 0083512 A1 which was previously incorporated by reference.

Referring to the application view is interface compatible with the add in view if the views are identical or otherwise if each of the views is operable by itself to transfer data between the application and the add in .

Because the application and add in views and are interface compatible in this example the pipeline need include only a single pipeline node here a single view node for transferring data between the application and the add in . Because the application and add in views and are interface compatible the pipeline builder may instantiate either the application view or the add in view as the view node . For example if the pipeline builder designs and instantiates the application view as the view node then the builder retrieves the application view from the application if the view is part of the application otherwise the builder may retrieve the application view from the sub store or from another location. Likewise if the pipeline builder designs and instantiates the add in view as the node then the builder retrieves the view from the add in if the view is part of the add in otherwise the builder may retrieve the add in view from the sub store or from another location.

During pipeline operation the view node receives data from the application and provides this data to the add in and receives data from the add in and provides this data to the application . If the pipeline is unidirectional then the interface node transfers data in only one direction. Furthermore the application add in and view node may all run in the same execution domain or may run in two or more different execution domains.

Referring to the isolation boundary provides a pre established level of isolation between the application and the add in . For example the boundary may restrict the application e.g. a word processor or browser from sending a certain type of data e.g. the personal information of a user to the add in . Therefore in this example the boundary prevents an unauthorized party from acquiring the restricted information via the add in .

Typically a platform with which the run time environment is compatible defines a number e.g. ten of pre established isolation levels with the lowest level providing the least isolation and the highest level providing the greatest isolation. For example the lowest isolation level may restrict the transfer of fewer data types than the highest isolation level.

Either or both of the application and the add in may require the isolation boundary to have a specified isolation level or to have an isolation level within a specified range of isolation levels. For example the application may specify an isolation boundary of e.g. level two or greater and the add in may specify e.g. no isolation boundary or an isolation boundary of level three or lower. 

As long as the application and add in specify the same isolation level or overlapping ranges of isolation levels the application and add in are isolation compatible. For example the application and add in are isolation compatible if they both require an isolation boundary of level two or require an isolation boundary of level of two or greater. The application and add in are also isolation compatible for example if the application requires an isolation boundary of level of two or greater and the add in requires an isolation boundary of level of two or lower because both can transfer data across a common isolation boundary of level two. But the application and the add in are isolation incompatible if for example the application requires an isolation boundary of level five or greater and the add in requires an isolation boundary of level four or lower because there is no common isolation boundary across which both the application and add in may transfer data.

Still referring to the application and add in views and indicate the isolation levels across which they are remotable. For example the application view may indicate that it is remotable across an isolation boundary of level five or lower and the add in view may indicate that it is remotable across an isolation boundary of level two or higher. It is also contemplated that either or both of the application view and the add in view are not remotable across an isolation boundary of any isolation level.

As long as the application view and add in view are both remotable across at least one common isolation boundary the application view and add in view are isolation compatible. For example if the application view is remotable across an isolation boundary having a level two or higher and the add in view is remotable across an isolation boundary having a level three or lower then the views are isolation compatible because each is remotable across a level two boundary and a level three boundary.

Still referring to to implement the isolation boundary the pipeline builder designs the pipeline to include one and only one node here a view node which may be the same as either of the application or add in views and as discussed below.

First the pipeline builder determines that one or both of the application and add in require an isolation boundary.

Next the pipeline builder determines whether there exists a common isolation boundary with which both the application and add in are compatible.

If there exists no common isolation boundary with which both the application and add in are compatible then the pipeline builder determines that it cannot design or instantiate the pipeline of FIG. the builder may however determine that it can design and instantiate the pipeline of as discussed below.

But if there exists at least one common isolation boundary with which both the application and add in are compatible then the pipeline builder determines whether at least one of the application and add in views and is compatible with the at least one common isolation boundary.

If at least one of the application and add in views and is compatible with the at least one common isolation boundary then the pipeline builder may design and instantiate the pipeline of . First the builder selects which of the at least one common isolation boundaries to implement as the isolation boundary . For example the builder may select the at least one common isolation boundary having the lowest isolation level. Next the builder selects for implementation as the view node the one of the application and add in views and that is remotable across the boundary if both of the application and add in views are remotable across the boundary then the builder may select either of the application and add in views for implementation as the view node .

Still referring to during operation of the pipeline the view node receives data from the application and provides this data across the isolation boundary to the add in and receives data from the add in and provides this data across the isolation boundary to the application. If the pipeline is unidirectional then the view node transfers data in only one direction. Furthermore the application add in and view node may all run in the same execution domain or may run in two or more different execution domains. For example the isolation boundary may require the application and the interface node to run in a first execution domain and may require the add in to run in a second execution domain.

The pipeline builder may implement the application view as the view node and may implement the add in view as the view node

The adapter may be any executable node suitable for transferring data between the view node and the protocol node and the adapter may be any executable node suitable for transferring data between the view node and the protocol node.

The protocol node may be any node suitable for transferring data between the adapters and according to any known protocol. Examples of known protocols include the Internet Protocol IP and the Transmission Control Protocol TCP .

The protocol node may implement an isolation boundary required by either or both of the application and the add in as long as the application and add in are isolation compatible as discussed above in conjunction with . But because the protocol node implements the isolation boundary the pipeline builder may design and instantiate the pipeline even if the application and add in views and are not isolation compatible with each other or with the isolation boundary.

Still referring to during operation of the pipeline the view node receives data from the application and provides this data to the adapter node and receives data from the adapter and provides this data to the application . Similarly the adapter node transfers data between the view node and the protocol node the protocol node transfers data between the adapter nodes and across the isolation boundary if present the adapter node transfers data between the protocol node and the view node and the view node transfers data between the adapter node and the add in . If the pipeline is unidirectional then the pipeline nodes and transfer data in only one direction. Furthermore the application add in and the pipeline nodes and may all run in the same execution domain or may run in two or more different execution domains. For example if the isolation boundary is present then the application the view node the adapter node and the protocol node may run in a first execution domain and the adapter node and the add in may run in a second execution domain. A pipeline similar to the pipeline 20 of FIG. 4 is described in U.S. Patent Application Publication No. 2007 0016691 A1 which was previously incorporated by reference.

Referring again to in summary an embodiment of the pipeline builder designs and instantiates the shortest available pipeline i.e. the pipeline having the fewest pipeline nodes between the application and the add in . If the application and add in views and are interface compatible and the application and the add in do not require an isolation boundary then the builder may design and instantiate the pipeline having only a single pipeline node for example as discussed above in conjunction with . If either or both the application and the add in require an isolation boundary and the application and add in views and are interface compatible and remotable across the isolation boundary then the builder may design and instantiate the pipeline implementing the isolation boundary and have only one pipeline node for example as discussed above in connection with . And if the application and add in views and are interface incompatible then the pipeline builder may design and instantiate the pipeline having only five pipeline nodes for example as discussed above in connection with . Consequently as long as the store stores the necessary pipeline nodes or the pipeline builder otherwise has access to the necessary pipeline nodes the pipeline builder is able to design and instantiate a pipeline between the application and the add in in virtually any situation.

Still referring to alternate embodiments of the run time environment are contemplated. For example the pipeline builder may be operable to design the pipeline for instantiation between executable nodes that are not software application or software add in nodes. Furthermore although an embodiment of the pipeline builder is described as being operable to perform certain functions other embodiments of the builder may be operable to perform any one or more but fewer than all of these functions. Moreover other embodiments of the builder may be operable to perform other functions in addition to or instead of the above described functions.

The portion of the flow chart in describes the operation of the pipeline builder during a pipeline design phase and the portion of the flow chart in describes the operation of the pipeline builder during a pipeline instantiation phase.

Generally during the pipeline design phase the pipeline builder identifies one or mode add ins that meet the criteria specified by the application designs and generates descriptions of all the possible pipelines that can be instantiated between the application and the identified add ins given the available view nodes and other pipeline nodes and presents to the application the identified add ins for which at least one pipeline description has been generated a pipeline description is a design specification for example in the form of a file that describes the pipeline and from which the pipeline builder can instantiate the pipeline.

And generally during the pipeline instantiation phase the pipeline builder determines whether or not the application or add in selected by the application requires an isolation boundary. If an isolation boundary is required then the pipeline builder determines from the previously generated pipeline descriptions whether there are any available pipelines that can implement the required boundary and if there is at least one such pipeline instantiates one of these at least one pipelines between the application and the selected add in. If no isolation boundary is required then the pipeline builder may instantiate any one of the available pipelines from the respective pipeline description. If in either of the above situations i.e. isolation boundary or no isolation boundary required there are multiple available pipelines then the pipeline builder may select from the available pipelines based on a predetermined criteria. For example the builder may select for instantiation the shortest available pipeline.

Referring to the operation of an embodiment of the pipeline builder during the pipeline design phase is described.

Starting at block of the pipeline builder receives a request from the software application to find an add in that meets one or more pre established requirements which may be included with the request or provided to the pipeline builder before or after the request. The application may initiate the request in response to a pre established stimulus such as a request from a user of the application. For example if the application is a word processor then the stimulus may be a user requesting the correct spelling of an English word. In response to the user s request the word processor requests the builder to find and instantiate an English language spell check add in. Furthermore if the pipeline builder is not instantiated at the time of the request from the application then the application s request may serve to instantiate the builder.

Next at block the pipeline builder finds available add ins that meet the pre established requirement s specified by the application . For example the pipeline builder may search the sub store and or any other location that may store add ins that meet the specified requirements.

If the pipeline builder cannot find any such add ins then at block the pipeline builder informs the software application via an error message or in another conventional manner that the requested add in is unavailable and thus that the pipeline builder cannot service the add in request. The application may then process this information in a conventional manner.

But if the pipeline builder finds at least one add in that meets the specified requirement s then at block the pipeline builder retrieves the application view and the respective add in view for each of the found add ins. For example the pipeline builder may retrieve the application view from the application from the sub store or from any other location and may retrieve each of the add in views from the respective add in the sub store or from any other location.

Next at block the pipeline builder compares the application view with the view of a first one of the found add ins.

Then at block the pipeline builder determines whether the first add in view is interface compatible with the application view .

If the first add in view is interface compatible with the application view then at block the pipeline builder generates respective pipeline descriptions for the two single node pipelines e.g. the pipeline of that respectively include the application view and the view of the first add in. The pipeline descriptions may be respective files or may have any other suitable format. The pipeline builder generates descriptions for two single node pipelines instead of only one single node pipeline because if the application or the found add in requires an isolation boundary discussed below in conjunction with then having two pipeline descriptions increases the chances that at least one of the single node pipelines is able to implement the isolation boundary. Alternatively because the first add in view is interface compatible with the application view the pipeline builder may generate a description for only one single node pipeline that includes either the first add in view or the application view.

Next at block the pipeline builder generates descriptions for other available pipelines between the first add in and the application . An available pipeline is a pipeline that the pipeline builder can design and instantiate from available pipeline nodes including the nodes in the store and nodes in other locations to which the pipeline builder has access. The other available pipelines may include single node pipelines having nodes other than the application view and the first add in view or multi node pipelines for example like the pipeline of . As discussed above the pipeline builder generates descriptions for these other available pipelines to increase the chances that at least one of these available pipelines is able to implement an isolation boundary that the application or the first found add in may require. Alternatively if the pipeline builder generates a description of at least one single node pipeline per block then the builder may skip block .

Referring back to block if the first add in view is not interface compatible with the application view then the pipeline builder skips block and proceeds directly to block .

If there is another found add in then at block the pipeline builder compares the view of the next e.g. the second found add in with the application view and repeats the steps in blocks and as described above.

At block the pipeline builder determines whether there is at least one found add in for which the builder has generated a pipeline description. That is the pipeline builder determines whether there is at least one found add in for which the builder can instantiate a pipeline with the available pipeline nodes.

If there is at least one such add in then at block the pipeline builder provides a list of these add ins to the application . The list may be in the form of a folder including files that each contain the source or compiled code of a respective add in or the list may be in any other form.

The application then selects an add in from the list and provides the identity of the selected add in to the pipeline builder which then enters the pipeline instantiation phase as discussed below in conjunction with . Alternatively the application may select more than one add in from the list or the pipeline builder may select one or more add ins from the list instead of or in addition to the application.

But if there is no found add in for which the pipeline builder was able to generate a pipeline description then at block the pipeline builder informs the software application via an error message or in another conventional manner that the builder cannot service the add in request because the necessary pipeline nodes are unavailable to the builder. The application may then process this information in a conventional manner.

Referring to and B the operation of an embodiment of the pipeline builder during the pipeline instantiation phase is discussed.

At block the pipeline builder receives from the application the identify of the listed add in that the application has selected for instantiation. Alternatively the pipeline builder may receive from the application the identifies of multiple listed add ins that the application has selected for instantiation. In this latter situation the below described steps of the pipeline instantiation phase may be repeated for each identified add in. Alternatively the pipeline builder may select the one or more listed add ins for instantiation particularly if there is only one listed add in. If the pipeline builder selects the one or more listed add ins then the pipeline builder may skip block . But for example purposes it is assumed in the following description that the either the application or the pipeline builder has selected the add in of for instantiation.

At block the pipeline builder determines whether the application or the selected add in requires an isolation boundary.

If neither of the application nor the add in requires an isolation boundary then the pipeline builder proceeds to block which is described below.

But if either the application or add in requires an isolation boundary then at block the pipeline builder determines whether there is at least one common isolation boundary that satisfies the isolation requirements and that is isolation compatible with both the application and the add in . For example if the application requires an isolation boundary of level three or higher and the add in can transfer data across an isolation boundary of level four or higher then an isolation boundary of level four or higher satisfies the isolation requirements and is compatible with both the application and the add in . Conversely if the application requires an isolation boundary of level three or higher and the add in can transfer data across an isolation boundary of only level two or lower then there is no common isolation boundary because no isolation boundary satisfies the isolation requirements and is compatible with both the application and the add in .

If there is no common isolation boundary that satisfies the isolation requirements and that is compatible with both the application and the add in then at block the pipeline builder informs the software application via an error message or in another conventional manner that the builder cannot service the add in request because the builder cannot implement the required isolation boundary. The application may then process this information in a conventional manner.

But if the pipeline builder determines that there is at least one common isolation boundary that satisfies the isolation requirements and that is compatible with both the application and the add in then at block the builder determines whether there are any available pipelines that can implement the at least one common isolation boundary between the application and the add in . To make this determination the pipeline builder examines the previously generated descriptions of the available pipelines between the application and the add in . For example if one of the common isolation boundaries is a level three isolation boundary there is available a single node pipeline that includes the application view and the application view is remotable across a level three boundary then this single node pipeline can implement a common isolation boundary for example as discussed above in conjunction with . Or if one of the common isolation boundaries is a level four isolation boundary and there is available a multi node pipeline that can implement a level four boundary then this multi node pipeline can implement a common isolation boundary for example as discussed above in conjunction with .

If the pipeline builder determines that there are no available pipelines that can implement a common isolation boundary then at block the pipeline builder informs the software application via an error message or in another conventional manner that the builder cannot service the add in request because the builder cannot instantiate a pipeline that implements the required isolation boundary. The application may then process this information in a conventional manner.

But if the pipeline builder determines that there is at least one available pipeline that can implement common isolation boundary then the builder proceeds to block .

At block the pipeline builder selects from the previously generated pipeline descriptions the available pipeline that best meets one or more pre established criteria. For example if there are multiple available pipelines a pre established criteria may be that the pipeline builder select an available pipeline having the fewest nodes. Under this criteria if there is one available single node pipeline for example as described above in conjunction with and one available multi node pipeline for example as described above in conjunction with then the pipeline builder selects the available single node pipeline. Or where an isolation boundary is required then a pre established criteria may be that the pipeline builder select an available pipeline that implements the common isolation boundary having the lowest possible isolation level. Under this criteria if a common isolation boundary of at least level three is required a first available pipeline can implement at minimum a level four isolation boundary and a second available pipeline can implement at minimum a level five isolation boundary then the pipeline builder selects the first available pipeline. If multiple available pipelines meet the pre established criteria to the same degree e.g. multiple available pipelines each have a single node then the pipeline builder may choose among these available pipelines in a pre established manner for example according to another pre established criteria.

Next at block the pipeline builder instantiates the selected pipeline as the pipeline . For example if the selected pipeline is similar to the pipeline of then the pipeline builder retrieves the adapter nodes and and the protocol node from the sub store the pipeline builder may already have the application view and the add in view per block in or may retrieve these views from the sub store and instantiates these nodes along with the application view and add in view nodes to instantiate this pipeline between the application and the add in .

Next after instantiating the pipeline per block at block the pipeline builder notifies the application that the pipeline has been instantiated. In response to this notification the application and the add in may proceed to communicate via the instantiated pipeline .

Referring to alternate embodiments of the disclosed operation are contemplated. For example other embodiments of the pipeline builder may perform fewer or more steps than those discussed and may perform the steps in an order different from that discussed. Furthermore some of these steps may be performed by an executable software node other than the pipeline builder .

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention. Furthermore where an alternative is disclosed for a particular embodiment this alternative may also apply to other embodiments even if not specifically stated.

