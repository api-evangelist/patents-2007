---

title: Automatic API generation for a web application
abstract: A system and a method are disclosed for automatically providing an API for a Web-based application. An API processing core receives a call, performs a variety of actions on the call prior to executing it, determines based on the actions whether the call is a valid API call to the currently existing application functionality, and if the call is a valid API call, executes it. The call syntax is constructed primarily out of elements applicable to any Web-based application using the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504543&OS=08504543&RS=08504543
owner: Glam Media, Inc.
number: 08504543
owner_city: Brisbane
owner_country: US
publication_date: 20070309
---
The present application contains subject matter that may be related to the subject in one or more of the following commonly owned applications U.S. patent application Ser. No. 11 134 250 filed on May 19 2005 and entitled Hosted Application Server U.S. patent application Ser. No. 11 141 983 filed on May 31 2005 and entitled Content Access and Navigation U.S. patent application Ser. No. 11 195 378 filed on Aug. 2 2005 and entitled Shared Data Model U.S. patent application Ser. No. 11 195 349 filed on Aug. 2 2005 and entitled Interacting with a Shared Data Model U.S. patent application Ser. No. 11 213 309 filed on Aug. 26 2005 and entitled Content Selection and U.S. patent application Ser. No. 11 621 056 filed Jan. 8 2007 and entitled Web Application Cloning each of which are hereby incorporated by reference.

The present invention generally relates to the field of computer software and more specifically to Web based applications.

An application programming interface API allows programmatic access to the facilities of an application such as the data that the application manages and the operations provided by the application. Such programmatic access allows interaction with the application such as retrieving and updating application content through program code. This access through an API is typically exposed to other applications which can be either remotely or locally situated with respect to the application itself. In addition an API can often be accessed by a user through a suitable user interface for the application itself or from a client application such as a browser. Thus for example if a first application exposes its operations through an API then not only can a user manually interact with the first application through its user interface but a second application can also interact with it programmatically using its API.

Existing systems however require developers to manually design and code the API for the application operations that they choose to expose. This approach has a number of shortcomings. First it requires the developers to invest initial time and effort to provide the API an investment that could have been better spent in some more substantive and creative area of development. Second when the operations of the application change the manual API generation approach requires subsequent effort to reflect these changes in the API thus requiring ongoing effort on the part of the developers or in some cases restricts the functionality changes that can be made in order to ensure compatibility.

From the above there is a need for a system and method to automatically provide an application with an API.

A system and method automatically provides to a Web based application an API enabling client applications to access the application s functionality.

The system comprises an API processing core which analyzes and executes API calls received from various client applications and a data store which stores application data for various Web based applications. A call for a particular application is received from a client by the API processing core. The API processing core performs various preprocessing and validation actions on the call prior to executing it such as call syntax validation identifying the application for which the call is intended and security checks of the call the client and the application. As a result of these actions some of which involve communicating with the data store the API processor can determine whether the call is a valid API call according to the operations currently exposed by the application and the application s associated data. If the call is a valid API call the API processor executes the call against the data store and returns the resulting data if any to the client.

The call itself is specified largely according to a meta API syntax that is neutral with respect to any Web based application supported by the system. More specifically the syntax includes a component to identify an application to receive the call and one or more components identifying an operation to be performed on the application. The components are application independent in that they may be applied to any hosted application and are not specific to operations defined within an application. Application specific components of the call are limited to identification of specific resources e.g. data of the application on which the operation is to be performed. The use of the meta API for the call and the call verification checks performed by the system for any application specific portion of the call make it safe and simple for a client to specify a call to the functionality exposed by a Web based application with no need for the developer to manually provide an API.

The features and advantages described in the specification are not all inclusive and in particular many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings specification and claims. Moreover it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter.

The figures and the following description relate to embodiments of the present invention by way of illustration only. It should be noted that from the following discussion alternative embodiments of the structures and methods disclosed herein will be readily recognized as viable alternatives that may be employed without departing from the principles of the claimed invention.

An exemplary system architecture is now described wherein the applications for which their APIs can be provided are Web based applications running on a hosted application server. and their associated text discuss the general functionality of the Web based application e.g. the generation of its content pages using the exemplary architecture and and its associated text further discuss automatic API generation for a Web application operating within this exemplary architecture.

The system architecture is accessible by any number of clients although for clarity only one is shown via a network such as the Internet the system may alternatively or additionally be accessible via one or more other networks or combinations of networks. For example architecture may be accessible via a local area network LAN such as a network maintained and owned by a particular organization e.g. school company and or a wireless e.g. 801.11 Zigbee etc. or mobile e.g. cellular network. Additionally in some cases the client making a request may be another application hosted within the system or by an application at a remote location over the network for this reason the term client herein shall be used to refer to any type of application that is adapted to make a request of the system .

Architecture includes an API processing core and a runtime engine and application store each of which has one or more modules. As used herein a module is any program logic and or functionality that is implemented in software and or hardware. The API processing core handles both requests for providing an entire Web page of content and for executing an API call the latter typically being one step in accomplishing the former and includes a preprocessing module that analyzes requests from the client . A request can be initiated for example by a user at client entering a Web page address i.e. a uniform resource locator URL associated with a Web application supported by architecture . A request may also be generated by the user selecting a link via for example a mouse click on a Web page that references a Web application supported by architecture . A request may also be generated by an application such as application or making a request for content held in content store .

The runtime engine and application store are adapted to store in memory and execute Web applications written in various programming languages. For example the runtime engine and application store can support web applications in any one or more of the PHP JavaScript Ruby Perl and Python programming languages. Each Web application has an owner and as such the runtime engine and application store may store Web applications for a plurality of users each user being able to access at least his or her Web applications stored in the runtime engine and application store . In addition the Web applications are made available to be viewed and used by users other than their respective owners. In other words the system enables users to create and share applications amongst any number of other users. This feature goes beyond existing application hosting websites or social networking websites which provide a fixed set of one or more applications and at best allow users to create upload and share content or data. In these existing systems the applications provided by the site are created only by the site owner and developer users themselves cannot create new applications to be hosted on the site and shared by others.

Generally the applications access various types of data managed by the content store . The content store is a common structure in which data can be stored shared and retrieved by multiple web applications . In other words the content store includes a shared set of data that may be accessed and modified by multiple users or web applications . Objects data in the content store are contributed by architecture itself and or by users of architecture . As shown in the content store includes one or more substores . Particularly the content store includes an apps data substore a content data substore a users data substore and a tags data substore . The apps data substore stores metadata about applications such as the identity of the owner the content data substore stores application content objects discussed below the users data substore stores information on system users such as username and password as well as profile metadata and the tags data substore stores identities of the content objects users applications or other objects that a user has tagged with a personal string as well as the value of the tag itself. A further description of embodiments of the content store is provided in U.S. patent application Ser. No. 11 195 378 referenced above as being incorporated herein.

As noted above each application has an owner which will be one of the users each user is registered with the system and has a user record in the users data substore . A user may be the owner of any number of applications . For each application the owner sets the access privileges that are available to others. The owner can make the application available to all other users or to any specified group or groups of users. The owner can also specify the level of access to the application s own functionality e.g. the ability to modify the application and the level of access to the application s data in the content substore e.g. create read update delete .

Referring again to in general the preprocessing module authenticates requests from the client . The authentication process includes authenticating a user and determining privileges associated with that user. To authenticate the user name and password information is accessed from the user data substore similarly the user s privileges with respect to the system or particular applications are accessed here as well. The authentication process can also include adding information e.g. tokens to an incoming request and or performing one or more security measures e.g. recording an internet protocol IP address of the client .

Upon authenticating a particular request the preprocessing module passes the request to the runtime engine and application store via an appropriate language application program interface API for the application selecting the appropriate language API based upon the source languages of the code modules in which the Web based application is implemented and which are implicated by the request.

In general an incoming request to the runtime engine and application store causes execution of code in the web application referenced by the request. The execution may for example directly call up particular web services or make callbacks to API processing core . Callbacks to API processing core request a service from a shared services module . In general the shared services module provides services to users for use in their web applications. More particularly for example the shared services module provides services for messaging user registration tagging searching account management navigation and or advertising. Further the shared services module can make calls to a content store to access any data of the substores therein. As instances of execution are completed in the runtime engine and application store the runtime engine and application store outputs the results of each call to a post processing module in API processing core . The post processing module takes the output from the runtime engine and application store and builds a web page or other form of result that can be delivered to and displayed at the client .

It is within the context of such a system that the automatic API generation of the present invention operates.

Web based applications require an application layer network communication API to transmit a call across the network from the client to the Web based application. There exist various design methodologies for network communication APIs including remote procedure call e.g. XML RPC service oriented architectures e.g. SOAP and representational state transfer REST . The present invention is not limited to a particular one of these methodologies for performing application level network communications. Rather the particular methodology is a design choice left to the system designer.

In one embodiment the REST methodology is employed to implement the network communications API. A REST based communication system transmits domain specific data over an application independent protocol such as the HTTP application layer protocol without employing an additional messaging layer such as SOAP. Further the application data and operations desired to be exposed as application services are described as resources identified by a universal syntax such as a uniform resource locator URL and are manipulated solely using standard verbs commands within the application layer protocol such as HTTP command verbs GET PUT POST and DELETE. As a result application developers do not need to impose any further application specific processing overhead on the clients such as constructing SOAP compliant messages or marshalling data for RPC type commands.

The client issues a call to the Web based application the call being received by API processing core . The call is in the form of an HTTP request with the syntax of the call constructed with a restricted set of application independent operators and parameters that can be applied to any of the applications i.e. the operators and parameters are not defined by the applications as well as whatever application specific resources or data are to be handled for the request. The API processing core then performs a number of steps to analyze and execute the call including validating the call syntax checking the call operation and executing the call against the content store . These steps are further described below with reference to the above embodiment of hosted Web based applications where the network communication API is designed according to the REST methodology. One of skill in the art would realize however that the application is not limited to these particular embodiments. For example the Web based applications need not all be within the same system nor need they structure their services or data storage in the manner disclosed nor need the REST methodology be employed for network communications.

The API processing core validates that the URL has proper syntax. The syntax for the call identifies the application for which the call is being made the data protocol for the result to be returned and the operation defined by operators and parameters to be executed on the application and its associated data. As noted above apart from the data described in the call all other syntax elements are application agnostic and hence available for all applications. This is one feature that frees the application developers e.g. the owners from having to write their own APIs for their applications.

In one embodiment the syntax of the URL is of the form . In the sample URL restaurant.host.com xn atom 1.0 content author steve restaurant.host.com is the application pathname component that identifies the application xn atom 1.0 is the data protocol pathname component that describes the language format for the result and content author steve is an example endpoint pathname component that defines the operation to be executed. Within the operation content describes the operation type and author steve is a parameter here called a selector. Selectors are parenthesized portions of the endpoint that serve as filters that control what information is returned from the endpoint. They consist of arbitrary boolean expressions that involve field selector operator and value and that can be nested using parentheses. The endpoint can include multiple operators and selectors.

More specifically the application pathname component specifies the name of the particular application to be called. For example the name restaurant.host.com specifies the application named restaurant that is hosted in the domain host.com. Additionally a particular reserved name such as api.host.com may be used to specify that a call is to be issued to the API processing core itself which supports actions that can be applied against any or all of the applications such as accessing metadata about any of the applications . In such a case the Web based application may itself be a composite of all the hosted Web based applications so that the application data includes the union of data and metadata for the set of all applications.

The data protocol pathname component specifies the data format provided in the request and expected for the response. For example xn atom 1.0 specifies that data returned by the call should be in version 1.0 of the Atom XML data protocol. Of course data protocols other than Atom may be used.

Finally the endpoint s types specify the type of API call desired and the endpoint s selectors if any specify the particular attributes of the call. For example for endpoint content author steve the operation type content specifies that the application should return its own content data objects and the selector author steve specifies that more particularly the application data objects returned should be those created by the application user steve. The endpoint types preferably are taken from a fixed set of endpoints defined by the system designer and applicable across all applications . In one embodiment the set of endpoints is content application profile and tag allowing access to content objects application metadata user profiles and user tagged objects respectively stored in the various substores of the content store . The various attributes specified by the selectors may be either general or application specific. For example the compound selector author steve my.avgRating 4 includes both a general attribute applicable to all applications i.e. the author of the application and an application specific attribute i.e. the my.avgRating data .

The following tables further describe the details of the API syntax for one embodiment of the system .

Note that the selector parameters such as C P R and T in the endpoints of Table 1 may specify application specific values effectively creating an application specific call out of what is otherwise an application neutral meta API. 

Table 2 lists the selector operators that are used within the field selector operator value triplets used in selectors according to the preceding exemplary embodiment.

Note that not all fields can be used with all selector operators and not all fields and selector operators can be used in all selectors. Tables 3 through 7 list which fields and selector operators are available in the different kinds of selectors according to the exemplary embodiment.

The selector values may be of various types such as strings numbers or dates. Table 8 sets forth a description of how a set of supported types is specified according to the exemplary embodiment discussed above.

The combination of the application data protocol and endpoint components as well as application neutral values of the selector component can be seen as constituting a meta API applicable to all applications running on the hosted Web server. The addition of selectors that reference application specific attributes results in an API specific to a particular application. As a result owners of the applications need not write any specific APIs for their applications at all. Rather they need only define the data which the application uses and any internal functionality that operates within the application itself. Note that the applicability of the meta API to each hosted application makes for much more efficient API call processing than if each application had an API with an entirely distinct format since this allows the API processing core to execute much optimized general purpose code before being required to examine application specific details.

Referring again to the API processing core performs various availability and security validation actions on the call in order to ensure that it is both possible and safe to execute the call. One action is to verify that the specified application does in fact exist and is available. This is done by querying the data store for the application identifier. If the data store validates the existence of the application the core continues processing.

Another action is to ensure that the client has permission to perform the action specified by the endpoint i.e. the call does not violate application security settings. This may be accomplished by querying the data store for the owner of the application and comparing the current user against the owner s security constraints. For example one simple security scheme is to allow the call if the current user is the owner but if the current user is not the owner to allow the call only if the current user is on the owner s list of authorized users. A more complex security scheme also takes into account the level of privacy of the data and whether the request involves reading or writing data. For example data designated private is not be accessible by any user other than the owner and a read of non private data is allowed to any user but a data write is allowed only for the author and his or her authorized users. Alternately in another exemplary security scheme operations that create update or delete data may be performed only by the owner of the application. In such a scheme the operation may be performed over the Secure Sockets Layer SSL protocol specified by the URL beginning with https rather than http with the authentication credentials being sent according to the HTTP Basic Authentication standard.

Yet another action is to verify that the actual data read and or written has a format matching that specified in the call. Since the format of an application s data can be changed over time it is important that the automatically provided API accounts for these changes. Thus if a particular data field in the data for an application has 2 elements e.g. a user has first name and last name the API processing core will accept calls specifying 2 elements but not those specifying 3 unless of course in a particular context it is desirable to allow implicit creation of new data. In the latter case the API processing core can modify the schema for the data and update it to include the additional data elements. Then after the data field has been set to have 3 elements however the API processing core will automatically accept calls specifying 3 elements. This automatic adjustment of the API can be accomplished by dynamic checking of the current data store schema for the relevant data.

The API processing core checks that the payload of the HTTP request if any is well formed and valid according to the data protocol specified by the data protocol component of the URL. For example if the data protocol component is xn atom 1.0 the API processing core verifies that the payload conforms to the general XML syntax and more specifically to the semantics of version 1.0 of the Atom XML data protocol. Note that this verification is skipped when the HTTP request corresponding to the URL of the received call has no payload as is usually the case for operations resulting in data reads but no data writes.

If all the validation checks of steps above result in positive outcomes then the API processing core determines that the call is a valid call within the API of the Web based application to which the call is directed and proceeds to execute the call as described below. If any of the checks fail however the API processing core rejects the call invokes its own error handling routines and returns an error code and optionally an explanation and terminates processing rather than proceeding to the following steps.

The API processing core determines which HTTP I O command e.g. GET POST PUT DELETE to use to carry out the request by examining the request line of the HTTP request message. Once the appropriate command has been determined the API processing core then runs it against the content objects and metadata for the specified application supplying any needed parameters from the call request payload.

After determining that the call is a valid call to the API of the specified application and having determined what HTTP I O command to use to carry it out the API processing core executes the call performing the action specified by the endpoint URL component against the data store s content objects and metadata for the specified application.

If the call is one resulting in creation or modification of data of the content store such as a call entailing a PUT command then at step the content store responds to the issued call by modifying the data accordingly. For example if the call specifies a DELETE command for the URL restaurant.host.com xn atom 1.0 content author steve then the content store will delete all content objects with author steve .

It is expected that most calls will involve textual data. Creation of binary data may be accomplished in much the same was as textual data however the difference lying in the request headers request payload and the URL query parameters rather than in the main body of the URL itself. For example posting a block of text and a binary image object to a given application would involve the same URL body e.g. restaurant.host.com xn atom 1.0 content. However creating the block of text would involve the HTTP request payload containing an XML document such as one following the Atom data protocol and the binary image object would involve a payload containing the raw binary data. Additionally creating the binary image object would involve providing a suitable MIME type for the HTTP Content Type header e.g. image png and placing a binary true parameter in the URL query string.

If the call is one resulting in retrieval of data from the content store such a call entailing a GET command then the content store responds to the issued call by returning the requested data. For example if the call specifies a GET command for the URL restaurant.host.com xn atom 1.0 content author steve then the content store will retrieve all content objects with author steve and return them to the API processing core which will in turn communicate the retrieved content objects to the client .

Finally as described above in conjunction with the post processing module can then use the current state of the content store and or application store to generate a web page or other form of result to be delivered and displayed at the client .

Thus by providing a flexible meta API applicable to a each of a set of Web applications with at most only a small number of well defined points required for specifying application specific details and by providing runtime system checks to ensure that the application specific portion of the call properly accesses operations currently exposed by the application the application developer is freed from the necessity of providing his or her own API. Rather a client can easily specify a call using the basic meta API with application specific details specified as needed and the system can properly interpret verify and execute the call leaving the developer free to concentrate on tasks more creative and productive than routine API specification and maintenance.

The present invention has been described in particular detail with respect to one possible embodiment. Those of skill in the art will appreciate that the invention may be practiced in other embodiments. First the particular naming of the components and variables capitalization of terms the attributes data structures or any other programming or structural aspect is not mandatory or significant and the mechanisms that implement the invention or its features may have different names formats or protocols. Also the particular division of functionality between the various system components described herein is merely exemplary and not mandatory functions performed by a single system component may instead be performed by multiple components and functions performed by multiple components may instead performed by a single component.

Some portions of above description present the features of the present invention in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations while described functionally or logically are understood to be implemented by computer programs. Furthermore it has also proven convenient at times to refer to these arrangements of operations as modules or by functional names without loss of generality.

Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system memories or registers or other such information storage transmission or display devices.

Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention could be embodied in software firmware or hardware and when embodied in software could be downloaded to reside on and be operated from different platforms used by real time network operating systems.

The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may also be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the art along with equivalent variations. In addition the present invention is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein and any references to specific languages are provided for invention of enablement and best mode of the present invention.

The present invention is well suited to a wide variety of computer network systems over numerous topologies. Within this field the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network such as the Internet.

Finally it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly the disclosure of the present invention is intended to be illustrative but not limiting of the scope of the invention which is set forth in the following claims.

