---

title: Method and system for implementing hierarchical permission maps in a layered volume graph
abstract: The invention is for a method of mapping hierarchical volume permission to top level permissions in a layered volume graph of a virtual data storage system with hierarchy of storage volumes requiring permission at every volume level and the top level volume exposed to the hosts via intelligent switches comprising: applying volume level permissions on a volume of the volume graph and mapping condensed permission hierarchically for the entire volume graph to the top level volume from said individual volume level permission.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07849281&OS=07849281&RS=07849281
owner: EMC Corporation
number: 07849281
owner_city: Hopkinton
owner_country: US
publication_date: 20070313
---
The present application claims the priority to India Patent Application No. 298 KOL 2006 filed on Apr. 3 2006 entitled METHOD AND SYSTEM FOR IMPLEMENTING HIERARCHICAL PERMISSION MAPS IN A LAYERED VOLUME GRAPH the contents and teachings of which are hereby incorporated by reference in their entirety.

The present invention relates to a system having a hierarchy of storage volumes requiring permissions at every volume level and more particularly to a mechanism of mapping hierarchical volume permissions to top level permissions in a volume graph structure supported by intelligent multi protocol switches.

Storage virtualization or just virtualization is defined as the process of taking many different physical storage networks and devices and making them appear as one virtual entity for purposes of management and administration. The view of the storage device structure may not correspond to the actual physical storage system hence virtual . Virtualization using intelligent multi protocol switches separates host commands into Slow Path and Fast Path. Slow Path commands consist of all Non READ Non WRITE Small Computer System Interface SCSI commands in an input output IO stream viz. INQUIRY READ CAPACITY TEST UNIT READY etc. whereas all READ WRITE SCSI commands qualify as Fast Path commands. All Slow Path commands can be faulted back to the Storage Application and appropriate response can be generated. Fast Path commands on the other hand directly go the back end.

Storage Applications may rely on volumes of data. These are logical volumes or logical objects . In order for many Storage Applications to work in tandem e.g. Mirroring a Snapshot volumes must be organized as a hierarchical graph structure where each Storage Application owns a layer in the graph. Since each Storage Application should be able to work independently of each other every Storage Applications can apply individual permissions on the volumes it owns.

In Switch based virtualization the permissions applied on various volume levels need to be applied at the switch ports where IOs can either be faulted or let through based on the permissions. Switch vendors provide an application programming interface API to allow storage applications to set permissions whereby Storage Applications put volume permissions to control the behavior of Fast Path commands. The permissions determine whether Fast Path IO will get faulted back to the Storage Application will be held at the switch port or will be allowed. Examples of Storage Applications can be Clones Data Mobility Snapshot etc.

Storage area network SAN with controlled access to the hosts connected to the network is well known in the art. Host computers can be any type of computers for application processing operating systems and data management applications. The host computers may be connected over a network. This network may include switching nodes although any other form of network may be used. There are number of granted patents in the field that discloses methods for storage virtualization access control handling of overlapping requests and mapping of permission for different hosts in the control memory block. Some of these prior art patents in the field are briefly described below.

U.S. Pat. No. 6 993 589 discloses a method and apparatus for providing secure access to a computer system resource. The computer system includes a plurality of logical volumes of data that are visible to a host computer and a storage system. In accordance with one aspect of the invention a request from a requester having less than system administrator access privileges to perform an action directly on the one of the plurality of raw storage devices is granted so that a logical channel is provided for the direct access without the said logical channel being mapped by a file system LVM mapping layer contained in the host computer. According to another aspect a plurality of volumes of storage are visible to the application layer and access privileges less than the root access privileges are assigned to the at least one application program to access the plurality of volumes of storage.

Another approach for managing access to a plurality of storage resources in a computer system has been described in U.S. Pat. No. 6 993 581. In one aspect requests to access one of the plurality of storage resources from the application layer are intercepted and at least one of the interests is modified in a manner that will impact the access facility in determining whether the requestor satisfies the privilege level to be granted access to the one of the plurality of storage resources.

Yet another approach has been taken in the US 2004 0098424 A1 wherein metadata that relates logical block addresses of data used by a file system with the physical block addresses at which the data is stored is maintained in nodes that are arranged into a hierarchical volume map tree that extends from a root node to a plurality of leaf nodes. A method and apparatus is described for efficiently copying distributed data files. A copy of the volume map tree root node is maintained in a covolume and the modifications to that volume map tree copy is maintained as a new covolume by creating a new delta.

U.S. Pat. No. 6 535 891 discloses a technique for identifying accesses to a repository of logical objects stored on a storage system based upon information identifying accesses to physical storage locations. The repository is mapped from application space to physical space to create mapping information identifying which units of storage in physical space store the repository and the mapping information is made visible to the application space. An incremental operation is executed on the repository of logical objects. A further aspect is directed to a storage system that identifies to the host accesses to a repository of logical objects based upon accesses to corresponding units of storage in physical space.

Further a technique for host volume mapping for shared storage volumes in a multi host computing environment has been disclosed in WIPO Publication No. WO 01 20470 A1. The method for controlling access to a shared storage device includes the steps of associating a locally unique identifier with each of the plurality of computers defining a data structure in a memory identifying which particular ones of the computers based on the locally unique identifier may be granted access to the device and querying the data structure to determine if a requesting one of the computers should be granted access to the device.

Furthermore U.S. Pat. No. 6 842 843 discloses a digital data storage subsystem including arrangement for increasing cache memory addressability. A memory access request receiver module of a memory manager is configured to receive an access request requesting an access operation in connection with the memory the access request including an address. A memory access operation control module of a memory manager is configured to perform an access operation in connection with the memory using an absolute address generated by an address translation module. The address in an access request includes a segment identifier and an offset the address translation module being configured to process the segment identifier and offset to generate an absolute address identifying at least one storage location.

Another approach for storage mapping and partitioning among multiple host processors has been described in U.S. Pat. No. 6 799 255. A storage controller for controlling access to data storage has a memory and at least one data port for a data network including host processors. When the storage controller receives a data access request from a host processor it decodes a host identifier from the data access request and searches the memory for a host identifier matching the host identifier decoded from the request. Upon finding a match the respective specification of the respective subset for the host processor is accessed to determine whether or not storage specified by the storage access request is contained in the respective subset. If so then storage access can continue and otherwise storage access is denied.

However current limitation in switch implementation is that they do not support hierarchical volume permissions that is the multi protocol intelligent switches do not support permissions which are applied at various individual volume levels in a volume graph. On the contrary they require the permissions to be applied only at the top level volume of the graph which is exposed to the host via the intelligent port. Therefore the challenge is to create a mapping mechanism which can convert permissions at an individual volume level to be translated and applied at the top level. This kind of layered permissions is called a hierarchical permission map. Thus in order to make hierarchical Storage Applications e.g. data mobility or a cloned volume there is a need for a mechanism to map hierarchical permissions to top level permissions supported by the switches. The present invention aims to solve this technical problem for a storage area network SAN .

The invention deals with development of an algorithm to allow maintenance of hierarchical permission maps and the ability to condense the permissions by ORing the permissions hierarchically into a combined condensed and cumulative permission map which can be applied on the switches at the top level volume. The invention also allows for maintaining the hierarchical permission semantics and at the same time applying cumulative permissions on the switch. Apart from these to and fro mappings said algorithm provides condensation of the permission map by reducing redundancy and merging adjacent regions having same permissions.

Accordingly the present invention provides a method of mapping hierarchical volume permissions to top level volume permissions in a layered volume graph structure of a virtualized data storage system having a hierarchy of storage volumes requiring permissions or access control at every volume level wherein said top level volume is exposed to the host via intelligent multi protocol switch es said method comprising the steps of applying volume permissions on a volume within said volume graph structure and mapping condensed permissions hierarchically for the said entire volume graph structure to the top level volume from said individual volume permission.

The present invention also provides a system for implementing hierarchical permission maps in a layered volume graph structure of a virtualized data storage volume having a hierarchy of storage volumes requiring permissions or access control at every volume level said system comprising 

Intelligent multi protocol switch es between host server s and virtualized data storage volume said switch es being adapted to read the hierarchical volume permission set at the top most level of said volume graph structure 

means for condensing permissions from the individual volume levels to the top most volume level of said volume graph structure hierarchically for the entire volume graph structure for access control through said intelligent switch es .

The present invention further provides a storage area network connected to a plurality of host computers wherein the storage is a virtual storage with a hierarchical volume structure and the storage application is adapted to set permission for individual volumes in the volume graph and also map the hierarchical top level volume permission by condensing combining and accumulating individual volume level permissions to the top level volume in the hierarchy comprising 

at least one physical storage device configured to virtual storage volumes with a hierarchical structure 

a plurality of host computers connected to the virtual storage volumes through multi protocol intelligent switch es 

a controller device being a generic computing device that runs the applications for storage virtualization for applying individual volume level permissions and for mapping the hierarchical permissions to the top most level of the volume graph by combining condensing and accumulating the individual volume level permissions to the top most level wherein said application for mapping the top most level hierarchical permission initially sets ALLOW permission as the default permission for the entire region of the top most level volume in the hierarchy and then rolls up the individual volume level permissions to the top level volume whenever interrupted by a negative or hold permission in the corresponding region of next or subsequent child volume in the hierarchy a communication channel between the host computer s and virtual volumes through said intelligent switch es wherein all I Os from the hosts are broken into fast path or slow path and depending on the volume permission as read by the switch from the mapped top level hierarchical permission the fast path I O is faulted back to the storage application or allowed access to the respective physical storage as per the mapping module while generating appropriate message for the host when the access is denied or kept on hold and a table comprising the permission map with rolled up permission of all individual volume level permission to the top most level of the hierarchical volume graph wherein said table is embedded in a memory of said controller device to allow hold or deny access to the host requesting the permission.

The present invention further provides a computer operable program implementing the inventive method. In this connection there is provided a computer program product comprising a computer readable storage medium having a computer program embedded therein said program being adapted to map the volume level permission at the individual volumes to top level volume permission in a hierarchical volume graph of a virtual storage by rolling up the respective volume level permission to the top most level of the hierarchical volume graph wherein the permission applied to a corresponding region of a parent volume always gets precedence over the permission applied on the same region of child in the hierarchy.

The present invention provides these and other advantages as will be apparent to those having ordinary skill in the art upon reading of the following detailed description of the invention with reference to the accompanying drawings as briefly described below.

For purposes of the specification and claims a volume as illustrated in also called a Logical Unit LU represents a virtual contiguous storage space. It refers to a logical entity and may map to a physical disk or another volume that is it generally corresponds to a logical abstraction of physical storage. Regions in a volume are addressed by using the logical block address LBA . LBA for a volume starts from 0 and ends at the maximum capacity of the volume. Volumes can be stacked and layered above one another forming a hierarchical graph structure. The top level root volume of the graph represents the entire graph range. Typically IOs flow from top level root volume down the graph and take various paths depending on the IO range offset length .

A brief definition of the various terms that are used in the description is given below in order to facilitate understanding of the present invention. The invention is illustrated with reference to the properties of a volume which include its type capacity and the permission map it contains. There can be various types of volumes like slice concat stripe simple and mirrored. and give examples of how volumes can be constructed.

A slice volume as shown in represents a subset of an existing volume on which it is created. Its attributes are the offset into the original child volume LBA and its capacity Length . The length of the Slice Volume V in is just taken as an example. The Client application which creates the Slice Volume decides on the length. Concat Volume A concat volume as shown in represents an aggregate of an existing set of volumes. The capacity of the concat volume is the sum of the capacities of its child volumes. The address space of the new concat volume is a serial join of the address spaces of the child volumes. Mirror Volume A mirror volume as shown in represents a volume where every IO is replicated over all its children i.e. Mirrored. The capacity of the mirror volume is same as each of its child and all child volumes of a mirror have identical capacities. Volume Graph As mentioned hereinbefore a volume is a logical entity and can be constructed in various ways using other volumes. Similarly volumes of various types slice concat mirror can be combined to form a more complex structure called a volume graph. shows an exemplary layout of volumes configured with a hierarchical architecture. This is called layered Volume Graph and is also known as Hierarchical Volume Graph. Here a concat volume has been constructed out of three mirror volumes. As can be seen in the diagram a volume graph can be viewed as a hierarchy of volumes. Volume Permissions As IO is done on a volume it can be thought of being passed top down through the volume graph. For example if IO is done on volume V in it will pass down the graph via V and either V V or V depending on the LBA range on which the IO was done and its mapping in the child volumes. At every volume certain permissions can be applied which can control the action which ought to be taken in the event of an IO happening on a certain LBA range within that volume. Permissions can be Either FAULT ON READ Any READ IO on the specified range will result in the IO being faulted back to the storage application. FAULT ON WRITE Any WRITE IO on the specified range will result in the IO being faulted back to the storage application. ALLOW IO Allow both READ and WRITE to proceed on the specified range. HOLD IO Hold all IO until the permission is changed. A permission consists of the permission attributes FAULT ON READ FAULT ON WRITE ALLOW IO HOLD IO and the region offset length in the corresponding volume affected thereby. These permissions can be applied on an LBA range within a volume. At any point in time there can be multiple permissions on a volume on different LBA ranges as shown in . In this example if an IO happens in the LBA range 0 to 1000 all READ operations will get faulted back to the storage application. Further if an IO happens in the LBA range offset 1000 Length 2000 both the READ and WRITE operations will be continued. Furthermore if an IO happens in the LBA range offset 3000 Length 1000 all WRITE operations will get faulted back to the storage application. In a volume graph permissions could be independently applied at any volume level. Volume Extent A volume extent is defined as a region in a volume. It is represented by the offset length tuple where offset is zero based from the start of the volume and length represents the size of the region. The basic unit of offset and length is blocks. Typically an entire volume range can be broken down into a list of contiguous extents. Permission Mask A permission mask enumerates the various permissions that have been applied to a volume extent. In the algorithm this mask is represented as an enum 

A volume graph can consists of heterogeneous volume types concat slice mirrored etc. . Since the volumes are stacked hierarchically over each other there is a parent child relationship already established. To attain the objective of the present invention every volume type is expected to provide functionality for two basic models 

This method allows a region in a parent volume to be mapped into corresponding regions in the child volume s . A volume graph can consist of heterogeneous volume types concat simple mirror and each volume type will have a different algorithm for mapping regions in its child volumes. It may be assumed that such a mapping function is available for every type of volume. In object oriented terminology this is assumed to be a polymorphic method available in the generic volume class.

The behavior of the function for different kinds of parent volume types and in particular for Slice and Concat volume types is explained below 

In this case there is only one child volume possible and the region in the parent volume gets offseted by the ChildOffset as shown by the example illustrated in

A concat is made up of many child volumes and a region in a concat volume can map into more than one child volumes depending on the range as shown by the example illustrated in

The expected output of the function mapRegionInChild is a list each element of which contains the tuple ChildVolume Mapped LBA range as depicted in aforesaid and

This method works the other way from mapRegionInChild. It allows a region in a child volume to be mapped to the corresponding region in the parent volume. A volume graph can consist of heterogeneous volume types concat slice mirror etc. and each volume will have a different algorithm for mapping child regions in its corresponding parent volumes. It may be assumed that such a mapping function is available for every type of volume.

A region in a child volume with a Slice volume as its parent just maps the LBA range directly with adjustment done for the ChildOffset as shown by the example illustrated in

A region in a child volume with Concat volume as its parent maps in the corresponding area in the parent volume which the said child volume represents as shown by the example illustrated in

The expected output of the function mapChildRegion is the tuple containing the parent volume and the mapped region in the parent volume.

Apart from the above described two main methods each volume object is adapted to maintain a local permission map which represents the permissions applied at that volume.

The calculation of cumulative permissions according to the present invention is depicted in . The calculation is based upon the concept of condensing or ORing of permissions. Permissions can be applied by storage applications at any level in the hierarchy. More than one permission can be applied on a given volume resulting in a permission map for that volume. This map can dynamically change as per the current permission settings. To attain the objective of the present invention this map is required to be applied on the switches for which it needs to be condensed into a single map for the entire volume graph.

The example depicted in shows a typical hierarchical permission map where individual volumes V and V have permissions set on certain regions and the effective condensed permission map is calculated for the entire graph at the top level volume TLV .

A permission of FAULT ON READ has been applied on the volume V of the layered volume graph on the LBA range offset 100 Length 50 whereas another permission FAULT ON WRITE has been applied on the volume V on the LBA range offset 300 and Length 30.

The calculation of cumulative permissions on the top level volume V is started from the lower most volume leaves of the graph working the way upwards. The regions in the leaves are mapped to the corresponding regions in parent volumes and so on till the top level volume is reached. In the event of any permission being found set for a region on the way a note of it is made. If the corresponding region in the parent volume has a different permission set then the permissions of the parent take precedence. In the event of the mapped regions in the parent being set to ALLOW IO the corresponding child permissions are continued that is promoted. This process continues till all the regions in the leaves are mapped and effective permissions calculated.

Applying this method to the hierarchical volume graph in permission FAULT ON READ on child volume V LBA range offset 100 Length 50 maps to the corresponding region offset 300 Length 50 in its parent volume V. Since the corresponding region in the parent volume V already has a permission FAULT ON WRITE set on the LBA range offset 300 Length 30 applying the aforesaid logic of precedence parent permission for the length of 30 blocks is maintained and child volume permission is promoted for the rest of the parent length i.e. for 20 blocks. Accordingly effective permissions at volume V stand as shown in . Continuing this logic throughout the hierarchical volume graph leads to the final cumulative permissions for the top level volume TLV V which is the effective Top Level Volume Permissions as shown in the diagram of .

The size of the various volumes in the hierarchical volume graph may be suitably modified to meet the needs of a particular computer implementation.

The mechanism of mapping hierarchical volume permissions to top level permissions in a volume graph structure and the application of cumulative permissions on the intelligent multi protocol switch according to the present invention involves two main sub steps 

Each volume maintains a local permission map which contains the permissions applied on that volume. Said local permission map is maintained as a list of permission map entries. Each of the permissions is reference counted in order to allow the same permissions to be set by multiple clients. In order to reduce the complexity and the number of entries in the volume permission map the algorithm provides for condensation of the permission map by reducing redundancy and applies merge logic which combines adjacent extents in a volume if they happen to have similar permissions. The merge logic is explained hereinafter.

When a request to apply new permissions is received the algorithm works by calculating the existing regions in the volume which get affected. shows how a permission map for a volume changes as and when various permissions are applied to the volume. The previous permissions are overwritten with newly modified permissions.

Local volume permission maps get modified in the following manner Old Permission Map New Permissions New Permission Map Calculating Condensed Permissions

Once the local volume permission map has been applied it needs to be rolled up to the top level volume or the root of the volume graph for calculating the effective permission for the entire graph. For every region in the root volume which has permission set to ALLOW the corresponding region is mapped into its child volumes using the mapRegionInChild method. If the corresponding child regions have non ALLOW permissions those permissions are rolled up to the root level. In case the corresponding region in child is also set to ALLOW then the process continues to the next child level. It continues until either all root ALLOW regions have been filled up by rolling child permissions or we have reached the end of the graph. If the end of the graph is reached the corresponding root region gets set to ALLOW.

The basic idea underlying this technique is that ALLOW is considered as a hole and whenever there is a hole detected all child permissions in the volume graph are explored to ascertain whether permissions from a lower level can be promoted to fill the hole. The default permission being ALLOW which is the least restrictive in nature is applied at the top level of the graph and the entire graph is explored from the top through down the graph looking for more restrictive ones.

At any volume level if adjacent regions of a volume have similar permissions then it can be thought of as though the same permissions were applied to the combined region. This facilitates in merging of the adjacent regions into a single region with a bigger size hence reducing the number of permission entries in a permission map. Consequentially the size of the permission map is reduced. The technique of merging adjacent regions of a Volume Permission Map according to the present invention is shown in .

In the process of mapping condensed permissions to the top level volume an appropriate message is generated for a host trying to access a volume extent with FAULT ON READ or FAULT ON WRITE or HOLD IO permission.

There is no restriction on programming language for implementing the algorithm. The various methods according to the present invention may be implemented in any programming language like C C or Java . For purpose of illustration only the pseudo code is represented here in a C style of coding. For the purpose of the algorithm a volume is represented as a class containing the above methods. shows Class Diagram of Volume in accordance with the present invention.

In considering the specific manner in which the invention operates the two main sub steps involved in carrying out the methodology of the invention are as follows 

The method UpdateLocalPermissionMap updates the local permission map of a volume. It basically works by calculating existing map entries which will get affected and then overwriting the new permissions. If the new region intersects any old map entry regions the old regions are split.

The method CondensePermissions condenses the permissions for a region specified by mapEntry argument. It traverses down the graph to every child volume until permissions for the entire mapEntry region are calculated or the end of the graph is hit.

To attain the objective of the present invention at every volume level a method called update needs to be implemented as follows 

Based on the reference counts new permissions are set. If HOLD reference count is a non zero value block the node s READ and WRITE permissions are set to HOLD block . On the contrary if READ FAULT reference count corresponds to zero block then the node s READ permission is set to ALLOW block otherwise it is set to FAULT block . Similarly if WRITE FAULT reference count corresponds to zero block then the node s WRITE permission is set to ALLOW block otherwise it is set to FAULT block .

At this point there may be adjacent permission map entries in the map which might have similar permissions and reference counts. The method terminates at block where the entries can be merged in order to create a compact map.

The cumulative permissions for a mapEntry region are calculated as illustrated in starting from the top level volume going down to children until the permissions are no longer ALLOW or there are no more children.

The method of calculating effective cumulative permissions starts at block a and continues via block b where in the event of mapEntry s READ permission being set to ALLOW the READ permission of mapnode is taken to be equal to the mapEntry s READ permission block c . On the contrary if the mapEntry s WRITE permission is set to ALLOW block d then the WRITE permission of mapnode is taken to be equal to the map Entry s WRITE permission block e .

If the volume has children and any of the mapNode s READ or WRITE permission is set to ALLOW block f then the parent region is passed to the child volume and the process of condensing of the region permissions is continued blocks g h and i as a result of which a list of corresponding mapped Region in the child volume is obtained. On the contrary if the permissions are no longer ALLOW or the volume has no children the region is mapped back to the top level volume that is the volume where the process started and added to the condensed Permission Map blocks j k and l .

At this point there may be adjacent permission map entries in the map which might have similar permissions and reference counts. The method terminates at block m where the entries can be merged in order to create a compact map.

This technique can be applied to any system having a hierarchy of objects requiring permissions or access control at every object level. The algorithm is generic in nature and can be used to calculate effective object graph permissions or access control .

The present invention typically runs on a generic controller hardware which has connectivity to the intelligent switches. illustrates an exemplary diagram of a system for implementing the present invention. The controller device resides in the network as shown in the diagram of . The storage area network SAN of the system as illustrated in is connected to a plurality of host computers such as Host Host Host etc. and physical storage arrays such as Storage Storage etc. . In a preferred embodiment controller device and the applications running on the controller virtualize the physical storage into a virtual storage with a hierarchical volume graph structure and said storage application is also adapted to apply permission for individual volumes in the volume graph and for condensing combining and accumulating individual volume level permissions to the top level volume so that intelligent switch es connected to the top level volume in the hierarchy may read the resultant top level hierarchical permission as set for access control.

As an alternative to above preferred embodiment the application for storage virtualization and or for applying permission at individual volume level and or for setting condensed combined and accumulative hierarchical permission at the top most level may also run on the intelligent switch es instead of running on a separate controller device.

The number of storage devices hosts and intelligent switches as shown in are just for the example. There is no theoretical limit on these numbers as such. The controller device could be any network device capable of running this algorithm with processing capability and network connectivity.

Each virtualized storage volume can be presented to a cluster of hosts. The permissions on the volume are not affected by the number of hosts connected to the volume in as much as it is the storage applications which set permissions. The storage applications run on the controller device. I O initiated by the hosts gets affected due to permissions placed on the volume. If permissions on a volume change it affects I O from all hosts connected to it.

The host does not have direct access to the storage. All I O goes through the intelligent switch es where it gets broken into Fast Path or Slow Path. shows how the I O issued by host is split into Fast Path and Slow path by the intelligent switch. Which physical storage device the I O finally lands on is determined by the mapping logic running on the intelligent switch port. The volume permissions are controlled by the software running on the controller device or the intelligent switch es as the case may be. The volume permissions determine whether the Fast Path I O should get faulted back to the storage application or allowed to go to the physical storage as per the mapping rules.

While the invention has been described with particular reference to the illustrated embodiment numerous modifications thereto may be apparent to those skilled in the art. Accordingly the above description and accompanying drawings should only be taken as illustrative of the invention and not in a limiting sense.

