---

title: Methods and systems for in-place shader debugging and performance tuning
abstract: One embodiment of the present invention sets forth a system that allows a software developer to perform shader debugging and performance tuning. The system includes an interception layer between the software application and the application programming interface (API). The interception layer is configured to intercept and store source code versions of the original shaders included in the application. For each object in the frame, the interception layer makes shader source code available to the developer, so that the developer can modify the source code as needed, re-compile only the modified shader source code, and run the application. Consequently, shader debugging and performance tuning may be carried out in a manner that is more efficient and effective relative to prior art approaches.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08296738&OS=08296738&RS=08296738
owner: NVIDIA Corporation
number: 08296738
owner_city: Santa Clara
owner_country: US
publication_date: 20070813
---
Embodiments of the present invention generally relate to software graphics applications and more specifically to methods and systems for in place shader debugging and performance tuning.

As is well known graphics applications usually include many different shading programs referred to herein as shaders . Software developers commonly encounter situations where individual shaders must be modified in order to eliminate programming bugs or improve application performance. A typical cycle for debugging an application starts with a developer compiling and running the application and looking for anomalies as the application runs. One type of anomaly may be a visual anomaly such as when the armor of a knight being rendered is not shiny enough. Another type of anomaly may be a performance anomaly such as a low frame rendering rate. Once an anomaly is detected the developer typically exits the application attempts to identify the error in the shader code makes appropriate modifications to the shader code re compiles the application and then runs the application again to see if the modifications to the shader code fixed the anomaly.

One problem with this cycle is that even for moderately sized applications the turn around time associated with exiting the application making modifications to the shader code re compiling the application and then running the application again from the beginning may take a significant amount of time. For example the process of re compiling the application alone may take from several minutes to several hours. Another problem is that identifying the part of the shader code responsible for the observed anomaly may be a daunting task because of the large number of frames and the large number of shaders associated with the application. Furthermore after making the modifications to the shader code and re compiling the application the developer must be able to reproduce the original conditions such as a specific location camera angle and setting within a game sequence used to identify the visual anomaly well enough to determine whether the shader code modifications fixed the anomaly.

As the foregoing illustrates what is needed in the art is a more efficient technique for shader debugging and performance tuning.

One embodiment of the present invention sets forth a method for managing shader code in a graphics system. The method includes the steps of intercepting a source code version of a shader that is in route to an application programming interface API for compiling generating a copy of the shader source code intercepting a handle to a machine code version of the shader that is in route to an application generating a copy of the handle and associating the copy of the handle with the copy of the shader source code.

One advantage of the disclosed method is that by including an interception layer between the software application and the API modifications to shader source code may be made without having to exit the application and to recompile the entire application. In one implementation for each object in the frame the interception layer makes shader source code available to the developer for modifications so that the developer may simply pause the application modify the source code as needed re compile only the modified shader source code and un pause the application. As a result shader debugging and performance tuning may be carried out in a manner that is more efficient and effective relative to prior art approaches.

The graphics application typically includes multiple shaders configured to perform specific types of graphics rendering tasks such as those defined by the API . One well known graphics task defined by the API is the draw call operation. In order to execute the various shaders included in the graphics application for each shader the graphics application transmits the shader source code to the API to be compiled. The API in conjunction with the driver compiles the shader source code and passes a handle corresponding to the machine code version of the shader back to the graphics application . In addition the driver passes the machine code version of the shader to the GPU for storage until execution at a later time.

As set forth in below the interception shim is configured to store source code versions of the original shaders included in the graphics application as well as corresponding handles to the API handles of the original shaders stored in the driver referencing machine code versions stored in the GPU . The interception shim is further configured to enable a developer to modify the source code of one or more of the original shaders. If such modifications are made the source code versions of the modified shaders are stored in the interception shim along with corresponding handles to the driver versions of the modified shaders stored in the driver referencing machine code programs stored in the GPU . When executing the graphics application after such modifications are made the developer can select whether to implement the original shaders included in the graphics application or the modified shaders. For a given selection by the developer the interception shim is configured to pass either the API handle to the original shader or the API handle to the modified shader to the API so that the selected machine code version of the shader can be executed on the GPU .

The method begins in step where for each shader included in the graphics application the graphics application transmits the shader source code to the API to be compiled in conjunction with the driver . In step for each shader the interception shim intercepts the shader source code. In step for each shader the interception shim makes a copy of the shader source code. In step for each shader the interception shim transmits the shader source code to the API . In step for each shader the API in conjunction with the driver compiles the shader source code. In step for each shader the driver transmits the resulting machine code version of the shader to the GPU . In step for each shader the API transmits a handle corresponding to the machine code version of the shader to the graphics application . Persons skilled in the art will recognize that the handles transmitted to the graphics application are the same handles the graphics application may later pass to the driver to call a particular shader for execution. In step for each shader the interception shim intercepts and makes a copy of the handle. In step for each shader the interception shim associates the handle with the corresponding source code version of the shader stored in the interception shim . Finally in step for each shader the interception shim transmits the handle to the graphics application .

The method begins in step where a developer uses a frame debugger included in the interception shim shown as element in to render each frame generated by the graphics application on an object by object basis while the graphics application runs on the system . The frame debugger allows the developer to scroll through a frame from the first object to the last object watching as the scene is being constructed. For each object in the frame the interception shim makes the draw call invoked to render the object available for the developer to view. For example in one embodiment the draw calls may be shown to the developer through graphical user interface controls rendered on top of the display frames generated by the graphics application .

In step the developer identifies the draw call related to anomalous object. As previously described herein one type of anomaly may be a visual anomaly detected by the developer for example a wrong color of the object . In step the developer changes to the advanced frame debugger screen where state information including the shader source code stored in the interception shim is shown to the developer. In step through the frame debugger the interception shim makes shader source code corresponding to the anomalous object available to the developer for modifications. In an alternative embodiment the interception shim may make the assembly code for the shader available to the developer for modifications.

In step the developer modifies the source code of the shader used to render the anomalous object. In step the interception shim makes a copy of the modified shader source code and transmits the modified shader source code to the API to be compiled. In step the API in conjunction with the driver compiles the modified shader source code. In step the driver transmits the resulting machine code version of the modified shader to the GPU . In step the API transmits a handle corresponding to the machine code version of the modified shader to the interception shim . In step the interception shim associates the handle to the machine code version of the modified shader with the modified shader source code stored in the interception shim and with the handle to the machine code version of the original shader source code stored in the interception shim .

For example consider the case where the graphics application includes ten shaders. First the graphics application transmits the source code for each of the ten shaders included in the graphics application to the API to be compiled. As described in for each shader the interception shim stores a copy of the shader source code and pairs the source code version of the shader with the handle to the machine code version of the shader. The developer then renders each frame on an object by object basis looking for anomalies as the application runs. For the purposes of discussion only it is assumed that the developer identifies an anomalous object and that shader was used to render that object. Also it is assumed that the developer modified the source code of shader in an attempt to cure the anomaly as described in . As a result the interception shim stores the source code for the original shaders the handles to the machine code version of each of the original shaders the source code for the modified shader and the handle to the machine code version of the modified shader . More specifically the interception shim associates the handle to the machine code version of the modified shader with the source code of the modified shader as well as with the handle to the machine code of the original shader which is associated with the source code of the original shader .

In one embodiment the interception shim allows the developer to switch between rendering an object using the original shader and rendering an object using the modified shader to allow the developer to see the effect modifications to a particular shader have on the rendered object. Furthermore the interception shim allows the developer to switch and compare rendering output and performance related statistics for a frame rendered using the original shader and a frame rendered using the modified shader. The interception shim then provides the developer with an option to select whether to use the original or the modified shader when rendering the frames generated by the graphics application .

The method begins in step where the graphics application issues a draw call to render a particular object in a given frame generated by the graphics application . In step the graphics application transmits the handle to the machine code version of the original shader used to execute the draw call to the API . In step the interception shim intercepts the handle. In step the interception shim determines whether the developer has chosen to use the original or modified version of the shader. If the developer has chosen to use the original shader then in step the interception shim simply passes the handle to the machine code version of the original shader to the API . In step the API sends the handle to the driver where the driver maps the handle to the machine code version of the original shader stored in the GPU . In step the GPU executes the machine code version of the original shader to render the object.

If however in step the interception shim determines that the developer has chosen to use the modified shader then in step the interception shim passes the handle to the machine code version of the modified shader to the API . In step the API sends the handle to the driver and the driver maps the handle to the machine code version of the modified shader stored in the GPU . In step the GPU executes the machine code version of the modified shader to render the object.

More details regarding the functionality of the performance dashboard the frame debugger and the profiler are described in the related U.S. patent application titled A Method and System for Debugging a Graphics Pipeline Subunit filed on Aug. 1 2006 and having Ser. No. 11 498 203 the related U.S. patent application titled User Interface and Method for Graphical Processing Analysis filed on Aug. 1 2006 and having Ser. No. 11 498 207 and the related U.S. patent application titled A Method and System for Calculating Performance Parameters for a Processor filed on Aug. 1 2006 and having Ser. No. 11 497 863. These related patent applications are hereby incorporated herein by reference.

In the embodiments illustrated above the anomalous objects have been considered to have a visual anomaly for the purpose of discussion. As previously described herein another type of anomaly may be a performance anomaly related to the performance of the GPU . In one embodiment the interception shim includes a profiler configured to calculate and display frame related performance statistics such as for example frame rate GPU bottleneck and utilization information and so forth. Furthermore the interception shim further includes a performance dashboard shown as element in configured to calculate and display real time performance statistics of the GPU and Driver such as frame rate pixel rendering rate frequency of API calls memory utilization driver overhead etc. Using the performance dashboard and the profiler the developer may run performance analysis on a given frame generated by the graphics application and then identify a particular draw call as the one causing the performance anomaly. For example the developer may identify a draw call that requires excessive amount of time to render a particular object thereby decreasing the frame rate. The developer may then modify the source code of the shader used to execute the draw call in an attempt to cure the anomaly as described in . As also previously described the interception shim allows the developer to compare frame and performance related statistics by switching between rendering an object using the original shader and rendering an object using the modified shader. Thus after making the modifications the developer may render the frame using the modified shader to render the anomalous object to see if there is any impact on the frame rate. Using the frame rate readout in the performance dashboard the developer determines at a glance if the modifications have indeed improved performance. Finally the developer can re run profiling in order to further confirm that the modifications relieve previous performance bottlenecks in the GPU associated with executing the draw call.

In one embodiment of the present invention the computing device may be implemented as a desktop computer system or server computer system. Alternatively the computer device may be implemented as a set top video game console device such as for example the Xbox 360 available from Microsoft Corporation of Redmond Wash. or the Playstation 3 available from Sony Computer Entertainment Corporation of Tokyo Japan. Further the computer device may be implemented as a portable computing system such as a laptop computer personal digital assistant PDA cellular phone etc.

Although the computer device is depicted in with certain components to simplify the discussion it should be understood that the computer device may comprise additional and or alternative components devices buses etc. in other embodiments. Additionally it should be appreciated that elements of the computer device may be alternatively grouped. Furthermore although elements of the computer device are depicted as discrete components in it should be appreciated that they may be alternatively implemented as discrete integrated circuit dies e.g. mounted directly on the motherboard graphics card etc. or as components included within the integrated circuit die of a computer system chipset component.

One advantage of the disclosed systems and methods is that by including an interception layer between the software application and the API modifications to shader source code may be made without having to exit the application and to recompile the entire application. The interception layer is configured to intercept and store source code versions of the original shaders included in the application. For each object in the frame the interception layer makes shader source code available to the developer for modifications so that the developer may simply modify the source code as needed re compile only the modified shader source code and run the application. As a result shader debugging and performance tuning may be carried out in a manner that is more efficient and effective relative to prior art approaches.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention.

In addition persons skilled in the art will understand that the systems and methods described herein can be extended to multi GPU systems. In such systems there can be a separate interception shim for each GPU or a given interception shim can be configured to interact with multiple GPUs.

