---

title: Business object document mapper
abstract: In accordance with an embodiment, an architecture for directly interfacing Business Object Documents (BODs) may include a BOD mapper which employs the BOD for input and output. A model object definable by class is created corresponding to the data contained in the BOD. System logic for the local domain is provided with communication with the BOD mapper through a BOD mapper application programming interface. The logic operates on the model object and a mapping configuration is provided for relating elements of the BOD to the model object. An addressing element communicates with the BOD mapper to define the mapping configuration for the BODs operated on by the BOD Mapper for input/output and mapping for a map call and parsing for a list call is accomplished for the contents from the BOD to the model object as defined by the BOD mapping configuration.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07873679&OS=07873679&RS=07873679
owner: The Boeing Company
number: 07873679
owner_city: Chicago
owner_country: US
publication_date: 20070926
---
This application claims priority of U.S. Provisional Application Ser. No. 60 939 338 filed on May 21 2007 having the same title as the present application the entirety of which is incorporated herein by reference.

Certain software programs or routines disclosed in this application are subject to copyright protection and all rights thereto are specifically reserved. No dedication to the public of those copyrights is intended or made by such disclosure in this specification.

This invention relates generally to computer communications and more particularly to improved communications axing encapsulated message passing in various applications.

The Open Applications Group Integration Specification OAGIS Business Object Document BOD standard is a method for formatting messages that are encapsulated for transport using an eXtensible Markup Language XML format. These messages or BODs may be used to send and receive various types of data between participating software systems. Although the use of XML has many benefits the process of encapsulating a message in the XML format may require the creation of a large amount of code to convert the message data into a format that can be interpreted by a software system. For instance if a particular BOD contains 25 30 different fields. The corresponding code to transform the contents of that BOD could easily exceed many thousands of lines of code. Such transformation code may be expensive to create maintain and use. Therefore there remains a need in the art for an improved system and method for transforming BOD messages.

In one or more exemplary embodiments an architecture to reduce the complexities related to producing and consuming OAGIS BODs is disclosed. Such architecture eliminates the need to write verbose error prone and hard to manage code by parsing the BOD and then mapping its contents to a model object defined by the interacting software system or conversely mapping the contents of a model object in the interacting software system to a representative BOD. The architecture eliminates the need for interfacing systems to change code when an OAGIS BOD is modified. For the embodiments disclosed herein the interfacing system architecture provides a specific mapping function generally referred to as the BOD Mapper.

According to one embodiment an architecture may include a Business Object Document BOD mapper employing a BOD as input and output data files that conform to an Open Applications Group Integration Specification OAGIS standard. A model object definable by class corresponding to the data contained in the BOD allows system logic for a local domain to communicate with the BOD mapper through a BOD mapper application programming interface API adapted to operate on the model object. A mapping configuration relates elements of the BOD to the model object and an addressing element communicates with the BOD mapper to define the mapping configuration for the BOD to be operated on by the BOD Mapper.

According to another embodiment a method for interfacing of Business Object Documents BOD to a local domain may be accomplished by providing a BOD mapper which employs an OAGIS BOD for input and output. A model object is created corresponding to the data contained in the BOD which is definable by class. System logic is provided for the local domain which communicates with the BOD mapper through a BOD mapper application programming interface and operates on at least one model object to provide a mapping configuration for relating elements of the BOD to the model object. An addressing element is provided to communicate with the BOD mapper to define the mapping configuration for the BODs operated on by the BOD Mapper for input output. Mapping for a map call and parsing for a parse call is accomplished on the contents from the BOD to the model object defined by the BOD mapping configuration.

According to yet another embodiment a method implemented in Java to process OAGIS Business Object Documents BODs may include creating a plurality of Java model objects that allow for the storage of data contained in each BOD and creating a BOD mapping configuration file for each mapped BOD. How the contents of the BOD should be mapped to the Java model object is determined and an application programming interface API written in Java is supplied that the interfacing system calls. Mapping for a map call and parsing for a parse call is then accomplished on the BOD contents based on the BOD mapping configuration. For the exemplary embodiment a mapBod Java method a mapBodCriteria Java method and a mapResponseBod Java method a parseBod Java method a parseBodCriteria Java method and a parseResponseBod Java method are all defined in the BodMapper Java class.

The OAGIS Business Object Document BOD standard requires the involved system to have a high level of knowledge about the way a message is constructed. This requires that the same set of code be written to parse and map each BOD that the software system consumes and or receives. In addition the code that is required to parse and map the XML in a BOD is extremely verbose and hard to maintain.

It is therefore desirable to provide an architecture to abstract all fee complexities related to producing and consuming OAGIS BODs. It is further desirable that such architecture eliminates the need to write verbose error prone and hard to manage code by parsing the BOD and then mapping its contents to a model object defined by the interacting software system. It is also desirable that the architecture eliminates the need for interfacing systems to change code when an OAGIS BOD is modified. For the embodiments disclosed herein the interfacing system architecture provides a specific mapping function generally referred to as the BOD Mapper. The BOD Mapper and the architecture may be implemented using a standard Java based framework where Java is a trademark of Sun Microsystems Inc. of Santa Clara Calif. that reduces the effort required to send and receive messages while conforming to the OAGIS BOD standard. Using a standard framework shields the interfacing system from the complexities involved in parsing a BOD s XML and allows the software system to easily map a BOD s contents to a Java model object that is previously defined. While the examples provided for the embodiments are implemented using Java no limitation to Java code for embodiments of the present invention is required or implied. For the Java embodiment disclosed herein the BOD Mapper utilizes one open source library xmlbeans available via a free license from the Apache Software Foundation of Forest Hill Md.

The interfacing system may first create one or more Java classes that incorporate the data contained in the BOD. The interfacing system then employs a BOD mapping configuration file providing metadata defining the mapping for each mapped BOD. This mapping directs fee BOD Mapper how the contents of fee BOD should be mapped to the Java class written by the interfacing system. The specific required elements are the model class that will be mapped to the defined BODs the structure of the request BOD the structure of the response BOD and how the contents of the BOD fields relate to the model object . Table 1 provides an exemplary format for the configuration elements.

The BOD Mapper provides several Java methods that the interfacing system may call. In one exemplary embodiment there are four basic methods within the BOD Mapper. A BusinessObjectDocument mapBod Object model provides mapping of a model object or collection of model objects to a request BOD and the BOD s type is dictated by the BOD mapping for the supplied model s class. BusinessObjectDocument mapResponseBod Object model BusinessObjectDocument requestBod provides mapping of the model object or collection of model objects to a response BOD based on the supplied request BOD where the BOD s type is dictated by the BOD mapping for the supplied model s class. List parseBod Class modelClass BusinessObjectDocument requestBod which parses the contents of the supplied request BOD into a list of model objects. The BOD mapping that is used to parse the contents is based on the model class that is supplied. Finally List parseResponseBod Class modelClass BusinessObjectDocument responseBod parses the contents of the supplied response BOD into a list of model objects. The BOD mapping that is used to parse the contents is based on the model class that is supplied. Examples of mapBod and parseBod are provided in the OrderService example discussed subsequently herein for the first embodiment. The mapResponseBod and parseResponseBod methods provide identical functions except they map and parse the response BOD as opposed to the initial request BOD.

Additionally in alternative embodiments the BOD Mapper provides a mapBodCriteria Java method defined in the BodMapper Java class and a parseBodCriteria Java method defined in the BodMapper Java class. As an exemplary embodiment mapBodCriteria public static BusinessObjectDocument mapBodCriteria String selectExpressionName String selectExpressionParams Class modelClass maps the select expression associated with the supplied name to the configured BOD associated with the supplied model class. The select expression parameters will be used to populate the parameters defined in the BOD Mapper XML file for the supplied model class. e.g. 0 1 The select expression parameters will be populated in ascending order with the parameters defined in the select expressions value in the BOD Mapper xml. Similarly parseBodCriteria public static String paresBodCtiteria Class modelClass BusinessObjectDocument requestBod parses the select expression contained in the supplied BOD. The BOD Mapper then parses or maps depending on the method called the contents to or from the BOD defined in the selected configuration.

As shown for the exemplary embodiment in BOD Mapper is driven through a BOD Mapper API by generalized system logic in a local domain . The desired model objects shown representatively as two types model object type A and model object type B are constructs generated by the software logic to represent the domain model e.g. the data displayed maintained or otherwise operated on and the persistence of that data. The OAGIS BODs presented to the BOD Mapper are also shown representatively in as two types BOD type A and BOD type B . As described previously a mapping configuration is established and provided for use by the BOD Mapper for each BOD type BOD Type A Mapping Configuration and BOD Type B Mapping Configuration are accessed by the BOD Mapper for information corresponding to the two exemplary BOD types. A bodmapper.cfg.xml file provides the BOD Mapper the location and names of the BOD mappings. Using the mapping configurations the BOD s presented to the BOD Mapper are provided through the system as corresponding Model object s using the internal functions of the BOD Mapper Map BOD Parse BOD Map Response BOD and Parse Response BOD .

Embodiments of the present invention may be used to provide various services including retail purchasing and vehicle maintenance. As an example of the implementation of the system elements described a model for a wedding registry with the associated BOD object models and interfacing system logic is provided as shown in . In the example a standard form BOD with an order for two items is placed a wide screen television and a DVD player. The BOD incorporates the item number names of the items descriptive data including price and capabilities. The order number as well as registry number and type are also defined in the BOD. As an example for order number 1065648 placed by a user having ID on Mar. 7 2007. A first item has item number 121 for a 40 LCD Wide Screen TV priced at 1599.99 and characterized as a LCD Wide Screen TV with 1080 pixels resolution and 6000 1 contrast ratio. A second item has item number 548 a DVD Player priced at 199.99 and characterized as a DVD Player that up converts to 1080 pixel resolution. A gift registry is identified as having registry number 487 W and a registry type characterized as Wedding . The exemplary BOD is shown in Table 2.

The BOD configuration mapping file structured as previously defined for this example corresponding to the BOD of Table 1 for the example domain in is defined in Table 3.

The class shown in Table 3 represents the primary Java model object definition that is supplied by the interfacing system. All properties that are to be mapped parsed to the BOD are listed here. For the embodiment shown the property name and the bodName can be different. Additionally the type defaults to a string if not defined. Each property is required to have a getter setter in the associated model class that matches the name defined. In the example to support the orderNumber property the Order class must define String getOrderNumber void setOrderNumber longorderNumber .

An order may contain many purchased items for each item the Item class is represented as an association with the Order class. Additionally the node attribute defines how this association should be mapped within the BOD xml and the adder attribute declares that BOD Mapper should use the addItem method on the Order class to add a specific Item to the Order when parsing from a BOD.

In the exemplary embodiment shown in the table the Subclass represents an order placed for a gift registry. The GiftRegistryOrder must derive from the Order class and the node attribute indicates that the specific properties defined by the GiftRegistryOrder class should be mapped to a specific node within the BOD xml.

The model objects for the example which ultimately provide the data from the BOD through the BOD Mapper to the using system include an order object an item object and a gift registry order object . These objects correspond to the elements of the BOD. An exemplary order object is provided in Table 4.

The Order class sets a random order number for the object. As described herein for the exemplary code each property defined in the order placed by the BOD must have a corresponding getter setter that communicates the name of the property mapped in the BOD mapping configuration file. For the example shown the property String orderUserID is mapped using the property . The Set and setItems commands correspond to the items collection mapped in the BOD mapping configuration file as 

The getOrderDate and setOrderDate commands correspond to the orderDate property mapped in the BOD Mapping Configuration file . The getOrderNumber and setOrderNumber commands correspond to the orderNumber property mapped in the BOD mapping configuration file as . Finally the getOrderUserId and setOrderUserId commands correspond to the orderUserId property mapped in the BOD mapping configuration file . Business methods specific to the domain are then accomplished by the object. Exemplary of such methods in the code of Table 4 are processOrder cancelOrder or chargeOrderToUser the functions of which are self explanatory based on the titles.

The commands getDescription and setDescription correspond to the itemNumber property mapped in the BOD mapping configuration file . The getItemNumber and setItemNumber commands Corresponds to the itemNumber property mapped in the BOD mapping configuration file . The getName and setName commands correspond to the name property mapped in the BOD mapping configuration file . While the getPrice and setPrice commands correspond to the price property mapped in the BOD mapping configuration file .

The final object the GiftRegisteryOrder object is shown in example form in Table 6. As a feature of the invention shown in the exemplary embodiment the GiftRegistryOrder class is an extension of the Order class. Public class GiftRegistryOrder extends Order by a Java extension concept with the configuration.

For this object the getRegistryNum and setRegistryNum commands correspond to the registryNum property mapped in the BOD mapping configuration file . The getRegistryType and returnRegistryType commands correspond to the registryType property mapped in the BOD mapping configuration file .

The addressing element to connect the BOD Mapper with the model objects bodmapper.cfg.xml provides the location of the exemplary configuration mapping file for the example is shown in Table 7.

The BOD of Table 2 is mapped with this simple code to the configuration mapping file Order.bm.xml of Table 3. With the configuration mapping file objects and addressing element in place the system logic can then process the BOD information as required. Examples of processes conducted in the present example are an ordering system and an ordering service wherein the ordering system places an order via an order service.

Java code for the ordering system for the example is shown in Table 8. The ordering system relies on the conversion of data from the BOD by the BOD Mapper into the format of the various objects as defined above. This data is then recognizable to those business methods which are specific to the domain of the example.

The Ordering Service process is provided by example Java code in Table 9. This example shows how tire BOD Mapper API would be used to both map and parse an instance of Order to and from the PlaceOrder BOD.

In this example the OrderService would both send and receive order requests via sendOrder and processOrder respectively. The processOrder command processes an incoming order BOD by parsing the BOD into the proper format with the BOD Mapper and then processing the order itself. A BusinessObjectDocument is simply an object that represents the corresponding BOD XML as a Java class. The details of this implementation are not included in the BOD Mapper nor is it specific to its domain. The result provided by the inventive embodiment is simply an interface that should be viewed as the XML itself. The BOD represents the received place order BOD. There could be multiple nodes contained in the BOD thus the call to parseBod will return a List of all Orders.

The sendOrder command sends the supplied Order by first mapping it to the appropriate BOD as configured in the BOD mapping configuration and then sending the BOD via the interlacing system s messaging system. Finally the sendBOD command is implemented by the interfacing system since the BOD Mapper is not a full messaging system solution but simply a mechanism for translating an OAGIS BOD to and from a system model. This example demonstrates the flexibility and power of the inventive system. The ability for the BOD Mapper to transition the OAGIS BOD into an object which is then recognizable and directly operable by the domain processing the BOD greatly simplifies the interface programming requirements.

As an additional example embodiment a BOD Mapper as disclosed is used on a system architected as a system of systems solution which requires each individual sub system to communicate with each other via OAGIS Business Object Documents BOD . For the references in this example the OAGIS BOD is simply a message that is defined in XML that complies with the OAGIS BOD standard. These BODs are sent between sub systems via an Application Integration Manager AIM Gateway. The AIM Gateway acts as the main message bus between each sub system handling all the necessary routing and delivery of the BOD.

Communications on this interface between the AIM Gateway and each sub system is enhanced by the BOD Mapper capabilities. The BOD Mapper simplifies this interface by mapping the contents of a model object written by the sub system to a BOD for transmission to another sub system. An exemplary use is for communications in a Sustainment Data System SDS environment wherein the BOD Mapper may be used to easily integrate SDS related services for maintaining aircraft trucks automobiles motorcycles tanks ships hovercraft submarines and other vehicles weapons system or other complex devices. The term aircraft is meant to include any aerospace vehicle including a spacecraft an airplane and a helicopter. The phrase weapon system can include any mobile or fixed weaponry requiring periodic inspection and or maintenance. Further a suitable weapon system may be mounted on towed by contained in or associated with any of the vehicles described above. The example shown in and described herein is a brief description of elements of an aircraft discrepancy tracking system communicating over the gateway with the BOD Mapper simplifying the interface requirements on the Gateway. Submission of a discrepancy on an aircraft is accomplished via a BOD .

An example BOD for the discrepancy information transfer is shown in Table 10. In the code an example aircraft type a Boeing F A 18 Hornet has two discrepancies which are being submitted for an aft wing and a generator. The code provides all of the necessary data for the BOD including originator information a discrepancy number occurrence date model numbers part numbers and serial numbers.

Table 11 provides the exemplary configuration mapping for the example to provide the primary java model object definition that is supplied by the interfacing system

All properties that should be mapped parsed to the BOD are listed. As in the prior example the property name and the bodName can be different. The type defaults to a string if not defined. Each property is required to have a getter setter in the associated model class that matches the name defined. e.g. the Discrepancy class must have the following defined to support the discrepancyNumber property Siring getDiscrepancyNumber and void setDiserepancyNumber long discrepancyNumber . If the discrepancy involves a particular aircraft a subclass that represents a discrepancy specific to an aircraft is provided. The AircraftDiscrepancy must derive from the Discrepancy class. The node attribute indicates that the specific properties defined by tire AircraftDiscrepancy class should be mapped to a specific node within the BOD xml. An aircraft discrepancy may contain many parts involved in the discrepancy. The Part class is represented as an association with the AircraftDiscrepancy class. The node attribute defines how this association should be mapped within the BOD xml. The adder attribute declares that the BOD mapper should use the addPart method on the AircraftDiscrepancy class to add a specific Part to the AircraftDiscrepancy when parsing from a BOD.

The model objects which provide the data relating to the BOD through the configuration mapping for this example include a discrepancy origination an aircraft description for the aircraft on which the discrepancies exist and a part description for use in conjunction with the discrepancy definition. Table 12 provides an example of the discrepancy object.

Each property defined in Discrepancy must have a corresponding getter setter that corresponds with the name of the property mapped in the BOD mapping configuration file. For instance the property String originatorUserId must be mapped via the following property in Discrepancy.bm.xml. getDateOccurred corresponds to the dateOccurred property mapped in the BOD mapping configuration file 

The object for the aircraft discrepancy extends the discrepancy object with additional data. An example of this object is shown in Table 13.

In Table 13 public class AircraftDiscrepancy extends Discrepancy and includes Set which corresponds to the parts collection mapped in the BOD mapping configuration file including . Similarly addPart corresponds to the method name that was declared by the adder attribute on the collection within the BOD mapping configuration file. . The class getModel corresponds to the model property mapped in the BOD mapping configuration file . Similarly getTailNumber corresponds to the tailNumber property mapped in the BOD mapping configuration file 

In Table 14 getPartNumber corresponds to the partNumber property mapped in the BOD mapping configuration file while getName corresponds to the name property mapped in the BOD mapping configuration file and getSerialNumber corresponds to the serialNumber property mapped in the BOD mapping configuration file .

The local domain employs two local processes DiscrepancySystem and DiscrepancyService. The example demonstrates how the BOD mapper API would be used to both map and parse an instance of Discrepancy to and from the SubmitDiscrepancy bod. In this example the DiscrepancyService would both send and receive discrepancy submission requests via sendDiscrepancy and processDiscrepancy respectively.

An incoming discrepancy BOD is processed by parsing the BOD into the proper format with the BOD mapper and then processing the discrepancy itself. A Business Object Document is simply an object that represents the corresponding BOD XML. The details of this implementation are not included in the BOD mapper nor is it specific to its domain. This is simply an interface that should be viewed as the xml itself. Example code to submit an example discrepancy via the DiscrepancyService is shown in Table 15.

The DiscrepancyService class is demonstrated in Table 16 which demonstrates how the BOD mapper API would be used to both map and parse an instance of Discrepancy to and from the SubmitDiscrepancy bod. In this example the DiscrepancyService would both send and receive discrepancy submission requests via sendDiscrepancy and processDiscrepancy respectively.

There could be multiple nodes contained in the BOD thus the call to parseBod will return a List of all Discrepancies sendDiscrepancy Discrepancy discrepancy sends the supplied Discrepancy by first mapping it to the appropriate BOD as configured in the BOD mapping configuration and then sending the BOD via the interfacing system s messaging system. The sendBod command is not implemented by the interfacing system since the BOD mapper is not a full messaging system solution but simply a mechanism for translating to and from a system model.

Having now described the invention in detail as required by the patent statutes those skilled in the art will recognize modifications and substitutions to tire specific embodiments disclosed herein. Such modifications are within the scope and intent of the present invention as defined in the following claims.

