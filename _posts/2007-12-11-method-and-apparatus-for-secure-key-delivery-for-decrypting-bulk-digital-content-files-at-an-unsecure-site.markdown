---

title: Method and apparatus for secure key delivery for decrypting bulk digital content files at an unsecure site
abstract: Rather than downloading each content document on demand from the publisher location to the user site, at the publisher location, each content document is encrypted and then multiple encrypted documents are assembled into a distribution archive that is itself encrypted with a scheduled key. The distribution archive is then downloaded into a content server at the user site. When the content server receives the distribution archive, it decrypts the archive file and unpacks the encrypted documents. The scheduled key used to decrypt an archive file is included with an archive file that was sent previously to the user site in accordance with the subscription service. The scheduled key to decrypt the first archive file sent to the user is sent from the publisher to the user over a communication channel different from the communication channel used to send the archive file from the publisher to the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08130963&OS=08130963&RS=08130963
owner: Imophaze Research Co., L.L.C.
number: 08130963
owner_city: Dover
owner_country: US
publication_date: 20071211
---
This application is a continuation of U.S. application Ser. No. 10 615 278 which was filed on Jul. 8 2003 entitled Method and Apparatus For Secure Key Delivery For Encrypting Bulk Digital Content Files At An Unsecure Site which issued as U.S. Pat. No. 7 324 648 on Jan. 29 2008.

This invention relates to electronic commerce to methods and apparatus for distributing encrypted bulk digital content files to an unsecure site and to methods and apparatus for securely distributing keys that can be used to decrypt the bulk files.

Global distribution systems such as the Internet are increasingly being used for distribution of digital content that includes text and graphic information encoded in a variety of formats. However copyright holders and publishers of such digital content have been slow to embrace the use of the Internet for distribution of digital content because it has been difficult to control unauthorized copying and dissemination of the content once it has been delivered onto the Internet. In particular once content has been placed in digital form and delivered to a user it can easily be copied printed or forwarded to other users.

Thus providers of digital content desire to establish a secure global distribution system for digital content that protects the rights of the content s copyright holders. One prior art technique for controlling the distribution of digital content is shown in . In this technique unencrypted content is placed in a server farm that is located behind a secure firewall. A user such as user desiring access to the content stored in database logs in to the server using a conventional authentication scheme such as a password or subscription service. Once connected to the server an authorized user can view content and request a copy of that content as indicated by arrow . In response to this request the server retrieves the information from the database as indicated schematically by arrow and displays the content.

This conventional protection technique has several drawbacks. First many users prefer to view the content with a conventional web browser. In order to display the content in such a browser it is necessary to download a digital version of the content as indicated schematically by arrow . This digital version is typically stored at least temporarily in the computer and can be printed or forwarded to other users. Therefore in accordance with another prior art technique in order to view the content the conventional browser must be equipped with a plug in ActiveX components or another program which controls the browser and disables the printing function and prevents forwarding the content to unauthorized users. However in order to use this system it is necessary to first download and install the plug in the ActiveX libraries or other program before the content can be viewed. In addition since the content is not encrypted when it is downloaded to the browser it can still be stored and then later printed or forwarded to other users.

Another conventional protection technique is called a secure container system. In this system the content is delivered to the user in an encrypted form and is decrypted at the user s site by means of a decryption key. This technique provides a solution to protecting the document during delivery over insecure channels but has the same drawback as the firewall system in that the content must still be decrypted in order to present it to the user. The decrypted content can be stored and then later printed or forwarded to other users.

In both of these prior art systems all of the content is located at the publisher s location. Thus multiple and often substantial downloads from the publisher s location to the user s site are required for users to access the content. In many cases the users are connected to an internal corporate network or corporate intranet that is in turn connected to the Internet by means of a firewall and this latter firewall often interferes with the content downloads. Further many corporate entities find it desirable to manage the information at their own sites using their own hardware and in many cases proprietary software.

A content server is located at the user s site. This server delivers content locally to users at the site and logs content access at the site. The server also provides additional content encryption log authentication key transfer and key management services to ensure the security and authenticity of content data without substantially interfering with the user access.

Rather than downloading each content document on demand from the publisher location to the user site at the publisher location each content document is encrypted and then multiple encrypted documents are assembled into a distribution archive that is itself encrypted with a key that is created specially for that archive. This latter key is called the scheduled key for that archive. The distribution archive is then downloaded into the content server at the user site. When the content server receives the distribution archive it decrypts the archive file and unpacks the encrypted documents but does not decrypt each document. Instead the encrypted documents are stored in encrypted form in a local document database. In this system users can purchase a subscription service in which archive documents are sent to the user site on a regular basis.

In accordance with the principles of the invention the scheduled key to decrypt an archive file is included with an archive file that was sent previously to the user site in accordance with the subscription service. This prevents a third party who has improperly obtained the archive file from decrypting the file unless the third party has also obtained a copy of the previous archive file.

In one embodiment the scheduled key to decrypt the first archive file sent to the user is sent from the publisher to the user over a communication channel different from the communication channel used to send the archive file from the publisher to the user.

In another embodiment the scheduled key is encrypted along with the content in the archive file so that the archive file must be decrypted before the scheduled key can be extracted.

In still another embodiment the local content server logs content access at the site including various user activities such as login to the system registration creation of a user profile and the reading and printing of selected content documents. The logged activities are stored in a log file at the customer site. This log file is then sent to the publisher in return for a distribution archive containing new content. The contents of the log file can be extracted by a reporting server located at the publisher location formatted and provided to a reporting client.

The inventive content distribution system which is called hereinafter a metrics system can be configured to run in one of two modes including a publisher hosted mode and a distributed mode. In the publisher hosted mode the entire distribution system is located at the publisher s premises whereas in the distributed mode portions of the distribution system are located on the user s premises. These modes are described in more detail below. A content publisher chooses the configuration that best meets its desired business model and deploys or configures the application software accordingly.

A block schematic diagram of the content distribution system configured in the publisher hosted mode is shown in . A user operating a workstation accesses the distribution system over a network through a conventional browser program. Browser programs that are suitable for use with the invention include Microsoft Internet Explorer Netscape Opera or other Java 1.1 compatible browsers. Using the browser the user requests a document either by a file name or by a URL as indicated schematically by arrow . This request is received in the publisher s location by the publisher s content server . However rather than accessing the content data directly as in the prior art the publisher s content server refers the request to a metrics content server as indicated schematically by arrow . The metrics content server provides access to the publisher s content stored in database . It also creates a log file that records various user activities including login to the system registration creation of a user profile and the reading and printing of selected content.

The contents of log file can be extracted and formatted by a metrics reporting server and provided to a reporting client as indicated schematically by arrow .

More specifically the first time a user accesses the metrics contents server a registration file is created. This file includes user identifying information such as a user ID and a password that the user will utilize to access the system. This information is stored in a metrics user database as indicated schematically by arrow . The information in the metrics user database is used later to authenticate users who are requesting access to the publisher content.

The metrics content server interacts with a publisher content database as indicated by arrow . Each piece of content in the publisher content database has been processed by encrypting the document and providing a unique identifier called an object identifier OID that uniquely identifies that piece of content. This processing is performed by a metrics publishing tool that receives the output of the publisher s conventional publishing process . The metrics publishing tool encrypts documents for distribution via the distribution system. The process takes content files and optionally content metadata files as input and generates an encrypted document package document identifier and key data as output. The encrypted output is generated in one of two forms depending on the configuration of the distribution system.

Document level encryption is used when the metrics content server is running at the publisher s own trusted site. In this case the encryption can be performed in a batch process in order to protect entire collections of content in a single off line operation. Alternatively individual files can be dynamically encrypted as they are requested. Distribution level encryption can be used when a portion of the distribution system is running at a customer site. In the distribution level encryption model the publisher performs batch processing on content to prepare encrypted bundles or archives that contain document collections. The archives can then be distributed to customers either on portable media such as compact disks or via network downloads for example via the FTP protocol.

In either the publisher hosted or the distributed modes a user accesses the content in the same manner. shows a more detailed schematic block diagram illustrating the system components involved in a typical request and delivery of content. In this figure a user at user workstation interacts with a metrics server that could be located at a publisher or user premises by means of a conventional web browser running the work station . The steps involved in this process are illustrated in which when placed together form a flowchart illustrating the request and delivery of content with the inventive system.

As shown in the metrics server hosts a web server which actually performs the functions of login registration and delivery of encrypted content and corresponding decryption keys. This web server can be a conventional web server that acts as a container for a collection of servlets that actually perform the processing. Web server software suitable for use with the present invention is the Tomcat web server available from the Apache Software Foundation 1901 Munsey Drive Forest Hills Md. 21050 2747.

Servlets are programs that run within the web server and process requests from an HTTP client. The servlet container that is bundled with the Tomcat web server supports all servlet activity. In this architecture the servlet container provides the appropriate libraries to process requests. The servlet container contains four main servlets that perform login registration and content transfer. These include the login servlet the register servlet the request content servlet and the request key servlet . The operation of these servlets is described in conjunction with the flowchart illustrated in .

The content request and delivery process begins in step and proceeds to step where a user desiring a presentation of selected content contacts a publishing service or a web farm to request the content by means of a file name or URL or other identifier. In step this request is forwarded to the metrics server . In step the metrics server uses the login servlet to determine whether the user has previously registered with the system. If not the register servlet is used to update the user data files create a user profile and register the user as set forth in step .

After the user has been registered the metrics server downloads a metrics viewer applet to the web browser operating in the user workstation . The metrics viewer is an applet that retrieves and displays secured contents from the metrics server . In one embodiment this applet is a Java applet that operates in conventional browsers. The metrics viewer allows users to access content as they do in their familiar browser environments including reading printing and emailing of content to other users while retaining control of the content. In a preferred embodiment of the viewer the list of content use features can be changed by customization. For example publishers preferring not to allow printing can customize the viewer applet to disable or eliminate the printing feature. In general the viewer prevents storage of content by preventing storage of the information to the user s storage devices such as a hard drive.

In one embodiment the metrics viewer supports the following features 1 navigation within individual articles and overall navigation from article to article 2 setting bookmarks to favorite articles 3 e mailing an article to a list of e mail addresses 4 printing selected articles 5 logging into the metrics server and registering with the server and 6 searching by means of a search engine located within the metrics server in installations that support server searching. These operations are initiated by a viewer GUI that includes buttons for each operation. These buttons are trapped so that user activities can be logged as discussed below.

It should be noted that the content is only displayed in a window that is controlled by the viewer and that the viewer does not use any of the standard browser functions. Therefore the standard browser buttons or menu selections do not affect the display or manipulation of the displayed content and need not be disabled. For example since the content is displayed only in a window controlled by the viewer selection of the conventional print function in the browser will print only the content portion displayed in the viewer window and not the entire content document.

After the viewer has been downloaded the user can then use the viewer to locate desired content. A content article could be identified for example by document name or URL. In step the metrics viewer interacts with the request content servlet as indicated schematically by arrow to request a content document. The process then proceeds via off page connectors and to step where the request content servlet uses the provided document name or URL to retrieve an encrypted content file from the content files database . The metrics server then downloads the encrypted file to the metrics viewer .

As set forth in step after the encrypted file has been completely downloaded the viewer computes the OID for the document. This content identifier is calculated using the encrypted content itself. Although the content identifier can be calculated in many ways it is important that the identifier cannot be calculated from the content alone. Therefore the content identifier is related to the content but not directly derivable from the content.

An exemplary architecture and process for calculating the OID are shown in respectively. The process begins in step and proceeds to step where a hash of a secret string is calculated with a one way hashing mechanism . The secret string is embedded in the viewer code so that it is downloaded when the viewer is downloaded. The secret string may be obfuscated in the viewer code in a conventional manner to deter reverse engineering of the viewer code.

The one way hashing algorithm used by mechanism to create this hash for example may be an SHA 1 secure hashing algorithm as described in FIPS 180 1 at the web site located at URL http www.itl.nist.gov fipspubs fip180 1.htm. Then in step a hash of the encrypted content item is computed using for example the SHA 1 hashing algorithm in one way hashing mechanism . In step the hash computed in step is hashed with the hash computed in step using for example the SHA 1 algorithm again in hashing mechanism . The process then ends in step . The resulting OID value is mathematically likely to be unique to the particular encrypted file and cannot be derived from the data in the file alone.

Returning to in step the viewer requests a key for decrypting the file using the OID computed from the encrypted content. In particular the metrics viewer sends the OID to the request key servlet as indicated schematically by arrow . The request key servlet retrieves a decryption key from the key database using the OID to access the database. As set forth in step the metric server then downloads the requested decryption key corresponding to the OID to the metrics viewer . Next as set forth in step the viewer uses the key to decrypt the encrypted content file. Finally as set forth in step the viewer presents the plaintext content file in the web browser . The process then finishes in step .

In order to operate in the manner set forth in the content files must first be encrypted and the OIDs generated. As mentioned previously the encryption is performed by a metrics publishing tool. The steps in this process are set forth in and the internal architecture of the tool is shown in . The metrics publishing tool is responsible for encrypting the publisher s content and packaging it for distribution. The publishing tool could consist of a command line utility controlled through configuration files. Alternatively it is possible to customize the publisher s publishing environment so that the publishing tool is called through an application programming interface API .

The publishing process involves encrypting content and providing identifiers for the encrypted content generating decryption keys and linking the identifiers and the decryption keys so that the decryption key for a requested content document can be located. In order to provide the greatest level of flexibility and the highest level of security the encryption and key management implementations obey the following principles 

Next in step the publishing tool uses a file compressor to compress the content file using a conventional compression algorithm. For example Flate compression is suitable for use with the invention and is described in detail at the website located at URL http www.gzip.org zlib .

After compressing the file the publishing tool uses a key generator to generate a unique content key in step . For example in one embodiment the key generator could operate with the Blowfish algorithm and this key would be a 128 bit Blowfish key. Next in step the publishing tool uses an encryption engine to encrypt the content item with this unique key. Then in step the publishing tool uses an OID calculator to calculate a content identifier for the encrypted content item. This content identifier is calculated from the encrypted content by the same algorithm used by the viewer and described in connection with and . In this case the same secret string embedded in the viewer code is also embedded in the server code.

Returning to the OID is stored with the decryption key for the content item. In step the content key is encrypted using the key encryptor with a secret key that is unique to the server. This latter encryption prevents the content key from being discovered by searching the server files. The resulting outputs are then stored in the content database . The process then finishes in step .

As mentioned above an important feature of the inventive system is the ability to offer text content in a format in which it can be indexed by third party search utilities and yet not be available as plaintext. The text scrambler uses a process called content scrambling to produce an indexable version of a composite content file. This process is illustrated in A and B. The process starts in step and proceeds to step where the text scrambler receives a composite content file that may contain text and graphics. The text scrambler uses a stripper to remove any formatting information and graphics producing a stream of plain text. Thus the text scrambler can handle mixed text and graphic formats such as HTML Adobe PDF and Microsoft Office documents.

Next in step the text scrambler uses a parser to parse the plain text stream into words. The parsing can be performed in a known manner by using delimiters such as spaces tabs etc. to divide the text stream into words. The parser then removes the most common words from the content stream. Such words include common articles such as the a and an conjunctions such as and and or and other common words. In step a fragmenter breaks the parsed content stream up into random two to five word phrases.

The operation of the fragmenter is shown in . This operation begins in step and proceeds to step where a determination is made whether there is more text to be processed. If not the process ends in step . Assuming there is more text to be processed then in step a pseudo random integer equal to or greater than two and less than or equal to five is generated in a conventional fashion. In step a number of words equal to the generated pseudo random number are selected from the stream and the selected words are assembled into a phrase in step . The assembled phrase is streamed out in step . The process then returns to step where a new phrase is generated starting by generating a new pseudo random number in step . Steps to are then performed to generate a new phrase. Operation continues in this fashion until the entire text stream has been processed.

Returning to in step the phrases generated by the fragmenter are assembled by stream assembler in random order into an unpunctuated text stream. The manner in which this text stream is assembled is shown in .

As illustrated in the incoming phrases are assembled into blocks each of which comprises a fixed predetermined number of phrases. In particular the assembly process starts in step and proceeds to step where a fixed number of 2 5 word phrases generated by the fragmenter are assembled into a first block.

Proceeding to step the process then shifts the first block into the second block. In step the fixed number of phrases is again assembled into the first block. At this point there exist two blocks both holding the same fixed number of phrases although the phrases in each block could be of different word lengths. The phrases in the first block are then paired with the phrases in the second block. For example a phase in the first block can be paired with a phrase in the corresponding location in the second block. Next a check is made in step to determine whether all phrase pairs have been processed. If not the process proceeds to step where the next unprocessed phrase pair is selected. In step a pseudo random number is generated for the phrase pair.

In step the generated pseudo random number is compared to a predetermined threshold. If the generated pseudo random number is greater than the threshold then in step the phrase in the first block is swapped with the phrase in the second block. The process then returns to step where a decision is made whether all pairs have been processed. Alternatively if the generated pseudo random number is less than the threshold then the process returns directly to step .

If as determined in step all phrase pairs have been processed then in step the second block is streamed out. In step a decision is made whether additional phrases remain to be processed. If not the process finishes in step . Alternatively if additional phrases remain to be processed then the process returns to step in which the first block is shifted into the second block and in step the first block is filled with the predetermined number of phrases. Operation continues in this fashion until all text phrases have been processed.

The resulting stream contains nearly all of the words in the original content and most of the phrases but cannot be read. This unpunctuated text stream is enclosed in a simple HTML file and stored in unencrypted form on the content server where it will be exposed to third party indexing utilities. These utilities are allowed to crawl the content distribution to build an index of the content. Searching on particular words or phrases will still return most of the same hits as the unscrambled content. However simply navigating straight to the target file will display to the user a scrambled content file that cannot be read.

When scrambled content is indexed by web crawling search engines such as Google the inventive distribution system returns the scrambled content. However when a user uses a browser to link from the search engine to the indexed page the publisher may prefer to present to the user an e commerce page containing an unscrambled article extract and an offer to provide the entire unscrambled article for a purchase price. There are a number of effective techniques to direct the user to the publisher when the user links to the page. For example browsers and search engines requesting a resource typically supply to the web server a user agent parameter that specifies the browser that is requesting the resource. A web server can examine the user agent parameter and supply the scrambled content to requests containing user agent values that correspond to search engines. Alternatively the web server can return the publisher s e commerce page to requests containing user agent values corresponding to browsers.

It is also possible to accomplish the same result by ending the scrambled HTML page with a call to a JavaScript routine that loads the publisher s e commerce page. In this case a user at a browser will see the e commerce page immediately after the scrambled page loads. On the other hand a search engine will ignore the JavaScript and process only the scrambled page. For cosmetic reasons the scrambled page in this approach can also be defined to hide the scrambled text from the end user.

As previously mentioned the inventive content distribution system can also operate in a distributed mode in which content is provided to users at a customer site from a content server that is also located at the customer site. Such a configuration is shown in . In this configuration a content server is located at a corporate site attached to a corporate intranet or other corporate network. An additional content server may also be located at the publisher site to provide controllable and trackable content forwarding as will hereinafter be described. The customer site content server can also provide content searching capabilities using a conventional search engine such as the Apache Lucene open source search engine. The content is indexed at load time using the scrambled text files generated as described below.

The content server at the customer site manages clients and users at the customer site performs secure key exchanges with authenticated clients and logs all usage events for later upload to a metrics reporting server. Contrary to the publisher hosted mode content is distributed from the publisher s site to the user content server as indicated schematically by arrow in blocks of content documents called content distribution archives. Archives might be distributed to customer sites in return for log file information gathered at the customer site as indicated schematically by arrow . The return of log information from the customer site allows the publisher to track content usage at the customer site and to track content forwarding as described below.

As well as containing encrypted documents the distribution archive is itself encrypted. Consequently the customer site content server must unpack the archive and store the encrypted content and keys in the encrypted content database as schematically indicated by arrow . In order to decrypt the archive during the content loading process the customer site content server uses a scheduled key to decrypt the archive. The scheduled key for an archive is contained in a previous archive file that was received by the customer. The first time that content is loaded into the customer site server the scheduled key must be obtained from the publisher as described below.

In addition to containing the encrypted content files the archive contains various keys and an OID to decryption key mapping. The OID Key mapping is also encrypted with the scheduled key. During the unloading process the encrypted content files are extracted but not decrypted. The encrypted files are stored in database and still bear the same names that they did before encryption but there is no explicit cross reference between the encrypted files and their decryption keys. In order to find the key that decrypts a given file name the server receives an OID for the file from a client who is requesting content then uses the received OID to look up the corresponding key in the OID Key mapping. The unloading process is described in more detail below.

The customer site server acts as a conventional server in a client server application performing password based authentication and storing user data in the metrics user database as indicated schematically by arrow . Data is transferred from the client to the server using the regular HTTP protocol in cases where the data is secure encryption is applied to the HTTP payload rather than using a secure protocol such as SSL. Each client of which clients are shown in can contact the server as indicated schematically by arrows and respectively and retrieve content using a process similar to that illustrated in and described in connection with the publisher based system of .

In order to package content documents into a content archive the publisher uses the publishing tool described above in connection with that follows the process set forth in B and A B. The process set forth in illustrates an exemplary process for encrypting the content files. The process set forth in shows an exemplary process for packaging the encrypted content files into a distribution archive.

Generally the publisher s normal content preparation workflow results in a collection of content files content files and directories or compressed content file archives in a location known to the preparation program and specified in a configuration file. Publishers can elect to prepare separate distributions for every customer with if desired different content subsets for each. In this case a separate configuration file is maintained for each customer. The content preparation process starts in step and proceeds to step where the publishing tool examines each file in the content directories or in the compressed content file archive in a location specified in the customer configuration file. In step a determination is made whether any files remain to be processed. If all files have been processed then the process ends in step .

Alternatively if files remain to be processed for each content item in the content collection the publishing tool extracts the file as set forth in step . Then the file is examined and in step a determination is made whether the file contains text. For content items containing text in addition to performing the normal processing the publishing tool contains a text scrambler that performs special processing to create an indexable version of the content as set forth in step . This processing is described in detail above in connection with A and B. After generating the scrambled file the process proceeds via off page connectors and to step where the scrambled file is added to the distribution archive package as described below.

Next in step the content file is compressed in the file compressor using for example the aforementioned Flate compression algorithm. Then in step a key generator in the publishing tool generates a unique 128 bit content encryption key using for example the aforementioned Blowfish algorithm. The process proceeds via off page connectors and to step where the publishing tool encrypts the compressed content item with the unique content key generated in step using the encryption engine .

The publishing tool then calculates a content identifier for the content item as set forth in step with the OID calculator . This process is described above in connection with . The resulting value is mathematically likely to be unique to the particular encrypted file and cannot be derived from the data in the file alone. The OID is used as the content identifier and is stored with an encrypted content key for the content item.

Then in step the content key is encrypted with the key encryptor using the aforementioned Blowfish algorithm. Then in step the computed OID and the encrypted content key are appended to a cache corresponding to the archive file. Specifically the publishing tool caches a list of keys and OIDs as it encrypts every content file. This cache is called an OID Key mapping.

After each content item is encrypted in step the resulting encrypted data is stored in a compressed file the distribution archive under the same name and in the same relative position under the archive root as the position of the original file in the original content file. This is accomplished in step . The process then returns via off page connectors and back to step to determine if additional files need to be processed. Operation continues in this manner until all files have been processed. The result is an archive file containing encrypted content files and an OID Key mapping for each file. These two files are then packaged into the final distribution archive by the process shown in .

There are two slightly different processing flows for content packaging depending on whether a particular subscription or distribution to a particular customer or group of customers is the first distribution to that customer or is a subsequent distribution to that customer. In particular during the packaging process the OID Key mapping is encrypted with the aforementioned scheduled key. A new scheduled key is included with each distribution archive. This new key will be used to decrypt the next distribution archive received by the customer. Therefore the first time a particular customer receives a distribution archive the customer will not have the scheduled key and it will be necessary to send the required key to the customer. After the first distribution archive has been received the customer will have the scheduled key that was delivered in the previous distribution archive.

The packaging process begins in step and proceeds to step where a decision is made whether the customer to which the archive is being sent already has the scheduled key. If this is not the first distribution then the process proceeds to step which is discussed below. If the intended customer does not have the scheduled key the process proceeds to step where the publishing tool generates a new scheduled key using the key generator . For example this key may be a 128 bit Blowfish key. In step this new scheduled key is encrypted using the key encryptor and for example the Blowfish algorithm and a secret key internal to the server. This encrypted key is not added to the archive but it is stored in a separate file. The encryption prevents the scheduled key from being discovered by searching the server files. The unencrypted key is also sent to the customer via a channel that is separate from the channel used to send the distribution archive. For example the scheduled key may be e mailed to the customer as set forth in step .

When the distribution archive is to be packaged in step the scheduled key is retrieved from storage and decrypted using the secret server key. The process then proceeds via off page connectors and to step where the publishing tool encrypts the OID Key mapping using the encryption engine with the scheduled key before adding the mapping to the distribution archive in step .

The publishing tool in step generates yet another key using the key generator for example a 128 bit Blowfish key called the new scheduled key. This new scheduled key is stored in the distribution archive in step and will be used by the customer to decrypt the next distribution archive that is received. Next in step the scheduled key is used to encrypt the entire distribution archive using the encryption engine . The new scheduled key is also encrypted with a secret server key in step and stored in a configuration file for the customer in step . The process then ends in step . At this point the distribution archive is complete and ready for publication to its customer or customers.

The use of the scheduled keys and next scheduled keys builds a chain of distribution files. However if a customer misses a distribution or loses a distribution archive file it will be impossible for the customer to load any subsequent distribution archive files. If this occurs the customer must contact the publisher and request a new distribution. The publisher then creates a first time distribution archive with its explicit scheduled key and transfers the archive and the scheduled key to the customer via separate channels for example the archive can be sent via FTP and the key can be sent via e mail .

Returning to when the customer site server receives a distribution archive it must unpack the archive before users can access the content therein. The unpacking process is performed by an update manager and is illustrated in A and B. illustrates the internal architecture of the update manager in more detail. The process begins in step and proceeds to step where the update manager uses a key decryptor to decrypt the scheduled key received with the distribution archive file that was previously received. Then in step the decrypted new scheduled key is used in the decryption engine to decrypt the distribution archive file. The resulting decrypted file contains the encrypted content files the scrambled content files an encrypted OID Key list and an encrypted new scheduled key.

In step the manager uses a file decompressor to extract the encrypted content files . These files are then stored in the content database located at the customer site. Next as set forth in step the file decompressor is used to extract the scrambled content files . These files are then stored in the customer site server in a location at the customer site that will be accessible to third party search engines.

In step the file decompressor is used to extract the encrypted OID Key list from the distribution archive file. An OID Key list decryptor decrypts the OID Key list using the new scheduled key obtained in step . The process then proceeds via off page connectors and to step where the OID Key map already existing in the customer site server is checkpointed using checkpointer . The checkpointer establishes a base state of the map before changes are made so that the map can be returned to its original state if errors occur during the addition of the new OID Key values received in the archive file.

The existing OID Key map is then cloned by cloner in step to produce a map clone . The new OID Key entries produced by the OID Key list decryptor are then added to the map clone in step . In step the checkpointer is used to checkpoint the map clone . If the checkpointing succeeds then in step the map clone with the added entries is adopted by overwriting the existing OID Key map in step and as schematically illustrated by arrow . Finally in step the file decompressor is used to extract the new scheduled key from the distribution archive file for use in decrypting the next distribution archive file. The process then ends in step .

Returning to the client site server logs all client activity that occurs at the customer site in a plaintext log file as indicated schematically by arrow . Such activity could include accessing and opening a document selecting a document searching or printing a document. The log file is kept in plaintext so that privacy conscious customers are able to verify that the log file does not report confidential data. In order to reduce the possibility of file corruption or deliberate modification the logging apparatus in the server signs each log file entry according to the process illustrated in . The process starts in step and proceeds to step where the logging apparatus generates a sequential sequence number by means of the sequence number generator . This number might be a sequential integer. Then in step the generated sequence number is appended to the current log record which includes the log record data and the timestamp by the appender .

Next in step the logging apparatus uses a signature generator to generate a message authentication code MAC based on the sequence number appended to the current log record the current log record data the timestamp of the current log record and the sequence number appended to the previous log record . This signature is then appended to the current log record in step . A MAC is an alternative to digital signatures for ensuring data integrity when the protected data is stored locally or when sender and recipient share a secret string or key. A MAC computation is similar to hashing except that a key is used in the computation so that only someone who knows the key can create or verify a MAC.

In a preferred embodiment the MAC can be generated by an algorithm called a salted hash algorithm. A salted hash algorithm is a secure hash that has been pre populated with a secret string. Illustratively the secure hash algorithm can be the SHA 1 secure hash algorithm discussed above. Other algorithms such as the SHA 256 or SHA 512 algorithms could also be used. In addition other alternative embodiments could use DSS or other signature standards such as HMAC instead of the salted hash algorithm. The secret string is known only to the publisher so that only the publisher can verify the MAC.

In accordance with another aspect of the invention in the distributed mode a client can forward a content document to one or more recipient e mail addresses including addressees who are not part of the client s corporate network. This forwarding process allows the recipients to access the specified content without losing the content protection. It also allows the inventive distribution system to track usage activity of recipient users in the same fashion as previously registered users. This process is illustrated in and . An overall view of the process is illustrated in . The steps in preparing the e mail are shown in and the steps in receiving and processing the content document identification information from the e mail recipient are shown in .

The process begins in step and proceeds to step where a user logged into a customer site server for example server at a customer site uses the metrics viewer operating in his browser to send an e mail to another user in order to forward a selected content document. The metrics viewer communicates to the customer site server to prepare an email with a link to the original publisher site . In step the customer site server uses a sender ID generator to generate a sender ID. Generally the sender ID would be a text string identifying the sender and the sender s corporate network. Next in step the server uses a recipient ID generator to generate a recipient ID. Generally the recipient ID would be a text string identifying the recipient and the recipient s corporate network.

Then in step the server uses a document ID generator to generate an ID identifying the content document that will be forwarded. This content ID might be the document name or URL. In step a concatentator concatenates the three IDs and in step the ID information is encrypted with an encryptor . In one embodiment this latter encryption might be RSA public key encryption using the public key of the publisher site that originated the content document. The encrypted ID string is then inserted into a URL that appears as a link when the e mail arrives in the recipient s e mail program or browser as set forth in step . The process then finishes in step . Subsequently the e mail is sent to the recipient.

When the recipient clicks on the link to the publisher in the e mail a supported browser is opened and the browser navigates to a forwarding metrics server in the publisher s site. This server might be server in publisher site as shown in . During this process the URL in the e mail is sent to the server and processed as set forth in . The server then downloads the metrics viewer described previously into the recipient s browser and launches the viewer as hosted by the server. The recipient then logs into the server and registers in the fashion described above.

Processing of the URL received at the forwarding server starts in step and proceeds to step where the URL is received from the e mail recipient. In step the forwarding server at the publisher site uses an extractor to extract the ID information from the URL. Next in step a decryptor in the forwarding server decrypts the ID information using the private key of the public private key pair in the publisher site. Then in step a document ID extractor extracts the document ID from the decrypted ID information. The forwarding server uses the document ID to locate the encrypted document information in the encrypted content database . The encrypted content information and accompanying OID are then sent to the e mail recipient s metrics viewer as set forth in step . The process then finishes in step . Operation then proceeds as set forth in .

The forwarding server can also log the sender s and recipient s ID information in a local log file as indicated schematically by arrow . In this manner the forwarding of content can be tracked. The information in log file and the information in log file can then be provided to a metrics reporting server not shown in that catalogs and formats the information to prepare reports.

A block schematic diagram of another embodiment of the inventive content distribution system is shown in . In this embodiment the metrics server is hosted by a third party called an application service provider . One or more publishers periodically upload new content to the application service provider using conventional means such as CDs or network transfers as indicated schematically by arrows and respectively. Content received from the publishers at the application service provider is processed by a publishing tool located at the application service provider location in order to generate encrypted content. The encrypted content is stored in databases at the application service provider location as indicated schematically by arrow .

In this embodiment a document identifier is computed by the metrics server at the application service provider site from the encrypted content and stored with a decryption key. Users and interested in receiving the content log into the metrics server at the application service provider site as indicated schematically by arrows and respectively. As indicated schematically by arrow the metrics server retrieves user information and profiles from the metrics user database located at the application service provider site and uses this information to log in the users as described above. During the login procedure secure content viewer software not shown in is downloaded into the user s local browser. In order to access the content the content viewer requests a selected document from the application service provider server by referring to a document name or URL. As indicated schematically by arrow the server retrieves the document from the content database and forwards it to the viewer in encrypted form. The viewer then computes a document identifier from the encrypted document content and uses the identifier to request a key from the server in order to decrypt the document. The key is forwarded from the server to the viewer which then decrypts the document and displays it in the viewer.

The metrics server at the application service provider site can also generate a usage log in order to track login to the system registration creation of a user profile and the reading and printing of selected content.

Still another embodiment is illustrated in . In this embodiment a user can elect to store encrypted content in a database located on his or her computer . For example the content may be delivered from a publisher site by conventional means such as CDs or DVDs. In order to view the content the user must log in to a metrics key server located at the publisher s site or another central location using a conventional browser as indicated schematically by arrow . During the login procedure the secure content viewer software is downloaded over the network into the user s browser as indicated schematically by arrow . In response to information from the user identifying a document the content viewer reads the encrypted content from the local database and computes a document identifier from the encrypted content in a manner previously discussed. The viewer then sends the document identifier to the key server in order to retrieve decryption keys from the key database . The decryption keys are then used to decrypt the encrypted content in the secure viewer software .

Still another embodiment is illustrated in in which encrypted content data is stored in a local database on the user s computer . The secure content viewer software is also stored on the user s computer . Decryption keys along with document identifiers may also be stored in a key database in encrypted form on the user s computer. For example the decryption keys may be encrypted with a key that is embedded in the viewer software . Alternatively the decryption keys may be retrieved from a networked key server not shown in as described in the previous embodiment. In response to information from the user identifying a document the content viewer reads the encrypted content from the local database and computes a document identifier from the encrypted content in a manner previously discussed. The viewer then retrieves an encrypted decryption key from the local key database . The decryption keys are then used to decrypt the encrypted content in the secure viewer software .

A software implementation of the above described embodiment may comprise a series of computer instructions either fixed on a tangible medium such as a computer readable media for example a diskette a CD ROM a ROM or a fixed disk or transmittable to a computer system via a modem or other interface device over a transmission path. The transmission path either may be tangible lines including but not limited to optical or analog communications lines or may be implemented with wireless techniques including but not limited to microwave infrared or other transmission techniques. The transmission path may also be the Internet. The series of computer instructions embodies all or part of the functionality previously described herein with respect to the invention. Those skilled in the art will appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic optical or other memory devices or transmitted using any communications technology present or future including but not limited to optical infrared microwave or other transmission technologies. It is contemplated that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation e.g. shrink wrapped software pre loaded with a computer system e.g. on system ROM or fixed disk or distributed from a server or electronic bulletin board over a network e.g. the Internet or World Wide Web.

Although an exemplary embodiment of the invention has been disclosed it will be apparent to those skilled in the art that various changes and modifications can be made which will achieve some of the advantages of the invention without departing from the spirit and scope of the invention. For example it will be obvious to those reasonably skilled in the art that in other implementations process operations different from those shown may be performed. Other aspects such as the specific process flow and the order of the illustrated steps as well as other modifications to the inventive concept are intended to be covered by the appended claims.

