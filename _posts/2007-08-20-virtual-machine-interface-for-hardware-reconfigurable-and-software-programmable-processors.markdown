---

title: Virtual machine interface for hardware reconfigurable and software programmable processors
abstract: A virtual machine interface for a separate reconfigurable wireless network communication apparatus comprising a plurality of software objects, wherein each software object is associated with a hardware kernel assigned to the reconfigurable wireless network communication apparatus, each software object configured such that a change in the software object results in a change in the hardware kernel associated with the software object. The virtual machine interface has information as to types and numbers of software objects and values associated with the software objects necessary to implement a selected wireless communication protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08020176&OS=08020176&RS=08020176
owner: Infineon Technologies AG
number: 08020176
owner_city: Neubiberg
owner_country: DE
publication_date: 20070820
---
This application claims priority to the U.S. Patent Application VIRTUAL MACHINE INTERFACE FOR HARDWARE RECONFIGURABLE AND SOFTWARE PROGRAMMABLE PROCESSORS Ser. No. 09 828 381 that was filed Apr. 5 2001 now U.S. Pat. No. 7 703 107 which claims priority to U.S. Provisional Patent Application VIRTUAL MACHINE INTERFACE AND APPLICATION PROGRAMMING INTERFACE FOR HARDWARE RECONFIGURABLE AND SOFTWARE PROGRAMMABLE PROCESSOR Ser. No. 60 195 096 that was filed Apr. 6 2000.

A CONFIGURABLE CODE GENERATOR SYSTEM FOR SPREAD SPECTRUM APPLICATIONS U.S. patent application Ser. No. 09 751 782 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 567 017.

APPARATUS AND METHOD FOR CALCULATING AND IMPLEMENTING A FIBONACCI MASK FOR A CODE GENERATOR U.S. patent application Ser. No. 09 751 776 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 947 468.

A FAST INITIAL ACQUISITION AND SEARCH DEVICE FOR A SPREAD SPECTRUM COMMUNICATION SYSTEM U.S. patent application Ser. No. 09 751 777 filed Dec. 29 2000 now U.S. patent application Ser. No. 7 031 376.

A CONFIGURABLE MULTIMODE DESPREADER FOR SPREAD SPECTRUM APPLICATIONS U.S. patent application Ser. No. 09 751 785 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 934 319.

A CONFIGURABLE ALL DIGITAL COHERENT DEMODULATOR SYSTEM FOR SPREAD SPECTRUM APPLICATIONS U.S. patent application Ser. No. 09 751 783 filed Dec. 29 2000 now U.S. patent application Ser. No. 7 010 061.

A WIRELESS SPREAD SPECTRUM COMMUNICATION PLATFORM USING DYNAMICALLY RECONFIGURABLE LOGIC U.S. patent application Ser. No. 09 772 584 filed Jan. 29 2001 now abandoned.

A microfiche appendix entitled Appendix A Cellular Basestation Modem Engine CBME Virtual Machine Interface Specification Document Version 2.01 is included in the present application. The microfiche appendix includes 2 microfiche cards.

This invention relates generally to application programming interfaces. More particularly this invention relates to a virtual machine interface and or application program interface.

A cellular communication system is a wireless communication network in which geographical areas are divided into a number of smaller areas or cells in order to provide scalability of coverage for multiple users with minimal intercell interference. A mobile cellular communication system is a cellular communication network in which the terminal devices users mobiles may be in motion from one location to another relative to a basestation.

In a typical digital wireless communication system multiple basestations are provided to perform switching and connection services between users or terminal devices. illustrates typical cellular wireless communication system architecture. Basestation provides wireless communication system to mobile stations and . Similarly basestation provides wireless communication system to mobile stations and . Basestation is connected to the basestation via network .

Referring to a basestation BS provides basic connection service to terminal devices by terminating the radio path and connecting the terminal devices to network . A mobile station MS terminates the radio path on the user side and enables the user to gain access to services from the network. Network typically comprises a mobile switching center MSC . The MSC is an automatic system that interfaces the user traffic from the wireless network with the wireline network or other wireless networks. The basestations exchange messages with the MSC.

A variety of communication protocols can be used to operate and control a wireless communication system such as the system shown in . Representative protocols include but are not limited to the TDMA time division multiple access and CDMA code division multiple access protocol families. Among other adoptions TDMA protocol is used by GSM Global System for Mobile Communication which comprises GPRS General Packet Radio Service ECSD Enhanced Circuit Switched Data and EDGE Enhanced Data rates for Global Evolution systems. The CDMA protocol is adopted by cdma2000 wideband CDMA WCDMA IS 95 CDMA IS 95B CDMA CDMA TIA IS2000 TIA IS 2000A WIMS W CDMA ARIB WCDMA 1Xtrem 3GPP FDD 3GPP TDD TD SCDMA as well as several other multi carrier CDMA systems. Additional 2G and or 3G CDMA protocols may be found in Holma and Toskala eds. John Wiley Sons. Inc. New York 2000 and 95 2000 Garg ed. Prentice Hall PTR Upper Saddle River N.J. 2000 .

Although TDMA and CDMA are the most widely used communication protocols they each have unique system requirements. Prior art communication systems dedicated to supporting TDMA or CDMA protocols exist. However the prior art has failed to provide a communication system that is capable of supporting several different protocols including both TDMA and CDMA in a satisfactory manner. This failure is in part due to the fact that the hardware necessary to support TDMA is typically not compatible with the hardware necessary to support CDMA. For example typical TDMA systems require maximum likelihood sequence estimation MLSE equalization whereas CDMA systems do not. In contrast typical CDMA systems require RAKE receivers whereas TDMA systems do not.

Even within the same protocol family there are variations in the hardware necessary to support the protocol. For example although both the global positioning system GPS and IS 95 are CDMA protocols GPS and IS 95 have distinctly different hardware requirements. For example an IS 95 system requires a convolutional decoder whereas GPS does not.

Because of the unique hardware requirements necessary to support each of the existing communication protocols substantial expense is required to modify a basestation so that it supports a new communication protocol. Indeed such a modification requires a complete or partial overhaul of a basestation. In prior art systems the modification of a basestation to support a new communication protocol requires the installation of new equipment as well as significant modification of existing software throughout the network. In addition new terminal devices are required in order to be compatible with the modified basestation. Thus modification of a communication protocol used by a basestation is an expensive and time consuming task that results in service interruptions. For these reasons conventional wireless communication systems suffer from a lack of flexibility and adaptability and cannot provide timely and efficient adaptation to meet the ever changing needs of the wireless communication field.

Further in conventional wireless communication systems preparing an application program to run a particular communication protocol requires a programmer to know or understand the complex details and specifics of the underlying communication hardware. Thus every time there is a change in communication protocol the programmer has to first understand what changes are to be made at the hardware level and rewrite application programs accordingly. Such dependence on specific architecture of the underlying hardware makes it even more difficult and expensive to change and maintain wireless communication systems.

In view of the foregoing it is highly desirable to provide an adaptable and flexible wireless communication system. Also it is desirable to provide a hardware architecture independent communication platform on which a programmer can write application programs capable of modifying the communication protocol used by a reconfigurable wireless network communication apparatus without understanding underlying hardware requirements necessary to affect such a modification.

The present invention provides an object oriented reconfigurable multi protocol communication system comprising a virtual machine interface VMI and an application programming interface API for use in a wireless communication network. The wireless communication network includes a reconfigurable wireless network communication apparatus having a plurality of hardware kernels and an interconnect structure. The wireless network communication apparatus is configurable in accordance with a designated communication protocol. The VMI is disposed between an application translation layer and a software virtual machine and comprises a library of software procedures or objects.

In one embodiment the software objects of the VMI are hierarchically related. Software objects of the VMI have static attributes and or have dynamic attributes. The static attributes are adjustable when the reconfigurable wireless network apparatus or components thereof is off line. The dynamic attributes are adjustable regardless of whether the reconfigurable wireless network apparatus is off line or on line.

The software objects of the VMI are associated with hardware kernels in the underlying reconfigurable wireless network communication apparatus so that manipulation of VMI software objects regulate operations in the respective associated hardware kernels of the reconfigurable wireless network communication apparatus. Therefore by appropriate manipulation or programming of the VMI software objects a programmer can control essential functionality within the underlying reconfigurable wireless network communication apparatus without delving into the details and specifics of the reconfigurable wireless network communication apparatus.

A unique advantage of the present invention is that basestation conversion from one communication protocol to another is possible without expensive hardware changes. Rather such changes are made by appropriate programming or manipulation of the VMI or API.

One embodiment of the invention is directed to CDMA code division multiple access applications. In this embodiment the VMI provides the following software objects a CDMA basestation engine a searcher a code generation unit CGU a finger an uplink and a downlink. In turn the reconfigurable wireless network communication apparatus provides a searcher kernel a CGU kernel a finger kernel an uplink kernel and a downlink kernel. Each of these kernels are associated with corresponding software objects within the VMI. For example a VMI finger object is associated with a finger kernel a VMI searcher object is associated with a searcher kernel and so forth.

The present invention further provides an application program interface API to manage utilization scheduling and resource allocation. The API of the present invention comprises a library of higher level software objects that further abstract the details and specifics of the VMI so that the application programmer can change the communication protocol used by a reconfigurable wireless network communication apparatus using very simple application programs. Indeed in some embodiments the API allows a programmer to change the communication protocol used by an apparatus by selecting an option in a simple menu of options. In one embodiment of the present invention the API provides a standard uniform platform through which the programmer changes the wireless communication protocol used by a reconfigurable wireless network communication apparatus without having to understand the VMI the details of the underlying hardware of the apparatus or the requirements and specifications of the selected wireless communication protocol.

In another aspect of the present invention the API has i a parsing routine for parsing an application program that designates a communication protocol and ii a machine instruction generation routine for producing machine readable data capable of reconfiguring a wireless network communication apparatus in accordance with a communication protocol designated by the application program. In some embodiments in accordance with this aspect of the present invention the machine readable data comprise VMI objects.

Reference will now be made in detail to the preferred embodiments of the invention examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with preferred embodiments it is understood that the description is not intended to limit the invention to these embodiments. Rather the invention is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the invention as defined by the appended claims. Additionally in the following detailed description of the present invention numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be apparent to one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to obscure important aspects of the present invention. Furthermore while the present invention may be implemented in a reconfigurable wireless network communication apparatus such as a digital wireless communication system the methods of the present invention are also well suited for other applications and devices.

Representative reconfigurable wireless network communication apparatuses include but are not limited to fixed wireless unlicensed FCC wireless local area network LAN cordless telephony cellular telephony personal basestation and telemetry. Other applications include navigation encryption and other digital data processing applications.

The present invention provides an application program interface API and a virtual machine interface VMI to abstract details of the underlying reconfigurable wireless network communication apparatus so that an application programmer can prepare and modify an application program without requiring knowledge about the configuration control or management of the underlying communication hardware. Combined with an API the VMI gives a programmer the ability to adapt to the various communication protocols by invoking specific API and VMI software objects or programs without the need to directly program the hardware of the underlying reconfigurable wireless network communication apparatus. For example a mobile station programmer can program a mobile station so that it communicates using a new or altered communication protocol by use of the VMI and API rather than directly accessing the registers of the mobile station hardware.

In a preferred embodiment both the VMI and API are implemented as software procedures or objects. It will be apparent to one skilled in the art that in alternate embodiments of the invention the VMI and API can also be implemented as hardware. For instance VMI and API implementations can be implemented as logic on a programmable chip.

In alternate embodiments of the present invention the VMI and API may be used in conjunction with a basestation and its base transceiver station BTS engine. Serving as an interface between the BTS engine and network the VMI and API enable the programmer to manipulate the reconfigurable BTS hardware by manipulating the VMI and API instead of directly controlling and modifying the BTS hardware. In such embodiments the BTS hardware comprises multiple hardware kernels which are configurable into several modes of operation and parameterizable according to the demands of particular communication protocols such as TDMA and CDMA code division multiple access . For example the BTS engine may comprise one or more searchers fingers code generation units CGUs searcher dwell state machines DSMs combiners uplinks matched filters matched filter antennas downlinks and transmit multicode channel kernels. Each of these kernels is interconnected by a reconfigurable interconnect structure having flexible bandwidth characteristics. Such a reconfigurable BTS engine is described in U.S. patent application Ser. No. 09 772 584 now abandoned.

While the methods of the present invention advantageously regulate the communication protocol s used by a base station or mobile it will be apparent to one skilled in the art that the VMI and or API of the present invention may also be used in conjunction with hardware units other than a mobile station or basestation as long as the underlying hardware unit has a reconfigurable architecture. Indeed the VMI and or API of the present invention may be used with any reconfigurable wireless network communication apparatus.

Turning to the details of the invention illustrates one embodiment of the VMI and the API constructed in accordance with the present invention. API is disposed between an application translation layer and an application program . VMI is disposed between the application translation layer and a virtual machine layer which in turn is connected to a reconfigurable wireless network communication apparatus . The reconfigurable wireless network communication apparatus may comprise basestation hardware mobile station hardware or any other suitable hardware.

Specifically API abstracts details and specifics of the lower level functionality and implementation of the communication system from the programmer. Such details and specifics include application translation layer VMI virtual machine and reconfigurable wireless network communication apparatus . Thus the programmer can prepare and modify a program without having to worry about the configuration control or management of the underlying reconfigurable wireless network communication apparatus.

In one embodiment of the invention API provides an interface for writing high level programs that are translated by application translation layer into programs that may include VMI commands. The translated programs in turn affect the communication protocol used by reconfigurable wireless network communication apparatus . As a result API abstracts information as to the types and numbers of VMI objects necessary to effect a given communication protocol as well as parameter values associated with VMI objects used to implement the given wireless communication protocol. Thus in one embodiment the programmer only has to provide application program with information as to the type of communication protocol of interest. An example of an application program in accordance with the embodiment is provided by illustrative code line .

In illustrative code line the programmer sets the communication protocol for a reconfigurable wireless network communication apparatus to WCDMA.

In other embodiments in accordance with the present invention Application programming interface and application translation are not used. Rather a programmer writes a program in a language such as ANSI C that includes program calls to specific VMI objects. In this way the programmer is able to modify or change the communication protocol or the usage of a communication protocol by reconfigurable wireless network communication apparatus .

From the perspective of the programmer by abstracting the details and specifics as to the types and numbers of the VMI objects and relevant parameters API provides a communication protocol independent interface through which the programmer can control and operate the underlying reconfigurable wireless network communication apparatus . This convenience makes it possible to standardize the wireless communication architecture because an API can be developed as a uniform standard platform on which the user can operate and control various wireless communication protocols.

VMI in turn abstracts from the user details and specifics of the lower level implementation virtual machine and reconfigurable wireless network communication apparatus . In one embodiment of the present invention VMI provides a library of software calls for application program . VMI contains information as to the types and numbers of objects as well as the parameter values associated with the objects necessary to implement a selected wireless communication protocol.

VMI gives the programmer complete access to and control of reconfigurable wireless network communication apparatus without the need to directly control or access the apparatus. For example when used to implement a CDMA basestation VMI provides a hierarchical command structure including commands that control mobile and sector allocation of resources of the underlying reconfigurable wireless network communication apparatus . VMI also provides commands that control datapath interconnection as well as hardware kernel parameters.

In operation a particular communication protocol is selected and the application program makes the appropriate calls to software routines of API . Application program is then translated by application translation layer . The software routines of application translation layer have the information as to the types and numbers of the objects required to perform the particular communication protocol.

In alternate embodiments the methods and apparatuses of the present invention are practiced without API . In such embodiments application program makes calls to necessary software objects of VMI . For example when the user selects a communication protocol and prepares an application program to execute the communication protocol application program makes calls directly to software objects in VMI . The programmer can instantiate and use any object available from VMI to perform necessary functions according to the selected communication protocol. After instantiating a particular object the programmer assigns relevant parameter values to the instantiated objects in accordance with the particular communication protocols selected.

In one embodiment after application program is translated into a program readable by virtual machine virtual machine issues machine readable instructions and commands to the reconfigurable wireless network communication apparatus for execution. Unlike application program and API virtual machine requires general knowledge and information associated with underlying reconfigurable wireless network communication apparatus . Using such knowledge virtual machine translates the application program into lower level machine code that is required to control the underlying reconfigurable wireless network communication apparatus . Typically virtual machine comprises a memory manager thread scheduler interpreter as well as a compiler in order to control and coordinate the performance and execution of the underlying reconfigurable wireless network communication apparatus .

Typically the reconfigurable wireless network communication apparatus includes a resource allocator that receives and processes instructions and commands from the virtual machine to allocate and reconfigure the necessary hardware resources of the reconfigurable wireless network communication apparatus . Thus the scheduling and resource allocation of the underlying hardware are transparent to the user. The resource allocation and hardware reconfiguration of the reconfigurable wireless network communication apparatus is described in U.S. patent application Ser. No. 09 772 584 now abandoned.

One advantage of including VMI between virtual machine and any user program is to use the VMI to abstract details and specifics of the underlying hardware such as register values. The specifics and details of the underlying reconfigurable wireless network communication apparatus are handled by virtual machine . Thus regardless of the type of communication protocol used the programmer can instantiate and use the Cellular Basestation Modem Engine CBME searcher CGU uplink and matched filter objects available within VMI . In one embodiment of the present invention the programmer does not have to handle any level lower than VMI in order to program a particular reconfigurable wireless network communication apparatus. Specifically the user can control the underlying reconfigurable wireless network communication apparatus by manipulating the objects in VMI instead of directly controlling and accessing the underlying hardware of the reconfigurable wireless network communication apparatus .

In one embodiment of the present invention there is at least one hardware kernel assigned to reconfigurable wireless network communication apparatus for each instantiated software object of VMI . For example if CBME searcher CGU uplink and matched filter objects are instantiated from VMI there is at least one CBME engine searcher CGU uplink and matched filter kernel assigned in the reconfigurable wireless network communication apparatus . This relationship between the VMI and the underlying hardware makes it easier for a user to prepare and analyze an application program and shortens the time for the user to convert from one communication protocol to another. For example in order to convert from W CDMA protocol to IS 2000 the user instantiates additional objects as necessary deletes unnecessary objects and assigns parameter values as appropriate for the new protocol thereby effectively modifying the underlying reconfigurable wireless network communication apparatus .

Although certain software objects have been described with respect to for the purpose of illustration one of skill in the art will appreciate that other suitable software objects may be created and utilized as the system requires. For example an encoder decoder object may be added.

Turning attention to each object within VMI may comprise one or more associated functions or objects. Each of the objects within VMI is associated with one or more hardware kernels so that changes in the object affect the state of the associate hardware kernel. In some embodiments each object within VMI is assigned to a unique or different hardware kernel. However one of skill in the art will appreciate that many other configurations are possible including configurations where one or more VMI objects are assigned to the same hardware kernel or the inverse configuration in which one or more hardware kernels are assigned to the same VMI object. Each of the software objects illustrated in will now be described. In this description both the purpose of the software object and the function of the underlying hardware to which the software object is associated are provided.

A cellular basestation modem engine CBME kernel is a reconfigurable wireless network communication apparatus which itself is composed of a plurality of kernels to facilitate wireless communication. In one embodiment CBME is a Morphics cellular base transceiver system BTS . CBME object is a software object within VMI that regulates various aspects of the underlying CBME hardware. CBME object includes associated functions CBME new and CBME set user data . CBME new is invoked to allocate a new CBME object. CBME set user data is used to write user data to a CBME object.

The CBME kernel includes one or more code generation unit CGU kernels. The on chip CGU kernels are object specific in that each on chip CGU kernel only works with one type of VMI object. In one embodiment of the present invention a particular CGU kernel only works with an Uplink Searcher a preamble detection engine antenna object or a downlink object . Illustrative CGU kernels in accordance with various embodiments of the present invention are disclosed in A configurable code generator system for spread spectrum applications U.S. patent application Ser. No. 09 751 782 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 567 017 Apparatus and method for calculating and implementing a Fibonacci mask for a code generator U.S. patent application Ser. No. 09 751 776 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 947 468 Universal code generation U.S. Ser. No. 60 222 829 filed Aug. 3 2000 and A Wireless Spread Spectrum Communication Platform Using Dynamically Reconfigurable Logic U.S. patent application Ser. No. 09 772 584 filed Jan. 29 2001 now abandoned.

In some embodiments of the present invention the CGU unit kernel provides all required codes among a set of standards including but not limited to IS 95 cdma2000 IS2000 ARIB and 3GPP. Various codes are generated for both uplink and downlink requirements. In some embodiments of the present invention CGU kernels contain timing information for a modem and for each individual finger of a RAKE receiver. In additional embodiments of the present invention the CGU contains a mask generation unit which is used to transform a given code offset into a set of code dependent parameters. Such parameters are used in the reassignment of a code s phase. The output of a CGU kernel is a pseudo random noise code sequence for the downlink and each RAKE finger.

Code generation unit CGU object includes functions such as CGU new and CGU set user data . CGU new is invoked to allocate a new CGU object and object CGU set user data is used to write user data to a CGU object .

In a spread spectrum system basestations as well as some handsets transmit a standardized pilot signal having a known sequence of binary digits to aid in communication of data signals. These pilot signals can have a wide variety of codes as determined by a specific communication protocol. For example in one protocol a pilot signal has a length of 2 32 768 bits or chips . This known sequence is referred to as a short pseudonoise PN sequence in IS 95 CDMA.

A searcher kernel is designed to search for new multi paths by correlating a received code sequence such as a short PN sequence having an unknown phase with a second code sequence that is a locally generated PN sequence with a known phase. Once a searcher kernel finds a multi path a finger kernel is assigned to the multipath. Searcher kernels in accordance with the present invention are disclosed in A Fast Initial Acquisition and Search Device for a Spread Spectrum Communication System U.S. patent application Ser. No. 09 751 777 filed Dec. 29 2000 now U.S. patent application Ser. No. 7 031 376 A Configurable Multimode Despreader for Spread Spectrum Applications U.S. patent application Ser. No. 09 751 785 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 934 319 A Configurable All Digital Coherent Demodulator System For Spread Spectrum Applications U.S. patent application Ser. No. 09 751 783 filed Dec. 29 2000 now U.S. patent application Ser. No. 7 010 061.

Referring to a Searcher object provides a software object for controlling a searcher kernel. In a typical embodiment a Searcher object is associated with a searcher kernel and thereby processes correlation results performs peak detection threshold comparison and controls a multi standard multi dwell search engine.

Searcher object class includes Searcher new . When Searcher new is called by VMI a number of processing steps are automatically performed for the user programmer in order to look for conflicts and to properly initialize resources for the underlying searcher kernel. Use of an object such as Searcher new is advantageous because it allows the programmer to request a Searcher kernel without painstaking hardware level programming such as board and chip programming and conflict management. The processing steps that are performed for the programmer by Searcher new in one embodiment in accordance with the present invention are illustrated in .

Turning attention to the processing steps performed by one embodiment of Searcher new begin with processing step . In processing step a particular searcher object is identified. All subsequent processing steps either check to determine whether attributes of the searcher identified in step are in the appropriate state and or set particular attributes of the searcher identified in processing step .

In processing step a check is made to see if error checking is enabled. If error checking is enabled Yes then a number of checks are performed. It will be appreciated that the order of many of the checks that are performed is not important. Additionally one of skill in the art will appreciate that several additional checks that are not disclosed in could be performed and all such checks are within the scope of the preset invention.

In a first check a determination is made as to whether the searcher that has been obtained by a call to Searcher new is of the right type. In some embodiments of the present invention there are two types of searchers those that are dedicated to finding new mobiles and those that are dedicated to existing mobiles. If the searcher that has been obtained by a call to Searcher new is not dedicated to finding new mobiles No the process ends with return error . If the searcher is dedicated to finding new mobiles Yes then check is performed. In processing step a check is performed to see whether a function call has been made to a routine that sets cellular basestation modem engine CBME mobile resources. If the routine has not been called No CBME is not in the appropriate state and the process ends with return error . If the routine has been called Yes check is performed. In check a determination is made as to whether the time period for the searcher identified in processing step has been set. Check returns an error if the time period for the searcher has not been set No and the process ends with error condition . If a time period has been set for the searcher the process continues with check .

In processing step a check is made to determine whether the function CGU new has been called. CGU new allocates a new CGU kernel. Illustrative CGU kernels in accordance with one embodiment of the present invention are disclosed in A Configurable Code Generator System for spread spectrum applications U.S. patent application Ser. No. 09 751 782 filed Dec. 29 2000 now U.S. patent application Ser. No. 6 567 017. If CGU new has not called No the process ends with return error . If a CGU new has been called Yes a determination is made as to whether the CGU kernel fetched by CGU new is the right type. In one embodiment of the present invention there are four types of CGU kernels a searcher CGU an uplink CGU a Preamble Detection Engine PDE Antenna CGU and a downlink CGU. Check will return an error No if the CGU type for Searcher is any type other than a Searcher CGU.

If the CGU kernel called by CGU new is a valid type Yes check is performed to determine whether the CGU fetched by CGU new and the Searcher are assigned to the same CBME . If the CGU and the searcher are not assigned to the same CBME No the process ends with error . If the CGU and the searcher are assigned to the same CBME Yes the process continues with check . In check a determination is made as to whether the maximum number of Searchers have already been committed to CBME . If the maximum number of Searchers have already been committed to CBME Yes then Searcher new will fail and the process ends with error code . If the maximum number of Searchers have not already been committed to CBME No the process continues with processing steps through which are designed to initialize Searcher and the associated Searcher kernel to the proper state. Although refers to each error code as error one of skill in the art will appreciate that each error code could in fact be a unique error code. For example a different return value for Searcher new could be assigned for each different type of error encountered during processing steps through .

Attention now turns to processing steps through in . Processing step is reached if all error checks are performed satisfactorily No or if error checking is disabled No . In processing step the searcher type of the searcher is designated as NEW. In one embodiment of the present invention VMI flags Searcher as new using illustrative code line .

In illustrative code line p searcher is a pointer to the Searcher identified in processing step . Searcher type is the attribute of p searcher that tracks the type of p searcher. By assigning the attribute searcher type to M New Mobile Searcher p searcher is committed to type NEW. In processing step a CGU is attached to Searcher . In processing step an attribute that tracks the number of CGUs that have been attached to the searcher is incremented by 1 . In one embodiment in accordance with the present invention this attribute is associated with the pointer to the CGU that has been associated with p searcher and the increment is performed using illustrative code line .

In illustrative code line p cgu is a pointer to the CGU that has been attached to p searcher p searcher is the Searcher identified in processing step . In processing step a mobile RAM index is assigned to Searcher . In processing step a searcher finger context memory SFCM element is assigned to Searcher . The SFCM element controls the scheduling and attributes of Searcher such as the search window size of the code offset dwell state number a phase count for searches greater than chip resolution and a control flag that is used to start and stop Searcher . One of skill in the art will appreciate that any number of SFCM element data structures and schemes are possible for controlling Searcher and the associated Searcher kernel and all such data structures and schemes are within the scope of the present invention.

In processing step the mobile random access memory RAM linear feedback shift register LFSR associated with Searcher is zeroed out. In processing step the mobile RAM DSP memory is zeroed. In processing step the attribute that tracks the number of searchers assigned to CBME is incremented by 1 . In processing step Searcher is added to the searcher list of CBME using the SFCM element assigned to Searcher as an index. In one embodiment processing step is performed using illustrative code line .

In illustrative code line the attribute new searcher called is set to M TRUE. This attribute is used to indicate that Searcher new has been properly called for p searcher. In illustrative code line p searcher is associated with CBME . Finally in illustrative code line the attribute state is set to M SEARCHER STOPPED to indicate that the searcher kernel associated with p searcher is not currently in search mode. In processing step Searcher New ends with an error free return to the calling program.

Review of the flowchart in reveals a number of advantages of VMI . The VMI programmer can use VMI to request a Searcher and associated Searcher kernels without need for instance to resolve complex hardware conflicts and board level programming.

Returning attention to Searcher further includes functions such as Set searcher static attributes Set searcher dynamic attributes Searcher start Searcher stop and Assign DSM to searcher . Set searcher static attributes is used to set searcher static attributes such as system parameters antenna data port and despread mode. The function Set searcher dynamic attributes is used to set searcher dynamic attributes such as channel type and number. Searcher start is used to start a Searcher . Searcher stop is used to stop a Searcher . Assign DSM to searcher is used to assign a searcher DSM to a Searcher .

Each Searcher must be assigned to a dwell state machine DSM . A DSM is used to configure the Searcher algorithm. Searcher DSM includes Searcher DSM new and Set DSM state attributes . Searcher DSM new is invoked to allocate a new DSM and Set DSM state attributes is used to set the integration length and threshold for a specific state of a searcher DSM. Functionally a searcher VMI object is used to control the corresponding searcher kernel hardware for mobile channels and a searcher DSM is used to configure the searcher algorithms. Further details of the searcher hardware kernel are found in U.S. patent application Ser. No. 09 751 777 filed Dec. 29 2000 now U.S. patent application Ser. No. 7 031 376.

A searcher PDP power delay profile is a data type used to store results returned from the searcher. In one embodiment of the invention each searcher has one DSM and one PDP.

A Preamble Detection Engine PDE kernel detects the presence of access bursts from new mobiles. A PDE is associated with one or more antennas. An access burst signal is used by a mobile to attempt access to a basestation its time of transmission is random. In the methods of the present invention a PDE object is associated with a PDE kernel. The PDE object class includes PDE new for allocating a new PDE as well as PDE add antenna for adding an antenna to a PDE .

A finger kernel is a component of a RAKE receiver kernel. Each finger kernel of the RAKE receiver kernel is used to track an individual multipath signal over time. Multipath signals are caused when the signal emitted from a transmitter bounces off an object and arrives at the receiver through an alternate delayed path. In a typical environment multipaths are very dynamic in nature since a mobile is moving relative to reflecting objects. A RAKE receiver kernel is used to collect echos multipath signals align them in time then accumulate the energy to produce the best possible signal strength. Each finger locks onto and tracks a particular multipath signal and demodulates the data associated with the signal for later combining with other multipaths. In addition to the fundamental demodulation of the incoming multipath each finger kernel is required to continually update an estimate of channel quality in order to test for a minimum level of quality across the channel. Further details of finger kernels that are associated with the finger object class of the present invention may be found in U.S. patent application Ser. No. 09 772 584 now abandoned.

A finger object is used to control the corresponding finger kernel. In one embodiment of the present invention each finger kernel used is associated with a different Finger object using an association process such as the one described below in conjunction with . The fingers can be combined using combiner object or can remain independent. Finger object class includes Finger new . Finger new is invoked to allocate a new finger.

When Finger new is called by a VMI application a number of processing steps are performed by VMI . is a flowchart that illustrates one embodiment of Finger new in accordance with the present invention. The process begins at start . In processing step a query is made as to whether error checking is to be performed. If error checking is to be performed Yes a number of checks are performed before associating a new finger with a CBME.

In check VMI determines whether an instance of CBME new has been called. The purpose of CBME new is to create a CDMA basestation modem engine object . Thus by barring allocation of a finger unless CBME new has been called No check insures that fingers are not allocated to a nonexistent CDMA basestation modem engine object .

In check VMI determines whether CBME set mobile resources has been called. CBME set mobile resoures configures the CDMA basestation modem engine object for a the number of mobiles that can be supported and b the tracking finger block size for each mobile. CBME set mobile resources is called by VMI after calling CBME get resource attributes which returns the maximum number of fingers max fingers that may be associated with the CBME as well as the maximum number of tracking fingers supported by the CBME at its input clock rate. Using max fingers a determination can be made based on system requirements on how many mobiles to support and for each mobile what will be the initial number of tracking fingers available to it. By barring allocation of a finger unless CBME set mobile resources been called No check insures that fingers are not allocated to a CDMA basestation modem engine object that has not been properly initialized.

Once CBME set mobile resources and CBME get resource attributes have been called the CBME is properly initialized. Therefore the maximum number of fingers that may be associated with the CBME is determined. Check insures that this maximum is not exceeded. If a request is made to associate a finger to a CBME that already has the maximum number of fingers associated with it Yes an error code is returned.

If error checking is disabled No or all error checks are satisfied Yes Yes No then normal processing steps through are performed by Finger new . In processing step the CBME finger count is incremented. The CBME finger count tracks the number of fingers that have been associated with the CBME. In processing step the finger that is to be associated with the CBME parent CBME is set a known default state. In one embodiment processing step resets the state of the finger in accordance with lines through of the following exemplary code.

In processing step the attribute new finger called is set to M TRUE to indicate that a new finger has been called. Finally in processing step the finger object is associated with a parent CBME. In one embodiment processing step is performed by setting an attribute termed p cbme to the address of the parent p cbme. Such a command could be performed using line of the exemplary code.

Returning attention to the Finger object class further includes Finger set static attributes Finger set dynamic attributes Finger start and Finger stop . Set finger static attributes as well as the VMI object Set finger dynamic attributes are used to set static and dynamic attributes for a finger respectively. Finger start and Finger stop are used to start and stop a finger object respectively.

A combiner kernel combines the outputs of one or more finger kernels and sums them in accordance with a combining rule. In some embodiments a combiner kernel is associated with one to sixteen finger kernels. In one embodiment of the present invention each finger kernel is assumed to track a single multi path and a set of finger kernels are set up for combining using VMI .

After time alignment of each stream the outputs of the set of finger kernels are combined by arithmetically summing the outputs. In non coherent IS 95 mode for example a combination operation such as a Hadamard Transform results in arithmetic summation of the outputs before entry into a soft decision device. In coherent mode each finger kernel provides an estimate of instantaneous channel energy and each is selected for combining based on a sufficiently large SIR. In one embodiment the largest and smallest instantaneous estimate is recorded for each finger kernel over a window of size K. The finger kernel is selected for combining if the following condition is true max 10 10

In CDMA logical channels include the control and traffic channels. The traffic channels are used to carry user information along with signaling traffic between the basestation and the mobile station. The control channels comprise downlink channels and uplink channels. Accordingly VMI provides an uplink object and a downlink object .

Uplink object is used to group Combiners along with their respective attached Fingers as well as Searchers that are common to a mobile uplink. Typically Combiners and Searchers are added to an Uplink. In some embodiments of VMI there is no limit to the number of Uplink objects that can be declared. Uplink object class includes Uplink new which is used to allocate a new uplink. Downlink object class includes Downlink new which is used to allocate a new downlink.

Transmit multicode channel object includes MTX new . MTX new is used to allocate a Transmitter channel.

In some embodiments objects Set searcher static attributes and Set finger static attributes are called to set static attributes when the underlying hardware is not running or is off line. For example static attributes of a searcher object may be set by calling Set searcher static attributes upon a power up or reboot of the system or if the pertinent objects are not running. On the other hand objects Set finger dynamic attributes and Set searcher dynamic attributes are called regardless of whether the underlying hardware is running or not allowing the dynamic attributes to be set on the fly. 

In addition to the VMI objects illustrated in VMI includes additional software objects such as a matched filter. The matched filter VMI object is used to control the corresponding matched filter kernel. The matched filter is a faster version of a searcher kernel but the matched filter kernel is not as configurable as the searcher kernel. In one embodiment of the invention the matched filter is used when the underlying reconfigurable wireless network communication apparatus is configured for 3GPP mode. In another embodiment of the present invention a matched filter may be used in either a multi standard CDMA traffic channel receiver or a RACH type receiver 3GPP and both coherent and noncoherent accumulation modes are allowed.

Although certain methods and objects have been described with respect to it will be apparent to one skilled in the art that other objects and methods may be defined and used as appropriate in conjunction with the invention. Further some objects may be combined or divided. For example the searcher and finger objects may be combined to form a single object. In another embodiment the searcher and finger may be further divided into multiple objects.

The VMI of the present invention is designed to synchronize respective hardware kernels with corresponding software objects so that a manipulation of VMI objects within the VMI causes an analogous change in the hardware. To this end each software object has one or more corresponding hardware components in the underlying hardware CBME. For example CBME corresponds to and controls a CBME CDMA BTS engine . Uplink corresponds to and controls the uplink hardware components and searcher corresponds to and controls a hardware searcher in the CBME. Thus in one embodiment there is at least one hardware module for each VMI software object. In alternate embodiments of the invention there may be a many to one correspondence between software objects and the counterpart hardware kernel. This is possible when one hardware kernel is configured to support multiple counterpart software objects in a time sliced fashion. For example one hardware searcher kernel may support many software searcher objects if the latter can be serviced by the hardware kernel in a time multiplexed fashion. In still other embodiments there may be a many to one correspondence between hardware kernels and a VMI software object.

As illustrates there is a hierarchical relationship among VMI objects in one embodiment of the present invention. On the hardware side hardware kernels and are coupled to each other via a reconfigurable interconnect . As illustrates there is at least one hardware kernel for each instantiated object in the VMI in some embodiments of the present invention. For example the CGU combiner and matched filter are each supported by hardware counterparts CGU combiner and matched filter . However it is also possible for one hardware kernel to support a plurality of VMI objects. For example in searcher objects and are supported by a single searcher kernel . Such single kernel to multiple object correspondence is possible if searcher objects and can be serviced by the single searcher kernel in a time multiplexed fashion.

As discussed above the VMI objects illustrated in are designed to synchronize the corresponding hardware kernels so that a manipulation of the VMI objects causes an analogous change in the hardware components. For example if the user changes a parameter in a searcher object for instance the sub chip resolution value of the searcher object that change will be reflected in the corresponding hardware kernel within the appropriate time interval.

Although a searcher finger combiner code generation unit and matched filter are shown in it will be appreciated by one skilled in the art that as many hardware kernels and corresponding software objects may be created and utilized according to the needs and requirements of a particular communication system as may be permitted by the available resources. Various VMI objects can be instantiated parameterized and reconfigured to accommodate and adapt to the unique requirements of various communication protocols. For example when a CDMA protocol is used a MPSK multiple phase shift keying demodulator object a convolutional decoder object and a rake receiver object are instantiated and parameterized to configure the corresponding hardware modules. On the other hand when a TDMA protocol is used an MPSK demodulator object a convolutional decoder object and an MLSE equalization object are instantiated and parameterized according to TDMA system specifications.

After the resource allocation and configuration are performed in steps and the actual allocation and configuration of the hardware resources are performed by the resource allocator of the reconfigurable wireless network communication apparatus based on the machine readable instructions provided by the virtual machine .

In step the programmer determines what objects to instantiate and use for the protocol determined in step . In step the programmer instantiates an object and continues until all necessary objects have been instantiated. In step the programmer parameterizes each object instantiated according to the system specification of the protocol. When the parameterization is complete in step the programmer continues to the next task.

Alternatively the programmer may combine instantiation and parameterization in step . In other words the programmer may instantiate and parameterize each object in step instead of performing a separate parameterization step in . Thus the present invention provides the ability to instantiate different VMI objects in steps through and to give different parameters to the instantiated objects in steps through in order to accommodate different protocols. Once instantiated VMI objects control and coordinate functions of the corresponding hardware kernels in order to perform a given task. Reconfiguration and parameterization of corresponding hardware kernels are described in U.S. patent application Ser. No. 09 772 584 now abandoned.

In one embodiment of the invention a searcher can be optimized in different ways. For example in order to minimize dropped phone calls in a wireless terminal application a programmer may decide to allocate the majority of search resources to detecting new multi paths for existing calls at the expense of detecting new calls. The present invention allows such dynamic reallocation of search resources and parameterization at and performed by a searcher VMI object. For example at a peak number of callers the searchers can be prioritized for minimum dropped calls whereas at a lower number of callers the searchers can be prioritized to minimize the detection time of new callers.

In the embodiment shown in blocks through are implemented by a VMI searcher object . Hardware software interface provides an interface between the VMI searcher object and BTS modem .

Now that the basic operation of various VMI objects has been described a detailed example of an Application program will be described to further illustrate the advantages of the present invention. In this example a CBME is created a searcher is created and associated with the CBME and then the searcher is started.

Step 1 lines In Step 1 the procedure DFS Pre Simulation Hook is defined. This procedure will create a CBME and start a searcher . Further in lines through various variables that are used by the procedure are defined. Finally a file for writing out a power delay profile PDP is opened.

Step 2 lines VMI object CBME new is used create a CBME . The mobile resources for the newly created CBME are defined using the VMI object CBME set mobile resources.

Step 4 lines VMI objects are used to obtain a code generation unit for an uplink. First the list of possible CGUs available is obtained. For each available CGU a check is performed to insure that the CGU has the object type M UPLINK CGU. When a CGU having this attribute is found it is initialized and assigned to the newly created CBME using the VMI object CGU new .

Step 6 lines A Combiner is assigned to the newly created CBME using the VMI objects Combiner new and Uplink Add Combiner.

Step 7 lines VMI objects Finger New Add Finger To Combiner and Finger Set Offset are buried in a loop so that num finger fingers can be created added to the newly created CBME and set to an appropriate position. In one embodiment the value of num finger is set to 1 so that only one finger is added during step 7. Once the combiner has been appropriately populated with one or more fingers the Combiner is started with the VMI command Combiner start .

Step 8 lines A searcher is defined. First the VMI object CBME Set searcher energy scaling is run. Internally CBME generates a 32 bit search result value. However in some embodiments of the present invention only 12 bits are reported to the microprocessor. CBME set searcher energy scaling sets the range of energy bits to report to the microprocessor. Next the VMI object CBME Set Search Time Period is executed. This function sets the search period for all searchers under a CBME . The search period is nominally milliseconds and is defined by the following formula timer constant input chipping rate search period 256 As an example presume that the desired search period is 50 milliseconds and that the input chipping rate is 3.84 Mcps. Then timer constant 3.846 503 256 750 The minimum duration for the timer setting should be such that it does not restart a new search before the completion of the previous search.

Once the time period has been set the VMI command Searcher New is used to assign a Searcher to the newly created CBME and the static attributes of the searcher are defined using VMI object Searcher set existing mobile static attributes. In one embodiment because the Searcher is set up as an existing mobile searcher the following conditions must be satisfied before a Searcher is started i Searcher set existing mobile static attributes must be called ii the Searcher must be added to an uplink and iii a Combiner with at least one Finger must have been added to uplink and the Combiner must have been started.

Step 9 lines Once a Searcher has been defined a Searcher DSM is created and assigned to the Searcher. Using VMI objects a Searcher DSM is created and assigned to a Searcher in three stages i setting up the Searcher DSM lines ii setting up the state of Searcher DSM lines and iii assigning the Searcher DSM to the Searcher lines . More specifically in order to set up a Searcher DSM the VMI object CBME set DSM subchip phase is used to configure the DSM subchip phase. Then the VMI object Searcher DSM new is used to obtain a searcher DSM on lines and of the illustrative code. Each state of the Searcher DSM is then set up using the VMI object Searcher DSM set state attributes on lines through of the illustrative code. Once each state of the Searcher DSM has been set the Searcher DSM is assigned to the searcher that was defined in step 8. Further in line of the illustrative code the Searcher is added to the Uplink that was associated in step 5 with the newly created CBME .

Step 10 lines In the final step of this illustrative example Searcher is started with VMI object Searcher start . The process ends on line of the illustrative code with a return to the calling function.

A sophisticated virtual machine interface VMI has been described. Further the function of several VMI objects or procedures in accordance with one embodiment of the present invention have been introduced. In addition the detailed processing steps performed by two such VMI objects Finger new and Searcher new have been described. From these examples one of skill in the art will appreciate that the VMI of the present invention facilitates the rapid adaptation of a reconfigurable wireless network communication apparatus from supporting one communication protocol such as CDMA to supporting another communication protocol such as a different form of CDMA or indeed even TDMA.

The VMI of the present invention is an example of an approach to providing high level programming support for a reconfigurable wireless network communication apparatus. Such high level programming frees a programmer from the intricacies of setting the appropriate state for each of the hardware kernels as is otherwise necessary to support a given communication protocol. Referring to a programmer uses VMI by writing Application programs which include VMI function calls.

As shown in the methods of the present invention provide an even higher level of programming control over an apparatus . For instance Application programs are in general higher level programs for configuring an apparatus than Application programs . Application translation mechanism translates Application program into a language recognized by virtual machine . In some embodiments Application Translation translates Application program into instructions that are recognized directly by reconfigurable wireless network communication apparatus and a virtual machine is not used. In other embodiments Application Translation translates Application program into instructions that include VMI instructions. Exemplary codes lines through above detail an exemplary Application program whereas Exemplary code line below illustrates an exemplary Application program .

In the relationship between an Application program and an underlying object oriented reconfigurable wireless network communication apparatus in accordance with one embodiment of the present invention is detailed. One characteristic of Application program is that it uses a limited instruction set to reconfigure the communication protocol used by the associated reconfigurable wireless network communication apparatus . For example in one embodiment a representative Application program that requests a mobile station to communicate using wideband CDMA WCDMA protocol has the form of illustrative code line 

A comparison of illustrative code lines through which represents a program of format to the program represented by illustrative code line which represents a program of format provides one example of how usage of an application translation layer can be used to simplify the task of a programmer who is reconfiguring a reconfigurable wireless network communication apparatus to support a different communication protocol.

While distinguishes between an Application program and the present invention contemplates any number of variants of Application program and . For example in some embodiments Application translation uses VMI objects as well as a scan chain binary to support an Application program . In other embodiments Application translation uses VMI objects and does not use a scan chain binary.

Reference will now be made to in order to illustrate the advantage of one embodiment of the present invention in which an Application program is used to set the communication protocol for a basestation. In particular details the processing steps that are performed in response to the execution of an Application program such as the one provided by illustrative code line above.

In processing step application translation allocates a CBME object using a software routine such as CBME new . In processing step the RAM scan chain is sent to the basestation using a VMI software routine such as CBME scan chain write. Processing step is used to initialize a number of on board CBME RAMs within the basestation. Each of these RAMs can be of a different bit width and word depth. In the embodiment shown in the RAM CBME scan chain is separated from writing from other scan chains because writing from the RAM scan chain corrupts the data from other scan chains. In processing step all other scan chains are written to the CBME.

The scan chains that are written to the basestation are summarized in . In CBME Config Tools are used to write a scan chain binary based on appropriate parameterization of DSP parameters DLL early late settings DSP code types of code generation slot formats and antenna modes . Scan chain binary therefore consists of microcode for CBME processor elements and parameters for CBME RAM which set items such as decimator taps interpolator taps DLL taps DLL microcode rate selection PDE vs. FHT bypass decimator mode selection enable disable TFCI input PDEs antenna selection CGU polynomials and CGU microcode as well as many other hardware settings.

In processing step the resources available within reconfigurable wireless network apparatus are determined using a querying routine such as VMI object CBME Get Resource Attributes. Processing step will return the maximum number of fingers available to CBME at the input clock rate supplied by the basestation. In processing step a determination is made on how many mobiles to support. This decision is based on the number of fingers available to CBME that was calculated in processing step . Further in processing step for each mobile station that will be supported by CBME a decision is made on the initial number of tracking fingers available to the mobile. In one embodiment processing step is executed using VMI object CBME set mobile resources.

In processing step the search periodicity of each searcher that will support CBME is set using a routine such as VMI object CBME set search periodicity. Further in processing step the energy range limits that each searcher will be allowed to report is defined using a routine such as VMI object CBME set searcher energy scaling. In processing step the subchip phase of the searcher DSM associated with each searcher that will support the CBME is set using a routine such as VMI object CBME set DSM subchip phase.

In processing step Preamble Detection Engine PDE parameters are defined. Each PDE is assigned a specific mode of operation and an access slot within the basestation. In some basestations in accordance with the present invention a PDE can be associated with one to eight antennas depending on its mode. In some embodiments the VMI function CBME Set PDE Num Slots configures the total number of access slots for the specific communication standard requested by application program as well as the number of PDE time slots.

In processing step the number of CGUs that are available in the basestation is obtained using a command such as VMI object CBME get CGU list. Then in processing step the list of downlink slot formats that are available on the CBME is retrieved. In processing step the list of multiplexed transmission fields available within the basestation is retrieved using a routine such as VMI object CBME get downlink field list. Finally in processing step the uplink slot formats that are available are retrieved using a routine such as VMI object CBME get uplink slot format list.

The VMI of the present invention may be implemented in conjunction with any suitable operating system real time operating system RTOS or non RTOS. For example in one embodiment of the invention the VMI is integrated with a real time operating system RTOS . In RTOS environment any preemptive multi tasking operating system that supports counting semaphores may be used to support the VMI. A typical example of non RTOS integrated with the VMI of the present invention is a round robin based operating system.

While reference was made to a Cellular Basestation Modem Engine CBME object when describing VMI it will be appreciated that VMI may be used not only for changing or modifying the attributes of one or more communication protocols used by a basestations but in fact the communication protocol used by any reconfigurable wireless network communication apparatus including a mobile. Accordingly in such alternative embodiments parameters within the CBME object may be modified added or deleted in order to adopt to the specific hardware attributes of a particular reconfigurable wireless network communication apparatus.

While VMI objects were typically referred to as objects such as those found in an object oriented language it will be appreciated that this representation serves merely as an example. In various embodiments the VMI software objects objects of the present invention are defined as objects object classes sets of objects sets of object classes procedures sets of procedures functions sets of functions or related software routines. What is common to all VMI software objects of the present invention is that they run to a completed state when called. This feature is advantageous because it allows the software VMI objects of the present invention to be operated in an operation system free environment. As used herein a completed state comprises either a successful operation such as the acquisition of a finger kernel by Finger new or an error code upon failure to achieve a task.

A VMI and API have been described in conjunction with a reconfigurable wireless network communication apparatus. Unlike conventional wireless communication apparatuses the present invention provides a flexible and efficient platform that can easily adapt to various wireless communication protocols. Also the VMI and API of the present invention abstract the details and specifics of the underlying communication hardware so that a programmer can prepare an application program without having to change or know the specific configuration requirements of the underlying hardware.

As described above the VMI of the present invention provides a programmer interface to the underlying CBME hardware kernel providing reconfigurability and flexibility necessary to take advantage of the reconfigurability and flexibility of the underlying CBME kernel. The VMI of the present invention synchronizes the hardware kernels which comprise the CBME with corresponding software objects so that a manipulation of the VMI objects causes an analogous change in the hardware. In one embodiment each software object has one or more corresponding hardware components in the underlying hardware CBME.

The foregoing description for purposes of explanation used specific nomenclature to provide a thorough understanding of the invention. However it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention. In other instances well known components and devices are shown in block diagram form in order to avoid unnecessary distraction from the underlying invention. Thus the foregoing descriptions of specific embodiments of the present invention are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed obviously many modifications and variations are possible in view of the above teachings. Obviously the embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.

