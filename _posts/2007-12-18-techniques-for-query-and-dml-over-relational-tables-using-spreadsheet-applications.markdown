---

title: Techniques for query and DML over relational tables using spreadsheet applications
abstract: In one embodiment, a database server receives a request from a spreadsheet application to open a file with spreadsheet data. The spreadsheet data is stored in one or more relational tables in one or more relational databases that are managed by the database server. In response to the request, the database server generates the file, where generating the file comprises retrieving the spreadsheet data from an XML view that is defined by an XQuery query. When executed, the XQuery query returns the spreadsheet data in an XML spreadsheet format that is understood by the spreadsheet application. The database server provides the generated file with the spreadsheet data directly to the spreadsheet application, where the spreadsheet data as retrieved from the XML view is formatted according to the XML spreadsheet format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330149&OS=09330149&RS=09330149
owner: ORACLE INTERNATIONAL CORPORATION
number: 09330149
owner_city: Redwood Shores
owner_country: US
publication_date: 20071218
---
The present invention relates to querying and modifying relational tables using spreadsheet applications.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

Presently commercial spreadsheet applications like Microsoft Excel and Open Office Calc cannot directly access and modify data that is stored in databases managed by a database server. One reason for this is that spreadsheet applications typically access spreadsheet data that is stored as files while databases typically store data in non file formats such as tables and other persistent database objects. Another reason is that it is not a trivial task to convert data stored in a database into data that can be rendered as a spreadsheet by a spreadsheet application.

To allow spreadsheet applications to access data stored in databases past approaches invariably use some kind of intermediate non database server components that convert translate re format and or otherwise process data from a database into spreadsheet data that can be rendered as a grid of cells by a spreadsheet application.

For example some past approaches provide for data drivers that execute outside of a database server and that provide the functionalities that allow a spreadsheet application to retrieve data from and store data in a database managed by a database server. These functionalities may include data type conversions translations and re formatting of data that is exchanged between the spreadsheet application and the database server managing the database. For example a data driver would typically open a cursor with the data requested by a spreadsheet application and would then process the cursor row by row and field by field by performing various operations to convert translate and or reformat the data from the cursor into a form or format that is understood by the spreadsheet application. In order to modify data stored in a database managed by a database server a data driver would similarly open a cursor at the database server and would then process any data changes against the data in the cursor. Examples of such data drivers are Java Database Connectivity JDBC drivers and Open Database Connectivity ODBC drivers.

The main disadvantage of these past approaches is that they add an additional intermediate level of data processing that is performed outside of the database server that manages the data accessed and modified by a spreadsheet application. The additional intermediate level of data processing increases user response times and is costly in terms of the computing resources used. In addition since the intermediate level of data processing is performed outside of the database server it cannot take advantage of various optimizations that the database server may otherwise provide for processing data stored in various databases managed by the database server.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Techniques are described herein for querying and modifying relational tables using spreadsheet applications. As used herein spreadsheet application refers to an unmodified commercially available application that is operable to render and process data as a spreadsheet comprising a grid of cells. Examples of spreadsheet applications include but are not limited to Microsoft Excel and Open Office Calc. The techniques described herein may be implemented without limitation for any spreadsheet application that is operable to store and process spreadsheet data in an XML spreadsheet format.

As used herein spreadsheet data refers to any set of data that can be rendered by a spreadsheet application as a spreadsheet comprising a grid of cells. XML spreadsheet format refers to a specification that uses eXtensible Markup Language XML to define a spreadsheet. For example an XML spreadsheet format may define a set of tags for representing rows and cells as well as any row cell properties such as for example formulas associated with rows cells data types associated with rows cells fonts associated with rows cells etc. One example of such XML spreadsheet format is the format specification defined by the XMLSS schema provided by Microsoft Corporation.

According to the techniques described herein a spreadsheet application can directly access and modify spreadsheet data that is stored in a relational database managed by a database server. In this context directly means at least that 1 the database server can provide spreadsheet data in a format that is understood and can be rendered by the spreadsheet application and 2 the spreadsheet application can provide spreadsheet data in a format that is understood and can be processed by the database server. Thus directly means that a spreadsheet application can access and render spreadsheet data that is stored in a relational database without the help of any intermediate non database server components that transform translate convert reformat or otherwise process the spreadsheet data exchanged between the spreadsheet application and the database server. Examples of such intermediate components that are not part of a database server include without limitation ODBC drivers JDBC drivers and various other types of intermediate modules that facilitate access to data managed by a database server.

In one embodiment a database server receives a request from a spreadsheet application to open a file with spreadsheet data. The spreadsheet data is stored in one or more relational tables in one or more relational databases that are managed by the database server. In response to the request the database server generates the file where generating the file comprises retrieving the spreadsheet data from an XML view that is defined by an XML Query Language XQuery query. When executed the XQuery query returns the spreadsheet data in an XML spreadsheet format that is understood by the spreadsheet application. The database server provides the generated file with the spreadsheet data directly to the spreadsheet application where the spreadsheet data as retrieved from the XML view is formatted according to the XML spreadsheet format.

In step a database server receives a Structured Query Language SQL query that specifies spreadsheet data that is stored in one or more relational tables in one or more relational databases that are managed by the database server. The database server may receive the SQL query through various mechanisms including but not limited to a command line user interface a graphical user interface and various program applications that are operable to connect and submit requests to the database server.

In different embodiments the spreadsheet data may be specified to the database server in the form of requests and or information that are different from a SQL query. For example in some embodiments the database server may receive an XQuery query that specifies the spreadsheet data which is stored in one or more relational tables managed by the database server. In other embodiments the database server may receive a list of information that identifies the tables and columns which store the spreadsheet data of interest. An example of such list of information may be EMP DEPT EMP.EMPNO EMP.NAME DEPT.LOCATION where EMP and DEPT are the names of relational tables EMPNO and NAME are columns of the EMP table and LOCATION is a column of the DEPT table. Thus the use of a SQL query to specify spreadsheet data to a database server as described herein is to be regarded in an illustrative rather than a restrictive sense.

As used herein database server refers to a set of integrated software components which when executed may be allocated computational resources such as memory CPU time and storage space for providing database management functions on behalf of clients of the server. Among other functions of database management a database server governs and facilitates access to one or more databases creates and manages database objects for storing data in the databases stores data in the databases and processes requests and queries by clients to access the databases and the database objects therein. In various architectures a database server may be implemented as single server instance or as a cluster of multiple server instances.

In step the database server automatically determines one or more primary key PK foreign key FK relationships that are defined for the one or more relational tables. For example the database server may examine one or more database dictionaries that store metadata information about the one or more relational tables. Based on the metadata information the database server determines any primary keys and foreign keys that are defined for the one or more relational tables and any PK FK relationships that exist therefor.

In step the database server automatically generates an XQuery query based on the SQL query and on the one or more PK FK relationships. The XQuery query specifies an XML spreadsheet format that is understood by a spreadsheet application. The generated XQuery query is such that when executed it returns in the XML spreadsheet format the spreadsheet data that is specified in the received SQL query.

In step the database server automatically generates and stores an XML view that is defined by the XQuery query.

As used herein a view refers to a database object that is defined by a query which when executed returns a set of data. An XML view refers to a view that is defined by a query such as for example an XQuery query which when executed returns data that conforms to an XML format. Typically a view is created by executing a data definition language DDL statement at a database server where the DDL statement specifies a query that defines the view. The query defining the view specifies one or more columns that are mapped to one or more columns of one or more tables or other views the query defining the view may also specify one or more predicates that determine the rows of data from the one or more tables or other views that would be returned when the query is executed. When a data manipulation language DML statement or other database command requests data from a view the query that defines the view is executed to return the requested data. Views may be referenced in database commands and DML statements that conform to a query language e.g. SQL XQuery and may be treated by a database server as references to tables.

In step the database server automatically generates and stores a set of code that is associated with the XML view. The set of code is such that it is executed by the database server in response to any data modification operation that is performed on the XML view. According to the techniques described herein instead of performing a data modification operation on the XML view the set of code performs one or more data modification operations on the one or more relational tables that are referenced in the XML view. An example of such set of code is an Instead Of trigger that is associated with the XML view. It is noted however that the techniques described herein are not limited to Instead Of triggers or to any other type of triggers rather the techniques described herein may be implemented through any type of code function or procedure that can be executed by the database server instead of a data modification operation on an XML view. Thus an Instead Of trigger which is provided throughout the present disclosure as an example of the set of code utilized by the techniques described herein is to be regarded in an illustrative rather than a restrictive sense.

In step a database server receives a request from a spreadsheet application to open a file with spreadsheet data where the spreadsheet data is stored in one or more relational tables. The database server may receive the request from the spreadsheet application through a file protocol interface which is provided by the database server to expose database resources as files that can be accessed through various applications. For example the request may include a command to open a file and a filename for the file that are specified to the spreadsheet application by a user.

In response to receiving the request from the spreadsheet application in step the database server automatically generates the requested file by retrieving the requested spreadsheet data from an XML view that is defined by an XQuery query. When executed the XQuery query returns the spreadsheet data in an XML spreadsheet format that is understood by the spreadsheet application. For example based on a filename included in the request from the spreadsheet application a file protocol interface of the database server may determine that the spreadsheet application is requesting a file with spreadsheet data that can be retrieved from a particular XML view that is registered by the file protocol interface in association with the filename. After determining the particular XML view which can be used to retrieve the requested spreadsheet data the file protocol interface or another component of the database server executes a statement e.g. a SQL SELECT statement against the particular XML view to retrieve the spreadsheet data. The spreadsheet data retrieved from the XML view is formatted in an XML spreadsheet format that is understood by the spreadsheet application because the particular XML view is defined by an XQuery query that returns spreadsheet data in the XML spreadsheet format. The retrieved spreadsheet data in the XML spreadsheet format is then converted in file format by the file protocol interface of the database server.

In step the database server provides directly to the spreadsheet application the generated file with the spreadsheet data in the XML spreadsheet format. For example in response to the request from the spreadsheet application the file protocol interface of the database server may return the generated file to the spreadsheet application.

It is noted that the techniques for accessing spreadsheet data through an XML view described herein are completely transparent from the perspective of the spreadsheet application. For example the spreadsheet application sends a request for and receives a file with spreadsheet data without knowing that the data is actually stored in relational database tables managed by a database server and without needing to do anything outside of performing its normal operations for opening a file. Specifically in contrast to prior approaches the spreadsheet application does not need to use an intermediate data driver to access the spreadsheet data because the database server provides the spreadsheet data to the spreadsheet application in an XML spreadsheet format that is understood and can be directly rendered as a spreadsheet by the spreadsheet application.

In step the database server receives a request from a spreadsheet application to save a file that includes modified spreadsheet data. The modified spreadsheet data includes changes made by the spreadsheet application to spreadsheet data which spreadsheet data was previously retrieved by the database server from an XML view and was provided to the spreadsheet application.

For example the request from the spreadsheet application may be received by a file protocol interface of the database server. The request may include a command to save a file and a filename for the file that includes the modified spreadsheet data. Based on the filename included in the request the file protocol interface of the database server may determine that the spreadsheet application is requesting to save spreadsheet data that can be retrieved from a particular XML view that is registered by the file protocol interface in association with that filename. After determining the particular XML view the file protocol interface of the database server may convert the command to save the file with the modified spreadsheet data into one or more data modification operations against the particular XML view.

In step the database server stores into one or more relational tables the modified spreadsheet data that is received in the file sent from the spreadsheet application. For example after the file protocol interface of the database server has converted the command to save the file into one or more data modification operations against the particular XML view the database server executes the one or more data modification operations against the XML view.

Storing the modified spreadsheet data in the one or more relational tables comprises the database server performing steps A and B. In step A the database server determines that one or more data modification operations have been executed against an XML view. In response to the execution of the one or more data modification operations in step B the set of code associated with the XML view is executed instead of the one or more data modification operations. When executed the set of code associated with the XML view converts the one or more data modification operations into one or more sets of operations against the one or more relational tables that store the spreadsheet data accessible through the XML view. Thereafter the set of code executes the one or more sets of operations against the one or more relational tables to store the modified spreadsheet data.

For example the database server executes one or more data modification operations against a particular XML view after the file protocol interface of the database server has converted a command received from a spreadsheet application to save a file with the modified spreadsheet data. In response to the execution of the one or more data modification commands an Instead Of trigger associated with the particular XML view is fired and executed. When executed the Instead Of trigger determines the operations that need to be executed against the one or more relational tables underlying the particular XML view and executes these operations to store the modified spreadsheet data in the one or more relational tables.

It is noted that the techniques for modifying spreadsheet data through an XML view described herein are completely transparent from the perspective of the spreadsheet application. For example the spreadsheet application saves a file with spreadsheet data without knowing that the data is actually stored in relational database tables managed by a database server and without needing to do anything outside of performing its normal operations for saving a file. Specifically in contrast to prior approaches the spreadsheet application does not need to use an intermediate data driver to facilitate the storing of the spreadsheet data in a database managed by a database server. This is because the database server is capable of receiving the spreadsheet data in an XML spreadsheet format from the spreadsheet application and of executing data modification operations against an XML view to store the spreadsheet data where executing the data modification operations causes the execution of a set of code associated with the XML view that stores the spreadsheet data in the relational tables underlying that XML view.

Spreadsheet application is capable of communicatively connecting to database server which manages one or more relational databases such as relational database . Spreadsheet application is an unmodified commercially available application that can render and process data as a spreadsheet comprising a grid of cells such as for example Microsoft Excel and Open Office Calc. The techniques described herein may be implemented without limitation for any spreadsheet application that can store and process spreadsheet data in an XML spreadsheet format.

Database is a relational database that stores data in various relational data objects including but not limited to relational tables views and materialized views. In addition database may store various other objects including but not limited to indexes triggers functions user defined and or system and stored procedures user defined and or system . Database may also store metadata information associated with database users and the permissions the database users are granted to the various objects maintained in the database.

According to the techniques described herein database server comprises spreadsheet logic and file protocol interface .

Spreadsheet logic is a set of database server components which when executed are operable to receive various query statements and other database commands that define spreadsheet data that is stored in one or more relational tables of database . For example spreadsheet logic may be implemented as an Application Programming Interface API which is operable to receive SQL queries and other statements that conform to a query language such as SQL and XQuery. In various embodiments spreadsheet logic may be implemented as one or more database server components that can receive requests and information from various entities such as for example graphical user interfaces command line interfaces and any program applications that can send requests to and receive data from a database server.

According to the techniques described herein spreadsheet logic when executed is operable to generate and store XML views that can be used to access spreadsheet data in an XML spreadsheet format. For example spreadsheet logic may operable to examine SQL queries that define spreadsheet data that is stored in one or more relational tables. Examining the SQL queries that define spreadsheet data may include consulting one or more database dictionaries to determine any PK FK key relationships that may have been defined for the one or more relational tables referenced in the SQL queries. Based on a SQL query and on the PK FK key relationships of the relational table s referenced in the query spreadsheet logic is operable to generate an XQuery query which when executed returns the spreadsheet data in an XML spreadsheet format that is understood by the spreadsheet application.

According to the techniques described herein spreadsheet logic when executed is operable to generate and store in database XML views that are defined by the XQuery queries generated by the logic. For example in order to generate and store an XML view spreadsheet logic may automatically construct and execute a DDL statement e.g. a SQL CREATE VIEW statement that specifies an XQuery query.

According to the techniques described herein spreadsheet logic when executed is also operable to generate and store in database Instead Of triggers that are respectively associated with XML views . For example as part of generating an XML view spreadsheet logic may automatically construct and execute a DDL statement e.g. a SQL CREATE TRIGGER statement that specifies an Instead Of trigger for that XML view. An Instead Of trigger associated with an XML view is executed by database server in response to any data modification operation that is performed on that XML view. According to the techniques described herein instead of performing a data modification operation on the XML view the Instead Of trigger performs one or more data modification operations on the one or more relational tables that are referenced in that XML view. In this manner the techniques described herein provide a mechanism for modifying spreadsheet data that is stored in relational tables and that can be accessed through XML views defined over the relational tables.

According to the techniques described herein a mapping may be generated in or for access by an Instead Of trigger that is associated with an XML view. The mapping associates one or more cells specified in the XQuery that defines the XML view with one or more columns of the one or more relational tables that store the spreadsheet data defined in the XQuery query and accessible through the XML view. For example in some embodiments the mapping may be a list that maps XML elements cells in the XML spreadsheet format to rows columns in the relational table s where the data for the XML elements cells is stored. According to the techniques described herein an Instead Of trigger associated with a view may use the mapping to determine and generate DML statements that need to be performed against the rows columns in the relational table s when operations to store modified spreadsheet data are performed against an XML view.

File protocol interface is a set of database server components which when executed expose various database resources as files that can be accessed through various applications. An example of a file protocol interface is a database server interface that implements the Web based Distributed Authoring and Versioning WebDAV protocol which is a set of extensions to the Hypertext Transfer Protocol HTTP that allow access to files managed on remote servers. The WebDAV protocol allows applications to create access modify and move over HTTP files that are managed by remote servers. The WebDAV protocol is described in RFC 4819 which was published by the Internet Engineering Task Force IETF in June 2007.

According to the techniques described herein after generating XML views that can provide spreadsheet data in XML spreadsheet format spreadsheet logic registers the XML views with file protocol interface . To register an XML view file protocol interface may store metadata information that associates the XML view with a filename that can be used by a spreadsheet application to reference a file. According to the techniques described herein file protocol interface is operable to register multiple database resources of multiple types among these multiple database resources file protocol interface may register a plurality of XML views that provide access to a respective plurality of spreadsheet data that is defined over relational tables in one or more relational databases such as database .

As an operational example suppose that file protocol interface receives from spreadsheet application a File Open command to open a particular file identified in the command by a filename. Based on the filename and or on the file extension thereof file protocol interface examines the metadata information for the registered XML views and determines which particular XML view of the plurality of registered XML views is associated with that filename. If the filename received in the File Open command is not associated with any registered database resource then file protocol interface would return an error to spreadsheet application . File protocol interface then translates the File Open command into a SQL SELECT statement that references the particular XML view associated with filename executes or causes database server to execute the SQL SELECT statement against the particular XML view receives the results of the execution which would be the spreadsheet data in the XML spreadsheet format that can be accessed through the particular XML view and returns the spreadsheet data in the XML spreadsheet format as a file to the spreadsheet application. In this manner the techniques described herein provide to spreadsheet applications the ability to directly retrieve spreadsheet data that is stored in relational tables in databases managed by a database server.

As another operational example suppose that file protocol interface receives from spreadsheet application a File Save command to save a particular file identified in the command by a filename. Based on the filename and or on the file extension thereof file protocol interface examines the metadata information for the registered XML views and determines which particular XML view of the plurality of registered XML views is associated with that filename. If the filename received in the File Save command is not associated with any registered database resource then file protocol interface would return an error to spreadsheet application . File protocol interface then translates the File Save command into a SQL UPDATE statement that references the particular XML view associated with the filename and executes or causes database server to execute the SQL UPDATE statement against the particular XML view. In response to executing the SQL UPDATE statement against the particular XML view the Instead Of trigger associated with that XML view is fired and executed against the relational table s underlying that XML view. Based on a mapping between cells of the spreadsheet data and columns of the underlying relational table s the Instead Of trigger determines the data modification operations that need to be performed on the XML view translates these data modification operations into SQL UPDATE INSERT and or SQL DELETE statements against the underlying relational table s and executes the SQL UPDATE INSERT and or SQL DELETE statements to store in the underlying relational table s the changes to the spreadsheet data that are made by spreadsheet application . In this manner the techniques described herein provide to spreadsheet applications the ability to directly modify spreadsheet data that is stored in relational tables in databases managed by a database server.

Spreadsheet data is formatted in a XML spreadsheet format which comprises a set of tags that define one or more rows for storing spreadsheet data values and a set of tags that define one or more cells within the one or more rows. In some embodiments the row tags and the cell tags may define the rows and cells respectively as XML elements that are part of an XML document that comprises a root node. An XML element defined by the row and cell tags may include one or more attributes such as for example an attribute that defines a data type for a spreadsheet cell corresponding to the XML element and an attribute that defines a formula associated with the cell corresponding to the XML element.

According to the techniques described herein the XML spreadsheet format implemented in some embodiments may define for a row cell an XML attribute that indicates that the spreadsheet data value stored in that row cell cannot be modified. For example in attribute ss Style locked indicates that the cell associated with attribute is to be rendered according an XSLT style that is defined by a spreadsheet application for write protecting spreadsheet cells. A data value rendered in a locked write protected cell by a spreadsheet application cannot be modified by a user of the spreadsheet application. It is noted that various embodiments may use different types of XML attributes e.g. style attributes or other application or format specific attributes to indicate write protected cells in the spreadsheet data thus the example provided by attribute in is to be regarded in an illustrative rather than a restrictive sense.

By implementing an XML spreadsheet format with a mechanism for write protecting cells the techniques described herein allow for write protecting spreadsheet data values that should not be modified because of referential integrity constraints and rules that are enforced by a database server on the relational tables that store the spreadsheet data.

For example when a database server receives a SQL query or other database command that specifies spreadsheet data that is stored in one or more relational tables the database server automatically examines one or more database dictionaries that store metadata information about the one or more relational tables. Based on the metadata information the database server determines any primary keys and foreign keys that are defined for the one or more relational tables as well as any other referential integrity constraints such as for example NOT NULL column constraints and user defined column rules that may be defined on columns of the one or more relational tables. The database server then determines which spreadsheet data values stored in the one or more relational tables may violate the determined keys rules and constraints when these data values are modified by a spreadsheet application. For example the database server may determine that spreadsheet data values stored in a NOT NULL column of a relational table should not be allowed to be modified because a spreadsheet application may introduce a NULL value. In another example the database server may determine that spreadsheet data values stored in a primary key and or a foreign key columns of the relational tables should not be allowed to be modified because a spreadsheet application may introduce a spreadsheet data value that causes a primary key foreign key data inconsistency i.e. a data value that violates the PK FK relationship defined for the one or more relational tables .

Thereafter the database server generates an XML view defined by an XQuery query which when executed returns the spreadsheet data in an XML spreadsheet format where the XML spreadsheet format provides in a locked write protected cell each of the spreadsheet data values that may violate any rules and constraints enforced by the database server. By providing spreadsheet data in an XML spreadsheet format with write protected cells the database server causes the spreadsheet application which renders the spreadsheet data to follow any referential integrity rules and constraints that are defined on the one or more relational tables that store the spreadsheet data while still allowing the spreadsheet application to modify any other spreadsheet data values that would not cause any referential integrity problems.

According to the techniques described herein a spreadsheet application retrieves spreadsheet data from an XML view that is exposed as a resource through a file protocol interface provided by a database server. When the spreadsheet application accesses the XML view an XQuery query that defines the XML view is executed to return the spreadsheet data in an XML spreadsheet format that is understood and can be directly rendered by the spreadsheet application.

After the spreadsheet application renders the spreadsheet data a user may modify the spreadsheet data through the spreadsheet application. For example the user may change data values in the cells of the rendered spreadsheet and may add or delete rows of cells in the spreadsheet data. Thereafter the user may save the modified spreadsheet data by invoking a Save File command through the spreadsheet application. When the Save File command is invoked the spreadsheet application sends the command along with the modified spreadsheet data to the file protocol interface of the database server. The file protocol interface of the database server then examines the Save File command and determines in which particular XML view of possibly a plurality of XML views to store the modified spreadsheet data. The file protocol interface of the database server then converts the File Save command into one or more data modification commands that are executed against the XML view.

The techniques described herein are not limited to any particular data modification commands that the file protocol interface of the database server can execute against an XML view. For example in some embodiments the file protocol interface may generate a data modification command that specifies an update operation that updates a value in a cell of the spreadsheet data that is specified by the XQuery query defining the XML view. In another example the file protocol interface may generate a data modification command that specifies an insert operation that inserts a new row of cells in the spreadsheet data that is specified by the XQuery query defining the XML view. In yet another example the file protocol interface may generate a data modification command that specifies a delete operation that deletes a row of cells from the spreadsheet data that is specified by the XQuery query defining the XML view.

It is noted that in some embodiments the file protocol interface may generate an update command against the XML view where the update command would cause an Instead Of trigger associated with the XML view to be executed. Thereafter the Instead Of trigger would examine the modified spreadsheet data received from the spreadsheet application through the file protocol interface of the database server and would determine exactly what data modification operations need to be performed against the XML view in order to store the modified spreadsheet data.

When the Instead Of trigger associated with the XML view is executed the Instead Of trigger translates the data modification commands against the XML view into one or more DML statements against the one or more relational tables that store the spreadsheet data accessible through the XML view. The one or more DML statements may include various operations against the one or more relational tables including but not limited to one or more SQL UPDATE operations one or more SQL INSERT operations and one or more SQL DELETE operations. For example the Instead Of trigger may examine a mapping that maps rows and cells in the spreadsheet data to rows and columns of the underlying relational tables and may translate a data modification command which updates the value in a spreadsheet cell into a SQL UPDATE operation on a particular column of a particular relational table. In another example the Instead Of trigger may determine that the modified spreadsheet data includes a new row of cells in this case the Instead Of trigger may translate the data modification command which inserts the new row of cells in the XML view into a SQL INSERT operation against the one or more relational tables that store the spreadsheet data. In another example based on the mapping the Instead Of trigger may determine that the modified spreadsheet data does not include a particular row of cells that was previously sent by the database server to the spreadsheet application in this case the Instead Of trigger may translate the data modification command which deletes the particular row of cells from the XML view into a SQL DELETE operation against the one or more relational tables that store the spreadsheet data.

If the current row is newly added then the code represented by block when executed inserts the data values from the current row into the underlying relational tables. For example the code may inspect a mapping to determine which cells of the modified spreadsheet data correspond to which columns in which underlying relational tables and may then generate and execute one or more SQL INSERT statements against the one or more underlying relational tables.

If the current row is not newly added then the code represented by block when executed uses the data values from the current row to update the corresponding columns of the underlying relational tables. For example block represents code which when executed may inspect a mapping and may compare the data values in the current row of the modified spreadsheet data to the corresponding column values in the underlying relational tables. The code represented by block when executed generates and executes one or more SQL UPDATE statements to update the corresponding columns of the one or more underlying relational tables with the data values in the current row of the modified spreadsheet data. In this manner the Instead Of trigger code represented by pseudo code allows a spreadsheet application to directly update spreadsheet data that is stored in one or more relational tables managed by a database server.

Suppose that in an example operational context a user specifies through an interface of a database server the following a SQL query that specifies spreadsheet data 

In the above SQL query Q1 is received at database server as SQL query . The database server processes SQL query against the relational tables EMP and DEPT where tables and are relational tables that are managed by the database server in a relational database. As illustrated in table EMP comprises columns empno deptno empname and salary where column empno is defined as the primary key for the table and column deptno is defined as a foreign key referencing column deptno in table DEPT . Table DEPT comprises columns deptno and location where column deptno is defined as the primary key of the table.

After receiving SQL query according to the techniques described herein the database server automatically discovers the PK FK key relationships that are defined for tables EMP and DEPT . For example the database server may execute against a database dictionary the following query 

Thereafter according to the techniques described herein the database server translates the determined PK FK key relationships into join conditions and uses the join conditions to generate an XQuery query which when executed returns the spreadsheet data specified in SQL query the above query Q1 in an XML spreadsheet format. For example the following XQuery query XQuery query Q2 may be generated 

Thereafter the database server generates XML view that is defined by the XQuery query . For example the database server may generate the following DDL statement 

According to the techniques described herein when the database server generates XML view the database server also registers the XML view with a file protocol interface of the database server. The file protocol interface is operable to expose as a file the data that can be accessed through XML view . The file protocol interface may register XML view by associating it with a filename such as for example xmlEMPS.xls .

When the database server generates the XML view according to the techniques described herein the database server also generates Instead Of trigger that is associated with XML view . Instead Of trigger is executed automatically by the database server in response to any update operation that is executed against XML view . Instead Of trigger includes a mapping which maps the cells specified in XQuery query that defines XML view to columns of tables EMP and DEPT. For example the spreadsheet cell EMP EMPNO text specified in XQuery query maps to column empno in table EMP the spreadsheet cell EMP EMPNAME text specified in XQuery query maps to column empname in table EMP and spreadsheet cell DEPT LOCATION text specified in XQuery query maps to column location in table DEPT . Instead Of trigger uses mapping to determine which columns in tables EMP and DEPT need to be updated in response to any updates to the corresponding spreadsheet cells that may be made by a spreadsheet application.

Suppose that spreadsheet application sends command File Open xmlEMPS.xls to the file protocol interface of the database server. The file protocol interface of the database server uses the filename xmlEMPS.xls provided in command to determine which XML view of a plurality of registered XML views is referenced in command . Thus the file protocol interface of the database server determines that spreadsheet application is referencing data accessible through XML view xmlEMPS . Based on the command identifier e.g. File Open of command the file protocol interface of the database server determines that spreadsheet application wants to open the spreadsheet data accessible through XML view xmlEMPS . Thereafter the file protocol interface of the database server translates the File Open xmlEMPS.xls command to a DML statement which when executed can retrieve the requested spreadsheet data from the XML view xmlEMPS . The translated DML statement may be for example 

The file protocol interface of the database server then executes the above DML statement to retrieve the requested spreadsheet data. With reference to the data stored in tables EMP and DEPT in portions of the retrieved spreadsheet data are illustrated in Table 1 below 

When the file protocol interface of the database server retrieves the spreadsheet data from XML view xmlEMPS the file protocol interface converts the retrieved spreadsheet data into spreadsheet file . The file protocol interface of the database server then provides spreadsheet file to spreadsheet application and the spreadsheet application renders the spreadsheet data from the file. In this manner the techniques for accessing spreadsheet data through an XML view described herein are completely transparent from the perspective of spreadsheet application . For example the spreadsheet application sends a request for and receives spreadsheet file without knowing that the spreadsheet data is actually stored in relational database tables managed by the database server and without needing to do anything outside of performing its normal operations for opening a file.

Suppose that spreadsheet application sends command File Save xmlEMPS.xls to the file protocol interface of the database server. Spreadsheet application also provides to the file protocol interface of the database server file e.g. the file xmlEMPS.xls referenced in command which includes modified spreadsheet data that has been changed by spreadsheet application . Suppose that the modified spreadsheet data provided in file includes the change of the name of the employee with employee number from Donn to Don . The modified spreadsheet data with this change is illustrated in Table 2 below 

The file protocol interface of the database server uses the filename xmlEMPS.xls of file to determine which XML view of a plurality of registered XML views is referenced in command . Thus the file protocol interface of the database server determines that spreadsheet application is referencing data accessible through XML view the XML view named xmlEMPS . Based on the command identifier e.g. File Save of command the file protocol interface of the database server determines that spreadsheet application wants to store the spreadsheet data of file into XML view . Thereafter the file protocol interface of the database server translates the File Save xmlEMPS.xls command to a DML statement which when executed can store the spreadsheet data of file into XML view . The translated DML statement may be for example 

The file protocol interface of the database server then executes the above DML statement to store the modified spreadsheet data of file into XML view . In response to executing the DML statement against XML view Instead Of trigger is fired and executed. When executed Instead Of trigger processes the modified spreadsheet data in file row by row and determines based on mapping exactly which columns in exactly which rows of tables EMP and or DEPT need to be updated. For example during this processing Instead Of trigger would determine that the employee name of the employee with employee number 1202 needs to be changed to Don . Instead Of trigger then generates SQL DML statement which includes a SQL UPDATE operation against table EMP in order to store the changed employee name. For example Instead Of trigger may generate the following SQL DML statement 

In this manner the techniques for modifying spreadsheet data through an XML view described herein are completely transparent from the perspective of spreadsheet application . For example spreadsheet application saves the spreadsheet data of file without knowing that the spreadsheet data is actually stored in relational database tables managed by the database server and without needing to do anything outside of performing its normal operations for saving a file.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing data that causes a machine to operate in a specific fashion. In an embodiment implemented using computer system various computer readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to storage media and transmission media. Storage media includes both non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications. All such media must be tangible to enable the instructions carried by the media to be detected by a physical mechanism that reads the instructions into a machine such as for example computer system .

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

