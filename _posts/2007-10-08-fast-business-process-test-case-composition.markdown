---

title: Fast business process test case composition
abstract: Methods and apparatuses enable fast business process test case composition. Instead of the labor intensive and error-prone manual test case composition of previous systems, a group of one or more test agents enables creation of a business process test based on monitoring a business process application. The test agents monitor a backend interface of the business process application that interfaces the application with a backend enterprise system. The test agents generate business process test components and an ordering for the business process test components based on the monitoring. From the test components and the monitoring, the test agents create a business process test. The entire creation process can be performed with little to no user interaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08893089&OS=08893089&RS=08893089
owner: SAP SE
number: 08893089
owner_city: Walldorf
owner_country: DE
publication_date: 20071008
---
This application claims priority to Provisional Patent Application No. 60 828 764 filed on Oct. 9 2006 and entitled Adaptive Business Process Change Verification .

Embodiments of the invention relate to verifying business process changes and more particularly to business process test case composition with componentized test case building blocks.

Businesses increasingly rely on business processes to accomplish various tasks within the organization. The business software that is used to implement the business processes becomes critical to the organization. Some software e.g. SAP business software of SAP AG of Walldorf Germany allows customization and modification of the business process applications. Changes to the business processes may be made frequently e.g. weekly or even daily in some organizations. Prior to implementing a change in the business process software the organization would ideally verify validate the change to ensure the change accomplishes what is desired and does so correctly without interruption to the normal flow of the organization. However current methods of verification of the business process changes are expensive time consuming and often require tradeoffs between reliability and cost and or time.

Currently business software is tested in one of two ways manually or via record and playback scripting. Manual testing involves having people sit in front of a controlled environment and run the proposed changed business software following written test instructions. Testing can only be performed by human interaction with the system on which the software is installed. Manual testing is deficient in that the testing time is very high and the scope of tests possible is very small. The risk that an error will make its way through the testing is relatively high. The inefficiency and cost aspects to manual testing makes manual testing a generally unacceptable procedure.

Record and playback testing traditionally involves recording an entire sequence of activities that a particular participant in the business process would perform. However conventional record and playback requires that the test setup be an exact system duplicate of the recording. Variations between the systems frequently fail the testing. Additionally the testing system must be extremely stable given that changes to the system will fail the recording. Even in systems where the test does not fail for minor system changes there is generally a limited access for test systems to business process content. The result of the lack of content access is less flexibility than would be preferred for most system operators. Furthermore program scripting has a significant drawback in that specific tests must traditionally be written and adapted manually for every change. All current scripting tools have proprietary components that require specialists in the tool to implement. The cost of maintenance can become significant and possibly prohibitive. Thus record and playback scripting requires controlled conditions that are very difficult to produce and difficult to duplicate. The complexity increases the cost of the procedure and does not guarantee the desired outcome.

Methods and apparatuses enable fast business process test case composition. A test suite having one or more modules enables creation of a business process test based on monitoring a business process application. The test suite monitors a backend interface of the business process application that interfaces the application with a backend enterprise system. The test suite generates business process test components and an ordering for the business process test components based on the monitoring. From the test components and the monitoring the test suite creates a business process test.

In one embodiment the test suite reads metadata defining user interface screens for a business process flow and derives test components from the metadata. The test suite may monitor service requests generated for the backend enterprise system. In one embodiment the test suite performs offline monitoring. In one embodiment the test suite performs online monitoring. Both online and offline monitoring can be performed and the results combined. Online monitoring may be real time monitoring of a business process application as a business process flow is executed. The monitoring may include reading and interpreting a technical application flow inside a backend application stack. In one embodiment the test suite derives application flow rules and or deviations to describe the technical application flow for the business process application. In one embodiment the results of the monitoring are stored to a test component ontology map that provides the test suite with intelligent logic for determining how to create a test flow.

The business process test components may be reusable components that are stored and reused with other tests requiring the same component. In one embodiment the business process test components are based on UI screen definitions for the business process flow. Such UI screen definitions can be defined in a UI description table that includes descriptions of the fields and associations of various UI screens. The test components are ordered according to a flow determined by the test suite and the test is created from the components with the particular flow. An example of creating the test may be the generation of a test script.

Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein. An overview of embodiments of the invention is provided below followed by a more detailed description with reference to the drawings.

As provided herein a test suite monitors an execution environment to determine how work of a user is performed with a business process application. The test suite can monitor the backend interfaces of the business process application to determine how to generate a business process test. Such backend monitoring provides more information more flexibility than normal testing or record and playback techniques. Even in systems that record business process application activity the recording or monitoring has traditionally been performed at a front end of the business process application. The front end generally refers to the user interface UI where the data that is rendered and presented to the user. Thus traditional business application activity monitoring is performed by monitoring what is presented to a user UI monitoring or UI scanning . In contrast as described herein a test suite has the ability to monitor a backend where the business process application interfaces with the underlying enterprise system or systems that provide change and store the content e.g. business objects represented by fields or forms on the user interface screen. Such backend monitoring may be referred to as system Inspection referring to the more detailed inspecting of the system from the technical interface rather than the display perspective. The test suite may also monitor or at least have the ability to access what screens would be provided to a user as described in more detail below which may be performed in conjunction with or in addition to monitoring the backend interface.

Monitoring the backend interfaces can include monitoring the service requests made to the backend enterprise systems. The system has access to the UI description table that indicates what UI components are available and what properties they have. The test suite uses such information to compare against the monitored services to determine how a user interacts with the business process application. Any other metadata that indicates UI component information could also be read. Interactions and metadata can be persisted across multiple tests in one embodiment to enable the test suite to build up an ontology map. Thus the test system can understand e.g. via the ontology map how a business process application is used and what parameters and services are involved in the use of the business process application.

The test suite can then generate test components that represent discrete UI screens for a business process workflow. The test components are reusable and can be applied to any of a number of different workflows or scenarios as executed from the business process application. The test case includes the test components with accompanying test data for an expected result response from the enterprise system. Based on the workflow s as monitored from the operation of the business process application the test suite can generate a test script that applies the test components and test data. The test suite enables adaptive testing that reduces or eliminates the need for user input and improves upon traditional monitoring and recording techniques.

In one embodiment a test agent in the test target is coupled to the test suite. The test agent can observe or inspect the work flow of the test target and the test suite e.g. via an analyzer component generates flows according to observed i.e. in response to recorded behavior and alternatively or in addition to behavior indicated in a file or metadata or through other means. Generating the flow may include concatenating multiple test components which might be any of multiple screens to a transaction multiple transactions to a business process and or multiple business processes to a complete end to end application. Also non user interface functionality can be captured for test component creation for example software programs without a user interface interface modules such as enterprise services request for comments RFCs and business application program interfaces business APIs . Thus based on work flow and context the test suite can generate a test case or a sequence of test components matching the exact system for testing. The inspection of test components and analyzing of flows can be performed via a background task without user interface meaning that no actual processes have to be executed to verify a change to a business process. As a result manual input may be significantly reduced or eliminated. Such a background task may include a monitor that accesses a backend application stack and reads monitors the data on the stack.

Application is based on base content which represents out of the box or an initial configuration version of a business process or application. In one embodiment tests content and or test results are stored from one test to another. In such a case base content may represent a previously known good version or a previously tested version of a business process or application. Thus test content for application may be generated that represents a modification from a previous test of application . The adaptations of test content could therefore be incremental according to the changes made to application over previous versions. In one embodiment metadata may represent a difference configuration referring to information that indicates only what is different from base content rather than having an entire configuration.

Application further includes test agent . Test agent includes metadata reader that gathers metadata from application . The gathered metadata can be analyzed i.e. by test suite to determine how to generate a test for the business process flow of application . For example the test suite may indicate how application differs from base content . The metadata gathered by metadata reader can be analyzed by inspector and change analyzer . Inspector can access information related to backend system interfaces to determine how to generate test components. In one embodiment test agent includes flow agent that generates flow metadata which includes information about work flows in application . A work flow includes one or more sequences in which work is performed and includes data related to how systems and data of application are used.

In one embodiment test agent includes flow agent which represents one or more components that observe and record user behavior with respect to application . Flow agent may observe user behavior on the subject test target for a period of time e.g. one week or a number of uses e.g. five complete uses of the business process . The observed behavior may indicate what components users select i.e. what buttons or icons are pressed or used and in what order what screens a user follows to complete a task e.g. what sequence of screens or operations a user follows etc. The observed behavior provides information that can be later used to construct a test case that mirrors actual user behavior. Flow agent can generate flow metadata from observation which provides metadata regarding the flow of operations and data on application and may include some analysis of the data or organization grouping of the data e.g. categories of data .

Metadata reader may refer to a module that can read and parse data from a UI screen description table. Such a screen description table may reside in a backend and indicate what UI components are available what fields are in the screens what parameters or inputs are permissible etc. Such metadata may be read online or offline and interpreted by the test suite. Flow agent may provide additional information via online metadata gathering. Flow metadata refers to information about how the system operates in runtime. As used herein offline monitoring refers to monitoring that can be performed whether or not the business process application is actively executing a business process. Online monitoring refers to monitoring when the business process application is in an active state and a business process is loaded for execution. The business process flow can be interpreted from the change of one screen to another within the business process application together with the input that caused the flow change. As used herein the change of the business process from one state to another or from one phase to another may be referred to as application flow.

Offline monitoring as performed by test agent can predictively indicate an application flow based on interpretation of the metadata descriptions. Online monitoring as performed by test agent can provide an active look at the application by storing information from the application stack to indicate what is occurring within the application. That is the execution instructions as well as input values or input commands will be placed on the application stack and control operation of the application. In one embodiment the application flow can be interpreted for application flow rules and application flow deviations. Application flow rules refer to the standard operation of the business process application with one or more business process flows. Application flow deviations refer to exceptions special cases changes etc. from standard operation. Together the standard operation and the deviations indicate a technical application flow referring to the flow of the application from the command and input value level.

Test suite represents a testing entity. Test suite may provide test agent and or additional components for monitoring and analysis. In one embodiment test agent performs monitoring and test suite provides analysis. In another implementation test agent can also provide some or all of the analysis. In one embodiment test suite includes base content i.e. in a repository of test content data . In another embodiment test suite accesses base content from where it is stored.

Test suite includes multiple modules or components to generate the test content and possibly apply a test case to application . In one embodiment applying the test case or testing the test target is performed by an entity external to test suite . Thus test suite generates the test content which it provides to a test application tool. The following are possible components in one or more embodiments but should be understood as only examples and not as an exhaustive list nor as a list of necessary components. In one embodiment test suite includes inspector change analyzer and script generator . As described above test suite receives or accesses base content from which test content may be derived in addition to information from monitoring a backend interface. Base content identifier enables inspector and change analyzer to determine what is the base content for application and enables access to the base content. Base content identifier may select from among multiple available copies of base content e.g. different versions of application or different base content for different test targets . To select base content each test component has a unique identifier that matches the identity of application .

In one embodiment test suite includes test case constructor which represents one or more components that enable test suite to generate test content that incorporates work flow information. In some testing scenarios test suite generates one or more flows to construct an end to end test case or different flows related to aspects of application to be tested that are not necessarily end to end. Test case constructor may include flow analyzer that receives flow metadata of flow agent and analyzes user behavior information from flow metadata and determines how the business process or application is actually used by users. For example patterns of use e.g. data access service access etc. can be identified from flow metadata generated by flow agent . In one embodiment flow agent and test case constructor are part of a single entity of test suite . The analyzed information can inform test suite of how application is used in practice. Test case constructor may determine what tests are appropriate e.g. through heuristic or analytics algorithms for application based on the analysis of flow analyzer .

Context analyzer obtains context information for application and determines from the context how to generate a test case for the business process flow. In one embodiment context analyzer is part of inspector and or change analyzer . Thus context analyzer may represent functional components of inspector and or change analyzer . Alternatively context analyzer could exist wholly or in part as a separate component entity. In one embodiment one or more functional components of context analyzer are part of test agent . Based on the difference s detected by context analyzer test suite generates test content adapted to match the context of application . Context analyzer includes comparison module which represents one or more components through which differences are determined between application and base content which may work redundantly to or in conjunction with change analyzer . In one embodiment context analyzer includes user I O input output module . User I O module can enable user interaction with the context analysis. User I O module may for example provide a report that a user can verify to determine whether the analysis of test suite matches what is known of application . The user may be able to make changes to the information as necessary. Additionally user I O module could allow a user to input specific information that the user wants test suite to consider in generating test content. Thus test suite can adapt base content independent of user input and or may include a user in the process through user I O module .

Test case constructor generates one or more flow scenarios depicted by screen transaction process and end to end application appl . The depicted cascading of each of these components illustrates the concept that test case constructor can construct one from the other. For example multiple screens may be concatenated in a sequence to generate one transaction . Multiple transactions can be concatenated in a sequence to generate one process . Multiple processes can be concatenated in a sequence to generate end to end application . The sequence for each grouping is derived from information produced by flow analyzer . Flow analyzer receives and interprets flow information from other components of test suite and bases the test case flow on the monitoring of application online and or offline monitoring .

Test suite includes component library which represents a database or library of components that can be used to generate a test case for application . Component library provides reusable data objects that can be instantiated in different test cases. Component library includes components as part of test suite . Such commonly provided components are referred to as standard components . Additionally standard components can be modified and or additional components added to the library of components. Such components are referred to as custom components . In one embodiment one or more of the components is a drag and drop component that enables relatively quick generation of test content.

With the test components and test architecture described herein test suite supports various aspects of testing that are currently handled manually. For example test suite can enables slim test system setup via triggering of professional applications to perform the slim test system setup. With the understanding of the test case test suite can provide detailed instructions regarding how to set up a test system. The detailed setup understanding is contrasted with the existing professional application setup e.g. on SAP TDMS or Gamma InfoShuttle that must be configured from scratch without the benefit of the information available to test suite . Test suite can enable a wizard to create test execution data based on information that test suite gathers for introspection of screens and other functionality.

Additionally test suite can enable a more sophisticated analysis of a system than what is currently available. For example an advanced analysis possible with test suite includes information as to why a test case failed e.g. which particular data input field had an incorrect value missing user authorization etc. The advanced analysis renders test result analysis more efficient which can expedite the testing procedure. Additionally test suite can provide consolidated test results. For example a pie chart can be generated that displays how many high priority test areas resulted in how many severe errors.

UI screen generator provides components to the user access device which is the front end device. UI screen generator is generally based on business logic associated with the application for which the screens are generated. The generation of UI screens may be based on UI description tables which provide associations of components to input fields and inputs to transitions or changes in the UI. UI interfaces represent the hardware and or software e.g. drivers necessary to interact with a user.

Business process application represents a business process application according to any embodiment described herein. Business process applications can exist for different systems in an enterprise e.g. customer relationship management CRM supply chain management SCM human resources HR etc. . The business process applications can each execute one or more business processes. Business logic represents the logic of the application which provides the functionality of the application. Business process application interfaces with a user via front end interfaces which is an abstraction to represent any user interface layer for display such as UI screens and other types of input output I O devices.

Business process application also includes one or more backend interfaces . Backend interfaces represent one or more mechanisms with which the business process application or a business process being executed in the application accesses enterprise backend . In one embodiment backend interfaces include service request mechanisms such as in an enterprise services architecture ESA . Backend interfaces may include a backend application stack. Such a stack may be implemented to monitor the application and provide tracking of instructions and data resulting from execution of a business process. In one embodiment business process application is generated as an instance of an application via an application server. In such a case the application stack may be created as part of the runtime resources allocated to the application instance.

Enterprise backend can include any number of backend systems each of which may provide data objects and or services to business process application . Such systems are represented by systems and . Metadata and are associated respectively with systems and . Although depicted with the individual systems the metadata may actually be located in a single location. That is there may be metadata associated with access to each of the different systems. The metadata may be in a consolidated location such as a runtime resource table such as the UI description table or some other data resource. Each system may have distinct information regarding protocols or parameters for access or even security. Such information can be kept to be provided to a business test case to enable the operation of the test case on the system. In one embodiment enterprise backend includes an application server which may include an application stack for application .

Test suite may include a number of components to provide test suite functionality according to any functionality that is described herein. For example interface monitor represents one or more functional components or mechanisms through which test suite may monitor backend interface . Note that there may be significant distinction in different mechanisms employed for interface monitoring. For example a database or table access module may access data stored in records or tables that indicates information about various UI screens and or their relationships with each other or other data. Another mechanism may be a stack monitor that reads data from an application stack. Such a stack monitor could be an inline module that intercepts and forwards data instructions to the stack or a parallel component that reads the data placed on the stack. The parallel module could receive the data in addition to the stack or could read the data written to the stack. Another mechanism may be a request monitor that records what service requests were made to the backend systems and with what input parameters. The return data could also be recorded.

Test case generator provides the ability to gather and interpret the data monitored at the interfaces and may include any of the functional elements of test suite of . Interpreting the data can include determining how the flow of operation functions for a particular business process and or application. Application flow rules can be generated corresponding to the information. The system can also determine an ordering for each item monitored. Thus associations between items can be determined as well as dependencies and regular or expected flows. All such information can be stored for use in generating a test case. In one embodiment such information is persisted beyond the scope of a single business process or even beyond the scope of a particular application. The information can be stored in ontology map . As will be understood an ontology map in this case would provide a data model representing the various UI components of the business process es and relationships between those components. There could potentially be dozens if not hundreds or thousands of UI components. There could be any of a number of relationships among the various components. Thus ontology map represents one known mechanism to provide intelligence to the test suite in making determinations about the generation of test cases. Test case generator can use any form of logic algorithms determination sets etc. to generate a test case from monitored data. Note that in certain test cases only a fraction of available content may be used as would be determined by test suite .

Test data represents a test case as generated within test suite . Test data will ideally allow a system administrator to test the validity of a business process on the system. Thus changes to the business process can be applied to the test case and the results determined by executing the test case on business process application . Alternatively changes to the business process application or some enterprise service may be testable with test data generated as described herein.

System includes business process BP application appl that executes a business process. The execution includes access to enterprise backend . Business process application includes data renderer which represents data layer components of the application which provides a representation of data to a user on UI . In one embodiment business process application includes service interface which represents interfaces for an ESA based enterprise. Such interfaces may include data agents that have particular components for communicating with the backend. Service interface generates one or more service requests for data from enterprise backend . Service request may specify the service or data desired and access parameters necessary to obtain a result.

In one embodiment system includes UI description descr table which represents one or more items that provide UI data for rendering by data renderer . That is the business process application can indicate certain data to data renderer which then accesses UI description table to determine how to render the particular data generated within business process application . As is common with a table information can be stored by row and or column that is accessible via a key or handle to obtain graphic representations or other data related to the handle. UI description table may include UI data which provides the actual UI screens for rendering as well as UI metadata . UI metadata provides information about the UI screens such as information about how the screens are used conditions related to the use of the screens inputs etc. Such metadata information can be analyzed by test monitor to obtain information that indicates how to construct a test case for the system. Test monitor provides functionality similar to Inspector of .

Test monitor embodies any of the various monitoring mechanisms described herein. Test monitor is shown more particularly accessing UI description table to access UI metadata . Test monitor is also shown monitoring service request and monitoring the various requests that may be made to enterprise backend . In one embodiment test monitor is coupled to test components which represents components that are generated responsive to the monitoring. In one embodiment test components are generated relative to one particular type of monitoring which may include ordering the test components in a test case. The test case and or a test component may be modified based on a different type of monitoring. Thus if a test case is preliminarily set out based on monitoring UI metadata the test case may be monitored based on information obtained while monitoring service request . The reverse case could also occur in certain implementations.

Various components described herein may be a means for performing the functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc. Software content e.g. data instructions configuration may be provided via an article of manufacture including a machine readable medium which provides content that represents instructions that can be executed. The content may result in a machine performing various functions operations described herein. A machine readable medium includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . The content may be directly executable object or executable form source code or difference code delta or patch code . A machine readable medium may also include a storage or database from which content can be downloaded. A machine readable medium may also include a device or product having content stored thereon at a time of sale or delivery. Thus delivering a device with stored content or offering content for download over a communication medium may be understood as providing an article of manufacture with such content described herein.

A test suite is initialized to generate a test case for a particular system. The test system may need to perform one or multiple different business processes. The scope of the test may be dependent on the configuration as provided for initialization of the test. A business process application of a test system or a test target is initialized. The business process application includes one or more backend interfaces to the enterprise backend. The test suite accesses the backend interface of the business process application . As used here access may refer to accessing the actual interface e.g. via an application programming interface API or simply accessing the data generated at the interface.

In one embodiment the test suite reads metadata related to UI screens of the business process application . In one embodiment the individual UI screens are the UI components from which the test case is generated. That is a screen with various layout components and various fields for display and or input may be a building block component from which test cases may be generated. In one embodiment the test suite identifies service requests for services of the backend enterprise system.

With the data accessed from a backend interface the test suite is able to generate one or more business process test components . As suggested above the generation of business process test components may include offline and or online aspects. Each will be described in turn. However it is important to note that one or the other could be omitted or otherwise optional in certain implementations. Additionally the different aspects could be performed in a way that one is dependent upon the other or they could be implemented in a way that both are separate from each other.

In an implementation where the test suite performs offline monitoring of the business process application the test suite may optionally generate a metadata analysis . Such an analysis may or may not be persisted beyond the scope of the particular test case. The analysis could simply be temporarily stored and then purged upon generation of the test case. Alternatively the analysis could be persisted in whole or in part. The test suite generates test components based on the metadata analysis . The metadata analysis can be understood here to include information from which test components can be derived. In one embodiment one or more test components or simply a relationship between test components can be adjusted based on a technical flow output from an online monitoring analysis .

In an implementation where the test suite performs online monitoring the test suite reads and interprets a technical application flow of the business process application. The technical application flow indicates on a low level e.g. via instructions object layer method calls etc. what the flow of the business process is and what can be generated to match such a flow. In one embodiment the test suite optionally creates a technical flow output which may or may not be persisted. The test suite can generate test components based on a metadata analysis and the technical flow output . Such an implementation is one in where an offline analysis is performed prior to the online analysis. Such an order of analyses need not be followed. The metadata analysis may occur after certain online technical flow monitoring is performed and test data relative to the online monitoring can be modified to include information derived from the offline monitoring.

Whether from online and or offline monitoring the test suite generates an ordering for the generated test components . From the test components and the test component ordering the test suite creates a business process test . In one embodiment the test suite generates a test script to implement the generated business process test .

Besides what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

