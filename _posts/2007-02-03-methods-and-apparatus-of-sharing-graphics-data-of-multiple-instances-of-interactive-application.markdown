---

title: Methods and apparatus of sharing graphics data of multiple instances of interactive application
abstract: The present invention presents systems and methods for running interactive applications such as video games remotely over broadband network by an interactive application host system. In accordance with the present invention, interactive applications such as video games can be hosted and executed remotely by one or multiple interactive application hosts in native mode or using emulation or other similar binary execution technique. An interactive application host system can use dedicated graphics rendering apparatus inter-connected with the interactive application host(s) for rendering or compressing frames of multiple interactive applications. A graphics rendering apparatus can cache the graphics data received from the interactive application host(s) and share graphics data among multiple instances of interactive application from the same interactive application host or from different interactive application hosts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07830388&OS=07830388&RS=07830388
owner: 
number: 07830388
owner_city: 
owner_country: 
publication_date: 20070203
---
This application claims the benefit of U.S. Provisional Application No. 60 765 930 filed on Feb. 7 2006 and U.S. Provisional Application No. 60 780 020 filed on Mar. 7 2006.

This invention relates to video game or interactive application hosting service where frames or video of the hosted applications are rendered remotely and delivered to the clients e.g. set top box mobile device etc. over broadband network wherein the interactive application hosting service applies resource sharing in graphics rendering apparatuses.

The prior art of running interactive entertainment applications on widely available consumer media play devices are specialized game consoles such as Playstation 3 or XBOX that become increasingly sophisticated and expensive to design and manufacture interactive television that mainly designed for on demand viewing of shows movies videos etc on demand game download that downloads games or emulators on demand over broadband network to a device that will execute the downloaded game or emulator locally.

While the patent invention shall now be described with reference to the embodiments shown in the drawings it should be understood that the intention is not to limit the invention only to the particular embodiments shown but rather to cover alterations modifications and equivalent arrangements possible within the scope of appended claims. Throughout this discussion that follows it should be understood that the terms are used in the functional sense and not exclusively with reference to specific embodiment implementation programming interface.

Discussion in this section is intended to provide a brief description of some exemplary embodiments of the present invention.

On the client side there are clients e.g. set top box computer mobile device such as PDA or cellphone etc. . A client supports rendering of the media streams transmitted to it from an interactive application host center over the network . It can decompress the received media stream display the interactive application frames on an attached display device e.g. television monitor LCD panel etc. .

For interactive game play or control a client system can compromise one or multiple input devices such as game pad or video game controller or other similar game input device. Optionally a television controller or the client itself e.g. cellphone PDA can be used as an input device. An input device can connect to the client via wired or wireless connection.

In one embodiment an interactive application host can comprise multiple high performance computer processors or comprise multiple computer processors featuring several processing elements or processor cores in a single chip or in a single IC integrated circuit package so called multi core or many core processors.

The interactive applications hosted by an interactive application host can be single user or multi user applications. For a single user application the application receives interactive inputs from a single client. For a multi user application the application receives inputs from multiple or a collection of clients . Furthermore in an embodiment to support large number of clients multiple interactive application hosts can participate in running one interactive application. According to the present invention multiple game applications can also be executed concurrently on a video game host in native mode in which each interactive application instance is executed as a task or a computer process.

In accordance with the present invention in one embodiment an interactive host can use emulation e.g. platform emulation virtual machine operating system emulation etc. to run interactive applications developed for hardware or operating system different from the hardware or system of the interactive application host . In one exemplary embodiment an interactive application host can run multiple emulation or simulation tasks with each task emulating a console or a computer platform or an operating system. For example in one embodiment an interactive application host can run multiple emulators of some commercial game console or arcade.

Furthermore in each emulated platform there can be one or multiple interactive applications executed. An interactive application host can also run simulation or emulation of another operating system target operating system in order to run interactive applications originally developed for the target operating system. Note that this can be done by providing compatible software implementation of the target operating system s kernel services. For example using OS emulation or simulation Windows interactive applications can be executed on Linux system. When emulation is used the host operating system running on the interactive application host can create emulation tasks that emulate the target platform or the target operating system along with the interactive application or applications running over the target platform or the target operating system.

Still referring to there are a collection of rendering apparatuses used for graphics rendering. An interactive application host can capture the graphics command e.g. graphics processing API application programming interface call graphics rendering command etc. and or graphics data of an interactive application . The interactive application host can send the graphics command or graphics data to the graphics rendering apparatuses that perform graphics processing. A graphics rendering apparatus can comprise one or multiple networking communication interfaces for receiving graphics command or graphics data and one or multiple graphics processing elements for conducting graphics processing and frame rendering.

In additional embodiment because the rendered frames are not displayed locally by the video game host for each game application its graphics can be rendered on some virtual frame buffer e.g. emulated display device virtual frame buffer non display buffer or memory surface etc. .

In an alternative embodiment fake or dummy OpenGL or Direct3D device driver can be used to capture all the graphics API calls or graphics data . Those dummy graphics drivers export the standard OpenGL or Direct3D or graphics device calls.

After graphics commands or graphics data are captured by either an emulator or redirected API interface or an API wrapper or a dummy fake graphics driver they are sent to one or multiple graphics rendering apparatuses via inter connect network e.g. system area network local area network local bus connection or hierarchy or other similar inter connect or network communications . An interactive application host can comprise one or multiple network communication interfaces for transmitting graphics commands or graphics data and receiving data via the inter connect network .

Examples of local bus connection include but not limited to PCI or PCI X or PCI Express or other similar bus mechanism. Examples of system area network include but not limited to Infiniband. Furthermore the connection in can comprise bus hierarchy involving one or multiple bus bridges or one or multiple switches or one or multiple chip interconnects or combination of local bus with system area network.

It should be understood the scope of the present invention should not be limited to any specific interconnect configuration or interconnect topology or interconnect standards.

It should be understood that is for illustration purpose only. An inter connect that connects graphics rendering apparatus with interactive application host can include but not limited to advanced switching fabric built over high speed bus or Gigbit ethernet or other local area network or Infiniband or other system area network inter connect etc.

A graphics rendering apparatus comprises one or multiple graphics processing elements. A graphics processing element can render one or multiple streams of graphics frames for one or multiple interactive application instances e.g. interactive application task process or threads etc. . A graphics processing element can be a GPU graphics processing unit or a DSP digital signal processor or a computer micro processor or other similar processing element capable of running graphics processing and rendering. In additional embodiment a graphics rendering apparatus can render or generate frame images concurrently for multiple game applications.

A graphics rendering apparatus can also comprise one or multiple control processor . A control processor takes the role of setting up the graphics processing elements or dispatching graphics processing commands or graphics processing workload to the graphics processing elements .

Furthermore a graphics rendering apparatus can comprise integrated network processing capability. It can receive graphics commands or graphics data from multiple interactive application hosts.

A graphics rendering apparatus can comprise one or multiple graphics data caches . In one embodiment a graphics data cache is used for caching graphics data locally in a graphics rendering apparatus to save bandwidth of transmitting graphics data from an interactive application host to the graphics rendering apparatus . For example due to inter frame coherence or locality a video game host may send the same set of graphics data such as texture maps or collection of geometry data to a graphics rendering apparatus during rendering of consecutive frames instead of sending the same data over and over again the repeated graphics data can be cached by a graphics rendering apparatus .

The kind of graphics data that can be cached include but not limited to texture maps or geometry data or 3D mesh or vertex attributes or shader programs or other similar graphics data.

Still referring to and graphics data caching in one embodiment of the present invention when graphics data is cached by a graphics rendering apparatus an interactive application host can query whether a piece of or a set of graphics data has been cached by a destination graphics rendering apparatus .

In some additional embodiment an identifier is assigned to each piece or each set of graphics data. In this case an interactive application host can query whether a set of or a piece of graphics data is cached by a graphics rendering apparatus using its identifier. If the answer is yes the interactive application host can save communication bandwidth and speed up graphics processing by transmitting only the graphics commands and references to the cached graphics data.

In accordance with the present invention in some alternative embodiment an interactive application host sends graphics data identifier first. If a graphics rendering apparatus can not find the associated graphics data it can respond to the interactive application host and ask for the interactive application host to send the missing graphics data.

In accordance with the present invention in one embodiment graphics data caching is managed at the graphics API level. For example when using OpenGL or Direct3D a game application needs to declare frequently the accessed graphics data as graphics API objects. In the case of Direct3D a graphics object can be texture surfaces or vertex buffers or other similar graphics data. The same texture surface or vertex buffer can be used repeatedly for rendering frames. A dummy graphics API driver or emulation driver or implementation of redirected API interface can capture declaration of graphics objects and have the corresponding graphics data such as texture map or vertex attributes cached in a graphics rendering apparatus . A unique identifier can be assigned to a cached graphics object. A video game host or a graphics rendering apparatus can query whether a graphics object is cached using its identifier. In accordance with the present invention in a embodiment how video game hosts or graphics rendering apparatuses come up the identifier is irrelevant. Note that graphics object is a type of graphics data.

In one embodiment the identifier can be computed in a centralized way using one or multiple servers who can uniquely assign an identifier to each graphics object.

In an alternative embodiment identifier can be computed in a distributed way by interactive application host or graphics rendering apparatus . For example in one embodiment for a newly declared graphics object an interactive application host can assign an identifier that is a concatenation of its machine name and the current time.

It should be understood that the aforementioned example is to demonstrate how easily identifiers can be assigned to graphics objects. The example is not intended to limit the scope of the present invention to any specific way how identifier is computed and assigned to graphics object.

Furthermore the scope of the present invention is neither limited by who can compute or assign an identifier to a graphics object. Identifier can be assigned by either an interactive application itself or an interactive application host or a graphics rendering apparatus or some other graphics object name identification server.

Still referring to graphics data cache depending on the implementation a graphics data cache may store many copies of redundant graphics data. For example if many interactive application hosts run the same interactive application and use the same graphics rendering apparatus the graphics rendering apparatus may cache multiple copies of the same graphics data if different identifiers are assigned to the same graphics data by different interactive application hosts.

In one embodiment of the present invention graphics object identifier can be assigned by the interactive application itself. For the same piece of graphics data for example the same texture map it is always referenced using the same identifier by an interactive applications. This embodiment requires the game applications themselves to manage identities of graphics data and expose them to the interactive application hosts or the graphics rendering apparatuses . Alternatively the issue can be dealt with transparently.

In one embodiment graphics data can be compressed and then transmitted to a graphics rendering apparatus as a solution for reducing bandwidth demand. Examples of compressible graphics data include but not limited to textures or 3D geometry attributes or vertex attributes or vertex buffer data or vertex arrays or 3D mesh or other similar graphics data.

In additional embodiment mobile codes or programs for generating or synthesizing graphics data can be transmitted to a graphics rendering apparatus in replacing of the graphics data themselves. For example many interactive applications use some sorts of particle simulation to simulate natural phenomena or to achieve many visual effects. Instead of sending large amount of particle data an interactive application can transmit or upload mobile codes or programs of particle simulation to a graphics rendering apparatus. During graphics rendering the mobile codes or programs can generate or simulate particle data based on certain control parameters. Those control parameters can be sent by an interactive applications in realtime without consuming large amount of bandwidth.

In another example an interactive host can send programs or codes that can synthesize or generate textures to a graphics rendering apparatus instead of transmitting the textures themselves. Similarly 3D mesh can be also generated or synthesized using codes or programs. Those mesh generating or synthesizing or tessellation programs or codes can be transmitted to a graphics rendering apparatus for producing mesh data instead of transmitting the mesh data themselves.

Furthermore mesh generating or synthesizing programs can export control parameters that can be used for controlling mesh generation. An interactive application host can at runtime send different configurations of control parameters to generate the kind of mesh that it wants without transmitting large number of vertices or geometry data.

In addition vertex attributes such as texture coordinates etc. can also be generated or synthesized using programs or codes executed by a graphics rendering apparatus.

In additional embodiment a graphics rendering apparatus can directly deliver the compressed frames to the client via broadband network e.g. Internet IP TV network 3G 4G network etc. .

Still referring to to test whether a new graphics object is identical to some old graphics objects in one embodiment a digital hash e.g. hash signature or other similar shortened representative value can be computed for each graphics object using its data values. An interactive application host or a graphics rendering apparatus or a stand alone name identification server can maintain a collection of graphics object hash values and their corresponding data values.

When a new graphics object is declared its hash value can be matched against the collection of hash values. If there is no match this new graphics object is certainly not a replica of some existing graphics objects and a new identifier can be assigned to it. In some embodiment if there is a match data values of this new graphics object can be compared with the data values of those matched graphics objects. If it is found out that this new graphics object is the same as some old graphics object this new graphics object can be referenced using the same identifier assigned to the old graphics object who has identical data values.

To give a more concrete example for example in one embodiment assume that a texture image is used by multiple instances of the same interactive application by more than one interactive application host . Further assume that several interactive application hosts use the same graphics rendering apparatus . The first time a graphics object of the texture map is created an identifier is assigned to it. When it is first time processed by the rendering apparatus its data values will be cached. Next time when the same texture map is used by another instance of the same interactive application another graphics object based on the same data will be created. Since this graphics object has identical data values with the old graphics object it will be assigned the same identifier. If this another instance of the same interactive application wants to render frames using this texture map and finds out that it has been cached by the rendering apparatus it will simply send graphics rendering commands plus identifier of the texture graphics object. It is not necessary to transmit the texture itself because an identical version of the texture is already cached by the graphics rendering apparatus .

Still describing caching of identical graphics data comparison of graphics data hash values can be carried out by either the video game host or by some dedicated server or by the graphics rendering apparatus . In one embodiment one or multiple centralized servers can be used for checking whether graphics objects with identical values have been created by different interactive application hosts .

Alternatively an embodiment can apply distributed servers where each server serves a number of interactive application hosts . Each server will have its own collection of graphics objects created by the interactive application hosts it connects with. The distributed servers themselves can be synchronized on the graphics objects or graphics object identifiers that have been created or assigned.

Alternatively in another embodiment a graphics rendering apparatus can compare the identifiers and or the data values of the graphics objects that it wants to cache with those already cached and detect whether a copy of the graphics data has already been cached.

In one embodiment when there is insufficient storage space left for caching new graphics objects in a graphics rendering apparatus a graphics rendering apparatus can remove some cached graphics objects.

Furthermore a graphics rendering apparatus can notify interactive application hosts via unicast or via multi cast or via broadcast the status of the graphics objects removed from its collection of graphics data cache .

It should be understood that the exemplary embodiments aforementioned are for demonstration purpose to show how the present invention may work in the field. They are not intended to limit the scope of the present invention to the illustrated approaches of caching graphics data.

As various changes can be made in the above embodiments and operating methods without departing from the spirit or scope of the following claims it is intended that all matter contained in the above description or shown in the accompanying drawings should be interpreted as illustrative and not in a limiting sense. The invention is not limited by the specific embodiments described herein. Variations or modifications to the design and construction of this invention within the scope of the appended claims may occur to those skilled in the art upon reviewing the disclosure herein. Such variations or modifications if within the spirit of this invention are intended to be encompassed within the scope of any claims to patent protection issuing upon this invention.

