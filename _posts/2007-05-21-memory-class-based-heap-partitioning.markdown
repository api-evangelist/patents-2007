---

title: Memory class based heap partitioning
abstract: The illustrative embodiments provide a computer implemented method, apparatus, and computer usable program code for managing a heap. The heap is partitioned into at least one sub heap based on a relationship to at least one memory class of a plurality of memory classes. A memory allocation request comprising a memory class is received from a requester. A unique heap handle based on the memory class and associated with a specific sub heap is generated. The unique heap handle is then returned to the requester.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08996834&OS=08996834&RS=08996834
owner: International Business Machines Corporation
number: 08996834
owner_city: Armonk
owner_country: US
publication_date: 20070521
---
This invention was made with United States Government support under Agreement No. NBCH3039004 awarded by DARPA. The Government has certain rights in the invention.

The present invention relates generally to memory management in a data processing system and specifically to a memory management scheme that is adapted to address the problem of debugging heap.

Programs often wish to dynamically allocate memory from a shared dynamic memory pool. This allows programs to scale their memory usage to runtime environments. The memory pool is a dynamic pool because the amount of memory a program needs does not need to be known until runtime. Thus memory is allocated during runtime or dynamically. This shared dynamic pool of memory is often referred to as heap or sometimes as shared heap. 

The opposite of dynamic memory is static memory. For static memory a program may say it always uses a fixed amount of memory. That is simpler but it does not allow the program to use additional memory.

Heap is commonly used in single threaded applications. In single threaded applications heap memory is shared among components of the application. An application can be very large and have unrelated components that are allocating memory from a single pool. The management of the heap is done by either the applications themselves allocating and de allocating memory as required or by the operating system or other data processing system programs.

The malloc application program interface API is an example of a memory allocator. APIs are a set of routines that an application uses to request and carry out lower level services performed by a computer s operating system. Also APIs may be a set of calling conventions in programming that define how a service is invoked through the application.

The memory returned from malloc is often shared among multiple software components. Malloc is primarily a C library routine that returns number bytes and the address for those bytes to the calling routine. The malloc API takes a number of bytes as an input parameter. This allows programs to wait until they know input parameters to request the memory they need.

The free API is used to free the memory allocated by a malloc call. Other languages use memory allocators that work in the same manner. For example in the Advanced Interactive Executive AIX operating system the kernel API xmalloc is used to allocate memory and xmfree is used to free the memory.

Bugs occur when the programs still use the memory stored in a location even though a free API has occurred. Other types of bugs include using more memory than was allocated and failing to initialize memory. These bugs can cause the previous data to corrupt or overwrite the data that is supposed to be placed into the memory currently.

When heap corruption occurs in dynamically allocated memory the results can be unpredictable and difficult to diagnose.

The illustrative embodiments provide a computer implemented method apparatus and computer usable program code for managing a heap. The heap is partitioned into at least one sub heap based on a relationship to at least one memory class of a plurality of memory classes. A memory allocation request comprising a memory class is received from a requester. A unique heap handle based on the memory class and associated with a specific sub heap is generated. The unique heap handle is then returned to the requester.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . Clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub NB MCH and a south bridge and input output I O controller hub SB ICH . Processing unit main memory and graphics processor are coupled to north bridge and memory controller hub . Processing unit may contain one or more processors and even may be implemented using one or more heterogeneous processor systems. Graphics processor may be coupled to the NB MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB and other ports and PCI PCIe devices are coupled to south bridge and I O controller hub through bus and hard disk drive HDD and CD ROM are coupled to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to south bridge and I O controller hub .

An operating system runs on processing unit and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processing unit . The processes of the illustrative embodiments may be performed by processing unit using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

The hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is generally configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

Heap corruption issues continue to be a significant service problem. In heap management there are two conflicting goals to be achieved. One goal is achieving optimum performance. The other goal is to provide greater protection and isolation of heap data between components in order to meet Reliability Availability Servicability RAS requirements.

Reliability requirements refer to the computer s or program s doing or performing what it is supposed to do. Availability requirements refer to the likelihood that the computer or program is ready to perform a requested task. Serviceability requirements refer to the ability figure out what went wrong and correct the error when the system does have a problem.

Multiple heaps provide better memory isolation and can help identify the source of heap corruption. While providing multiple heaps provides better memory isolation it has a performance cost. Providing multiple heaps adds to memory fragmentation.

The following illustrative embodiments provide for memory class based heap partitions. New APIs are provided to identify memory allocation classes that are requested from shared heaps.

The new APIs allow the system to partition what appears to be a single shared heap into multiple sub heaps based on a memory class. Partitioning a heap means that a single large pool of memory the heap is divided into smaller pools of memory that are isolated from each other. These smaller isolated pools of memory are referred to as sub heaps. The actual number of heaps or sub heaps may be varied to tradeoff performance against requirements for RAS.

Multiple sub heaps allow heap debug settings to be separately maintained for each memory class. While providing multiple memory class based sub heaps provides better memory isolation it has a performance cost. Providing multiple sub heaps adds to memory fragmentation.

Various illustrative embodiments allow the memory classes to be easily adjusted so that RAS performance tradeoffs may be tuned to a specific configuration. For example in a benchmarking environment all memory classes may be serviced from a single heap. This configuration maximizes performance at the expense of RAS.

Alternatively when debugging a heap corruption problem all memory classes may be provided with unique sub heaps. This configuration maximizes RAS at the expense of performance.

Typical default environments map related memory classes into the same sub heap. For example the AIX kernel maps all memory classes that are exclusively accessed by the kernel into a new shared kernel sub heap. In contrast memory classes belonging to the block storage sub system are mapped to a shared block kernel extension sub heap.

Turning back to the figures is a block diagram of a system for providing multiple memory class based heaps in accordance with an illustrative embodiment. System comprises server which may be implemented as data processing system in that has resident operating system databases and programs and APIs and and heap . While databases and along with programs and are depicted as resident on server in the present illustrative embodiment in alternative embodiments databases and along with programs and may be remote from server or a combination of remote and resident.

Databases and and programs and are examples of programs that may request access to a heap. Databases and and programs and communicate with server through APIs and requesting access to heap . Some typical examples of such APIs include but are not limited to heap create xmalloc and xmfree .

Internal to an operating system are functions which is software that performs an operation. Internal functions are called to map memory classes to sub heaps. Thus in response to a request to access heap from a program such as databases and and programs and operating system calls internal functions such as internal functions and to map the request to sub heaps or of heap . However it will appear to databases and and programs and that all requests are mapping to a single heap heap .

It should be understood that while in the depicted illustrative embodiment databases and and programs and are shown as communicating with only one API either API or databases and and programs and may communicate with any and all APIs of operating system .

API or API determine which sub heap to access by examining a heap handle which is a unique identifier that is created by the heap create call at the time of the call s execution. This heap handle is then used for all subsequent memory allocations.

The heap handle is based on the memory class. A heap handle is a data structure that includes characteristics of a heap or sub heap. A heap handle is used by a shared memory allocator to reference the proper sub heap. Each heap handle is unique.

Software components register for memory allocation by performing a heap create call. The heap create call is provided with heap attributes. One attribute is a memory class. This is an identifier that is registered with the system. The memory class describes the type of memory to be allocated. A memory class is assigned or determined by software or a programmer. A memory class may be named anything and can be used to categorize memory in any manner desired. For example memory could be categorized by application by system by device device driver and so forth. The name of the memory class should be finely granulated. For example if the calling device is a mouse device driver the memory class may be called devicedriver mouse not simply devicedriver or device. Other device drivers would be similarly named such as devicedriver keyboard devicedriver monitor and so forth. The kernel defines memory classes for its subsystems such as kernel vmm kernel virtual memory manager or kernel lfs kernel logical filesystem .

The heap create call returns a heap handle that is used for subsequent memory allocations. The heap handle is a unique identifier that is based upon the received memory class. The heap create caller does not have direct knowledge of how heap create is mapping memory classes to implemented heaps. This allows a single global shared heap to be replaced with shared sub heaps. Thus while the accessing programs all believe that one heap is being accessed the requests may in fact be directed to specific sub heaps. For example all request from the memory class devicedriver such as devicedriver keyboard devicedriver monitor and devicedriver mouse may be sent to one shared sub heap while all requests from the kernel such as kernel vmm or kernel lfs are sent to a different sub heap.

The actual number of sub heaps used may be altered for performance and RAS requirements. For example if the user wanted to maximize performance then all requests may be for one heap and no sub heap would be created. However in the case where a problem arose and debugging was desired the number of sub heaps could be increased. Thus memory could be partitioned off to determine where the trouble was occurring. For example all requests from the memory class devicedriver may be sent to one shared sub heap partition. Once it is determined that the trouble is coming from that particular sub heap the heap may then be further partitioned into additional sub heaps.

The heap handle allows for a unique sub heap partition to be created for each member of a memory class. The heap create service maps a request to create a shared heap to the existing sub heap partition. The heap create service returns a unique heap handle that can be used for future allocation calls such as xmalloc . Although the returned heap handle references a shared sub heap partition there are properties such as a debug level that are unique to the returned heap handle.

Debug level controls are a collection of runtime check operations that can be performed by the allocate and free services. The debug operations can have a significant performance penalty but they are often useful to catch memory allocation errors. For example when full pages of memory are freed the operating system can make them inaccessible. If a program attempts to access memory after the memory has been freed and debug code has made the memory inaccessible a storage access exception occurs that can be easily debugged. Debug code is code used to catch or debug problems.

Another example of debug code is when the caller uses more memory than was allocated to the caller. The contents of memory beyond the allocated range of memory can be checked at free time to determine if the caller overran their allocated memory size. Another debug method is to place random patterns into memory at allocation time to catch callers that use memory without initializing the memory.

Prior debugging solutions called for these checks to be applied to an entire heap. In contradistinction illustrative embodiments provide for creating debugging properties for specific memory classes. This reduces the overall performance costs by allowing higher granularity when applying debug checks. These debug properties can be set on the individual heap handle further improving serviceability.

Furthermore the combination of heap handles and memory classes allows a user to change both the relationship of how heap or sub heap partitions are mapped to memory classes and the debug property of the memory class without having to change the actual call routines. The user may tune the system through use of a heap configuration command or set of commands. The user would simply alter the allocation policies and save the changes in persistent memory. Persistent memory also referred to as persistent storage is a memory location that survives operating system boots. Some examples of persistent memory include but are not limited to hard drives floppy disks CDs DVDs and so forth. Then upon the next boot up of the system the system would query persistent memory for the currently saved allocation policies and build the appropriate sub heap partitions.

Thus if a user wanted to debug all devicedriver memory allocations a user such as a system administrator could set the debug level associated with all handles of that memory class to the appropriate debug level. Additionally the user may define special sub heap mappings for that memory class or classes. For example the user could set the sub heap mapping such that allocation requests are referred to a unique sub heap partition for each member of the memory class and the debug operations are performed based on the debug properties. Alternately the user could set the sub heap mappings such that allocation requests are referred to a unique sub heap partition only for a certain memory class while the other memory classes are referenced to a different shared sub heap partition.

Calling program sends input to API . API queries allocation policies and sends output to calling program in response to receiving input . Input comprises a heap create call with a memory class heap attribute. Output comprises a unique heap handle.

Calling program registers for memory allocation by issuing a heap create call containing a memory class heap attribute to API . API queries allocation policies to determine an appropriate unique heap handle based on the received memory class attribute. This unique heap handle is returned to the calling program and is used for all subsequent allocation calls.

The changes to the allocation policies are saved in persistent memory step . The system is then either shutdown or rebooted step . Upon the next boot up the system queries the persistent memory for the currently saved allocation policies step and builds the appropriate sub heaps which may be implemented as sub heaps or in step and the process ends.

Allocation policies include debug properties for memory classes as well as memory class mappings to heaps and sub heaps. These debug properties will be placed into heap handles by heap create . Thus as shown in a user can alter both the memory class to sub heap mappings and the debug property without actually changing any code for any call routines. Thus saving both time and expense.

The flowcharts and block diagrams in the different depicted embodiments illustrate the architecture functionality and operation of some possible implementations of apparatus methods and computer program products. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified function or functions. In some alternative implementations the function or functions noted in the block may occur out of the order noted in the figures. For example in some cases two blocks shown in succession may be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved.

Thus the different illustrative embodiments provide a computer implemented method apparatus and computer usable program code for managing a heap. IN different embodiments the heap is partitioned into at least one sub heap based on a relationship to at least one memory class of a plurality of memory classes. A memory allocation request comprising a memory class is received from a requestor. A unique heap handle based on the memory class and associated with a specific sub heap is generated. The unique heap handle is then returned to the requester.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

Further a computer storage medium may contain or store a computer readable program code such that when the computer readable program code is executed on a computer the execution of this computer readable program code causes the computer to transmit another computer readable program code over a communications link. This communications link may use a medium that is for example without limitation physical or wireless.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

