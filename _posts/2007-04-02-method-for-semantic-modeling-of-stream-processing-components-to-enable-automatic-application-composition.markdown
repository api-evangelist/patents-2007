---

title: Method for semantic modeling of stream processing components to enable automatic application composition
abstract: A method for modeling components of a stream processing application, includes: defining an input message pattern of a processing element, wherein the input message pattern includes variables representing data objects that must be included in a message input to the processing element, and a graph pattern that semantically describes the data objects that must be included in the message input to the processing element; and defining an output message pattern of the processing element, wherein the output message pattern includes variables and new data objects, the variables and new data objects representing data objects that must be included in a message output from the processing element, and a graph pattern that semantically describes the data objects in the message output from the processing element.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08098248&OS=08098248&RS=08098248
owner: International Business Machines Corporation
number: 08098248
owner_city: Armonk
owner_country: US
publication_date: 20070402
---
This invention was made with Government support under Contract No. H98230 05 3 0001 awarded by the U.S. Department of Defense. The Government has certain rights in this invention.

This application is related to commonly assigned U.S. application entitled METHOD AND SYSTEM FOR ASSEMBLING INFORMATION PROCESSING APPLICATIONS BASED ON DECLARATIVE SEMANTIC SPECIFICATIONS Ser. No. 11 695 238 filed concurrently herewith and incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING STREAM PROCESSING GRAPHS IN STREAM PROCESSING SYSTEMS Ser. No. 11 695 487 filed concurrently herewith and incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR DECLARATIVE SEMANTIC EXPRESSION OF USER INTENT TO ENABLE GOAL DRIVEN STREAM PROCESSING Ser. No. 11 695 430 filed concurrently herewith and incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING PROCESSING GRAPHS IN INFORMATION PROCESSING SYSTEMS Ser. No. 11 695 349 filed concurrently herewith and incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR MODELING COMPONENTS OF AN INFORMATION PROCESSING APPLICATION USING SEMANTIC GRAPH TRANSFORMATIONS Ser. No. 11 695 311 filed concurrently herewith and incorporated by reference herein in its entirety commonly assigned U.S. application entitled METHOD FOR DECLARATIVE SEMANTIC EXPRESSION OF USER INTENT TO ENABLE GOAL DRIVEN INFORMATION PROCESSING Ser. No. 11 695 279 filed concurrently herewith and incorporated by reference herein in its entirety and commonly assigned U.S. application entitled METHOD AND SYSTEM FOR COMPOSING STREAM PROCESSING APPLICATIONS ACCORDING TO A SEMANTIC DESCRIPTION OF A PROCESSING GOAL Ser. No. 11 695 410 filed concurrently herewith and incorporated by reference herein in its entirety.

The present invention relates to modeling components of a stream processing application and more particularly to a method for semantic modeling of stream processing components to enable automatic application composition.

Stream processing applications ingest large volumes of streaming data from one or more sources process it using a variety of components and produce results that satisfy user queries.

Stream processing systems are needed in situations where source data is too voluminous to store and analyze. Such data observed on high capacity streams must be processed on the fly by stream processing applications in response to user queries. These applications are typically expressed as processing graphs or workflows of components that can extract meaningful information from mostly unstructured streaming data. A processing graph is a stream interconnected collection of data sources and processing elements PEs . Data sources produce the possibly unstructured streaming data to be observed. PEs are deployable software components that can perform various kinds of operations on the data to produce new derived data streams.

A key challenge for stream processing systems lies in the construction of processing graphs that can satisfy user queries. With many thousands of disparate data sources and PEs to choose from we cannot expect the end user to craft these graphs manually. These users are typically not skilled programmers and they may not have knowledge of the functions performed by different components.

We can also not rely on programmers or experts to construct these graphs. With the large numbers of data sources and PEs to consider the number of possible graphs is enormous. Different users can have different queries requiring different graphs to be constructed. Thus it is not feasible to pre construct all possible graphs to satisfy the wide variety of end user queries manually.

Also for a given query a number of alternative processing graphs can be assembled each achieving a similar result each consuming possibly different amounts of computational resources and each producing different levels of quality. Depending on deployment time resource utilization a particular graph may not be deployable but some alternate graph consuming fewer resources at some sacrifice in result quality might be deployable. Typically however users will not know how to construct the right graph to produce the highest quality result with resource limitations at deployment time.

In an exemplary embodiment of the present invention a method for modeling components of a stream processing application comprises defining an input message pattern of a processing element wherein the input message pattern includes variables representing data objects that must be included in a message input to the processing element and a graph pattern that semantically describes the data objects that must be included in the message input to the processing element and defining an output message pattern of the processing element wherein the output message patter includes variables and new data objects the variables and new data objects representing data objects that must be included in a message output from the processing element and a graph pattern that semantically describes the data objects in the message output from the processing element.

The graph pattern that semantically describes the data objects that must be included in the message input to the processing element uses terms defined in ontologies represented in Web Ontology Language OWL . The graph pattern that semantically describes the data objects in the message output from the processing element uses terms defined in ontologies represent in OWL.

The method further comprises defining a set of variables that represent configuration parameters of the processing element. The method further comprises inputting a plurality of modeled processing element descriptions each processing element description having a defined input and output message pattern and defined configuration inputting a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome and assembling a processing graph that produces a stream that satisfies the desired processing outcome.

Assembling the processing graph comprises matching a message output from a first processing element to an input message pattern of a second processing element if the message includes the data objects that must be included in a message input to the second processing element and if a graph that semantically describes data objects in the message satisfies the graph pattern that semantically describes the data objects that must be included in the message input to the second processing element.

The method further comprises connecting the first processing element to the second processing element when the message is matched to the input message pattern of the second processing element.

The method further comprises generating an output message of the second processing element by applying differences between the graph pattern that semantically describes the data objects that must be included in the message input to the second processing element and the graph pattern that semantically describes the data objects produced as output by the second processing element to the graph that semantically describes the data objects in the message based on a graph transformation operation.

The method further comprises defining an output message pattern of a data source wherein the output message includes exemplar terms the exemplar terms representing data objects that must be included in a message output from the data source and a graph that semantically describes the data objects in the message output from the data source.

The graph that semantically describes the data objects in the message output from the data source is formed by OWL assertions.

The method further comprises inputting a plurality of modeled processing element descriptions each processing element description having a defined input and output message pattern inputting a plurality of data source descriptions each data source description having a defined output message pattern inputting a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome and assembling a processing graph that includes at least one of the modeled processing elements or at least one of the modeled data sources that produces output messages that satisfy the desired processing outcome.

Assembling the processing graph comprises matching a message output from a data source to an input message pattern of a processing element if the message includes the data objects that must be included in a message input to the processing element and if a graph that semantically describes data objects in the message satisfies the graph pattern that semantically describes the data objects that must be included in the message input to the processing element.

The method further comprises connecting the data source to the processing element when the message is matched to the input message pattern of the processing element.

The method further comprises generating an output message of the processing element by applying differences between the graph that semantically describes data objects in the message and the graph pattern that semantically describes the data objects that must be included in the message input to the processing element to the graph pattern that semantically describes the data objects in the message output from the processing element based on a graph transformation operation.

In an exemplary embodiment of the present invention a system for modeling components of a stream processing application comprises a memory device for storing a program a processor in communication with the memory device the processor operative with the program to define an input message pattern of a processing element wherein the input message pattern includes variables representing data objects that must be included in a message input to the processing element and a graph pattern that semantically describes the data objects that must be included in the message input to the processing element and define an output message pattern of the processing element wherein the output message pattern includes variables and new data objects the variables and new data objects representing data objects that must be included in a message output from the processing element and a graph pattern that semantically describes the data objects in the message output from the processing element.

The graph pattern that semantically describes the data objects that must be included in the message input to the processing element uses terms defined in ontologies represented in OWL. The graph pattern that semantically describes the data objects in the message output from the processing element uses terms defined in ontologies represent in OWL.

The processor is further operative with the program to define a set of variables that represent configuration parameters of the processing element. The processor is further operative with the program to receive a plurality of modeled processing element descriptions each processing element description having a defined input and output message pattern and defined configuration receive a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome and assemble a processing graph that produces a stream that satisfies the desired processing outcome.

When assembling the processing graph the processor is further operative with the program to match a message output from a first processing element to an input message pattern of a second processing element if the message includes the data objects that must be included in a message input to the second processing element and if a graph that semantically describes data objects in the message satisfies the graph pattern that semantically describes the data objects that must be included in the message input to the second processing element.

The processor is further operative with the program to connect the first processing element to the second processing element when the message is matched to the input message pattern of the second processing element.

The processor is further operative with the program to generate an output message of the second processing element by applying differences between the graph pattern that semantically describes the data objects that must be included in the message input to the second processing element and the graph pattern that semantically describes the data objects produced as output by the second processing element to the graph that semantically describes the data objects in the message based on a graph transformation operation.

The processor is further operative with the program to define an output message pattern of a data source wherein the output message includes exemplar terms the exemplar terms representing data objects that must be included in a message output from the data source and a graph that semantically describes the data objects in the message output from the data source.

The graph that semantically describes the data objects in the message output from the data source is formed by OWL assertions.

The processor is further operative with the program to receive a plurality of modeled processing element descriptions each processing element description having a defined input and output message pattern receive a plurality of data source descriptions each data source description having a defined output message pattern receive a processing request wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome and assemble a processing graph that includes at least one of the modeled processing elements or at least one of the modeled data sources that produces output messages that satisfy the desired processing outcome.

When assembling the processing graph the processor is further operative with the program to match a message output from a data source to an input message pattern of a processing element if the message includes the data objects that must be included in a message input to the processing element and if a graph that semantically describes data objects in the message satisfies the graph pattern that semantically describes the data objects that must be included in the message input to the processing element.

The processor is further operative with the program to connect the data source to the processing element when the message is matched to the input message pattern of the processing element.

The processor is further operative with the program to generate an output message of the processing element by applying differences between the graph that semantically describes data objects in the message and the graph pattern that semantically describes the data objects that must be included in the message input to the processing element to the graph pattern that semantically describes the data objects in the message output from the processing element based on a graph transformation operation.

In an exemplary embodiment of the present invention a computer program product comprising a computer useable medium having computer program logic recorded thereon for modeling components of a stream processing application the computer program logic comprises program code for defining an input message pattern of a processing element wherein the input message pattern includes variables representing data objects that must be included in a message input to the processing element and a graph pattern that semantically describes the data objects that must be included in the message input to the processing element and program code for defining an output message pattern of the processing element wherein the output message pattern includes variables and new data objects the variables and new data objects representing data objects that must be included in a message output from the processing element and a graph pattern that semantically describes the data objects in the message output from the processing element.

The foregoing features are of representative embodiments and are presented to assist in understanding the invention. It should be understood that they are not intended to be considered limitations on the invention as defined by the claims or limitations on equivalents to the claims. Therefore this summary of features should not be considered dispositive in determining equivalents. Additional features of the invention will become apparent in the following description from the drawings and from the claims.

In accordance with an exemplary embodiment of the present invention a semantic model is provided that captures the semantics or meaning of the data on streams. In this model streams are described using semantic graphs formed by facts represented in Web Ontology Language OWL described in D. McGuinness and F. van Harmelen. OWL web ontology language overview. In W3C Recommendation 2004 a copy of which is incorporated by reference herein in its entirety. OWL is one of the standard languages of the Semantic Web. This model is used to describe different data sources and processing elements PEs in terms of the semantics of the data they consume and produce. Users can also frame queries on the streaming data based on this model. A stream query is represented in the form of a semantic graph pattern that describes the kinds of streams the user is interested in. Data sources are described as producing patterns of streams. All semantic descriptions are based on domain ontologies that define the relevant terms in an area of interest using OWL.

In accordance with another exemplary embodiment of the present invention by using the semantic model a method and system for composing processing graphs automatically and on the fly whenever a new query is submitted is provided. In order to achieve this automatic composition a planning algorithm enhanced to efficiently accommodate the semantic descriptions that views a stream query as a semantic goal that is to be achieved by composing different data sources and PEs into a processing graph. The planning algorithm constructs optimal graphs that meet the security and privacy constraints. Since OWL is built on Description Logic DL the planning algorithm makes use of a class a DL reasoning while constructing optimal graphs.

The system for composing graphs is built on top of the System S Stream Processing Core SPC described in N. Jain L. Amini H. Andrade R. King Y. Park P. Selo and C. Venkatramani. Design implementation and evaluation of the linear road benchmark on the stream processing core. In SIGMOD 06 June 2006 a copy of which is incorporated by reference herein in its entirety.

The System S see is built on the SPC which is a scalable distributed runtime for stream processing of unstructured data. The SPC provides a set of components that jointly manage deployment and execution of distributed stream processing applications under heavy workload. Application processing graphs submitted to SPC must be described in a Job Description Language JDL specifying a set of PE instances to be deployed and the connections between the PEs. Runtime environment on each of the SPC nodes includes Data Fabric for managing data flows and PE Controller that manages execution of PEs deployed on the node. Structured and or unstructured data is sent between the PEs packaged in stream data object SDO format. A Graph Manager component controls I O channels of the data fabric and a Resource Manager manages dynamic allocation of PE instances to nodes subject to various resource constraints.

In what follows INQ will be described a component of System S responsible for semi automatic generation of JDL job descriptions based on ontology supported descriptions of processing goals. Inquiry specifications encoded in ISL and received through Inquiry Manager are fed to a Semantic Planner which consults domain ontologies to interpret the inquiry spec and consults domain and system ontologies to match the request to the capabilities of candidate data sources and PEs. Semantic planning is achieved using formal reasoning over the various ontologies and will be discussed later. The processing graphs produced by the planner are then translated into JDL by a Plan Manager and can submitted for deployment in SPC. Completely automatic composition may not work in all scenarios and users have the option to review the composed application and may decide to go back and revise their inquiry.

We illustrate the main underlying idea of INQ by an example. Assume that in a company called Enterprise Global Services EGS the System S is connected to a private VoIP based telephone network. Following a customary business practice all callers to EGS phones are warned that the calls may be monitored to ensure quality service. Thanks to VoIP employees of EGS can travel and take calls anywhere they can find an Internet connection. The person whose job it is to monitor the quality of service may be interested in calls made by a specific employee or in location of that employee. These questions can be answered by a stream processing application schematically shown in .

In a single SourcePE EVAS is connected to EGS VoIP network and streams out VoIP packets packaging them as SDOs. A number of PEs process the information and eventually output three result streams via corresponding SinkPE. NES sink produces alerts when employee Bob makes a call NEL sink produces the same alerts but also provides information on the location of Bob based on his IP address and finally LCP sink streams out information on the location of all employees currently making calls. Different implementations of SinkPEs can be used with the same data to provide different types of result disposition for example store the results in a database or stream notifications to user s console.

We have not included all PEs required in our implementation of this processing graph but the main PEs are shown. SPA and VBF carry out simple preliminary analysis of VoIP streams at a high rate removing noise. PSD can detect speaker names using voice signatures of EGS employees. NES is a filtering PE configured to select only calls of the employee named Bob. SLF looks up the geographic location of a caller based on the IP address and JoinLL computes a window join between the streams of identified speakers and caller locations.

The graph in shows the result of overlaying three separate inquiries. Rather than developing three disconnected graphs and including a new copy of the EVAS SPA VBF chain in all three the System S can overlay the graphs and reuse partially processed results.

At a high level the process of composing such an application can be described informally as follows. Given an inquiry where is Bob the planner will look for a PE that can provide location of employee Bob treating Bob as a literal. JoinLL PE can do that and it requires two input streams one carrying speakers identified as Bob and another carrying location information. NES can provide speakers named Bob if it receives a stream of identified speakers and has configuration parameter name set to Bob . This search continues until a processing graph similar to the graph shown on is built where all input requirements of all PEs are satisfied.

To implement this approach the Semantic Planner uses descriptions of PEs sources and inquiries expressed in OWL and makes use of OWL DL reasoning to compare the requirements of PEs and inquiries to streams produced by other PEs and sources. In particular ontologies and reasoning help make the connection between the user s terms and the system s terms for example match where is . . . goal to a stream carrying geographic location of phone call . When more than one alternative stream can satisfy an input requirement the planner evaluates all possible alternatives rejecting those that violate various operational constraints and selecting optimal graphs from the remaining alternatives.

The Semantic Planner creates the plans based on the descriptions of PEs and data sources represented in OWL. These descriptions directly affect the output of the planner and therefore significantly impact how the system reacts to user s requests and what kinds of requests are supported. Hence the process of describing the semantics of PEs and becomes a part of the software engineering process in the System S . We refer to this process as ontology engineering to emphasize that we are talking about writing semantic descriptions not programs. While this new process introduces additional complexity and increases the costs of developing applications we argue that in large systems the advantages achieved in separating PE and source development from the formulation of inquiries outweighs such concerns. This provides a rough equivalent of making database queries independent of the database schema and stored procedures via a mapping supported by extensible ontologies.

INQ and ISL in particular provides a bridge between the users understanding of processing goals and the specific application configurations deployable in SPC.

In the past few years the growth of the Semantic Web has resulted in a number of different models and languages for representing and reasoning about knowledge. A number of tools have also been developed to aid the specification of ontologies as well as perform reasoning on the ontologies. A number of ontologies have been developed in various domains such as bioinformatics and medical research. Thus it is becoming increasingly easier to leverage these powerful technologies in managing data. New tools developed in the future will further help in managing large ontologies.

There are a number of different data models that can be used for describing stream queries and stream system components. These include keyword based models relational models object oriented models etc. The main reason for choosing a semantic graph based model is that it is highly expressive and supports the use powerful reasoning mechanisms during composition.

Semantic models are especially useful for describing arbitrary operations on data in a formal manner and then build a plan automatically that uses these operations Relational algebra and its extensions is very well suited for describing relational and time windowed operations on streaming data. However they are not as useful for describing arbitrary operations such as annotation classification transformation etc. on different kinds of structured semi structured or unstructured data in different formats including text audio video etc. . Although SQL has user defined functions that can perform arbitrary analysis of data these functions have to be explicitly declared by users in their SQL queries. So the people writing SQL queries need to have expert knowledge on the functions and on the different tables. This approach does not scale well when the set of possible operations is huge and dynamically changing.

Since PEs can perform arbitrary processing on the data they must have a semantic model that allows them to be composed. We describe the PEs using graph transformation approaches. That is the inputs to a PE are described in terms of graph patterns that describe the kinds of input streams they can handle and outputs are described in terms of graph patterns that describe the kinds of output streams they produce. This is more expressive and has a basis in formal description logic. It is also very powerful since DL reasoning can be used to match components hence components can be matched to one another even if they use different terms and graph structures. Our main hypothesis is that we can capture enough of the PE s behavior in terms of these graph transformations so as to construct processing graphs using them in an automatic manner.

In the past few years the growth of the Semantic Web has resulted in a number of different models and languages for representing and reasoning about knowledge. A number of tools have also been developed to aid the specification of ontologies as well as perform reasoning on the ontologies. A number of ontologies have been developed in various domains such as bioinformatics and medical research. Thus it is becoming increasingly easier to leverage these powerful technologies in managing data. New tools developed in the future will further help in managing large ontologies.

A stream carries of zero or more data objects called Stream Data Objects SDOs . Each SDO is associated with a timestamp. In addition a stream is associated with metadata that is described semantically using a graph described in OWL a standard language of the Semantic Web. This semantic description of the stream provides rich information about the meaning of the data on the stream together with its format.

Formally a Stream S is a 2 tuple Sem where Sem is the semantic description of the stream. represents a multiset of stream data objects SDO each of which is associated a with timestamp T. T represents a discrete ordered time domain. A time instant is any value from T. The semantics of each SDO is based on Sem.

The basis of semantic descriptions of streams are ontologies. Ontologies are formal descriptions of the kinds of entities there are and how they are related. Here we use ontologies specified in OWL which is based on RDF. OWL is emerging as a standard Semantic Web language for describing ontologies and is based on Description Logics DL . OWL ontologies describe concepts or classes properties and individuals or instances relevant to a domain of interest.

Description Logic DL is typically used to represent and reason about the terminological knowledge of an application domain. In DLs there are two kinds of facts TBox terminological box and ABox assertion box . In general the TBox contains sentences describing concepts and properties. For instance it describes concept hierarchies and the domains and ranges of properties. The ABox contains ground sentences describing individuals or instances . For instance it describes which concepts an individual belongs to as well as the values of any properties defined on the individual. OWL ontologies may be described as RDF graphs. We assume that there is a common set of ontologies on which all stream descriptions PE and data source descriptions and inquiry goals are based. This allows us to compose stream processing applications that satisfy user goals without having to worry about the tough problem of mapping or integrating heterogeneous ontologies.

RDF Term. Let U be the set of all URIs. Let RDFbe the set of all RDF Literals which are data values that may be typed . The set of RDF Terms RDF is U RDF.

Note that RDF also defines blank nodes which are unique nodes that can be used in one or more RDF statements but have no intrinsic name or URI. In our model of streams we do not consider blank nodes however the model can be easily extended with blank nodes.

2. the predicate which is an RDF URI reference. The predicate is also known as the property of the triple.

An RDF triple is conventionally written in the form subject predicate object . An example of a triple is Earth locatedIn SolarSystem .

RDF Graph. An RDF graph is a set of RDF triples. The set of nodes of an RDF graph is the set of subjects and objects of triples in the graph. The edges are labeled by the properties.

OWL Axiom. An OWL Axiom is a sentence in the TBox of an ontology that gives information about classes and properties. This information includes subclass and subproperty relationships whether a certain property is transitive symmetric or functional or the inverse of another property restrictions on the values of a property etc. An OWL Axiom may be represented as an RDF triple. An example is Planet rdfs subClassOf HeavenlyBody which describes how the concepts Planet and HeavenlyBody relate to each other.

OWL Fact. An OWL fact is an ABox assertion that states information about a particular individual in the form of classes that the individual belongs to plus properties and values of that individual. An OWL fact may be represented as an RDF triple. An example is Earth rdf type Planet which describes the individual Earth as belonging to the concept Planet.

Each stream is associated with a semantic description Sem. This description is represented as a special kind of semantic graph that captures the semantics of the data in a typical or exemplar SDO in the stream. The semantic description describes the data present in the SDO and any constraints that are satisfied by the data in terms of a graph of OWL facts.

Exemplar Individual. In order to describe the semantics of a stream we introduce the notion of an exemplar individual which is a special kind of OWL individual. An exemplar individual is a member of the set Ewhere Eis infinite and E U. An exemplar individual represents an existentially quantified variable whose value belongs to the set of regular or nonexemplar individuals i.e. who s value belongs to U E. For the purpose of representation in an OWL ontology we describe the exemplar individual as an OWL individual that belongs to a special concept called Exemplar individual.

Exemplar Literal. An exemplar literal is a member of the set Ewhere Eis infinite and E RDF. An exemplar literal represents an existentially quantified variable whose value belongs to the set of regular or non exemplar literals i.e. who s value belongs to RDF E.

For the purpose of representation in an OWL ontology we define an exemplar literal to have a special xsd type called xsd exemplar. In this paper we represent all exemplar individuals and literals with a preceding  .

The semantic description of a stream is expressed in terms of exemplar individuals and exemplar literals. Exemplar individuals may be associated with a number of constraints in the semantic description of the stream. For example the constraints on exemplar individuals include the classes they belong to and values of various properties. Different SDOs in the stream may replace the exemplar individuals and literals with regular or non exemplar individuals and literals. The replacement regular individuals and literals must obey all the constraints that are associated with the exemplars.

Stream Triple. A stream triple is an OWL fact that is a member of the set U E U RDF E E where either the subject is an exemplar individual or the object is an exemplar individual or an exemplar literal. An example of a streamtriple is x rdf type Person . Note that rdf type is a standard RDF predicate that indicates that the subject  x is an individual that is of type Person which may be an OWL concept. Different SDOs in a stream may replace  x with different values such as John or Mary . However any values that  x is replaced by must satisfy the condition that it s type is the OWL concept Person.

A Basic Stream Graph is a set of Stream Triples as depicted below in RDF N3 format described in T. Bemers Lee Notation 3. Technical report a copy of which is incorporated by reference herein in its entirety 

Stream Value Constraint. A value constraint is a boolean valued expression of exemplar individuals and RDF Terms. An example is SVC1 Duration PT0.5S xs duration 

Semantic Description of a Stream. The semantic description of a stream describes the data present in a typical SDO on the stream and any constraints on the data expressed using a graph of OWL facts. The semantic description of a stream is a 3 tuple of the form SN SD SG where

We represent the semantic description of a stream using OWL facts and value constraints. An example of a stream is the VoIP AudioSegmentStream which contains the exemplar individual  VoIP AudioSegment  which is further described by the stream graph USG. The stream is represented as follows 

In the above description the stream contains an exemplar individual called  VoIP AudioSegment . In other words all the SDOs in the stream contain an element that satisfies all the constraints described on  VoIP AudioSegment .

The stream graph USG describes the constraints on  VoIP AudioSegment . It states that  VoIP AudioSegment  is of type VoIP AudioSegment and also states constraints on certain properties of  VoIP AudioSegment . shows the description as a graph .

Also note that a stream description only contains OWL facts i.e. assertions about different individuals exemplar and regular and how they are related. It does not contain OWL TBox axioms i.e. it does not define new concepts or properties or extend the definitions of existing concepts and properties. A stream description only uses concepts and properties defined in the ontology. In the above example the ontology defines different concepts like InfraredImage Image etc. and different properties like imageOf. In addition it defines some individuals like Earth and Hubble.

An important point is that Hubble Earth and  c do not really appear in the stream they are semantic descriptions of the  VoIP AudioSegment  data which appears in the stream. Hence the contains relation is a special one only those data items that the stream explicitly says it contains are actually in the stream. The rest of the graph forms a rich semantic description of what the stream contains.

Ground Instance of a Basic Stream Graph. Exemplar individuals and literals in a basic stream graph act as existentially quantified variables. Hence they may be replaced by regular non exemplar individuals or literals.

Let M be a mapping from a set of exemplar individuals and literals to some set of non exemplar individuals and literals. Then the graph obtained from a basic stream graph G by replacing all of the exemplar individuals and literals e in G by M e is a ground instance of G. This ground instance is represented by M G .

Structure of an SDO in the stream. Each SDO in a stream may also be described as a semantic graph. The semantic descriptions of the SDO is derived from the semantic description of the stream after replacing all exemplar individuals and literals by regular non exemplar individuals and literals.

In the above example different SDOs in the stream might have different images in place of the exemplar  VoIP AudioSegment  and different times in place of the exemplar  StartTime. However all the images in the SDOs satisfy the different conditions described in USG viz. that it is of type InfraredImage it is an image of Earth etc. In a specific SDO all the exemplar individuals and literals are replaced by regular individuals and literals. For example a specific SDO may contain a specific image say image123 with 64 colors. This specific image obeys all the constraints described on  VoIP AudioSegment  e.g. 

While all streams have a semantic description based on stream graphs they do not necessarily carry data in the form of such graphs. For purposes of efficiency and performance the stream data objects may be formatted using other models. Examples of models used for representing the format of the data on the stream are keywords attribute value pairs types structures in a programming language like C or Java encoding formats like jpg etc. and relations or tuples .

The separation of the semantic model of a stream and the actual format of the data on the stream is a key element of our approach. We distinguish the format of the data from the meaning of the data. For purposes of efficiency or compatibility with legacy systems that actual data on the stream may be formatted in different ways. However for the purposes of automatic composition of stream processing applications there needs to be semantic models of streams which are then used to describe PEs and Data Sources.

A data source is described as producing a single stream. Formally a data source is a 3 tuple of the form DSN SDS DD where

An example Data Source is shown in . This source produces a stream that contains an exemplar called  VoIP AudioSegment . The semantic graph describes the constraints on  VoIP AudioSegment . For instance it states that  VoIP AudioSegment  is of type VoIP AudioSegment.

Another example of a Data Source is shown in . The HubbleEarthImageSource produces a stream that contains HubbleEarthImage  an individual in the class InfraredImage.

The streams produced by data sources may sometimes satisfy inquiries by themselves. Typically however some processing needs to be done on one or more primal streams coming from data sources in order to produce a stream that satisfies an inquiry. This processing is done by one or more PEs laid out in a processing graph. In our system PEs may be implemented using either Java or C they have well defined interfaces describing their inputs and outputs in terms of types in a typesystem Java or C .

A PE is represented as an individual of the concept PE and is described as taking in one or more input streams and producing one or more output streams. In addition a PE may be associated with other properties like developer algorithmUsed etc. The semantic description of a PE contains a description of the kinds of streams it takes in and the kinds of streams it gives out. In order to describe the inputs and outputs we introduce the notion of a stream pattern.

Broadly a stream pattern describes an equivalence class of streams. Its description looks similar to the description of a stream except that certain elements in the description can now be variables.

A triple pattern is an RDF triple containing a subject predicate and object where either the subject or the object is a variable. An example of a triple pattern is x imageOf Earth .

Value Constraint. A value constraint is a boolean valued expression of variables and RDF Terms using string based or numeric relational operators. An example is VC1 NoColors

PEs are described in terms of the kinds of streams they require as input and the kinds of streams they produce as output. They are modeled in terms of graph transformations. The inputs and outputs are described as stream patterns which in turn consist of graph patterns. Hence the basic PE model is that it takes m input graph patterns on its m input streams processes or transforms them in some fashion and produces n output graph patterns on its n output streams. In addition a PE can have zero or more configuration parameters that can be used to dictate exactly how the PE behaves. Each configuration parameter is represented as a variable literal of a certain type like xs string or xs int .

An example PE is shown in . This PE requires an input stream which contains VoIP CallAudioSegment  that is associated with various constraints. The format of VoIP CallAudioSegment  is an RTP packet. The PE extracts the start time and call channel information from the incoming RTP packet and computes the end time from the duration. It then puts this information along with the original VoIP  CallAudioSegment  on the output stream .

Another example of another PE is shown in . The ImagePatternRecognizer PE is defined as requiring one stream containing some Image Image  and as producing a single output stream containing Image  and a Keyword Keyword  such that Image  is describedBy Keyword . The meaning is that the ImagePatternRecognizer requires as input some Image  and produces the same Image  as output annotated by some Keyword . The ImagePattern Recognizer is defined to perform a few functions it conveys a known Image from input to output it creates a new object a Keyword and it establishes a new relation describedBy.

The semantic description of a PE gives a general application independent description of the kinds of streams and parameters it requires and the kinds of streams it produces. In a given application or processing graph a specific set of input streams may be connected to the PE and a specific set of configuration parameters may be given to the PE. As a result the PE produces a specific set of output streams.

Note that the semantic description of the PE is in terms of streams and not in the form of individual SDOs. For example the description does not say how many SDOs a PE takes in on any input stream for producing SDOs on the output stream.

Note that although the PEs inputs outputs and parameters are described using OWL assertions that does not mean that the PEs actually take in and produce data in the form of OWL assertions. The data they take in and produce may be in any format text image video etc. however their semantics are as described by these OWL assertions.

PEs performing different kinds of functions are classified according to a PE taxonomy which distinguishes different PEs based on patterns by which the semantics of the output are related to the semantics of the input.

The StreamProtocolAnnotator PE takes in some input data and outputs a copy of the input data annotated with additional information. As such the StreamProtocolAnnotator is classified as an Annotator one of several design patterns that can be described. Annotator PEs are a class of PE that take in some input and produce a stream containing the same content with some additional annotation. Other types of PEs include Aggregators Classifiers DemultiplexorsDemultiplexors Filters Joins and Monitors as well as SourcePEs and SinkPEs responsible for respectively conditioning data entering and exiting the system .

The semantic description of a PE gives a general application independent description of the kinds of streams and parameters it takes in and the kinds of streams it gives out. In a given application or processing graph a specific set of input streams may be connected to the PE and a specific set of configuration parameters may be given to the PE. As a result the PE produces a specific set of output streams.

In order to connect an input stream to a PE we need to be able to match the stream to the stream pattern describing the PE s input requirement. Based on this match we describe the conditions for connecting a specific set of input streams to the PE and instantiating the PE with a specific set of configuration parameters. We also describe the method for calculating the description of the specific output streams the PE produces.

Matching a Stream to a Stream Pattern. A stream matches a stream pattern if and only if all the conditions or constraints in the stream pattern are satisfied by the stream. We now describe what is required for a stream to match a stream pattern.

In order to define a match we first define the notion of a pattern solution which expresses a substitution of the variables in a stream pattern. We then define the conditions for a match in terms of the existence of an appropriate pattern solution.

Pattern Solution. A pattern solution is a substitution function V RDF from the set of variables in a graph pattern to the set of RDF terms. Variables may also be mapped to exemplar individuals and exemplar literals. For example one possible definition of for the graph pattern UGP is Earthimage  hei StormPattern  TropicalStorm NoColors  c.

The result of replacing a variable v is represented by v . The result of replacing all the variables in a graph pattern GP is written as GP .

Condition for match. Consider a stream pattern SP SV GP and a stream S SN SD SG . GP can be considered to be the union of a basic graph pattern BGP and a set of value constraints VC. SG can be considered to be the union of a basic stream graph BSG and a set of stream value constraints SVC. We define the stream pattern SP to be matched by the stream S based on an ontology O if and only if there exists a pattern solution defined on all the variables in GP such that following conditions hold 

The above definition is very generic. It allows the use of different kinds of reasoning to decide if a stream matches a stream pattern. Our system does reasoning on a specific subset of DL called DLP Description Logic Programs . We represent this match as S SP to state that stream S matches stream pattern SP with a pattern solution . One way of looking at the above definition is that the stream should be more general than the stream pattern. The stream should have at least as much semantic information as described in the stream pattern. An example of the match with the variable substitutions is shown in .

Associating a set of streams and parameter values with PE. We extend the definition of a match between a stream and a stream pattern to provide the conditions for determining if a set of streams match the set of stream patterns that describe the PE s input requirements and if a set of parameter values are valid.

The stream patterns representing the different input stream requirements of a PE may not be independent. Different stream patterns may share variables and thus the assignment of variables to values for one stream pattern would also depend on any constraints associated with the variable in other stream patterns. Hence it is not possible to look at each stream pattern individually and determine if a certain stream matches the stream pattern. All the stream patterns must be treated holistically. In addition a PE may have zero or more configuration parameters associated with datatype constraints.

Let ISR SP SP . . . SP represent the set of streampatterns that describes the m input stream requirements of a PE. Each stream pattern is of the form SP ID IGP . Let Params p . . . p represent k configuration parameters to the PE.

Let SS S . . . S represent a set of m streams. Each stream is of the form S SN SD SG . In addition let PV v . . . v represent k parameter values. We define the set of stream patterns ISR to be matched by the set of streams SS if and only if there exists a pattern solution defined on all the variables in IGP Params such that S SPfor i 1 . . . m. Also the parameter values are valid if p vand vsatisfies the type constraint associated with pfor j 1 . . . k.

Determining the output of a PB. When a set of input streams are connected to the PE the PE generates output streams. The actual description of the output streams is generated by combining the descriptions of the input streams fed to the PEs with the stream patterns describing the outputs of the PE in the PE s semantic description. We formally define this combination in terms of a graph transformation operation.

Let ISR ID IGP i 1 . . . m be the in input streampatterns to a PE. Each IGPcan be considered to have a basic graph pattern Land a set of value constraints LVC. Let OSP OD OGP j 1 . . . n be the n output streampatterns of the PE. Each OGPcan be considered to have a basic graph pattern Rand a set of value constraints RVC. Let Land R. The PE implements a graph transformation pe 

Now assume that the in input graphs have been matched to m streams generated by other components i.e. ISRis matched to stream IS which has a basic stream graph X for i 1 . . . m. Let be the overall variable substitution function for all the variables in .

Let the output streams coming out of the PE as a result of connecting the streams ISto it be represented as OS. Each OScontains a basic stream graph Y. We determine each Yusing a graph homomorphism f where Xand Y.

1. f L X. This means that each substituted input basic graph pattern is a subgraph of the actual basic stream graph of the stream that was matched to it. This follows from the entailment relation between the graphs as defined in the match between the input stream pattern and the stream.

2. f R Y. This means that each substituted output basic graph pattern is a subgraph of the output stream graph.

3. f and f where represents the graph difference operation. This means that exactly that part of X is deleted which is matched by elements of not in and exactly that part of is created that is matched by elements new in R .

Using properties 2 and 3 it is possible to determine the outputs Y of a PE as a result of connecting Xto it. This operation is performed in two main steps. In the first step we remove all the edges and vertices from X that are matched by to get a graph D where D . We make sure that D is a legal graph i.e. no edges are left dangling because of the deletion of the source or target vertices. We also remove any components in the graph that are disconnected from the set of exemplar individuals that appear in the output stream graphs. In the second step we glue D with to get .

An example of this process can be seen in . Notice how some of the semantics of the matched input stream are carried over to the output stream .

It should also be understood that the present invention may be implemented in various forms of hardware software firmware special purpose processors or a combination thereof. In one embodiment the present invention may be implemented in software as an application program tangibly embodied on a program storage device e.g. magnetic floppy disk RAM CD ROM DVD ROM and flash memory . The application program may be uploaded to and executed by a machine comprising any suitable architecture.

It is to be further understood that because some of the constituent system components and method steps depicted in the accompanying figures may be implemented in software the actual connections between the system components or the process steps may differ depending on the manner in which the present invention is programmed. Given the teachings of the present invention provided herein one of ordinary skill in the art will be able to contemplate these and similar implementations or configurations of the present invention.

It should also be understood that the above description is only representative of illustrative embodiments. For the convenience of the reader the above description has focused on a representative sample of possible embodiments a sample that is illustrative of the principles of the invention. The description has not attempted to exhaustively enumerate all possible variations. That alternative embodiments may not have been presented for a specific portion of the invention or that further undescribed alternatives may be available for a portion is not to be considered a disclaimer of those alternate embodiments. Other applications and embodiments can be implemented without departing from the spirit and scope of the present invention.

It is therefore intended that the invention not be limited to the specifically described embodiments because numerous permutations and combinations of the above and implementations involving non inventive substitutions for the above can be created but the invention is to be defined in accordance with the claims that follow. It can be appreciated that many of those undescribed embodiments are within the literal scope of the following claims and that others are equivalent.

