---

title: Method and system for wrapping and componentizing javascript centric widgets using java components
abstract: A method and system for providing a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets includes receiving a request for a widget to be rendered on the client by a client runtime component. The request includes a tag that defines a plurality of tag attributes. The tag and the tag attributes distinctly identify the widget. The request is forwarded to the server that identifies the widget and a plurality of component resources associated with the widget based on the tag attributes received from the client. A JavaScript wrapper code is generated to wrap the widget and the associated plurality of component resources. The wrapped widget and components are forwarded to the client for rendering. The wrapped widgets are rendered at an HTML page during the initial HTML page load based on the information provided by the associated component resources. The rendering of the components enables the component resources to be evaluated in the global scope of the HTML page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08150939&OS=08150939&RS=08150939
owner: Oracle America, Inc.
number: 08150939
owner_city: Redwood City
owner_country: US
publication_date: 20070511
---
The present invention relates generally to client server computing systems and more particularly to a method and system for providing a wrapper framework for componentizing JavaScript centric widgets.

Widgets are small interactive web applications that run on a browser window. A widget is a short form for Windows gadgets. Widgets are installed on a client and provide interactive graphical user interface GUI . The widgets provide visual information and easy access to frequently used functions. Some of the functions that these widgets provide include news aggregators calculators weather forecasts interactive maps clock and stock quotes. These widgets provide a way to multitask and are relatively easy to develop. The early widgets such as Confabulators were strictly desk top widgets and did not have the ability to access the internet. Current day widgets including mobile widgets that are designed for mobile devices have the capability to access the internet and provide access to resources available on the internet.

The modern day widgets use scripting language such as Java and Tool Command Language TCL on a server to interact with and render graphics on a graphical user interface running on a client. Most if not all applications that are developed today using Java TCL or other scripting languages come equipped with a ready made library of widget components that a programmer can incorporate into a widget application and customize. Each of the widget application developed by a programmer will include components that describe what a particular widget looks like how it behaves and how it interacts in response to user actions. To incorporate one or more components into a widget application on the client a programmer needs to have working knowledge of the various components so that the programmer will know which components need to be included in the application. Some of these components could be supplied by an external service and the programmer will have to have a knowledge of the existing Application Programming Interfaces APIs in order to access those components. As more components and APIs are made available the widget application development becomes more complex.

There is therefore a need for uniformly componentizing various components that define each widget so that the programmers are exposed to the same set of relevant components when defining a widget application. There is also a need to simplify and standardize the widget application development process so as to minimize the development time for creating new widgets. There is also a need to make these widgets reusable so that programmers do not have to program and re program the same set of widget applications.

The present invention fills the need by providing a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets. The framework includes a client runtime component on the client. The client runtime component includes a tag that identifies a widget to be rendered on the client. The tag defines a plurality of tag attributes that distinctly identify the widget. The client runtime component is configured to load the widget when a HTML page initially loads on the client. The widget is identified on the server based on the plurality of tag attributes the identified widget is associated with a plurality of component resources. A JavaScript wrapper code is generated for the identified widget and the associated plurality of component resources. The wrapped component resources for the identified widget are forwarded to the client in response to the request for widget resources from the client. The plurality of component resources are rendered at the client during the HTML page load or based on an event on the HTML page. The rendered widget is based on information provided by the associated plurality of component resources through the identified widget s tag. The associated component resources define the behavior and style of the resources that make up the widget.

In one embodiment a method for providing a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets is disclosed. The method includes receiving a request for a widget at the client. The request includes a tag that identifies a widget to be rendered on the client. The tag defines a plurality of tag attributes that distinctly identify the widget. The widget is identified on the server based on the plurality of tag attributes the identified widget is associated with a plurality of component resources. The plurality of component resources for the identified widget is wrapped using a JavaScript wrapper code and forwarded to the client in response to the request. The widget is configured to render on the client during the HTML page load or based on an event on the HTML page based on information provided by the associated plurality of component resources through the tag. The associated component resources define the behavior and style of the widget.

In another embodiment a system for providing a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets is disclosed. The system includes a widget model and a client runtime component CRC on the client and a server runtime component SRC on the server. The widget model on the client provides a component model for the widget and includes a plurality of component resources that define behavior and style of a widget so that the widget can be accessed by other components available at the client. The CRC on the client includes a tag having a plurality of tag attributes that identifies the widget to be rendered on the client. The CRC is configured to forward a request for widget resources to the server using tag attributes receive a plurality of component resources associated with the widget from the server verify the correctness of the plurality of component resources received from the server render the widget on the client and link a plurality of widgets on the client. The SRC on the server is configured to interface with the CRC on the client. The SRC is further configured to identify the widget and associated plurality of component resources at the server using tag attributes forwarded by the client track and wrap the plurality of component resources associated with the widget available to the server and serialize data in the plurality of component resources such that the proper data associated with the plurality of component resources are forwarded to the client.

The present invention thus describes a method and system for providing a JavaScript wrapper framework for componentizing JavaScript centric widgets divided between a client and a server. The embodiments of the present invention include providing runtime components on the client and the server so that the component resources can be efficiently componentized and uniformly made available to all users. The framework thus provides a reusable widget thereby simplifying and standardizing widget creation.

The present invention provides a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets. The wrapper framework provides logic on the client that is used to interact with server side logic to dynamically identify a plurality of components associated with a widget generate JavaScript code to wrap the widget and the associated component resources and render the components on the client during an HTML page load or based on an event on the HTML page. The generated JavaScript code wrapping the widget with the appropriate component resources may be stored in a widget library on the server so as to enables one to re use the widget without having to independently develop the widget. Moreover the widget development is more structured and organized so that each widget when rendered at the client use the appropriate component resources. The wrapping of the widgets can be customized to allow the same widgets to be rendered multiple times on the HTML page without conflicts when referring to the respective widget s component resources.

Several embodiments for providing a JavaScript wrapper framework for componentizing JavaScript centric widgets are described. It should be appreciated that the present invention can be implemented in different ways such as a system or a method. It will be apparent to those skilled in the art that the present invention may be practiced without some or all of the specific details set forth herein.

To facilitate an understanding of the embodiments a basic widget model associated with a widget rendered at the client will be described first. The process of the disclosed embodiments will then be described with reference to the basic model. In the current application browser browser client and client are used interchangeably to refer to a client in a client server computing system. A client is a computer or computing device that runs client software referred to as a browser to access the Internet and render content.

In order to facilitate creation and or rendering of a widget on the client a JavaScript wrapper framework a jMaki framework is provided. The jMaki framework includes JavaScript to define a wrapper code for a widget to be rendered on the client. JavaScript is a client side and server side scripting language used mainly within a HTML page to create interactive pages. JavaScript is a platform independent algorithm that can run on most any basic hardware and software platforms. Thus JavaScript is not dependent on any specific hardware and will run on any computer with a Java Virtual Machine software. The jMaki framework includes a client side component and a server side component. The client side component and server side components further include a plurality of components. The components within the client side component include a widget model and client runtime component. The server side component includes a server runtime component and a generic proxy component.

A basic widget model associated with a widget rendered on a client is illustrated in as a jMaki widget . The jMaki widget provides a component model for the widget and is essentially made up of re usable JavaScript components. The three core components that define the jMaki widget include a HTML template component a JavaScript initialization and configuration code component and a Style sheet component . The HTML component defines the content of the widget the JavaScript component defines the behavior of the widget and the Style sheet component defines the style of the widget s display. The JavaScript component contains JavaScript code that is used to wrap the widget and the various component resources of the widget together handle user initiated events generated by the widget and interacts with the server side component using an asynchronous JavaScript and XML AJAX mechanism. The widget model structure described herein can be used in creating a new widget or wrap existing widgets from any toolkit available to the client.

In addition to the three core components the widget model may include a widget JavaScript Object Notation JSON component as illustrated in . The JSON component describes the widget s attributes and the format of the data that the widget can accept from external services through a toolkit interface. The widget defined on a client may include component resources that access one or more external services. The jMaki framework provides the wrapper code for the widget so that the widget may be interact with external services through the respective toolkit interfaces such as Dojo toolkit Yahoo User Interface UI Scriptaculous interface Google UI Spry UI Prototype and some native widget toolkits. Although the commonly used toolkits have been identified in this embodiment other toolkits that provide widget components may also be used.

In addition to the widget model the client includes a client side services component to access and interact with internal and external services for obtaining component resources for defining and for pre defined widgets. The client side services component includes application program interfaces APIs to interface with internal and external services located either in a same web domain as an application executing on the client that is requesting a widget or on different web domains. illustrates sample client side APIs that allow the widget to interface with internal services located within a single domain available at the client. The client side services are provided as a means of communication between various widgets available at the client.

The client side services component includes an XMLHttpRequest XHR API to request and receive resources through an asynchronous JavaScript and XML AJAX mechanism a publish subscribe mechanism API that facilitates inter widget communication by allowing a widget to register and publish an event for the widget defined by a topic so that other widgets can subscribe to the topic an Injector API to bring and load contents including widgets from a separate Uniform Resource Locator URL than the one that the server is residing on. In this embodiment the separate URL is hosted within the same web application domain as the one hosting the application executing on the client. A topic defining a widget is used when publishing or subscribing to an event associated with the widget so as to allow anonymity of the actual widgets during inter widget communication. The events to the topic may be published based on a user action or based on an automatic timer mechanism. The subscription to the events may be based on what is published. The client side services component also includes a Glue timer API that allows defining widget application behavior and ties widgets together using JavaScript actions when a specific event is published to a topic. The Glue timer API is mostly used with the publish subscribe mechanism API .

The client side component also includes a jMaki client runtime component . The client runtime component is responsible for bootstrapping widgets and passing widget related information received from the server to the appropriate widgets on the client. In one embodiment the communication between the server and the client is through AJAX mechanism. The client runtime component ensures that the widget related information such as input attributes is unique for each widget and each of the widgets is passed only the appropriate widget related information. The client runtime component also ensures that the properties of each widget components are uniformly shared among other widget components available at the client. Thus the embodiments of the invention define reusable components that are defined and shared amongst widgets available on the client.

The server side components include a jMaki server runtime component and a generic proxy component as illustrated in . The jMaki server runtime component ties the jMaki client runtime component with the server through a server side interface such as a Java servlets or servlets developed in other scripting languages such as PHP Hypertext Preprocessor PHP or Phobos. The server runtime component identifies and tracks the corresponding component resources that make up the widget based on one or more input attributes received from the client. The input attributes from the client define a type of widget requesting component resources which is then used to identify the widget available to the server. When a widget is first created on the server a plurality of component resources are first identified at the server wrapped using JavaScript wrapper code and stored in a library. A plurality of widget libraries may be available to the server. The input attributes received from the client provide the keys to uniquely identify the widget library available to the server in which the widget resources are stored. In this embodiment the widget and the corresponding widget components are hosted on a single domain. The widget libraries are organized such that each widget and its associated component resources can be uniquely identified. The widget libraries may use a directory file structure to store the component resources for each widget. The input attribute such as a name attribute may be used to map to the appropriate directory on the server that contains the component resources for the specific widget. The directory structure is organized in such a way as to distinguish one widget s resources from another widget s resources. In one embodiment the directory for the various widgets on the server is a resource directory and the resource directory structure is explained in greater detail with reference to further below.

Referring back to the server runtime component includes a plurality of sub components that are used in identifying configuring linking converting and wrapping the various component resources associated with the widget into a server side widget for rendering at the client. The component resources that make up the server side widget may include objects from various resources. The various resources from which the component resources are obtained are identified as enterprise resources in . The enterprise resources include service resources database resources managed object resources and web service resources. The web service resources in this embodiment include resources that are hosted in the same web application domain as the one hosting the application executing on the client.

The widgets on the client may require access to external services that are outside the web application domain. In such cases the client is equipped with an Asynchronous JavaScript and XML AJAX mechanism to enable asynchronous communication between the widget on the client and the external services. In this embodiment the server is equipped with a generic proxy component generic proxy such as an XMLHttpProxy component to interact with the external services as illustrated in . The generic proxy on the server receives the AJAX request from the client and interacts with the external service on the client s behalf. The generic proxy in addition to interacting with the external services is configured to interact with other server side components such as the servlets and the server runtime component. The generic proxy may be developed using JavaScript code or may be developed using other scripting languages.

The generic proxy is also configured to perform data conversions so that varied data formats received from the external services are restricted. In order to address the data format restrictions the generic proxy is endowed with a transformer such as an XSL transformer as shown in . As mentioned the external services may include component resources that may be defined in different standards than the component resources defined within the web application domain. In such cases the generic proxy engages the XSL transformer to transform the format of one or more component resources to a format that is acceptable to the widget so that the widgets can access these component resources in a uniform way. For example the external services may include component resources encoded in extensible markup language XML standard. In this case an extensible stylesheet language XSL is used to describe how the XML styled component resources have to be formatted and transformed. A XSL transformer available to the generic proxy provides an XSL to JSON transformation so that the transformed components defining the widget can be accessed by the client.

Although a specific format transformer has been specified in this embodiment the transformer is not restricted to XSL formatted components but can be extended to other format transformations. Further this transformer may be customized to suit the specific widget requirements. The generic proxy XMLHttproxy component thus allows an AJAX enabled client to access external services outside the web application domain such as Representation State Transfer RESTful web services that provide Rich Site Summary RSS feeds Yahoo Geocoding service and Flickr image searches to name a few.

In order to allow the widget to access external services the input attributes include one or more API keys that were originally provided to the client by an external service during an initial request from the client. In this embodiment the external service resources are identified using the API keys. The API keys may be generic to a particular external service or may be specific to a particular widget resource. The API keys allow the various widget applications to use a single configuration in a configuration file to reliably access the same external services. The various widget applications receive appropriate component resources associated with the widgets from the external services based on the input attributes passed in the request.

The server side components include the server side runtime service component and a generic proxy component . The server runtime component ties the jMaki client runtime component with the server side interface and identifies and tracks the corresponding component resources that make up the widget based on one or more input attributes received from the client. The widget component resources are gathered and wrapped using JavaScript code into a JavaServer Phase custom tag handler or JavaServer Faces component and stored in a widget library. A library of widgets as explained earlier may be available to a server and include instances of these custom wrapped widget components so they can be re used. For widgets that are not part of the library and having component resources that are not wrapped using the JavaScript code new component resources are defined by wrapping the existing component resources with JavaScript code. These newly wrapped component resources may be stored in the library of widget components available to the server under the specific widget so they can be re used. The generic proxy component interacts with other server side components and external services and performs data conversions so that varied data formats received from the external services are restricted.

The server side component includes the server runtime component and a generic proxy component. The server runtime component receives the request and uses the tag input attributes to identify the appropriate widget and the associated component resources for the widget available to the client. If the request is for component resources that are hosted on the same domain as the web application the server runtime component looks to a widget library resident on or available to the server to identify the relevant component resources. If the identified resources are found in the widget library links to the resource component are defined and wrapped together by the server runtime component and forwarded to the client for rendering. In the embodiment where the request from the client is an asynchronous request the response from the server runtime component is asynchronous in the form of an XMLHttpResponse.

A default widget resource directory is maintained at the server to include default component resources for each of the widgets accessible by the client. In the case where the widget component resources are not located in the appropriate widget library of the server the server runtime component uses the default widget resource directory to identify the appropriate default resource components. The identified default resource component links are then wrapped and forwarded to the client as a response to the request.

In one embodiment the widget request from the client may include request for component resources from external services that are outside the web application domain of the application executing on the client. In this embodiment the request from the client is sent to the server as an XMLHttpRequest. The server receives the request through an XMLHttpProxyServlet as illustrated in . The request is then forwarded to a generic proxy on the server such as an XMLHttpProxy. The XMLHttpProxy uses a HttpClient to access the external service on the client s behalf and receive XML data which is then returned to the XMLHttpProxy. The generic proxy also includes a transformer such as an XSLT transformer to transform the format of the component resources to a format that is acceptable by the client such as a JavaScript Object Notation JSON format. The transformed component resources are forwarded to the XMLHttpProxyServlet instance which interacts with server runtime component to wrap the component resource links and passes the wrapped component resource links back to the client for rendering. The generic proxy provides a way for the application on the client to access external services and acts as a buffer between the external service and the client by eliminating exposure of the client components to the external services thereby avoiding potential security risk. The data conversion component provides a more robust jMaki interface that allows the client to access wide variety of component resources without having restriction on formats.

The life cycle of a JavaScript wrapper framework jMaki widget is illustrated in . The life cycle of the jMaki widget provides a detailed view of how the jMaki widgets are created and initialized. In operation a defined jMaki widget is encountered. A jMaki widget is defined on a HTML page using a JSP tag handler or a JSF component. Other ways of defining the jMaki widget may be used as the present invention is not restricted to a JSP tag or JSF component to define the jMaki widget. The defined jMaki widget is created by adding the required jMaki resources and widget resources for the specific widget to the application that loads the HTML page on the client. The defined jMaki widget may be configured with a variety of properties using a plurality of input attributes on the JSF component or using a JSP tag. The input attributes help in identifying a specific widget defined on the HTML page and may include properties such as name of the component script for the component template for the component style sheet for the component service value associated with each component instance value associated with each component instance arguments and type to specify a library or a set of libraries. The type attribute is used to provide a mapping to the jMaki tag with the appropriate services available to the server through a configuration file.

The tag handler uses the input attributes received from the client to identify a widget defined on the server. The jMaki server side component receives the request from the client through a Java servlet and identifies the widget s component resources including the template and style sheets and forwards links to the identified component resources to the client as illustrated in operations and . The JSP tag handler or the JSF component renders the necessary component resource contents along with proper linkages to the HTML page. A jMaki bootstrapper code is created and rendered to the HTML page and initialized by a JSP tag or a JSF component as shown in operation . The bootstrapper code is written in JavaScript and is used to register load and support the jMaki widgets component resources being rendered at the HTML page. After the component resources for the widget and the jMaki bootstrapper code have been rendered on the page a widget instance for each of the widgets available to the HTML page is registered with the jMaki bootstrapper as shown in operation . Based on an event on the page such as onload the jMaki bootstrapper will go through the various widget instances that are available to the HTML page and initialize each one of the widget instances and render the widgets on the HTML page as shown in operation . Once rendered the HTML page is made available at the client for further event processing as shown in operation . The widgets may depend on additional widgets for rendering one or more component resources associated with the widget. The registering and initializing of the component resources and each of the widgets ensures that the dependencies are also initialized and rendered.

In order for the widgets to uniformly share their resources and to provide a means to respond to jMaki widget events a publish subscribe mechanism maybe used. One or more component resources are configured to publish contents to a particular topic of interest. The application running on the client may subscribe to the topic by adding a listener to a widget event and then subscribing to the event.

In an embodiment where the component resources for the widget are from services either internal or external to the web application domain a configuration file such as a config.json is available to locate a resource directory library for the service to obtain the necessary component resources as illustrated in . The configuration file contains configuration information of the third party libraries including the location API keys global styles associated with a specific library that might be used by the widget on the client. In addition the configuration file will include configuration information of the internal service libraries including the location styles etc. The jMaki framework allows for multiple versions of a library in an application by using version numbers.

With a system and component model explained earlier a method for providing a JavaScript wrapper framework divided between a client and a server for componentizing JavaScript centric widgets will now be described in detail with reference to flow charts illustrated in and . illustrates the process operation involved in providing a JavaScript wrapper framework in one embodiment of the invention. illustrates the client side operation and illustrates the server side operations involved in one embodiment of the invention.

Referring to the method begins with a request for a widget received by a client as illustrated in operation . The request may be caused by an initial HTML page load by an application executing on the client or based on an event on the HTML page. A JavaScript wrapper code for the JavaScript wrapper jMaki framework is encountered and initialized at the client. The request for the widget is received by a client runtime component. The request for the widget includes a tag that identifies the widget to be rendered on the client. The tag defines a plurality of tag attributes received at the client that distinctly identifies the widget. The tag attributes are also referred in this application as input attributes. The client runtime component is configured to load the widget when a HTML page loads on the client or based on an event on the HTML page. The request for the widget is forwarded to the server as illustrated in operation . The request is received at the server by a server runtime component through a Java servlet.

The server runtime component identifies the widget and the associated plurality of component resources available at the server using the input attributes received from the client as illustrated in operation . The component resources are static resources. A JavaScript wrapper code is generated for each of the component resources and for the identified widget and the widget and the associated component resources are wrapped using the JavaScript wrapper code as illustrated in operation . A link to the wrapped widgets and the associated plurality of component resources are forwarded to the client in response to the request as illustrated in operation . The forwarded links to the widget and component resources are received by the client runtime component as illustrated in operation . The widget is rendered at the client during the HTML page load or in response to the event on the HTML page based on information received from the plurality of component resources as illustrated in operation . The process concludes upon rendering of the widget on the client. The associated component resources define the behavior and style of the resources of the widget.

The client side operations will now be described with reference to . The client side operations begin with a request for a widget received at client runtime component on the client as shown in operation . The request may originate from a HTML page during the initial HTML page load or based on an event on the HTML page. The client runtime component will recognize the jMaki widget request and initialize the jMaki bootstrapper code. Upon initialization the jMaki bootstrapper code will be able to initialize each widget instance available at the HTML page for rendering. The request for the widget s component resources is then forwarded to a server as illustrated in operation .

In one embodiment the request is forwarded to a server using an XMLHttpRequest API interfacing with an AJAX mechanism at the client. The client receives a plurality of component resources associated with the requested widget from a server runtime component in response to the initial request from the client as illustrated in operation . In the embodiment where the request is sent as an AJAX request the server runtime component forwards a link to the widget resources to the client as an AJAX response.

Upon receipt of the response the client runtime component verifies to ensure that proper resources from the server for the specific widget have been identified as illustrated in operation . An Injector component associated with client services component parses the original HTML page to obtain a list of component resources that are already rendered on the HTML page. The Injector component then parses the component resources of the specific widget from the server based on the link to determine the type of component resources to be received for the specific widget as illustrated in operation .

Upon identifying the type of component resources to be received the Injector component creates a list of plurality of components for each type of component resource to be received for the widget as illustrated in operation . The Injector then injects the list of components for each type of component in the appropriate location on the HTML page ensuring that each component resources injected into the HTML page is distinct and is in the order they appear in the widget of the HTML page as illustrated in operation . The injection of the component resources enables the component resources to be evaluated in the global scope of the page. The process completes upon rendering the widget on the client as illustrated in operation .

The server side operations will now be described with reference to . The server side process begins when a request for a widget is received from the client as illustrated in operation . The request from the client may include a plurality of input attributes that identify the widget on the server. The input attributes may additionally point to a service that is either internal to a web domain on which an application requesting the widget components is executing on the client or external to the web domain. The input attributes from the client may include the API keys. The API keys are used to identify an appropriate widget library available to the server or to interact with the external service through a generic proxy where the component resources for each corresponding widgets are maintained.

A widget library associated with each widget maybe in a resource directory on the server. The API keys identify the specific widget in the widget library using a type mapping wherein a type attribute identifies the widget type requested. The widget and the corresponding component resources are identified by a server runtime component available at the server using these input attributes as illustrated in operation . The server runtime component includes the JavaScript code to identify the resource components for the widget based on the API keys and other input attributes link the components together and generate a JavaScript wrapper code for the widget and the associated component resources as illustrated in operation . The wrapped component resources may be stored in a library such as a resource directory on the server so that these component resources may be reused. The process concludes when a link to the wrapped components for the identified widget is forwarded to the client in response to the request as illustrated in operation .

By providing a framework that includes client side components and corresponding server side components an effective JavaScript wrapper framework is provided to componentize the JavaScript centric widgets so that they could be rendered on the client. These widgets can be reused without requiring a developer to have in depth knowledge of the JavaScript code or the jMaki code.

The invention is not restricted to the computer system configuration as used in this application. The invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a network.

With the above embodiments in mind it should be understood that the invention may employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

Any of the operations described herein that form part of the invention are useful machine operations. The invention also relates to a device or an apparatus for performing these operations. The apparatus may be specially constructed for the required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

It will be obvious however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

