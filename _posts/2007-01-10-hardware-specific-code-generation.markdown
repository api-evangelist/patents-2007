---

title: Hardware specific code generation
abstract: A computer-implemented method for generating code based on a graphical model may include: translating the graphical model into a graphical model code, the graphical model code including a first graphical model code function; performing a lookup of the first graphical model code function in a hardware specific library, the hardware specific library comprising a plurality of relationships between graphical model code functions and hardware specific functions, where the first graphical model code function is one of the graphical model code functions; obtaining a matched hardware specific function based on the lookup, wherein the matched hardware specific function is one of the hardware specific functions from the hardware specific library; and modifying the graphical model code based on the matched hardware specific function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08015543&OS=08015543&RS=08015543
owner: The MathWorks, Inc.
number: 08015543
owner_city: Natick
owner_country: US
publication_date: 20070110
---
Tools exist for producing computer implemented graphical models. Using the tools models can be created edited and executed within a computing system. These models can then be translated into a high level language program code such as C C Ada Java or Javascript which may then be compiled into an object code or executable code. The object code or executable code can then be run on computing hardware independent of the graphical modeling tools.

Current graphical modeling tools produce program codes that are generic in nature. For example current tools may use program code that compiles or may be precompiled into object code or executable code which can be run on a wide variety of computing hardware. A single program code generated from a graphical model may compile into a single object code that may be run on for example an x086 Intel type processor an AMD type processor and a PowerPC type processor. This generic single program code and the single object code the generic single program code compiles into may not be able to take advantage of specific performance enhancing features of these various processor types because the single program code was generated and compiled to run on all of these processor types.

Single program code compiled into the single object code may not achieve optimal or improvable performance on any computing hardware. Additionally current graphical modeling tools may produce processor specific program code that may use processor optimized function calls inlined assembly code or C C language extensions in order to access the hardware specific optimization capabilities. For example Simulink and Real Time Workshop by The MathWorks Inc. of Natick Mass. hereinafter The MathWorks may provide target specific optimization capabilities for the C90 ISO IEC 9899 1990 and C99 ISO IEC 9899 1999 C language standards as well as the GNU compiler tool chain. Additionally target specific optimizations may be achieved with Simulink and Real Time Workshop by creating a user defined S function block. However these existing approaches may not be configurable customizable or extensible through a documented API. Furthermore their capability may be limited to predefined replacements and are not generally applied across all graphical modeling constructs.

One embodiment includes a computer implemented method for generating code based on a graphical model. The method includes translating the graphical model into a graphical model code the graphical model code including a first graphical model code function performing a lookup of the first graphical model code function in a hardware specific library the hardware specific library comprising a plurality of relationships between graphical model code functions and hardware specific functions where the first graphical model code function is one of the graphical model code functions obtaining a matched hardware specific function based on the lookup wherein the matched hardware specific function is one of the hardware specific functions from the hardware specific library and modifying the graphical model code based on the matched hardware specific function.

One embodiment includes a computer readable medium including software instructions which when executed by a computer system causes the computer system to perform operations for a method for generating code based on a graphical model. The computer readable medium includes instructions for translating the graphical model into a graphical model code the graphical model code including a first graphical model code function instructions for performing a lookup of the first graphical model code function in a hardware specific library the hardware specific library comprising a plurality of relationships between graphical model code functions and hardware specific functions where the first graphical model code function is one of the graphical model code functions instructions for obtaining a matched hardware specific function based on the lookup wherein the matched hardware specific function is one of the hardware specific functions from the hardware specific library and instructions for modifying the graphical model code based on the matched hardware specific function.

One embodiment includes a system for code generation of a graphical model. The system includes means for translating the graphical model into a graphical model code the graphical model code including a first graphical model code function means for performing a lookup of the first graphical model code function in a hardware specific library the hardware specific library comprising a plurality of relationships between graphical model code functions and hardware specific functions where the first graphical model code function is one of the graphical model code functions means for obtaining a matched hardware specific function based on the lookup wherein the matched hardware specific function is one of the hardware specific functions from the hardware specific library and means for modifying the graphical model code based on the matched hardware specific function.

Further features of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings.

A computer may refer to one or more apparatus and or one or more systems that are capable of accepting a structured input processing the structured input according to prescribed rules and producing results of the processing as output. Examples of a computer may include a computer a stationary and or portable computer a computer having a single processor multiple processors or multi core processors which may operate in parallel and or not in parallel a general purpose computer a supercomputer a mainframe a super mini computer a mini computer a workstation a micro computer a server a client an interactive television a web appliance a telecommunications device with interne access a hybrid combination of a computer and an interactive television a portable computer a tablet PC a personal digital assistant PDA a portable telephone application specific hardware to emulate a computer and or software such as for example a digital signal processor DSP a field programmable gate array FPGA an application specific integrated circuit ASIC an application specific instruction set processor ASIP a chip chips or a chip set a System on Chip SoC and a Multiprocessor System on Chip MPSoC an optical computer a quantum computer a biological computer and an apparatus that may accept data may process data in accordance with one or more stored software programs may generate results and typically may include input output storage arithmetic logic and control units.

 Software may refer to prescribed rules to operate a computer. Examples of software may include software code segments instructions applets pre compiled code compiled code computer programs and programmed logic.

A computer readable medium may refer to any storage device used for storing data accessible by a computer. Examples of a computer readable medium may include a magnetic hard disk a floppy disk an optical disk such as a CD ROM and a DVD a magnetic tape a memory chip and or other types of media that can store machine readable instructions thereon.

A computer system may refer to a system having one or more computers where each computer may include a computer readable medium embodying software to operate the computer. Examples of a computer system may include a distributed computer system for processing information via computer systems linked by a network two or more computer systems connected together via a network for transmitting and or receiving information between the computer systems and one or more apparatuses and or one or more systems that may accept data may process data in accordance with one or more stored software programs may generate results and typically may include input output storage arithmetic logic and control units.

A network may refer to a number of computers and associated devices e.g. network devices that may include gateways routers switches firewalls address translators etc. that may be connected by communication facilities. A network may involve permanent connections such as cables or temporary connections such as those that may be made through telephone or other communication links. A network may further include hard wired connections e.g. coaxial cable twisted pair optical fiber waveguides etc. and or wireless connections e.g. radio frequency waveforms free space optical waveforms acoustic waveforms etc. . Examples of a network may include an internet such as the Internet an intranet a local area network LAN a wide area network WAN a metropolitan area network MAN a body area network BAN and a combination of networks such as an internet and an intranet. Exemplary networks may operate with any of a number of protocols such as Internet protocol IP asynchronous transfer mode ATM and or synchronous optical network SONET user datagram protocol UDP IEEE 802.x etc.

A processor may refer to the hardware device such as a microprocessor microcontroller digital signal processor FPGA SoC MPSoC ASIC ASIP graphical processing unit GPU or chip which executes machine instructions contained in object code. A processor may refer to a more specific form of the term computer as it refers to the device within a computer which executes the machine instructions.

A target may refer to a hardware device or software component e.g. an object that may receive information from a sending device or software component. For example a target may refer to a combination that includes a compiler and a processor where the combination can define a high level programming environment. For example a given processor may have specific hardware capabilities such as saturated arithmetic support for which there is no direct mapping to the standard ISO C ANSI C high level language. Compiler vendors may provide library functions callable from C code or may extend the C language by adding custom qualifiers to be used when declaring variables in order to fully leverage the hardware capabilities. Thus given a combination of compiler and processor program code for that specific target environment may be generated using a hardware specific library.

Exemplary embodiments are discussed in detail below. While specific exemplary embodiments are discussed it should be understood that this is done for illustration purposes only. In describing and illustrating the exemplary embodiments specific terminology is employed for the sake of clarity. However the invention is not intended to be limited to the specific terminology so selected. A person skilled in the relevant art will recognize that other components and configurations may be used without parting from the spirit and scope of the invention. It is to be understood that each specific element includes all technical equivalents that operate in a similar manner to accomplish a similar purpose. The examples and embodiments described herein are non limiting examples.

In block a graphical modeling environment may be initiated on a computer . The graphical modeling environment may be based on for example Simulink by The MathWorks Inc. of Natick Mass. hereinafter The MathWorks or Stateflow by The MathWorks. The graphical modeling environment may be an environment in which a graphical model or parts of a graphical model may be executed. Examples of a graphical modeling environment may include Simulink by The MathWorks Inc. Stateflow by The MathWorks SimEvents by The MathWorks SimMechanics by The MathWorks LabView by National Instruments Inc. VisSim by Visual Solutions Inc. Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Gedae by Gedae Inc. Scicos from The French National Institute for Research in Computer Science and Control INRIA aspects of a Unified Modeling Language UML or SysML environment among others. The graphical modeling environment may be an executable modeling environment for a graphical executable model.

In block a graphical model may be generated in the graphical modeling environment . The graphical model may be generated by being for example created in or loaded into the graphical modeling environment . The graphical model may be a model of a system built using block elements corresponding to the graphical modeling environment and may possibly be executed. For example the graphical modeling environment may contain a block element to represent the clutch control system of a car.

The graphical model may include multiple domains such as time based data flow or physics modeling. In one exemplary embodiment the graphical model may include for example text based modeling code finite state machine modeling e.g. statecharts physical systems modeling or UML diagrams such as sequence diagrams and or may operate on top of a text based modeling environment. In another exemplary embodiment the graphical model may have the ability to include code such as for example legacy code provided by the user. Flow may proceed to block or block .

In one exemplary embodiment the graphical model may be a time based block diagram. In one exemplary embodiment the time based block diagram may be executed. In another exemplary embodiment the time based block diagram may be processed before code is generated from the time based block diagram. This processing may include preparing data structures and or evaluating parameters configuring and or propagating block characteristics determining block connectivity performing block reduction and block insertion etc. During the configuration and propagation of block and or port signal characteristics the compiled attributes e.g. dimensions data types complexity sample time etc. of each block e.g. and or ports may be setup on the basis of corresponding functional attributes and or the attributes of blocks and or ports that are connected to the given block through lines.

In one exemplary embodiment attribute setup may be performed through a process during which block functional attributes ripple through the block diagram from one block to the next following signal connectivity referred to herein as propagation . Blocks that are implemented to be compatible with a wide range of attributes may adapt their behavior in accordance with the attributes of the blocks connected to them.

Based on actual block connectivity determined by for example removing blocks that have no functional bearing but only a graphical implication the block diagram may be further modified for example to run faster by performing block reduction and or insertion. During this step blocks may be inserted or a set of blocks may be removed or reduced to a single equivalent block. For example a signal copy block may be automatically inserted in order to make contiguous memory copies of signals that are made up of disjoint memory sections.

The way in which blocks are interconnected in the block diagram may or may not represent an order in which the equations e.g. execution methods corresponding to the individual blocks will be solved e.g. executed . In one exemplary embodiment an actual order may be partially determined during the sorting step performed during compilation.

The first step in sorting may involve transforming the time based block diagram into a compiled e.g. in memory directed graph having for example arcs and vertices. The vertices may be derived from some of the blocks that have a functional bearing. For instance blocks with only a graphical implication and or reduced blocks may not appear in the directed graph. The arcs may represent data dependencies between the vertices and may correspond to the data dependencies in the block diagram. In addition data dependencies may be added to capture implicit dependencies. For example in one exemplary embodiment all inputs to a Function Call subsystem may be implicit data dependencies to the owner e.g. caller block. In another exemplary embodiment a portion of the inputs to a Function Call subsystem may be implicit data dependencies to the owner block. The graph may be used to sort the blocks into a linear sorted list.

Sorting may also take into consideration user specified dependencies between the blocks such as for example priorities and placement groups. A block priority may specify the order in which the equations associated with a block are evaluated with respect to other blocks. Placement groups may be used as a way of causing each class of block execution methods for a specified set of blocks to be placed together in the block method execution lists.

During the linking stage block method execution lists may be derived from the sorted list to allow for execution of the block diagram. Each block method execution list may be a list of block methods that are to be executed in a sequence when each execution method within the list has a sample hit. In multi tasking mode the lists may be further partitioned when block diagrams have blocks with different sample rates.

Those skilled in the art will recognize that while the block method execution lists may be derived from the sorted list the block method execution lists may not necessarily correspond one to one with the sorted lists because some blocks may not have a corresponding method and some block may have an owner block that triggers their execution.

In block a hardware specific library may be selected. The hardware specific library may be selected by selecting from a list of available hardware specific libraries etc. available in the graphical modeling environment . The hardware specific library may be selected through a graphical user interface in the graphical modeling environment or by text based commands entered into the graphical modeling environment . A hardware specific library may be defined for a specific target environment compiler and processor such as for the Texas Instrument Intrinsic library for a TI C28xx processor used with Code Composer Studio or for a specific industry standard interface API such as SAL BLAS or MPLIB or for a programming language standard such as DSP C System C.

The hardware specific library may be directed towards a particular type of computing hardware and may include specific functions . Hardware specific functions may be functions or operations that have been designed to be compiled into object code for execution on a particular type of computing hardware. For example the hardware specific library may contain hardware specific functions created for use on an Intel Dual Core processor. Another hardware specific library may contain hardware specific functions created for use on Transmeta Crusoe processor. Still other hardware specific libraries etc. may contain hardware specific functions created for use on Intel x086 processors AMD type processors PowerPC type processors etc. Hardware specific functions may be functions or operations containing instrumentation code which may allow for data collection.

A hardware specific function may refer to a C or C language function which may be callable from a C or C program. It may also refer to primitive constructs in the programming language such as all standard C or C operators including assignment add subtract multiply divide shift and data type casts. A target environment may have replacements for these standard operators or for C callable functions. These replacements may be for example replacements which run faster on the target. If flow proceeds from block to block flow may proceed to block or block .

The graphical model code function may contain argument data . Argument data may include the number of arguments the data types of arguments and other attributes of the arguments for example the number of bits needed to represent the argument. The attributes for the arguments may also include characteristics that are not present in programming languages such as C or C . For example arguments may be defined as fixed point integers and have attributes such as Slope and Bias or Fraction Length or may be defined as matrices and have corresponding attributes such as Number of Dimensions and Dimensions.

For example referring to the hardware specific library may contain a hardware specific library entry that contains a wildcard. The hardware specific library may also contain a hardware specific library entry with conceptual arguments as discussed below in a hardware specific library entry that may contain a pointer to a dynamic code generator as discussed below in a hardware specific library entry that was generated by a dynamic code generator and a hardware specific library entry that may contain an intermediate representation pattern that may be matched to an intermediate representation translated from the graphical model code .

Each hardware specific library entry may contain a list of various properties of the hardware specific function contained in the hardware specific library entry . For example hardware specific library entry points to list containing the function key name and the function prototype . The function prototype may point to a second list containing further properties of the hardware specific function . For example the prototype points to a second list containing the name of the hardware specific function the location of the file in which the source code for hardware specific function is located and the argument data for each argument of the hardware specific function .

Each argument for a hardware specific function may have its own set of argument data. Argument data for each function may include the various types of data discussed above in . For example argument data contain the name of the argument the data type of the argument and the I O type of the argument. The argument data type may contain further properties relating to the argument data type. For example the argument data type contains the number of bits needed to represent the data type and an indication of whether or not the data type is a signed data type.

In block the graphical modeling environment may translate the graphical model into the graphical model code . The process of translation is used by modeling tools such as Simulink by The MathWorks to create a graphical model code that may be compiled into an executable computer program from a graphical model. The elements that make up the graphical model are represented by graphical model code functions written in a programming language. For example the graphical model code may be for example C or C code translated from the graphical model in which the elements of the graphical model are represented by C or C functions.

The graphical model code for the entire graphical model may be translated before proceeding to block . The graphical model code may be for example an intermediate representation . An intermediate representation may be a representation of a function in a form suitable for optimization by a compiler. For example an intermediate representation may be in the form of a tree such as the intermediate representation used by a C or C compiler. If flow proceeds from block to block flow may proceed to block or block . If the graphical model code for the graphical model has previously been translated and is available for instance when flow proceeds from block to block and to block block may retrieve the graphical model code instead of generating a new graphical model code before proceeding to block .

In block a graphical model code function from the graphical program model code translated from the graphical model may be looked up in the hardware specific library to obtain a hardware specific function . The graphical model code may include a sequence of functions for example C functions. A function in the graphical model code may be referred to as a graphical model code function . The graphical model code function may be looked up in a data structure such as the hardware specific library to determine if a matching hardware specific function exists.

The lookup process may include matching a plurality of properties of the graphical model code function from the graphical model code to properties of a hardware specific library entry . The properties matched by the lookup process may include for example referring to function class function key name function attributes and function argument data including the number of arguments the data type of the function arguments and the attributes of the function arguments among others.

The lookup process in block may be hierarchical such that the properties of a graphical model code function are arranged in hierarchical fashion and then matched with hardware specific library entries according to that hierarchy. For example a graphical model code function may have a hierarchy in which its properties are in the order class key name attributes arguments. When the graphical model code function is looked up in the hardware specific library the hardware specific library may first determine which hardware specific entries in the hardware specific library match the class of the graphical model code function . The hardware specific library may then determine which of those hardware specific entries that match the class of the graphical model code function also match the key name of the graphical model code function and so on until each attribute of the graphical model code function has been used and a matching hardware specific function has either been found or not found.

In block the function from the graphical model code may be selected for matching such as graphical model code function .

In block the hardware specific library may be searched to determine if at least one of the hardware specific library entries in the library contains a hardware specific function that is of the same class as the graphical model function selected in block . If no match is found for the function class flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the set of hardware specific library entries found to be matches in block may be searched to determine if at least one of the hardware specific library entries in the set contains a hardware specific function that matches the key name of the graphical model code function. If no match is found for the function key name flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the set of hardware specific library entries found to be matches in block may be searched to determine if at least one of the hardware specific library entries in the set contains a hardware specific function that has attributes such as for example saturation and rounding mode matching the attributes of the graphical model code function . If no match is found for the function attributes flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the arguments of the function are checked for example in block the set of hardware specific library entries found to be matches in block may be searched to determine if at least one of the hardware specific library entries contains a hardware specific function which has the same number of arguments as the number of the arguments of the graphical model code function . If no match is found for the number of arguments of the graphical model code function flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the set of hardware specific library entries found to be matches in block may be searched to determine if at least one of the hardware specific library entries contains a hardware specific function which has arguments whose data types match the data types of the arguments of the graphical model code function . If no match is found for the argument data types of graphical model code function flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the set of hardware specific library entries found to be matches in block may be searched to determine if at least one of the hardware specific library entries contains a hardware specific function whose arguments have the same attributes as the argument attributes of the graphical model code function . If no match is found for the argument attributes of the graphical model code function flow proceeds to block and ends. If at least one match is found flow proceeds to block .

In block the hardware specific function that matches the graphical model code function may located which provides the answer for the decision in block .

The set of hardware specific library entries may contain a priority value such that multiple similar hardware specific functions may be present in the hardware specific library. The entries may be searched based on priority allowing for a priority hierarchy in the matching process. For example an implementation of a matrix multiply function that runs faster on the target may be available when the arguments operands are matrices of dimensions 3 3. There may additionally be a matrix multiply function which supports matrix arguments of any dimension that runs slower on the target. Setting the priority of the 3 3 matrix multiply functions higher than that of the general matrix multiply the lookup and replacement may choose the more efficient implementation when the arguments are the proper size.

When the arguments are not the proper size to use the most efficient implementation of a hardware specific function a transformation may be performed on the arguments of a graphical code function in order to create arguments of the proper size. For example if the graphical code function has arguments that are 6 6 matrices it may not be directly replaced by the efficient 3 3 matrix multiply function discussed above because the arguments are the wrong size. In this case a transformation may be performed to decompose each 6 6 matrix into 4 3 3 matrices. Operations on the 3 3 matrices may then be performed by the efficient hardware specific function. Hardware specific libraries may be created in a modular way for example including of a base hardware specific library which provides all general hardware functions and additional increasingly specialized hardware specific libraries which may override that base hardware specific library via a priority mechanism.

Likewise weighting values may be supplied that indicate a level of preference for a hardware specific entry to be used for example on a normalized scale. A hardware specific entry with weight 0.8 may be preferred over a hardware specific entry with weight 0.5. This allows comparing combinations of hardware specific entries. For example one combination of hardware specific entries may include a hardware specific entry with weight 0.4 and one hardware specific entry with weight 0.3 whereas an alternative may include one hardware specific entry with weight 0.2 and one with weight 0.9. Depending on the criteria used for selection either one of these may be preferred. For example if a simple mean is used to decide the combination of entries with weight 0.2 and 0.9 would be preferred. If for example minimizing the variance would be preferred the combination of hardware specific entries with weight 0.4 and 0.3 would be preferred. The alternative combinations do not need to include the same number of entities.

Matching during the lookup process may include wildcards by using a hardware specific library entry with a wildcard. The matching process may also include wildcards by applying wildcards to the properties of the graphical model code function for example the key name . The use of wildcards is well known in the art of regular expressions. A wildcard may be shown for example with the use of the i.e. asterisk character or the i.e. question mark character. A wildcard may be added to an attribute in order to allow for non exact matching.

For example a graphical model code function with a key name of cos may have a wildcard on the key name. The wildcard key name cos or cos may match a hardware specific library entry with a function key name of cosine . A wildcard may also be used in the argument attributes for example when performing lookups where arguments represent fixed point integers. The attributes of Slope and Bias may be wildcarded. Matching may also occur on derived properties such as for example net Slope or net Bias as calculated across the arguments and the matching may use wildcards.

For example wildcards may be used to match a specific list of values or ranges of values such as for example net Slope equal to 2or net Bias in the range from 0 to 1. As an additional example the relative value of an attribute across the arguments may be of importance. For example the match function may determine if the Slope value for all arguments is the same. Wildcards may provide a mechanism by which a reduced subset of entries may be needed to match a potentially large number of possible combinations for a given class of function or operation. In the preceding example there may be for example many thousands of possible fixed point scalings of arguments used in a two argument fixed point multiple function. A wildcard may allow for only a single or few entries to be needed to support matching and replacement of this large number of fixed point scalings.

The lookup process in block may perform matching based on the property of conceptual arguments. An entry in the hardware specific library may have associated with it a property of conceptual arguments as well as actual arguments. Conceptual arguments are sets of arguments that may be used to match the argument properties of a function being looked up such that a function may be matched to a hardware specific library entry even if the function arguments do not match exactly with the actual argument properties of the library entry. Conceptual arguments may allow a library entry to match a wider variety of graphical program code function. Conceptual arguments may match a library entry to a function with a different number of arguments than the actual arguments of the entry. Conceptual arguments may match a function with arguments of a different data type than the arguments of the entry. For example the graphical program code may contain a function A double outarg matrix multiply double inarg1 double inarg2 The hardware specific library may contain an entry with a hardware specific function B void matrix multiply double inarg1 real double inarg1 complex double inarg2 real double inarg2 complex double outarg real double outarg complex 

If a lookup is performed in the hardware specific library on the graphical model code function A and the hardware specific library entry does not contain conceptual arguments for the hardware specific function B the lookup may not match the graphical model code function A to any library entry including the entry for the above hardware specific function B. In the case of the above exemplary hardware specific function B the number of arguments does not match between the hardware specific function B and the graphical model code function A. The hardware specific function B has four arguments while the graphical model code function A has only two. If the hardware specific library entry does contain conceptual arguments the lookup may match the graphical model code function A to the library entry for the hardware specific function B if one set of conceptual arguments from the entry matches the arguments from the graphical model code function A. The hardware specific library entry may contain the conceptual argument property double inarg1 real double inarg2 real 

The graphical model code function A may now be matched to the hardware specific library entry containing hardware specific function B because the hardware specific function B has conceptual arguments that match the arguments of the graphical model code function A in number data type and attributes.

The lookup in block may also match the graphical model code function to the hardware specific library entry containing a pointer to a dynamic code generator . This match may occur when the graphical model code function is matched to entry properties which designate it as a function that can be replaced by the dynamic code generator . This match may occur when the graphical model code function fails to match any other entry in the hardware specific library . The dynamic code generator may generate hardware specific functions that may be placed into the graphical model code .

The hardware specific functions generated by the dynamic code generator may also be inserted into the hardware specific library as a new library entry . Additionally the dynamic code generator may recursively access the hardware specific library performing a lookup in order to implement its intended algorithm. For example an entry in the hardware specific library for the hardware specific function such as for example a Fast Fourier Transform FFT may be pointed to by the dynamic code generator to create the function. To implement the FFT algorithm a lookup for a trigonometric function such as cosine may also be required. One skilled in the art will recognize that an arbitrary number of levels of recursive lookups could occur in this manner as well as an arbitrary numbers of lookups occurring at a given level.

A given hardware specific entry or set of entries may also be configured to be pre generated outside of the context of a graphical model code generation session. Additionally the location e.g. directory to which the hardware specific functions should be pre generated may be configured. This may enable separation of the generation of hardware functions from the generation of the graphical model code from a graphical model. This also may allow for example for the qualification activities to proceed on the generated hardware specific functions independent of qualification activities on the graphical model code generated from the graphical model. Additionally a given hardware specific library entry or set of entries may be configured as do not use . This may avoid the use of unqualified functions or functions that are not currently supported in a target environment.

The lookup in block may also be based on an intermediate representation . The graphical model code may be translated into an intermediate representation . Matching may be performed by looking up intermediate representation patterns translated from the graphical model code in the hardware specific library . The hardware specific library entry may contain a property defining which intermediate representation patterns the entry may match.

Referring back to in block if a match for the graphical model code function has been found in the hardware specific library flow proceeds to block . If no match has been found flow proceeds to block .

In block the graphical model code function or intermediate representation may be replaced in the graphical model code with the hardware specific function from the entry in the hardware specific library that the graphical model code function matched. The replacement of graphical model code functions or intermediate representations with hardware specific functions may result in the creation of a replacement graphical model code . The hardware specific function may be placed into the graphical model code itself overwriting the original graphical model code function . The hardware specific function may be translated into an intermediate representation before being placed into the graphical mode program code.

In block if there are more functions in the graphical model code remaining to be looked up flow proceeds back to block . Otherwise flow proceeds to block .

In block traceability lists may be provided for the replacement graphical model code . In an exemplary embodiment two traceability lists of graphical model code functions representing functions that were and were not replaced during the matching and replacement may be displayed. These lists may be referred to as traceability lists . The first traceability list may contain a listing of each function from the graphical model code that was replaced by a hardware specific function from the hardware specific library during the code generation process. The second traceability list may contain a listing of each function from the graphical model code that was not replaced by a hardware specific function from the hardware specific library during the code generation process. These lists may be created during the matching process in blocks and as the results from a lookup of a graphical model code function are recorded once the lookup is complete.

The traceability lists may be provided by for example displaying storing or sending the lists . The traceability lists may be represented in the graphical model by highlighting the blocks for which replacement was done in one color and blocks for which replacement was not done in a different color. Others forms of representing the replacement status of a block in the graphical model may be used such as annotation of the block with a text message or changing the border that defines the block outline. The traceability lists may be displayed separately or they may be displayed intertwined listing each function in the order in which it appears in the graphical model code .

The traceability lists may be stored as file on a computer readable medium of the computer for later retrieval or for use by the graphical modeling environment or another application or environment of the computer . The traceability lists may be sent another to computer or computer system via a network. Reports on the traceability information may also be provided such as percentage replacement. For example a report may contain information that 86 of all addition e.g. operators were replaced with a hardware specific function . Active links such as for example hyperlinks may also be provided from the operator in the generated code to the originating block or blocks in the graphical model for which a replacement was done or not done. Similarly active links may be included in the model to link an element in the model such as for example a block to the related part of the generated code.

Additionally from a graphical model block reports on what hardware specific functions were used by that block may be made available such as for example through a right click context menu or popup menu. In another aspect the hardware specific library and the hardware specific library entries may contain linkage to a requirements management system in order to provide traceability to the originating requirements document for a design.

Additionally the availability of a hardware specific function that may be used as a replacement for graphical model code generated from a specific graphical model block may be indicated by a change in the depiction of the graphical model block in a user interface. For example a graphical model block may be colored green in the user interface to indicate that the current hardware specific library contains a hardware specific function for that graphical model block.

In block the graphical model code function that was replaced in block may be added to the first traceability list . The first traceability list may be a list containing all graphical model code functions that were replaced by hardware specific functions during the code generation process.

In block the graphical model code function for which no match was found in the hardware specific library may be added to the second traceability list . The second traceability list may be a list containing all graphical model code functions that were not replaced by hardware specific functions during the code generations process.

Referring back to a hardware specific library may be created from a documented application programming interface API allowing for extensibility and customization. are a representative example of an API for creating a hardware specific library. Additionally contains a second API example for registering hardware specific libraries with the graphical model .

Referring back to in block another hardware specific library may be selected. If another hardware specific library is selected flow proceeds back to block . Otherwise flow proceeds to block . Another hardware specific library may be selected for example to allow for the graphical model code to be to be run on multiple targets for example different types of computer hardware. Selecting another hardware specific library may result in the production of a second replacement graphical model code .

In block flow ends. A replacement graphical model code which may include hardware specific functions that replaced graphical model code functions and graphical model code functions that were not replaced may replace the graphical model code . In the replacement graphical model code is depicted outside the computer and the modeling environment for illustrative purposes. The replacement graphical model code may also be provided for example by a paper report or by placing the replacement graphical model code on a computer different from the computer with the graphical modeling environment .

In block the graphical modeling environment may translate the graphical model into the graphical model code . The graphical model code may be for example C code. The graphical modeling environment may translate a single graphical model code function from the graphical model based on the current location in the generation process. When block is reached from block block may translate the first graphical model code function from the graphical model . When block is reached from block block may translate subsequent graphical model code functions from the graphical mode .

In block if any of the graphical model remains to be translated into graphical model code functions which may then be looked up in the hardware specific library flow proceeds back to block . Otherwise flow proceeds to block .

Exemplary embodiments may be embodied in many different ways as a software component. For example it may be a stand alone software package or it may be a software package incorporated as a tool in a larger software product such as for example a mathematical analysis product or a statistical analysis product. It may be downloadable from a network for example a website as a stand alone product or as an add in package for installation in an existing software application. It may also be available as a client server software application or as a web enabled software application.

Bus may include one or more interconnects that permit communication among the components of computer . Processor may include any type of processor microprocessor or processing logic that may interpret and execute instructions e.g. a field programmable gate array FPGA . Processor may include a single device e.g. a single core and or a group of devices e.g. multi core . Memory may include a random access memory RAM or another type of dynamic storage device that may store information and instructions for execution by processor . Memory may also be used to store temporary variables or other intermediate information during execution of instructions by processor .

ROM may include a ROM device and or another type of static storage device that may store static information and instructions for processor . Storage device may include a magnetic disk and or optical disk and its corresponding drive for storing information and or instructions. Storage device may include a single storage device or multiple storage devices such as multiple storage devices operating in parallel. Moreover storage device may reside locally on computer and or may be remote with respect to a server and connected thereto via network and or another type of connection such as a dedicated link or channel.

Input device may include any mechanism or combination of mechanisms that permit an operator to input information to computer such as a keyboard a mouse a touch sensitive display device a motion based device a camera such as a webcam a thumb wheel or jog dial a touchpad a joystick a microphone a pen based pointing device and or a biometric input device such as a voice recognition device and or a finger print scanning device. Output device may include any mechanism or combination of mechanisms that outputs information to the operator including a display a printer a speaker etc.

Communication interface may include any transceiver like mechanism that enables computer to communicate with other devices and or systems such as client license manager vendor etc. For example communication interface may include one or more interfaces such as a first interface coupled to network and or a second interface coupled to license manager. Alternatively communication interface may include other mechanisms e.g. a wireless interface for communicating via a network such as a wireless network. In one implementation communication interface may include logic to send code to a destination device such as a target device that can include general purpose hardware e.g. a personal computer form factor dedicated hardware e.g. a digital signal processing DSP device adapted to execute a compiled version of a model or a part of a model etc.

Computer may perform certain functions in response to processor executing software instructions contained in a computer readable medium such as memory . A computer readable medium may be defined as one or more memory devices and or carrier waves. In alternative embodiments hardwired circuitry may be used in place of or in combination with software instructions to implement features consistent with principles of the invention. Thus implementations consistent with principles of the invention are not limited to any specific combination of hardware circuitry and software.

Exemplary implementations may allow for the generation of hardware specific code from a model such as a graphical model. Hardware specific code generated using exemplary embodiments may efficiently use logic features associated with a piece of target hardware onto which the hardware specific code is used.

The foregoing description of exemplary embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example while a series of acts has been described with regard to and the order of the acts may be modified in other implementations consistent with the principles of the invention. Further non dependent acts may be performed in parallel.

In addition implementations consistent with principles of the invention can be implemented using devices and configurations other than those illustrated in the figures and described in the specification without departing from the spirit of the invention. Devices and or components may be added and or removed from the implementations of and depending on specific deployments and or applications. Further disclosed implementations may not be limited to any specific combination of hardware.

Further certain portions of the invention may be implemented as logic that performs one or more functions. This logic may include hardware such as hardwired logic an application specific integrated circuit a field programmable gate array a microprocessor software wetware or any combination of hardware software and wetware.

No element act or instruction used in the description of the invention should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on as used herein is intended to mean based at least in part on unless explicitly stated otherwise.

