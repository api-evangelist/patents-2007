---

title: Synchronization associated duplicate data resolution
abstract: Systems, methods, and data structures associated with the detection and resolution of duplicate data that might result when using multiple synchronization protocols are described. These techniques may use different types of identification data associated with data that is synchronized, as well as a defined set of operations that may be performed by one or more endpoints to identify and remove duplicated data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08751442&OS=08751442&RS=08751442
owner: Microsoft Corporation
number: 08751442
owner_city: Redmond
owner_country: US
publication_date: 20070212
---
As communication endpoints including computing devices are increasingly linked to other endpoints the use of a variety of techniques for synchronizing data between endpoints has become widespread. Synchronization implementations often include functionality to communicate changes to synchronized data to communicate new items to communicate the deletion of items and so on. Synchronization implementations may also include functionality that minimizes the creation of duplicate items on different endpoints at least in certain cases.

Many synchronization implementations operate using a synchronization protocol that defines characteristics like how data is communicated between endpoints which data is communicated and when it is communicated how conflicts are handled when different endpoints modify the same data and so on.

In some cases it may be useful for endpoints to communicate using more than one synchronization protocol. Each synchronization protocol may transfer some or all of the same data but may do so using different operations different types of communication and so on and may provide different benefits. For example one synchronization protocol may make it possible to synchronize particular data between different endpoints used by a single person. As just one example and without limitation such a synchronization protocol might synchronize personal information management PIM data by synchronizing each endpoint with a central server or servers. As a result the single user might be able to access their PIM data on more than one endpoint they might be able to access say their contacts and calendar items on a desktop computer at work on their home computer on their mobile phone and so on. Another exemplary synchronization protocol may make it possible to synchronize the same or other data say in a peer to peer fashion between different users. When used with PIM data this other exemplary synchronization protocol may enable users to share contacts calendar items and so on with other people everyone in the same family might share a set of contacts for example. While both exemplary synchronization protocols may ultimately synchronize some or all of the same data they may do so in different ways.

When more than one synchronization protocol is used to transfer the same data there may be situations where particular pieces of data are transferred perhaps by both synchronization protocols and duplicate data is created. For example while a synchronization protocol may include functionality to minimize the creation of duplicates when data is transferred using just that synchronization protocol the synchronization protocol may not include functionality to avoid creating duplicate data when another synchronization protocol also synchronizes or transfers the same data.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and does not identify key or critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Described herein are various techniques directed toward the reduction or elimination of duplicate data that may result when multiple synchronization protocols are used. These techniques may use different types of identification data associated with data that is synchronized as well as a defined set of operations that may be performed by one or more endpoints to identify and remove duplicated data.

The present invention extends to various techniques directed toward the reduction or elimination of duplicate data that may result when multiple synchronization protocols are used. These techniques may use different types of identification data associated with data that is synchronized as well as a defined set of operations that may be performed by one or more endpoints to identify and remove duplicated data.

Turning now to shown therein is an exemplary system that demonstrates just one environment in which synchronization duplication may occur as well as data and operations that may be used to resolve such duplication. This description of may be made with reference to other figures. However it should be understood that the elements described with reference to are not intended to be limited to being used with the elements described with reference to other figures. In addition while the exemplary diagram in indicates particular elements in some implementations not all of these elements may exist and in some implementations additional elements may exist. Furthermore it should be understood that the exemplary representations of the systems shown in are provided only for purposes of discussion and in no way should be construed as limiting the scope of the techniques described herein to any particular representation or implementation.

The exemplary system may contain an endpoint Z an endpoint A an endpoint B a synchronization session a synchronization session and a synchronization session . In some cases endpoint Z may be associated with an item Z which may in turn be associated with a shared ID . In the same or other implementations endpoint A and endpoint B may have an item AZ and an item BZ respectively which may be associated with an application ID and an application ID as well as with the shared ID in some implementations.

Before discussing how identification data and particular operations may reduce or eliminate duplicate data when multiple synchronization protocols are used it may be useful to introduce at least one situation in which duplicate data may be created without the use of such duplicate reduction operations. In summary and without limitation in one example a new item Z might be created on endpoint Z . The item Z might be synchronized with endpoint A via the synchronization session which might result in the creation of the local item AZ . Similarly item Z might be synchronized with endpoint B this time via the synchronization session and this synchronization might result in the creation of the local item BZ . Until this point no duplicate items may have been created. However now suppose that endpoint A and endpoint B also synchronize data including one or both of item AZ and item BZ using the synchronization session . Also further suppose that the synchronization session uses a different synchronization protocol than the synchronization protocols used perhaps by the synchronization sessions and and perhaps as a result that duplicate detection operations associated with the synchronization protocols used by the synchronization sessions and may not affect the synchronization session . In at least such a case item BZ might be synchronized from endpoint B to endpoint A and this might result in the creation of a new item not shown on endpoint A where the new item is a duplicate of item AZ.

In at least some more detail each endpoint may be associated with a variety of data that may be synchronized using a variety of mechanisms with one or more other endpoints. For example endpoint Z may be associated with a variety of data. Endpoint Z may synchronize some or all of this data with endpoint A . Endpoint Z may also synchronize some or all of this data with endpoint B . The data associated with each endpoint may be located locally on that endpoint for example on disk storage that is part of the same computing device or may be located remotely on one or more types of networked or other remote storage connected via any suitable communication media.

In at least one exemplary implementation a user process some executable code or so on may create an item such as item Z on endpoint Z . While item Z may represent any kind of data again for purposes of example it may be considered to represent say a calendar item. In some implementations for example endpoint Z may be a computer located say at a user s home. Such a user might create an exemplary item Z by using a PIM application to create a new appointment or calendar item. As part of the creation of item Z item Z may be assigned or associated with one or more particular pieces of identifying data such as a number or numbers. For example item Z may be associated with the shared ID which may have the value IDZ. Of course the identifier might be represented using any of a variety of means including numbers globally unique identifiers created using one or more rules for the generation of globally unique identifiers and so on. It should be noted that while some IDs such as the shared ID in some cases and at some times may be shared say between different endpoints that identifiers and IDs do not have to be shared or even when shared at some times do not have to be shared at all times. Furthermore application IDs may in some cases be associated with one or more applications processes or the like but do not have to be associated with such applications processes and so on.

In some exemplary implementations endpoint Z may synchronize data with endpoint A . Endpoint Z and endpoint A may synchronize data using a synchronization session . For example suppose that endpoint Z synchronizes all calendar items with endpoint A. When item Z is created on endpoint Z endpoint Z may use a synchronization session to communicate the new item Z or data associated with the new item Z to endpoint A. The synchronization session may use a variety of synchronization protocols where a synchronization protocol generally defines a set of rules to be followed and data to be communicated during synchronization. For example in one implementation perhaps different than at least some of the previous and subsequent examples endpoint A might include a PIM application such as the Microsoft Outlook application produced by Microsoft Corporation of Redmond Wash. and endpoint Z might comprise a server that includes server PIM functionality associated with instances of the PIM application running on endpoint A such as an instance of Microsoft Exchange Server. In such an example endpoint A and endpoint Z might communicate using synchronization sessions that use a synchronization protocol understood by the PIM application and the server. Such a synchronization protocol may define a variety of information necessary for the endpoints to synchronize data including for example and without limitation when changes should be communicated the underlying networking or communication protocols to be used what data should be communicated at what times and so on.

In another example endpoint A and endpoint Z may be connected through another synchronization protocol including for example the synchronization protocol defined by the Simple Sharing Extensions SSE specification. The SSE specification defines additional data elements and a set of rules that may be used with an existing data interchange protocol like Rich Site Summary Really Simple Syndication RSS or Atom to synchronize data. For example one might publish an RSS Atom or other feed that contains data items. An endpoint or more than one endpoint might subscribe to the feed and be notified when for example new items are added or existing items are changed. In addition a subscribing endpoint might publish its own feed with the same data that is provided in the original publisher s feed and also with changes or additions made by the subscriber. The original publisher might then subscribe to this second feed. Through these mutual subscriptions changes made by either endpoint may be reflected in the data maintained by both endpoints. SSE may also provide other functionality including for example methods for operating with conflicts that can occur for example when multiple endpoints change the same item independently.

It is common for synchronization protocols to use one or more identifying values when synchronizing data. Such values may enable a synchronization protocol to among other things determine data that has been synchronized track data that has changed and has or has not been synchronized and so on. In some cases each item synchronized between endpoints may maintain a single identifying value. This may be the case for example when a synchronization protocol is tied or closely associated with the data being synchronized. As just one specific example when a calendar item is created by a PIM application and synchronized to and from a PIM server using a synchronization protocol defined by or associated with the PIM system as might be the case with Microsoft Outlook and Microsoft Exchange Server for example the synchronization protocol may use an identifying value for each item of data where the identifying value is defined and managed by the PIM system.

In other cases including those where the synchronization protocol in use is not tied or associated specifically with the data being synchronized other additional identifying values may be introduced or used during synchronization. Again as just one example SSE may specify that a unique SSE ID be used for each piece of data synchronized with SSE. If SSE or some other protocol that defines or uses its own or other identifying values is used to synchronize data that already has associated identifying values each piece of data may ultimately be associated with multiple identifying values or IDs.

Returning to the elements of one instance in which multiple IDs may be associated with a single piece of data or item may be illustrated by item AZ that is associated with endpoint A . First before any synchronization with endpoint A or the creation of item AZ item Z may have been created on endpoint Z . Item Z may have been created on endpoint Z as a result of a variety of operations it may have been created locally on endpoint Z it may have been created as a result of synchronizing data from some other endpoint perhaps not shown to endpoint Z and so on. While item Z may be or include any type of data for the purposes of explanation and without limitation item Z may be considered to comprise a calendar item or appointment maintained in a PIM system.

At some point item Z may be synchronized from endpoint Z to endpoint A perhaps using a synchronization session that uses a particular synchronization protocol. The synchronization session may include or transmit a new item instruction that in some implementations includes both item information as well as item metadata. In this context item information may be understood to comprise any information associated with the item that is not item metadata that is it may be understood to comprise any information that is not data about the item data. For example in a calendar item or appointment item information might include a description of the appointment or event the location of the appointment a time or time range associated with the appointment and so on. A single exemplary calendar item might have item information like Doctor Appointment at 123 1Street from 2 00 pm to 3 00 pm. In contrast item metadata may be comprised of information associated with the item like one or more item identifiers that might be for example defined or created when the item is first synchronized when the item is created or at some other time. For example when item Z is created or when item Z is first synchronized item Z may be assigned a shared ID perhaps with the value IDZ. In some cases both item information and item metadata may be simply considered to be item data and a division between types of data may not be useful. It should also be noted that a new item instruction may not necessarily refer to an item that an endpoint has never received before and may not necessarily result in the creation of a new item on a recipient endpoint. For example with some synchronization protocols particular or perhaps all items may be included in each synchronization session and for example a recipient endpoint may determine if any of the items are new or need to be created on the recipient endpoint.

When endpoint A receives the new item instruction it may perform a variety of operations as part of determining if a new item should be created locally and if so the data that the new local item should use. For example the synchronization protocol used in the synchronization session may specify that endpoint A should only create a new item locally if it does not already have a local item with the same shared ID that is communicated as part of the new item instruction. In this example if endpoint A receives a new item instruction for item Z that includes a shared ID value of IDZ it may examine its own local data to determine if it already has an item with a shared ID that has a value of IDZ. If it already has an item with a shared ID value of IDZ it may not create a new item.

In contrast in this example if endpoint A does not have an item with the shared ID value of IDZ it may use some or all of the item information and possibly the item metadata communicated as part of the synchronization session to create a new local item. Such a new local item may be represented by item AZ and may be for example a calendar item that has the same item information like Doctor Appointment and so on as previously explained . In some cases item AZ may have its own application ID such as application ID with the value IDA. This may be the case as just one example and without limitation when the endpoint maintains its data separate in some manner from the synchronization protocol from which the new item was created. For example endpoint A might maintain calendar items using a PIM application and the PIM application s associated data store. When it receives new calendar items as part of a synchronization session that uses a synchronization protocol that is for example not closely associated with the PIM application it may create new calendar items using for example a local application programming interface API provided by the PIM application. In such an example the PIM application may not have any specific knowledge of the synchronization session synchronization protocol or from where the calendar item information was defined or provided. As a result the PIM application may assign its own or another ID to the new item. Such an ID in this example might be represented by the application ID that in this example has a value of IDA. 

In some implementations including those that do not perform duplicate detection as described herein the shared ID that was provided for example as part of the new item instruction may not be saved after an item is created. However as will be explained below in more detail the shared ID may be useful for resolving synchronization duplication and therefore or for other reasons may in some implementations be saved when a new item is created. The manner in which the shared ID may be saved may vary depending on a variety of factors including the manner in which the new item is created. For example some PIM applications may provide the ability to store arbitrary additional data with items maintained by the PIM application. In such a case the shared ID may be stored directly with the new item. In another case the shared ID may be stored in some data structure or store that is separate from the new item. For example the shared ID may be stored in a database or in memory data structure like a hash table indexed by or linked to the application ID of the new item. With such an arrangement of data the shared ID for a particular item may be determined by looking up the application ID of the item and retrieving the associated shared ID.

Continuing with the example that will ultimately demonstrate one manner in which duplicate items might be created as well as how the existence of such duplicate items might be resolved consider that endpoint B may also synchronize data perhaps including calendar items with endpoint Z . At some point after the new item Z exists on endpoint Z it may be synchronized perhaps using the synchronization session with endpoint B. In just one example and without limitation suppose that the synchronization session uses the same synchronization protocol as the synchronization session and as a result item BZ is created locally on endpoint B in the same or similar fashion as item AZ was created on endpoint A . As such item BZ may have its own application ID this time with a value of IDB. In this example both item AZ and item BZ were created locally on their own endpoint as part of synchronizing with endpoint Z and so may each have their own different application ID even though they are conceptually the same item may have the same item information and so on. In implementations where the shared ID may be stored or associated with local items both item AZ and item BZ may have the same shared ID as both items were created after synchronizing the item Z .

Now consider a third synchronization session that synchronizes data perhaps in this example including calendar items between endpoint A and endpoint B . In this example the synchronization session may use a different synchronization protocol than the synchronization protocol used by the synchronization session and the synchronization session . For example the synchronization session may use a protocol that is associated with the data stored by endpoint A and endpoint B. In this example with calendar items the synchronization protocol might be a synchronization protocol for the PIM applications in use on endpoint A and endpoint B. Such a synchronization protocol may operate directly between endpoint A and endpoint B may operate using one or more intermediary servers that are not shown or may operate in some other topology. 

In a specific but non limiting example suppose that endpoint A is configured to receive all new changed or deleted calendar items that exist on endpoint B using the synchronization session . At some point after item BZ is created on endpoint B item BZ will be synchronized with endpoint A. In this case as introduced previously the synchronization protocol may be different than the synchronization protocol previously used to synchronize the item from endpoint Z. This synchronization protocol for example may have no inherent knowledge of the shared IDs that may or may not be associated with item AZ and item BZ. Instead it may only use for example the application IDs associated with the items. As part of this synchronization endpoint A may receive a new item instruction from endpoint B. Then as part of processing this new item instruction endpoint A may determine if it already has an item with the same application ID as the incoming item BZ with application ID and if so may determine that it already has the item that is the subject of the new item instruction. However in this case while both item AZ and item BZ have been created as a result of the existence of the same item Z and both items may have the same item information their application IDs are different. As a result endpoint A may determine that it does not have item BZ already because it does not have an item with an application ID that has the value IDB. As a result endpoint A may create a new local item. Ultimately endpoint A may have two local items when it should only have one it may have item AZ that it created using the synchronization session and another item based on item BZ that it created using the synchronization session .

However this problem may be resolved and only a single item may remain through additional processing. For example and in summary as part of processing a new item instruction and in addition to examining the application ID of the incoming item endpoint A might also examine the shared ID of the incoming item. If endpoint A already has an item with the same shared ID as the item that is being communicated as part of a synchronization session regardless of the new item s application ID it may also consider that the item is actually a duplicate item. In the case where items have the same shared ID additional processing may be performed so that only a single item is kept and items are not duplicated. Some examples of such additional processing are provided below with reference to .

Such additional processing and the operations described to resolve a duplicate detected in a manner like this may not be a part of the normal synchronization processing that an endpoint might perform. That is the additional processing necessary to detect and resolve duplicate items when multiple synchronization protocols are used may not generally be part of the normal processing defined for a particular synchronization protocol. In such cases the additional processing may be integrated or used with the endpoint using a variety of integration means. For example as introduced previously when endpoint A synchronizes with endpoint B it may use a synchronization protocol that is closely associated with the data being transferred with a PIM application for example. Such a synchronization protocol may have no specific knowledge of the shared ID information that may be associated with each item and may not know how to use such information. However the PIM application for example may have hooks or other connecting points where additional processing or executable code may be integrated or called. For example a PIM application might define a manner in which additional executable code can be registered so the PIM application calls the additional executable code whenever the PIM application is about to create a new item. In such a case the processing that identifies and resolves duplicates as described previously and also as described below for example with reference to might be registered to be called in such a manner and so might be integrated with the processing that is already part of the implementation of the synchronization protocol.

While in at least one example item Z is communicated between endpoints it should be noted that data may be transmitted in a variety of ways between endpoints that synchronize data. For example when another item is created on endpoint Z another instance of a synchronization session may be created so the new item may be similarly transmitted. In the same or other implementations a single synchronization session may transmit multiple changes. Furthermore if changes on endpoint A are being transmitted to endpoint Z as they might be for example in a bidirectional synchronization relationship then endpoint A might initiate or use a synchronization session to communicate changes to endpoint Z. Furthermore while some specific examples of synchronization protocols have been defined and are used herein for explanatory purposes generally any synchronization protocol may be used to synchronize data. It should also be noted that as used herein phrases like send the item communicate the item between endpoints and so on may not actually refer in at least some implementations to the communication of the item itself. Instead they may refer to for example the communication of at least some data associated with the item where the data is sufficient for the receiving endpoint to be able to recreate the item or use the item in some form.

It should be noted that in this example endpoint Z endpoint A and endpoint B may each be a computing device of any of a variety of types including those described below for example with reference to . Each endpoint may also be embodied in one or more applications running on any of a variety of computing devices of any type. In some cases the different endpoints may be implemented on different computing devices while in other cases more than one endpoint may be implemented on the same computing device for example as separate applications processes or the like .

Turning now to shown therein is an exemplary generalized operational flow including various operations that may be performed when detecting and resolving synchronization duplication. The following description of may be made with reference to other figures. However it should be understood that the operational flow described with reference to is not intended to be limited to being used with the elements described with reference to these other figures. In addition while the exemplary operational flow of indicates a particular order of execution in one or more alternative embodiments the operations may be ordered differently. Furthermore while the exemplary operational flow contains multiple steps it should be recognized that in some implementations at least some of these operations may be combined or executed contemporaneously.

In at least one implementation of operation a new item may be created on some endpoint. In the context of this operational flow this item may be referred to as being created on a remote or parent endpoint at least in the sense that the item may be created on an endpoint that is different than the endpoint that creates a local item as described below. For example a new item may be created on a remote endpoint like endpoint Z described previously with reference to . The new item may be created on the remote endpoint as a result of a variety of actions or operations including when a user creates the new item manually on the remote endpoint when the new item is created on the remote endpoint as a result of some other synchronization performed by the remote endpoint with yet another endpoint and so on.

The item created on the remote endpoint may have item information that is associated with the item. For example if the item is a calendar item or appointment the item information may include a description of the appointment and so on as described previously. Of course the item could hold any kind of information in a variety of formats.

In an exemplary implementation of operation a local endpoint may create a local item that may be associated with the item created on the remote endpoint in operation . For example the local endpoint may synchronize with the remote endpoint and as a result of the new item on the remote endpoint may create its own local copy of the item so that both endpoints are synchronized and have the same items. For example the local item created in this operation may in some cases be analogous to item AZ associated with the endpoint A which might itself be the local endpoint and both described previously with reference to .

As a result of the synchronization between the local and remote endpoints the local item may generally have the same item information as the item on the remote endpoint. If the original item on the remote endpoint was a calendar item with a description of Doctor Appointment the local item would likely have the same description and so on. The local item may also have other data including item metadata where at least some of the data may be different from the corresponding item on the remote endpoint. For example as part of creating the item locally the local item may have been assigned an application ID. Such an application ID might not have been provided during the synchronization request and might therefore be unknown to the remote endpoint. In some implementations such an application ID may be the same as or similar to the application ID of item AZ both described previously with reference to .

The local item may also have or be associated with a shared ID in some fashion. The shared ID may have been created or defined in a variety of ways. For example it might have been assigned perhaps by the remote endpoint to the item synchronized by the remote endpoint. Perhaps as a result if the remote endpoint synchronizes the same remote item with an endpoint that is different from the local endpoint discussed here the shared ID may remain the same. The local item may in some cases store the shared ID directly while in other cases the shared ID may be associated with the local item in another manner like through the use of a hash or table of application IDs and shared IDs as described previously. In some cases the shared ID may be the same as or similar to the shared ID that is shown as associated with item AZ both of .

In an exemplary implementation of operation a synchronization session may be initiated. Such a synchronization session may occur between the local endpoint introduced previously in operation and some other endpoint that is different from the remote endpoint and might use a different type of synchronization protocol than the synchronization protocol that might have been used for example when the local item was created in operation . In just one example the synchronization session of operation may be the same as or similar to the synchronization session of which occurs between endpoint A and endpoint B both also of .

In at least one exemplary implementation of operation it is determined if the synchronization session initiated in operation is complete. In this context a synchronization session may be determined to be complete in a variety of ways depending on characteristics like the nature of the synchronization protocol. As just one example as defined by the synchronization protocol a remote endpoint might provide a list of one or more items that may be new have changes or may be deleted. As a result each iteration of particular operations in this operational flow such as operation operation operation operation and operation may operate on one such item. When all of the items in the list have been processed the synchronization session may be complete. When other synchronization protocols are used the synchronization session may be determined to be complete based on other criteria. Regardless of the criteria when the synchronization session is complete the operational flow may end. If the synchronization session is not complete and additional items may need to be processed for example then the operational flow may proceed to operation .

In at least some implementations of operation it may be determined if the item being processed is a new item. The determination of whether the item is a new item may be relevant because for example in some cases duplicate items are not created as a result of instructions that are not related to creating new items. That is duplicate items may not in some cases be created as part of changing existing items or deleting existing items. In such cases or in at least some other cases if the item being processed is not considered to be a new item the operational flow may proceed to operation where another item in a list of items that are part of the synchronization session may be identified or the synchronization session may end. In contrast if the item is or may be a new item and so duplicate detection and processing may be useful the operational flow may proceed to operation .

In an exemplary implementation of operation it may be determined if the item being processed is a duplicate of another item that already exists on the local endpoint. While a variety of existing synchronization protocols may perform operations to detect and resolve duplicates this operation may specifically use existing identifying data like the shared ID to detect duplicates. Specifically in this operation the application ID of the local item and the corresponding application ID of the item being considered or processed as part of the synchronization may not be used. Instead the local endpoint may execute code that identifies the shared ID of the item being presented and determines if it is the same as any shared ID associated with an item that already exists locally. This may detect a duplicate that would not otherwise be detected during a normal synchronization session in the same way that has been described previously with reference to . If the item being considered as part of the synchronization session is identified as a duplicate because it has the same shared ID as an item that already exists locally the operational flow may proceed to operation . Otherwise the operational flow may proceed to operation where another item in a list of items that are part of the synchronization session may be identified or the synchronization session may end.

In an exemplary implementation of operation one of the duplicate items may be selected as the item to keep. The item that is not selected may then in some implementations be deleted in a subsequent operation. This operation may be performed when a local item and an incoming item presented as part of a synchronization session have been identified as being duplicates as previously described. This operation may then choose or select one of either the local item or the incoming item as the item to keep and then select the other item as the item not to keep. Both items may be determined in a variety of manners. For example in one implementation the application IDs of both items which again may be different if they have been created for example on separate endpoints as has been previously described may be sorted in some fashion like through the use a normal alphanumeric sort and the item to keep may be determined to be the item that has the higher or lower application ID value. For example item AZ of has an application ID with a value of IDA and item BZ also of has an application ID with a value of IDB. If item AZ is the local item and item BZ is the incoming item and their application IDs are sorted alphanumerically item BZ might be determined to be the item to keep because its application ID has a greater alphanumeric sort value than the application ID of item AZ.

Regardless of the specific steps used to determine an item to keep and an item not to keep it may in some implementations be important that the steps be designed so that their execution always produces the same result regardless of at least some other factors including for example and without limitation the point in time at which the steps are executed on what endpoint the steps are executed and so on. Without a guarantee of such deterministic behavior different endpoints might choose for example different items to keep and not to keep which might result in unpredictable or possibly undesirable behavior such as item deletions that are not desired.

In an at least one implementation of operation changes that might be associated with the item that was selected as the item not to keep may be considered and possibly applied merged or changed on the item to keep. This operation may be performed to avoid losing information or data on an item that is going to be deleted. For example one case in which a change might be applied or merged might be where the item not to keep has been changed and has at least some information that is different from the original item from which both the item to keep and item not to keep were created. In such a case without any further processing these changes may be lost when the item not to keep is deleted. To avoid this occurrence if possible it may be desirable to update the item to keep in some fashion so that it also reflects the changes that exist on the item not to keep. It should be noted that updating the item to keep may not always be desirable or possible. This might be the case in just one example when both the item to keep and the item not to keep have been updated after they were created based on the original item and the changes exist to the same parts of the item information or are mutually exclusive. In such a case some changes may be lost or the conflict between the changes may be handled or processed in some other fashion.

Finally in an exemplary implementation of operation a delete command may be sent to delete the item that was selected as the item not to keep in operation . When this item is deleted only a single item may remain and the duplicate situation detected in operation may be resolved. Depending on particular factors like the nature of the synchronization protocol or protocols in use the manner in which the delete command is sent may be different and might ultimately result in a variety of actions. For example in some cases the item not to keep may be deleted locally and such a local deletion may then be synchronized as part of this synchronization session or as part of a later synchronization session to other endpoints. Because multiple endpoints may perform duplicate detection and resolution processing before such a later synchronization the synchronization protocols or applications may need to be robust in the face of deletion commands for items that have already been deleted.

Turning now to this figure and the related discussion are intended to provide a brief and general description of an exemplary computing environment in which the various technologies described herein may be implemented. Although not required the technologies are described herein at least in part in the general context of computer executable instructions such as program modules that are executed by a controller processor personal computer or other computing device such as the computing device illustrated in .

Generally program modules include routines programs objects components user interfaces data structures and so on that perform particular tasks display particular information or implement particular abstract data types. Operations performed by the program modules have been described previously with the aid of one or more block diagrams and operational flowcharts.

Those skilled in the art can implement the description block diagrams and operational flows in the form of computer executable instructions which may be embodied in one or more forms of computer readable media. As used herein computer readable media may be any media that can store or embody information that is encoded in a form that can be accessed and understood by a computer. Typical forms of computer readable media include without limitation both volatile and nonvolatile memory data storage devices including removable and or non removable media and communications media.

Communication media embodies computer readable information in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communications media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

The computing device illustrated in in its most basic configuration includes at least one processing unit and memory . In some implementations the computing device may implement all or part of for example a computer system that might provide a communication endpoint like the endpoint Z endpoint A or endpoint B described previously with respect to . In some implementations the processing unit may be a general purpose central processing unit CPU as exists for example on a variety of computers including desktop and laptop computers. Depending on the exact configuration and type of computing device the memory may be volatile such as RAM non volatile such as ROM flash memory and so on or some combination of the two. This most basic configuration is illustrated in by dashed line . Additionally the computing device may also have additional features and functionality. For example the computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by the removable storage and the non removable storage .

The computing device may also contain one or more communications connection s that allow the computing device to communicate with other devices and services. For example the computing device might have one or more connections to other computing devices and use such connections to transmit or receive synchronization data as described previously with reference to and to . The computing device may also have one or more input device s such as an image input devices like cameras or scanners keyboards mice pens voice input devices including microphone arrays touch input devices and so on. One or more output device s such as a display speakers printer and so on may also be included in the computing device .

Those skilled in the art will appreciate that the technologies described herein may be practiced with computing devices other than the computing device illustrated in . For example and without limitation the technologies described herein may likewise be practiced in hand held devices including mobile telephones and PDAs multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Each of these computing devices may be described at some level of detail by the system of or may be described differently.

The technologies described herein may also be implemented in distributed computing environments where operations are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote devices.

While described herein as being implemented in software it will further be appreciated that the technologies described herein may alternatively be implemented all or in part as hardware firmware or various combinations of software hardware and or firmware.

Although some particular implementations of methods and systems have been illustrated in the accompanying drawings and described in the foregoing text it will be understood that the methods and systems shown and described are not limited to the particular implementations described but are capable of numerous rearrangements modifications and substitutions without departing from the spirit set forth and defined by the following claims.

