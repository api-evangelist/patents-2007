---

title: File system and methods for performing file create and open operations with efficient storage allocation
abstract: A client computer system of a cluster may send a request to create a file in a cluster file system. A server may create a file in response to the information and allocate space in a storage to the file. If a request to write to the file is received within a predetermined amount of time, the write may complete without requiring that additional operations be performed to allocate space to the file. If a write to the file is not received within the predetermined amount of time, the space allocated to the file when it was created may be de-allocated. The file system may additionally or alternatively perform a method for opening a file while delaying an associated truncation of space allocated to the file. If a request to write to the file is received within a predetermined amount of time, the write may be performed in the space already allocated to the file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07797357&OS=07797357&RS=07797357
owner: Symantec Operating Corporation
number: 07797357
owner_city: Mountain View
owner_country: US
publication_date: 20070228
---
This application is a continuation of U.S. patent application Ser. No. 10 735 088 entitled FILE SYSTEM AND METHODS FOR PERFORMING FILE CREATE AND OPEN OPERATIONS WITH EFFICIENT STORAGE ALLOCATION filed on Dec. 12 2003 now U.S. Pat. No. 7 188 128 which is hereby incorporated by reference in its entirety.

Various computer systems are often coupled to one or more networks in a given environment. These computer systems may need to share data storage or computing power beyond each computer system s individual capacity. Thus with the growing needs for additional computing power and storage by sharing the resources of each computer system cluster technology is an increasing focus of research and development. One of these important resources is shared data storage.

A cluster may be constructed from a plurality of computer systems coupled to a network. The computer systems that are included in the cluster are referred to as nodes and the network that couples the nodes is often termed a cluster interconnect. However merely coupling a plurality of computers to a network does not constitute a cluster. Each node of the cluster must run clustering software to unify each node s otherwise independent operation. By the unification of otherwise independent operation it is possible to increase computing power and increase amounts of data storage available.

Typically with computer systems the storage and retrieval of data often involves using a file system associated with the operating system. A file system may include a collection of management structures which impose a logical and or systematized structure upon a storage medium.

A cluster file system is a form of file system that may allow a plurality of nodes of a cluster to simultaneously access the same storage medium such as a storage area network SAN . Typically one or more server nodes access the storage medium directly. Server nodes using a cluster file system may provide access to the storage medium as a shared data storage to client nodes. Each client node using the cluster file system may view the shared data storage as a local resource.

A cluster file system is dynamic in function and may include data structures in the shared data storage as well as in other memory mediums associated with the servers and clients. A data structure including user data may be considered a file or regular file . The file may store the user data in a space of the shared data storage. Other data structures may organize internal data referred to as metadata of the cluster file system. Metadata may include information about files file identity allocated space and or de allocated space of the cluster file system.

Often nodes include a local cache of the metadata or a local status of the metadata. Typically one of the server nodes handles metadata updates and is responsible for coordinating accesses by the various nodes such that integrity and accuracy of the metadata including local caches of the metadata and or local statuses of the metadata are maintained. Since the nodes only share the shared data storage and not a local memory medium a significant amount of communication between the nodes may take place to correctly synchronize updates to the user data metadata and or local statuses of the metadata in the cluster file system. Such updates may be required when various cluster file system operations including creating files allocating space to files de allocating space from files and or deleting files are performed.

For example a software program may issue a request to create a file in the cluster file system. The creation of a file in the cluster file system may require communication and or synchronization of metadata and or metadata updates between the nodes. After the file is created the software program may subsequently issue a command to store user data in the file. The cluster file system may respond by allocating a space in the shared data storage to the file. However such space allocation by the cluster file system may require additional communication and or synchronization of metadata and or metadata updates between the nodes. After space has been allocated to the file the software program may store the desired user data in the file. The multiple communication and synchronization operations of the cluster file system between nodes as described in this example may add undesirable latency and limit performance.

Likewise a software program may overwrite a file by first truncating it while opening the file. Common examples are file editors that write a file after changes and compilers that write object files when generated. Thus when the cluster file system opens the file the space associated with the file is de allocated. Similar to the foregoing this de allocation of space may require communication and or synchronization between the various nodes. Following this when the software program stores data in the file the cluster file system allocates new space to the file thus requiring additional communication and or synchronization between the nodes. Undesirable latency may thus be introduced and performance may be adversely affected.

One embodiment of a cluster file system may perform a method for pre allocating space in a storage for a file in response to a request message including information to create a file. A client computer system of a cluster may send the request message to a server of the cluster. The cluster file system functionality within the server may create a file in response to the information and allocate space in a storage to the file. The server may send a response message to the client which may include information indicating the creation of the file and or space allocated to the file. The creation of the file and the allocation of space may occur within an atomic transaction that is coordinated and or synchronized with various nodes of the cluster. In one particular embodiment if a request to write to the file is received within a predetermined amount of time the write may complete without requiring that additional operations be performed to allocate space to the file. If a request to write to the file is not received within the predetermined amount of time the space allocated to the file when it was created may be de allocated.

In another embodiment a file system may perform a method for opening or truncating a file with space allocated to the file and delaying an associated storage de allocation operation. If a request to write to the file is received within a predetermined amount of time the write may be performed in the space already allocated to the file. On the other hand if a request to write to the file is not received prior to expiration of the predetermined amount of time the space allocated to the file may be de allocated.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

As shown the cluster of includes a set of interconnected computer systems sometimes called nodes . More particularly one or more servers are shown coupled to a storage such as a storage area network SAN . One or more clients may access storage through servers .

Each server and each client may be coupled to a network . The network may include a wired network a wireless network or a combination of wired and wireless networks. For example the network may be a standard wired Ethernet network which connects one or more of clients to one or more of servers . The network may also include a wireless network based on IEEE 802.11 IEEE 802.15 IEEE 802.16 etc. The network may be or be coupled to any of various local area networks LANs or wide area networks WANs including the Internet.

Each server may be coupled to a common storage interconnect CSI such as a fibre channel hub or an Ethernet network switch. One or more storage devices may be coupled to CSI by SCSI small computer system interface IEEE 1394 universal serial bus USB Ethernet fibre channel and or any combinations of these among others. Some embodiments of storage devices may include a non volatile memory such as a magnetic media e.g. a hard drive a floppy drive or optical storage and or a permanent memory e.g. a CD ROM. Storage devices may include other types of memory as well and or combinations thereof such as a redundant array of independent drives RAD and or a JBOD just a bunch of drives configuration.

For cluster computing software technology may also be necessary. In one embodiment cluster may utilize a shared data model where storage devices can be accessed by more than one server at the same time. The servers may synchronize access to data so they may avoid interfering with each other s operations. According to one embodiment this shared data model is embodied by various components and functions of a cluster file system CFS which is illustratively shown distributed across the nodes of cluster .

In general cluster file system provides shared file access from multiple nodes of a cluster. Cluster file system may support various well known file system functions as desired. For example in one embodiment cluster file system may incorporate features of the Veritas SANPoint Foundation Suite .

Metadata may include various indexes or data structures such as file indexes and free space indexes . In the depiction file indexes are associated with files respectively. Free space indexes may be associated with available space that is not currently allocated such as file data spaces and . Generally metadata is considered internal data of CFS .

In one embodiment each file index may include a file pointer. The file pointer may identify a file associated with the file index. For example file pointers identify files respectively. Additionally a file index may include a file data pointer. The file data pointer may associate a file with one or more file data spaces. For example a file data pointer may associate file index with file data spaces and . Similarly a file data pointer may associate file data space . Moreover a free space pointer may associate a free space index with a file data space. For example free space pointer associates free space index with file data space and free space pointer associates free space index with file data space

Various file system operations may require updates to metadata . For example a software program may issue a command to create a file in CFS . CFS may respond with a cluster file system operation to create a file which may include creating a file and associating the file with an available file index such as for example file index . File index may be associated with the file by updating file pointer such that it identifies the newly created file. Thus metadata is updated when a file is created.

Similarly when the software program issues a command to store user data in the file a file data space may need to be allocated to the file before the user data may be stored. Accordingly CFS may respond with a cluster file system operation to allocate space to the file which may include for example disassociating the file data space from free space index and associating file data space with file index . This may include updating free space pointer and file data pointer

The software program may likewise issue a command to de allocate space of file . CFS may respond for example by disassociating file data space from file index and associating file data space with free space index . This may include updating file data pointer and free space pointer

Still further the software program may issue a command to delete a file such as file . CFS may respond by de allocating space of file as described above and disassociating file from file index . This may include updating file pointer

In one embodiment one of the server nodes handles updates to metadata of CFS . However the other nodes of cluster may include a local cache or local status of metadata . Accordingly when changes or updates to metadata are required the CFS functionality within the server node may coordinate and or synchronize these operations between the nodes to ensure coherency and to ensure that access conflicts do not occur.

Following in block the client may send the request message to a server . The request message may be sent through network . The server may receive the request message in block . Next the server may perform the metadata updates within a transaction as shown in block .

According to one embodiment the transaction performed in block may include a set of interrelated operations that may cause changes to the metadata of CFS in a way that is atomic consistent and isolated. Furthermore in some embodiments the transaction may be synchronized between the various nodes of cluster .

In one embodiment the transaction may be implemented using a transaction manager that keeps track of transactions as they execute. Before the beginning of the sequence of operations within a transaction a call of transaction start may be issued to the transaction manager. Similarly after the sequence of operations has completed a call of transaction commit may be issued to the transaction manager. The atomicity of the transaction may be controlled by the call of transaction commit. If there is a failure within the system before the call of transaction commit the transaction may not affect the state of the system. If the transaction cannot be completed for other reasons a call of transaction abort may be issued to the transaction manager. The transaction abort call may nullify or mitigate any effects of the transaction.

When the transaction is completed the server may send the results of the transaction in a response message to the client as shown in block . The response message may be sent through network . The client may receive the response message in block . Next in block the CFS functionality within the client may update its local metadata status with information included in the response message. Finally the client may release the cluster wide lock as shown in block .

Thus at block a server may receive the request for a file to be created in CFS . Following in block in response to receiving the request CFS both creates the file and additionally allocates a predetermined amount of space e.g. of a storage device to the file. The CFS of the server may send a response message back to the client including information identifying the allocated space. It is noted that the specific amount of space e.g. the number of file data spaces allocated to the file in response to the request may be a fixed size. In other embodiments the amount of space allocated in block may be programmable and or set to a desired amount by for example a user or software program. An application programming interface API may be provided for this purpose.

If a predetermined amount of time has not transpired block the software program may issue a write command to store data to the file as shown in block . If adequate space is contained in the file to accommodate the write the client may perform the write. It is noted that client may use its local metadata status for this determination. If additional space needs to be allocated the CFS of the client may send a request to server to cause CFS to allocate additional space to the file in block .

On the other hand if the predetermined amount of time has transpired prior to receipt of a write command as determined in block the space allocated to the file is de allocated by CFS block . It is noted that the predetermined amount of time as determined in block may be a fixed amount of time. In other embodiments the predetermined amount of time may be programmable and or set to a desired amount of time by for example a user or software program. CFS may include an application programming interface API that may allow a software program to set the predetermined amount of time for an individual file. Further the API may allow a software program to communicate to CFS that the space allocated in block should be de allocated by CFS prior to expiration of the predetermined amount of time if needed.

In accordance with the cluster file system operations as illustrated in and described above since space may be allocated to a file at the same time the file is created updates to metadata corresponding to both the creation of the file and the allocation of the space to the file may involve only a single transaction as described above in conjunction with . When the client performs a subsequent write to the file an additional update to the metadata and the corresponding operations of may be avoided. Accordingly latency associated with space allocation may be reduced as well as messaging traffic between the clients and server. Additionally CPU consumption within for example the server may be reduced thus resulting in overall improved performance.

It is further noted that the method for creating a file and preallocating space in a storage to the file as described above in conjunction with may be implemented within other file systems of a client server environment. In addition it is noted that the method may be applied to other types of files. For example the method may preallocate space when creating files such as directories named pipes device special files and or local socket as well.

Next at block a server receives the request in block and the server opens the file in CFS . CFS does not however immediately de allocate the space from the file. For example the file may be a file that includes file data spaces and as illustrated in . Rather than de allocating the file data spaces which would require a metadata update e.g. and the associated update operations depicted in CFS preserves the space already allocated to the file.

Following at block a flag which may form a portion of metadata associated with the file may be set. The flag may indicate that file space is allocated to the file but beyond the file size. CFS may include additional functionality to periodically check such flags and reclaim space associated with the file if the file is not written to for a given period of time. In this manner unnecessary allocation of space to a given file may be avoided.

As illustrated in following the operations of for a given file a predetermined amount of time transpires without receipt of a write request to the file as determined in block CFS de allocates the space of the file in block . It is noted that the predetermined amount of time as determined in block may be a fixed amount of time. In other embodiments the predetermined amount of time may be programmable and or set to a desired amount of time by for example a user or software program. CFS may include an application programming interface API that may allow a software program to set the predetermined amount of time for an individual file. It is also noted that in one embodiment the operations of may be performed only for files in which a flag from block is set. Following the truncation operation of block the associated flag may be cleared.

When a write command is received the functionality of may be performed. As shown in block the software program may issue the write request to store data to the file. Subsequently the CFS functionality in the client may determine if space is available to the file to accommodate the write as shown in block . The client may use its local metadata status for this determination. Since the space that was previously allocated to the file was preserved the method may proceed to block in which the software program may write the data to the file. Thus in this instance since the space preserved in the file is sufficient to accommodate the write the overhead of truncation during the initial open operation is avoided as well as the need to allocate the space in response to the write request. It is noted that if the space preserved within the file is not sufficient to accommodate the write as determined in block additional space may be allocated to the file in block . Following the allocation operation the flag from block associated with the file may be cleared.

In various other embodiments the delayed de allocation functionality as depicted in may be performed in response to a truncation request rather than in response to an open request . For example a software program may explicitly issue a request for space of a file to be truncated. The truncation request may include information requesting CFS to de allocate a portion of the space allocated to the file or to de allocate all the space allocated to the file. The method illustrated in may be used to delay de allocation in response to such truncation requests.

It is also noted that the functionality as depicted in may be performed selectively on a file by file basis. CFS may include an API for this purpose. For example in one embodiment the API may be used to allow a software program to set information which may form a portion of metadata such as a flag for each associated file to selectively cause the functionality of to be performed.

In addition in other embodiments functionality similar to that of may be performed by a file system that is not specifically a cluster file system. For example the functionality of may be performed by a file system in other client server environments. Likewise in other embodiments a method for opening a file and preserving space to the file in a manner similar to that described may be employed within a local file system of a single computer system.

One or more of the systems described above such as client server common storage interconnect and storage may include a memory medium on which operating systems software programs file systems or data may be stored. For example each of the clients and or the servers may store a data structure as described above comprising information regarding metadata or data of a part of the cluster file system . Each of the clients and or the servers may further store computer executable instructions for implementing CFS .

The term memory medium is intended to include various types of memory or storage including an installation medium e.g. a CD ROM or floppy disks a random access memory or computer system memory such as DRAM SRAM EDO RAM Rambus RAM NVRAM EPROM EEPROM flash memory etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory medium may comprise other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer system in which the programs are executed or may be located in a second different computer system which connects to the first computer over a network. In the latter instance the second computer system provides the program instructions to the first computer system for execution. The memory medium may also be a distributed memory medium e.g. for security reasons where a portion of the data is stored on one memory medium and the remaining portion of the data may be stored on a different memory medium. Also the memory medium may be one of the networks to which the current network is coupled e.g. a SAN Storage Area Network .

Also each of the computer systems described above may take various forms including a personal computer system mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system or other device. In general the term computer system can be broadly defined to encompass any device having a processor which executes instructions from a memory medium.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

