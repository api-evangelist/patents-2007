---

title: Bitmap-based display remoting
abstract: Bitmap transfer-based display remoting by a server coupled to a client is described. Specifically, an application executing on the server implements operations to render a portion of a graphical user interface (GUI). The server decomposes corresponding rendering-based command(s) into simple bitmap raster operations commands. The server sends the bitmap-based commands to the client. The client, responsive to receiving the commands, respectively stores and draws bitmaps from an offscreen display surface, as directed by the server, to an onscreen display surface to present the GUI portion to a user. Logic at the client to store and present the GUI portion are independent of any client-implemented display remoting cache management logic. The client operations are also independent of determinations and processing of graphical object semantics beyond bitmap semantics. Such management and semantic determinations and processing are implemented and maintained respectively at and by the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08140610&OS=08140610&RS=08140610
owner: Microsoft Corporation
number: 08140610
owner_city: Redmond
owner_country: US
publication_date: 20070531
---
Remote Desktop Protocol RDP provides remote display and input capabilities over network connections to terminal server TS based applications. For instance RDP uses its own video driver on the server to render an application s display output to a client device by constructing the rendering information into network packets for communication over a network to the client. Responsive to receiving such network packets the client decodes and interprets the rendering information into corresponding Graphical Device interface GDI Application Programming Interface API calls. GDI is typically associated with a respective portion of an operating system . Such decoding and interpreting generally requires the client to be configured not only to decode RDP which is an extensive interface but also configured to map received rendering information into corresponding GDI calls. Such operations typically require the client to create and maintain multiple different data context dependent caches to use graphical objects such as fonts brushes glyphs fragments etc. in GDI based rendering operations. Because of the complexity of these tasks creating a RDP based client can be very time consuming and labor intensive. Moreover an RDP based client must typically have substantial processing power to implement such operations such processing resources is generally not found on small form factor devices. As a result small form factor devices are not typically used to implement a RDP based client.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In view of the preceding paragraph bitmap transfer based display remoting by a server computing device server coupled to a client computing device client is described. In one aspect an application executing on the server implements operations to render a portion of a GUI. The server translates corresponding rendering based command s e.g. GDI commands etc. into simple bitmap transfer commands. The server sends the bitmap transfer commands to the client. For example in one implementation the server translates a GDI command into one or more bitmap manipulation operational commands raster operations . In one implementation the server implements rendering operations according to the GDI command to obtain operational result s .

The server sends the operational result s to the client as bitmap s in bitmap transfer command s . The client responsive to receiving bitmap transfer commands from the server respectively stores and draws bitmap s from an offscreen display surface as directed by the server to an onscreen display surface to present the GUI portion to a user. In this manner the server uses only bitmap transfer commands without using or depending on any conventional RDP client side remoting logic e.g. cache management determinations and processing of graphical object semantics beyond bitmap semantics etc. to direct and cause the client to remote the application s GUI. Such management and semantic determinations and processing are implemented and maintained respectively at and by the server.

Systems and methods for bitmap transfer based display remoting are described. The systems and methods address the limitations of conventional RDP with a simple bitmap transfer based display remoting protocol SBTDRP . The SBTDRP allows a server that hosts application s to direct and control arbitrary bitmap storing and stored bitmap display at a client to present the GUI of an application executing on the server on the client. Via this direction and control the server abstracts what would otherwise be complex rendering and caching operations at the client into 3 way or 4 way raster operations ROPS between two or more surfaces at the client. The COPY ROP is an example of such operations. Whereas conventional RDP tightly couples client side caching of multitude of different graphical objects with rendering logic in this implementation only the server implements cache management logic e.g. to map where resource bits are stored by the server to the client . These and other aspects of the systems and methods for the SBTDRP are now described in more detail.

Each computing device and respectively includes one or more processors coupled to system memory comprising computer program modules encoded thereon. The computer program modules include instructions executable by respective ones of the processor s . Such system memory also includes program data generated and or used by respective ones of the computer program instructions during program module execution. For example server includes one or more processors coupled to system memory representing volatile random access memory RAM and non volatile read only memory ROM . System memory includes program modules comprising computer program instructions executable by processor s . System memory also includes program data generated and or used by respective ones of the program modules during program module execution.

In this implementation for example program modules include one or more arbitrary applications e.g. a word processor an e mail program a spreadsheet applications and or so on for terminal services based access server side terminal services and other program modules such as an operating system to provide a runtime environment device drivers network communication logic etc. In this implementation for example computer program logic at client includes for example client based terminal services and other program modules such as an operating system drivers network communication logic etc. Server and client terminal services and allow a user of client to establish a terminal services session over network to run one or more arbitrary applications on server to access any combination of files databases network resources etc. Although the executing application s run entirely on server system implements a simple bitmap transfer based display remoting protocol SBTDRP to present elements of the GUI of the executing application s to an end user via display device .

In this implementation for example SBTDRP is implemented by bitmap transfer based display remoting module or logic as part of server side terminal services and client side bitmap store and display logic as part of client side terminal services . SBTDRP allows bitmap transfer based display remoting logic remoting logic of server to direct and control arbitrary bit storage and stored bit display at client to present a GUI of one or more of the server hosted executing applications s to a user. SBTDRP obviates traditional RDP based display remoting operations requiring a client to implement complex caching and rendering logic to implement the extensive RDP. To this end SBTDRP abstracts conventional complex display remoting protocols into simple server controlled bitmap transfer raster operations from to a server purposed offscreen display surface s at client .

In this implementation for example SBTDRP includes the following exemplary commands interfaces or calls CreateSurface SetSurfaceBits TransferSurfaceBits and DestroySurface. This set of commands could be more or less in number being a function of the particular implementation of system . Additionally the particular names provided for the exemplary commands are illustrative designed to convey a respective description of operations associated with each command s respective implementation. Thus these interfaces and their associated operations which are described in detail immediately below can be represented with different named interfaces.

A CreateSurface command is issued by server side remoting logic to direct client side logic to allocate an offscreen display surface of a particular size at a client for server purposed bitmap storage. In this implementation for example parameters for CreateSurface include a unique server supplied identifier ID for client side logic to map to a newly created offscreen display surface and a surface size. In this implementation the surface size is expressed as a bitmap width height and color depth e.g. 8 16 24 32 bits per pixel . The number of bytes is determined from these dimensions by both client and server i.e. the number of bytes is width height color depth in bytes per pixels . Possible color depths can be negotiated in an initial protocol capability exchange. Responsive to receiving a CreateSurface command client side logic allocates the requested surface and maps the server supplied unique surface ID to the newly allocated surface . As described below remoting logic utilizes this ID to refer to this specific allocated surface in subsequent commands .

In one implementation for example and using conventional messaging techniques remoting logic determines a maximum amount of memory that client can utilize for caching arbitrary server purposed bits. Based on this determination remoting logic directs client to allocate at least a subset of the maximum amount of memory as an offscreen display surface . In this scenario remoting logic causes client to allocate an offscreen display surface independent of detecting and or mapping a rendering command call from an application executing on server which is in contrast to conventional RDP based implementations.

Server side remoting logic communicates a SetSurfaceBits command over network to client to direct client side logic to store a set of bits at specific destination locations on an identified client side offscreen display surface . In this implementation for example parameters for SetSurfaceBits include a unique ID identifying the offscreen display surface the set of bits and the destination locations for the bits. In one implementation for example a destination location identifies coordinates for a rectangle expressed in left top right and bottom coordinates. Alternatively a storage rectangle is identified using X Y width and height. In another implementation a destination location identifies coordinates for geometrical object s that are not rectangles e.g. squares circles arbitrary shapes etc. .

Responsive to receiving a SetSurfaceBits command client side logic stores the specified bits to the indicated destination location s on the designated offscreen display surface . As described below at paragraphs 0040 through 0042 see also the set of bits being stored by remoting logic correspond to bits describing a graphical object that may subsequently be used by rendering logic to render one or more aspects of a GUI of an application executing on server . From the perspective of the client however and independent of being bitmap bits the meaning or semantics of these stored bits is of no significance the bitmap has arbitrary meaning and are merely stored onto the offscreen display surface by client side logic as directed by server .

Remoting logic uses the TransferSurfaceBits command to direct client side logic to transfer specific bit s cached in a particular client side offscreen display surface into a different surface e.g. an on screen rendered surface another offscreen surface etc. for presentation by client via display device . In this implementation for example parameters for the TransferSurfaceBits include one or more of the following 

In one implementation failure by client side logic to transfer the bitmap causes client logic to communicate a generic dirty surface notification to remoting logic and thereby notify remoting logic that the surface bits are not valid. In one implementation and responsive to such notification server sends updates to client logic for the invalid surface bits region the updates will make the region valid .

Remoting logic sends a DestroySurface command to direct client side logic to destroy de allocate a server initiated and purposed offscreen display surface . In this implementation parameters for DeleteSurface include for example a unique surface ID to a particular offscreen display surface .

The following examples compare and contrast use of conventional RDP to display an element of a GUI of an application executing on a TS based server on a TS based client to the use of SBTDRP. These examples are illustrative and other sequences of operations graphical objects surfaces and or so on can be substituted without straying from these examples.

Using conventional RDP based logic the following operations are typically required to cache a brush object to a particular location and use the brush object to fill a rectangle in a primary on screen display surface. For purposes of exemplary illustration the brush is a 16 16 pixel brush and the rendering location on the on screen display surface is 0 0 64 16 Representing a surface area encapsulating multiple such brushes.

In contrast to the above example system of utilizes SBTDRP to store a bitmap of the brush onto an offscreen display surface at the client and multiple server initiated bitmap copy commands one command at a time serially to fill in a rectangle on on screen display surface at client . Thus the server decomposes or breaks a more complex rendering command from the application e.g. a GDI command into simpler bitmap transfer commands. One distinction between caching and storing in this context is that to cache an object at client using RDP the RDP based client requires cache management logic to perform the cache operation and to perform the object transfer. In contrast bitmap storage and bitmap transfer on client is completely independent of any cache management at client .

For purposes of exemplary illustration and comparison the brush size is 16 16 bits coordinates of the surface rectangle on the on screen display surface e.g. surface at client are 0 0 64 16 . As in the immediately preceding example it would take multiple rendering operations to fill in the target surface rectangle. Please note that in the previous example the client used GDI to convert the server command into multiple rendering operations to fill in the surface rectangle. In contrast server iteratively communicates multiple transfer surface bit commands to the client to perform the exemplary rendering operation.

Referring to the immediately preceding example using SBTDRP please note that remoting logic iteratively implements the transfer surface bits command in this example four times to fill the specified destination rectangle with the specified brush bitmap. In contrast to conventional systems the simplified protocol implemented by system uses the simple SBTDRP commands for bitmap and brush handling as well as all other operations utilized to display a GUI from an application executing at server onto a display device coupled to a remote client . As a result client is configured to implement simple bitmap surface read and write manipulations to render respective portions of a GUI associated with an application executing a server . That is server breaks down complex graphic rendering commands e.g. like FillRect GDI commands etc. into individual corresponding bitmap raster operations commands. This is in contrast to conventional RDP systems where a client is configured to maintain multiple different graphical object specific caches understand semantic differences between various graphical objects e.g. glyphs brushes bitmaps etc. and often convert RDP rendering commands into corresponding GDI commands e.g. to fill in a rectangle with a brush from a brush cache .

For example and as described above if application generates a GDI command to create a brush graphical object server remoting logic writes a bitmap to a particular offscreen display surface of at client . In another example if the application utilizes the brush graphical object to fill in a portion of the GUI server remoting logic directs client one or more times to transfer the bitmap corresponding to the brush to a particular portion of onscreen display surface to present the GUI portion to user. Such transfer operations include bitmap read and write operations.

Operations of block send the bitmap raster operations commands please see operations of block to client . Operations of block decode by client the received bitmap raster operations commands to respectively store and or draw corresponding bitmaps to onscreen display surface to present the GUI portion to a user. In one implementation the commands may direct client to transfer bitmaps s from one offscreen surface to another offscreen surface before transferring bitmap s to an onscreen surface. Logic at client to store and draw bitmaps to present the GUI portion is are completely independent of client implemented cache management logic. Moreover the client logic is completely independent of any determination and processing of graphical object semantics beyond bitmap semantics. This is in contrast to conventional RDP operations.

Operations of block request by the server the client to store a bitmap to a specific location on the offscreen display surface. In one implementation for example this operation is made responsive to the application requesting a GDI or other graphical interface to create or modify a graphical object e.g. brush glyph bitmap font etc. to render the GUI on the server. In one implementation rendering logic intercepts calls from the application to the GDI. In another implementation for example this operation is performed independent of a request to the GDI. For example the operation can be performed responsive to the client being requested to display something other than GDI output e.g. a black rectangle etc. and or so on. When such a call is associated with creating or modifying a graphical object for rendering the GUI rendering logic requests client side logic to store an arbitrary bitmap representing the graphical object to a specific location on the allocated offscreen display surface . Such a request is made for example by rendering logic communicating a SetSurfaceBits command to client side logic .

Operations of block are responsive to the server intercepting a rendering command from the application wherein the rendering command is associated with a previously created graphical object e.g. a brush a glyph etc. . Techniques such as mirror drivers etc. to intercept rendering commands from specific applications are known . Specifically operations of block cause the server to transmit a command to the client to direct the client to transfer a bitmap corresponding to the previously created graphical object from the offscreen display surface to at least one location on a client side display surface. These operations result in rendering a portion of the GUI for presentation to a user of the client. In one implementation for example operations at block are implemented by rendering logic communicating a TransferSurfaceBits command to client side logic . Receipt of this command by client side logic causes client side logic to transfer of the server specified bitmap to a destination location on a different display surface e.g. an on screen rendered surface . These arbitrary bitmap transfer operations by client side logic result in a portion of the GUI of application which is executing on server to be presented to a user of the client . These and further details of exemplary procedures for bitmap transfer based display remoting are now described in more detail with respect to .

Referring to operations of block direct by a server a client to allocate an offscreen display surface of a specific size for server directed and purposed bitmap storage operations. This direction does not include any information indicating to client that the requested surface will be used for bitmap or any other data storage. In one implementation for example remoting logic of server requests client side logic to indicate a size e.g. maximum default or otherwise that the client can allocate for an offscreen display surface . Responsive to determining the size remoting logic sends a CreateSurface command to client . The CreateSurface command directs client side logic to allocate an offscreen display surface of the indicated size. This communication also includes a server supplied unique ID for the client side logic to associate with the newly allocated offscreen display surface . As described below remoting logic will use this unique ID when directing client side logic to perform bitmap based operations associated with this particular offscreen display surface . In one implementation operations of block are implemented by remoting logic and client side logic as part of initial protocol configuration operations. Operations of block responsive to receiving by client a command to create an offscreen display surface client allocates the offscreen display surface of a particular specified or default size.

Operations of block intercept rendering commands e.g. calls to a GDI to present a GUI of an executing terminal services based application. In one implementation for example remoting logic utilizes a conventional driver to intercept rendering calls from an executing application e.g. to GDI logic etc. to present a GUI associated with executing application . Operations of block determine whether the intercepted rendering command or rendering associated command is to create or modify including a delete destroy command a graphical object e.g. a brush glyph fragment bitmap font etc. or whether the intercepted rendering command is a command to use a particular graphical object to perform a rendering operation e.g. a fill command a draw operation etc. . In one implementation remoting logic makes this determination by parsing the command using known rendering command parsing techniques e.g. GDI command parsing techniques etc. . At block if the intercepted rendering command call is directed to creating or modifying an existing graphical object operations of procedure continue at block of as indicated by a on page reference A . Otherwise if the intercepted rendering call is directed to utilizing a particular graphical object to implement a rendering operation operations of procedure continue at block of page 7 as indicated by a one page reference B . In one implementation the operations of block are implemented by remoting logic of server .

In one implementation for example created or modified graphical object bits in a SetSurfaceBits command indicate for example bitmap size color compression and or so on. Operations to send these bits to the client are completely independent of sending any indication to client of corresponding bit definition or context of the bits. Additionally the specific offscreen display surface specified in the SetSurfaceBits command is a surface that remoting logic identifies with a unique ID. Please recall that in this implementation remoting logic supplied this unique ID to client side logic when the surface was created via CreateSurface command .

Operations of block responsive to receiving a set surface bits command stores arbitrary bits arbitrary from the perspective of client and client logic associated with the set surface bits command into a specified offscreen display surface. In one implementation for example client side logic responsive to receiving a SetSurfaceBits command stores the associated arbitrary bits into the specified offscreen display surface at server specified locations on the surface . In this scenario client is configured to understand that the communicated bits represent a bitmap and the SetSurfaceBits command requests a corresponding bitmap copy or transfer operation. Other than this the configuration of client is completely independent of any need to determine a definition context semantics etc. for the bits communicated in the SetSurfaceBits command . From the perspective of client the received bits merely represent an arbitrary bitmap of unknown semantics being stored at client by remoting logic . Thus client caches the received bits independent of determining any graphical object based semantic. Exemplary determinations of graphical object based semantics include for example logic to determine answers to questions such as do received bits represent a graphical object of some type and if so what type of graphical object For instance do the bits represent a brush a bitmap a glyph a fragment etc. Conventional RDP client implementations perform special processing based on the determined type of graphical object.

Operations of block determine whether the intercepted call was a call to delete a graphical object. If so operations continue at block where it is determined whether the server has any need to maintain bits in a client side a screen display surface. Such a determination is arbitrary and based on the particular implementation of server side remoting logic . For example in one implementation server side remoting logic evaluates local cache to determine whether a client side offscreen display surface associated with the graphical object identified in the call is still useful. Such a determination can be made based on many different arbitrary parameters based on the particular implementation of server side remoting logic .

For instance if the graphical object scheduled by the call for deletion at the server side is the only object with corresponding bits cached in the client side on screen display surface remoting logic may decide to overwrite the corresponding bits with any subsequent cached bits or may request client side logic to delete the surface . In another example consider that remoting logic utilizes one or more offscreen surfaces to cache brushes. When a brush is deleted at server via GDI remoting logic may determine to re purpose the area occupied by the corresponding bitmap cached on a surface at client i.e. the surface bits can be used for something else . Note that the brush bits area on the client side can be managed as one surface per brush or multiple bitmaps representing brushes on a same surface as described in the preceding example. Thus and in one implementation remoting logic may not delete a surface but merely repurpose at least a portion of the associated surface bits.

In view of the above and if deletion of the surface is dictated operations of block cause remoting logic to communicate a DeleteSurface command directing client side logic to delete the particular offscreen display surface . Responsive to receiving such a command client side logic de allocates destroys the identified offscreen display surface .

If operations of block determine that the intercepted call was not a call to delete a graphical object then the call is associated with using a specific graphical object to implement a rendering operation e.g. a draw command a fill command etc. . Thus operations of procedure continue at block . At block a server sends one or more transfer surface bits commands to a client to copy bits from a specific offscreen display surface to locations in a frame display buffer to provide effective results at the client of the intercepted GDI rendering command. In one implementation for example rendering logic sends one or more TransferSurfaceBits commands to client side logic to copy bits from a specific surface to locations in a frame display buffer to provide effective results at client of the intercepted rendering command. The particular bits being copied represented the bits previously cached by rendering logic into the specific offscreen display surface . In one implementation remoting logic maps graphical objects at server to specific client side on screen display surfaces via the unique surface IDs and corresponding source locations at surface using server side cache .

Although the above sections describe bitmap transfer based display remoting in language specific to structural features and or methodological operations or actions the implementations defined in the appended claims are not necessarily limited to the specific features or actions described. For example although operations of procedure please refer to are shown with a particular flow and sequential ordering these operations are exemplary and meant only to be illustrative of one illustrative and exemplary implementation of system . For instance although operations to create a client side off screen display surface are described with respect to block of procedure remoting logic can create as many such offscreen display surfaces as per its particular implementation. For instance after operations of block where a rendering associated call is intercepted another implementation of rendering logic may create another such offscreen display surface as described with respect to blocks and to cache bits for a corresponding graphical object. In view of this procedures and are examples of the many different arbitrary operational flows that could be taken by a particular implementation of system . Thus the specific features and operations for bitmap transfer based display remoting described above are exemplary forms of implementing the claimed subject matter.

