---

title: Method and a system for composing an optimally-grained set of service functions
abstract: Disclosed is a computer program product for managing granularity of a computing infrastructure, wherein the program, when executed on a computer, causes the computer to: identify at least one set of service functions suited to characterization by one or more sets of metrics; create a representation of at least one supplied functionality for the set of service functions for input to a formal process; characterize at least one rule and at least one constraint for input to the formal process; determine at least one set of metrics for evaluating the service functions; quantify benefits associated with at least one of the sets of service functions using the set of metrics; and provide one or more of the sets of service functions as output, wherein the output is based on the metrics determining the output by use of the formal process. Systems and infrastructure are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07882500&OS=07882500&RS=07882500
owner: International Business Machines Corporation
number: 07882500
owner_city: Armonk
owner_country: US
publication_date: 20070102
---
The present disclosure relates generally to information technology systems and in particular to efficient management of service functions and services for providing responsive systems.

As information technology IT has advanced over the past fifty years practitioners have assembled ever more complex collections of function into comprehensive IT solutions. One example of this trend includes an integrated customer management system that includes potential customer identification sales product delivery warranty services follow on sales and an assortment of related information. Traditionally individual systems owned by individual parts of the extended organization addressed the needs for each of these aspects separately. Unfortunately relying on fragmented and separate IT solutions does not provide users with many advantages that should be available with a robust system.

A number of challenges to effective integration of the fragmented and diverse systems exist. For example it is difficult to separate out those functions and capabilities that are common across the extended organization and provide related and meaningful functions for all users across an extended organization. Some terms of art are provided to lend insight into the challenges for design and implementation of a comprehensive IT solution.

 Granularity refers to an amount of computation in relation to communication i.e. a ratio of computation to the amount of communication . A finely grained task is relatively small in terms of code size and execution time. Associated data are frequently transferred among processors in small packages such as a single or only a few words. A coarsely grained task is the opposite data are communicated infrequently after larger amounts of computation.

As used herein the term granular is with regard to processing of complex information entities called information granules. The granules arise in the process of data abstraction and derivation of knowledge from information. Generally information granules are collections of entities that usually originate at the numeric level and are arranged together due to their similarity functional adjacency coherency or the like. Accordingly granular computing is discussed with regard to theories methodologies techniques and tools that make use of information granules in the process of problem solving.

Stated another way granular computing provides for delineation and consideration of those things that serve a specific interest as well as switching those things. By focusing on different levels of granularity one can obtain different levels of knowledge as well as a greater understanding of inherent knowledge structure. Solving the challenges associated with managing granular systems is essential for design and implementation of intelligent systems.

As evidenced by the high failure rate for large IT initiatives the process of designing services that can satisfy a collection of broad and evolving requirements strains the technology for large IT systems.

One key aspect of improving the success rate for building comprehensive services that successfully satisfy the needs of a broad audience is to define the services to be of the right granularity and scope. If the services offered are too fine grained i.e. specific then many service consumers end up revising functional code in order to serve the related business function. If the services are too coarse grained then service consumers may not be able to get the required information or they may need to call a complex and expensive service and throw away all but a small fraction of the results. This leads to high levels of run time inefficiency. On the other hand if the provider offers varieties of both fine grained and coarse grained services the cost of maintaining the services themselves and the complexity of understanding how to manage the services will balloon to unacceptable levels.

A review of the development of comprehensive IT services is now provided. This review considers the various ways in which system designers have attempted to handle the challenges of granular computing.

An early application oriented approach for using services was similar to an application programming interface API . Typically APIs were considered to be fine grained each function or method call being a detail oriented technical construct used by programmers. Many early services implementations performed direct one to one translations of existing APIs into service methods interfaces. Not only did this approach generate large amounts of network traffic but it also required developers to program extensive business logic into the calling system.

Later it became a best practice for experts to recommend that service functions should be coarse grained. This relied upon a premise that services were a resource that would be deployed across the Internet via a slow and unreliable connection. Using a small number of coarse grained messages would reduce the number of transmissions and increase the likelihood that a message would arrive and a transaction would be completed while the connection was still available.

Some architects have recommended using varying granularities. For example service methods for work inside an enterprise having a finer granularity than methods for external interface. Using this approach the fine grained functions interface offer more flexibility to the requester application. However this also means that a service provider will need to satisfy more patterns of interaction with different service requesters and that this can make services support more difficult for the service provider.

One approach has recognized that the granularity of a service is a relative characteristic. What is fine grained for one application is coarse grained for another. Even though a definition of service granularity is derived using several criteria such as the scope of a service and the ability of a service to be useful in higher level services no formal methodology or definition is provided for deciding on service granularity.

Another approach concludes that there is no rule that external services should all be coarse grained while internal services should all be fine grained but that each service should be right grained for its specific task without consideration for the speed of connection. This approach considers that there is no rule that services should all be coarse grained or fine grained. The ideal is that they should be right grained for the specific usage scenario. While this is a clear statement of the problem little is offered to provide guidance as to the right solution.

The forgoing discussion shows that there is an ongoing problem of choosing an appropriate service granularity. Stated more succinctly service owners architects or even an automated service design process do not have a robust technique for taking a defined range of capabilities and offering the capabilities as a collection of services.

Currently when services are designed twenty to forty percent of the development lifecycle is dedicated to design service functions and services. This is because designing services is an iterative process during which the architects and designers model the service functions and services discuss them with end users and developers receive feedback refine the service functions and finally assemble them into services.

While users want highly customized services management wants to minimize the number of service functions developed in order to reduce project costs. The optimal solution is likely to be somewhere in between where the solution provides enough service functions to satisfy customers on one hand and keeps the development costs within budget on the other. The automation of creating an optimal set of service functions will significantly reduce the cost of system development.

In a system that has already gone into operation automation may include the creation of new service functions when needed while preserving or pruning existing functions.

Reducing discussion time between customers architects and developers during the services development process as automation does will lead to savings that can be passed down to users in order to attract price sensitive customers. At the same time preserving existing service functions will provide for retention of existing customers.

What are needed are techniques for managing IT services having a diverse granularity wherein the techniques provide for a range of capabilities and offering of the capabilities as a collection of services.

Embodiments of the invention include a computer program product for managing granularity of a computing infrastructure wherein the program when executed on a computer causes the computer to identify at least one set of service functions suited to characterization by one or more sets of metrics create a representation of at least one supplied functionality for the set of service functions for input to a formal process characterize at least one rule and at least one constraint for input to the formal process determine at least one set of metrics for evaluating the service functions quantify benefits associated with at least one of the sets of service functions using the set of metrics and provide one or more of the sets of service functions as output wherein the output is based on the metrics determining the output by use of the formal process.

The teachings provide the foregoing and other embodiments having advantageous technical effects which include embodiments where the formal process uses a representation of the functionality rules and constraints as input the rules and constraints include at least one of branching expressions boolean expressions and groupings of data elements the at least one set of service functions include at least one of logic data and combinations of logic and data the constraints specify at least one of complexity and cost for one of the service functions the constraints comprises a tolerance coefficient for output data of at least one of the service functions the set of service functions include service functions having diverse granularity the set of service functions have at least one of a business function and an output data object the at least one set of metrics is responsive to a service requester wherein a response to the service requestor is constructed using at least one of connectivity rules a data access matrix and a tolerance coefficient encryption for at least one of the input and the output is included and at least one of the steps of identifying creating characterizing determining quantifying and providing may be repeated as at least one of requirements are modified and additional data elements are created.

Other systems methods and or computer program products according to embodiments will be or become apparent to one with skill in the art upon review of the following drawings and detailed description. It is intended that all such additional systems methods and or computer program products be included within this description be within the scope of the present invention and be protected by the accompanying claims.

The detailed description explains the preferred embodiments of the invention together with advantages and features by way of example with reference to the drawings.

Disclosed are optimization techniques for defining individual capabilities for a set of services. The set of services covers a predetermined range of capabilities. The techniques can be applied to situations in which a service provider is starting from scratch referred to as a green field design or extended to an existing collection of services and thus cover a broader or narrower range of capabilities . In some embodiments the techniques may be applied in support of right grained service functions that are an equivalent for all customers i.e. not customized for any of them .

The teachings herein provide for optimizing a tradeoff between coarse grained and fine grained computing services. The techniques disclosed make use of mathematical processes for optimizing aggregate utility of the computing services. The optimization is performed for service consumers for a given investment by the service provider. As disclosed herein the techniques are illustrated for providing data access services. However the embodiments provided are merely illustrative and are not limiting. For example the teachings may be applied to any collection of requirements that can be quantified in a similar manner by one skilled in the art.

Referring now to an embodiment of a computer processing system for implementing the teachings herein is depicted. System has one or more central processing units processors etc. collectively or generically referred to as processor s . In one embodiment each processor may include a reduced instruction set computer RISC microprocessor. Processors are coupled to system memory and various other components via a system bus . Read only memory ROM is coupled to the system bus and may include a basic input output system BIOS which controls certain basic functions of system .

As disclosed herein the system includes machine readable instructions stored on machine readable media for example the hard disk for managing resources having a plurality of functions and resources of varying granularity. As disclosed herein the instructions are referred to as service granularity software . Typically the service granularity software also referred to simply as software includes instructions as needed for supporting certain aspects of the system and operation in accordance with the teachings herein.

The software may be produced using software development tools as are known in the art. The software may be provided as an add in to an application where add in is taken to mean supplemental program code as is known in the art . In such embodiments the software replaces or supplements structures of another application for managing granularity.

Thus as configured the system includes processing means in the form of processors storage means including system memory and mass storage input means such as keyboard and mouse and output means including speaker and display . In one embodiment a portion of system memory and mass storage collectively store an operating system such as the AIX operating system from IBM Corporation to coordinate the functions of the various components shown in .

Examples of other operating systems supported by the system include versions of Windows Macintosh Java Virtual Machine LINUX and UNIX or other suitable operating systems.

Users of the system can connect to the network through any suitable connection such as standard telephone lines digital subscriber line LAN or WAN links e.g. T1 T3 broadband connections Frame Relay ATM and wireless connections e.g. 802.11 a 802.11 b 802.11 g .

Referring now to aspects of the system having diverse granularity are shown. The system provides a depiction and a context for describing aspects of the terminology used herein. In a plurality of service requestors are denoted as R R R . . . R and a complete set of business level building blocks realizing a set of business functions BFBF BF. . . BF as CC C. . . C where M N . A set of output data objects associated with the building blocks BF is denoted as CDCD CD. . . CD. The union of the output data objects CD is an input vector FF F . . . F for finding an optimal set of output data objects SDSD SD. . . SD associated with the service functions SFSF SF. . . SF where L

If Fis a field of the input vector F then a set of connectivity rules A R among fields for a particular requestor Rcan be conveyed with if then rules such as 

The statement F F indicates that fields Fand Fare a part of any output from a function. The statement F F F indicates that F Fand Fshould always appear together in a function response as a group. A simplified notation for this Boolean expression is provided as group F F F . The connectivity rules for a requestor business function to be used as an input into the system may be defined as 

If a requestor Rneeds Fdata field then the data access matrix field P R F is set to 1 otherwise it is set to 0.

In addition to connectivity rules and data access matrix there exists a requesters tolerance to excessive data in service response which is introduced as a tolerance coefficient tk 0

A response to a requester Ris a subset of data objects SD constructed based on connectivity rules data access matrix and tolerance coefficient.

Given the above a problem of finding an optimal set of service functions SF becomes a problem of finding an optimal number of service data objects SD for given data vector F F F. . . . F data connectivity rules A R and the tolerance coefficient tk.

In an exemplary embodiment a solution to the problem above is provided. First the smallest number of service functions that covers each requestor with respect to all business functions nis computed. Consider the case where the number of requestors is 3 and the number of business functions is 5. If a business function is realized by a separate single service function for each requester then nis equal to 3 5 15.

Then the smallest total number of non customized service function data objects for all requesters nis computed. The smallest total number given to nis 5 since the same business functions are implemented for all requesters.

Finally an optimal number L is determined as somewhere between nand n. The determination can be done by increasing the total number of service data objects from the minimum nup resulting in a progressively bigger number of service data objects per requester. This continues until some reasonable point beyond which no further improvements can be expected.

In other words the number of the service data objects per business function could be used here as a criterion for optimization. The optimization is performed under a number of constraints e.g. related to cost complexity of individual service functions and satisfaction of rules . Furthermore constraints could demand that certain service functions be selected a priori to be a part of the system.

This process is depicted in . Referring to an embodiment for selecting an optimal set of service functions SF is provided. Selecting the optimal set of service functions SF in this example first calls computing the smallest number of service functions that covers each requester with respect to all business functions n . This is followed by determining the smallest total number of non customized service function data objects for all requesters n . Finally determination of the optimal number L between nand nis completed.

In case of applying the teachings to an evolving system additional rules are introduced to preserve existing service functions. Consider the example provided in . illustrates how applying the teachings to an existing system would give additional service data blocks SD. . . SD while retaining existing service data blocks SD SD SD.

An example of the teachings herein is now provided. The example provides a context for introduction of software building blocks SB SB SB. . . SB which provide for a set of service functions SF.

Consider building blocks of the Food Distribution Management System. This is merely one example of a distribution system. The distribution system includes a list of business functions BF BF BF BF BF BF BF such as BF CD CD CD Sales Order for Requestor 1 Customer Representative BF CD CD Sales Order for Requestor 2 Sales Representative BF CD CD CD Sales Order for Requestor 3 Warehouse Manager BF CD CD CD Invoice for Requestor 1 Customer Representative BF CD CD Invoice for Requestor 2 Sales Representative and Requestor 4 Truck driver BF CD CD CD Invoice for Requestor 3 Warehouse Manager BF CD Truck Loading List for Requestor 4 Truck driver .

An entity relationship diagram is provided in . In this example the diagram depicts relationships between the requestors R the business functions BF and service functions SF.

The food distribution management system has the following business building blocks C Sales Itemized Order C Sales Order History Summary C Itemized Invoice C Invoice History Summary C Truck Loading List C Pick Ticket C Account Receivables etc. As provided below each of the building blocks includes a

Consider application of the teachings herein for a company operation as shown in . First consider data objects CDthat are used as inputs for the system. The data objects CDare created based on interest of the requestor Rin particular data. With the requesters Rand data objects CDinputted a Requestor Data matrix Ais generated where n represents a number of requesters and m represents a number of fields in the data vector that is used as an input to find an optimal set of data objects SDassociated with service functions SF. Based on matrix A and given the constraints below an optimal set of service functions is composed. The optimal set can then be assembled into a service or several services. Services interface messages and operations can then be generated based on this optimal set of service functions.

More specifically assume that the tolerance coefficient tk for example is 25 for all three requestors and for all business functions. Accordingly subsets of data fields are defined for each business function BF as follows 

In this example each of the business function vectors BFthrough BF is filtered for repeated fields and then a union vector F is created. In this example the unit vector includes fields for item product name package order quantity ship quantity weight ordered price by weight quantity unit price discount tax cost of goods sold service charge items extended price margin order order date delivery date total quantity total weight ordered cost of goods sold total sale amount profit loss of backlogs total quantity total weight ordered total actual weight total sale amount mark up profit loss delivery date total quantity total ordered weight customer name address order delivery dates delivery memo routing info balance credit limit terms over due last pay last pay day.

Subsequently a Requestor Data matrix Table 1 is created with cells marked for each data field. The number of rows n corresponds to the total number of different requesters. The number of columns m is equal to the number of fields in the union of vectors F i.e. number of fields in the complete data vector .

In a third step some cells in the Requestor Data matrix are marked for exclusion. For example if a requester Ris not granted permission to see the contents based on a permission qualification matrix P . If for example Requestor Ris not supposed to get information about profit a corresponding cell will be marked in the Requestor Data matrix.

In a forth step a set of connectivity rules is created for the fields in the service data object. They are created based on the rules set by the requestors. Global order this indicates that order will be a part of any order .

The last step is to generate service data objects by extracting subsets of fields from the Requestor Data matrix under the given constraints of rules then group them into service functions and check the cost of possible service functions SF SF for the cost constraint. Finally the service functions are associated with service building blocks SB . In this example the service functions SFare 

An exemplary process for managing infrastructure granularity is provided in . In a first step includes creating a Requestor Data matrix A. In a second step cells in the Requestor Data matrix Aare marked for exclusion. In a third step the set of connectivity rules is created for the fields in the service data object. A fourth step of this embodiment calls for generating service data objects SD by extracting subsets of fields from the Requestor Data matrix A under the given constraints of rules then group them into service functions and check the cost of possible service functions SF SF for the cost constraint where the service functions SF are associated with service building blocks SB . In a last step composing an optimal set of service functions is completed. An exemplary embodiment for this last step includes the embodiment for selecting an optimal set of service functions SF provided in .

A mathematical approach to composing an optimally grained set of service functions is now provided. In general deriving a set of optimally grained service functions involves solving of an optimization problem under a number of constraints.

One skilled in the art will recognize that a large number of situations exist or may be realized where the teachings herein may be applied. An exemplary problem is now provided as an illustration of optimization as presented herein. The solution provided is merely illustrative as well as rudimentary and is not limiting of the teachings.

First suppose that each of the service requesters R R . . . R is interested in a respective business function BF BF. . . BF. Each business function BFcalls for gaining access to a certain subset from the complete set of fields F F . . . F A.1 In other words a business function BFis associated with a single building block Cthat provides data CD Subset of F F . . . F.

A service function SFprovides a subset of fields that are generally referred to herein as an output data object or a data object. Every data object satisfies two types of conditions a mandatory field inclusion and a group. For example every data object may be required to include the Product ID field. In addition every data object may be required to satisfy the conditions of type Group Group Group Group A.2 where groups are pre specified and cover all the fields of the complete set provided in A.1 . In addition another condition may be that every field belongs to one and only one group. The set of groups is thus G k 1 2 . . . K . The number of fields in group k is denoted by C. As noted above if a set of fields belongs to a given group k then these fields must appear together in any data object. In other words the groups correspond to disjoint sets covering J fields. This may be expressed as Eq. A.3 

The notation j Gdenotes that the field j is the member of the k th group. In what follows it is assumed that without loss of generality that there are no mandatory inclusion conditions one can see that such conditions lead to the same type of problem but with a reduced number of fields . Under such an assumption the size of the complete set of fields in the above example is J 9 and the number of groups is K 4.

A weight may be associated with every Requestor R. The weights establish priority associated with the needs of the Requestor Rand are represented in the objective function and or constraints of the optimization problem used to obtain an optimally grained set of service functions as will be illustrated later. The weights are denoted by w where i 1 2 . . . I . In some embodiments the weights ware assigned automatically. The automatic assignment may occur for example on the basis of the number of fields in the business function BFcorresponding to this requestor R.

A data object corresponding to a given service function is a collection of fields but it can also be thought of as a collection of groups. Thus constructing a service function SF i.e. data object amounts to specifying the groups that are its members. It may be assumed that associated with each service function SFis a single building block SBthat consists of providing the data SD in the data object. Note however that the building blocks could have been associated with individual groups instead of individual data objects.

Now some constraints on service functions SFare introduced. The constraints will play a role in establishing the graining of the set of service functions. Namely to avoid having complex data objects the total number of fields in each data object should be less or equal to b. This restriction could be related to a cost for implementation of the service function SF for example.

In this embodiment it is considered that the business function BFfor the i th user is covered by a set of data objects i.e. set of service functions if the union of all fields in this set contains all the fields in CD. In principle if a given requestor is interested in more than b fields then the requestor cannot be covered by a single data object.

The basic problem is to establish a set of data objects that covers all the users in some optimally grained way. Any set of data objects that covers all the users is called a feasible set. The overall number of data objects in a given set of interest is denoted by D. These data objects are indexed by d 1 2 . . . D. A given data object d is denoted as ythe variable indicating whether this data object contains the k th group as a member. This is a decision variable y 1 if the k th group is chosen to a member of the d th data object and 0 otherwise. The variables yare defined for all d 1 2 . . . D and k 1 2 . . . K. An immediate set of constraints is related to the maximal number of fields in a data object as provided in Eq. A.4 

One approach to selection of the best feasible set of data objects would be to establish the feasible set having the smallest possible size D. The feasible set having the smallest possible size D is called a minimal set . A size of the minimal set is denoted D this size corresponds to nas introduced above . However such a solution though appealing to the data object designer may not be the best from the perspective of a user. Consider for example a case with six requesters R R . . . R and four fields when the groups correspond to individual fields i.e. G GroupF for k 1 2 3 4 . Suppose that the business functions BF for these requestors can be described by the following 6 4 matrix A 

One embodiment of a mathematical formulation for addressing this problem is provided in Eq. A.6. First consider the set of data objects of interest S having a size D and that every group should be a member of at least one data object. In other words 

Note that the implication of Eq. A.6 is that any group k even one for which no user expressed a need in the demand matrix A should be covered in at least one data object. Furthermore a given group k can be covered by more than one data object. The latter point is important because it can strongly reduce the number of data objects per user. Now consider the requester Rand the number of groups k that are needed to cover this requester denoted by k i as well as the indices of the groups denoted by u u . . . u. So for example if covering the business function BFof the first requestor Rrequires groups k 4 5 and 7 then k i 3 and u 4 u 5 and u 7. In what follows the symbol g is used to index groups k for a given requestor R. So for the i th requester R the indices will be g 1 2 . . . k i . It may be said that the i th requester can be covered by a set of data objects of size D i if a set of indices j 1 j 2 . . . j D i can be found for which Eq. A.7 applies 

Eq. A.7 indicates that there exists a subset of data objects d d . . . d that covers all the k i groups pertaining to Requestor R.

The set of data objects that can be used to cover the Requestor R this set contains D i members is denoted by S i . However not all of the data objects in the set S i are necessary for the task because some groups can be covered by multiple data objects. Therefore the set that is necessary is identified as provided in Eq. A.8 tilde over S i S i of minimal size tilde over D i D i A.8 

The identifying proceeds by identifying members of S i that can be dropped i.e. groups k that they cover are covered by the remaining members in the set . If no data object can be dropped then a minimal set for the i th user is realized. However if several candidates are found then the one that covers the smallest number of groups in the set of groups u u . . . uis dropped i.e. the one that can be considered as being least relevant is dropped . Then the list of candidates for being dropped is re evaluated. It should be noted that the list could have been reduced by more than one after the chosen data object was dropped. Once again selection among the remaining candidates for the one that covers the smallest number of groups in the set of groups u u . . . uis undertaken. This process is repeated until the list of candidates becomes empty yielding the desired set tilde over S i of size tilde over D i .

It should be noted that in principle this problem can be solved by methods of combinatorial optimization. However solving the problem individually for every user is too resource demanding. Hence the heuristic algorithm provided herein is typically applied on a per user basis. In further embodiments one may select the set tilde over S i via a forward selection process starting by selecting the most relevant candidate among data objects in S i to be included in the set tilde over S i then selecting the next relevant member etc. This embodiment is however more complex. For example consider the requester Rthat requires single member groups 1 2 . . . 6 and suppose that the set S i consists of four data objects 1 2 3 1 4 2 5 and 3 6 . Then the selection is started by including the most relevant data object 1 2 3 and one would need all four data objects to cover this requester. On the other hand if the described backward elimination process is used then one may immediately establish that the data object 1 2 3 is the only one that can be dropped and obtain a set tilde over S i consisting of only 3 data objects 1 4 2 5 and 3 6 .

Now the optimization problem that finds the optimally grained set of service functions SF i.e. data objects becomes 

Accordingly this is an optimization problem over a range of 0 1 with linear constraints and a nonlinear objective function a special case of linearly constrained nonlinear integer optimization . Techniques for handling such problems are known in the art. In practice one starts with a given value of D and attempts to solve the problem described by Eq. A.8. If no feasible solution is found then the selected value of D is too small and it is increased. Eventually a value D Dis found that is high enough that the problem of Eq. A.8 yields a feasible and optimal solution. This is the smallest possible number of data objects that is capable of covering all the business functions while also covering all the groups . As noted above Dcorresponds to nas described above. By further increasing D the value of the objective function f y will further improve up to a certain point. Beyond this point further increase of D will not bring any improvements. This point is referred to as D. This value corresponds to n also described above. A typical solution for D includes a result somewhere in the interval between D D . The solution is dependent among other things on the desired granularity. Choosing a solution closer to Dwould decrease the number of service functions SF that the service provider needs to maintain but it might force the requesters to deal with a larger number of them potentially increasing their costs for example if they are being charged based on the number of service functions needed to cover them .

Of course one could consider more complex forms of optimization here for example those that take into account costs of maintaining various service functions and costs of their activation. The number of possibilities is very large but in general they will tend to lead to a mathematical programming formulation of a type similar to Eq. A.9 may include a more general objective function and possibly different or additional constraints.

Disclosed are a method and a system which for given business functions data grouping rules and constraints identifies a set of service related elements that include service functions services and choreographed services that are responsive to a set of metrics.

These teachings include a method and apparatus for optimizing the tradeoff between coarse grained and fine grained services using a mathematical technique for optimizing the aggregate utility to all service consumers for a given investment by the service provider. The techniques disclosed are illustrated for cases of providing data access services. However one skilled in the art will recognize that such embodiments are general and that the teachings can be applied to any collection of requirements that can be quantified in a similar manner.

Stated another way the teachings herein include data oriented techniques for composing an optimally grained set of service data objects that with logic added can be implemented as service functions that can be assembled into one or more choreographed services. One embodiment of this invention can implement the technique as a plug in for a modeling tool that will allow a designer to create a high level data organization that covers both the requesters and business functions they requested. The teachings also allow a designer to model data objects that could be realized as service functions. In other embodiments a designer is able to model new data objects that could be realized as new service functions while preserving the existing data objects and corresponding service functions. Further the teachings provide a development tool to simulate service functions. Some embodiments provide for analysis of the inventory of existing services in case of acquisitions and mergers with merged services by comparing the existing repositories of services with preliminary designed services using the tolerance data coefficient. In some other embodiments excessive data can be optionally encrypted for privacy and security.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode and other embodiments.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage device through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types o network adapters.

As described above embodiments can be embodied in the form of computer implemented processes and apparatuses for practicing those processes. In exemplary embodiments the invention is embodied in computer program code executed by one or more network elements. Embodiments include computer program code containing instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other computer readable storage medium wherein when the computer program code is loaded into and executed by a computer the computer becomes an apparatus for practicing the invention. Embodiments include computer program code for example whether stored in a storage medium loaded into and or executed by a computer or transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via electromagnetic radiation wherein when the computer program code is loaded into and executed by a computer the computer becomes an apparatus for practicing the invention. When implemented on a general purpose microprocessor the computer program code segments configure the microprocessor to create specific logic circuits.

While the invention has been described with reference to exemplary embodiments it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition many modifications may be made to adapt a particular situation or material to the teachings of the invention without departing from the essential scope thereof. Therefore it is intended that the invention not be limited to the particular embodiment disclosed as the best mode contemplated for carrying out this invention but that the invention will include all embodiments falling within the scope of the appended claims. Moreover the use of the terms first second etc. do not denote any order or importance but rather the terms first second etc. are used to distinguish one element from another. Furthermore the use of the terms a an etc. do not denote a limitation of quantity but rather denote the presence of at least one of the referenced item.

