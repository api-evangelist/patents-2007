---

title: Method and apparatus for authenticating a request between tasks in an operating system
abstract: One embodiment of the present invention provides a system that authenticates requests between tasks in an operating system. During operation, a first task prepares a request to perform an operation in a second task. In doing so, the first task attaches a credential to the request, and then a trusted entity transfers the request and the credential to the second task. Next, the second task determines whether the credential is valid. If the credential is valid, the second task determines from the credential whether the first task is authorized to request the operation, and, if so, proceeds to perform the operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08875300&OS=08875300&RS=08875300
owner: Google Inc.
number: 08875300
owner_city: Mountain View
owner_country: US
publication_date: 20070330
---
The present invention relates to techniques for controlling access to computational resources and data within computer systems. More specifically the present invention relates to a method and an apparatus for authenticating a request between tasks in an operating system.

In modern operating systems a program may be associated with one or more independent processes which may communicate with each other using inter process communication IPC mechanisms provided by the operating system. In multi user systems such inter process communication mechanisms can allow a process to provide services to processes associated with different users. In doing so the process may provide different data or different levels of service to different calling processes based on users associated with the calling processes. However a process providing such a service may not be able to simply trust an identity claimed by a calling process because doing so would risk leaking sensitive information to an unauthorized user. Although some techniques authenticate callers by exchanging digital certificates and or passwords via IPC these techniques add additional overhead and complexity to inter process interactions.

Hence what is needed is a method that facilitates authenticating a request between processes without the above described limitations.

One embodiment of the present invention provides a system that authenticates requests between tasks in an operating system. During operation a first task prepares a request to perform an operation in a second task. In doing so the first task attaches a credential to the request and then a trusted entity transfers the request and the credential to the second task. Next the second task determines whether the credential is valid. If the credential is valid the second task determines from the credential whether the first task is authorized to request the operation and if so proceeds to perform the operation.

In some embodiments the second task produces a set of results in response to the request and then modifies the set of results based on authentication information contained within or determined from the credential.

In some embodiments the system can limit the results which are returned by the operation based on authentication information determined using the credential.

In some embodiments the system provides a standardized service with extensible capabilities that limits responses to client requests based on a credential for the client presented to the service by the trusted entity.

In some embodiments the credential is a send right for a task port that is associated with the first task.

In some embodiments transferring the request and the credential to the second task involves sending a Mach message from the first task to the second task.

Table 1 illustrates a function interface for sending a task port to a task in accordance with an embodiment of the present invention.

Table 2 illustrates a function interface for receiving a task port to a task in accordance with an embodiment of the present invention.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the claims.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. This includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

Many operating systems support simultaneous execution of a number of programs such as web browsers databases email clients and other application programs using multiple processes. Some or all of these programs may need to interact with each other which creates a need for inter process communication IPC . Different operating systems support different flavors of IPC with varying implementations including CORBA the Common Object Request Broker Architecture Java RMI remote method invocation RPC remote procedure call and Cocoa Distributed Objects. Such IPC implementations typically involve an abstraction of one process invoking methods in another process. In an object based system the IPC implementation may allow an object in one process to communicate with objects in other processes as if they are local objects. IPC mechanisms often facilitate client server operations in which a server process vends an object or method that can then be accessed by one or more clients. Client processes typically first obtain a reference to the vended object or method and then send requests and or messages to remotely invoke desired operations.

For some applications or in a system with only a single user a given service may not care about the identity and or user associated with a calling process. For instance if all of the processes and data in the system belong to a single user and connections can only come from within that user s session no security violations are expected. However security can be a major concern for a service that needs to run as a root process in a multi user system for instance to gain higher privileges or to achieve an economy of scale in providing the service to multiple users of a multi user system. In this case the service may need to determine the identity associated with a calling process in order to limit and or execute a query properly. For instance the service may need to ensure that a calling process executed by a first user does not divulge restricted information belonging to another user.

Many techniques used for IPC do not include support for sending user authentication information to another process. For instance in systems where calling processes communicate with services using mechanisms such as shared memory semaphores pipes and or transmission control protocol TCP sockets additional program layers might be added on top of the IPC functionality to provide authentication e.g. using certificates or password prompts to authenticate the identity of each caller. Other techniques such as Unix domain sockets and Mac OS X security trailers allow a calling process to send credentials to another process. These techniques have a number of problems for example they are not very flexible typically do not integrate well with high level programming and are limited to select operating systems.

One of the IPC mechanisms in Mac OS X is the Cocoa Distributed Object DO system which provides a robust fast and object oriented way to send and receive messages between processes on the same machine as well as to other machines . DO is built on Mach messaging which allows objects to send messages to other objects using Mach ports. Objects in the system can be associated with one or more Mach ports to which other objects in the system can send requests. For instance every central processing unit CPU in the system may be associated with one or more Mach ports. Similarly every task in the system is typically assigned a Mach port which is called its task port. Objects can look up Mach and task ports in the system for instance by using the discovery mechanism provided by launchd the Mac OS X bootstrap server.

Note that while a task in Mac OS X may be associated with many Mach ports e.g. for communicating with a number of other entities each task is usually associated with exactly one task port. Objects can send messages and requests to given tasks using these task ports. For instance an object might suspend a task by calling a task suspend function with a corresponding task port as an argument.

Mach ports are typically associated with a number of rights including send rights and receive rights. For instance one task may have a send right to a given Mach port while another task has the receive right for the same Mach port. An object with a send right for a Mach port can send a message to the Mach port while an object with a receive right for the Mach port can receive messages sent to the Mach port. Objects can send Mach port rights to one another using Mach messages. Note that the operating system kernel maintains information on the Mach ports that each task can validly access and hence keeps track of such transfers.

In Mac OS X while many objects may hold send rights to a specific Mach port only one object may have a receive right for the Mach port. Also in Mac OS X the operating system kernel holds the receive rights for all task ports so that all messages involving task ports are first received and inspected by the kernel. The kernel can thereby serve as a trusted entity that can be used to authenticate task identity.

In one embodiment of the present invention a first task sends a task port to a second task when the first task requests the second task perform an operation. A trusted entity such as the kernel forwards the request and task port to the second task. The second task then determines from the received task port whether the first task is authorized to request the specified operation and if so performs the operation.

The desktop daemon shown in receives input from many other processes as indicated by the number of arrows pointing to the desktop daemon in . Moreover the desktop daemon may vend a number of listener objects to which these other processes can send requests and objects using Mach messages. Some or all of these listener objects may need to know the identity of the user who sent them a message in order to provide a correct response. For example when a user issues a query a DO message is sent to a QueryListener object in the desktop daemon which then needs to determine who sent the message in order to perform accurate permissions checks and ensure that data is not returned to a user who should not have access to that data. To provide authentication the application programming interface API for both the sending and receiving processes include as a parameter a task port identifier that can be used to identify the caller as shown in Tables 1 and 2 for a listener and client respectively . For instance every method on a vended DO object in the desktop daemon takes as an argument an NSMachPort object corresponding to the caller s task port or more specifically a send right to the caller s task port. When the desktop daemon receives a message it can use the Mach port provided by the authPort parameter to determine the caller s user ID. The kernel enforces security for creating accessing and sending task ports and can hence prevent task ports from being spoofed. Note that for non authenticated communication objects can simply send standard Mach messages using Mach ports and do not need to send task port information.

In essence the calling desktop agent sends to the desktop daemon a Mach port right that gives the desktop daemon permission to ask the kernel who the owner of the request is. Because the desktop agent can only send Mach ports that it has authorized access to and hence awareness of and because the kernel confirms that the sent Mach port right is indeed a task port and provides the user ID associated with that task port the identity of the calling process can be trusted to the extent that the kernel is trusted. If the caller attempts to send a send right to an invalid task port the kernel detects the violation and halts the transfer of the corresponding request. Note that if a caller does have authorized access to another task s task port it is safe for the caller to send that other task s task port to the desktop daemon . Because the caller cannot get the other task s task port without going through the proper authentication mechanisms the fact that the caller has authorized access to the other task s task port indicates that the caller has a valid right to access services and data on the behalf of the other task.

Note that the task port in this situation is used mainly for authentication and not communication. A desktop agent that is expecting a response for the request may send along with the request a send right for another Mach port not a task port with which the desktop daemon can send replies to the desktop agent .

Note also that Mach port rights can be sent from one task to another using Mach messages in the same way that DO messages are sent using high level DO methods. Unlike some other available authentication techniques these high level methods do not require access to raw Mach ports. For instance security trailers add identity information to an extra structure at the end of Mach messages. This structure is checked and guaranteed by the kernel which requires access to raw Mach ports. Note that this type of access is not available at the programming level provided by DO. Hence security trailers do not provide the same level of abstraction that is provided by the techniques described in the present invention.

In summary to ensure a caller s identity the system allows a Mach task port identifier to be sent as a parameter in an IPC call. The kernel ensures that the task port information is valid and allows the receiving process to use the task port information to retrieve the true identity of the calling task. Hence the receiver can verify the exact identity of the caller and the caller is unable to claim to be another user and cause a security leak.

The foregoing descriptions of embodiments of the present invention have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

