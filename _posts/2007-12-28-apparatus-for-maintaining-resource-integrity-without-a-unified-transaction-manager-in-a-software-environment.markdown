---

title: Apparatus for maintaining resource integrity without a unified transaction manager in a software environment
abstract: An apparatus and method for maintaining integrity of data in a software environment are provided. With the apparatus and method, the individual software resources associated with a transaction are identified and the processing of these resources is started. As the processing of these resources terminates, their associated APIs return messages indicating either that the software resource committed or was unable to commit and the reason why the software resource was unable to commit. Based on this reason, appropriate error resolution and recovery operations are performed and the transaction is resubmitted only to those software resources that were unable to commit. The software resources that already committed have their states maintained. In this way, roll back of committed software resources is avoided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07448035&OS=07448035&RS=07448035
owner: International Business Machines Corporation
number: 07448035
owner_city: Armonk
owner_country: US
publication_date: 20071228
---
This application is a continuation of application Ser. No. 10 457 843 filed on Jun. 10 2003 now U.S. Pat. No. 7 346 905.

The present invention is generally directed to an improved computing system. More specifically the present invention is directed to a resource integrity engine that maintains the integrity of data in the computing system when handling transactions involving multiple software resources.

With the exception of very trivial applications it is common for application programs executing in today s software environments to interact with multiple software resources in order to accomplish a specified task. Many times these software resources are basically independent of each other but together need to act as an atomic unit i.e. an unbreakable whole during the execution of the application program. This unit of execution having multiple resources acting in concert as an atomic unit is referred to as a transaction.

For example a single task may require a database software resource to perform an update of a record in the database and require a messaging software resource to send a message to another software resource indicating completion of the update. The transaction would be comprised of the updating of the database record and the sending of the message. Both of these operations must be performed in order for the transaction to complete successfully.

Certain software operating systems provide a mechanism for executing collaboration between the individual resources. This mechanism is often referred to as a transaction manager. Such a mechanism creates a single context that acts as the single atomic unit for each transactional operation that is distributed among the individual resources. One well known technique for managing transactions in a transaction manager of this type is to use a two phase commit process.

The two phase commit process involves a prepare phase and a commit phase. During the prepare phase the transaction manager informs all of the participants of the intended transaction and requests that they acknowledge that they are prepared to either commit or rollback the pending transaction. During the commit phase all of the participants in the transaction are asked to commit the transaction i.e. complete their portion of the transaction. If a participant is unable to commit the transaction or does not respond during the prepare phase then the transaction fails and any changes are rolled back. The rollback of changes made by a transaction that has not been completed by all of the participants is intended to maintain integrity of the data in the system. That is a synchronization of the states of the software resources involved in the transaction must be maintained.

The transaction manager provides this functionality transparent to the application program. While this is a perfectly acceptable approach when the managed software resources are supported by the computing system software not all different software resource types are necessarily supported by every transaction manager. Furthermore not all software environments include a transaction manager that may be used to manage transactions through for example a two phase commit process.

Thus it would be beneficial to have an apparatus and method for maintaining the integrity of data in a computing system where a transaction manager is not present or where certain software resources are not supported by the transaction manager that may be present in the computing system.

The present invention provides an apparatus and method for maintaining resource integrity in a software environment without a transaction manager. With the apparatus and method of the present invention a resource integrity engine is provided for interfacing with an application program and a plurality of software resource application program interfaces APIs . The resource integrity engine receives a transaction from the application program that identifies a plurality of software resources that are involved in the transaction. The resource integrity engine identifies the appropriate API which is registered with the operating system for the software resources identified in the transaction and sends a request to the software resources via the APIs to ask that they respond with an acknowledgement that they are ready to receive the transaction.

Upon receiving an acknowledgement from the software resources the resource integrity engine transmits the transaction to the software resources e.g. database communication channel queue messaging software or the like causing them to perform the requisite functionality indicated in the transaction i.e. commit or fail to commit. A software resource may fail to commit for many different reasons including for example communication connections failing database connections that become stale a resource manager failing a queue being full timeout conditions being met a maximum number of possible connections being reached a hardware failure such as a disk drive system memory exhausted or the like.

With the present invention a recognition engine of the resource integrity engine receives messages back from the APIs associated with the software resources indicating whether the respective software resources were successfully committed or that the commit failed. The recognition engine employs logic to determine if all of the software resources were successfully committed if none of the software resources were successfully committed or if there was a partial commit of the transaction.

If all of the software resources identified as being part of the transaction are successfully committed i.e. the transaction functions associated with the software resource are performed successfully then the transaction completes without an error. If however one or more of the software resources associated with the transaction fails to commit then the recognition engine determines if and how to resubmit the remainder of the transaction associated with the software resources that failed to commit. This is contrary to the known two phase commit operations which rollback changes when even one resource fails to commit.

In the case where none of the software resources associated with the transaction successfully committed the transaction may be resubmitted as a whole to the software resources since the previous submission did not result in a change of state for any of the software resources. However without error recovery the resubmission of the portions of the transaction that failed may not result in a successful commit of the software resources. Therefore the recognition engine analyzes the response messages received from the APIs to determine the reason why the software resources were unable to commit in the previous submission of the transaction. Based on the determined reason the recognition engine invokes either appropriate error recovery or other appropriate continuation logic in order to increase the likelihood that a resubmission of the transaction will result in a successful commit of all of the software resources.

In the case of a partial commit of the software resources associated with the transaction the recognition engine employs logic for maintaining the data integrity of software resources that have already committed while resubmitting the portions of the transaction that failed to the software resources that did not commit. In this case the recognition engine identifies which software resources have been committed and which ones have not. Only those software resources that were not successfully committed are resubmitted as part of the transactional process in order to avoid duplication of data that could cause an error condition within the transaction.

The logic for resubmission is similar to that discussed above with regard to the case where none of the software resources committed. That is the messages returned by the APIs of the software resources are analyzed by the recognition engine to determine if the software resources successfully committed or if there was an error encountered by one or more of the software resources. In one embodiment information that is inherent to the transaction is used to determine whether a resource has been committed or not. For instance a transaction could have a unique identification number. If this unique identifier is found within the resource then the recognition engine can conclude that the resource was committed. In this way the software program is able to keep the state of each software resource without explicitly tracking the integrity of the data. Note that in order for the recognition engine to query a resource the resource entity must be retrievable via the resource s API or other register mechanisms.

The recognition engine of the resource integrity engine may then apply one or more recovery and resubmission rules to the non committed entries in the data structure. These rules may include correlating the error code to a proper procedure for resubmitting the transaction to an associated software resource. The rules may look at the error codes returned and the context in which the error code was returned. For example if the error code indicates that a communication connection with an outbound queue has failed then the resubmission procedure identified through the rules may be to wait a predetermined period and then resubmit the transaction to the outbound queue.

Software resources which committed successfully do not have their changes rolled back. A feature of the invention is the fact that the present invention does not rollback committed resources. It detects that situation and resubmits the uncommitted resource immediately upon detection. Eventually if resubmission ultimately fails then the entire transaction is sent to an Error Handler for Problem Determination and Correction. So while the invention does not enact rollbacks an explicit indication is provided to indicate the transaction is not completed. The rationale is for most cases resubmission will succeed. In the rare case that resubmission does not succeed the resource at risk is identified and sent to the Error Handling Mechanism. That mechanism may in fact do any number of things including a rollback.

Thus with the present invention a mechanism is provided for handling transactions in a software environment that does not have a transaction manager. Moreover the present invention provides a mechanism in which portions of a transaction may be resubmitted to the operating system of those software resources that were unable to commit in order to complete the transaction and avoid rolling back the changes made to committed software resources. These and other features and advantages of the present invention will be described in or will become apparent to those of ordinary skill in the art in view of the following detailed description of the preferred embodiments.

The present invention provides a mechanism for managing transactions in a software environment that does not include a transaction manager. Moreover the present invention provides a mechanism for resubmitting a transaction to software resources associated with the transaction that were unable to commit in a previous submission of the transaction. The mechanisms of the present invention may be implemented in a stand alone computing device or a distributed data processing environment without departing from the spirit and scope of the present invention. In a preferred embodiment the present invention is implemented in a server computing device of a distributed data processing system. Therefore the are provided hereafter in order to give a context for the discussion of the features and advantages of the present invention.

With reference now to the figures depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented. Network data processing system is a network of computers in which the present invention may be implemented. Network data processing system contains a network which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example server is connected to network along with storage unit . In addition clients and are connected to network . These clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients . Clients and are clients to server . Network data processing system may include additional servers clients and other devices not shown. In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial government educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the present invention.

Referring to a block diagram of a data processing system that may be implemented as a server such as server in is depicted in accordance with a preferred embodiment of the present invention. Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors and connected to system bus . Alternatively a single processor system may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . I O bus bridge is connected to system bus and provides an interface to I O bus . Memory controller cache and I O bus bridge may be integrated as depicted.

Peripheral component interconnect PCI bus bridge connected to I O bus provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add in connectors. Communications links to clients in may be provided through modem and network adapter connected to PCI local bus through add in boards.

Additional PCI bus bridges and provide interfaces for additional PCI local buses and from which additional modems or network adapters may be supported. In this manner data processing system allows connections to multiple network computers. A memory mapped graphics adapter and hard disk may also be connected to I O bus as depicted either directly or indirectly.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. For example other peripheral devices such as optical disk drives and the like also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.

The data processing system depicted in may be for example an IBM eServer pSeries system a product of International Business Machines Corporation in Armonk N.Y. running the Advanced Interactive Executive AIX operating system or LINUX operating system.

With reference now to a block diagram illustrating a data processing system is depicted in which the present invention may be implemented. Data processing system is an example of a client computer or a stand alone computing device. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Accelerated Graphics Port AGP and Industry Standard Architecture ISA may be used. Processor and main memory are connected to PCI local bus through PCI bridge . PCI bridge also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus may be made through direct component interconnection or through add in boards. In the depicted example local area network LAN adapter SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . Small computer system interface SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add in connectors.

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as Windows XP which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provide calls to the operating system from Java programs or applications executing on data processing system . Java is a trademark of Sun Microsystems Inc. Instructions for the operating system the object oriented operating system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash read only memory ROM equivalent nonvolatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

As another example data processing system may be a stand alone system configured to be bootable without relying on some type of network communication interfaces As a further example data processing system may be a personal digital assistant PDA device which is configured with ROM and or flash ROM in order to provide non volatile memory for storing operating system files and or user generated data.

The depicted example in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system also may be a kiosk or a Web appliance.

As previously mentioned the present invention provides an apparatus and method for maintaining resource integrity in a software environment without a transaction manager. The present invention provides a resource integrity engine that ensures the integrity of the data of the computing system while providing for the resubmission of a transaction to software resources in partially committed transactions.

With reference now to a resource integrity engine is provided for interfacing with an application program and a plurality of software resource application program interfaces APIs associated with a plurality of software resources . The application program resource integrity engine APIs and software resource may be resident on the same or different computing devices. For example the application program may be resident on a client computing device while the resource integrity engine APIs and software resources are resident on a server computing device.

The application program submits a transaction for processing to the resource integrity engine that identifies a plurality of software resources involved in the transaction. The resource integrity engine identifies the software resources that are part of the transaction and their respective APIs . The resource integrity engine then submits the transaction to the identified software resources via their APIs . These APIs provide indications as to whether their corresponding software resources successfully or unsuccessfully performed their part of a transaction.

For example the transaction may take the form of placing a database update message on an inbound queue applying business rules to the update message to thereby update a database and then setting an update complete message on an outbound queue. From this transaction it is clear that two resources are being used the messaging middleware resource and the database software resource. APIs for these two resources are presumed to have been registered with the operating system and can be invoked by the resource integrity engine via the operating system in a known manner such that the success error codes returned by the APIs may be checked by the resource integrity engine .

The primary function of the resource integrity engine is to maintain integrity of the data managed by the software resources . In order to maintain integrity the resource integrity engine is required to keep the software resources synchronized among each other. This means that the individual software resources are kept current relative to the transaction being executed. If at least one of the software resources is not committed a condition exists where the software resources are not synchronized with any other software resource taking part in the transaction.

In order to process transactions such that the transaction operates as an atomic unit with regard to the software resources and maintain the integrity of the data managed by the software resources such that the software resources are synchronized the present invention performs the following five functions 

 5 error recovery and resubmission of the transaction to software resources that did not commit based on the recognized reasons for the software resource having not committed.

As previously mentioned the resource integrity engine receives a transaction that identifies the software resources that are involved in the transaction. From this information in the transaction the resource integrity engine may identify associated APIs through their registration with the operating system of the computing device in which the present invention is operating. Moreover the APIs provide an interface through which the resource integrity engine is informed of either the successful or unsuccessful completion of its thread of execution of the transaction by the associated software resources i.e. whether the software resource committed the transaction or not. Thus the interaction with the APIs of the software resources provide the ability for the resource integrity engine to perform functions 1 and 2 above i.e. the identification of independent software resources and the ability to verify the successful commit of software resources.

The resource integrity engine upon receiving a transaction from an application program identifies the appropriate APIs of the software resources that are part of the transaction. The resource integrity engine also initializes a data structure for maintaining context state information about the transaction. The resource integrity engine then sends the transaction to the identified software resources via their respective APIs . The resource integrity engine then awaits a response from the APIs indicating either a successful commit of the software resource or an error condition with regard to the software resource. The successful commit or the error condition is then recorded in the data structure associated with the transaction.

Transactions may be performed in many different ways depending on the particular implementation of the computing system. For example in one particular implementation processing may be based on a set of software instructions that entail a sequential flow of execution such that when an individual software resource is successfully committed processing flows to the next independent software resources that is to partake in the transaction. In another exemplary implementation event notification logic may be utilized. For example when an individual software resource commits the program committing the resource would notify the resource integrity engine that the action had completed successfully. Part of the information supplied is the status indication of success or failure of the resource.

The preferred embodiments of the present invention are being described in terms of the event notification implementation described above. However it should be appreciated that the sequential processing flow may be used as well. In such a case the context state data structure maintained by the resource integrity engine may include information about the serialization of the software resources and whether they returned a successful commit or not. If a software resource returns an error condition any software resource appearing in the serialization after the software resource that returned an error will not have an entry for their current state since they require the successful commit of the software resource that returned the error.

In either case the resource integrity engine may look at the state information in the context state data structure for the transaction to determine if all of the software resources of the transaction committed the transaction function 3 above . The resource integrity engine employs a recognition engine to discriminate between the possible cases that result from the transaction being submitted to the software resources function 4 above . If any of the software resources listed in the context state data structure returned an error condition then the transaction did not complete successfully and a recovery and resubmission of the transaction is in order. If all of the software resources listed in the context state data structure returned a successful commit then the transaction completed successfully and normal processing of a successful transaction is performed. By normal processing what is meant is that the transaction produced the desired action such as successfully recording patient information in a database and transmitting that information to another system a banking deposit was recorded properly an airline reservation was successfully booked etc. and processing specific to the implementation is then carried out.

For example assumed that a patient message is received which contains information that gets written into a database record. This information includes a unique ID contained in the message. Additionally once the database is updated the message content is also delivered to another messaging system. If a problem occurs between the database update and the sending of the message onto the next system data may be out of sync. If the message added a patient in the first system and the first system now gets an update for that patient it can appropriately update the record. However if the update is sent to the next messaging system it would fail since the initial record was never received.

Without the present invention when the initial message was requeued for processing on the first system since it was never committed by the messaging system but was only committed on the database system an error was returned indicating duplication of a record in the database. That would terminate processing of that transaction in known systems.

With the present invention the recognition engine determines that the identifier in the database matches the identifier in the message and allows subsequent processing to take place namely sending the message onto the next system.

In the case where no software resources were successfully committed then the entire set of collaborative operations in the transaction can essentially be repeated. In a practical sense this implies that the initial software resource failed and processing of the subsequent software resources should be abandoned. However unless an error resolution and recovery operation is applied there is no guarantee that repeating the operations will result in a successful commit of the software resources. The particular error resolution and recovery operations performed is based on the type of error encountered by the software resource when trying to commit the transaction.

For example the recognition engine of the resource integrity engine may apply recognition rules against the error indicators returned by the APIs associated with the software resources and stored in the context state data structure to determine the type of error resolution and recovery operations to be performed prior to resubmission of the transaction. Such error resolution and recovery operations may involve the initiating of another software operation to actively resolve the error and recover the software resource or may be a passive resolution and recovery such as waiting a predetermined period of time prior to resubmitting the transaction to the software resource. Once the appropriate error resolution and recovery operations are performed the resource integrity engine may resubmit the transaction to the software resources via their APIs function 5 above .

In the case where some software resources committed but others did not the resource integrity engine ensures overall data integrity while being able to resubmit the transaction to only those software resources that did not commit. In this way duplication of data that may lead to an actual error condition within the transaction causing the transaction to not be able to be completed at all is avoided.

In the partial commit case the recognition engine of the resource integrity engine determines for each software resource in the context state data structure of the transaction whether the software resource is already committed if the software resource has an associated error condition noted or if the software resource is essentially being processed for the first time. If the software resource is already committed the changes made to the data by the software resource are not rolled back. Instead the current state of the data changes made by the software resource are maintained.

If the software resource has an associated error condition appropriate error resolution and recovery operations are performed based on the identification of the error and the transaction is resubmitted to only those software resources with error conditions. Once all of the software resources indicate that they have committed the transaction then normal processing is performed to complete the transaction in the system. If some of the software resources continue to return error conditions the error resolution and resubmission logic of the present invention may be continued either until all software resources commit or until a predetermined number of resubmissions is made. If after the predetermined number of resubmissions is made there is still one or more software resources that have not committed it may be determined that the transaction cannot be completed successfully and the changes made by the other software resources may be rolled back.

Thus the present invention provides a mechanism for managing transactions in a software environment where there is no transaction manager present. Furthermore the present invention provides a mechanism for monitoring the software resources associated with a transaction such that software resources that do not commit may have the transaction resubmitted after appropriate error resolution and recovery operations are performed. With the present invention only software resources that did not commit will have the transaction resubmitted those that did commit will not have their state changed.

As shown in the resource integrity engine includes a controller an interface one or more API interfaces a recognition engine a transaction state data structure storage and an error resolution and recovery resubmission rules database hereafter referred to as the rules database . The elements are in communication with one another via the control data signal bus . Although a bus architecture is shown in the present invention is not limited to such and any architecture that facilitates the communication of control information and data between the elements may be used without departing from the spirit and scope of the present invention.

The controller controls the overall operation of the resource integrity engine and orchestrates the operation of the other elements . The interface provides a communication pathway to one or more application programs. The API interfaces provides a communication pathway with the APIs of software resources with which the resource integrity engine operates. The controller receives transactions via the interface and sends transaction messages to the software resources via their APIs via the API interfaces . The APIs in turn return messages indicating either the successful commit of the software resource or an error condition. The state of these software resources returned by the APIs is stored by the controller in a transaction state data structure in the transaction state data structure storage .

The recognition engine performs the functions described above with regard to discriminating between cases where all of the software resources committed none of the software resources committed and a partial commit of the software resources involved in the transaction. The recognition engine further identifies which software resources committed and which did not based on the transaction state data stored in the transaction state data structure storage . The recognition engine may then apply rules from the rules database to determine proper error resolution and recovery operations to be performed on the software resources as well as how and when to resubmit the transaction to the software resources.

With the mechanism shown in transactions may be submitted to software resources in a software environment where a transaction manager is not present. Moreover with the mechanism of the transaction may be resubmitted to software resources that did not commit while maintaining the state of software resources that did commit. Thus the present invention avoids having to roll back changes made by software resources that did commit so that the entire transaction may be resent.

As a result of the above failure the API for the database resource returns a message that the database resource is committed but the API for the message resource indicates that the message resource is not committed and the error condition indicating why the message resource did not commit. Based on this error condition the recognition engine of the present invention would apply appropriate error resolution and recovery operations before resubmitting the transaction to the message resource. The transaction would not be resubmitted to the database resource.

In resubmitting the transaction to the message resource the message resource may attempt to place another of the same update message on the inbound queue . An error may then result because of the same message being placed on the inbound queue . In a known system this would result in an error condition that would result in a roll back of the changes made by the software resources based on the transaction.

However the present invention applying rules from the rules database may determine that the database is committed and thus the duplicate message on the inbound queue is not an unrecoverable error and may skip the placing of the duplicate message on the inbound queue the updating of the database and may proceed to the placing of the update completion message on the outbound queue . After the update completion message is placed on the outbound queue the message resource API returns a message to the resource integrity engine indicating that the message resource has committed and thus all of the software resources have committed.

Although not explicitly shown in and addition step of determining if a predetermined number of resubmission or restarts of a resource has been made may be included. In such a case if the predetermined number of resubmissions has been made a critical error may be identified and the committed resources may be rolled back. Otherwise the resubmission may continue until the predetermined number of resubmissions has been made or all of the resources are committed.

Thus with the present invention a mechanism is provided for handling transactions in a software environment that does not have a transaction manager. Moreover the present invention provides a mechanism in which portions of a transaction may be resubmitted to software resources that were unable to commit in order to complete the transaction and avoid rolling back the changes made to committed software resources.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

