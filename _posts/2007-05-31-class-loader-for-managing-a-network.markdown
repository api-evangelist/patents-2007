---

title: Class loader for managing a network
abstract: Methods, apparatuses, and systems for managing a network with a non-system class loader via remote method invocation are described. A method includes transferring the Java remote method invocation (RMI) call to a network element in order to obtain a version of the management software associated with the network element. The method further includes determining if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non-system namespace. The method further includes obtaining a byte code associated with the requested class from a class hash with a class name key if the requested class belongs to the non-system namespace. The method further includes loading the requested class and associated byte code to a Java virtual machine with a non-system class loader if the requested class belongs to the non-system namespace.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010973&OS=08010973&RS=08010973
owner: Calix, Inc.
number: 08010973
owner_city: Petaluma
owner_country: US
publication_date: 20070531
---
Embodiments of the invention relate to the field of network management. More particularly embodiments of the invention are directed to remote method invocation for management of the network with a class loader.

A network having numerous network elements can provide voice data and video communications across a pure packet network. Typically the packets conform to a single protocol of a single layer of the International Organization for Standardization s Open System Interconnection OSI Model. The single protocol may be the internet protocol IP . The network elements can be broadband loop carriers that include switching routing aggregation and plain old telephone service POTS functionality. High speed Internet VoIP IP video and gaming are some of the increasing number of applications that rely on an IP service delivery model. Advanced layer specific service management fault isolation and pro active diagnostic tools are some of the features that are required for day to day network operations.

In order for a system to perform successfully in a user environment it is necessary that the user be able to configure the system to operate as desired and to be able to observe the network elements for troubleshooting monitoring and management purposes. Management can be effected through a variety of user interfaces. The most common is Command Line Interface CLI where configuration and display commands are entered in text mode and promptly executed. Another common interface is Simple Network Management Protocol SNMP where configuration and monitoring data is transmitted over the network.

A Java based model provides a much broader and more abstract framework in a Java platform. A Java Virtual Machine JVM interprets and executes Java byte code that has been generated by a compiler. In Java a class represents a set of instructions. A primordial class loader loads a class into the JVM whenever the class has been referenced. The primordial class loader locates the class to be loaded by locating the appropriate class path. The class is read from a jar file a collection of classes or from a local file system referenced in the class path.

A Java remote method invocation RMI client server model can be the underlying architecture for a management application. An external entity in order to manage the network elements in the network communicates with exposed RMI application programming interfaces APIs . An API is a source code interface that a computer system or program library provides in order to support requests for services from a software application. An API is specified in terms of a programming language that can be interpretative or compiled when an application is built rather than an explicit low level description of how data is laid out in memory. A Java RMI API is a mechanism to invoke a method or function call on an object that exists in another address space. The other address space can be on the same machine or a different machine. The invoking entity is called a client while the invoked entity is called a server. A managing entity that manages a network of network elements should have remote interfaces and data classes of a management RMI API available in an application path of the managing entity. The interfaces and data classes of the management RMI API are usually made available in a jar file. The interfaces and data classes in the jar file may vary across different versions of the management software. The managing entity needs to have multiple versions of jar files to manage network elements that have different versions of the management software.

The fact that the remote interfaces and the data classes belong to the same namespace e.g. a directory in an operating system and can be different across various software versions presents a great challenge for the managing entity. A class loader may load a class with the correct namespace but corresponding to the wrong software version being run by a network element. Also the different versions of the management software may require different parameters in order to manage the network element associated with a particular version of the management software. For example sending a management call appropriate for software version A to a network element running software version B may result in an exception condition causing a crash or other error.

In an environment with management software interacting with network elements via a remote method invocation RMI call a method is described that includes transferring the remote method invocation RMI call to a network element in order to obtain a version of the management software associated with the network element. The method further includes determining if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non system namespace. The method further includes obtaining a byte code associated with the requested class from a class hash with a class name key if the requested class belongs to the non system namespace. The method further includes loading the requested class and associated byte code to a Java virtual machine JVM with the non system class loader if the requested class belongs to the non system namespace. The non system class loader loads classes having a common namespace and associated with different versions of the management software. For one embodiment the non system class loader dynamically learns and loads a plurality of generic Java applications having a common namespace.

Other features and advantages of embodiments of the invention will be apparent from the accompanying drawings and from the detailed description that follows below.

A method for using management software to manage a network is described. In an environment with management software interacting with network elements via a remote method invocation RMI call the method includes transferring the remote method invocation RMI call to a network element in order to obtain a version of the management software associated with the network element. The method further includes determining if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non system namespace. The method further includes obtaining a byte code associated with the requested class from a class hash with a class name key if the requested class belongs to the non system namespace. The method further includes loading the requested class and associated byte code to a Java virtual machine JVM with a non system class loader if the requested class belongs to the non system namespace.

An intended advantage of the non system or custom class loader is the ability to manage network elements running disparate versions of management software. For one embodiment the non system class loader dynamically learns and loads a plurality of generic Java applications having a common namespace.

The Java APIs provides various APIs such as windowing networking file input output and programming utilities for managing the client and servers and . The servers and may form a network of servers. The Java APIs include a remote method invocation RMI API for performing the object equivalent of remote procedure calls between the client and various servers and . RMI allows applications to call object methods located remotely sharing resources and processing load across a network. RMI allows both a client and a server to dynamically load new object types as required.

The JVM interprets and executes Java byte code which comprises a form of instructions. Programs to be executed on the JVM are typically compiled into a standardized portable byte code format which generally is in the form of class files. For easier distribution of large programs multiple class files may be packaged together in a jar file. The JVM uses a class loader to load a class into the JVM that may be operating in memory . For one embodiment the Java class loader or system class loader is a primordial class loader. Whenever a class is referenced the primordial class loader locates the application or system class path. The class or classes to be loaded are then read from a jar file or a local file system given by the application class path.

For certain embodiments the system is a Java RMI client server model that forms the underlying architecture for a software application such as management software . Any external entity not shown uses the exposed RMI APIs in the client in order to manage a network of servers and . For one embodiment an external entity is a remote computing system that connects to the client via a network such as a wide area network or local area network. Each server and may have a different version of the management software as represented by libraries and respectively. A library is a collection of subprograms used to develop software. Many operating systems provide libraries that implement the majority of system services. The operating system of the management software may have numerous versions located in the various libraries and . RMI calls from the client to a server include parameters that may vary between different versions of the management software . The RMI calls need to have the appropriate parameters for the version of management software associated with a server being called by the client . Otherwise an error fault or exception condition may occur.

For one embodiment an external or managing entity starts a client application with a Java applet by accessing the management software via a wide area network or local area network such as the internet or Ethernet respectively. The managing entity receives a view of the network of servers and via the Java applet. The managing entity can then configure and manage the network of servers or other network elements. The managing entity has access to remote interfaces and data classes of the RMI API stored in jar files in order to manage the network of servers or other network elements. The remote interfaces and data classes may vary across different versions of the management software and belong to the same namespace because a particular function call has the same name for all servers within the network of the servers and .

For certain embodiments a non system class loader or custom class loader library allows a software application to over ride the default system class loader and control the class loading. The non system class loader enables a single entity the system to manage the servers and or any collection of network elements running disparate software versions in a network such as a telecommunications network. The network elements may be broadband loop carriers that provide voice and data communications via the network.

In contrast a prior art approach for managing a network would require a separate system for each software version or would use the system class loader which would load the first library or found in an application class path. The library loaded may not correspond to the library being run by a particular server or leading to an exception error or fault condition.

The processing unit may execute the management software in order to manage the servers and . For example execution of the management software transfers a Java remote method invocation RMI call to server in order to obtain a version of the management software associated with the server . Then execution of the management software occurs in order to determine if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non system namespace. The non system class loader loads classes having a common namespace and associated with different versions of the management software . The management software manages the network of network elements that form at least two sets of network elements with each set running a disparate software version of the management software.

At runtime a Java application can install class loader objects that load classes in custom ways such as by downloading class files across a network. Class loader objects are written in Java compiled into class files loaded into the JVM and instantiated just like any other object. The non system class loader dynamically extends a Java application at runtime. At runtime the management software can determine what extra classes are needed based on RMI calls and load the classes through one or more class loader objects.

The non system class loader loads a particular library associated with a particular software version via the JVM into memory at runtime in response to a RMI call retrieving the particular software version being run on a particular network element that is being managed configured or monitored. Each library may correspond to a different version of an operating system OS such as an OS of the management software . Various network elements within a network being managed by the management software may have different versions of the OS of the management software . The management software manages the network of network elements that form at least two sets of network elements with each set running a disparate software version of the management software.

The non system class loader via the JVM enables multiple classes belonging to the same namespace to be resident in memory simultaneously. The non system class loader is customized to create a co resident application having its own namespace. A co resident application is defined as an application within an application with a common namespace.

The JVM uses a class loader to load a class or classes into memory . For one embodiment the Java class loader or system class loader is a primordial class loader that is part of the JVM implementation. Whenever a class is referenced the primordial class loader locates the application class path. The class or classes to be loaded are then read from a jar file or a local file system given the application class path. The class is converted into byte code and loaded into the JVM for execution by an execution engine of the JVM . The JVM interprets a stream of byte codes as a sequence of instructions and then executes the sequence of instructions to produce a desired output.

Execution of the management software may transfer a Java remote method invocation RMI call to a network element in order to obtain a version of the management software associated with the network element not shown . Then execution of the management software occurs in order to determine if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non system namespace. The requested class and an associated byte code are loaded into the JVM with the non system class loader if the requested class belongs to the non system namespace. The JVM can then interpret and or execute the byte code for instantiation into the memory .

The non system class loader loads classes having a common namespace such as namespace A and associated with different versions of the management software . For example the non system class loader may load the library via the JVM into memory if the library contains the class or classes associated with the version of the management software running on a particular network element that has been issued a RMI call. The library contains interface descriptions parameters attributes methods and other information associated with the particular network element needed for communicating with the network element.

The non system class loader loads classes having a common namespace that are associated with different versions of the management software. The requested class or classes may represent a library containing interface descriptions parameters attributes methods and other information associated with the particular network element needed for communicating with the network element. For one embodiment the non system class loader dynamically at Java runtime execution learns and loads a plurality of generic Java applications having a common namespace.

The method further includes sending the requested class to a Java system class loader if the requested class belongs to the Java system namespace at block . The Java system class loader loads the requested class into the JVM at block . The JVM interprets a stream of byte codes as a sequence of instructions and then executes the sequence of instructions to produce a desired output.

The method includes receiving a user input to discover network elements within the network at block . The method further includes initiating a first discovery call to a mediation agent to locate or discover network elements within the network at block . The method further includes transferring a Java remote method invocation RMI call to a network element in order to obtain a version of the management software associated with the network element at block . Transferring the Java RMI call is either one of issuing initiating or receiving the Java RMI call. For one embodiment the mediation agent or other agent of the management software issues the RMI call to the network element. The method further includes determining if a non system class loader associated with the version of the management software obtained from the network element is located in a cache at block . The method further includes obtaining the non system class loader if the non system class loader is located in the cache at block . In certain embodiments the mediation agent determines if the non system class loader is located in the cache at block .

The method further includes obtaining a jar file location from a configuration file. The jar file is associated with the version of the management software obtained from the network element if the non system class loader is not located in the cache at block . The method further includes reading class file entries in the jar file converting each class file into a byte array and adding the byte arrays into a hash table keyed by the class name at block . illustrates a hash table keyed by class name in accordance with an embodiment of the invention. The class name column is the key or index for locating the appropriate byte code forming the byte arrays. For example class name 1 is associated with byte code 1. The hash table may be located in the cache or at a different memory location.

The method further includes adding the class loader to a class loader hash table that is keyed by version of the management software associated with the class loader at block . illustrates a hash table keyed by version of the management software associated with the class loader in accordance with an embodiment of the invention. The version column is the key or index for locating the appropriate class loader . For example version 1 is associated with class loader 1. The hash table may be located in the cache or at a different memory location.

The method further includes determining if a requested class to be loaded by a class loader based on the RMI call belongs to a system namespace or a non system namespace at block . The method further includes obtaining a byte code associated with the requested class from a class hash with a class name key if the requested class belongs to the non system namespace at block . The method further includes loading the requested class and associated byte code to a Java Virtual Machine JVM with a non system class loader if the requested class belongs to the non system namespace at block . The JVM processes the class and associated byte code with an execution engine. The JVM interprets a stream of byte codes as a sequence of instructions and then executes the sequence of instructions to produce a desired output. The non system class loader loads classes having a common namespace and associated with different versions of the management software. For one embodiment the non system class loader dynamically learns and loads a plurality of generic Java applications having a common namespace.

The method further includes sending the requested class to a Java system class loader if the requested class belongs to the Java system namespace at block . The Java system class loader locates the requested class from a system class path application class path or from local disk and loads the requested class into memory at block . The method further includes transferring subsequent discovery calls to the mediation agent in order to obtain information associated with one or more of the network elements such as detailed device information at block . The detailed device information may include the type of interfaces available the number of interfaces the current interface status and the diagnostic information associated with the interfaces.

Embodiments of the present invention provide software solutions for managing network elements running disparate software versions in a network such as a telecommunications network. The software solutions are simple and easy to integrate with prior software solutions. Additional management support or functionality for a future software version can be easily obtained by modifying a configuration file which essentially eliminates the need for any new development cycle.

From the above description and drawings it will be understood by those of ordinary skill in the art that the particular embodiments shown and described are for purposes of illustration only and are not intended to limit the scope of the invention. Those of ordinary skill in the art will recognize that embodiments of the invention may be embodied in other specific forms without departing from its spirit or essential characteristics. References to details of particular embodiments are not intended to limit the scope of the claims.

